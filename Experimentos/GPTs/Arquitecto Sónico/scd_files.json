{
    "Ch15code.scd": "\n//Figure 1: Immediate machine listening example using Pitch and Amplitude UGens. The original detected pitch appears in your left ear and an octave up in the right.\n(\nx={\n\tvar in, amp, freq, hasFreq, out;\n\tin = SoundIn.ar(0);;\n\tamp = Amplitude.ar(in);\n\t# freq, hasFreq = Pitch.kr(in);\n\tLFTri.ar(freq*[1,2]) * amp;\n}.play\n)\n\nx.free;\n\n\n\n//Figure 2: Loudness \n\nb = Buffer.alloc(s,1024,1);   //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n(  //analyse loudness and poll result\nx={\n\tvar in, fft, loudness;\n\t\n\tin = SoundIn.ar(0);; \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tloudness = Loudness.kr(fft); \n\t\n\tloudness.poll(20); //poll for testing 20 times per second\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n\n\n\n//Figure 3: MFCC \n\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//d=Buffer.read(s,\"sounds/a11wlk01.wav\");\n\n\n(\nx= {\n\tvar in, fft, array;\n\t\n\t//in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tin = SoundIn.ar(0);; \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tarray = MFCC.kr(fft); \n\t\n\tarray.size.postln; \n\t\n\tOut.kr(0,array); \n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\n\nc= Bus.new('control', 0, 13); \n\n//poll coefficients\nc.getn(13,{arg val; {val.plot;}.defer}); \n\n\n//Continuous graphical display of MFCC values; free routine before closing window\n\n(\nvar ms; \n\nw = GUI.window.new(\"Thirteen MFCC coefficients\", Rect(200,400,300,300));\n\nms = GUI.multiSliderView.new(w, Rect(10,10,260,280));\n\nms.value_(Array.fill(13,0.0));\nms.valueThumbSize_(20.0);\nms.indexThumbSize_(20.0);\nms.gap_(0);\n\nw.front;\n\nr = {\n\t\n\tinf.do{\n\t\t\n\t\tc.getn(13,{arg val; {ms.value_(val*0.9)}.defer}); \n\t\t\n\t\t0.04.wait; //25 frames per second\n\t};\n\n}.fork;\n\n)\n\n\n//tidy up\n(\nr.stop;\nb.free;\nc.free;\nx.free;\nw.close;\n)\n\n\n\n\n//Figure 4: Onsets\n\n// Prepare the buffer\nb = Buffer.alloc(s, 512);\n\n(\nx = {\n\tvar sig, chain, onsets, pips, trigger;\n\t\n\tsig = SoundIn.ar(0);; \n\t\n\tchain = FFT(b, sig);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger= SendTrig.kr(onsets);\n\t\n\tpips = SinOsc.ar(880, 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));\n\t\n\tOut.ar(0, ((sig * 0.1) + pips).dup);\n}.play;\n)\n\n(\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\t[time,responder,msg].postln;\n}).add;\n)\n\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer\n\n\n\n\n//Figure 5: BeatTrack\n\n\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin); events will be spawned at quarter, eighth and sixteenth note rates\n(\nx= SynthDef(\\help_beattrack2,{\t\n\tvar trackb,trackh,trackq,tempo;\n\tvar source;\n\tvar bsound,hsound,qsound;\n\t\n\tsource = SoundIn.ar(0);;\n\t\n\t#trackb,trackh,trackq,tempo = BeatTrack.kr(FFT(b.bufnum, source));\n\t\n\tbsound = Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);\n\t\n\thsound = Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);\n\t\n\tqsound = Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);\n\t\n\tOut.ar(0, bsound+hsound+qsound);\n}).play;\n)\n\n\nx.free;\nb.free; // Free the buffer\n\n\n\n\n//Figure 6: KeyTrack\n\n//straight forward test file with few transients; training set in e minor from MIREX2006 \n//You will need to substitute your own soundfile to load here\nd=Buffer.read(s,\"/Users/nickcollins/Desktop/ML/training_wav/78.wav\")\n\n\nb = Buffer.alloc(s,4096,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,8192,1); //for sampling rates 88200 and 96000\n\n(\nx= {\n\tvar in, fft; \n\tvar key;\n\t\n\tin = PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tkey = KeyTrack.kr(fft, 2.0, 0.5);\n\t\n\tkey.poll; //write out detected key\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n\n\n//Figure 7: Simple melodic transcription\n//see melodytranscription.rtf\n\n\n//Figure 8: OnlineMIDI\n\n//do this first: \nMIDIIn.connect; \t// init for one port midi interface\n\n\n//now:\nm = OnlineMIDI();\n\nm.analyse(3,1.0); //3 seconds window, step size of 1.0 seconds\n\nm.data //poll current data\n\nm.status = true; //prints analysis data as it goes\nm.status= false;\n\n//use analysis data to formulate responses\n\n(\nSynthDef(\\beep2,{arg freq=440,amp=0.1, pan=0.0, dur=0.1; \nvar source; \n\nsource= SinOsc.ar(freq*[1,1.007],0,amp*0.5);\n\nOut.ar(0,Pan2.ar(Mix(source)*Line.kr(1,0,dur, doneAction:2),pan))}).add;\n)\n\n//to echo each note you play on a MIDI keyboard with a sound; your SynthDef must have freq and amp arguments, and deal with duration and freeing the Synth itself.  \n(\nm.playinput= true; \nm.inputsynthdef= \\beep2; \n)\n\n//set a function that gets called after each window is analysed, to schedule events over the next second \n(\nm.response = {|analysis|  \n\tvar number;\n\tnumber= analysis.density; \n\t//number= max(0,(10-(analysis.density))); //inverting number of notes playing\n\t\n\tif(analysis.iois.notEmpty, {\n\t\t{\n\t\t\n\t\tnumber.do{\n\t\t\n\t\tSynth(\\beep2, [\\freq, analysis.pitches.choose.midicps, \\amp, 0.2*(rrand(analysis.volumemin, analysis.volumemax))]);\n\t\t\n\t\tanalysis.iois.choose.wait; //could last longer than the next second, but still fun! \n\t\t\n\t\t}; \n\t\t\n\t\t}.fork;\n\t}); \n\t\n};\n)\n\n\nm.response= nil; //stop\n\n\n\n",
    "CloudGenMiniFull.scd": "// CloudGenMini is based on CloudGenerator, a granular synthesis program \n// by Curtis Roads and John Alexander. \n// This partial miniature version was implemented by Alberto de Campo, 2007. \n\n\n\t// figure 6.23 - some granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp * AmpComp.ir(freq) * 0.5, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp * AmpComp.ir(freq) * 0.5, 4), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t// a noise band grain with percussive envelope\nSynthDef(\\percNoise, { |out, amp=0.2, freq=440, sustain=0.01, pan, rq=0.1| \n\tvar snd = BPF.ar(GrayNoise.ar, freq, rq, 3);\n\tvar env = EnvGen.ar(Env.perc, timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, \n\t\tPan2.ar(snd * env, pan, amp)\n\t);\n}, \\ir ! 6).store\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\gabWide);\nSynth(\\percSin);\nSynth(\\percSinRev);\n\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\percNoise, [\\amp, 0.2, \\sustain, 0.1]);\n\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t// figure 6.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n/*\n\t// figure  6.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n*/\n\n\n\n\n\t// figure 6.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 6.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t// figure 6.28 is an image, the CloudGenMini GUI //\n\n\n\n\n\t// figure 6.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 0@0;\t// where to put the gui window\n\t\n\tw = GUI.window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)).postln)).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tGUI.button.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tGUI.staticText.new(w, 60@20).string_(\"xfadeTime\"); \n\tfdBox = GUI.numberBox.new(w, 40@20).action_{ |nbx| tdef.envir.xfadeTime = nbx.value }; \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = GUI.compositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tGUI.button.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tGUI.button.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tGUI.rangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 250@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tGUI.staticText.new(w, 50@20).string_(\"synthdef:\"); \n\tGUI.popUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tGUI.button.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tGUI.button.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);\n\n\n",
    "c16_micro_figures1_perception.scd": "\t\t\t// Microsound - code figures //\n\n\n\t\t// perception at the micro time scale //\n\t\t\n\t//  pulses, transition from rhythm to pitch \n{ Impulse.ar (XLine.kr(12, 48, 6, doneAction: 2)) * 0.1 ! 2 }.play; // up\n\n{ Impulse.ar (XLine.kr(48, 12, 6, doneAction: 2)) * 0.1 ! 2 }.play; // down\n\n{ Impulse.ar (MouseX.kr(12, 48, 1)) * 0.1 ! 2 }.play; // mouse-controlled\n\n\n\n\n\n\t// figure 16.1 short grain durations - pitch to colored click \n(\t// a gabor grain, gaussian-shaped envelope\nSynthDef(\\gabor, { |out, freq = 440, sustain = 1, pan, amp = 0.1, width = 0.25 |\n\tvar env = LFGauss.ar(sustain, width, loop: 0, doneAction: 2);\n\tvar son = FSinOsc.ar(freq, 0.5pi, env);\n\tOffsetOut.ar(out, Pan2.ar(son, pan, amp));\n\n}, \\ir ! 6).memStore;\n\n\t// or an approximation with a sine-shaped envelope\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n\n(\nPbindef(\\grain,\n\t\\instrument, \\gabor, \\freq, 1000, \n\t\\dur, 0.5, \\sustain, 20/1000, \\amp, 0.2\n).play;\n)\nPbindef(\\grain, \\sustain, 10/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 5/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 3/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 2/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 1/Pkey(\\freq));\n\n\t// successively shorter, end\nPbindef(\\grain, \\sustain, Pseq((10..1)) / Pkey(\\freq)).play;\n\n\t// random drift of grain duration\nPbindef(\\grain, \\sustain, Pbrown(1, 10, 3) / Pkey(\\freq), \\dur, 0.1).play\n\n\n\n\n\t// short grains seem softer \n(\nPbindef(\\grain, \n\t\\instrument, \\gabor, \\freq, 1000, \\dur, 1,\n\t[\\sustain, \\amp], Pseq([[0.001, 0.1], [0.1, 0.1]], inf) \n).play;\n)\n\t\t// short grain 2x louder \nPbindef(\\grain, [\\sustain, \\amp], Pseq([[0.001, 0.2], [0.1, 0.1]], inf));\n\n\t\t// short grain 4x louder\nPbindef(\\grain, [\\sustain, \\amp], Pseq([[0.001, 0.4], [0.1, 0.1]], inf));\n\n\n\n\t// a grain with quasi-rectangular envelope, short grain 6x louder.\n(\nSynthDef(\\pip, { |out, freq=440, sustain=0.02, amp=0.2, pan=0| \n\tOffsetOut.ar(out, \n\t\tPan2.ar(SinOsc.ar(freq) \n\t\t* EnvGen.ar(Env.linen(0.0005, sustain - 0.001, 0.0005, amp), doneAction: 2), pan)\n\t); \n}).memStore;\n\n\t// is this equal loudness?\nPbindef(\\grain).clear;\nPbindef(\\grain, \n\t\\instrument, \\pip,\n\t\\freq, 1000, \\dur, 1,\n\t\\sustain, Pseq([0.001, 0.1], inf), \n\t\\amp, Pseq([0.6, 0.1], inf) \t\n).play;\n)\n\n\n\n\n\t// figure 16.2 - Perception of short silences.\n(\np = ProxySpace.push;\n\n~source = { SinOsc.ar * 0.1 };\n~silence = { |silDur=0.01| \n\tEnvGen.ar(\n\t\tEnv([0, 1, 1, 0, 0, 1, 1, 0], [0.01, 2, 0.001, silDur, 0.001, 2, 0.01]), \n\t\tdoneAction: 2) ! 2\n};\n~listen = ~source * ~silence;\n~listen.play;\n)\n\n~silence.spawn([\\silDur, 0.001]); // sounds like an added pulse \n~silence.spawn([\\silDur, 0.003]);\n~silence.spawn([\\silDur, 0.01]);\n~silence.spawn([\\silDur, 0.03]);\t  // a pause in the sound\n\n\t// try the same examples with noise:\n~source = { WhiteNoise.ar * 0.1 };\t\n\np.clear.pop; \n\n\n\n\n\t// figure 16.3 - order confusion with sounds in fast succession. \n\t// as grains move closer and closer together, their order becomes ambiguous. \n(\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp), timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n(\nPbindef(\\lo, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 250, \\amp, 0.2, \\dur, 0.5, \\lag, 0\n).play;\nPbindef(\\hi, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 875, \\amp, 0.1, \\dur, 0.5, \\lag, 0\n).play;\n)\n\t// try different lag times between them\nPbindef(\\hi, \\lag, 0.1);\nPbindef(\\hi, \\lag, 0.03);\nPbindef(\\hi, \\lag, 0.01);\nPbindef(\\hi, \\lag, 0.003);\n\n\t// hi too early or too late by a fixed time - which one is first?\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.01).postln).play;\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.02).postln);\n\n\t// is it easier to hear when the sounds are panned apart?\nPbindef(\\hi, \\pan, 0.5); Pbindef(\\lo, \\pan, -0.5);\nPbindef(\\hi, \\pan, 0);   Pbindef(\\lo, \\pan, 0);\n\n\n\n\n\n\t// figure 16.4: multiple grains fuse into one composite.\n\t// when their order changes, the sound is subtly different.\n(\nPbindef(\\grain4, \n\t\\instrument, \\percSin, \\sustain, 0.03, \\amp, 0.2,\n\t\\freq, Pshuf([1000, 600, 350, 250]), // random every each time\n\t\\dur, 0.005\n).play;\n\t\t\t\t// repeat grain cluster \nTdef(\\grain, { loop { Pbindef(\\grain4).play; 1.wait } }).play;\n)\n\t// fixed order\nPbindef(\\grain4, \\freq, Pseq([1000, 600, 350, 250].scramble));\n\n\t// different order every time\nPbindef(\\grain4, \\freq, Pshuf([1000, 600, 350, 250]));\n\n",
    "c16_micro_figures2_anatomy.scd": "\t\t\t// microsound - code figures - anatomy //\n\n\n\t// waveform, envelope, grain plotted\n\ne = Env.sine.asSignal(400).as(Array); \nw = Array.fill(400, { |i| (i * 2pi / 40).sin });\ng = e * w;\t\n\n[e, w, g].flop.flat.plot(\"envelope, wave, grain\", Rect(0,0,408,600), numChannels: 3);\n\n\n\t// a gaussian envelope created with the LFGauss UGen\n{ LFGauss.ar(0.01, 0.26) }.plot;\n\n\t// and a curve created from the gaussian distribution formula\n(-1, -0.995 .. 1).collect { |x| exp(squared(x) / (-2.0 * squared(0.26))) }.plot;\n\n\n\t// a gabor grain and tests\n\n(\nSynthDef(\\gabor0, {|out, freq=440, sustain=0.02, amp=0.2, pan|\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tvar sound = SinOsc.ar(freq) * env;\n\tOffsetOut.ar(out, Pan2.ar(sound, pan))\n}, \\ir.dup(5)).memStore;\n)\n\t\t// test with synth\nSynth(\\gabor0);\t\t// defaults from SynthDef\nSynth(\\gabor0, [\\freq, 1000, \\sustain, 0.005, \\amp, 0.1, \\pan, 0.5]);\n\n\t\t// test with event.play\n(instrument: \\gabor0).play;\t\t// default values from Event.defaultEvent\n(instrument: \\gabor0, sustain: 0.02).play;\n(instrument: \\gabor0, sustain: 0.002, freq: 1500, amp: 0.3, pan: 0.5).play;\n(instrument: \\gabor0, sustain: 0.001, freq: 2500, amp: 0.05, pan: -0.5).play;\n\nSynth.grain(\\gabor0, [\\freq, 2000, \\sustain, 0.003]) // higher efficiency, as no NodeID is kept\n\ns.sendMsg(\"s_new\",  \\gabor0, -1, 0, 0, \\freq, 2000, \\sustain, 0.003); // even more efficient, as no Synth object is created.\n\n\n\n\t// figure 16.6 - making different envelope shapes\n\nEnv.sine.plot;\t\t// approx. gaussian \nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\sin).test.plot; // quasi-gaussian\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\lin).test.plot; // 3 stage line segments.\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\welch).test.plot; // welch curve interpolation\nEnv([1, 0.001], [0.1], \\exp).test.plot;\t// expoDec (exponential decay);\nEnv([0.001, 1], [0.1], \\exp).test.plot;\t// revExpoDec (reverse exponential decay);\nEnv.perc(0.01, 0.09).test.plot;\n\n(\t// a sinc function envelope \nq = q ? ();\nq.makeSinc = { |q, num=1, size=400| \n\tdup({ |x| x = x.linlin(0, size-1, -pi, pi) * num; sin(x) / x }, size);\n}; \na = q.makeSinc(6);\na.plot(bounds: Rect(0,0,409,200), minval: -1, maxval: 1);\n)\n\n\n\n\n\n\n(\t// more envelopes plotted \n[ \tEnv.sine, \n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\sin), \n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\lin),\n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\welch),\n\tEnv([1, 0.001], [1], \\exp),\n\tEnv([0.001, 1], [1], \\exp), \n\tEnv.perc(0.05, 0.95)\n]\t.collect(_.discretize(400))\n\t.add(q.makeSinc(6)).clump(4).collect { |gr4, i| \n\t\tgr4.flop.flat.plot(\n\t\t\t[\"gauss, quasi-gauss, line, welch\", \n\t\t\t\"expodec, rexpodec, perc, sinc\" ][i], \n\t\t\tRect(420 * i + 100, 300, 408, 400), numChannels: 4)\n\t};\n)\n\n\n\n\t// figure 16.9 - SynthDefs with different envelopes\n\n(\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env.sine(sustain, amp2), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp2, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// an exponential decay envelope\nSynthDef(\\expodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = AmpComp.ir(freq.max(50)) * 0.5 * amp;\n\tvar env = XLine.ar(amp2, amp2 * 0.001, sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed exponential decay envelope\nSynthDef(\\rexpodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = XLine.ar(amp2 * 0.001, amp2, sustain, doneAction: 2) \n\t\t* (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n\n\n\n\n\n\t// figure 16.10 - changing grain duration, frequency, envelope\n(\nPbindef(\\grain0,\n\t\\instrument, \\gabor1, \\freq, 500, \n\t\\sustain, 0.01, \\dur, 0.2\t\n).play;\n)\n\t// change grain durations\nPbindef(\\grain0, \\sustain, 0.1);\nPbindef(\\grain0, \\sustain, 0.03);\nPbindef(\\grain0, \\sustain, 0.01);\nPbindef(\\grain0, \\sustain, 0.003);\nPbindef(\\grain0, \\sustain, 0.001);\nPbindef(\\grain0, \\sustain, Pn(Pgeom(0.1, 0.9, 60)));\nPbindef(\\grain0, \\sustain, Pfunc({ exprand(0.0003, 0.03) }));\nPbindef(\\grain0, \\sustain, 0.03);\n\n\t// change grain waveform (sine) frequency\nPbindef(\\grain0, \\freq, 300);\nPbindef(\\grain0, \\freq, 1000);\nPbindef(\\grain0, \\freq, 3000);\nPbindef(\\grain0, \\freq, Pn(Pgeom(300, 1.125, 32)));\nPbindef(\\grain0, \\freq, Pfunc({ exprand(300, 3000) }));\nPbindef(\\grain0, \\freq, 1000);\n\n\t// change synthdef for different envelopes\nPbindef(\\grain0, \\instrument, \\gabor1);\nPbindef(\\grain0, \\instrument, \\gabWide);\nPbindef(\\grain0, \\instrument, \\percSin);\nPbindef(\\grain0, \\instrument, \\percSinRev);\nPbindef(\\grain0, \\instrument, \\expodec);\nPbindef(\\grain0, \\instrument, \\rexpodec);\nPbindef(\\grain0, \\instrument, Prand([\\gabWide, \\percSin, \\percSinRev], inf));\n\n\n\n\n\n\t// bonus track - adjusting phase for attack color\n\t\n(\t// an expodec envelope sine grain with adjustable phase\nSynthDef(\\expodecPH, { |out, amp=0.1, freq=440, click=0, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq, click * 0.5pi);\n\tvar env = XLine.ar(amp, amp * 0.001, sustain, doneAction: 2) * (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 6).memStore;\n)\n(\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodecPH, \n\t\\sustain, 0.1, \n\t\\freq, [100, 300],\n\t\\click, Pseq((0..20)/20, inf) // add more and more click \n).play;\n)\n\n\n\n\n\n\n\t// figure 16.11 - different control strategies applied to density\n\t\n(\t// synchronous - regular time intervals\nPbindef(\\grain0).clear;\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, 0.1, \\sustain, 0.06\n);\n)\n\t// different fixed values\nPbindef(\\grain0, \\dur, 0.06) \t// rhythm\nPbindef(\\grain0, \\dur, 0.035)\t\nPbindef(\\grain0, \\dur, 0.02)\t// fundamental frequency 50 Hz\n\n\t// time-changing values: accelerando/ritardando\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02], [4], \\exp), inf));\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02, 0.06, 0.01].scramble, [3, 2, 1], \\exp), inf));\n\n\t// repeating values: rhythms or tones\nPbindef(\\grain0, \\dur, Pstutter(Pwhite(2, 15), Pfunc({ exprand(0.01, 0.3) })));\n\n\t// introducing irregularity - quasi-synchronous\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.8, 1.2))\nPbindef(\\grain0, \\dur, 0.03 * Pbrown(0.6, 1.4, 0.1)) // slower drift\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.2, 1.8))\n\n\t// average density constant, vary degree of irregularity  \nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.1.linrand * 3) + 0.9 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.3.linrand * 3) + 0.3 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (1.0.linrand * 3) + 0.0 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ 2.45.linrand.squared })); // very irregular\n\n\n(\t// coupling - duration depends on freq parameter\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq  })\n);\n)\n\n\t// different freq movement, different timing\nPbindef(\\grain0, \\freq, Pbrown(48.0, 96.0, 12.0).midicps);\n\n(\t// duration depends on freq, with some variation - tendency mask\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq * rrand(0.5, 1.5)  })\n);\n)\n\n\n\t// figure 16.12 - control strategies applied to different parameters\n(\nPbindef(\\grain0).clear;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, 200,\n\t\\sustain, 0.05, \\dur, 0.07\n).play;\n)\n\t// time-varying freq with envelope pattern\nPbindef(\\grain0, \\freq, Pn(Penv([200, 1200], [10], \\exp), inf));\n\t// random freq\nPbindef(\\grain0, \\freq, 400 * Pwhite(-24.0, 24).midiratio);\n\t// timechanging with random variation\nPbindef(\\grain0, \\freq, Pn(Penv([400, 2400], [10], \\exp), inf) * Pwhite(-24.0, 24).midiratio);\n\n\t// panning\nPbindef(\\grain0, \\pan, Pwhite(-0.8, 0.8));  // random\nPbindef(\\grain0, \\pan, Pn(Penv([-1, 1], [2]), inf)); // tendency\nPbindef(\\grain0, \\pan, Pfunc({ |ev| ev.freq.explin(50, 5000, -1, 1) })); // coupled to freq\n\n\t// time scattering variants\nPbindef(\\grain0, \\dur, 0.1 * Pwhite(0.5, 1.5));\t// random range\nPbindef(\\grain0, \\dur, 0.05 * Prand([0, 1, 1, 2, 4], inf)); // rhythmic random\n\n\t// amplitude - randomized\nPbindef(\\grain0, \\amp, Pwhite(0.01, 0.2));\t// linear\nPbindef(\\grain0, \\amp, Pwhite(-50, -14).dbamp); // exponential - more depth\nPbindef(\\grain0, \\dur, 0.025 * Prand([0, 1, 1, 2, 4], inf)); // could be denser now\n\n\t// random amplitude envelopes with Pseg\n(\nPbindef(\\grain0, \n\t\\amp, Pseg(\n\t\tPxrand([-50, -20, -30, -40] + 10, inf), // level pattern\n\t\tPxrand([0.5, 1, 2, 3], inf), \t\t// time pattern\n\t\tPrand([\\step, \\lin], inf)\t\t\t// curve pattern\n\t).dbamp\n); \n)\n\t// grain sustain time coupled to freq\nPbindef(\\grain0, \\sustain, Pkey(\\freq).reciprocal * 20).play;\n",
    "c16_micro_figures3_grainugens.scd": "\t\n\t// GrainSin.help example as nodeproxy\n\t\np = ProxySpace.push;\n(\n~grain.play;\n~grain = {\targ envbuf = -1, density = 10, graindur=0.1, amp=0.2;\n\tvar pan, env, freqdev; \n\tvar trig = Impulse.kr(density);\n\tpan = MouseX.kr(-1, 1);\t\t// use mouse x to control panning\n\t// use WhiteNoise and mouse y to control deviation from center\n\tfreqdev = WhiteNoise.kr(MouseY.kr(400, 0));\n\tGrainSin.ar(2, trig, graindur, 440 + freqdev, pan, envbuf) * amp\n};\n)\n\n\n\n\t// switching envelopes while playing\n\t\nq = q ? ();\t\t// make a dict to keep things around\nq.envs = ();\t\t// e.g. some envelopes \nq.bufs = ();\t\t// and some buffers\n\t\t\t\t// make an envelope, and convert it to a buffer\nq.envs.perc1 = Env([0, 1, 0], [0.1, 0.9], -4);\nq.bufs.perc1 = Buffer.sendCollection(s, q.envs.perc1.discretize, 1);\n\n\t// switch between built-in hanning envelope and custom - perc1\n~grain.set(\\envbuf, -1);\n~grain.set(\\envbuf, q.bufs.perc1.bufnum);\n\n\n\n\t//  fixed parameters and control proxies\n~grain.set(\\density, 20);\n~grain.set(\\graindur, 0.03);\n\n\t// map a control proxy to a parameter\n~grdur = 0.1;\n~grain.map(\\graindur, ~grdur);\n~grdur = { LFNoise1.kr(1).range(0.01, 0.1) };\n~grdur = { SinOsc.kr(0.3).range(0.01, 0.1) };\n~grdur = 0.01;\n\n\t// create random densities from 2 to 2 ** 6, exponentially distributed\n~grdensity = { 2 ** LFNoise0.kr(1).range(0, 6) };\n\t// map to density control\n~grain.map(\\density, ~grdensity);\n~grdensity = { 2 ** LFNoise0.kr(1).range(2, 4) };\n\n\n~grain.clear;\n\n\t// GrainFM with mouse control\n(\n~grain.play;\n\t\t// original\n~grain = { arg envbuf = -1, density = 10, graindur=0.1, modfreq=200;\n\tvar pan = MouseX.kr(-1, 1);\n\tvar trig = Impulse.kr(density);\n\tvar freqdev = WhiteNoise.kr(MouseY.kr(0, 400));\n\tvar freq = 440 + freqdev;\n\tvar moddepth = LFNoise1.kr.range(1, 10);\n\tGrainFM.ar(2, trig, graindur, freq, modfreq, moddepth, pan, envbuf) \n\t* 0.2\n};\n)\n\n(\t// help file example rewritten to use MouseX for modulation range\n~grain = { arg envbuf = -1, density = 10, graindur=0.1, modfreq=200;\n\tvar pan = WhiteNoise.kr;\n\tvar trig = Impulse.kr(density);\n\tvar freqdev = WhiteNoise.kr(MouseY.kr(0, 400));\n\tvar freq = 440 + freqdev;\n\tvar modrange = MouseX.kr(1, 10);\n\tvar moddepth = LFNoise1.kr.range(1, modrange);\n\tGrainFM.ar(2, trig, graindur, freq, modfreq, moddepth, pan, envbuf) \n\t* 0.2\n};\n)\n\n\n\t// figure 16.13   - GrainFM with individual control proxies\n(\n~trig = { |dens=10| Impulse.kr(dens) };\n~freq = { MouseX.kr(100, 2000, 1) * LFNoise1.kr(1).range(0.25, 1.75) };\n~moddepth = { LFNoise1.kr(20).range(1, 10) };\n~modfreq = 200;\n~graindur = 0.1;\n\n~grain = { arg envbuf = -1;\n\tGrainFM.ar(2, ~trig.kr, ~graindur.kr, \n\t\t~freq.kr, ~modfreq.kr, ~moddepth.kr, \n\t\tpan: WhiteNoise.kr, envbuf: envbuf) * 0.2\n};\n~grain.play;\n)\n\t// change control ugens: \n~modfreq = { ~freq.kr * LFNoise2.kr(1).range(0.5, 2.0) }; // modfreq roughly follows freq\n~trig = { |dens=10| Dust.kr(dens)};\t// random triggering, same density\n~freq = { LFNoise0.kr(0.3).range(200, 800) };\n~moddepth = 3; \t// fixed depth\n~graindur = { LFNoise0.kr.range(0.01, 0.1) };\n\n\n\n\t// bonus: blend dust and impulse triggers\n~trig = { |dens=20, bal=0.2| Dust.kr(dens * (1-bal)) + Impulse.kr(dens * bal) };\n~trig.set(\\bal, 0.1);\n~trig.set(\\bal, 0.5);\n~trig.set(\\bal, 0.9);\n\nProxyMixer(p);\n\n\n\n\np = ProxySpace.push;\n\n\n\t// figure 16.14 - GrainBuf and control proxies\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~grain.set(\\wavebuf, b.bufnum);\n~trig = { |dens=10| Impulse.kr(dens) };\n~graindur = 0.1;\n~filepos = {LFNoise2.kr(0.2).range(0, 1) };\n~rate = { LFNoise1.kr.range(0.5, 1.5) };\n\n~grain = { arg envbuf = -1, wavebuf = 0;\n\tGrainBuf.ar(2, ~trig.kr, ~graindur.kr, wavebuf, \n\t~rate.kr, ~filepos.kr, 2, WhiteNoise.kr, envbuf) * 0.2\n};\n~grain.play;\n)\n\n\t// experiment with control proxies\n~trig = { |dens=20| Impulse.kr(dens) };\n~rate = { LFNoise1.kr.range(0.99, 1.01) };\n~filepos = { MouseX.kr + LFNoise0.kr(100, 0.03) };\n~graindur = 0.05;\n~trig = { |dens=50| Dust.kr(dens) };\n\nc = Buffer.sendCollection(s, Env.perc(0.01, 0.99).discretize, 1);\n~grain.set(\\envbuf, c.bufnum); \n~grain.set(\\envbuf, -1);\n\n~trig = { |dens=50| Impulse.kr(dens) }; ~graindur = 0.05;\n\n\n",
    "c16_micro_figures4_synthesis.scd": "\n\n\t// FM grain as synthdef\n(\nSynthDef(\\grainFM0, {|out, carfreq=440, modfreq=200, moddepth = 1, \n\tsustain=0.02, amp=0.2, pan|\n\t\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tvar sound = SinOsc.ar(carfreq, SinOsc.ar(modfreq) * moddepth) * env;\n\tOffsetOut.ar(out, Pan2.ar(sound, pan))\n}, \\ir.dup(7)).memStore;\n)\n(instrument: \\grainFM0, sustain: 0.1, amp: 0.2).play;\n\n\t// to use buffer envelopes: Osc1 \n(\nq = q ? ();\nq.envbuf = Buffer.sendCollection(s, Env.perc(0.1, 0.9).discretize, 1);\n\nSynthDef(\\grainFM1, {|out, envbuf, carfreq=440, modfreq=200, moddepth = 1, \n\tsustain=0.02, amp=0.2, pan|\n\t\n\tvar env = Osc1.ar(envbuf, sustain, doneAction: 2);\n\tvar sound = SinOsc.ar(carfreq, SinOsc.ar(modfreq) * moddepth) * env;\n\tOffsetOut.ar(out, Pan2.ar(sound, pan, amp))\n}, \\ir.dup(8)).memStore;\n)\n\n(instrument: \\grainFM1, sustain: 0.1, envbuf: q.envbuf).play;\n\n(\nPbindef(\\fm, \n\t\t\\instrument, \\grainFM1, \n\t\t\\carfreq, Pbrown(300, 1200, 300), \n\t\t\\modfreq, 200, \n\t\t\\modindex, Pbrown(1.0, 10.0, 2.5), \n\t\t\\sustain, 0.1, \n\t\t\\dur, 0.1,\n\t\t\\envbuf, q.envbuf,\n\t\t\\pan, Pwhite(-0.8, 0.8)\n).play;\n)\n\n\n\n\n\t// GrainBuf as synthdef\n(\nq = q ? ();\nq.envbuf = Buffer.sendCollection(s, Env.perc(0.1, 0.9).discretize, 1);\nq.apollo = Buffer.read(s,\"sounds/a11wlk01.wav\");\n\nSynthDef(\\grainBuf1, {|out, envbuf, wavebuf, filepos, rate=1, \n\tsustain=0.02, amp=0.2, pan|\n\t\n\tvar env = Osc1.ar(envbuf, sustain, doneAction: 2);\n\tvar sound = PlayBuf.ar(1, wavebuf, \n\t\trate * BufRateScale.ir(wavebuf), 1,\n\t\tstartPos: BufFrames.ir(wavebuf) * filepos) \n\t\t* env;\n\t\n\tOffsetOut.ar(out, Pan2.ar(sound, pan, amp))\n}, \\ir.dup(8)).memStore;\n)\n\n(instrument: \\grainBuf1, sustain: 0.1, envbuf: q.envbuf, wavebuf: q.apollo).play;\n\n(\nPdef(\\buf1, \n\tPbind(\n\t\t\\instrument, \\grainBuf1, \n\t\t\\envbuf, q.envbuf, \\wavebuf, q.apollo,\n\t\t\\sustain, 0.1, \\dur, 0.05,\n\t\t\\pan, Pwhite(-0.8, 0.8),\n\t\t\\filepos, Pn(Pseries(0, 0.01, 100))\n\t)\n).play;\n)\n\nq.envbuf.sendCollection(Env.sine.discretize);\nq.envbuf.sendCollection(Env.perc.discretize);\n\n\n\n\t// figure 16.15 - Glisson synthesis\n(\nSynthDef(\"glisson\", \n\t{ arg out = 0, envbuf, freq=800, freq2=1200, sustain=0.001, amp=0.2, pan = 0.0;\n\t\tvar env = Osc1.ar(envbuf, sustain, 2);\n\t\tvar freqenv = XLine.ar(freq, freq2, sustain);\n\t\tOffsetOut.ar(out, \n\t\t\tPan2.ar(SinOsc.ar(freqenv) * env, pan, amp)\n\t\t)\n}, \\ir!7).memStore;\n)\n\n(\nTdef(\\gliss0, { |e|\n\t100.do({ arg i;\n\t\ts.sendBundle(s.latency, [\"/s_new\", \"glisson\", -1, 0, 0, \n\t\t\t\\freq, i % 10 * 100 + 1000,\n\t\t\t\\freq2, i % 13 * -100 + 3000,\n\t\t\t \\sustain, 0.05, \n\t\t\t \\amp, 0.1,\n\t\t\t \\envbuf, q.envbuf.bufnum\n\t\t]);\n\t\t(3 / (i + 10)).wait;\n\t});\n}).play;\n)\n\n\n\n/*\n\tMagnetization patterns can be:\n\tbidirectional, shallow, \n\tbidirectional, deep, \n\tunidir, up,\n\tunidir, down,\n\tconverging to center, \n\tdiverging from center. \n*/\n\n(\nSynthDef(\\glisson0, { |out, freq1=440, freq2=660, sustain=0.05, amp=0.2, pan, envwide=0.5| \n\tvar slopetime = (1 - envwide) * 0.5;\n\tvar sound = SinOsc.ar(XLine.ar(freq1, freq2, sustain));\n\tvar env = EnvGen.ar(\n\t\tEnv([0, amp, amp, 0], [slopetime, envwide, slopetime], \\sin), \n\t\ttimeScale: sustain,\n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(sound * env, pan));\n}).memStore; \n)\n\n(\nTdef(\\biGliss).set(\\fmin, 100, \\fmax, 5000, \\fratio, 1.0); // non-gliss, wide freq range\n\nTdef(\\biGliss, { |envir|\n\t\n\tvar f1, f2, temp; \n\tinf.do { \n\t\tf1 = exprand(envir.fmin, envir.fmax);\n\t\tf2 = f1 * (envir.fratio ** 1.0.rand2);\n\t//\t[f1, f2].postln;\n\t\t(\tinstrument: \\glisson0, \n\t\t\tfreq1: f1, \n\t\t\tfreq2: f2,\n\t\t\tpan: 1.0.rand2,\n\t\t\tsustain: 0.05\n\t\t).play;\n\t\t0.03.wait;\n\t};\n}).play;\n)\nTdef(\\biGliss).play;\nTdef(\\biGliss).set(\\fratio, 1.4);\t// shallow\nTdef(\\biGliss).set(\\fratio, 3.0);\t// wide\n\n\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 1.0);  // fixed\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 1.4);  // diverging, shallow\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 2);\t   // diverging\n\n(\nTdef(\\biGliss).set(\\fmin, 1800, \\fmax, 600, \\fratio, 2.0);\t// converging\nTdef(\\biGliss, { |envir|\n\t\t\n\tvar f1, f2, temp; \n\t500.do { \n\t\tf1 = exprand(envir.fmin, envir.fmax);\n\t\tf2 = f1 * (envir.fratio ** 1.0.rand2);\n\t\t\n\t\t(\tinstrument: \\glisson0, \n\t\t\tfreq1: f2, \t// swap f1 and f2 here for converging\n\t\t\tfreq2: f1,\n\t\t\tpan: 1.0.rand2,\n\t\t\tsustain: 0.1\n\t\t).play;\n\t\t0.1.linrand.wait;\n\t};\n}).play;\n)\n\nTdef(\\biGliss).set(\\fmin, 1800, \\fmax, 2600, \\fratio, 2.0);   // converging\n\n",
    "c16_micro_figures5_pulsar.scd": "\n\t// figure 16.16 - Pulsar basics - make a set of waveform and control tables\n(\nq = ();\nq.curr = (); \t// make a dict for the set of tables\nq.curr.tab = ();\n\t\t\t\t// random tables for pulsaret  and envelope waveforms:\nq.curr.tab.env = Env.perc.discretize; \nq.curr.tab.pulsaret = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// random tables for the control parameters:\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.curr.tab.amp = 0.2.dup(1024);\nq.curr.tab.pan = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// make buffers from all of them:\nq.bufs = q.curr.tab.collect({ |val, key| Buffer.sendCollection(s, val, 1) });\n)\n\t\t// plot one of them\nq.bufs.pulsaret.plot(\"a pulsaret\");\n\n\n\n\n\t// figure 16.17 - Pulsars as nodeproxies using GrainBuf\n(\np = ProxySpace.push; \n\n\t\t// fund, form, amp, pan\n~controls = [ 16, 100, 0.5, 0]; \n~pulsar1.set(\\wavebuf, q.bufs.pulsaret.bufnum);\n~pulsar1.set(\\envbuf, q.bufs.env.bufnum);\n\n~pulsar1 = { |wavebuf, envbuf = -1| \n\tvar ctls = ~controls.kr;\n\tvar trig = Impulse.ar(ctls[0]);\n\tvar grdur = ctls[1].reciprocal;\n\tvar rate = ctls[1] * BufDur.kr(wavebuf);\n\t\t\n\tGrainBuf.ar(2, trig, grdur, wavebuf, rate, 0, 4, ctls[3], envbuf);\n};\n~pulsar1.play;\n)\n\n\t// crossfade between control settings\n~controls.fadeTime = 3; \n~controls = [ 16, 500, 0.5, 0]; \t// change formfreq\n~controls = [ 50, 500, 0.5, 0]; \t// change fundfreq\n~controls = [ 16, 100, 0.5, 0]; \t// change both\n~controls = [ rrand(12, 100), rrand(100, 1000)]; \n\n(\t// control parameters from looping tables\n~controls = { |looptime = 10| \n\tvar rate = BufDur.kr(q.bufs.pulsaret.bufnum) / looptime; \n\tA2K.kr(PlayBuf.ar(1, [\\fund, \\form, \\amp, \\pan].collect(q.bufs[_]), \n\t\trate: rate, loop: 1));\n};\n)\n\n\n\t// figure 16.18 - make new tables and send them to buffers\n\n\t// make new pulsaret tables and send them to the buffer:\nq.bufs.pulsaret.sendCollection(Array.linrand(1024, -1.0, 1.0)); // noise burst\nq.bufs.pulsaret.read(\"sounds/a11wlk01.wav\", 44100 * 1.5);       // sample\nq.bufs.pulsaret.sendCollection(Pbrown(-1.0, 1.0, 0.2).asStream.nextN(1024));\n\n\t// make a new random fundfreq table, and send it\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.bufs.fund.sendCollection(q.curr.tab.fund);\n\n\t// and a new random formfreq table\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.bufs.form.sendCollection(q.curr.tab.form);\n\n\n\n\n\n\n\n\t// Pulsar synthesis with client-side control\n\t\n\t\t// a pulsaret and an envelope\na = Signal.sineFill(1024, 1/(1..10).scramble).putLast(0);\nb = Env.perc.discretize(1024).putLast(0);\n\t\t// as buffers\nx = Buffer.sendCollection(s, a, 1);\ny = Buffer.sendCollection(s, b, 1);\n\n\t\t// a pulsar synthdef\n(\nSynthDef(\\pulsar1, {|out, wavebuf, envbuf, form=200, amp=0.2, pan| \n\tvar grDur =  1/form;\n\tvar pulsaret = Osc1.ar(wavebuf, grDur);\n\tvar env = Osc1.ar(envbuf, grDur, doneAction: 2);\n\t\n\tOffsetOut.ar(out, Pan2.ar(pulsaret * env, pan, amp));\n}, \\ir ! 6).memStore;\n)\nSynth(\\pulsar1, [\\wavebuf, x, \\envbuf, y]);\n\n\t// a simple pattern\n(\nPbindef(\\pulsar1, \n\t\t\\instrument, \\pulsar1, \n\t\t\\wavebuf, x, \\envbuf, y, \n\t\t\\form, Pn(Penv([20, 1200], [4], \\exp)).loop, \n\t\t\\amp, 0.2, \\pan, 0,\n\t\t\\fund, 12, \n\t\t\\dur, Pfunc({ |ev| ev.fund.reciprocal })\n).play;\n)\n\n\n\n\t// Control from patterns and tables\n\nPbindef(\\pulsar1, \\form, Pn(Penv([20, 1200], [4], \\exp)).loop);\nPbindef(\\pulsar1, \\fund, Pn(Penv([5, 50], [5])).loop);\nPbindef(\\pulsar1, \\amp, Pn(Penv([0, 0.2, 0.1], [7])).loop);\nPbindef(\\pulsar1, \\pan, Pbrown(-1.0, 1.0, 0.2));\nPbindef(\\pulsar1, \\amp, 0.2);\n\n\t// use Pseg for a control table reader\nf = Env({ 100.0.rand }.dup(10), {1.0.rand}.dup(9).normalizeSum, \\sine).asSignal;\nf.plot;\n\nPbindef(\\pulsar1, \\fund, Pseg(f, 0.01, \\lin, inf)).play;\n\n\n",
    "c16_micro_figures6_time_constQ.scd": "\t\t\t\t// time-pitch changing // \n\n\n\n\t\t// figure 16.19 time-pitch changing\np = ProxySpace.push(s.boot);\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~timepitch = {arg sndbuf, pitchRatio=1, pitchRd=0.01, grainRate=10, overlap=2, \n\tposSpeed=1, posRd=0.01;\n\t\n\tvar graindur = overlap / grainRate;\n\tvar pitchrate = pitchRatio + LFNoise0.kr(grainRate, pitchRd);\n\tvar position = LFSaw.kr(posSpeed / BufDur.kr(sndbuf)).range(0, 1) \n\t\t+ LFNoise0.kr(grainRate, posRd);\n\t\t\n\tGrainBuf.ar(2, Impulse.kr(grainRate), graindur, sndbuf, pitchrate,\n\t\t\tposition, 4, 0, -1)\n};\n~timepitch.set(\\sndbuf, b.bufnum);\n~timepitch.play;\n);\n\nSpec.add(\\pitchRatio, [0.25, 4, \\exp]);\nSpec.add(\\pitchRd, [0, 0.5, \\amp]);\nSpec.add(\\grainRate, [1, 100, \\exp]);\nSpec.add(\\overlap, [0.25, 16, \\exp]);\nSpec.add(\\posSpeed, [-2, 2]);\nSpec.add(\\posRd, [0, 0.5, \\amp]);\nNodeProxyEditor(~timepitch, 10);\n\n\t// reconstruct original\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 1, \\posRd, 0);\n\n\t// four times as long: tweak pitchRd and posJitter to reduce artifacts\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0);\n\n\t// random read position, random pitch\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0.5, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0.5);\n\n\n\n\n\n\n\t\t\t// examples constantQ granulation \n\n\n\t// figure 16.20 - A constant-Q Synthdef.\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\nSynthDef(\\constQ, { |out, bufnum=0, amp=0.1, pan, centerPos=0.5, sustain=0.1, \n\trate=1, freq=400, rq=0.3| \n\n\tvar ringtime = (2.4 / (freq * rq) * 0.66).min(0.5); // estimated\n\tvar ampcomp = (rq ** -1) * (400 / freq ** 0.5);\t\n\tvar envSig = EnvGen.ar(Env([0, amp, 0], [0.5, 0.5] * sustain, \\welch));\n\tvar cutoffEnv = EnvGen.kr(Env([1, 1, 0], [sustain+ringtime,0.01]), doneAction: 2);\n\tvar grain = PlayBuf.ar(1, bufnum, rate, 0, \n\t\tcenterPos - (sustain * rate * 0.5) * BufSampleRate.ir(bufnum), \n\t\t1) * envSig;\t\n\tvar filtered = BPF.ar( grain, freq, rq, ampcomp ); \n\n\tOffsetOut.ar(out, Pan2.ar(filtered, pan, cutoffEnv))\n}, \\ir.dup(8)).memStore;\n)\n\nSynth(\\constQ, [\\bufnum, b, \\freq, exprand(100, 10000), \\rq, exprand(0.01, 0.1), \\sustain, 0.01]);\n\n\n\n\n\t// parameter tests for constant Q granulation\n\t\nSynth(\\constQ, [\\bufnum, b]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5]);\t// centerPos = where in soundfile (seconds)\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 1]);\t\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 1.5]);\t\n\t\n\t// sustain is sustain of exciter grain: \nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.01]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.03]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.1]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.3]);\n\n\t// filter parameters, rq of bandpass determines ringtime\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 1]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.3]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.1]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.03]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.01]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.003]);\n\n\t// lower freq rings longer\nSynth(\\constQ, [\\bufnum, b, \\freq, 600, \\rq, 0.003]);\n\n\n\n\t// figure 16.21 - a stream of constant Q grains\n(\nPbindef(\\gr1Q, \n\t\\instrument, \\constQ, \\bufnum, b.bufnum,\n\t\\sustain, 0.01, \\amp, 0.2,\n\t\\centerPos, Pn(Penv([1, 2.0], [10], \\lin)), \n\t\\dur, Pn(Penv([0.01, 0.09, 0.03].scramble, [0.38, 0.62] * 10, \\exp)),\n\t\\rate, Pwhite(0.95, 1.05), \n\t\\freq, Pbrown(64.0, 120, 8.0).midicps,\n\t\\pan, Pwhite(-1, 1, inf),\n\t\\rq, 0.03\n).play;\n)\n\t// changing parameters while playing\nPbindef(\\gr1Q, \\rq, 0.1);\nPbindef(\\gr1Q, \\rq, 0.01);\nPbindef(\\gr1Q, \\sustain, 0.03, \\amp, 0.08);\nPbindef(\\gr1Q, \\freq, Pbrown(80, 120, 18.0).midicps);\n\nPbindef(\\gr1Q, \\rq, 0.03);\n\nPbindef(\\gr1Q, \\rate, Pn(Penv([1, 2.0], [6], \\lin)));\n\n\t// variable duration\nPbindef(\\gr1Q, \\dur, Pwhite(0.01, 0.02));\n\n\t// a rhythm that ends\nPbindef(\\gr1Q, \\dur, Pgeom(0.01, 1.1, 40));\n\n",
    "c16_micro_figures7_waveset.scd": "\n\n\t//\tfigure 16.22 - a Wavesets object\nw = Wavesets.from(\"sounds/a11wlk01.wav\");\n\nw.xings;\t\t\t// all integer indices of the zero crossings found\nw.numXings;\t\t// the total number of zero crossings\nw.lengths;\t\t// lengths of all wavesets\nw.amps;\t\t\t// peak amplitude of every waveset\nw.maxima;\t\t\t// index of positive maximum value in every waveset\nw.minima;\t\t\t// index of negative minimum value in every waveset\n\nw.fracXings;\t\t// fractional zerocrossing points\nw.fracLengths;\t// and lengths: allows more precise looping.\n\t\t\t\t\nw.lengths.plot;\t// show distribution of lengths\nw.amps.plot;\n\n\t// get data for a single waveset: frameIndex, length (in frames), dur\nw.frameFor(140, 1);\t\nw.ampFor(140, 1);\t\t// peak amplitude of that waveset or group\n\t\n\t// extract waveset by hand\nw.signal.copyRange(w.xings[150], w.xings[151]).plot(\"waveset 150\");\nw.plot(140, 1);\t// convenience plotting\nw.plot(1510, 1);\t\n\n\t// plot a group of 5 adjacent wavesets\nw.plot(1510, 5)\t\n\n\n\n\t// figure 16.23 and 24 are screenshots\n\n\n\n\t//\tfigure 16.25 - wavesets and buffers\n\n\t// A Synthdef to play a waveset (or group) n times.\n(\n\t// A wavesets loads the file into a buffer by default.\n\t\tb = w.buffer;\t\t\n\t// Wavesets.prepareSynthDefs loads this synthdef: \n\t\tSynthDef(\\wvst0, { arg out = 0, buf = 0, start = 0, length = 441, playRate = 1, sustain = 1, amp=0.2, pan; \n\t\t\tvar phasor = Phasor.ar(0, BufRateScale.ir(buf) * playRate, 0, length) + start;\n\t\t\tvar env = EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2);\n\t\t\tvar snd = BufRd.ar(1, buf, phasor) * env;\n\t\t\t\n\t\t\tOffsetOut.ar(out, Pan2.ar(snd, pan));\n\t\t}, \\ir.dup(8)).memStore;\n)\n\n// play from frame 0 to 440, looped for 0.1 secs, so ca 10 repeats. \n(instrument: \\wvst0, bufnum: b.bufnum, start: 0, length: 440, amp: 1, sustain: 0.1).play;\n\n\t// get data from waveset\n(\nvar start, length, sustain, repeats = 20; \n#start, length, sustain = w.frameFor(150, 5);\n\n(\tinstrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\tstart: start, length: length, sustain: sustain * repeats\n).play;\n)\n\n\t// or even simpler: \nw.eventFor(startWs: 150, numWs: 5, repeats: 20, playRate: 1).put(\\amp, 0.5).play;\n\n\n\n\n\t// figure 16.26 - a pattern to play wavesets\n\n\t// by default, this pattern reconstructs a soundfile segment.\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 3000), 1), \n\t\\numWs, 1, \n\t\\playRate, 1, \n\t\\bufnum, b.bufnum, \n\t\\repeats, 1, \n\t\\amp, 0.4,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur; \n\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\t\t[start, length, wsDur * ev[\\repeats] / ev[\\playRate].abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\n\n\n\t//\tfigure 16.27 - some of wishart's transforms\n\n\t// waveset transposition: every second waveset, half speed\nPbindef(\\ws1, \\playRate, 0.5, \\startWs, Pn(Pseries(0, 2, 500), 1)).play;\n\n\t// reverse every single waveset \nPbindef(\\ws1, \\playRate, -1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\t// reverse every 2 wavesets\nPbindef(\\ws1, \\numWs, 2, \\playRate, -1, \\startWs, Pn(Pseries(0, 2, 1000), 1)).play;\n\t// reverse every 20 wavesets\nPbindef(\\ws1, \\numWs, 20, \\playRate, -1, \\startWs, Pn(Pseries(0, 20, 1000), 1)).play;\n\t// restore\nPbindef(\\ws1, \\numWs, 1, \\playRate, 1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\n\t// time stretching\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 4).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1, \\repeats, 1).play;\t// restore\n\n\t// waveset omission: drop every second\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1,1, \\, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pfunc({ if (0.25.coin, 1, \\) }) ).play; // drop randomly\nPbindef(\\ws1, \\numWs, 1, \\freq, 1, \\startWs, Pn(Pseries(0, 1, 1000)) ).play; // restore\n\n\t// waveset shuffling (randomize waveset order +- 5, 25, 125)\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 5.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 25.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 125.rand2 })).play;\t\n\n\n\n\n\n\t//\tfigure 16.28 - waveset substitution\n\t\n\t// the waveform to substitute\nc = Buffer.alloc(s, 512); c.sendCollection(Signal.sineFill(512, [1]));\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 1000), 5), \n\t\\numWs, 1, \\playRate, 1, \n\t\\buf, c.bufnum, // sine wave\n\t\\repeats, 1, \n\t\\amp, 1,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur, origRate; \n\t\torigRate = ev[\\playRate];\n\t\t\n\t\t\t// get orig waveset specs\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\n\t\t\t// adjust playrate for different length of substituted wave\n\t\tev[\\playRate] = origRate * (512 / length); \n\n\t\t\t// get amplitude from waveset, to scale full volume sine wave\n\t\tev[\\amp] = ev[\\amp] * w.ampFor(ev[\\startWs], ev[\\numWs]);\n\t\t\n\t\t[0, 512, wsDur * ev[\\repeats] / origRate.abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\t// clearer sinewave-ish segments\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1).stop;\n\n\t// different waveforms\nc.sendCollection(Signal.sineFill(512, 1/(1..4).squared.scramble));\nc.sendCollection(Signal.rand(512, -1.0, 1.0));\nc.sendCollection(Signal.sineFill(512, [1]));\n\nc.plot;\n\n\n\n\n\t//\twaveset interpolation - web examples only\n(\nSynthDef(\"wsInterp\", { arg out = 0, \n\tbuf1 = 0, start1 = 0, len1 = 1000, \n\tbuf2 = 0, start2 = 0, len2 = 500, \n\tplayRate = 1, sustain = 1, \n\tamp=0.2, pan; \n\t\n\tvar lenRatio = (len1 / len2);\n\tvar playRateLine = Line.ar(playRate, playRate * lenRatio, sustain); \n\t\n\tvar phasor1 = Phasor.ar(0, BufRateScale.ir(buf1) * playRateLine, 0, len1);\n\tvar phasor2 = phasor1 / lenRatio; \n\tvar xfade = Line.ar(0, 1, sustain);\n\t\n\tvar snd = (BufRd.ar(1, [buf1, buf2], \n\t\t[phasor1 + start1, phasor2 + start2], \n\t\tinterpolation: 4)\n\t\t* [1 - xfade, xfade]).sum;\n\t\n\tOffsetOut.ar(out, \n\t\tPan2.ar(\n\t\t\tsnd * EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2),\n\t\t \tpan\n\t \t)\n\t );\n}, \\ir.dup(12)).memStore;\n)\n\n(\nq = q ? ();\nq.playInterp = { |q, start1, len1, start2, len2, numWs=200| \n\tvar set1 = w.frameFor(start1, len1).postln;\n\tvar set2 = w.frameFor(start2, len2).postln; \n\tvar sustain = (set2[2] + set1[2] * 0.5 * numWs).postln;\n\n\t(instrument: \\wsInterp, buf1: b.bufnum, buf2: b.bufnum, amp: 0.5,\n\t\n\t\tstart1: set1[0], len1: set1[1], playRate: 1,\n\t\tstart2: set2[0], len1: set2[1], sustain: sustain\n\t).play;\t\n};\n)\n\t// some interpolations\nq.playInterp(200, 1, 500, 1, 400);\nq.playInterp(400, 8, 600, 3, 100);\nq.playInterp(200, 1, 500, 5, 600);\n\n\n\n\n\n\t//\tfigure 16.29 - wavesets played with Tdef \n\t\n\t// very simple first pass, fixed repeat time\n(\nTdef(\\ws1).set(\\startWs, 400);\nTdef(\\ws1).set(\\numWs, 5);\nTdef(\\ws1).set(\\repeats, 5);\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain; \n\n\tloop { \n\t\t#startFrame, length, wsSustain = w.frameFor(ev.startWs.next, ev.numWs);\n\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * ev.repeats;\n\t\t).play;\n\t\t\n\t\t0.1.wait;\t\n\t}\n}).play;\n)\n\nTdef(\\ws1).set(\\startWs, 420);\nTdef(\\ws1).set(\\repeats, 3);\nTdef(\\ws1).set(\\numWs, 2);\n\n\t\t// drop in a pattern for starting waveset \t\t\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\n\n\n\n\n\t// figure 16.30 - waittime from waveset duration, gap\n(\nTdef(\\ws1).set(\\gap, 3);\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps; \n\n\tloop { \n\t\treps = ev.repeats.next;\n\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, ev.numWs.next);\t\t\t\n\t\t\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * reps,\n\t\t\tpan: 1.0.rand2\n\t\t).play;\n\t\t\n\t\t\t// derive waittime from waveset sustain time\n\t\t\t// add gap based on waveset sustain time \n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\t// experiment with dropping in patterns:\n\t// very irregular gaps\nTdef(\\ws1).set(\\gap, { exprand(0.1, 20) });\n\t// sometimes continuous, sometimes gaps\nTdef(\\ws1).set(\\gap, Pbrown(-10.0, 20, 2.0).max(0).asStream);\n\n\t// random repeats\nTdef(\\ws1).set(\\repeats, { exprand(1, 20).round });\n\t// randomize number of wavesets per group\nTdef(\\ws1).set(\\numWs, { exprand(3, 20).round });\nTdef(\\ws1).set(\\numWs, 3, \\repeats, { rrand(2, 5) });\n\nTdef(\\ws1).stop;\n\n\n\n\t// figure 16.31 - add pitch contour and dropout rate\n(\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\nTdef(\\ws1).set(\\gap, 0);\nTdef(\\ws1).set(\\pitchContour, 0);\nTdef(\\ws1).set(\\keepCoin, 1.0);\nTdef( 'ws1' ).set( 'repeats' , 5 );\nTdef( 'ws1' ).set( 'numWs' , 3 );\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps, numWs, len2Avg; \n\tvar squeezer, playRate;\n\tloop { \n\t\treps = ev.repeats.next;\n\t\tnumWs = ev.numWs.next;\n\t\t\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, numWs);\t\t\t\n\t\t\n\t\tlen2Avg = length / numWs / w.avgLength;\t\t\n\t\tsqueezer = len2Avg ** ev.pitchContour.next;\n\t\twsSustain = wsSustain / squeezer; \n\t\tplayRate = 1 * squeezer;\n\n\t\tif (ev.keepCoin.next.coin) { \n\t\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\t\tstart: startFrame, length:  length, \n\t\t\t\tsustain: wsSustain * reps,\n\t\t\t\tplayRate: playRate, \n\t\t\t\tpan: 1.0.rand2\n\t\t\t).play;\n\t\t};\n\t\t\n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\n\t// try different pitch Contours:\nTdef(\\ws1).set(\\pitchContour, 0); \t// original pitch\n\nTdef(\\ws1).set(\\pitchContour, 0.5); // flattened contour\n\n\t\t// waveset overtone singing - all equal length\nTdef(\\ws1).set(\\pitchContour, 1.0); \n\n\t\t// inversion of contour\nTdef(\\ws1).set(\\pitchContour, 1.5);\nTdef(\\ws1).set(\\pitchContour, 2);\nTdef(\\ws1).set(\\repeats, 3); \n\n\t// waveset omission\nTdef(\\ws1).set(\\keepCoin, 0.75);\nTdef(\\ws1).set(\\keepCoin, 1);\n\n\t// fade out by omission over 13 secs, pause 2 secs \nTdef(\\ws1).set(\\keepCoin, Pn(Penv([1, 0, 0], [13, 2])).asStream).play;\n\n\t// add a pitch contour envelope\nTdef(\\ws1).set(\\pitchContour, Pn(Penv([0, 2, 0], [21, 13])).asStream);\n\n\n",
    "Ch1code.scd": "\"Hello world\"\n\nServer.default = s = Server.internal.boot;\n\n/////////////\n\nplay({SinOsc.ar(LFNoise0.kr(12, mul: 600, add: 1000), 0.3)})\n\n/////////////\n\nplay({RLPF.ar(Dust.ar([12, 15]), LFNoise1.ar(1/[3, 4], 1500, 1600), 0.02)})\n\n///////////// Figure 1.1 Example of additive synthesis\n\nplay({\n\tvar sines = 100, speed = 6;\n\tMix.fill(sines, \n\t\t{arg x; \n\t\t\tPan2.ar(\n\t\t\t\tSinOsc.ar(x+1*100, \n\t\t\t\t\tmul: max(0, \n\t\t\t\t\t\tLFNoise1.kr(speed) +\n\t\t\t\t\t\tLine.kr(1, -1, 30)\n\t\t\t\t\t)\n\t\t\t\t), rand2(1.0))})/sines})\n\n/////////////\n\nrand(100)\n\nexprand(1.0, 100.0) \n\nthisThread.randSeed = 666; {rand(10.0)} ! 10;\n\ndup(\"echo\", 20)\n\nround([3.141, 5.9265, 358.98], 0.01)\n\nsort([23, 54, 678, 1, 21, 91, 34, 78])\n\nround(dup({exprand(1, 10)}, 100), 0.1)\n\nsort(round(dup({exprand(1, 10)}, 100), 0.1))\n\n/////////////\n\n                            exprand(1.0, 1000.0)\n                   dup({exprand(1.0, 1000.0)}, 100)\n           sort(dup({exprand(1.0, 1000.0)}, 100))\nround(sort(dup({exprand(1.0, 1000.0)}, 100)), 0.01)\n\n///////////// Figure 1.3 Fortuitous futuristic nested music.\n\n(\nplay(\n\t{\n\t\tCombN.ar(\n\t\t\tSinOsc.ar(\n\t\t\t\tmidicps(\n\t\t\t\t\tLFNoise1.ar(3, 24, \n\t\t\t\t\t\tLFSaw.ar([5, 5.123], 0, 3, 80)\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\t0, 0.4), \n\t\t\t1, 0.3, 2)\n\t}\n)\n)\n\n/////////////\n\n[45, 13, 10, 498, 78].sort // collection of items, do this; sort yourself\n\n\"echo\".dup(20) // echo, do this; repeat yourself 20 times\n\n50.midicps // the number 50, do this; convert yourself into Hz\n\n444.cpsmidi // 444, do this; convert yourself into a midi number\n\n100.rand // 100, do this; pick a number between 0 and yourself\n\n{100.rand}.dup(50) // random picking function, do this; repeat 50 times\n\n[1.001, 45.827, 187.18].round(0.1) // collection of items; round to 0.1\n\n// Mac users only, sorry\n\"I've just picked up a fault in the AE35 unit\".speak // Hal; plot to kill me\n\n/////////////\n\n1000.0 // a number\n\n1000.0.rand // choose a number between 0 and 1000\n\n1000.0.rand.round(0.01) // choose a number and round it\n\n1000.0.rand.round(0.01).post // choose, round, then post\n\n{1000.0.rand.round(0.01).postln}.dup(100).plot // choose, round, dup, plot\n\n{1000.0.rand.round(0.01).postln}.dup(100).postln.sort.plot // choose etc., sort, plot\n\n//Mac only\n1000.0.rand.round(0.01).postln.asString.speak // convert to string and speak\n\n5 + 10 * 4\n\n[0, 11, 10, 1, 9, 8, 2, 3, 7, 4, 6, 5].reverse // retrograde of a 12-tone row\n\n12 - [0, 11, 10, 1, 9, 8, 2, 3, 7, 4, 6, 5].reverse // retrograde inversion\n\n[0, 2, 4, 5, 6, 7, 9, 11].scramble // diatonic scale\n\n[60, 62, 64, 67, 69].mirror // pentatonic\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].rotate\n\n[60, 62, 64, 65, 67, 69, 71].midicps.round(0.1) // convert midi to frequency in Hz\n\n[1, 0.75, 0.5, 0.25, 0.125].choose // maybe durations?\n\n0.125 * [1, 2, 3, 4, 5, 6, 7, 8].choose // multiples of a smallest quantize value\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].permute(6) \n\n/////////////\n\nexprand(1, 1000.0)\n\n{exprand(1, 1000.0)}\n\ndup(rand(1000.0), 5)  // picks a number, duplicates it\n\ndup({rand(1000.0)}, 5)  //duplicates the function of picking a number\n\n// essentially, this (which has a similar result) \n[rand(1000.0), rand(1000.0), rand(1000.0), rand(1000.0), rand(1000.0)]\n\n/////////////\n\n{LFNoise0.ar}.play  //play a series of random numbers\n\n{LFNoise0.ar(10000)}.plot // plot those numbers\n\n{LFNoise0.ar(10000)}.scope // play and show on a scope\n\n{100.rand}.dup(10) // pick 10 random numbers\n\n{100.rand} ! 10 // same as above\n\n{100.rand}.dup(10).postln.plot // pick 10 numbers, post, then plot them\n\n{100.rand}.dup(100).sort.plot // pick 100 numbers, sort them, then plot\n\n/////////////\n\n{Blip.ar(25, LFNoise0.kr(5, 12, 14), 0.3)}.play // single channel\n\n{Blip.ar(25, LFNoise0.kr([5, 10], 12, 14), 0.3)}.play // stereo\n\n{Blip.ar(25, LFNoise0.kr([5, 10, 2, 25], 12, 14), 0.3)}.play // quad\n\n{Blip.ar(25, LFNoise0.kr([5, 4, 7, 9, 5, 1, 9, 2], 12, 14), 0.3)}.play // 8\n\n/////////////\n\n{PMOsc.ar(440, 550, 7)}.play // pretty boring, like an FM radio\n\n{PMOsc.ar(440, MouseY.kr(1, 550), MouseX.kr(1, 15))}.play\n\n{PMOsc.ar(100, 500, 10, 0, 0.5)}.play // all arguments listed in order\n\n{PMOsc.ar(carfreq: 100, modfreq: 500, pmindex: 10, mul: 0.5)}.play // keywords\n\n{PMOsc.ar(carfreq: 100, mul: 0.5, pmindex: 10, modfreq: 500)}.play // mixed\n\n{SinOsc.ar(mul: MouseX.kr(0, 1.0))}.scope\n\n///////////// Figure 1.4 VCO, VCF, VCA\n\n(\n{\n\tBlip.ar(\n\t\tTRand.kr( // frequency or VCO\n\t\t\t100, 1000, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tTRand.kr( // number of harmonics or VCF\n\t\t\t1, 10, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tLinen.kr( // mul, or amplitude, VCA\n\t\t\tImpulse.kr(Line.kr(1, 20, 60)), // trigger\n\t\t\t0, // attack\n\t\t\t0.5, // sustain level\n\t\t\t1/Line.kr(1, 20, 60)) // trigger\n\t\t)\n}.play\n)\n\n/////////////\n\n(\na = 440;\nb = 3;\nc = \"math operations\";\n[c, a, b, a*b, a + b, a.pow(b), a.mod(b)]\n)\n\n// same as\n[\"math operations\", 440, 3, 440*3, 440 + 3, 440.pow(3), 440.mod(3)]\n\n/////////////\n\n(\n{\nr = MouseX.kr(1/3, 10);\nSinOsc.ar(mul: Linen.kr(Impulse.kr(r), 0, 1, 1/r))\n}.play\n)\n\n///////////// Example 1.5 Synthesis example with variables and statements\n\n(\n// run this first\np = { // make p equal to this function\nr = Line.kr(1, 20, 60); // rate\n// r = LFTri.kr(1/10) * 3 + 7;\nt = Impulse.kr(r); // trigger\n// t = Dust.kr(r);\ne = Linen.kr(t, 0, 0.5, 1/r); // envelope uses r and t\nf = TRand.kr(1, 10, t); // triggered random also uses t\n// f = e + 1 * 4;\nBlip.ar(f*100, f, e) // f, and e used in Blip\n}.play\n)\n\np.free;  // run this to stop it\n\n///////////// Figure 1.6 Phase modulation with modulator as ratio\n\n(\n{ // carrier and modulator not linked\n\tr = Impulse.kr(10);\n\tc = TRand.kr(100, 5000, r);\n\tm = TRand.kr(100, 5000, r);\n\tPMOsc.ar(c, m, 12)*0.3\n}.play\n)\n\n(\n{\n\tvar rate = 4, carrier, modRatio; // declare variables\n\tcarrier = LFNoise0.kr(rate) * 500 + 700;\n\tmodRatio = MouseX.kr(1, 2.0);\n\t// modulator expressed as ratio, therefore timbre\n\tPMOsc.ar(carrier, carrier*modRatio, 12)*0.3\n}.play\n)\n\n/////////////\n\n{SinOsc.ar}.play // generates a temp__reallyLongNumber name\n\n// names the synth and output bus 0 (left) explicitly\nSynthDef(\"sine\", {Out.ar(0, SinOsc.ar)}).play\n\nSynthDef(\"sine\", {Out.ar(1, SinOsc.ar)}).play // right channel\n\n// or\n\n(\nSynthDef(\"one_tone_only\", {\n\tvar out, freq = 440;\n\tout = SinOsc.ar(freq);\n\tOut.ar(0, out)\n}).play\n)\n\n// then to play it\n\nSynth(\"one_tone_only\");\n\n/////////////\n\n(\nSynthDef(\"different_tones\", {\n\targ freq = 440; // declare an argument and give it a default value\n\tvar out; \n\tout = SinOsc.ar(freq)*0.3;\n\tOut.ar(0, out)\n}).play\n)\n\n/////////////\n\n// Run all four, then stop all \n\nSynth(\"different_tones\", [\"freq\", 550]);\n\nSynth(\"different_tones\", [\\freq, 660]); // same as \"freq\"\n\nSynth(\"different_tones\", [\"freq\", 880]);\n\n// If no argument is specified, defaults are used (440)\nSynth(\"different_tones\")\n\n/////////////\n\na = Synth(\"different_tones\", [\"freq\", 64.midicps]);\n\nb = Synth(\"different_tones\", [\"freq\", 67.midicps]);\n\nc = Synth(\"different_tones\", [\"freq\", 72.midicps]);\n\na.set(\"freq\", 65.midicps);\n\nc.set(\"freq\", 71.midicps);\n\na.set(\"freq\", 64.midicps); c.set(\"freq\", 72.midicps);\n\na.free; \n\nb.free; \n\nc.free;\n\n///////////// Figure 1.7 Synth definition\n\n(\n//run this first\nSynthDef(\"PMCrotale\", {\narg midi = 60, tone = 3, art = 1, amp = 0.8, pan = 0; \nvar env, out, mod, freq;\n\nfreq = midi.midicps;\nenv = Env.perc(0, art);\nmod = 5 + (1/IRand(2, 6));\n\nout = PMOsc.ar(freq, mod*freq, \n\tpmindex: EnvGen.kr(env, timeScale: art, levelScale: tone), \n\tmul: EnvGen.kr(env, timeScale: art, levelScale: 0.3));\n\nout = Pan2.ar(out, pan);\n\nout = out * EnvGen.kr(env, timeScale: 1.3*art, \n\tlevelScale: Rand(0.1, 0.5), doneAction:2);  \nOut.ar(0, out); //Out.ar(bus, out);\n\n}).add;\n)\n\n//Then run this a bunch of times:\n\nSynth(\"PMCrotale\", [\"midi\", rrand(48, 72).round(1), \"tone\", rrand(1, 6)])\n\n\n~houston = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\n~chooston = Buffer.read(s, \"sounds/a11wlk01.wav\");\n\n{PlayBuf.ar(1, ~houston)}.play; // number of channels and buffer.\n\n{PlayBuf.ar(1, ~chooston)}.play; // number of channels and buffer.\n\n///////////// Figure 1.8 Playback buffers\n\n[~houston.bufnum, ~houston.numChannels, ~houston.path, ~houston.numFrames];\n\n[~chooston.bufnum, ~chooston.numChannels, ~chooston.path, ~chooston.numFrames];\n\n(  // phasing\n{\n\tvar rate, trigger, frames;\n\tframes = ~houston.numFrames; // or use ~chooston.numFrames\n\n\trate = [1, 1.01];\n\ttrigger = Impulse.kr(rate);\n\tPlayBuf.ar(1, ~houston, 1, trigger, frames * Line.kr(0, 1, 60)) * \n\tEnvGen.kr(Env.linen(0.01, 0.96, 0.01), trigger) * rate;\n}.play;\n)\n\n/////////////\n\n(  // speed and direction change\n{\n\tvar speed, direction;\n\tspeed = LFNoise0.kr(12) * 0.2 + 1;\n\tdirection = LFClipNoise.kr(1/3);\n\tPlayBuf.ar(1, ~houston, (speed * direction), loop: 1);\n}.play;\n)\n\n///////////// Figure 1.9 Connecting controls with a bus\n\n(\n// if these haven't been used they will hold 0\n~kbus1 = Bus.control; // a control bus\n~kbus2 = Bus.control; // a control bus\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tPlayBuf.ar(1, ~chooston, (speed * direction), loop: 1);\n}.play;\n)\n\n(\n// Start the controls\n{Out.kr(~kbus1, LFNoise0.kr(12))}.play;\n\n{Out.kr(~kbus2, LFClipNoise.kr(1/4))}.play;\n)\n\n// Start the second buffer with the same control input buses, \n// but send it to the right channel using Out.ar(1 etc.\n\n(\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tOut.ar(1, PlayBuf.ar(1, ~houston, (speed * direction), loop: 1));\n}.play;\n)\n\n/////////////\n\n~kbus3 = Bus.control; // a control bus\n\n~kbus4 = Bus.control; // a control bus\n  // run these one at a time, (turn down the speakers!)\n\n{Out.kr(~kbus3, SinOsc.kr(3).scope(\"out3\") * 100)}.play; \n\n{Out.kr(~kbus4, LFPulse.kr(1/3).scope(\"out4\") * 200)}.play;\n\n{Out.ar(0, SinOsc.ar(In.kr(~kbus3) + In.kr(~kbus4) + 440).scope(\"left\"))}.play;\n\n{Out.ar(1, SinOsc.ar(In.kr(~kbus3) + In.kr(~kbus4) + 880).scope(\"right\"))}.play;\n\n~kbus3 = Bus.control; // a control bus \n\n~kbus4 = Bus.control; // a control bus \n\n{Out.kr(~kbus3, SinOsc.kr(3).range(340, 540))}.play;\n\n{Out.kr(~kbus4, LFPulse.kr(6).range(240, 640))}.play;\n\nSynthDef(\"Switch\", {arg freq = 440; Out.ar(0, SinOsc.ar(freq, 0, 0.3)) }).add;\n\nx = Synth(\"Switch\"); // default\n\nx.map(\\freq, ~kbus3)\n\nx.map(\\freq, ~kbus4)\n\n///////////// Figure 1.10 Buffer modulation\n\n(\n{\n\tOut.ar(0,\n\t\tPan2.ar( PlayBuf.ar(1, ~houston, loop: 1) * \n\t\t\tSinOsc.ar(LFNoise0.kr(12, mul: 500, add: 600)),\n\t\t0.5)\n\t)\n}.play\n)\n\n(\n{\nvar source, delay; \n\tsource = PlayBuf.ar(1, ~chooston, loop: 1);\n\tdelay =  AllpassC.ar(source, 2, [0.65, 1.15], 10);\n\tOut.ar(0,\n\tPan2.ar(source) + delay\n\t)\n}.play\n)\n\n///////////// Figure 1.11 FX routing using buses.\n\n// Create and name buses \n~delay = Bus.audio(s, 2);\n~mod = Bus.audio(s, 2);\n~gate = Bus.audio(s, 2);\n~k5 = Bus.control;\n\n{Out.kr(~k5, LFNoise0.kr(4))}.play; // start the control\n\n// Start the last item in the chain, the delay\n{Out.ar(0, AllpassC.ar(In.ar(~delay, 2), 2, [0.65, 1.15], 10))}.play \n\n// Start the next to last item, the modulation\n{Out.ar(~delay, In.ar(~mod, 2) * SinOsc.ar(In.kr(~k5)*500 + 1100))}.play\n\n// Start the third to last item, the gate\n{Out.ar([0, ~mod], In.ar(~gate, 2) * max(0, In.kr(~k5)))}.play\n\n// Start one buffer\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~houston, loop: 1), 0.5))}.play;\n\n// Start the other\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~chooston, loop: 1), -0.5))}.play\n\n/////////////\n\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B \"];\n\na.at(8);\n\n\"Item at index 5 is: \".post; a.at(5).postln; // why didn't it print E?\n\n\"Item at index 0 is: \".post; a.at(0).postln; // because we start with 0\n\ndo(50, { [0, 2, 4, 5, 7, 9, 11].at(7.rand).postln})\n\ndo(50, { [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"].at(7.rand).postln})\n\n///////////// \n\nTask({\n\t50.do({\n\t\t[\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"].at(7.rand).postln;\n\t\t1.wait;\n\t});\n}).play\n\n///////////// Figure 1.12 Random MIDI walk.\n\nTask({\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"count, midi, pitch, octave\".postln;\n\tdo(50, {arg count;\n\t\tp = rrand(36, 72);\n\t\t[count, p, a.wrapAt(p), (p/12).round(1) - 1].postln;\n\t1.wait;\n\t})\n}).play\n\n///////////// 1.13 Random Crotale Walk\n\n// This uses the PMCrotale synth definition\n(\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"event, midi, pitch, octave\".postln;\nr = Task({\n\tinf.do({ arg count;\n\t\tvar midi, oct, density;\n\t\tdensity = 1.0; // 100% of the time. Uncomment below for 70%, etc.\n\t\t// density = 0.7; \n\t\t// density = 0.3;\n\t\tmidi = [0, 2, 4, 7, 9].choose;\n\t\t// midi = [0, 2, 4, 5, 7, 9, 11].choose;\n\t\t// midi = [0, 2, 3, 5, 6, 8, 9, 11] .choose; \n\t\t// midi = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] .choose;\n\t\toct = [48, 60, 72].choose;\n\t\tif(density.coin, \n\t\t\t{ // true action\n\t\t\t\t\"\".postln;\n\t\t\t\t[midi + oct, a.wrapAt(midi), \n\t\t\t\t(oct/12).round(1)].post;\n\t\t\t\tSynth(\"PMCrotale\", \n\t\t\t\t\t[\"midi\", midi + oct, \"tone\", rrand(1, 7), \n\t\t\t\t\t\"art\", rrand(0.3, 2.0), \"amp\", rrand(0.3, 0.6), \"pan\", 1.0.rand2]);\n\t\t\t}, {[\"rest\"].post}); // false action\n\t\t0.2.wait; \n\t}); \n}).start\n)\n\nr.stop; // run this to stop\n\n/////////////\n\nif(10 == 10, {\"10 is indeed equal to 10\"}, {\"false\"})\n\nif((1 < 20).and(1.isInteger), {\"1 is less than 20\"}, {\"false\"})\n\n10.do({arg count; [count, if(count.odd, {\"odd\"}, {\"even\"})].postln})\n\n(\n84.do({arg count; if([0, 4, 7].includes(count%12), \n\t{count.post; \" is part of a C triad.\".postln}, \n\t{count.post; \" is not part of a C traid\".postln})})\n)\n\n50.do({if(1.0.rand.round(0.01).post > 0.5,  {\" > 0.5\".postln}, {\" < 0.5\".postln})})\n\n50.do({if(1.0.rand > 0.5,  {\"play a note\".postln}, {\"rest\".postln})})\n\n50.do({if(0.5.coin, {\"play a note\".postln}, {\"rest\".postln})}) // same as above\n\nif((10.odd).or(10 < 20), {\"true\".postln}, {\"false\".postln})\n\n/////////////\n\nArray.fill(100, {wchoose([1, 2, 3, 4], [0.5, 0.3, 0.125, 0.075])}).sort\n\n/////////////\n\n[0, 2, 4, 5, 7, 9, 11].do({arg each, count; [\"count\", count, \"each\", each].postln})  \n// same\n[0, 2, 4, 5, 7, 9, 11].do({arg whatever, blech; [blech, whatever].postln})\n\n(\nvar pc;\npc = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n[0, 2, 4, 5, 7, 9, 11].do({arg each; pc.wrapAt(each).postln;})\n)\n\n///////////// Figure 1.14 Nested do to generate a 12-tone matrix.\n\n(\nvar row, inversion, pitchClass;\nrow = Array.series(11, 1).scramble.insert(0, 0); \n// or enter your own row, e.g. Webern's Op 27\n// row = [0, 11, 8, 2, 1, 7, 9, 10, 4, 3, 5, 6]; \nrow.postln;\ninversion = 12 - row;\n// I add spaces to the strings for a tidy row\npitchClass = [\"C  \", \"C# \", \"D  \", \"Eb \", \n\t\"E  \", \"F  \", \"F# \", \"G  \", \"Ab \", \"A  \", \"Bb \", \"B  \"];\ninversion.do({arg eachInv;\n\tvar trans;\n\ttrans = (row + eachInv); \n\t// prints just pitch class\n\ttrans.do({arg scaleDegree; pitchClass.wrapAt(scaleDegree).post});\n\t//\"\".postln; // uncomment these line if you want to do both\n\t// prints just numbers\n\t//trans.do({arg scaleDegree; (scaleDegree%12).post; \" \".post});\n\t\"\".postln;\n\t});\n\"\".postln\n)\n\n/////////////\n\n{LFNoise1.ar(5000)}.plot // random wave \n\n{max(0, LFNoise1.ar(5000))}.plot // return only positive values\n\n(\n{\nvar ampCont;\nampCont = max(0, LFNoise1.kr(12)); // slow it down for LFO control\nSinOsc.ar(440, mul: ampCont)\n}.scope\n)\n\n///////////// Figure 1.15 Example of additive synthesis\n\n// Mix down a few of them tuned to harmonics:\n\n(\n{\nvar fund = 220;\nMix.ar(\n\t[\n\tSinOsc.ar(220, mul: max(0, LFNoise1.kr(12))),\n\tSinOsc.ar(440, mul: max(0, LFNoise1.kr(12)))*1/2,\n\tSinOsc.ar(660, mul: max(0, LFNoise1.kr(12)))*1/3,\n\tSinOsc.ar(880, mul: max(0, LFNoise1.kr(12)))*1/4,\n\tSinOsc.ar(1110, mul: max(0, LFNoise1.kr(12)))*1/5,\n\tSinOsc.ar(1320, mul: max(0, LFNoise1.kr(12)))*1/6\n\t]\n)*0.3\n}.play\n)\n\n///////////// Figure 1.16 Example of additive synthesis\n\n// Try this first\nArray.fill(20, {arg cnt; cnt + 1*110}); // harmonics built on 440\n\n// And a patch\n(\n{Mix.ar(\n\tArray.fill(12, \n\t\t{arg count; \n\t\tvar harm;\n\t\tharm = count + 1 * 110; // remember precedence; count + 1, then * 110\n\t\t\tSinOsc.ar(harm, \n\t\t\t\tmul: max([0, 0], SinOsc.kr(count+1/4))\n\t\t\t\t)*1/(count+1)\n\t\t})\n)*0.7}.play\n)\n\n///////////// Figure 1.18 Physically modeled bells. \n\n// Try this first, to illustrate the array of arrays.\n\nArray.fill(3, {Array.fill(10, {rand(1000)})})\t\n// Then this patch.\n(\n{\nvar scale, specs, freqs, amps, rings, \n\tnumRes = 5, bells = 20, pan; \nscale = [60, 62, 64, 67, 69].midicps;\n\tMix.fill(bells, {\n\t\tfreqs = Array.fill(numRes, {rrand(1, 15)*(scale.choose)});\n\t\tamps = Array.fill(numRes, {rrand(0.3, 0.9)});\n\t\trings = Array.fill(numRes, {rrand(1.0, 4.0)});\n\t\tspecs = [freqs, amps, rings].round(0.01);\n\t\t// specs.postln;\n\t\tpan = (LFNoise1.kr(rrand(3, 6))*2).softclip;\n\t\tPan2.ar( \n\t\t\tKlank.ar(`specs, \n\t\t\t\tDust.ar(1/6, 0.03)), \n\t\t\t\tpan)\n\t})\n}.play;\n) \n\n///////////// Figure 1.19 Generative sequences using arrays\n\n( // first define the synth\n\nSynthDef.new(\"SimpleBlip\", { \narg midi = 60, tone = 10, art = 0.125, amp = 0.2, pan = -1;\nvar out, temper;\t\nout =\tPan2.ar(\n\t\t\tBlip.ar( // play the sequence\n\t\t\t\tmidi.midicps,\n\t\t\t\ttone\n\t\t\t\t) * EnvGen.kr(Env.perc(0.01, art)),\n\t\tpan // pan left, center, or right\n\t);\nDetectSilence.ar(out, doneAction:2);\namp = amp - ((midi - 60) * 0.02);\nOut.ar(0, out*amp)\n\t}).add;\n)\n\n/////////////\n \n(\n// Then run this Task\n~inst = [0, 0, 0]; // Three containers for tasks\n~pSeq = [0, 0, 0]; // Three containers for sequences\n~scaleAdd = [4, 5, 11, nil, 10, 3, 6, nil]; // \n~notes = \n[\" C\", \" C#\", \" D\", \" Eb\", \" E\", \" F\", \n\t\" F#\", \" G\", \" Ab\", \" A\", \" Bb\", \" B\"]; \n~rout = Task({\n\tinf.do({\n\t\targ cnt1; \n\t\tvar steps, durSeq, harmSeq;\n\t\tsteps = rrand(6, 12);\n\t\tif(cnt1%6 == 0, // every sixth iteration, add a degree\n\t\t\t{~scale = ~scale.add(~scaleAdd.wrapAt((cnt1/6).round(1) - 1));}); \n\t\t\"\\nIteration: \".post; cnt1.post; \n\t\t[\" (center) \", \" (right) \", \" (left) \"].wrapAt(cnt1).postln;\n\t\tif(cnt1%24 == 0, // reset all three\n\t\t\t{~scale = [0, 2, 7, 9]; \n\t\t\t3.do({arg cnt2; \n\t\t\t\t~pSeq.wrapPut(cnt2, \n\t\t\t\t\tArray.fill(steps, \n\t\t\t\t\t\t{~scale.choose + [48, 60].choose}))})});\n\t\t\"scale: \".post; ~scale.postln;\n\t\t~pSeq.wrapPut(cnt1, // fill array with scale steps\n\t\t\tArray.fill(steps, {~scale.choose + [48, 60].choose}));\n\t\t\"MIDI seq: \".post; (~pSeq.wrapAt(cnt1)%12).postln;\n\t\t\"Sequence (notes): \".post; \n\t\t~pSeq.wrapAt(cnt1).do( // print the sequence using note names\n\t\t\t{arg thisItem; ~notes.at(thisItem%12).post}); \n\t\t\"\".postln;\n\t\t// create harmonic and duration arrays\n\t\tharmSeq = Array.fill(steps, {rrand(1.0, 5.0)});\n\t\tdurSeq = Array.fill(steps - 1, {rrand(0.01, 0.9)});\n\t\t// stop the previous task at this array position\n\t\t~inst.wrapAt(cnt1).stop;\n\t\t~inst.wrapPut(cnt1, \n\t\t\tTask({\n\t\t\t\tinf.do({arg cnt3; // each sequence\n\t\t\t\t\tSynth(\"SimpleBlip\", \n\t\t\t\t\t\t[\\midi, ~pSeq.wrapAt(cnt1).wrapAt(cnt3), \n\t\t\t\t\t\t\\tone, harmSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\art, durSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\amp, rrand(0.1, 0.3), \n\t\t\t\t\t\t\\pan, cnt1.wrap(-1, 2)]);\n\t\t\t\t\t0.125.wait; // tempo of each note\n\t\t\t\t})}).start;\n\t\t);\n\t\t12.wait;})\n}).start; // time between each new sequence\n)\n\n~rout.stop; // stop new sequences\n\n~inst.at(0).free; // at any time, stop center sequence\n\n~inst.at(1).free; // stop right sequence\n\n~inst.at(2).free; // stop center sequence\n\n/////////////\n\nServer.internal.prepareForRecord; // or Server.local\n\nServer.internal.record;\n\nServer.internal.stopRecording;\n\n// Run these variations before to change file formats.\nServer.internal.recSampleFormat = \"int16\"; // change format\n\nServer.internal.recChannels = 1; // change from the default stereo\n// saves file in the SC folder, will be overwritten if repeated\n\nServer.internal.prepareForRecord(\"myAudio.aif\"); \n\n///////////// Figure 1.20 Offset and scale\n\n(\n\t{\n\tvar trigger, wave, label, scale, offset;\n\ttrigger = Impulse.kr(10);\n\twave = SinOsc.kr(1/10) ; // change to 400\n\tscale = 1; offset = 0;\n//\twave = wave * scale + offset; \n\tlabel = \"scale = \" ++ scale.asString ++ \", offset = \" ++ offset.asString;\n\twave.round(0.01).poll(label: label);\n\t}.scope(1)\n)\n\n///////////// Figure 1.21 SinOsc offset and scaled for control\n\n(\n\t{\n\tvar trigger, control, scale, offset;\n\tscale = 300; // try other values, but not greater than offset\n\toffset = 600; // try other values\n\ttrigger = Impulse.kr(10);\n\tcontrol = SinOsc.ar(1/4).scope(\"control\"); // LFO\n\tcontrol = control  * scale + offset;\n\tSinOsc.ar(freq: abs(control).poll).scope(\"audio\")\n\t}.play\n) \n\n// Speaking of vibrato, I can't resist this faux Theremin. Play it with the Mouse: \n\n{SinOsc.ar(SinOsc.ar(8, 0, 10, MouseX.kr(400, 1000, 1)))}.play\n\n///////////// Figure 1.22 Test you skills on a patch\n\n(\n{\n\tvar carrier, rate, trigger, modRatio, index, control, env;\n\trate = 3;\n\ttrigger = Impulse.kr(rate);\n\tcontrol = LFNoise0.kr(rate);\n\tcarrier = 62;\n\tmodRatio = 4.125;\n\tindex = 10;\n\tcarrier = carrier.midicps;\n\tcarrier.poll(trigger, \"carrier\"); \n\tindex.poll(trigger, \"index\"); \n\tmodRatio.poll(trigger, \"modRatio\");\n\tPMOsc.ar(carrier, carrier*modRatio, index)\n}.play\n)\n\n///////////// Figure 1.23 PMOsc with offset and scale. \n\n(\na = SynthDef(\"PMOsc_ex\", \n{\n\targ left = 10, right = 10, indexLow = 4, indexHigh = 12;\n\tvar pitch, timbre, trigger, env, index, out;\n\ttrigger = Impulse.kr([left, right]); // trigger\n\tpitch = TRand.kr(36, 72, trigger).round(1); // C2 to C6\n\ttimbre = LFNoise0.kr(1/20, mul: 0.2, add: 2); // mod control\n\tenv = Linen.kr(trigger, releaseTime: 1/[left, right]); // envelope\n\tindex = env * indexHigh + indexLow; // env scaled and offset for index\n\tpitch = pitch.midicps; // midi converted to freq\n\tout = PMOsc.ar(pitch, pitch*timbre, index, mul: env);\n\tOut.ar(0, out);\n}).play\n)\n\na.set(\"left\", 4)\n\na.set(\"right\", 5)\n\na.set(\"indexLow\", 1)\n\na.set(\"indexHigh\", 4)\n\n///////////// Figure 1.24 PMOsc with sample and hold (latch).\n\n(\n// run this first\na = SynthDef(\"Latch_demo\",\n{\narg rate = 9; \nvar freq, latchrate, index, ratio, env, out;\nlatchrate = rate*LFNoise0.kr(1/10, mul: 0.03, add: 1.6);\nindex = Latch.kr(\n\tLFSaw.kr(latchrate, mul: 5, add: 6),\n\tImpulse.kr(rate)\n\t);\nfreq = Latch.kr(\n\tLFSaw.kr(latchrate, \n\tmul: max(0, LFNoise1.kr(1/5, mul: 24, add: 10)), \n\tadd: LFNoise0.kr(1/7, mul: 12, add: 60)),\n\tImpulse.kr(rate)\n\t).round(1).midicps;\n\nratio = LFNoise1.kr(1/10, mul: 2.0, add: 5.0);\n\nenv = EnvGen.kr(\n\tEnv.perc(0, LFNoise0.kr(rate, mul: 1, add: 1.5)/rate), \n\tImpulse.kr(rate), \n\tLFNoise1.kr([5, 5], 2, 1).max(0).min(0.8));\nout = PMOsc.ar(\n\t[freq, freq * 1.5],\n\tfreq*ratio,\n\tindex,\n\tmul: env\n);\nOut.ar(0, out);\n}\n).play\n)\n\na.set(\"rate\", 10)\n\na.set(\"rate\", 15)\n\na.set(\"rate\", 6)\n\na.free;\n\n///////////// Figure 1.25 It's just a bell.\n\n(\n{ // it's just a bell\nvar burst, burstEnv, bell, delay, dry, \nburstFreq = 500, freqs, amps, rings;\nburstEnv = EnvGen.kr(Env.parc(0, 0.05),\n\t\t\t\tDust.kr(1/5), 0.1);\n// burstEnv.poll(100, \"env\");\nburst = SinOsc.ar(freq: burstFreq,\n\tmul: burstEnv);\n// burst.poll(100, \"burst\");\nfreqs = Array.fill(10, {exprand(100, 1000)});\namps = Array.fill(10, {rrand(0.01, 0.1)});\nrings = Array.fill(10, {rrand(1.0, 6.0)});\n// [freqs, amps, rings].round(0.01).postln;\n// \"safe\" values\n// freqs = [100, 200, 300, 400];\n// amps = [1, 1, 1, 1];\n// rings = [1, 1, 1, 1];\n\nbell = Pan2.ar(\n\tKlank.ar(`[freqs, amps, rings], burst), \n\trrand(-1.0, 1.0)\n);\n\ndelay = AllpassN.ar(bell, 2.5, \n\t[LFNoise1.kr(7, 1.5, 1.6), LFNoise1.kr(7, 1.5, 1.6)], \n\t1, mul: 0.8);\nbell \n+ delay\n// + SinOsc.ar(mul: LFPulse.kr(1) * 0.05);\n}.play\n)\n\n",
    "extra examples.scd": "\n// Decaying bell. Run several concurrently. \n\n(\n{\nvar aenv, fenv, out, trig, dur, base;\ndur = rrand(1.0, 6.0);\nbase = exprand(100, 1000);\ntrig = Impulse.kr(1/6);\nout = Mix.ar(\n\tArray.fill(15,{\n\t\targ count;\n\t\tvar thisDur;\n\t\tthisDur = dur * rrand(0.5, 1.0);\n\t\taenv = EnvGen.kr(\n\t\t\tEnv.new([0, 1, 0.4, 1, 0], [0, 0.5, 0.5, 0]), trig, \n\t\t\ttimeScale: thisDur);\n\t\tfenv = EnvGen.kr(\n\t\t\tEnv.new([0, 0, 0.5, 0.5, 0], [0.25, 0.5, 0.25, 0]), \n\t\t\t\ttrig, timeScale: thisDur);\n\t\tPan2.ar(SinOsc.ar( Rand(base, base * 12) * \n\t\t\tLFNoise1.kr(10, mul: 0.1 * fenv, add: 1), // freq\n\t\t\tmul: aenv // amp\n\t\t), ([1, -1].choose) * fenv)\n\t})\n) * EnvGen.kr(Env.linen(0, dur, 0), Impulse.kr(6), timeScale: dur, \n\t\tlevelScale: 0.05, doneAction: 2);\nout*0.3;\n}.play;\n)\n\n\n// Repeating gestures using PM crotales.\n\n(\nSynthDef(\"crotale\", {\narg param = #[500, 3, 2, 0, 6, 5, 0, 0.9]; \nvar factor, env, out, freq, index, dur;\nvar bus, ratioa, ratiob, attack, decay, panCont;\nfreq = param.at(0); index = param.at(1); dur = param.at(2);\nbus = param.at(3); ratioa = param.at(4); ratiob = param.at(5);\nattack = param.at(6); decay = param.at(7);\n\nenv = Env.perc(attack, decay);\nfactor = gcd(ratioa, ratiob);\nratioa = div(ratioa, factor); \nratiob = div(ratiob, factor);\n\npanCont = (EnvGen.kr(env, timeScale: dur*1.1, \n\tlevelBias: -1, levelScale: 2))\n\t\t\t* (IRand(0, 1) * 2 - 1);  // 0*2-1 = -1, 1*2-1 = 1\n\nout = PMOsc.ar(\n\tratioa*freq, //or try ratioa*freqCont,\n\tratiob*freq, //or try ratioa*freqCont,\n\tpmindex: EnvGen.kr(env, timeScale: dur, \n\t\tlevelBias: 1, levelScale: index), \n\tmul: EnvGen.kr(env, timeScale: dur, levelScale: 0.3));\n\nout = Pan2.ar(out, panCont);\n\nout = out * EnvGen.kr(env, timeScale: 1.3*dur, \n\tlevelScale: Rand(0.1, 0.5), doneAction:2);  \nOut.ar(0, out); //Out.ar(bus, out);\n\n}).add;\n)\n\n// Define the instrument by running the code\n// above, then run this task to actually play \n// the instrument. Run several concurrently.\n\n\n(\nr = Task({\n\tvar freq, indexDepth, indexRange, synthIndex, dur, repeat;\n\tvar next, count, countDown, offset, ratioa, ratiob, envs, env;\n\tvar range = 60, outBus = 0;\n\tcount = 0; countDown = 0; offset = 0;\n\tenvs = [[0, 0.9], [0.01, 0.9], [0.1, 0.8], [0.8, 0.01]];\n\trepeat = Array.fill(10, \n\t\t{[rrand(range, range+24).round(1).midicps, 3, \n\t\t\t2.1 - exprand(0.1, 2.0), 0, 1, 1, 0, 0.9]});\n\tnext = Array.fill(10, {[3, 0.75, 0.5, 0.25, 0.125].choose});\n\tfreq = rrand(range, range*2); // these two are just starting points\n\tindexDepth = 1;\n\t\n\tinf.do({\n\t\tif(countDown <= 0,\n\t\t\t{\n\t\t\tenv = envs.choose;\n\t\t\tnext.put(count%10, [3, 0.5, 0.25, 0.125, 0.125].choose); \n\t\t\trepeat.put(count%10, [\n\t\t\t\trrand(range, range + 24).round(1).midicps, \n\t\t\t\trrand(0.1, 12.0),\n\t\t\t\t2.1 - exprand(0.1, 2.0), outBus, rrand(1, 12),  \n\t\t\t\trrand(1, 12), env.at(0), env.at(1)]);\n\t\t\t});\n\t\t\t\n\t\t\tSynth(\"crotale\").setn(\\param, repeat.wrapAt(count));\n\t\t\tnext.wrapAt(count).wait;   \n\t\t\tif((count > 10).and(countDown <= 0), \n\t\t\t\t{offset = countDown = [0, 3.rand, 6.rand].choose; \n\t\t\t\tcount = count - offset});\n\tcount = count + 1;\n\tcountDown = countDown - 1;\n\t});\n}).play(SystemClock);\n)\n\n\n\n",
    "chapter10code.scd": "// Chapter 10 - SwingOSC\n\n// --------\n// -------- SECTION 2 - INSTALLATION --------\n// --------\n\n//////// configuring startup file\n// execute the next line only if you need to explicitly specify a java version\nSwingOSC.java = \"<javaPath>/java\";\t// replace <javaPath> here!\nSwingOSC.program = \"<installPath>/SwingOSC.jar\";   // replace <installPath> here!\ng = SwingOSC.default;\n\n// --------\n// -------- SECTION 3 - A SIMPLE GUI EXAMPLE --------\n// --------\n\n//////// booting SwingOSC\ng.boot;\n// wait until the \"SwingOSC : server connected.\" message appears!\n\n//////// creating and opening a window\n~win = JSCWindow.new;\n~win.front;\n\n//////// adding a two-state button\n(\n~playButton = JSCButton( ~win, Rect( 4, 4, 40, 56 ));\n~playButton.states = [[ \"Play\", Color.white, Color.green( 0.4 )],\n                      [ \"Stop\", Color.white, Color.red ]];\n~playButton.action = { arg view; \"New value is %\\n\".postf( view.value )};\n)\n\n//////// Figure 10.1\n// boot the sound synthesis server and prepare a SynthDef for buffer playback\n(\ns.waitForBoot({\n    SynthDef( \\bufPlay, { arg buf, amp = 1.0, speed = 1.0;\n        Out.ar( 0, Pan2.ar( PlayBuf.ar( 1, buf, speed * BufRateScale.kr( buf ), loop: 1 ) * amp ));\n    }).send( s );\n    ~buf = Buffer.read( s, \"sounds/a11wlk01.wav\" );\n});\n)\n\n// now replace the action function\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf ]);\n    }, {\n        ~node.free; ~node = nil;\n    })\n};\n)\n\n//////// Figure 10.2\n~amp   = 0.5;  // initial amplitude\n~speed = 1.0;  // initial speed (1.0 is normal, 0.5 is half-speed, etc.)\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf, \\amp, ~amp, \\speed, ~speed ]);\n    }, {\n        ~node.free; ~node = nil;\n    })};\n)\n~win.setInnerExtent( 360, 72 );  // more suitable dimensions for the window\n~win.resizable = false;\nJSCStaticText( ~win, Rect( 56, 4, 50, 25 )).align_( \\right ).string_( \"Amp:\" );\n(\n~ampSlider = JSCSlider( ~win, Rect( 110, 4, 200, 25 ))\n    .value_( ~amp ) // initial slider position\n    .action_({ arg view;\n        ~amp = view.value;\n        ~node.set( \\amp, ~amp );\n    });\n)\nJSCStaticText( ~win, Rect( 56, 32, 50, 25 )).align_( \\right ).string_( \"Speed:\" );\n~speedSpec = ControlSpec( 1/8, 8, \\exp );\n(\n~speedSlider = JSCSlider( ~win, Rect( 110, 32, 200, 25 ))\n    .value_( ~speedSpec.unmap( ~speed ))  // initial slider position\n    .action_({ arg view;\n        ~speed = ~speedSpec.map( view.value );\n        ~node.set( \\speed, ~speed );\n    });\n)\n\n//////// alternative verbose version\n// this is an alternative variant that should not be executed:\n~label = JSCStaticText( ~win, Rect( 56, 4, 50, 25 ));\n~label.align = \\right;\n~label.string = \"Amp:\";\n\n//////// remove the variant if you accidentally executed its code\n~label.remove;\n\n// --------\n// -------- SECTION 4 - USING THE MODEL-VIEW-CONTROLLER PATTERN --------\n// --------\n\n//////// Figure 10.4\n~node.free; ~node = nil;\n\n(\n~model        = Event.new;\n~model.amp    = ~amp;\n~model.speed  = ~speed;\n~model.node   = ~node;\n~model.buf    = ~buf;\n~model.adjust = { arg mod, key, value, source;\n    mod.put( key, value );\n    mod.changed( key, value, source )};\n\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\amp, value )}, \\amp );\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\speed, value )}, \\speed );\n\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~model.node = Synth( \\bufPlay, [\n            \\buf, ~model.buf, \\amp, ~model.amp, \\speed, ~model.speed ]);\n    }, {\n        ~model.node.free; ~model.node = nil;\n    })};\n~ampSlider.action   = { arg view;\n    ~model.adjust( \\amp, view.value, view )};\n~speedSlider.action = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( view.value ), view )};\n)\n\n//////// Figure 10.5\n(\n~ampText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 4, 50, 25 ));\n~ampTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~ampText.string = \"% dB\".format( value.ampdb.round( 0.1 ))}, \\amp );\n~speedText = JSCStaticText( ~win, Rect( ~speedSlider.bounds.right + 2, 32, 50, 25 ));\n~speedTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~speedText.string = \"%\\\\%\".format( (value * 100).round( 0.1 ))}, \\speed );\n)\n// note: the sliders must be initially dragged to cause view updates!\n\n//////// algorithmic controller\n(\n~ctrlFunc = { 60.do({\n\t~model.adjust( \\speed, exprand( 1/8, 8 ), thisFunction );\n\t0.1.wait })};\n)\n~ctrlFunc.fork;\t// run as a Routine\n\n//////// Figure 10.7\n(\n~ampSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~ampSlider, {\n        ~ampSlider.value = value;\n    })}, \\amp );\n~speedSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~speedSlider, {\n        ~speedSlider.value = ~speedSpec.unmap( value );\n    })}, \\speed );\n)\n\n//////// remove observers when views close\n~ampSlider.onClose   = { ~ampSliderUpd.remove };\n~speedSlider.onClose = { ~speedSliderUpd.remove };\n~ampText.onClose     = { ~ampTextUpd.remove };\n~speedText.onClose   = { ~speedTextUpd.remove };\n\n//////// MVC is complete\n~ctrlFunc.fork;\n\n// --------\n// -------- SECTION 5 - UNDER THE HOOD - THE INNER WORKINGS OF SWINGSOSC --------\n// --------\n\n// --------\n// -------- SECTION 6 - RESPONDERS AND ASYNCHRONICITY --------\n// --------\n\n//////// seeing which messages are sent by the responders back to the client\ng.dumpOSC( 0, 1 );\n// if the \"/info\" messages are bothering, stop alive-thread\ng.stopAliveThread;\n// turning it off again\ng.dumpOSC( 0, 0 );\n\n//////// wait requires code to be run inside a Routine\n2.wait; \"hello\".postln;           // not allowed! (\"yield was called outside of a Routine.\")\nfork { 2.wait; \"hello\".postln };  // ok!\n\n// --------\n// -------- SECTION 7 - EXTENDING THE GUI REPERTOIRE USING JSCUSERVIEW --------\n// --------\n\n//////// removing the standard speed JSCSlider\n~speedSlider.remove;\n\n//////// Figure 10.13\n(\n~mySlider            = Event.new;\n~mySlider.view       = JSCUserView( ~win, Rect( 110, 32, 200, 145 )).focusVisible_( false );\n~mySlider.pos        = ~speedSpec.unmap( ~model.speed );\n// these will be used in the final draw func:\n~mySlider.pressed    = false;\n~mySlider.project    = false;\n// this will update the slider position and refresh the view:\n~mySlider.adjustPos  = { arg slid, pos;\n    slid.pos         = pos;\n    slid.view.action.value( slid );\n    slid.view.refresh };\n// these will set the slider track curve and refresh the view:\n~mySlider.adjustCurve= { arg slid, curve;\n    slid.curve       = curve;\n    slid.lines       = curve.slide( 2, 1 ).clump( 2 );\n    slid.lineLens    = slid.lines.collect({ arg pair; pair[ 0 ].dist( pair[ 1 ])}).normalizeSum; \n    slid.projections = nil;\n    slid.view.refresh };\n// a primary draw function just to indicate the view's bounds:\n~mySlider.view.drawFunc = { arg view; var b = view.bounds;\n    JPen.line( 0 @ 0, b.width @ b.height );\n    JPen.line( 0 @ b.height, b.width @\u00ca0 );\n    JPen.stroke };\n// make the window a little bigger:\n~win.setInnerExtent( 370, 180 );\n)\n\n//////// Figure 10.14\n(\n~mySlider.adjustCurve([ 0 @ 0, 0.25 @ 1, 0.5 @ 0, 1.0 @ 0.5 ]);\n~mySlider.view.drawFunc = { arg view;\n    var b, scale, lnP1, lnP2, linePos, proj, inner, sum = 0;\n    b     = view.bounds;\n    // scaling factor for coordinates normalized to 0...1\n    scale = b.width @ b.height;\n    // set the initial curve coordinate\n    JPen.moveTo( ~mySlider.curve[ 0 ] * scale );\n    (1..(~mySlider.curve.size-1)).do({ arg i;\n        // create the curve by adding successive line segments\n        JPen.lineTo( ~mySlider.curve[ i ] * scale );\n    });\n    // stroke the curve with a 2-pixel wide black pen\n    JPen.width = 2;\n    JPen.color = Color.black;\n    JPen.stroke;\n    // draw the knob: iterate over the line segments until\n    // the one is found inside which the knob (read from ~mySlider.pos)\n    // is located.\n    block { arg break;\n        ~mySlider.lineLens.do({ arg len, i;\n            // if we have found the line segment...\n            if( sum + len >= ~mySlider.pos, {\n                // calucate the point inside this segment\n                // (proj) and draw a filled circle around it\n                #lnP1, lnP2    = ~mySlider.lines[ i ];\n                linePos        = (~mySlider.pos - sum) / len;\n                proj           = lnP1 + ((lnP2 - lnP1) * linePos);\n                JPen.fillOval( Rect.aboutPoint( proj * scale, 8, 8 ));\n                // if this view is focused, use blue color, otherwise grey\n                JPen.fillColor = Color.hsv( 0.7, view.hasFocus.if( 0.7, 0.0 ), 1.0 );\n                // if the mouse is pressed, the outline should be thicker\n                inner          = if( ~mySlider.pressed, 5, 7 );\n                JPen.fillOval( Rect.aboutPoint( proj * scale, inner, inner ));\n                break.value;\n            });\n            sum = sum + len;\n        });\n    };\n    \n    // a debugging utility to visualize the point projections\n    // of the mouse dragging\n    if( ~mySlider.project, {\n        ~mySlider.projections.do({ arg pt;\n            pt = pt * scale;\n            JPen.line( pt + (-5 @ -5), pt + (5 @  5) );\n            JPen.line( pt + (-5 @  5), pt + (5 @ -5) );\n        });\n        JPen.width = 1; JPen.stroke;\n    });\n};\n)\n\n//////// Figure 10.15\n(\nvar mouseFunc = { arg view, x, y, modifiers, buttonNumber, clickCount;\n    var b, nx, ny, dx, dy, lnP1, lnP2, linePos, lineLenSq,\n        proj, dist, sum = 0, minDist = inf, newValue;\n    \n    b  = view.bounds;\n    nx = x / b.width;\n    ny = y / b.height;\n    ~mySlider.projections = Array( ~mySlider.lines.size );\n    // look up the line segment which is closest to the mouse\n    ~mySlider.lines.do({ arg pair, i;\n        #lnP1, lnP2 = pair;\n        dx          = lnP2.x - lnP1.x;\n        dy          = lnP2.y - lnP1.y;\n        lineLenSq   = (dx*dx) + (dy*dy);\n        dist        = (((nx - lnP1.x) * dx) + ((ny - lnP1.y) * dy)) / lineLenSq;\n        proj        = (lnP1.x + (dist * dx)) @ (lnP1.y + (dist * dy));\n        if( lnP1.x != lnP2.x, {\n            linePos = (proj.x - lnP1.x) / dx;\n        }, {\n            linePos = (proj.y - lnP1.y) / dy;\n        });\n        if( linePos < 0, {\n            proj = lnP1;\n        }, { if( linePos > 1, {\n            proj = lnP2;\n        })});\n        ~mySlider.projections.add( proj );\n        dist = proj.dist( nx @ ny );\n        if( dist < minDist, {\n            newValue = sum + (linePos.clip( 0, 1 ) * ~mySlider.lineLens[i]);\n            minDist  = dist;\n        });\n        sum = sum + ~mySlider.lineLens[ i ];\n    });\n    ~mySlider.pressed = true;\n    ~mySlider.adjustPos( newValue );\n};\n~mySlider.view.mouseDownAction = mouseFunc;\n~mySlider.view.mouseMoveAction = mouseFunc;\n~mySlider.view.mouseUpAction   = { arg view; ~mySlider.pressed = false; view.refresh };\n~mySlider.view.action          = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( ~mySlider.pos ), ~mySlider )};\n)\n\n//////// making the point projections visible\n~mySlider.project = true; ~mySlider.view.refresh;\n\n//////// using a more elaborate curve\n(\n~mySlider.adjustCurve( Array.fill( 20, { arg i;\n    Polar( (i + 1) / 40, i / 19 * 4pi ).asPoint + (0.5 @ 0.5) }));\n)\n\n//////// adding keyboard control\n(\n~mySlider.view.keyDownAction = { arg view, char, modifiers, unicode, keycode;\n    switch( keycode, 37, {   // decrease slider-value with cursor-left\n        ~mySlider.adjustPos( (~mySlider.pos - 0.05).max( 0.0 ))},\n    39, {   // increase slider-value with cursor-right\n        ~mySlider.adjustPos( (~mySlider.pos + 0.05).min( 1.0 ))})};\n)\n\n// --------\n// -------- SECTION 8 - GENERIC JAVA SCRIPTING --------\n// --------\n\n//////// making incoming and outgoing OSC-messages visible\ng.dumpOSC( 1, 1 );\n\n//////// instantiating a JFrame and operating on it\n~frame = JavaObject( \"javax.swing.JFrame\", nil, \"Test\" );\n~frame.setSize( 400, 400 );\n~frame.setVisible( true );\n\n//////// adding a file chooser to the frame\n~cp          = ~frame.getContentPane__;\n~fileChooser = JavaObject( \"javax.swing.JFileChooser\" );\n~cp.add( ~fileChooser );\n~cp.revalidate;\n\n//////// receiving a primitive value from the server\nfork { ~title = ~frame.getTitle_; ~title.postln };\n\n//////// reading the currently selected file's path\n// note that this works only if a file is selected,\n// otherwise an error is printed. we leave out the\n// error handling here for brevity!\n(\nfork { ~file = ~fileChooser.getSelectedFile__;\n       ~fileName = ~file.getAbsolutePath_; ~file.destroy; ~fileName.postln };\n)\n\n//////// Figure 10.17\n(\n~action = { arg fileName; \"Selected file is '%'\\n\".postf( fileName )};\n~sResp  = JavaObject( \"de.sciss.swingosc.ActionResponder\", nil, ~fileChooser.id );\n~cResp  = OSCpathResponder( g.addr, [ '/action', ~fileChooser.id ], {\n    fork { var file, fileName;\n        file     = ~fileChooser.getSelectedFile__;\n        fileName = file.getAbsolutePath_;\n        file.destroy;\n        ~action.value( fileName.asString );\n    };\n}).add;\n)\n\n//////// turn off OSC-dumping\ng.dumpOSC( 0, 0 );\n\n// --------\n// -------- SECTION 9 - EMBEDDING ARBITRARY SWING VIEWS IN A JSCWINDOW --------\n// --------\n\n//////// Figure 10.18\n(\n~cp.remove( ~fileChooser );\n~frame.dispose;\n~cp.destroy; ~frame.destroy;\n~win.setInnerExtent( 760, 340 );   // again a bit bigger\n~plug = JSCPlugView( ~win, Rect( 370, 2, 386, 336 ), ~fileChooser );\n~action = { arg fileName; var sf, oldBuf;\n    // try to open as a sound file. returns nil if it could not be opened\n    if( (sf = SoundFile.openRead( fileName )).notNil, {\n        sf.close;  // the header info was read, we can close the file\n        if( sf.numChannels == 1, {  // allow mono files only\n            oldBuf = ~model.buf;\n            if( ~model.node.notNil, {  // free old buffer when synth is freed\n                UpdateListener.newFor( ~model.node, { arg upd;\n                    upd.remove; oldBuf.free }, \\n_end );\n                ~model.node.register;\n            }, {\n                oldBuf.free;\n            });\n            ~model.buf = Buffer.read( s, fileName );  // replace buffer\n        }, {\n            \"Sound file must be mono\".error;\n        });\n    });\n};\n)\n\n// --------\n// -------- SECTION 10 - USING CUSTOM JAVA CLASSES --------\n// --------\n\n// SoundFileChooser.java and JSCSoundFileChooser.sc are contained in separate files!\n\n//////// add the SoundFileChooser.jar to the classpath\ng.addClasses( \"file://<javaSourceCodePath>/SoundFileChooser.jar\" );   // replace <javaSourceCodePath> here!\n\n//////// Figure 10.21\n(\n~plug.remove;\t// this implicitly calls ~fileChooser.destroy!\n~soundChooser        = JSCSoundFileChooser( ~win, Rect( 370, 2, 386, 306 ));\n~soundChooser.path   = \"sounds/a11wlk01.wav\".absolutePath;\n~loadButton          = JSCButton( ~win, Rect( 370, 312, 60, 24 )).states_([[ \"Load\" ]]).enabled_( false );\n~infoText            = JSCStaticText( ~win, Rect( 438, 312, 318, 24 ));\n~soundChooser.action = { arg view; var enabled = false, info = \"\", sf;\n    if( view.path.notNil and: { (sf = SoundFile.openRead( view.path )).notNil }, {\n        sf.close;\n        enabled         = sf.numChannels == 1;\n        info            = \"% audio, %-chan. % % kHz, %\".format( sf.headerFormat, sf.numChannels, sf.sampleFormat, sf.sampleRate/1000, (sf.numFrames/sf.sampleRate).asTimeString );\n    });\n    ~loadButton.enabled = enabled;\n    ~infoText.string    = info;\n};\n~loadButton.action   = { ~action.value( ~soundChooser.path )};\n)\n\n//////// Figure 10.22\n(\n~ampSlider.resize     = 2;\n~mySlider.view.resize = 5;\n~ampText.resize       = 3;\n~speedText.resize     = 3;\n~soundChooser.resize  = 6;\n~loadButton.resize    = 9;\n~infoText.resize      = 9;\n~win.resizable        = true;\n)\n",
    "chapter10code_enbloc.scd": "// --------\n// -------- ALL IN ONE, LEADING TO THE FINAL EXAMPLE --------\n// --------\n\n(\ns.waitForBoot({\n    SynthDef( \\bufPlay, { arg buf, amp = 1.0, speed = 1.0;\n        Out.ar( 0, Pan2.ar( PlayBuf.ar( 1, buf, speed * BufRateScale.kr( buf ), loop: 1 ) * amp ));\n    }).send( s );\n    ~buf = Buffer.read( s, \"sounds/a11wlk01.wav\" );\n});\n\ng = SwingOSC.default;\ng.waitForBoot({\n    // replace <javaSourceCodePath> here!\n    g.addClasses( \"file://<javaSourceCodePath>/SoundFileChooser.jar\" );\n    \n    ~amp   = 0.5;  // initial amplitude\n    ~speed = 1.0;  // initial speed (1.0 is normal, 0.5 is half-speed, etc.)\n    \n    ~model        = Event.new;\n    ~model.amp    = ~amp;\n    ~model.speed  = ~speed;\n    ~model.node   = ~node;\n    ~model.buf    = ~buf;\n    ~model.adjust = { arg mod, key, value, source;\n        mod.put( key, value );\n        mod.changed( key, value, source )};\n\n    UpdateListener.newFor( ~model, { arg upd, mod, value;\n        mod.node.set( \\amp, value )}, \\amp );\n    UpdateListener.newFor( ~model, { arg upd, mod, value;\n        mod.node.set( \\speed, value )}, \\speed );\n    \n    ~win = JSCWindow( \"Panel\", Rect.new( 128, 60, 760, 340 ));\n    ~playButton = JSCButton( ~win, Rect( 4, 4, 40, 56 ))\n        .states_([[ \"Play\", Color.white, Color.green( 0.4 )],\n                  [ \"Stop\", Color.white, Color.red ]])\n        .action_({ arg view;\n            if( view.value == 1, {\n                ~model.node = Synth( \\bufPlay, [\n                    \\buf, ~model.buf, \\amp, ~model.amp, \\speed, ~model.speed ]);\n            }, {\n                ~model.node.free; ~model.node = nil;\n            })\n        });\n\n    JSCStaticText( ~win, Rect( 56, 4, 50, 25 )).align_( \\right ).string_( \"Amp:\" );\n    ~ampSlider = JSCSlider( ~win, Rect( 110, 4, 200, 25 ))\n        .value_( ~amp ) // initial slider position\n        .action_({ arg view;\n            ~model.adjust( \\amp, view.value, view )});\n    JSCStaticText( ~win, Rect( 56, 32, 50, 25 )).align_( \\right ).string_( \"Speed:\" );\n    ~speedSpec = ControlSpec( 1/8, 8, \\exp );\n\n    ~ampText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 4, 50, 25 ));\n    ~ampTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n        ~ampText.string = \"% dB\".format( value.ampdb.round( 0.1 ))}, \\amp );\n    ~speedText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 32, 50, 25 ));\n    ~speedTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n        ~speedText.string = \"%\\\\%\".format( (value * 100).round( 0.1 ))}, \\speed );\n\n    ~mySlider            = Event.new;\n    ~mySlider.view       = JSCUserView( ~win, Rect( 110, 32, 200, 145 )).focusVisible_( false );\n    ~mySlider.pos        = ~speedSpec.unmap( ~model.speed );\n    ~mySlider.pressed    = false;\n    ~mySlider.project    = false;\n    ~mySlider.adjustPos  = { arg slid, pos;\n        slid.pos         = pos;\n        slid.view.action.value( slid );\n        slid.view.refresh };\n    ~mySlider.adjustCurve= { arg slid, curve;\n        slid.curve       = curve;\n        slid.lines       = curve.slide( 2, 1 ).clump( 2 );\n        slid.lineLens    = slid.lines.collect({ arg pair; pair[ 0 ].dist( pair[ 1 ])}).normalizeSum; \n        slid.projections = nil;\n        slid.view.refresh };\n\n    ~mySlider.adjustCurve( Array.fill( 20, { arg i;\n        Polar( (i + 1) / 40, i / 19 * 4pi ).asPoint + (0.5 @ 0.5) }));\n\n    ~mySlider.view.drawFunc = { arg view;\n        var b, scale, lnP1, lnP2, linePos, proj, inner, sum = 0;\n        b     = view.bounds;\n        scale = b.width @ b.height;\n        JPen.moveTo( ~mySlider.curve[ 0 ] * scale );\n        (1..(~mySlider.curve.size-1)).do({ arg i;\n            JPen.lineTo( ~mySlider.curve[ i ] * scale );\n        });\n        JPen.width = 2;\n        JPen.color = Color.black;\n        JPen.stroke;\n        block { arg break;\n            ~mySlider.lineLens.do({ arg len, i;\n                if( sum + len >= ~mySlider.pos, {\n                    #lnP1, lnP2    = ~mySlider.lines[ i ];\n                    linePos        = (~mySlider.pos - sum) / len;\n                    proj           = lnP1 + ((lnP2 - lnP1) * linePos);\n                    JPen.fillOval( Rect.aboutPoint( proj * scale, 8, 8 ));\n                    JPen.fillColor = Color.hsv( 0.7, view.hasFocus.if( 0.7, 0.0 ), 1.0 );\n                    inner          = if( ~mySlider.pressed, 5, 7 );\n                    JPen.fillOval( Rect.aboutPoint( proj * scale, inner, inner ));\n                    break.value;\n                });\n                sum = sum + len;\n            });\n        };\n\n        if( ~mySlider.project, {\n            ~mySlider.projections.do({ arg pt;\n                pt = pt * scale;\n                JPen.line( pt + (-5 @ -5), pt + (5 @  5) );\n                JPen.line( pt + (-5 @  5), pt + (5 @ -5) );\n            });\n            JPen.width = 1; JPen.stroke;\n        });\n    };\n\n    ~ampSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n        if( source !== ~ampSlider, {\n            ~ampSlider.value = value;\n        })}, \\amp );\n    ~speedSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n        if( source !== ~mySlider, {\n            ~mySlider.adjustPos( ~speedSpec.unmap( value ));\n        })}, \\speed );\n\n    ~ampSlider.onClose   = { ~ampSliderUpd.remove };\n    ~mySlider.onClose    = { ~speedSliderUpd.remove };\n    ~ampText.onClose     = { ~ampTextUpd.remove };\n    ~speedText.onClose   = { ~speedTextUpd.remove };\n    \n    ~mouseFunc = { arg view, x, y, modifiers, buttonNumber, clickCount;\n        var b, nx, ny, dx, dy, lnP1, lnP2, linePos, lineLenSq,\n            proj, dist, sum = 0, minDist = inf, newValue;\n    \n        b  = view.bounds;\n        nx = x / b.width;\n        ny = y / b.height;\n        ~mySlider.projections = Array( ~mySlider.lines.size );\n        ~mySlider.lines.do({ arg pair, i;\n            #lnP1, lnP2 = pair;\n            dx          = lnP2.x - lnP1.x;\n            dy          = lnP2.y - lnP1.y;\n            lineLenSq   = (dx*dx) + (dy*dy);\n            dist        = (((nx - lnP1.x) * dx) + ((ny - lnP1.y) * dy)) / lineLenSq;\n            proj        = (lnP1.x + (dist * dx)) @ (lnP1.y + (dist * dy));\n            if( lnP1.x != lnP2.x, {\n                linePos = (proj.x - lnP1.x) / dx;\n            }, {\n                linePos = (proj.y - lnP1.y) / dy;\n            });\n            if( linePos < 0, {\n                proj = lnP1;\n            }, { if( linePos > 1, {\n                proj = lnP2;\n            })});\n            ~mySlider.projections.add( proj );\n            dist = proj.dist( nx @ ny );\n            if( dist < minDist, {\n                newValue = sum + (linePos.clip( 0, 1 ) * ~mySlider.lineLens[i]);\n                minDist  = dist;\n            });\n            sum = sum + ~mySlider.lineLens[ i ];\n        });\n        ~mySlider.pressed = true;\n        ~mySlider.adjustPos( newValue );\n    };\n    ~mySlider.view.mouseDownAction = ~mouseFunc;\n    ~mySlider.view.mouseMoveAction = ~mouseFunc;\n    ~mySlider.view.mouseUpAction   = { arg view; ~mySlider.pressed = false; view.refresh };\n    ~mySlider.view.action          = { arg view;\n        ~model.adjust( \\speed, ~speedSpec.map( ~mySlider.pos ), ~mySlider )};\n\n    ~mySlider.view.keyDownAction = { arg view, char, modifiers, unicode, keycode;\n        switch( keycode, 37, {   // decrease slider-value with cursor-left\n            ~mySlider.adjustPos( (~mySlider.pos - 0.05).max( 0.0 ))},\n        39, {   // increase slider-value with cursor-right\n            ~mySlider.adjustPos( (~mySlider.pos + 0.05).min( 1.0 ))})};\n\n    ~action = { arg fileName; var sf, oldBuf;\n        if( (sf = SoundFile.openRead( fileName )).notNil, {\n            sf.close;  // the header info was read, we can close the file\n            if( sf.numChannels == 1, {  // allow mono files only\n                oldBuf = ~model.buf;\n                if( ~model.node.notNil, {  // free old buffer when synth is freed\n                    UpdateListener.newFor( ~model.node, { arg upd;\n                        upd.remove; oldBuf.free }, \\n_end );\n                    ~model.node.register;\n                }, {\n                    oldBuf.free;\n                });\n                ~model.buf = Buffer.read( s, fileName );  // replace buffer\n            }, {\n                \"Sound file must be mono\".error;\n            });\n        });\n    };\n\n    ~soundChooser        = JSCSoundFileChooser( ~win, Rect( 370, 2, 386, 306 ));\n    ~soundChooser.path   = \"sounds/a11wlk01.wav\".absolutePath;\n    ~loadButton          = JSCButton( ~win, Rect( 370, 312, 60, 24 )).states_([[ \"Load\" ]]).enabled_( false );\n    ~infoText            = JSCStaticText( ~win, Rect( 438, 312, 318, 24 ));\n    ~soundChooser.action = { arg view; var enabled = false, info = \"\", sf;\n        if( view.path.notNil and: { (sf = SoundFile.openRead( view.path )).notNil }, {\n            sf.close;\n            enabled         = sf.numChannels == 1;\n            info            = \"% audio, %-chan. % % kHz, %\".format( sf.headerFormat, sf.numChannels, sf.sampleFormat, sf.sampleRate/1000, (sf.numFrames/sf.sampleRate).asTimeString );\n        });\n        ~loadButton.enabled = enabled;\n        ~infoText.string    = info;\n    };\n    ~loadButton.action   = { ~action.value( ~soundChooser.path )};\n\n    ~ampSlider.resize     = 2;\n    ~mySlider.view.resize = 5;\n    ~ampText.resize       = 3;\n    ~speedText.resize     = 3;\n    ~soundChooser.resize  = 6;\n    ~loadButton.resize    = 9;\n    ~infoText.resize      = 9;\n    \n    ~win.front;\n})\n)",
    "WindowsExamples.scd": "// Tasks \n(\nSynthDef(\"task\", { arg out=0, freq=2000;\n\tvar env = EnvGen.kr(Env.perc, 1.0, 0.2, doneAction:2);\n\tvar source = DynKlank.ar(`[ [0.5, 0.8, 1, 1.2, 2, 4]*freq, nil, nil ], PinkNoise.ar(0.007));\n\tOut.ar(out, source * env ! 2);\n}).store;\n\nt = Task({\n\tvar freq;\n\tloop {\n\t\tfreq = ((1..10)*220).choose;\n\t\tSynth(\"task\", [\\freq, freq]);\n\t\t0.3.wait;\n\t}\n})\n)\n\nt.start\nt.stop;\n\n\n// Patterns\n(\nSynthDef(\"pattern\", { arg out=0, freq=220, pan=0, gate=1;\n\tvar ctl = RLPF.ar(Saw.ar(5, 1.0, 2), 25, 0.03);\n \tvar source = SinOsc.ar(ctl * freq) * 0.1;\n\tvar env = EnvGen.kr(Env.adsr, gate, doneAction: 2);\n\tOut.ar(out, Pan2.ar(source * env, pan));\n}).store;\n\ne = Pbind(\n\t\\midinote, Pxrand(#[60, 61, 63, 65, 72], 20), \n\t\\dur, 0.4,\n\t\\pan, Pwhite(-1.0, 1.0, 20),\n\t\\instrument, \\pattern\n);\n)\n\ne.play;\n\n\n// ProxySpace\np = p ?? ProxySpace.push(s);\n\n~ctl = { SinOsc.kr(1) * 110 + 440 };\n~out = { arg freq=220, amp=0.5; Ringz.ar(Dust.ar(2, 0.4), freq, 0.8) ! 2 };\n\n~out.play;\n\n~out.map(\\freq, ~ctl);\n\n~ctl = { SinOsc.kr(LFSaw.kr(5, add: 2.0) * 10) * 220 + 440 };\n\nProxyMixer.new;\n\n~out.stop;\n~out.clear;\n\n// MIDI Example\n(\nSynthDef(\\midi, { arg out=0, midinote=60, dur=0.1;\n\tvar source = Blip.ar(midinote.midicps, 4, 0.2);\n\tvar env = EnvGen.kr(Env.perc(0.1, dur), 1.0, doneAction: 2);\n\tOut.ar(out, (source * env) ! 2);\n\n}).store;\n\nc = NoteOnResponder( { |src, chan, num, vel|\n\t[num, vel].postln;\n\tSynth.new(\\midi, [\\midinote, num, \\dur, vel/512]);\n});\n)\nc.remove;\n\n// NetAddr and OSCresponder example\nn = NetAddr(\"localhost\", 57120); \nr = OSCresponder(n, '/good/news', { arg time, resp, msg; [time, msg].postln }).add;\n\nn.sendMsg(\"/good/news\", \"you\", \"not you\");\n\nr.remove;\nn.disconnect;\n\n\n// GUI Example\n(\n\tSynthDef(\\gui, { arg out=0, freq=8, decay=0.11;\n\t\tvar in = Formlet.ar(Impulse.ar(freq, 0, 0.4), 800, 0.01, decay);\n\t\tOut.ar(out, in ! 2);\n\t}).memStore;\n)\n(\n\ta = Synth.newPaused(\\gui);\n\tw = Window.new( \"A GUI window\", Rect( 128, 64, 340, 250 ));\n\tw.view.decorator = FlowLayout( w.view.bounds );\n\n\tb = Button.new( w, Rect( 50, 20, 75, 24 ));\n\tb.states = [[ \"Start\"],[ \"Stop\"]];\n\tb.action_({ arg butt;\n\t\tif (butt.value == 1, { a.run }, { a.run(false) });\t\n\t});\n\n\tc = Slider2D.new( w, Rect(50, 120, 330, 200));\n\tc.x_(0.5).y_(0.5).action_({|sl|\n\t\t\ta.setn(\\freq, [sl.x * 10 + 3, sl.y / 5 + 0.01]);\n\t});\n\n\tw.front;\n)\n\n\n// Plus-GUI methods\nServer.inspect; \t\t\t\t\t// inspect a class\n\nUGen.browse;\t\t\t\t\t\t// ClassBrowser\nSynthDescLib( \\myLib ).read.browse;\n\ns.makeWindow;\t\t\t\t\t\t// a server control window\n\nEnv.perc.test.plot;\t\t\t\t\t// plotting \n\t\t\t\t\t\t\t\t\t\t\n{SinOsc.ar(LFSaw.kr(1,0,220,440)) *0.1}.scope\t\t// scope\n\n\n// Open new code window - workaround\n\"This is a new code window\".newTextWindow;   ",
    "chapter12code.scd": "// Figure 12.3\n//\n// select the following lines and type C-c C-x\n// stop synthesis with C-c C-s\n\n{\n\tvar trem = LFTri.kr(3).range(-12.dbamp, 0.dbamp);\n\tSinOsc.ar(\n\t\t{ rrand(60, 80).midicps } ! 6,\n\t\tmul: -10.dbamp * trem\n\t).clump(2).sum\n}.play\n\n\n// Figure 12.4\n//\n// evaluate the following lines by double-clicking on the\n// first paranthesis when `transient-mark-mode' is enabled\n// and pressing C-c C-c\n\n(\nx = {\n\tSaw.ar(\n\t\tXLine.kr(20, [400,403,407], 20),\n\t\tmul: 0.7\n\t).clump(2).sum\n}.play; \"scel\";\n)\n\n// evaluate this line by pressing C-c C-c\nx.free; \"rocks\";\n",
    "chapter12script.scd": "#!/usr/local/bin/sclang\n\n// Figure 12.1\n\nif (thisProcess.argv.isEmpty) {\n\t\"Missing arguments!\".postln;\n\texit(1);\n};\n\nthisProcess.argv.do { | x, i |\n\t\"% : %\\n\".postf(i, x);\n};\n\nexit(0);\n",
    "Sonif_13.12-13.16_juggle.scd": "/**** \n\tNote: all these examples require tracking data to produce sounds.\n\tAs the subtleties of the tracking data are very hard to simulate, \n\twe decided not to provide a (misleading) simulation. To hear the \n\texamples in action, please see and hear the videos on the book website.\n****/\n\n// example juggling 12 - Rotational Grain Train\n\n(\n~rotater = {|amp = 1|\n\tvar rotVel = ~rotVel.kr;\t// rotVel and height from tracking data proxies\n\tBPF.ar(\n\t\tImpulse.ar((rotVel > 0.5) * rotVel * 5).lag(0.0001),\n\t\t(~height.kr * 120 + 36 + [[0, 7], [0, 12], [0, 16]]).midicps, \n\t\t0.2\n\t).collect({ |pair| (pair * [1, 0.125]).sum }) \t* 6 * amp\n};\n)\n\n\n\n// example juggling 13 - Rotation Trigger\n(\n~planeTicker = {|saw2sin = 1, filterFreq = 2000, fSpread = 0.4, amp = 0.1|\n\t\n\tvar freq = 3000 * fSpread * (~height.kr * 4 - 1).range(0.5, 2);\n\t\n\tvar src = SelectX.ar(\n\t\tsaw2sin, \n\t\t[LFSaw.ar(freq) , SinOsc.ar(freq)]\n\t) \n\t* Decay2.ar(\n\t\tTrig1.ar(~zeroCrossing.ar, 0.001) * 0.1, \n\t\t0.001,\n\t\t0.3\n\t);\n\t\n\tLPF.ar(src, filterFreq, mul: amp * 0.1)\n};\n)\n\n\n\n// example juggling 14 - Distances to the Head\n(\n~backCross = {|amp = 1|\n\tvar \tnumObj = 3;\n\tvar \tin = ~isLeft.kr(numObj);\n\tvar \theight = ~height.kr(numObj), \n\t\tfront = ~isFront.kr(numObj); \n\tvar aEnv, fEnv, aEnvNoise;\n\n\tvar trig = Trig1.ar((in - Delay1.kr(in)).abs - 1, 0.00001) > 0.5;\n\t// only trigger if behind the body and near ground\n\ttrig = trig * (front < 0) * (height < 0.26);\n\taEnv = EnvGen.kr(Env.perc(0.05, 2), gate: trig);\n\taEnvNoise = EnvGen.kr(Env.perc(0.01, 0.1), gate: trig);\n\tfEnv = EnvGen.kr(\n\t\tEnv.perc(0.01, 0.1), gate: trig, \n\t\tlevelScale: 900, levelBias: 50\n\t);\n\t\n\taEnv * ((0.2 * WhiteNoise.ar * aEnvNoise) + \n\tSinOsc.ar(fEnv * (height * 8).squared * 0.4, 0, 1.5).softclip) * amp\n};\n)\n\n\n// example juggling 15 -  Left-right Trigger\n(\n~distances = {|amp = 0.2795| \n\tLFSaw.ar(min((~dist.kr * 2.5 * 90 + 20).midicps, 44100)) * amp\n};\n)\n\n\n// example juggling 16 - Rain on Bells\n(\n~clackUp = { |amp = 0.1|\n\tFormlet.ar(\n\t\t~trigsUp.ar.lag(0.0004), \n\t\t(~height.kr).exprange(25, 2500), \n\t\t0.002,\n\t\t0.05\n\t)\n\t* (~height.kr * 4 ** 2) \n\t* amp\n};\n)\n",
    "sonif13.18_navegarReson.scd": "/// figure sonif 19 - Sound design for a single country\n(\n~single = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, attack=0.00, decay = 1.0, \n\tdens = 2, amp=0.2, x=1, y = 0, step=0.33333| \n\t\n\tvar numChans = 4; \n\t\n\tvar freqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\tvar exciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07) // five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \t\t\t\t\t// slightly filtered\n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude comp for dust density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// some fused background noise\n\t\t\t* (decay ** -0.5);\t\t\t\t\t// amplitude comp. for decay\n\t\t\t\t\n\tvar resonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\tvar pos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (pi.reciprocal) + 1; // look west.\n\t\n\tPanAz.ar(numChans, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n\n~single.play;\n)\n\n",
    "sonif_13.01-13.7_basic.scd": "\u00ff\u00fe\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00001\u0000 \u0000-\u0000 \u0000L\u0000o\u0000a\u0000d\u0000i\u0000n\u0000g\u0000 \u0000t\u0000h\u0000e\u0000 \u0000d\u0000a\u0000t\u0000a\u0000\n\u0000(\u0000\n\u0000q\u0000 \u0000=\u0000 \u0000q\u0000 \u0000?\u0000 \u0000(\u0000)\u0000;\u0000\n\u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000 \u0000=\u0000 \u0000(\u0000)\u0000;\u0000\n\u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000 \u0000=\u0000 \u0000(\u00001\u00009\u00007\u00007\u0000 \u0000.\u0000.\u0000 \u00002\u00000\u00000\u00008\u0000)\u0000;\u0000 \u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000i\u0000s\u0000:\u0000 \u0000[\u0000t\u0000o\u0000t\u0000a\u0000l\u0000 \u0000f\u0000o\u0000r\u0000 \u0000e\u0000a\u0000c\u0000h\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000,\u0000 \u00001\u00009\u00007\u00007\u0000 \u0000.\u0000.\u0000.\u0000 \u00002\u00000\u00000\u00007\u0000]\u0000;\u0000\n\u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000 \u0000=\u0000 \u0000(\u0000\n\u0000\t\u0000T\u0000o\u0000t\u0000a\u0000l\u0000:\u0000 \u0000[\u00001\u00000\u00009\u00009\u0000,\u00001\u0000,\u00000\u0000,\u00002\u0000,\u00000\u0000,\u00001\u0000,\u00002\u0000,\u00005\u0000,\u00002\u00001\u0000,\u00001\u00008\u0000,\u00001\u00008\u0000,\u00002\u00005\u0000,\u00001\u00001\u0000,\u00001\u00006\u0000,\u00002\u00003\u0000,\u00001\u00004\u0000,\u00003\u00001\u0000,\u00003\u00008\u0000,\u00003\u00001\u0000,\u0000\n\u0000\t\u0000\t\u0000\t\u00005\u00006\u0000,\u00004\u00005\u0000,\u00007\u00004\u0000,\u00006\u00008\u0000,\u00009\u00008\u0000,\u00008\u00005\u0000,\u00006\u00006\u0000,\u00007\u00001\u0000,\u00006\u00005\u0000,\u00005\u00009\u0000,\u00006\u00000\u0000,\u00005\u00003\u0000,\u00004\u00002\u0000,\u00003\u00007\u0000]\u0000,\u0000\n\u0000\t\u0000N\u0000o\u0000r\u0000t\u0000h\u0000e\u0000a\u0000s\u0000t\u0000:\u0000 \u0000[\u00004\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00002\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000]\u0000,\u0000\n\u0000\t\u0000M\u0000i\u0000d\u0000w\u0000e\u0000s\u0000t\u0000:\u0000 \u0000[\u00001\u00002\u00009\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00005\u0000,\u00001\u0000,\u00001\u0000,\u00004\u0000,\u00003\u0000,\u00001\u00001\u0000,\u00009\u0000,\u00001\u00000\u0000,\u00005\u0000,\u00001\u00002\u0000,\u00005\u0000,\u00001\u00000\u0000,\u00009\u0000,\u00007\u0000,\u00007\u0000,\u00001\u00004\u0000,\u00006\u0000,\u00005\u0000,\u00002\u0000]\u0000,\u0000\n\u0000\t\u0000S\u0000o\u0000u\u0000t\u0000h\u0000:\u0000 \u0000[\u00009\u00003\u00003\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00002\u0000,\u00005\u0000,\u00002\u00001\u0000,\u00001\u00006\u0000,\u00001\u00008\u0000,\u00002\u00004\u0000,\u00001\u00000\u0000,\u00001\u00003\u0000,\u00001\u00007\u0000,\u00001\u00003\u0000,\u00002\u00006\u0000,\u00003\u00000\u0000,\u00002\u00006\u0000,\u00004\u00001\u0000,\u00002\u00009\u0000,\u00006\u00000\u0000,\u0000\n\u0000\t\u0000\t\u00005\u00005\u0000,\u00007\u00004\u0000,\u00007\u00006\u0000,\u00005\u00000\u0000,\u00006\u00001\u0000,\u00005\u00007\u0000,\u00005\u00000\u0000,\u00004\u00003\u0000,\u00004\u00004\u0000,\u00003\u00006\u0000,\u00003\u00005\u0000]\u0000,\u0000\n\u0000\t\u0000W\u0000e\u0000s\u0000t\u0000:\u0000 \u0000[\u00006\u00007\u0000,\u00001\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00001\u0000,\u00001\u0000,\u00002\u0000,\u00001\u0000,\u00000\u0000,\u00004\u0000,\u00004\u0000,\u00002\u0000,\u00002\u0000,\u00007\u0000,\u00004\u0000,\u00008\u0000,\u00001\u00001\u0000,\u00004\u0000,\u00004\u0000,\u00001\u0000,\u00000\u0000,\u00002\u0000,\u00002\u0000,\u00003\u0000,\u00001\u0000,\u00000\u0000]\u0000,\u0000\n\u0000\t\u0000T\u0000e\u0000x\u0000a\u0000s\u0000:\u0000 \u0000[\u00004\u00002\u00003\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00000\u0000,\u00001\u0000,\u00000\u0000,\u00003\u0000,\u00006\u0000,\u00001\u00000\u0000,\u00006\u0000,\u00003\u0000,\u00004\u0000,\u00004\u0000,\u00005\u0000,\u00001\u00002\u0000,\u00001\u00007\u0000,\u00001\u00004\u0000,\u00001\u00009\u0000,\u00003\u0000,\u00003\u00007\u0000,\u00002\u00000\u0000,\u00003\u00005\u0000,\u00004\u00000\u0000,\u00001\u00007\u0000,\u00003\u00003\u0000,\u00002\u00004\u0000,\u00002\u00003\u0000,\u00001\u00009\u0000,\u00002\u00004\u0000,\u00002\u00006\u0000,\u00001\u00008\u0000]\u0000\n\u0000)\u0000;\u0000\n\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000 \u0000=\u0000 \u0000{\u0000 \u0000|\u0000q\u0000,\u0000 \u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000|\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000[\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000]\u0000.\u0000d\u0000r\u0000o\u0000p\u0000(\u00001\u0000)\u0000 \u0000}\u0000;\u0000\n\u0000)\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00002\u0000 \u0000-\u0000 \u0000M\u0000a\u0000p\u0000p\u0000i\u0000n\u0000g\u0000 \u0000t\u0000h\u0000e\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000t\u0000o\u0000 \u0000p\u0000i\u0000t\u0000c\u0000h\u0000 \u0000i\u0000n\u0000 \u0000d\u0000i\u0000s\u0000c\u0000r\u0000e\u0000t\u0000e\u0000 \u0000e\u0000v\u0000e\u0000n\u0000t\u0000s\u0000\n\u0000(\u0000\n\u0000P\u0000b\u0000i\u0000n\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000,\u0000 \u0000\n\u0000\t\u0000\\\u0000n\u0000o\u0000t\u0000e\u0000,\u0000 \u0000P\u0000s\u0000e\u0000q\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000M\u0000i\u0000d\u0000w\u0000e\u0000s\u0000t\u0000)\u0000)\u0000,\u0000 \u0000\n\u0000\t\u0000\\\u0000o\u0000c\u0000t\u0000a\u0000v\u0000e\u0000,\u0000 \u00003\u0000,\u0000 \u0000\n\u0000\t\u0000\\\u0000d\u0000u\u0000r\u0000,\u0000 \u00005\u0000 \u0000/\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000.\u0000s\u0000i\u0000z\u0000e\u0000\n\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000)\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000t\u0000h\u0000e\u0000 \u0000d\u0000i\u0000f\u0000f\u0000e\u0000r\u0000e\u0000n\u0000t\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000\n\u0000P\u0000b\u0000i\u0000n\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000,\u0000 \u0000\\\u0000n\u0000o\u0000t\u0000e\u0000,\u0000 \u0000P\u0000s\u0000e\u0000q\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000N\u0000o\u0000r\u0000t\u0000h\u0000e\u0000a\u0000s\u0000t\u0000)\u0000)\u0000)\u0000;\u0000\n\u0000P\u0000b\u0000i\u0000n\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000,\u0000 \u0000\\\u0000n\u0000o\u0000t\u0000e\u0000,\u0000 \u0000P\u0000s\u0000e\u0000q\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000W\u0000e\u0000s\u0000t\u0000)\u0000)\u0000)\u0000;\u0000\n\u0000P\u0000b\u0000i\u0000n\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000,\u0000 \u0000\\\u0000n\u0000o\u0000t\u0000e\u0000,\u0000 \u0000P\u0000s\u0000e\u0000q\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000S\u0000o\u0000u\u0000t\u0000h\u0000)\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00003\u0000 \u0000-\u0000 \u0000C\u0000o\u0000n\u0000t\u0000i\u0000n\u0000u\u0000o\u0000u\u0000s\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000s\u0000o\u0000n\u0000i\u0000f\u0000i\u0000c\u0000a\u0000t\u0000i\u0000o\u0000n\u0000\n\u0000 \u0000\n\u0000b\u0000 \u0000=\u0000 \u0000B\u0000u\u0000f\u0000f\u0000e\u0000r\u0000.\u0000s\u0000e\u0000n\u0000d\u0000C\u0000o\u0000l\u0000l\u0000e\u0000c\u0000t\u0000i\u0000o\u0000n\u0000(\u0000s\u0000,\u0000 \u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000N\u0000o\u0000r\u0000t\u0000h\u0000e\u0000a\u0000s\u0000t\u0000)\u0000,\u0000 \u00001\u0000)\u0000;\u0000 \u0000\n\u0000(\u0000\n\u0000N\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000,\u0000 \u0000{\u0000 \u0000|\u0000d\u0000u\u0000r\u0000 \u0000=\u0000 \u00005\u0000,\u0000 \u0000s\u0000c\u0000a\u0000l\u0000e\u0000=\u00005\u00000\u0000,\u0000 \u0000o\u0000f\u0000f\u0000s\u0000e\u0000t\u0000=\u00002\u00000\u00000\u0000|\u0000 \u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000v\u0000a\u0000l\u0000s\u0000 \u0000=\u0000 \u0000P\u0000l\u0000a\u0000y\u0000B\u0000u\u0000f\u0000.\u0000a\u0000r\u0000(\u00001\u0000,\u0000 \u0000b\u0000,\u0000 \u0000d\u0000u\u0000r\u0000 \u0000/\u0000 \u0000S\u0000a\u0000m\u0000p\u0000l\u0000e\u0000R\u0000a\u0000t\u0000e\u0000.\u0000i\u0000r\u0000 \u0000)\u0000;\u0000\n\u0000\t\u0000P\u0000a\u0000n\u00002\u0000.\u0000a\u0000r\u0000(\u0000\n\u0000\t\u0000\t\u0000S\u0000i\u0000n\u0000O\u0000s\u0000c\u0000.\u0000a\u0000r\u0000(\u0000v\u0000a\u0000l\u0000s\u0000 \u0000 \u0000*\u0000 \u0000s\u0000c\u0000a\u0000l\u0000e\u0000 \u0000+\u0000 \u0000o\u0000f\u0000f\u0000s\u0000e\u0000t\u0000)\u0000,\u0000 \u00000\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000E\u0000n\u0000v\u0000G\u0000e\u0000n\u0000.\u0000k\u0000r\u0000(\u0000E\u0000n\u0000v\u0000.\u0000l\u0000i\u0000n\u0000e\u0000n\u0000(\u00000\u0000.\u00000\u00001\u0000,\u0000 \u0000d\u0000u\u0000r\u0000,\u0000 \u00000\u0000.\u00000\u00001\u0000,\u0000 \u00000\u0000.\u00002\u0000)\u0000,\u0000 \u0000d\u0000o\u0000n\u0000e\u0000A\u0000c\u0000t\u0000i\u0000o\u0000n\u0000:\u0000 \u00002\u0000)\u0000\n\u0000\t\u0000)\u0000;\u0000\n\u0000}\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000)\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000l\u0000o\u0000a\u0000d\u0000 \u0000o\u0000t\u0000h\u0000e\u0000r\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000 \u0000i\u0000n\u0000t\u0000o\u0000 \u0000b\u0000u\u0000f\u0000f\u0000e\u0000r\u0000\n\u0000b\u0000.\u0000s\u0000e\u0000n\u0000d\u0000C\u0000o\u0000l\u0000l\u0000e\u0000c\u0000t\u0000i\u0000o\u0000n\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000M\u0000i\u0000d\u0000w\u0000e\u0000s\u0000t\u0000)\u0000)\u0000;\u0000 \u0000 \u0000 \u0000N\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000)\u0000.\u0000s\u0000e\u0000n\u0000d\u0000;\u0000\n\u0000\n\u0000b\u0000.\u0000s\u0000e\u0000n\u0000d\u0000C\u0000o\u0000l\u0000l\u0000e\u0000c\u0000t\u0000i\u0000o\u0000n\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000W\u0000e\u0000s\u0000t\u0000)\u0000)\u0000;\u0000 \u0000 \u0000 \u0000N\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000)\u0000.\u0000s\u0000e\u0000n\u0000d\u0000;\u0000\n\u0000\n\u0000b\u0000.\u0000s\u0000e\u0000n\u0000d\u0000C\u0000o\u0000l\u0000l\u0000e\u0000c\u0000t\u0000i\u0000o\u0000n\u0000(\u0000q\u0000.\u0000g\u0000e\u0000t\u0000R\u0000e\u0000g\u0000(\u0000\\\u0000S\u0000o\u0000u\u0000t\u0000h\u0000)\u0000)\u0000;\u0000 \u0000 \u0000 \u0000N\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000)\u0000.\u0000s\u0000e\u0000n\u0000d\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00004\u0000 \u0000-\u0000 \u0000 \u0000S\u0000o\u0000u\u0000n\u0000d\u0000 \u0000d\u0000e\u0000s\u0000i\u0000g\u0000n\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000n\u0000o\u0000i\u0000s\u0000e\u0000 \u0000p\u0000u\u0000l\u0000s\u0000e\u0000s\u0000 \u0000\n\u0000(\u0000\n\u0000S\u0000y\u0000n\u0000t\u0000h\u0000D\u0000e\u0000f\u0000(\u0000 \u0000\"\u0000n\u0000o\u0000i\u0000s\u0000e\u0000p\u0000u\u0000l\u0000s\u0000e\u0000s\u0000\"\u0000,\u0000 \u0000{\u0000 \u0000a\u0000r\u0000g\u0000 \u0000o\u0000u\u0000t\u0000 \u0000=\u0000 \u00000\u0000,\u0000 \u0000s\u0000u\u0000s\u0000t\u0000a\u0000i\u0000n\u0000=\u00001\u0000.\u00000\u0000,\u0000 \u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000 \u0000=\u0000 \u00000\u0000,\u0000 \u0000p\u0000a\u0000n\u0000 \u0000=\u0000 \u00000\u0000.\u00000\u0000,\u0000 \u0000a\u0000m\u0000p\u0000 \u0000=\u0000 \u00000\u0000.\u00002\u0000;\u0000 \u0000\n\u0000\t\u0000O\u0000u\u0000t\u0000.\u0000a\u0000r\u0000(\u0000o\u0000u\u0000t\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000P\u0000a\u0000n\u0000A\u0000z\u0000.\u0000a\u0000r\u0000(\u00004\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000P\u0000i\u0000n\u0000k\u0000N\u0000o\u0000i\u0000s\u0000e\u0000.\u0000a\u0000r\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000*\u0000 \u0000D\u0000e\u0000c\u0000a\u0000y\u00002\u0000.\u0000a\u0000r\u0000(\u0000I\u0000m\u0000p\u0000u\u0000l\u0000s\u0000e\u0000.\u0000a\u0000r\u0000(\u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000 \u0000/\u0000 \u0000s\u0000u\u0000s\u0000t\u0000a\u0000i\u0000n\u0000,\u0000 \u00000\u0000,\u0000 \u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000.\u0000s\u0000i\u0000g\u0000n\u0000)\u0000,\u0000 \u00000\u0000.\u00000\u00000\u00001\u0000,\u0000 \u00000\u0000.\u00002\u0000)\u0000,\u0000\n\u0000\t\u0000\t\u0000\t\u0000p\u0000a\u0000n\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000E\u0000n\u0000v\u0000G\u0000e\u0000n\u0000.\u0000k\u0000r\u0000(\u0000 \u0000E\u0000n\u0000v\u0000.\u0000l\u0000i\u0000n\u0000e\u0000n\u0000(\u00000\u0000.\u00000\u0000,\u0000 \u00000\u0000.\u00009\u00009\u00005\u0000,\u0000 \u00000\u0000.\u00000\u0000)\u0000,\u0000 \u0000l\u0000e\u0000v\u0000e\u0000l\u0000S\u0000c\u0000a\u0000l\u0000e\u0000:\u0000 \u0000a\u0000m\u0000p\u0000,\u0000 \u0000t\u0000i\u0000m\u0000e\u0000S\u0000c\u0000a\u0000l\u0000e\u0000:\u0000 \u0000s\u0000u\u0000s\u0000t\u0000a\u0000i\u0000n\u0000,\u0000 \u0000d\u0000o\u0000n\u0000e\u0000A\u0000c\u0000t\u0000i\u0000o\u0000n\u0000:\u0000 \u00002\u0000)\u0000\n\u0000\t\u0000\t\u0000)\u0000\n\u0000\t\u0000)\u0000;\u0000\n\u0000}\u0000)\u0000.\u0000s\u0000t\u0000o\u0000r\u0000e\u0000;\u0000\n\u0000S\u0000y\u0000n\u0000t\u0000h\u0000D\u0000e\u0000f\u0000(\u0000\\\u0000t\u0000i\u0000c\u0000k\u0000,\u0000 \u0000{\u0000 \u0000|\u0000o\u0000u\u0000t\u0000,\u0000 \u0000a\u0000m\u0000p\u0000=\u00000\u0000.\u00002\u0000,\u0000 \u0000p\u0000a\u0000n\u0000|\u0000 \u0000\n\u0000\t\u0000O\u0000f\u0000f\u0000s\u0000e\u0000t\u0000O\u0000u\u0000t\u0000.\u0000a\u0000r\u0000(\u0000o\u0000u\u0000t\u0000,\u0000 \u0000P\u0000a\u0000n\u00002\u0000.\u0000a\u0000r\u0000(\u0000I\u0000m\u0000p\u0000u\u0000l\u0000s\u0000e\u0000.\u0000a\u0000r\u0000(\u00000\u0000)\u0000 \u0000*\u0000 \u0000L\u0000i\u0000n\u0000e\u0000.\u0000k\u0000r\u0000(\u0000a\u0000m\u0000p\u0000,\u0000 \u0000a\u0000m\u0000p\u0000,\u0000 \u00000\u0000.\u00000\u00000\u00001\u0000,\u0000 \u0000d\u0000o\u0000n\u0000e\u0000A\u0000c\u0000t\u0000i\u0000o\u0000n\u0000:\u0000 \u00002\u0000)\u0000,\u0000 \u0000p\u0000a\u0000n\u0000)\u0000)\u0000 \u0000\n\u0000}\u0000)\u0000.\u0000s\u0000t\u0000o\u0000r\u0000e\u0000;\u0000\n\u0000)\u0000\n\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000n\u0000o\u0000i\u0000s\u0000e\u0000p\u0000u\u0000l\u0000s\u0000e\u0000s\u0000,\u0000 \u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000:\u0000 \u00001\u00000\u0000,\u0000 \u0000l\u0000e\u0000g\u0000a\u0000t\u0000o\u0000:\u0000 \u00001\u0000,\u0000 \u0000d\u0000u\u0000r\u0000:\u0000 \u00002\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000t\u0000i\u0000c\u0000k\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00005\u0000 \u0000-\u0000 \u0000F\u0000o\u0000u\u0000r\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000 \u0000i\u0000n\u0000 \u0000s\u0000e\u0000q\u0000u\u0000e\u0000n\u0000c\u0000e\u0000\n\u0000(\u0000\n\u0000T\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000{\u0000 \u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000 \u0000=\u0000 \u00002\u0000;\u0000\t\u0000/\u0000/\u0000 \u0000o\u0000n\u0000e\u0000 \u0000y\u0000e\u0000a\u0000r\u0000 \u0000i\u0000s\u0000 \u00002\u0000 \u0000s\u0000e\u0000c\u0000o\u0000n\u0000d\u0000s\u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000,\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000n\u0000u\u0000m\u0000y\u0000e\u0000a\u0000r\u0000s\u0000 \u0000=\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000.\u0000s\u0000i\u0000z\u0000e\u0000;\u0000 \u0000\n\u0000\t\u0000[\u0000\\\u0000N\u0000o\u0000r\u0000t\u0000h\u0000e\u0000a\u0000s\u0000t\u0000,\u0000 \u0000\\\u0000M\u0000i\u0000d\u0000w\u0000e\u0000s\u0000t\u0000,\u0000 \u0000\\\u0000W\u0000e\u0000s\u0000t\u0000,\u0000 \u0000\\\u0000S\u0000o\u0000u\u0000t\u0000h\u0000]\u0000.\u0000d\u0000o\u0000 \u0000{\u0000 \u0000|\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000,\u0000 \u0000i\u0000|\u0000 \u0000\n\u0000\n\u0000\t\u0000\t\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000 \u0000=\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000[\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000]\u0000.\u0000p\u0000o\u0000s\u0000t\u0000l\u0000n\u0000;\u0000 \u0000\n\u0000\t\u0000\t\u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000.\u0000d\u0000o\u0000 \u0000{\u0000 \u0000|\u0000y\u0000e\u0000a\u0000r\u0000,\u0000 \u0000i\u0000|\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000 \u0000=\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000[\u0000i\u0000 \u0000+\u0000 \u00001\u0000]\u0000;\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000[\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000,\u0000 \u0000y\u0000e\u0000a\u0000r\u0000,\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000]\u0000.\u0000p\u0000o\u0000s\u0000t\u0000l\u0000n\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000t\u0000i\u0000c\u0000k\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000i\u0000f\u0000 \u0000(\u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000 \u0000>\u0000 \u00000\u0000)\u0000 \u0000{\u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000n\u0000o\u0000i\u0000s\u0000e\u0000p\u0000u\u0000l\u0000s\u0000e\u0000s\u0000,\u0000 \u0000l\u0000e\u0000g\u0000a\u0000t\u0000o\u0000:\u0000 \u00001\u0000,\u0000 \u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000:\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000d\u0000u\u0000r\u0000:\u0000 \u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000}\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000.\u0000w\u0000a\u0000i\u0000t\u0000;\u0000\n\u0000\t\u0000\t\u0000}\u0000;\u0000\n\u0000\t\u0000\t\u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000.\u0000w\u0000a\u0000i\u0000t\u0000;\u0000\n\u0000\t\u0000}\u0000;\u0000\n\u0000}\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000)\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00006\u0000 \u0000-\u0000 \u0000F\u0000o\u0000u\u0000r\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000 \u0000i\u0000n\u0000 \u0000p\u0000a\u0000r\u0000a\u0000l\u0000l\u0000e\u0000l\u0000\n\u0000(\u0000\n\u0000/\u0000/\u0000 \u0000f\u0000o\u0000u\u0000r\u0000 \u0000c\u0000h\u0000a\u0000n\u0000n\u0000e\u0000l\u0000s\u0000 \u0000p\u0000l\u0000a\u0000y\u0000i\u0000n\u0000g\u0000,\u0000 \u0000o\u0000r\u0000d\u0000e\u0000r\u0000e\u0000d\u0000 \u0000b\u0000y\u0000 \u0000t\u0000o\u0000t\u0000a\u0000l\u0000 \u0000n\u0000u\u0000m\u0000b\u0000e\u0000r\u0000.\u0000 \u0000\n\u0000/\u0000/\u0000 \u0000O\u0000n\u0000 \u0000s\u0000t\u0000e\u0000r\u0000e\u0000o\u0000 \u0000s\u0000y\u0000s\u0000t\u0000e\u0000m\u0000s\u0000,\u0000 \u0000o\u0000n\u0000l\u0000y\u0000 \u0000t\u0000h\u0000e\u0000 \u0000f\u0000i\u0000r\u0000s\u0000t\u0000 \u00002\u0000 \u0000c\u0000h\u0000a\u0000n\u0000n\u0000e\u0000l\u0000s\u0000 \u0000p\u0000l\u0000a\u0000y\u0000.\u0000\n\u0000T\u0000d\u0000e\u0000f\u0000(\u0000\\\u0000e\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000{\u0000 \u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000 \u0000=\u0000 \u00002\u0000;\u0000\t\u0000/\u0000/\u0000 \u0000o\u0000n\u0000e\u0000 \u0000y\u0000e\u0000a\u0000r\u0000 \u0000i\u0000s\u0000 \u00002\u0000 \u0000s\u0000e\u0000c\u0000o\u0000n\u0000d\u0000s\u0000\n\u0000\t\u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000.\u0000d\u0000o\u0000 \u0000{\u0000 \u0000|\u0000y\u0000e\u0000a\u0000r\u0000,\u0000 \u0000i\u0000|\u0000 \u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000,\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000n\u0000u\u0000m\u0000y\u0000e\u0000a\u0000r\u0000s\u0000 \u0000=\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000y\u0000e\u0000a\u0000r\u0000s\u0000.\u0000s\u0000i\u0000z\u0000e\u0000;\u0000 \u0000\n\u0000\t\u0000\t\u0000/\u0000/\u0000 \u0000o\u0000r\u0000d\u0000e\u0000r\u0000e\u0000d\u0000 \u0000b\u0000y\u0000 \u0000t\u0000o\u0000t\u0000a\u0000l\u0000 \u0000n\u0000u\u0000m\u0000b\u0000e\u0000r\u0000,\u0000 \u0000o\u0000n\u0000 \u0000s\u0000t\u0000e\u0000r\u0000e\u0000o\u0000,\u0000 \u0000o\u0000n\u0000l\u0000y\u0000 \u0000f\u0000i\u0000r\u0000s\u0000t\u0000 \u00002\u0000 \u0000p\u0000l\u0000a\u0000y\u0000.\u0000\n\u0000\t\u0000[\u0000\\\u0000S\u0000o\u0000u\u0000t\u0000h\u0000,\u0000 \u0000\\\u0000M\u0000i\u0000d\u0000w\u0000e\u0000s\u0000t\u0000,\u0000 \u0000 \u0000\\\u0000W\u0000e\u0000s\u0000t\u0000,\u0000 \u0000\\\u0000N\u0000o\u0000r\u0000t\u0000h\u0000e\u0000a\u0000s\u0000t\u0000 \u0000]\u0000.\u0000d\u0000o\u0000 \u0000{\u0000 \u0000|\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000,\u0000 \u0000j\u0000|\u0000 \u0000\n\u0000\n\u0000\t\u0000\t\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000 \u0000=\u0000 \u0000q\u0000.\u0000e\u0000x\u0000e\u0000c\u0000d\u0000a\u0000t\u0000a\u0000.\u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000s\u0000[\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000]\u0000.\u0000p\u0000o\u0000s\u0000t\u0000l\u0000n\u0000;\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000 \u0000=\u0000 \u0000r\u0000e\u0000g\u0000i\u0000o\u0000n\u0000[\u0000i\u0000 \u0000+\u0000 \u00001\u0000]\u0000;\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000[\u0000r\u0000e\u0000g\u0000N\u0000a\u0000m\u0000e\u0000,\u0000 \u0000y\u0000e\u0000a\u0000r\u0000,\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000]\u0000.\u0000p\u0000o\u0000s\u0000t\u0000l\u0000n\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000t\u0000i\u0000c\u0000k\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000i\u0000f\u0000 \u0000(\u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000 \u0000>\u0000 \u00000\u0000)\u0000 \u0000{\u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000(\u0000i\u0000n\u0000s\u0000t\u0000r\u0000u\u0000m\u0000e\u0000n\u0000t\u0000:\u0000 \u0000\\\u0000n\u0000o\u0000i\u0000s\u0000e\u0000p\u0000u\u0000l\u0000s\u0000e\u0000s\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000\t\u0000l\u0000e\u0000g\u0000a\u0000t\u0000o\u0000:\u0000 \u00001\u0000,\u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000\t\u0000d\u0000u\u0000r\u0000:\u0000 \u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000\t\u0000n\u0000u\u0000m\u0000P\u0000u\u0000l\u0000s\u0000e\u0000s\u0000:\u0000 \u0000n\u0000u\u0000m\u0000E\u0000x\u0000e\u0000c\u0000s\u0000,\u0000 \u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000\t\u0000p\u0000a\u0000n\u0000:\u0000 \u0000j\u0000 \u0000*\u0000 \u00000\u0000.\u00005\u0000 \u0000-\u0000 \u00000\u0000.\u00002\u00005\u0000 \u0000\t\u0000/\u0000/\u0000 \u0000t\u0000o\u0000 \u00004\u0000 \u0000c\u0000h\u0000a\u0000n\u0000n\u0000e\u0000l\u0000s\u0000\n\u0000\t\u0000\t\u0000\t\u0000\t\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\t\u0000\t\u0000\t\u0000}\u0000;\u0000\n\u0000\t\u0000\t\u0000}\u0000;\u0000\n\u0000\t\u0000\t\u0000y\u0000e\u0000a\u0000r\u0000D\u0000u\u0000r\u0000.\u0000w\u0000a\u0000i\u0000t\u0000;\u0000\n\u0000\t\u0000}\u0000;\u0000\n\u0000}\u0000)\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000)\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u00002\u0000 \u0000i\u0000n\u0000l\u0000i\u0000n\u0000e\u0000 \u0000c\u0000o\u0000d\u0000e\u0000 \u0000e\u0000x\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000\n\u0000{\u0000 \u0000S\u0000i\u0000n\u0000O\u0000s\u0000c\u0000.\u0000a\u0000r\u0000(\u0000[\u0000M\u0000o\u0000u\u0000s\u0000e\u0000X\u0000.\u0000k\u0000r\u0000(\u00002\u00000\u00000\u0000,\u0000 \u00003\u00000\u00000\u00000\u0000,\u0000 \u00001\u0000)\u0000,\u0000 \u0000M\u0000o\u0000u\u0000s\u0000e\u0000Y\u0000.\u0000k\u0000r\u0000(\u00002\u00000\u00000\u0000,\u0000 \u00003\u00000\u00000\u00000\u0000,\u0000 \u00001\u0000)\u0000]\u0000)\u0000 \u0000*\u0000 \u00000\u0000.\u00000\u00001\u0000 \u0000}\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000\n\u0000{\u0000 \u0000H\u0000e\u0000n\u0000o\u0000n\u0000C\u0000.\u0000a\u0000r\u0000(\u00002\u00000\u00000\u00000\u0000,\u0000 \u0000L\u0000F\u0000N\u0000o\u0000i\u0000s\u0000e\u00002\u0000.\u0000k\u0000r\u0000(\u0000[\u00001\u0000,\u0000 \u00001\u0000]\u0000,\u0000 \u00000\u0000.\u00002\u0000,\u0000 \u00001\u0000.\u00004\u0000)\u0000,\u0000 \u00000\u0000.\u00001\u00004\u0000)\u0000 \u0000*\u0000 \u00000\u0000.\u00002\u0000 \u0000}\u0000.\u0000p\u0000l\u0000a\u0000y\u0000(\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\t\u0000/\u0000/\u0000 \u0000f\u0000i\u0000g\u0000u\u0000r\u0000e\u0000 \u00001\u00003\u0000.\u00007\u0000 \u0000-\u0000 \u0000S\u0000o\u0000n\u0000i\u0000f\u0000i\u0000c\u0000a\u0000t\u0000i\u0000o\u0000n\u0000 \u0000o\u0000f\u0000 \u0000t\u0000a\u0000g\u0000 \u0000s\u0000y\u0000s\u0000t\u0000e\u0000m\u0000s\u0000\n\u0000(\u0000\n\u0000/\u0000/\u0000 \u0000c\u0000o\u0000m\u0000p\u0000a\u0000r\u0000e\u0000 \u0000t\u0000w\u0000o\u0000 \u0000a\u0000x\u0000i\u0000o\u0000m\u0000s\u0000 \u0000o\u0000n\u0000 \u0000l\u0000e\u0000f\u0000t\u0000 \u0000a\u0000n\u0000d\u0000 \u0000r\u0000i\u0000g\u0000h\u0000t\u0000 \u0000c\u0000h\u0000a\u0000n\u0000n\u0000e\u0000l\u0000s\u0000\n\u0000/\u0000/\u0000 \u0000\u00bc\u0003 \u0000=\u0000 \u00004\u0000 \u0000(\u0000s\u0000i\u0000z\u0000e\u0000 \u0000o\u0000f\u0000 \u0000a\u0000l\u0000p\u0000h\u0000a\u0000b\u0000e\u0000t\u0000)\u0000\n\u0000/\u0000/\u0000 \u0000v\u0000 \u0000(\u0000d\u0000e\u0000l\u0000e\u0000t\u0000i\u0000o\u0000n\u0000 \u0000n\u0000u\u0000m\u0000b\u0000e\u0000r\u0000)\u0000 \u0000v\u0000a\u0000r\u0000i\u0000e\u0000s\u0000 \u0000[\u00001\u0000.\u0000.\u00006\u0000]\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000h\u0000o\u0000r\u0000i\u0000z\u0000o\u0000n\u0000t\u0000a\u0000l\u0000 \u0000c\u0000u\u0000r\u0000s\u0000o\u0000r\u0000 \u0000p\u0000o\u0000s\u0000i\u0000t\u0000i\u0000o\u0000n\u0000\n\u0000{\u0000\n\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000t\u0000a\u0000g\u0000,\u0000 \u0000r\u0000u\u0000l\u0000e\u0000s\u0000,\u0000 \u0000v\u0000a\u0000l\u0000;\u0000\n\u0000\t\u0000r\u0000u\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000[\u0000[\u00000\u0000,\u0000 \u00001\u0000,\u0000 \u00001\u0000]\u0000,\u0000 \u0000[\u00001\u0000,\u0000 \u00003\u0000,\u0000 \u00002\u0000,\u0000 \u00000\u0000]\u0000,\u0000 \u0000[\u00001\u0000,\u0000 \u00002\u0000]\u0000,\u0000 \u0000[\u00003\u0000,\u0000 \u00001\u0000,\u0000 \u00001\u0000]\u0000]\u0000;\u0000 \u0000/\u0000/\u0000 \u0000s\u0000a\u0000m\u0000e\u0000 \u0000r\u0000u\u0000l\u0000e\u0000 \u0000f\u0000o\u0000r\u0000 \u0000b\u0000o\u0000t\u0000h\u0000\n\u0000\t\u0000v\u0000 \u0000=\u0000 \u0000M\u0000o\u0000u\u0000s\u0000e\u0000X\u0000.\u0000k\u0000r\u0000(\u00001\u0000,\u0000 \u00006\u0000)\u0000;\u0000\n\u0000\t\u0000v\u0000a\u0000l\u0000 \u0000=\u0000 \u0000d\u0000u\u0000p\u0000 \u0000{\u0000\n\u0000\t\u0000\t\u0000v\u0000a\u0000r\u0000 \u0000a\u0000x\u0000i\u0000o\u0000m\u0000 \u0000=\u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000.\u0000f\u0000i\u0000l\u0000l\u0000(\u00001\u00004\u0000,\u0000 \u0000{\u0000 \u0000#\u0000[\u00000\u0000,\u0000 \u00001\u0000,\u0000 \u00002\u0000,\u0000 \u00003\u0000]\u0000.\u0000c\u0000h\u0000o\u0000o\u0000s\u0000e\u0000 \u0000}\u0000)\u0000;\u0000 \u0000a\u0000x\u0000i\u0000o\u0000m\u0000.\u0000j\u0000o\u0000i\u0000n\u0000.\u0000p\u0000o\u0000s\u0000t\u0000l\u0000n\u0000;\u0000\n\u0000\t\u0000\t\u0000D\u0000u\u0000t\u0000y\u0000.\u0000a\u0000r\u0000(\u00001\u0000 \u0000/\u0000 \u0000S\u0000a\u0000m\u0000p\u0000l\u0000e\u0000R\u0000a\u0000t\u0000e\u0000.\u0000i\u0000r\u0000,\u0000 \u00000\u0000,\u0000 \u0000 \u0000D\u0000t\u0000a\u0000g\u0000(\u00007\u0000e\u00005\u0000,\u0000 \u0000v\u0000,\u0000 \u0000a\u0000x\u0000i\u0000o\u0000m\u0000,\u0000 \u0000r\u0000u\u0000l\u0000e\u0000s\u0000)\u0000,\u0000 \u0000d\u0000o\u0000n\u0000e\u0000A\u0000c\u0000t\u0000i\u0000o\u0000n\u0000:\u0000 \u00002\u0000)\u0000;\u0000\n\u0000\t\u0000}\u0000 \u0000*\u0000 \u00000\u0000.\u00001\u0000\n\u0000}\u0000.\u0000p\u0000l\u0000a\u0000y\u0000;\u0000\n\u0000)\u0000\n\u0000",
    "1_Magellan_Final_Prep.scd": "/*\n\nRequired Quarks: \n\n\tMathLib - includes nSorted method\n\nRecommended Quarks:\n\tSpeakersCorner - includes SpatioScope class for demonstrating spatialisation.\n\n\nQuarks.install(\"MathLib\");\nQuarks.install(\"SpeakersCorner\");\n\n*** recompile if needed ****\n\n1_Magellan_Final_Prep.scd\n\tReads in all data for the magellan sonification, \n\topens other text docs.\n\n2_PlaySingleCountries.scd\n\tplay contries individually\n3_Magellan_Reise.scd\n\tload timeline data (comments in German)\n\t\n4_windDev.scd\n\tthe motion noise, wind and storm sound\n\n5_FinalPlayer.scd\n\tplay the full piece (8 channels)\n\t\t\n6_VariousTests.scd\n\tindividual steps of the piece, for debugging\n\t\n*/\n\n(\nq = q ? ();\nq.dir = Document.current.path.dirname;\n//\tq.filename = q.dir ++ \"/ICADConcertData_Extend2.txt\";\n\tq.filename = q.dir ++ \"/ICADConcertData_Magellan.txt\"; // this data file for magellan\n\nq.text = TabFileReader.read(q.filename, true, false);\n\n\t\t// read the definitive timeline:\n(q.dir ++ \"/3_Magellan_Reise.scd\").loadPaths;\n\nq.names1 = q.text[0];\n\nq.chanNames = q.names1.collect(_.asSymbol);\n\n// Document.new(\"chanNames:\", q.chanNames.asCompileString); \nDocument.open(q.dir ++ \"/5_FinalPlayer.scd\"); \n// Document.open(q.dir ++ \"/4_windDev.scd\"); \nDocument.open(q.dir ++ \"/2_PlaySingleCountries.scd\"); \n\nq.dataChans = q.text\n\t.drop(1)\t\t// drop first line, chanNames\n\t.flop;\t\t\t\t// swap rows and columns\n\n\t// read using sonenvir class SEData: \n\nq.worlddata = SEData.fromNamesData(\n\t\\world,\n\tq.chanNames, \n\tq.dataChans\n);\n\n\t\t// convert channels with names to symbols\n[ 'Country', 'Capital', 'Region' ].do { |name, i| \n\tvar chandata = q.worlddata.atChan(name).data;\n\tchandata.do { |str, i| chandata.put(i, str.asSymbol) };\n};\n\n\t// convert channels with numbers to floats for better math precision:\nq.numberChannels = q.chanNames.reject(\n\t[ 'Country', 'Capital', 'Region', 'Latitude_deg', 'Longitude_deg' ].includes(_)\n); \n\nq.numberChannels.do { |name, i| \n\tvar data = q.worlddata.atChan(name).data;\n\tdata.do { |str, i| \n\t\tvar num = if (str.every({ |ch| ch.isDecDigit.not }), nil, str.asFloat);\n\t\tdata.put(i, num);\n\t};\n};\n\nq.worlddata.analyse; \n\n//\ttwo utilities for distance and angle on the sphere:\n\nq.rad2Deg = 180/pi; q.deg2Rad = pi / 180; \nq.earthRadius = 6372.8; \n\nq.sphDist = { |q, lat1, long1, lat2, long2, format=\\rad| \n\tvar res;\n\tlat1 = lat1 * q.deg2Rad; long1 = long1 * q.deg2Rad;\n\tlat2 = lat2 * q.deg2Rad; long2 = long2 * q.deg2Rad;\n\n\tres = 2 * asin( (\n\t\tsin(lat2 - lat1 * 0.5).squared \n\t\t+ (cos(lat1) * cos(lat2) * sin((long2 - long1).abs * 0.5).squared)\n\t\t).sqrt\n\t); \n\tif (format == \\rad, res, { res * q.rad2Deg });\n}; \n\nq.sphAngle = { |q, lat1, long1, lat2, long2, format=\\rad| \n\t// shorten angle by the ratio of higherLat / lowerLat to \n\t\n\tvar highLat, lowLat, shorten; \n\t#highLat, lowLat = [lat1, lat2].sort { |a, b| a.abs > b.abs }; \n\tshorten = (1-highLat.abs) / (1-lowLat.abs); \n\t\n\t(long2 - long1 @ (lat2 - lat1 * shorten)).theta \n\t* (if (format == \\rad, 1, q.rad2Deg))\n}; \n\nq.getTopN = {\u00ca|q, n = 40, curlat=0, curlong=0| \n\tq.vectors.collect({ |vect| vect ++ q.sphDist(vect[1], vect[2], curlat, curlong) })\n\t\t.nSorted(n, {\u00ca|a, b| a.last < b.last  })\n\t\t.collect({ |iVect| \n\t\t\tvar i, vect; #i, vect = iVect; \n\t\t\tvect.add(  q.sphAngle(vect[1], vect[2], curlong, curlong) );\n\t\t});\n};\n\nq.vectors = q.worlddata.vectorsCollect([\\Country, \\Latitude, \\Longitude], { |vect, i| vect ++ i }); \n\nq.setWind = { |q, newCoord, event|\n\tvar speed, angle, dirPoint;\n\tq.lastCoord = q.lastCoord ? newCoord; \n\tq.lastAngle = q.lastAngle ? -0.75pi;\t// southwest; \n\t[q.lastCoord, q.lastAngle ];\n\tspeed = q.sphDist(q.lastCoord[0], q.lastCoord[1], newCoord[0], newCoord[1]) \n\t\t* 0.33 * q.earthRadius;\t\t// stimmt das so? muss ein durch timestep!!!\n\t\t\n\tangle = if (speed > 0, { \n\t\tq.sphAngle(q.lastCoord[0], q.lastCoord[1], newCoord[0], newCoord[1]);\n\t}, { q.lastAngle });\n\tdirPoint = Polar(1, angle).asPoint; \n\tq.lastCoord = newCoord; \n\tq.lastAngle = angle;\n// \t[ \\speed, speed, \\dirPoint, dirPoint, \\event, event].postln;\n\n\tevent = event ? q.lastEvent ? \\normal;\n\t\n\tevent.switch(\n\t\t\\storm, { \n\t\t\t~wind.set(\n\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\\freq, rrand(450, 600), \n\t\t\t\t\\dRate, rrand(12, 15), \\drift, rrand(7, 10), \\q, 2.5, \n\t\t\t\t\\focus, rrand(0.2, 0.4)\n\t\t\t) }, \n\t\t\\calm, { \n\t\t\t~wind.set(\n\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\\freq, rrand(50, 60), \n\t\t\t\t\\dRate, 1, \\drift, 2, \n\t\t\t\t\\q, 1, \n\t\t\t\t\\focus, rrand(0.2, 0.5)\n\t\t\t) }, \n\t\t\\normal, {\t\n\t\t\t\\default.postln;\n\t\t\t~wind.set(\n\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\\freq, speed * 3 + 70, \n\t\t\t\t\\dRate, 3, \\drift, rrand(2.5, 4), \n\t\t\t\t\\q, speed * 0.05 + 1, \n\t\t\t\t\\focus, ((speed + 5) * 0.2)\n\t\t\t) }\n\t);\n\tq.lastEvent = event;\n};\n)\n/*\n\t// some tests to see that the data loaded OK: \nq.worlddata.chanNames.postcs;\n\t\t// some name channels\nq.worlddata.atChan('Country').postcs;\nq.worlddata.atChan('Capital').postcs;\nq.worlddata.atChan('Region').postcs;\n\n\t\t// some number channels\nq.worlddata.atChan('Population').postcs;\nq.worlddata.atChan('GDP_dollar').postcs;\nq.worlddata.atChan('GDP_per_capita').postcs;\nq.worlddata.atChan('Housing_total').postcs;\n\nq.worlddata.atChan('Latitude').data.postcs.plot;\nq.worlddata.atChan('Longitude').data.postcs.plot;\nq.worlddata.atChan('Latitude').data;\nq.worlddata.atChan('Longitude').data.do { |d, i| [i, d.round(0.1)].postln };\n\n\nq.worlddata.channels.do { |chan| [chan.name, chan.min, chan.max, chan.avg, chan.numNil].postln };\n*/\n\n/* test for geometry\n\na = q.worlddata.atVector(5, [ 'Country', 'Latitude', 'Longitude' ]);\nq.worlddata.atChan('Country').data.indexOf('Spain');\n\nb = q.worlddata.atVector(158, [ 'Country', 'Latitude', 'Longitude' ]);\n\nc = [ 'Victoria', b[1], b[2] ];\n\nq.sphDist(a[1], a[2], b[1], b[2]) * q.earthRadius;\n\n\t// angles: 0 is west, 0.5pi is north, pi is east, -0.5pi is south:\nq.sphAngle(50, 0, 50, 20);\t\t// ca London -> Kiew\nq.sphAngle(50, 0, 60, 0);\t\t// ca London -> Hebrides\nq.sphAngle(50, 0, 50, -120);\t// ca London -> Vancouver\nq.sphAngle(50, 0, 5, 0);\t\t// ca London -> Accra\n\n\t\t// Antigua_and_Barbuda -> Spain\nq.sphAngle(a[1], a[2], b[1], b[2], \\deg); //  ca 45 deg NW, OK!\n\nq.sphAngle(a[1], a[2], b[1], b[2]); \n\n*/\n\n// ten closest countries to sevilla: \n/*\nq.vectors = q.worlddata.vectorsCollect([\\Country, \\Latitude, \\Longitude], { |vect, i| vect ++ i }); \n\nq.vectors;\nq.currPos = [\\victoria, 37.5, -6];\n\n\nq.topN = q.getTopN(10, 37.5, -6); q.topN.round(0.01).printAll;\n\nq.topN = q.getTopN(10, -37.5, 174); q.topN.round(0.01).printAll;\n\nq.topN.do { |list| [ list[4] * q.earthRadius, list].round(0.01).postln; };\n\n*/\n",
    "2_PlaySingleCountries.scd": "/* \tMagellan Single Country Examples\n\nServer.default = s = Server.internal.boot;\np = ProxySpace.push(s);\n\n1. \trun ./1_MagellanFinalPrep.scd first to load data.\n2.\trun this entire file to try what single countries sound like\n3.\trun the piece from file 5_FinalPlayer.scd\n\n\n//////// some countries to try line by line\n\n\t// little water: \nq.setPxFromData(\\Afghanistan); \t// no gini\nq.setPxFromData(\\Laos); \t\t// gini known\n\t\n\t// low population density:\nq.setPxFromData(\\Mongolia); \t\n\n\t// high pop density\nq.setPxFromData(\\Hong_Kong); \t\nq.setPxFromData(\\China); \t\t\n\n\nq.setPxFromData(\\Denmark); \t\t\t// lowest gini\nq.setPxFromData(\\Switzerland); \t\t// slightly higher gini\nq.setPxFromData(\\United_States); \t// much higher gini\n\n\t// very poor, no gini\nq.setPxFromData(\\East_Timor); \t\nq.setPxFromData(\\Cape_Verde); \n\t// very rich, no gini\nq.setPxFromData(\\Brunei); \n\n\t// poor, known gini\nq.setPxFromData(\\Mozambique); \t\t// low gini\nq.setPxFromData(\\Lesotho); \t\t\t// VERY high gini\nq.setPxFromData(\\Sierra_Leone); \t\t// highest of all ginis\n\n\n\n*/\n(\n\t// adapt to number of speakers available!\nq.numSpeakers = 8;\t\t\n \n~single = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, \n\tattack=0.0, decay = 1.0, dens = 2,\n\t amp = 0.2, x = 0, y = 1, step=0.33333| \n\t \n\tvar freqs, exciter, resonator, ampcomp, pos; \n\t\n\tfreqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\texciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07) \t// five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude compensation for density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// soft background noise 'halo' for fusion\n\t\t\t* (decay ** -0.5);\t\t\t\t\t// amplitude compensation for decay time\n\t\t\t\t\n\tresonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\t\t// convert x, y to angle for panaz, \n\t\t// and rotate to look west.\n\tpos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (-pi.reciprocal) + 0.5; \n\n\tPanAz.ar(q.numSpeakers, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n\nq.setPxFromData = { |q, name, proxy| \n\t\tvar cntIndex = q.worlddata.atChan('Country').data.indexOf(name); \n\t\tvar dataVect = q.worlddata.atVector(cntIndex, \n\t\t\t[\\GDP_per_capita, \\Density, \\Drinking_total, \\prop10, \\prop20]);\n\t\t\n\t\tvar gdp, dens, drink, prop10, prop20; \n\t\t[name, cntIndex, dataVect].postln; \n\t\t#gdp, dens, drink, prop10, prop20 = dataVect; \n\t\t\n\t\tgdp = gdp.expexp(400, 58900, 200, 2200); \n\t\tdens = dens.expexp(1.8, 16204.5, 1.8, 170); \n\t\tdrink = (drink ? 100).linlin(13, 100, 0.2, 1.5);  // 1.5 secs max\n\t\tproxy = proxy ?\u00ca~single; \n\t\tproxy.set(\t\t\t\n\t\t\t\\rootFreq, gdp, \n\t\t\t\\outProp, (prop10 ? 1.2).sqrt, \t// unknown ginis form quartertone cluster\n\t\t\t\\inProp, (prop20 ? 1.1).sqrt, \t \n\t\t\t\\decay, drink, \t\t\t\t\n\t\t\t\\dens, dens \n\t\t);\n};\n\n~single.playN(vol: 0.25);\n\nq.makeButsWin = {\n\tvar w, btns;\n\tw = Window( \"Select a Country\", Rect( 128, 400, 1020, 480 ));\n\n\tw.view.decorator = FlowLayout( w.view.bounds, 4@4, 1@1 );\n\tw.view.background = Color( 0.6, 0.8, 0.8 );\n\n\tbtns = q.worlddata.atChan(\\Country).data.collect({ arg name;\n\t\t// the same is true for all other widgets\n\t\tButton( w, Rect( 0, 0, 100, 24 ))\n\t\t\t.states_([[ name, Color.black, Color.rand(0.6, 1.0) ]])\n\t\t\t.action_({ q.setPxFromData(name); });\n\t});\n\tw.front;\n};\nq.makeButsWin;\n\nSpec.add(\\rootFreq, \\freq);\nSpec.add(\\outProp, [1, 100, \\exp, 0.01, 10]);\nSpec.add(\\inProp, [1, 100, \\exp, 0.01, 10]);\nSpec.add(\\attack, [0.0001, 0.1, \\exp, 0.0001, 0.01]);\nSpec.add(\\decay, [0.1, 100, \\exp, 0.01, 1]);\nSpec.add(\\dens, [1, 1000, \\exp, 0.01, 10]);\nSpec.add(\\x, \\pan); Spec.add(\\y, \\pan);\nSpec.add(\\step, [0.001, 1, \\exp, 0.001, 0.1]);\n\nNodeProxyEditor(~single, 12);\n\n\t// a window to try changing the directions\nq.dirwin = Window(\"Check Directions\", Rect(350,0,240,240)).front;\nStaticText(q.dirwin, Rect(70, 0, 100, 20)).string_(\"West\").align_(\\center);\nStaticText(q.dirwin, Rect(70, 220, 100, 20)).string_(\"East\").align_(\\center);\nStaticText(q.dirwin, Rect(0, 50, 20, 100)).string_(\"S\\no\\nu\\nt\\nh\").align_(\\center);\nStaticText(q.dirwin, Rect(220, 50, 20, 100)).string_(\"N\\no\\nr\\nt\\nh\").align_(\\center);\n\nSlider2D(q.dirwin, Rect(20,20,200,200))\n\t.x_(0.5).y_(1)\n\t.action = { |sl2d| ~single.set(\\x, sl2d.x * 2 - 1, \\y, sl2d.y * 2 - 1) };\n\n\t// show the speaker setup and sound levels in a SpatioScope if there\nq.makeSpatio = { \n\tvar spatClass = 'SpatioScope'.asClass; \n\nif (spatClass.notNil) { \n\tq.spatio = spatClass.rings([8], 0.8, -0.625pi, bounds: Rect(0, 0, 220, 220));\n\tq.spatio.parent.bounds_(q.spatio.parent.bounds.moveTo(600,0));\n} { \n\"\t//The SpatioScope class (not installed) could be useful here.\n\t// To install it, do :\n\tQuarks.install(\\\"SpeakersCorner\\\");\".postln;\n}\n};\nq.makeSpatio;\n)\n\n",
    "3_Magellan_Reise.scd": "// \tTranscription of Travel timeline: \n\n//\tTimeline mostly from Stefan Zweig: Magellan, der Mann und seine Tat, 1937; \n//\tSOME details from Antonio Pigafetta: Mit Magellan um die Erde, Edition Erdmann, 2001\n//\t(Dank an Peter Jakober!)\n\nq.timeline = [\n\t[10,  8, 1519, 36.7, -6, nil, 'leave_sevilla'], \t\n\t\t\t//datum 10.8.1519; Breitengrad, L\u008angengrad,(wikipedia) \n\t\t\t// Richtungen: (0 westen, 1, norden, 2 osten 3 s\u009fden), information\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t//anzahl der matrosen, \n\t\t\t// Schiffe: \tTrinidad, \t\t130 Tonnen, 66 Mann( + Magellan)\n\t\t\t//\t\t\tSan Antonio,\t\t130 Tonnen, 60 Mann\n\t\t\t//\t\t\tConcepcion,\t\t90 Tonnen,  45 Mann\n\t\t\t//\t\t\tVictoria,\t\t\t90 Tonnen,  42 Mann\n\t\t\t//\t\t\tSantiago,\t\t\t60 Tonnen,  32 Mann\n\t\t\t// M\u0080NNER: 234; 170 Spanier, 40 Portugiesen, 20 Italiener, afrikanische und asiatische Dolmetscher\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\t[20,  8, 1519, 36.4, -6.4,  nil, 'reach_sanlucar'], // erfunden\n\t[20,  9, 1519, 36.4, -6.4,  nil, 'leave_sanlucar'], // open sea\n\t\t\t//Info: spanische Autorit\u008aten versuchen die Reise zu verhindern\n\t\n\t[26,  9, 1519,  28.5, -16,  nil, 'reach_teneriffa'],\n\t\t\t// 3 Tage in Teneriffa dann Monte Rosse\n\t\n\t[ 3, 10, 1519,  28.5, -16,  nil, 'leave_teneriffa'],\n\t\t\t// zu mitternacht wird in see gestochen\n\t\t\t// keine verluste gemeldet...\n\n\n\t\t\t// 14. oktober heftige st\u009frme, 14\u00a1 n\u009ardlicher breite\n\t\t\t//stimmung der mannscht verschlechtert sich...wollen heimkehren\n\t[14, 10, 1519,  14, -23.5, 'storm'],\n//\t[15, 10, 1519,  14.4, -23.5, 'normal'],\n\n\t[16, 10, 1519,  14.9, -23.5,  \\normal, 'reach_cape_verde'],\n\t[26, 10, 1519,  14.9, -23.5,  nil, 'leave_cape_verde'],\n\t\n\t[ 28, 11, 1519,  0, -30,  nil, 'cross equator'],\t\t// long is estimate\n\t\t\t//Pigafetta schreibt dass der Equator erst im Dezember erreicht wurde...\n\t\t\t//erste meuterei der spanischen kapit\u008ane, welche er durch die gefangennahme seines ersten offiziers beendet \n\t\t\t//(keine Berichte \u009fber tote gefunden...)\n\t\n\t[ 6, 12, 1519,  -8.4, -35,  nil, 'cape_san_augustin'], // near recife/olinda\n\n\t[13, 12, 1519, -23, -43.4, nil, 'reach_rio_de_janeiro'],\n\t\t\t//leiden unter hitze.\n\t\t\t//beschreibt die menschenfresser\n\t\t\t//nehmen anscheinend einen oder meherere Brasilianer an Board auf! (Kommen sp\u008ater im Text vor) (+ca 2Leute)\n\t\n\t\n\t[26, 12, 1519, -23, -43.4,  nil, 'leave_rio_de_janeiro'],\n\t\t\t//Pigafetta schreibt, dass sie erst am 27 dezember abreisen\n\t\t\t//wird noch nichts von Verlusten erw\u008ahnt \n\n\t\n\t[10,  1, 1520, -35, -55,  nil, 'reach_rio_de_la_plata'],\n\t[11,  1, 1520, -35, -55,  \\storm, ''],\n\t[13,  1, 1520, -35, -55,  \\normal, ''],\n\t\t\t//versuchten die meerenge zu finden, um, so Pigafetta, ins S\u009fdmeer zu kommen, ohne Erfolg\n\t\n\t[ 2,  2, 1520, -35, -55,  nil, 'leave_rio_de_la_plata'],\n\n\t\n\t[31,  3, 1520, -49.3, -67.6, nil, 'reach_port_san_julian'],  \n\t\t\t// stay for winter\n\t\t\t// die Essensrationen werden gek\u009frzt\n\t\t\t//nehemen 2 Riesen auf (+2 Leute)\n\t\n\t[ 1,  4, 1520, -49.3, -67.6, nil, 'mutiny'],\n\t\t\t//kapit\u008an Cartagena, armada , mendoza , coca gevierteilt, mendoza will fl\u009fchten und erschlagen dabei,  \n\t\t\t//MINUS 5 Leute\n\t\t\t//der portugiesische kapit\u008an wird begnadigt was wiederrum Hass hervorruft\n\t\t\t//der portugiesische Kapit\u008an und der Bischof versuchen magellan zu t\u009aten, scheitert, sie werden ausgesetzt\n\t\t\t//MINUS 2 Leute\n\t\n\t[ 7,  4, 1520, -49.3, -67.6, nil, 'verdict'],\n\n\t[10,  4, 1520, -49.3, -67.6,  \\storm],\t\t// these are invented, but typical\n\t[14,  4, 1520, -49.3, -67.6, \\normal],\t\t// invented\n\n\t[24,  4, 1520, -49.3, -67.6,  \\storm],\t\t// invented\n\t[26,  4, 1520, -49.3, -67.6,  \\normal],\t\t// invented\n\n\n\t[14,  5, 1520, -49.3, -67.6,  \\storm],\t\t// invented\n\t[21,  5, 1520, -49.3, -67.6,  \\normal],\t\t// invented\n\t\n\t[22,  5, 1520, -49.3, -67.6, nil, 'loss_of_ship_santiago'],\n\t\t\t//die Mannschaft \u009fberlebt aber durch ein Wunder und wird fernversorgt\n\n\t[30,  5, 1520, -49.3, -67.6,  \\storm],\t\t// these are invented, but typical\n\t[5,  6, 1520, -49.3, -67.6, \\normal],\t\t// invented\n\n\t[8,  6, 1520, -49.3, -67.6,  \\storm],\t\t// invented\n\t[20,  6, 1520, -49.3, -67.6,  \\normal],\t\t// invented\n\n\t[20,  7, 1520, -49.3, -67.6,  \\storm],\t\t// invented\n\t[27,  7, 1520, -49.3, -67.6,  \\normal],\t\t// invented\n\n\t[10,  8, 1520, -49.3, -67.6,  \\storm],\t\t// invented\n\t[15,  8, 1520, -49.3, -67.6,  \\normal],\t\t// invented\n\t\n\t[24,  8, 1520, -49.3, -67.6, nil, 'leave_port_san_julian'],\n\t\n\t[14, 9, 1520, -50, -68.5, nil, 'reach_rio_santa_cruz'],\n\t\t\t// laut Pigafetta erreichen sie Santa Cruz schon am 14. September!\n\t\t\t// (bleiben dort 2 monate wegen Gefahr von Schiffbruch)\n\t\n\t[14, 10, 1520, -50, -68.5, nil, 'leave_rio_santa_cruz'],\n\t\t\t// laut Pigafetta erreichen sie Santa Cruz schon am 14. September!\n\t\t\t// (bleiben dort 2 monate wegen Gefahr von Schiffbruch)\n\n\t[21, 10, 1520, -52.7, -68.35, nil, 'reach_cape_of_virgins'], \n\t\t\t//San Antonio und Concepcion werden vorausgeschickt\n\t\t\t// entry_of_passage\n\t[22, 10, 1520, -52.7, -68.35, 'storm'], \n\t\t\t//San Antonio und Concepcion werden vorausgeschickt\n\t\t\t// entry_of_passage\n\t[24, 10, 1520, -52.7, -68.35, 'normal'], \n\t\t\t//San Antonio und Concepcion werden vorausgeschickt\n\t\t\t// entry_of_passage\n\t\n\t[25, 10, 1520, -52.7, -68.35, nil, 'enter_passage'],   // 1. 11.!\n\t\t\t//laut Pigafetta fahren sie erst am 1.November in die Meeresenge rein.\n\t\t\t//Magellan nennt die Enge ja auch \"Allerheiligenstra\u00a7e\"\n\t\n\t[1, 11, 1520, -52.7, -69.5, nil, 'turn'],\n\t\n\t[3, 11, 1520, -53.15, -70.9, nil, 'turn'],\t\t\t// punta arenas\n\t[5, 11, 1520, -54, -71.2, nil, 'turn'],\t\t\t// monte victoria\n\t\n\t[ 8, 11, 1520, -52.5, -69.5, nil, 'desertion_ship_san_antonio'],\n\t\t\t//schreibt nichts ob die volle Besatzung des Schiffes nach hause f\u008ahrt, ich nehme die volle besatzung an..\n\t\t\t//MINUS 59 Leute; der urspr\u009fngliche Kapit\u008an wurde ja schon vorher umgebracht \n\t\n\t[28, 11, 1520, -52.8, -74.6, nil, 'enter_pacific_ocean'], // cabo deseado\n\t\t\t//Essensnot, man i\u00a7t verfaultes \n\t\t\t//MINUS 4 Leute: Hungertod\n\t\t\t//Krankheit: Zahnfleischerkrankung, k\u009annen nichts essen, daher:\n\t\t\t//MINUS 19 Leute (auch einer der Riesen ist dabei)\n\t\t\t//essen Ratten - gibt einen Streit: MINUS 2 M\u008anner \n\t\t\t\t// (bei diesem Streit erschl\u008agt der eine den anderen, der T\u008ater wird erdrosselt)\n\t\n\t[24,  1, 1521, -18.2, -140.8, nil, 'pass_san_pablo'],\t// now hao island\n\t\t\t//Magellan meint die Magnetnadel besitzt auf der s\u009fdlichen halbkugel keine Kraft den Nordpol zu finden\n\t\n\t[ 4,  2, 1521, 0, -160, nil, 'pass_tiburon_islands'], // unauffindbar, interpoliert\n\t\t\t//erreichen Cipangus (Japan)\n\t\t\t//hoffen die Gew\u009frzinseln zu erreichen\n\n\t[ 16,  2, 1521, 13, -179.74, nil, 'cross_dateline'], // interpolated: cross dateline!\n\t[ 17,  2, 1521, 13, 178.56, nil, 'passed_dateline'], // interpolated: cross dateline!\n\t\n\t[ 6,  3, 1521, 13.4, 144.7, nil, 'reach_ladrones'],\t   // now mariana islands, taking guam\n\t\t\t//es kommt zu Feindseligkeiten zwischen den Einheimischen und der Schiffsbesatzung\n\t\t\t//bei den Feindseligkeiten wird ein Matrose verletzt, Beinamputation, MINUS 1 Mann,  da er an den Folgen stirbt\n\t\n\t[16,  3, 1521, 10.8, 125.8, nil, 'reach_samar'],   // wikip says homonhon philippines ...\n\t\t\t//gutes Verh\u008altnis zwischen der Crew und den Insulanern\n\t\t\t//Insulaner werden durch Kanonfeuer stark erschreckt!\n\t\t\t//Laut Wikipedia sind zu dieser Zeit noch 150 Mann am Leben (das stimmt eigentlich mit meiner Berechnung \u009fberein!!!!)\n\t\n\t[28,  3, 1521, 10, 125, nil, 'reach_massawa'], \t//  stimmt!\n\t\t\t//K\u009anigsbesuch - man prahlt mit Waffen\n\t\t\t//Gutes Verh\u008altnis - Tauschhandel\n\t\t\t//Ein bestrafter Matrose wird gegen einen Einheimischen Piloten ausgetauscht\n\t\t\t//Auch der K\u009anig von Massawa begleitet sie\n\t\n\t[ 7,  4, 1521, 10.3, 123.9, nil, 'reach_cebu'],\n\t\t\t//dicke Freundschaft mit dem  K\u009anig\n\t\t\t//christliche Missionierung - es werden 800 Einheimische getauft\n\t\t\t//MINUS 2 Mann, Tod wegen zuviel Essens, nach der Hungerzeit\n\t\t\t//die Freundschaft ist der Grund f\u009fr den Angriff auf Mactan\n\t  \n\t[27,  4, 1521, 10.2, 124, nil, 'death_magellan_on_mactan'],\n\t\t\t//60 Mann der Besatzung greifen gemeinsam mit Magellan an und stehen einem Heer von 1500 gegen\u009fber\n\t\t\t//Bei dem Kampf sterben 8 Mann und Magellan (MINUS 9 Mann) \n\t \n\t[ 1,  5, 1521, 10.2, 124, nil, 'death_serrao_and_barbosa'],\n     //Verrat durch den Dolmetscher und durch den mittlerweile getauften christlichen K\u009anig (K\u009anig von Cebu),\n     //Bei diesem Verrat werden 24 Mann (darunter barobosa) erschlagen der Dollmetscher l\u008auft \u009fber, und Serranos wird ausgesetzt:\n     //MINUS 26 Mann\n     \n          \n\t[ 4,  5, 1521, 10.2, 124, nil, 'burn_ship_concepcion'],  \n\t\t\t//schlechte Stimmung wegen des Tods Magellans und wegen der reduzierten Besatzung\n\n//\t[ 6,  5, 1521, lat, long, nil, 'deserted_san_antonio_reaches_sevilla'],  \n\n\t\t\t// erreichen zuerst auch im Juni Panilongon, wo Pigafetta den k\u009anig besucht, der ist wohlgesonnen\n\t\t\t// danach gehts nach Cagaian (lage laut pigafetta 7\u00a1 30') (gibt keine genauen Daten an...), \n\t\t\t// und erst dann wird palaoan erreicht\n\t\n\t[10,  6, 1521, 9.8, 118.7, nil, 'reach palawan'],  // when? - auch pigafetta macht da keinen genaueren angaben\n\t\t\t//erz\u008ahlt vom Hahnenkampf\n\n\t[21,  6, 1521, 9.8, 118.7, nil, 'leave_palawan'],  // \n\t\n\t[7,  7, 1521, 4.9, 114.9, 'storm'],  // when? stay for 35 days\n\t[8,  7, 1521, 4.9, 114.9, 'normal', 'reach_brunei'],  // when? stay for 35 days\n\t\t\t//laut pigafetta wird borneo am 8 Juli erreicht, kommen in den schwersten Sturm\n\t\t\t//wieder Austausch von Geschenken\n\t\t\t//MINUS 2 Matrosen laufen zu den Mauren \u009fber\n\t\t\t//Verrat durch den K\u009anig, wollen die Besatzung angreifen, misslingt,\n\t\t\t//2 Matrosen und der Sohn des Steuermanns werden nicht mehr auf das Schiff zur\u009fckgelassen (MINUS 3 Mann)\n\t\t\t//Kontakt auch mit den Heiden\n\t\n\t[12,  8, 1521, 4.9, 114.9, nil, 'leave_brunei'],  // \n\t\n\t\t\t// kommen auf der Insel Cimbombon an, auf der sie die Schiffe reparieren wollen\n\t\t\t//bleiben auf dieser Insel 42 tage, Der aufenhaltszeitraum d\u009frfte zwischen August und September sein.\n\t\t\t//Im September verlassen sie die Insel und bestimmen vorher noch neue Kapit\u008ane(Gonzalo Gomez und del Cano)\n\t\t\t//gleich danach \"bringen sie eine Dschunke auf\"\n\t\t\t//segeln zur\u009fck und suchen die Molukken auf\n\t\t\t//im Oktober segeln sie zur Stadt Maingdanao (Mindanao)\n\t\t\t//26 Oktober \u009fberf\u008allt sie ein furchtbarer Sturm\n\t\t\t//erreichen Ende Oktober die Inselgruppe zwischen Celebes und den Philipinen\n\n\t[ 8, 11, 1521, 0.64, 127.3, nil, 'reach_tidore_moluccan_island'],  // victoria, trinidad, crew 115\n\t\t\t//der K\u009anig ist der Crew wohlgesonnen\n\t\t\t//bekommen Gew\u009frznelken (im Tausch)\n\t\n\t[18, 12, 1521, 0.64, 127.3, nil, 'trinidad_leaks'],\n\t\t\t//K\u009anig von Thadore versucht zu helfen, das Leck ist nicht auffindbar\n\t\t\t//die Mannschaft der Trinidad bleibt zur\u009fck: also ca: (MINUS ca. 54 Mann)\n\t\t\t//es gibt jetzt noch eine Mannschaft bestehend aus 47 Europ\u008aern und 13 Indern!!!\n\t \n\t[21, 12, 1521, 0.64, 127.3, nil, 'victoria_leaves_tidore'],\n\t\t\t//bei 2\u00a1 und 55 l\u008angen kommen sie auf die Insel Sulach (irgendwann im Dezember)\n\t\t\t//auf Sulach wohnen menschenfresser\n\t\t\t//von dort gehts weiter nach Buru (ca. einen Tag von Sulach entfernt)\n\t\n\t[8, 1, 1522, -8.2, 125, nil, 'victoria_reaches_Mallue'],\n\t\t\t//freundlich gesonnen\n\t\t\t//gen\u009fgend Essen\n\t\t\t\n\t[25,  1, 1522, -8.2, 125, nil, 'victoria_leaves_ombay'],\n\t\n\t\n\t[26, 1, 1522, -9, 125.2, nil, 'victoria_reaches_timor'],\n\t\t\t//zuerst keine Einigung mit dem Befehlshaber \u009fber den Tausch\n\t\t\t//nahmen den H\u008auptling eines Ortes gefangen und erpressen Nahrungsmittel\n\t\n\t[13,  2, 1522, -9, 125.2, nil, 'victoria_leaves_timor'],\n\t\t\t//9. M\u008arz \u009fberf\u008allt sie ein Orkan\n\t\t\t//MINUS 4 Mann beim Orkan ertrunken\n\t\t\t//am 18.M\u008arz fahren sie bei Neu Masterdam vorbei (38\u00a1 s\u009fdlicher Breite)\n\t\t\t// schon wieder lebensmittelknappheit, wegen des Orkans,\n\t\t\t//laut Pigafetta erreichen sie das kap der guten Hoffnung bereits am 7.Mai\n\t \n\t[16,  5, 1522, -34.7, 18.9, 'storm', ],\n\t[18,  5, 1522, -34.7, 18.9, 'normal' ],\n\t[19,  5, 1522, -34.7, 18.9, \\normal, 'round_cape_of_good_hope' ],\n\t\t\t// am 16 Mai \u009fberf\u008allt sie wieder ein Sturm\n\t\t\t//kommen deswegen langsamer voran\n\t\t\t//laut pigafetta umrunden sie das Cap erst sp\u008ater \n\t\t\t\t// (am 19. Mai sind sie gerade dabei es zu umrunden...)\n\t\t\t//MINUS 21 Mann sterben wegen verhungerns\n\t\t\n\t[ 9,  7, 1522, 14.9, -23.5, nil, 'reach_cabo_verde'],\n\t\t\t//erkennen dass sie sich um einen tag verechnet haben (wegen der Weltumsegelung)\n\t\t\t//MINUS 13 Mann wurden zur\u009fckgehalten (noch 22 Mann \u009fbrig, davon die H\u008alfte krank)\n\t\n\t[ 12, 7, 1522, 14.9, -23.5, nil, 'leave_cabo_verde'],  // guess date\n\t\t\t//MINUS 4 Mann: verhungert\n\t\n\t[ 6,  9, 1522, 36.4, -6.4, nil, 'reach_san_lucar'],\n\t\t\t//18 Mann erreichen San Lucar\n\t\n\t[ 8,  9, 1522, 36.7, -6, nil, 'reach_sevilla']\n];\n",
    "4_windDev.scd": "// the traveling speed wind and storm sound for Navegar - sonification.\n\n(\nq.numSpeakers = q.numSpeakers ? 8; \n~wind.clear.ar(q.numSpeakers);\n\n~wind = { |wfreq = 100, q = 1, dRate = 3, drift = 2, amp=0.1, x=0, y= -1, focus=10, step=0.333| \n\tvar n = 8, snd, pos, panamps; \n\tx = Ramp.kr(x, step); y = Ramp.kr(y, step);\n\t\n\tpos = atan2(y, x) * (-1/pi) + 0.5; // look west;\n\t\n\twfreq = wfreq.lag(0.3); \n\tdRate = dRate.lag(0.3);\n\tq = q.lag(0.3);\n\tamp = amp.lag(0.3);\n\tfocus = focus.clip(0.1, 10).lag(0.3);\n\tpanamps = PanAz.kr(8, 1, pos, amp, (20 / focus).min(8)) ** focus; \n\tpanamps = panamps / (panamps.sum.max(1e-15));\n\t\n\tsnd = LeakDC.ar(\n\t\tRLPF.ar({ BrownNoise.ar + WhiteNoise.ar(0.25) } ! n, \n\t\t\twfreq * LFDNoise3.kr(dRate ! n, drift).midiratio, \n\t\t\tq.reciprocal * LFDNoise3.kr(dRate ! n, 0.2, 1)\n\t\t), \n\t\t0.925\n\t) * panamps * amp; \n//\tSplay.ar(snd, levelComp: false);\n};\n\nq.setWind = { |q, newCoord, event|\n\tvar speed, angle, dirPoint;\n\tq.lastCoord = q.lastCoord ? newCoord; \n\tq.lastAngle = q.lastAngle ? -0.75pi;\t// southwest; \n\t[q.lastCoord, q.lastAngle ];\n\tspeed = q.sphDist(q.lastCoord[0], q.lastCoord[1], newCoord[0], newCoord[1]) \n\t\t* 0.33 * q.earthRadius;\n\t\t\n\tangle = if (speed > 0, { \n\t\tq.sphAngle(q.lastCoord[0], q.lastCoord[1], newCoord[0], newCoord[1]);\n\t}, { q.lastAngle });\n\tdirPoint = Polar(1, angle).asPoint; \n\tq.lastCoord = newCoord; \n\tq.lastAngle = angle;\n \t[ \\setWind, \\speed, speed.round(0.001), \\dirPoint, dirPoint.round(0.001), \\event, event].postln;\n\n\tevent = event ? q.lastEvent ? \\normal;\n\tq.lastEvent = event;\n\t\tevent.switch(\n\t\t\t\\storm, { \n\t\t\t\t~wind.set(\n\t\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\t\\wfreq, rrand(200, 350), \n\t\t\t\t\t\\dRate, rrand(12, 15), \\drift, rrand(7, 10), \\q, 2.5, \n\t\t\t\t\t\\focus, rrand(0.2, 0.4)\n\t\t\t\t) }, \n\t\t\t\\calm, { \n\t\t\t\t~wind.set(\n\t\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\t\\wfreq, rrand(45, 55), \n\t\t\t\t\t\\dRate, 1, \\drift, 2, \n\t\t\t\t\t\\q, 1, \n\t\t\t\t\t\\focus, rrand(0.2, 0.5)\n\t\t\t\t) }, \n\t\t\t\\normal, {\t\n\t\t\t\t// \\default.postln;\n\t\t\t\t~wind.set(\n\t\t\t\t\t\\x, dirPoint.x, \\y, dirPoint.y,\n\t\t\t\t\t\\wfreq, speed * 1 + 50, \n\t\t\t\t\t\\dRate, 3, \\drift, rrand(2.5, 4), \n\t\t\t\t\t\\q, speed * 0.02 + 1, \n\t\t\t\t\t\\focus, (speed * 0.3).sqrt\n\t\t\t\t) }\n\t\t);\n};\n)\n\n/*\t// tests\n~wind.playN;\n~wind.scope;\nq.setWind([-6, 37], \\storm);\nq.setWind([-6, 36], \\calm);\nq.setWind([-6, 36], \\normal);\nq.setWind([-6.5, 37], \\normal);\nq.setWind([-6, 37], \\normal);\n\nNodeProxyEditor(~wind);\n*/",
    "5_FinalPlayer.scd": "/*** \n\tThis script prepares a proxy for every country, and a Tdef to play the piece.\n\tIt takes a while to load, tells you when ready!\n\n***/ \n(\nq.numSpeakers = q.numSpeakers ? 8; \ns.recChannels_(q.numSpeakers);\n\t\n\t// settings for the concert version: \nTdef(\\navegar).set(\n\t\\steptime, 1/3, \t// a day is scaled into 0.3333 seconds\n\t\\numCountries, 15, // the 15 nearest countries are heard at any time\n\t\\timelineOff, 0, \t// timeline starts from the first day\n\t\\postEveryN, 10\t// every tenth day gets posted.\n);\n\t// testing values\nTdef(\\navegar).set(\n\t\\steptime, 1/3, \n\t\\numCountries, 1, // few countries\n\t\\timelineOff, 4, \n\t\\postEveryN, 1\t// post every day\n); \n\n\t// load the wind sound;\n(q.dir ++ \"/4_windDev.scd\").loadPaths;\n\n\t// If you have the AmbIEM quark installed, you can render the speakers\n\t// as sources in a virtual room, to stereo headphones.\n\t\n\t// for 8 chans uncomment these:\n//Kemar.path_(\"KemarHRTF/\")\t\t// for 8 chan\n//\t.initBuffers(\n//\t\t[25, 70, 115, 160, 200, 245, 290, 335].rotate(1), \n//\t\t[0, 0, 0, 0,  0, 0, 0, 0]\n//\t);\n\n\t// for 12 chans uncomment these:\n//Kemar.path_(\"KemarHRTF/\")\t\t// for 12 chans\n//\t.initBuffers(\n//\t\t[\t 15,  45,  75, 105, 135, 165, \n//\t\t\t195, 225, 255, 285, 315, 345 ].rotate(1), \n//\t\t0 ! q.numSpeakers\n//\t);\n\n\t// set up a player nodeproxy for every country;  \n\t// these are all countries that are being 'touched' by the travel route when q.numCountries = 20.\nq.usedNames = \n[ 'Algeria', 'Andorra', 'Angola', 'Antigua_and_Barbuda', 'Argentina', 'Australia', 'Bangladesh', 'Barbados', 'Belgium', 'Belize', 'Benin', 'Bhutan', 'Bolivia', 'Botswana', 'Brazil', 'Brunei', 'Burkina_Faso', 'Burma', 'Burundi', 'Cambodia', 'Cameroon', 'Cape_Verde', 'Central_African_Republic', 'Chad', 'Chile', 'China', 'Colombia', 'Comoros', 'Congo_Democratic_Republic', 'Congo_Republic', 'Costa_Rica', 'Cote_d_Ivoire', 'Cuba', 'Djibouti', 'Dominica', 'Dominican_Republic', 'East_Timor', 'Ecuador', 'El_Salvador', 'Equatorial_Guinea', 'Ethiopia', 'Fiji', 'France', 'Gabon', 'Gambia', 'Ghana', 'Grenada', 'Guatemala', 'Guinea', 'Guyana', 'Haiti', 'Honduras', 'Hong_Kong', 'India', 'Indonesia', 'Ireland', 'Italy', 'Jamaica', 'Japan', 'Kenya', 'Kiribati', 'Korea_North', 'Korea_South', 'Laos', 'Lesotho', 'Liberia', 'Libya', 'Liechtenstein', 'Luxembourg', 'Madagascar', 'Malawi', 'Malaysia', 'Maldives', 'Mali', 'Malta', 'Mauritania', 'Mauritius', 'Mayotte', 'Mexico', 'Monaco', 'Morocco', 'Mozambique', 'Namibia', 'Nepal', 'Netherlands', 'New_Zealand', 'Nicaragua', 'Niger', 'Nigeria', 'Oman', 'Palau', 'Panama', 'Papua_New_Guinea', 'Paraguay', 'Peru', 'Philippines', 'Portugal', 'Puerto_Rico', 'Reunion', 'Rwanda', 'Saint_Helena', 'Samoa', 'San_Marino', 'Senegal', 'Seychelles', 'Sierra_Leone', 'Singapore', 'Slovenia', 'Solomon_Islands', 'Somalia', 'South_Africa', 'Spain', 'Sri_Lanka', 'Suriname', 'Swaziland', 'Switzerland', 'Taiwan', 'Tanzania', 'Thailand', 'Togo', 'Tonga', 'Trinidad_and_Tobago', 'Tunisia', 'Tuvalu', 'Uganda', 'United_Arab_Emirates', 'United_Kingdom', 'Uruguay', 'Vanuatu', 'Venezuela', 'Vietnam', 'Yemen', 'Zambia', 'Zimbabwe' ];\n\np.clear;\n\n~allChans.ar(q.numSpeakers);\n~allChans.bus; \n\nq.synthfunc = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, \n\tattack=0.0, decay = 1.0, dens = 2,\n\t amp = 0.2, x = 0, y = 1, step=0.33333| \n\t \n\tvar freqs, exciter, resonator, ampcomp, pos; \n\t\n\tfreqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\texciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07) \t// five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude compensation for density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// soft background noise 'halo' for fusion\n\t\t\t* (decay ** -0.5);\t\t\t\t\t// amplitude compensation for decay time\n\t\t\t\t\n\tresonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\t\t// convert x, y to angle for panaz, \n\t\t// and rotate to look west.\n\tpos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (-pi.reciprocal) + 0.5; \n\n\tPanAz.ar(q.numSpeakers, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n\nSpec.specs.put('rootFreq', [100, 2000, \\exp].asSpec);\nSpec.specs.put('dens', [1.8, 16000, \\exp].asSpec);\nSpec.specs.put('attack', [0.0003, 0.1, \\exp].asSpec);\nSpec.specs.put('decay', [0.2, 3, \\exp].asSpec);\nSpec.specs.put('inProp', [0, 8].asSpec);\nSpec.specs.put('outProp', [0, 12].asSpec);\nSpec.specs.put('pos', \\pan.asSpec);\n\n~wind.clear.ar(q.umSpeakers);\n\nSpec.specs.put('wfreq', [40, 1000, \\exp].asSpec);\nSpec.specs.put('dRate', [0.1, 30, \\exp].asSpec);\nSpec.specs.put('drift', [0, 12].asSpec);\nSpec.specs.put('q', [0.01, 100, \\exp].asSpec);\nSpec.specs.put('x', [-100, 100].asSpec);\nSpec.specs.put('y', [-100, 100].asSpec);\nSpec.specs.put('focus', [0.1, 10, \\exp].asSpec);\nSpec.specs.put('step', [0.03, 3, \\exp].asSpec);\n\nq.usedNames.do { |name| p[name] = nil; p[name].ar(q.numSpeakers); p[name].bus_(~allChans.bus); };\n\n\nfork {\n\tvar syndef; \n\t\n\tq.usedNames.do { |name, i| \n\t\t0.05.wait; \n\t\tp[name].set(\\amp, 0).pause; \n\t\tif (i == 0, { \n\t\t\tp[name].source_(q[\\synthfunc]); \n\t\t\tsyndef = p[name].objects.first.synthDef; \n\t\t}, { \n\t\t\tp[name].source_(syndef)\n\t\t}); \n\t};\n\t\n\tq.dataVectors = q.usedNames.collect({ |name| \n\t\tvar cntIndex = q.worlddata.atChan('Country').data.indexOf(name); \n\t\tvar dataVect = q.worlddata.atVector(cntIndex, [\\GDP_per_capita, \\Density]);\n\t\t[name, cntIndex, dataVect]; \n\t});\n\t\n\t\t// get static values once from dataset!\n\tq.usedNames.do { |name| \n\t\tvar cntIndex = q.worlddata.atChan('Country').data.indexOf(name); \n\t\tvar dataVect = q.worlddata.atVector(cntIndex, \n\t\t\t[\\GDP_per_capita, \\Density, \\Drinking_total, \\prop10, \\prop20]);\n\t\t\n\t\tvar gdp, dens, drink, prop10, prop20; \n\t\t[name, cntIndex, dataVect].postln; \n\t\t#gdp, dens, drink, prop10, prop20 = dataVect; \n\t\t\n\t\tgdp = gdp.expexp(400, 58900, 200, 2200); \n\t\tdens = dens.expexp(1.8, 16204.5, 1.8, 170); \n\t\tdrink = (drink ? 100).linlin(13, 100, 0.2, 1.5); // 1.5 secs max\n\t\t\n\t\tp[name].set(\t\t\t\n\t\t\t\\rootFreq, gdp, \n\t\t\t\\outProp, (prop10 ? 1.2).sqrt, \t// unknown ginis form quartertone cluster\n\t\t\t\\inProp, (prop20 ? 1.1).sqrt, \t// this was wrong in the concert version, fixed for the book\n\t\t\t\\decay, drink, \t\t\t\t// wrong in the concert version, fixed for the book\n\t\t\t\\dens, dens, \n\t\t\t\n\t\t\t\\attack, 0.1, \t// all distant, off, and in the west\n\t\t\t\\amp, 0.0, \n\t\t\t\\x, 1, \\y, 0\n\t\t);\n\t\t0.02.wait;\n\t}; \n\t\"\\n\\nREADY!\\n\\n\\n\".postln;\n};\n);\n/*\t\n\tp[\\Spain].resume;\n\tp[\\Spain].pause;\n*/\n\n\t// Final Player sequencer\n(\nq.allUsed = Set.new(180);\n\nTdef(\\navegar, {\u00ca|e| \n\tvar daysToNext, newStreams = [], oldStreams = [], dyingStreams = []; \n\tvar finalN; \n\t\n\tp.wakeUp; \n\t0.5.wait;\n\tp.do(_.pause); \n\t0.5.wait;\n\t~allChans.wakeUp; \n\t~wind.set(\\amp, 0.1).wakeUp.resume;\n\t\n\t\t// orig uses AdCVerb, available in Sonenvir svn\n\t~out = { var snd = ~allChans.ar(q.numSpeakers) + ~wind.ar(q.numSpeakers); \n\t\tsnd // + (AdCVerb.ar(snd, 2.1, 0.6, q.numSpeakers) * 0.01)\n\t}; \n//\t\t// substitute FreeVerb if you like\n//\t~out = { var snd = ~allChans.ar(q.numSpeakers) + ~wind.ar(q.numSpeakers); \n//\t\tsnd + (FreeVerb.ar(snd, 1, 0.75, 0.8) * 0.01)\n//\t}; \n\n\t\t// render to headphone stereo, with a slight bass boost\n//\t~out = { MidEQ.ar(Kemar.ar(~allChans.ar) + ~wind.ar(q.numSpeakers), 100, 2, 6) };\n\n\t\t// or mix down to plain stereo for testing\n//\t~out = { Splay.ar(~allChans.ar(q.numSpeakers)[0, 7, 1, 6, 2, 5, 3, 4]) }; \n\n\t~out.wakeUp; \n\n\t0.5.wait;\n\t~out.resume.play(fadeTime: 10);\n\t~wind.resume.play(fadeTime: 6);\n\n\tq.timeline.drop(e.timelineOff).doAdjacentPairs { |line, line2, i| \n\t\tline.postln; \n\t\tdaysToNext = (((line2[2] * 365) + (line2[1] * 30) + line2[0]) \n\t\t\t- ((line[2] * 365) + (line[1] * 30) + line[0])); \n\t\t\t\n\t\t[ \"TIMELINE:\", line, line2, q.lastEvent ].postcs;\n\t//\t(\"\t\" ++ daysToNext).postln;\n\t\tdaysToNext.do { |i| \n\t\t\n\t\t\tvar posLat = blend(line[3], line2[3], i / daysToNext); \n\t\t\tvar posLong = blend(line[4], line2[4], i / daysToNext);\n\t\t\t\n\t\t\tvar topN = q.getTopN(e.numCountries, posLat, posLong); \n\t\t\tvar cntNames = topN.collect(_.first); \n\t\t\tvar poster = i % e.postEveryN == 0;\n\t\t\t\n\t\t\tq.setWind([posLat, posLong], line[5]);\n\t\t\t\n\t\t\tnewStreams = cntNames.difference(oldStreams);\n\t//\t\t[ 'oldStreams', oldStreams ].postln; \n\t\t\tif (newStreams.notEmpty) { [ 'newStreams', newStreams ].postln };\n\t\t\t\n\t\t\tdyingStreams = oldStreams.difference(cntNames);\n\t\t\tif (dyingStreams.notEmpty) { [ 'dyingStreams', dyingStreams ].postln };\n\n\t\t\toldStreams = cntNames; \n\t\t\t\n\t\t\t\t\t// turn off old proxies;\n\t\t\tdyingStreams.do { |name| \n\t\t\t\tvar px = p[name]; \n\t\t\t\tpx.set(\\amp, 0);\n\t\t\t\tSystemClock.sched(e.steptime, { px.pause });\n\t\t\t}; \n\t\t\t\t\t// turn on new ones\n\t\t\tnewStreams.do { |name| \n\t\t\t\tvar px = p[name]; \n\t\t\t\tpx.resume;\t\t\t\t\n\t\t\t}; \n\t\t\t\n\t\t\tif (poster, { [ \\SHIP, posLat, posLong, q.lastEvent].round(0.01).postln });\n\n\t\t\t\t\t// update the playing ones\n\t\t\ttopN.do { |list|\u00ca\n\t\t\t\tvar dist, angle, dirVect, x, y, amp, attack;\n\t\t\t\t\n\t\t\t\tdist = list[4] * q.earthRadius; \n\t\t\t\tangle = q.sphAngle(posLat, posLong, list[1], list[2]);\n\t\t\t\tdirVect = Polar(1, angle).asPoint; \n\t\t\t\tx = dirVect.x; y = dirVect.y; \t// send x, y as direction vector, \n\t\t\t\t\n\t\t\t\tamp = (dist.max(100) ** -1) * 50;\n\t\t\t\tattack = dist.max(100).linexp(0, 2000, 0.001, 0.1); \n\t\t\t\t\n\t\t\t\tif (poster, { \n\t\t\t\t\t[ list, \\dist, dist, \\panAz, angle / pi, \\x, x, \\y, y, \\atan, atan2(y, x), \\amp, amp, \\att, attack]\n\t\t\t\t\t\t.round(0.001).postln; \n\t\t\t\t}); \n\t\t\t\t\n\t\t\t\tp[list.first].set(\n\t\t\t\t\t\\amp, amp,\n\t\t\t\t\t\\attack, attack,\n\t\t\t\t\t\\x, x, \n\t\t\t\t\t\\y, y\n\t\t\t\t);\n\t\t\t};\n\t\t\t// \"\".postln; \n\t\t\tfinalN = topN; \t// so I can end them;\n\t\t\t\n\t\t\tq.allUsed.addAll(newStreams); \n\t\t\t\t\t\n\t\t\te.steptime.wait;\n\t\t};\n\t\t\"\".postln;\n\t//\t0.5.wait;\n\t};\n\t\n\t(\"\" + q.allUsed.size + \"countries touched.\").postln;\n\t~out.end(20);\n});\n)\n/*\n~allChans.stop;\n~allChans = nil;\n\n~allChans.stop;\n~allChans.vol_(0.1);\n\n\np[\\Spain].resume;\n\n~out = { ~allChans.ar };\n~out.play;\n\n// for use with HEADPHONES use these\n\n~out = { Splay.ar(~allChans.ar) };\n\n\t// HRTF rendering if you have AmbIEM installed:\n~out = { MidEQ.ar(Kemar.ar(~allChans.ar), 100, 2, 6) };\n~out = { ~allChans.ar };\n\n// ~out = { Splay.ar(~allChans.ar[0,7,1,6,2,5,3,4]) };\n\n\n~out.wakeUp.resume.play;\n\n~out.vol_(4);\n\nNodeProxyEditor(~out);\n*/",
    "6_VariousTests.scd": "Tdef(\\navegar).stop.play;\nTdef(\\navegar).pause;\nTdef(\\navegar).resume;\n\n\nTdef(\\navegar).set(\\steptime, 0.3, \\nCount, 15, \\timelineOff, 0, \\postN, 10); \n\n~wind.resume.play;\n\n~wind.set(\\amp, 0.08);\n\nNodeProxyEditor(~wind);\n\ns.recChannels_(q.nChans).prepareForRecord(\"Navegar_8ch.aiff\");\ns.record;\nTdef(\\navegar).stop.play;\nTdef(\\navegar).stop;\n\np.envir.keysValuesDo { |k, px| if (px.paused.not) { k.postln } }; \n\n~allChans.stop;\n~allChans.play(fadeTime: 2);\n~allChans.vol_(0.2);\n\n\nn = NodeProxyEditor(p[\\Paraguay]);\n\nn.proxy_(p[\\Uruguay], \\Uruguay);\n\np[\\East_Timor].pause;\np[\\Mauritius].pause;\np[\\Madagascar].resume;\np[\\Saint_Helena].resume;\np[\\Mozambique].resume;\n\n~all8.filter(5, { |in| Splay.ar(in.keep(8)) ++ Silent.ar(6) });\n\n~all8.playN(\n\touts: [ 0, [ 0, 1 ], [ 0, 1 ], 1 ],\n\tamps: [ 1, [ 0.8, 0.5 ], [ 0.5, 0.8 ], 1 ],\n\tvol: 1\n);\n\n~all8.playNDialog;\ns.scope(8)\n\nDocument.open(q.dir ++ \"/Magellan_Reise.rtf\")",
    "1_World_ReadSimple.scd": "/*\nsimple textfile reader for reading in ICAD concert data files in SC3\n*/\n\t\t// \n(\nq = q ? ();\nq.dir = Document.current.path.dirname;\nq.filename = q.dir ++ \"/WorldExtended2.txt\";\nq.text = TabFileReader.read(q.filename, true, false);\nq.names1 = q.text[0];\n\nq.chanNames = q.names1.collect(_.asSymbol);\n\nDocument.new(\"chanNames:\", q.chanNames.asCompileString); \n\nq.dataChans = q.text\n\t.drop(1)\t\t// drop first line, chanNames\n\t.drop(-1)\t\t// drop last line, total population\n\t.flop;\t\t\t\t\t\t\t\t// swap rows and columns\n\nq.worlddata = (); \n\nq.chanNames.do { |name, i| \n\tq.worlddata.put(name, q.dataChans.at(i));\n};\n\n\t\t// convert channels with names to symbols\n[ 'Country', 'Capital', 'Region' ].do { |name, i| \n\tvar chandata = q.worlddata.at(name);\n\tchandata.do { |str, i| chandata.put(i, str.asSymbol) };\n};\n\n\t// convert channels with numbers to floats for better math precision:\nq.numberChannels = q.chanNames.reject(\n\t[ 'Country', 'Capital', 'Region', 'Latitude_deg', 'Longitude_deg' ].includes(_)\n); \n\nq.numberChannels.do { |name, i| \n\tvar chandata = q.worlddata.at(name);\n\tchandata.do { |str, i| \n\t\tvar num = if (str.every({ |ch| ch.isDecDigit.not }), nil, str.asFloat);\n\t\tchandata.put(i, num);\n\t};\n};\n)\n\n/**** \n//\tcode that was used to convert latitude_deg and longitude_deg to float values:\n\n\t\t// latitude and longitude need special conversion to degrees:\n[ \t'Latitude', 'Longitude' ].do { |name, i| \n\tvar data = q.worlddata.atChan(name).data;\n\tdata.do { |str, i| \n\t\tvar sign, degrees, sep, minutes;\n\t\t#sign, degrees, sep, minutes = str.select(_.isPrint).split($ ).reject(_.isEmpty);\n\t\t\n\t\tsign = (N: 1, S: -1, E: 1, W: -1)[sign.asSymbol];\n\t\tdegrees = degrees.asFloat + ((minutes ? 0).asFloat / 60) * sign;\n\t\t\n\t\tdata.put(i, degrees);\n\t};\n};\n\t// write it out so you can copy/paste it into Excel\nq.worlddata.atChan('Latitude').size.do { |index| \n\tvar lat, long;\n\t#lat, long = q.worlddata.atVector(index, [ 'Latitude', 'Longitude' ]).round(0.0001);\n\t(\"\" ++ lat ++ Char.tab ++ long).postln;\n}; \"\";\n\n****/",
    "2_terra_nullius_scbook.scd": "\n// Terra Nullius\n\n// requires worlddata to be loaded - run 1_WorldReadSimple.scd first.\n\n(\nq.numberOfChannels  = 8; // number of speakers in the ring\nq.numParams = 24 * 2;\t// number of data dimensions\n\n\nq.all = [];\n\n// collect data and keys\n// q.all is an array of arrays of values\n\nq.worlddata.keysValuesDo { |key, x| \n\tq.all = q.all.add(x);\n\tq.allKeys = q.allKeys.add(key);\n};\n\n// keep a copy\nq.allOrig = q.all.copy;\n\n// a function to order along a given dimension\n// if no value exists, leave in place (in this piece this doesn't happen, because longitude is used)\nq.makeOrder = { |q, i=0|\n\tvar lastval = inf;\n\tq.currentOrder = q.all.at(i).collect({ |x| x !? {\u00calastval = x }; x ? lastval }).order;\n\t\n\tq.all = q.all.collect { |x| x[q.currentOrder] };\n\tq.allFlop = q.all.flop;\n};\n\nq.numberOfCountiesWithDist = {\u00ca|q, dist=5|\n\tq.allOrig.flop.count({ |x| x[q.allKeys.indexOf('Latitude')].absdif(50) < dist })\n};\n\nq.makeSelection = { |q, dist=5|\n\tvar func =  { |country| country[q.allKeys.indexOf('Latitude')].absdif(50) < dist };\n\t\n\tq.allFlop = q.allOrig.flop;\n\tq.allFlop = q.allFlop.select(func);\n\tq.all = q.allFlop.flop;\n\tq.all = q.all.keep(q.numParams ? 24); // keep a number of data dimensions only\n\tq.makeOrder;\n\n};\n\nq.embedSlice = {|q, i=0, dt=1.0, bgamp=0.03, dtEnd|\n\t\n\tq.makeOrder(i);\n\tq.playCurrent(dt, bgamp, dtEnd).embedInStream;\t\n\n};\n\nq.playCurrent = { |q, dt=0.05, bgamp=0, dtEnd|\n\tdtEnd = dtEnd ? dt;\n\t\n\tRoutine {\n\t\tvar n = q.allFlop.size;\n\t\t\n\t\t~out.set(\\bgamp, bgamp); // set the background noise amp\n\t\t\n\t\tq.allFlop.do { |x, i|\n\t\t\tvar t = (i+1).linexp(1, n+1, dt, dtEnd); // interpolate speed beteen rounds\n\t\t\t(\"  % \".format(t) ++ String.fill(x.size, {|i| if(x[i].isNil) { $* } { $ } })).postln;\n\n\t\t\tx = x.collect { |v| if(v.isNil) { 1 } {\u00ca0 } };\n\t\t\t\n\t\t\t~out.group.setn(\\amp, x); // set the node proxy band amplitudes\n\t\t\t~out.group.set(\\pan, (i / n * 2 - 1)); // set the node proxy pan pos\n\t\t\t\n\t\t\tt.wait;\n\t\t};\t\n\t}\n};\n);\n\n\n(\np = ProxySpace.push(s.boot);\n\n(\n~out = { |bgamp=0.2, pan=0, rq=0.1|\n\tvar n = q.numParams;\n\tvar amp = Control.names(\\amp).kr(0.0 ! n); // amplitude controls\n\tvar freqs = (0..n).linexp(0, n, 100, 12400);\n\tvar u1, u2;\n\t\n\t\tthisThread.randSeed = 2006; // scramble the frequencies always the same way\n\t\tfreqs = freqs.scramble;\n\t\n\tamp = amp.lag(0.02);\n\t\n\t// filtered noise bands with lagged filter coefficient\n\tu1 = {|i|\n\t\tvar freq = freqs[i];\n\t\tBPF.ar(WhiteNoise.ar, freq, rq.lag(5)) * AmpComp.ir(freq, 100, 0.6) * amp[i].lag(0.02)\n\t\t* LFNoise1.kr(0.3, 0.2, 1)\n\t}.dup(n);\n\t\n\tu1 = u1.sum;\n\t\n\t// background noise\n\tu2 = HPF.ar(Crackle.ar({ 1.32 + 0.001.rand2 } ! n, bgamp.lag(10)), 500);\n\t\n\t// mix and pan\n\tPanAz.ar(q.numberOfChannels, u1, pan)\n\t+ \n\tSplayZ.ar(q.numberOfChannels, u2)\n}\n);\n)\n\n\n(\nTdef(\\x) {\n\tvar steps, noise, count=0;\n\t\n\t// set level of background noise to 0, filter bandwidth to 0.5\n\t~out.set(\\bgamp, 0.0, \\rq, 0.5);\n\n\t// play the proxy to all output channels\n\t~out.play(0, q.numberOfChannels);\n\t\n\t3.wait; // pause before start\n\t\n\tsteps = (1..11).linexp(1, 11, 3, 130).collect(_.asInteger);\n\n\t(steps.size - 2 * 2 + 1).do { |i|\n\t\t\tvar dt, dt2, width, flopsize;\n\t\t\t\n\t\t\t// latitudinal width of selection\n\t\t\twidth = steps.foldAt(i);\n\t\t\twidth.postln;\n\t\t\t\n\t\t\tq.makeSelection(width);\n\t\t\tflopsize = q.allFlop.size;\n\t\t\t\n\t\t\t\"q.allFlop.size: %\\n\".postf(flopsize);\n\t\t\t\n\t\t\t// calculate beginning and ending time steps of this round\n\t\t\tdt = flopsize.linexp(2.5, 100, 3, 0.01);\n\t\t\tdt2 = q.numberOfCountiesWithDist(steps.foldAt(i + 1)).linexp(2.5, 100, 3, 0.01);\n\t\t\t\n\t\t\t// set the filter bandwidth\n\t\t\t~out.set(\\rq, i.linexp(1, steps.size * 2, 0.5, 0.01));\n\t\t\t\n\t\t\t// level of background noise\n\t\t\tnoise = i.linexp(1, steps.size * 2, 0.002, 3.0);\n\t\t\tq.embedSlice(q.allKeys.indexOf('Longitude'), dt, noise, dt2);\n\t\t\t\n\t};\n\t\n\t~out.group.setn(\\amp, 0.0 ! q.all.size); // set all to zero\n\t\n\t10.wait;\n\t\n\t~out.end(5);\n\t\n\t\\ende.postln;\n\t\n}.play;\n);\n\n\n",
    "spatial_example.scd": "/**\nIn this example the multichannel reverb changes according to where in the space a sound source is located.\n\n*/\n\ns.boot;\n\n( // define the synthdefs:\nSynthDef( \\pulse, { |out=0,amp=0.3|\n\tOut.ar( out, amp*Decay.ar( Impulse.ar( 1 ), 0.25, LFCub.ar(1200,0,0.1) ) )\n\t}).send(s);\n\nSynthDef( \\reverb, { |in=0,out=0,mix=0.5,room=0.5,damp=0.5,amp=1|\n\tOut.ar( out, amp*FreeVerb.ar( In.ar( in, 1 ), mix, room, damp ) )\n\t}).send(s);\n)\n\n( // create infrastructure\nb = Bus.audio( s, 1 );\n)\n\n( // create synths:\nx = Synth.new( \\pulse, [\\out, b, \\amp, 1] );\n// create six reverbs, with slightly different settings:\ny = 6.collect{ |it,i| Synth.new( \\reverb, [\\in, b, \\out, it, \\room, 0.2.rand + 0.4, \\damp, 0.2.rand + 0.4], addAction: \\addToTail ); };\n)\n\n\n(\n// Assign positions to each speaker: (6 speaker setup in a rectangle)\n~speakers = [ Point.new( 0, 0 ),  Point.new( 1, 0 ),  Point.new( 2, 0 ),  Point.new( 2, 1 ),  Point.new( 1, 1 ),  Point.new( 0, 1 ) ];\n\n// Position for the source signal:\n~src = Point.new( 0, 0 );\n\n// distance spec:\n~spec = [0,3].asSpec;\n\n// function to update the location:\n~updateLocation = { arg newpos;\n\t~src = newpos;\n\ty.do{ |it,i|\n\t\t// the mix gets more wet, the further the source is from the speaker:\n\t\tit.set( \\mix,  ~spec.unmap( ~src.dist( ~speakers.at(i) ) ).postln );\n\t}\n};\n)\n\n// corners:\n~updateLocation.value( Point.new( 0,0 ) )\n~updateLocation.value( Point.new( 1,0 ) )\n~updateLocation.value( Point.new( 2,0 ) )\n~updateLocation.value( Point.new( 0,1 ) )\n~updateLocation.value( Point.new( 1,1 ) )\n~updateLocation.value( Point.new( 2,1 ) )\n\n// middle:\n~updateLocation.value( Point.new( 0.5,0.5 ) )\n~updateLocation.value( Point.new( 1,0.5 ) )\n~updateLocation.value( Point.new( 1.5,0.5 ) )\n~updateLocation.value( Point.new( 1.5,0 ) )\n\n\n// clean up:\nx.free; y.do{ |it| it.free; }\n",
    "Ch17code.scd": "//////////////////////////////////////////////////////\nFigure  17.1 \n\n(\n// read a whole sound into memory\ns = Server.local;\nb = Buffer.read(s,\"sounds/a11wlk01.wav\"); // remember to free the buffer later.\n)\n(\nSynthDef(\"help_PlayBuf\", { arg out=0,bufnum=0, rate=1;\nOut.ar(out,\nPan2.ar(\nPlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)*rate, loop: 1),\n0)\n)\n}).send(s,[\\out, 0, \\bufnum, b.bufnum]);\n)\np=Synth(\\help_PlayBuf, [\\rate, 0.midiratio]); // original pitch\np.set(\\rate, 12.midiratio);\t// one octave up\np.set(\\rate, 7.midiratio);\t// seven semitones up (fifth interval)\n\nb.free;\nb=nil;\np.free;\np=nil;\n//////////////////////////////////////////////////////\n\f Figure  17.2 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5, 7]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.3 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5.25, 7.5]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.4 \n\n(\nPbind(\n\\note, Pseq([0,2,4,5,7,9,11,12], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.5 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.6 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5,\n\\scale, (0..11)\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.7 \n\n(\nPbind(\n\\degree, Pseq([0, 2, 2.1, 2.05], inf),\n\\dur, 0.3,\n\\scale, (0..11),\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.8 \n\n(\nPbind(\n\\note, Pwhite(-6,9),\n\\dur, 0.3,\n\\sustain, 1.1,\n\\stepsPerOctave, 7\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure  17.9 \n(\ne=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 4, 8, 11, 14, 17]\n).play;\n)\n//////////////////////////////////////////////////////\n\f Figure  17.10 \n\n(\n// previous example should still be running\ne.stream=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 3, 5, 8, 10, 13]\n).asStream;\n)\n//////////////////////////////////////////////////////\n\f Figure  17.11 \n\n(\nvar stepsperoctave=3;\nArray.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\n)\n\nUsing a function to calculate the value at a chosen degree\n(\nf = {|degree, steps|\n2.pow(degree/steps)\n};\n)\n// \tdegree 0\nf.(0, 3);\n// \tdegree 1\nf.(1, 3);\n// \tdegree 2\nf.(2, 3);\n\nThe function is modified to multiply the value by a root frequency in Hertz\n(\nf = {|degree, steps, root=440|\n2.pow(degree/steps)*root\n};\n)\n//\t12 notes per octave, degrees 0,1 and 12\nf.(0,12)\nf.(1, 12)\nf.(12, 12)\n\n//\t14 notes per octave, degrees 0,1, 12 and 14\nf.(0,14)\nf.(1, 14)\nf.(12, 14)\nf.(14,14)\n//////////////////////////////////////////////////////\n\n\f Figure 17.12 \n\n(\nSynthDef(\"tone2\", { arg freq = 440, amp=0.5, gate=1, envdur=1.5;\nvar sound, env;\nenv = EnvGen.kr(Env.perc(0.01, envdur), doneAction:2);\nsound = Pan2.ar(SinOsc.ar(freq, 0, amp)*env, 0);\nOut.ar(0, sound);\n}).load(s);\n)\n(\na=[ 1, 1.030303030303, 1.0606060606061, 1.1212121212121, 1.3636363636364, 1.6060606060606, 2 ]*220;\n\n// Play the all the notes of the tuning\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).play\n)\n// Choose the notes randomly\n(\ne.stream=Pbind(\n\\freq, Pn(Prand( a, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).asStream\n)\n//////////////////////////////////////////////////////\n\f Figure 17.13 \n\n(\n~rationames=[1/1, 8/7, 7/6, 6/5, 5/4, 4/3, 7/5, 10/7, 3/2, 8/5, 5/3, 12/7, 7/4];\n~scale=[0,3,5,8,10,12];\ne = Pbind(\n\\freq, Pseq([\nPfunc({\n(~rationames.wrapAt(~scale).[~scale.size.rand])*440\n})\n],inf),\n\\dur, 0.25,\n\\amp, 0.5,\n\\instrument, \\tone2\n).play; // returns an EventStream\n)\n// set a new scale\n~scale=[0,2,5,7,9,11];\n~scale=[0,1,3,5,6,8,9];\n~scale=[0,3,5,8,10,12];\n//////////////////////////////////////////////////////\n\f Figure 17.14 \n\n(\nvar n, buts, synths, ratios, rationames;\nw = SCWindow(\"tonality diamond\", Rect(200,500,420,150));\nw.view.decorator = FlowLayout(w.view.bounds);\n\nrationames=[\n\"7/4\", \"3/2\",\"5/4\",\"1/1\",\n\"7/5\",\"6/5\",\"1/1\",\"8/5\",\n\"7/6\",\"1/1\",\"5/3\",\"4/3\",\n\"1/1\",\"12/7\",\"10/7\",\"8/7\"\n];\n\nn=rationames.size;\n\nn.do({ |i|\nSCButton(w, Rect(20,20+(i*30),100,30))\n.states_([[rationames[i], Color.black, \nif((rationames[i])==\"1/1\", {Color.red},{Color.yellow})\n]\n])\n.action_({ arg butt;\nSynth(\\tone2, [\\freq, ((rationames[i]).interpret)*440]);\n\n})\n});\nw.front;\n)\n//////////////////////////////////////////////////////\n\f Figure 17.16 \n\n(\na=Pbind(\n\\degree, Pwhite(0, 12),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pwhite(0, 14),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////\n\f Figure 17.17 \n\n(\na=Pbind(\n\\degree, Pfunc({\n[\n[0, 6, 12].choose, 12.rand\n].choose;\n}),\n\\dur, 0.5,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pfunc({\n[\n[0, 7, 14].choose, 14.rand\n].choose;\n}),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.3,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////\n\f Figure 17.18 \n\n(\n~tolerance={|a, b, t, max|\nvar c, d;\nc=[];\nd=[];\na.do({ |aitem, aindex|\nb.do({ |bitem, bindex|\nvar x;\nx = (aitem-bitem).abs;\nif( (x > t) && (x < max),\n{\nc=c.add(aindex);\nd=d.add(bindex);\n//[aitem, bitem].post; \" out of tune \".post; [aindex, bindex].postln;\n//\" \".postln;\n})\n})\n});\n[(0..a.size).difference(c), (0..b.size).difference(d)];\n};\n)\n\n(\n// use the function function with two tunings\nvar mintreshold, maxtreshold, int;\n\n// two different equal tunings expressed linearly\na=Array.fill(12, { |i| (1/12)*(i) });\nb=Array.fill(21, { |i| (1/21)*(i) });\n\nint=1/21;\t\t\t\t// smallest interval\nmintreshold=int*0.15;\nmaxtreshold=int*0.85;\n/*\nintervals inferior to mintreshold are in tune\nintervals between mintreshold and maxtreshold are out of tune\nintervals superior to maxtreshold are in tune\n*/\n\n// print a list of notes from the two tunings which form a dissonant interval\n~tolerance.value(a, b, mintreshold, maxtreshold);\n)\n//////////////////////////////////////////////////////\n\f Figure 17.19 \n\n(\na=Pbind(\n\\degree, Pfunc({\n// notes which clash with the other tuning have been removed\n[0,4,8,12].choose\n}),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).play;\nb=Pbind(\n// notes which clash with the other tuning have been removed\n\\degree, Pfunc({\n[0,7,14,21].choose\n}),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.35,\n\\sustain, 0.85,\n\\stepsPerOctave, 21,\n\\instrument, \\tone2\n).play;\n)\n\n(\na.stream=Pbind(\n// introducing more notes from that tuning after having changed the threshold\n\\degree, Pfunc({\n[ 0, 1, 4, 7, 8, 9, 9, 12 ].choose\n}),\n\\dur, 0.75,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).asStream;\n)\n//////////////////////////////////////////////////////\n\f Figure 17.20 \n\n(\nf = {|steps| Array.fill(steps, { |i| 2.pow(i/steps) }) };\n//\tCalculation of the twelve equal-note temperament\nx =  f.(12);\n//\tmapping the tuning to a new range beyond an octave\ny = x.linlin(1, 2, 1, 2.25);\n//\tmultiplying by a root frequency\na=y*440;\n\nPbind(\n\\freq, Pfunc({ a.choose }),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure 17.21 \n\n(\nPbind(\n\\degree, Pwhite(0, 18),\n\\dur, 0.3,\n\\sustain, 1.0,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2,\n\\stepsPerOctave,  18.809\n).play;\n)\n//////////////////////////////////////////////////////\n\n\n\n\f Figure 17.22 \n\n(\na=[ 1, 1.09375, 1.1875, 1.28125, 1.375, 1.46875, 1.5625, 1.65625];\nb=a*440;\ne=Pbind(\n\\freq, Pseq( b, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).play\n)\n// play in a different order\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( b, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).asStream\n)\n//////////////////////////////////////////////////////\n\f Figure 17.23 \n\n(\n// F. Mogini pattern-based Tuning - 2000.\nx=880;\n\nPbind(\n\\freq, Pn(\nPlazy({\nif(x<=150, {x=x*2});\nif(x>=2000, {x=x/2});\nx=[\n\nx*[1.1428,  1.36, 1.26].choose,\nx/[1.1428,  1.36, 1.26].choose\n\n].choose\n})\n),\n\\dur, 0.14,\n\\sustain, 0.8,\n\\cutoff, Pfunc({ 1.0.rand})\n).play;\n)\n//////////////////////////////////////////////////////\n\n\n\n\n\f Figure 17.24 \n\na=(1..16)*100\n(\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2\n).play\n)\n\n// a beautiful tuning system can be created from the harmonic series.\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( a, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).asStream\n)\n//////////////////////////////////////////////////////\n\f Figure 17.25\n\na=(1..11);\n(\na.size.do({ |i|\nvar x=a[i];\nwhile({x>2},{x=x/2});\na.put(i, x)\n});\n)\n\nb=a.asSet.asArray.sort;\n(\ne=Pbind(\n\\freq, Pn(Pshuf( b*440, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure 17.26 \n\na=(1..8);\nb=(9..16);\n(\na.size.do({ |i|\nvar x=a[i];\nvar y=b[i];\n// harmonics below 8 remain in the first octave\nwhile({x>2},{x=x/2});\n// harmonics above 9 remain in the second octave\nwhile({y>4},{y=y/2});\na.put(i, x);\nb.put(i, y);\n});\n)\na;\nb;\nc=(a++b).asSet.asArray.sort;\nc;\n\n(\ne=Pbind(\n\\freq, Pn(Pshuf( c*200, 1)),\n\\dur, 0.2,\n\\sustain, 1.1\n).play\n)\n//////////////////////////////////////////////////////\n\f Figure 17.27 \n\n(\n// \ta function to expand the tuning from one octave to four octaves\n~harmsfunc={arg stepsperoctave=7;\nvar harms;\n// calculate each note from the tuning\nharms=Array.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\nharms.size.do({ |i|\nif( 0.6.coin, {\n// multiply some of the notes to create higher harmonics\nharms.put(i, (harms[i])*[1,2,4,8].choose )\n})\n});\nharms.sort;\n};\n)\n\n//  create an array of virtual harmonics, seven equal-note temperament\n~harms=~harmsfunc.value(7);\n\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).store;\n)\n\n(\ne=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are rpeated so we can notice the effect of harmonics\n\\degree, Pseq([0,1,2,3,4,5,6,7],inf),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).play;\n)\n\nSend the SynthDef function again to obtain new amplitudes for each harmonic\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).store;\n)\n\n// re-evalute the function to create new harmonics (update the SynthDef afterwards)\n~harms=~harmsfunc.value(7);\nSend the SynthDef function again, as we have done earlier to obtain new amplitudes for each harmonic\n\n// finally playing a random melody to make it less repetitive\n(\ne.stream=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are repeated so we can notice the effect of harmonics\n\\degree,  Pwhite(0, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).asStream;\n)\n// we could develop further and re-write the SynthDef with a partial argument \n// and also change the partials directly from Pbind\n\n//////////////////////////////////////////////////////\n\f Figure 17.28 \n\n(\nvar w, keys, steps, octaves;\n\nw = SCWindow.new.name=\"Custom keyboard: 7 steps per octave\";\nsteps = 7;\noctaves= 2;\n// seven steps per octave;\na=Array.fill(7, { |i| (1/7)*(i) })+1;\nb= a++(a*2);\n\nc=Synth(\\default, [\\amp, 0]);\n\nkeys=Array.fill(steps*octaves,{ |i|\n\nSCButton(w, Rect(20+(i*22),20,20,50))\n.states_([\nif(i.mod(steps)==0,{\n[i.asString, Color.black, Color.red]},{\n[i.asString, Color.black, Color.yellow]});\n\n])\n.action_({ arg butt;\nc.set(\\freq,b[i]*220, \\amp, 0.25)\n});\n});\n\nw.front;\n)\n//////////////////////////////////////////////////////\n\n",
    "chapter18code.scd": "/* Figure 18.1 */\n/*\nThis example is adapted and extracted from the Non-Realtime Synthesis helpfile itself, accessible from the Main SuperCollider help page.\n*/\n(\nvar f, c, d;\n// open a file for writing raw OSC data to\nf = File(\"~/test.osc\".standardizePath,\"w\");\n// start a sine oscillator at 0.2 seconds.\nc = [ 0.2, [\\s_new, \\default, 1001, 0, 0]];\n// convert the bundle to raw OSC\nd = c.asRawOSC;\nf.write(d.size); // each bundle is preceded by a 32 bit size.\nf.write(d); // write the bundle data.\nf.close;\n)\n/* End Figure 18.1 */\n/* Figure 18.2 */\ns = Server.local;\ns.boot;\n\n// a sample SynthDef\nSynthDef(\\NRT_beep, {arg freq, dur, amp = 0.1;\n\tvar half;\n\thalf = dur * 0.5;\n\tOut.ar(0, SinOsc.ar(freq, 0, \n\t\tEnvGen.kr(Env.new([0, amp, 0], [half, half], [4, -4]))));\n\t}).load(s);\n\n(\nvar score;\n\n// A Score, created from a note-list of time-stamped events.\nscore = Score.new([\n    [0.0,\n        [\\g_new, 1000],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.0,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [2.0,\n        [\\n_free, 1001, 1000]\n    ],\n\t[2.00001, [0]]\n]);\n\nscore.play(s); // play the Score in real-time...\n\n// ... or render in in Non-Real-Time\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n)\n/* End Figure 18.2 */\n/* Figure 18.3 */\n(\n//In this example, we use the higher-level server abstraction classes, Group and Synth to handle the\n// node IDs. At least as important though is the use of variables. Now that the relationships are\n// specified rather than the specific values, we can change the gesture dramatically by changing\n// just one or two variables. To transpose everything, we only need to change the value of \n// ~baseNote. To adjust the duration, we only need to change the ~dur variable, and this is now \n// independent of the deltaOn (i.e. independent of the amount of time between the start of one\n// note and the start of the next note).\nvar score;\nvar deltaOn = 0.2;  //amount of time between the start of one note and the start of the next note\nvar dur = 0.4;      //try changing dur to 0.3, 1.4, 3.4, or whatever you like\nvar baseNote = 75;  //transpose the entire fragment up or down\nvar firstPitch  = (baseNote + 0).midicps;  //alter the relationship between any of the pitches\nvar secondPitch = (baseNote - 4).midicps;  // without effecting the others\nvar thirdPitch  = (baseNote + 7).midicps;\n\nscore = Score.new([\n\t[t =  0.0,\n\t\t(g = Group.basicNew(s)).newMsg,\n\t\t//we use environment variables here (identified by the preceding ~) \n\t\t// since we might add or remove events; hence we don't know ahead of \n\t\t// time how many events we have, and therefore how many variables we'll need\n\t\t(~s01 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s01.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s02 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s02.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s03 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t],\n\t[t + dur,\n\t\t~s03.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s04 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s04.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s05 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s05.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s06 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s06.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s07 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s07.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s08 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s08.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s09 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s09.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s10 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s10.freeMsg,\n\t\tg.freeMsg\n\t],\n]\n);\n\nscore.sort;\nscore.play(s);\n)\n/* End Figure 18.3 */\n/* Figure 18.4 */\n(\nvar score, graingest;\n\n// seed the randomness\nthisThread.randSeed_(123);\n\n// a sample SynthDef\nSynthDef(\\NRT_grain, {arg freq, dur, amp, pan;\n\tOffsetOut.ar(0, Pan2.ar(\n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.ar(Env.sine(dur, amp), doneAction: 2)),\n\t\tpan)\n\t\t);\n\t}).load(s);\n\nscore = Score.new;\n\n// envelope times are scaled to 1.\ngraingest = {arg score, starttime, duration, windur, overlaps, freqenv, ampenv, panenv;\n\tvar ratio, curfreq, curamp, curpan, notestart, now = 0.0, note;\n\twhile({\n\t\tratio = now / duration;\n\t\tcurfreq = freqenv[ratio];\n\t\tcuramp = ampenv[ratio];\n\t\tcurpan = panenv[ratio];\n\t\tnotestart = now + starttime;\n\t\tnote = Synth.basicNew(\\NRT_grain);\n\t\tscore.add([notestart, \n\t\t\tnote.newMsg(1, [\\freq, curfreq,\\amp, curamp, \\dur, windur, \\pan, curpan], \\addToHead)]\n\t\t\t);\n\t\t// check the current event's endtime against the gloabl endtime\n\t\tnow = now + (windur / overlaps);\n\t\tnow < duration;\n\t\t});\n\t};\n\n// call the above function to populate the Score\n\ngraingest.value(score, 1.0, 10.0, 100.reciprocal, 1, Env([440, 550], [1]), \n\tEnv([0, 0.2, 0], [0.3, 0.7], [4, -4]), Env([0, 0], [1]));\ngraingest.value(score, 3.0, 3.0, 130.reciprocal, 2, Env([700, 400], [1]),\n\tEnv([0, 0.2, 0], [0.1, 0.9], [4, -1]), Env([-0.7, 0.7], [1]));\n\n// create a number of short gestures\n10.do({arg i;\n\tgraingest.value(score, 5.0.rrand(10.0), 3.0.rrand(5.0), (100 * i).reciprocal, [1, 2, 4].choose,\n\t\tEnv([1000, 800], [1]), Env([0, 0.2, 0], [0.5, 0.5]), Env([0.5.rand2, 0.5.rand2], [1]));\n\t});\n\n// save the endtime to the Score to tell NRT when to stop rendering. The above gestures won't\n// be more the 16 seconds\n\nscore.add([16, [0]]);\n\n// sort the score to ensure events are in the correct order\n\nscore.sort;\n\n// render the Score to the users home folder\n\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n\t\n// also save the Score to a file\nscore.saveToFile(\"~/test.sc\".standardizePath);\n)\t\n/* End Figure 18.4 */\t\n/* Figure 18.5 */\n(\nvar score, sndbuf, starttime, synth, options;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// create a Buffer object for adding to the Score\nsndbuf = Buffer.new;\n\n// for NRT rendering, the buffer messages must be added to the Score\nscore.add([0, sndbuf.allocReadMsg(\"sounds/a11wlk01-44_1.aiff\")]);\n\nstarttime = 0.0;\n\n// a small function to create a series of small notes based on the Buffer\nwhile({\n\tsynth = Synth.basicNew(\\NRT_playback);\n\tscore.add([starttime, \n\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\tstarttime = starttime + 0.05;\n\tstarttime < 10.0;\n\t});\n\n// the dummy command. The soundfile will be 11 seconds long\nscore.add([11, 0]);\n\nscore.sort;\n\n// the ServerOptions for rendering the soundfile\noptions = ServerOptions.new.numOutputBusChannels_(1);\n\n// write the soundfile out to disk\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, options: options);\n)\n/* End Figure 18.5 */\n/* Figure 18.6 */\n(\nvar score, sndbuf, starttime, synth, options, cond;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// set up a Condition to check for when asynchronous events are finished.\n\ncond = Condition.new;\n\n// wrap the code that will run in real-time in a Routine, to allow for the Server to sync\nRoutine.run({\n\t// load the buffer\n\tsndbuf = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\t\n\t// pause while the buffer is loaded\n\ts.sync(cond);\n\t\n\t// fill the Score with notes\n\t\n\tstarttime = 0.0;\n\t\n\twhile({\n\t\tsynth = Synth.basicNew(\\NRT_playback);\n\t\tscore.add([starttime, \n\t\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\t\tstarttime = starttime + 0.05;\n\t\tstarttime < 10.0;\n\t\t});\n\t\n\t// the last command is NOT needed, since no soundfile is being rendered\n//\tscore.add([11, 0]);\n\t\n\tscore.sort;\n\t\n\t// again, options won't be needed for real time performance\n//\toptions = ServerOptions.new.numOutputBusChannels_(1);\n\t\n\tscore.play;\n\t// schedule the freeing of the buffer after the Score is done playing\n\tSystemClock.sched(11, {sndbuf.free; \"Buffer resources freed\".postln;});\n\t})\n)\n/* End Figure 18.6 */\n/* Figure 18.7 */\n\n\n// environment variables are used for real-time examples of Ctk objects\n\nn = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg gate = 1, freq, amp;\n\t\tvar src, env;\n\t\tsrc = SinOsc.ar(freq, 0, amp);\n\t\tenv = EnvGen.kr(Env([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction:2);\n\t\tOffsetOut.ar(0, src * env);\n\t\t})\n\t);\n\t\n// create a new note based on 'n', start to play it in 0.1 seconds\na = n.new(0.1).freq_(440).amp_(0.1).gate_(1).play;\n// the release method will set 'gate' to 0.0, and free this node\na.release;\n\n// create another note\na = n.new(0.1).freq_(440).amp_(0.1).play;\n// alter the freq argument in real time\na.freq_(550);\n// alter the freq with a CtkControl that describes an Env\n// CtkControl.env(Env)\na.freq_(CtkControl.env(Env([550, 440, 550], [1, 2], \\exp)));\n// apply a random control to the amp parameter, with an envelope applied to the range. All \n// parameters to the CtkControl can themselves be CtkControls\n// CtkControl.lfo(KRUGen, freq, low, high, phase)\na.amp_(CtkControl.lfo(LFNoise2, 0.5, CtkControl.env(Env([0.1, 0.9], [5])), 0.1));\na.amp_(0.1);\n\n// release the note\na.release;\n\n/* End Figure 18.7 */\n/* Figure 18.8 */\n// melodic expander\n(\nvar note, keys, durs, now, score, chunk, expander, rangemap;\n\n// \nthisThread.randSeed_(123);\n\n// a simple note player\n\nnote = CtkSynthDef(\\NRT_dut, {arg key, amp, dur;\n\t\tOut.ar(0, SinOsc.ar(key.midicps, 0, XLine.kr(amp, 0.00001, dur)))\n\t\t});\n\n// first, make a melody - these will be used as midikeynums (easier to alter later)\n\nkeys = [ 72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72 ];\n\n// a list of durations\n\ndurs = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5];\n\n// create a var to store 'now' in\n\nnow = 0.0;\n\n// create a CtkScore with the above melody\n\nscore = CtkScore.new;\n\nkeys.do({arg thiskey, inc;\n\tvar thisdur;\n\tthisdur = durs[inc];\n\tscore.add(note.new(now, thisdur).key_(thiskey).amp_(0.2).dur_(thisdur));\n\tnow = now + thisdur;\n\t});\n\n// first, create a function that will return a chunk of the melody the duration of the chunk\n// sets the starttimes of the notes to a base of 0.0\n\nchunk = {arg offset = 0;\n\tvar size, start, end, duration = 0, chunk, copies;\n\t// the size of the current melody - 1 (for array access)\n\tsize = score.notes.size;\n\t// the beginning of the chunk can come from the beginning of the melody to the second to \n\t// last note\n\tstart = 0.rrand(size-1);\n\tend = start.rrand(size);\n\tchunk = score.notes[start..end].collect({arg anote; \n\t\tvar newnote;\n\t\tnewnote = anote.copy(duration + offset);\n\t\tduration = duration + anote.duration;\n\t\tnewnote;\n\t\t});\n\t[chunk, duration];\n\t};\n\n// now, create a function that will add those chunks to the score, and will keep doing this\n// until the score is at least the desired length. Then check the score size, and truncate to \n// desired size.\n\nexpander = {arg len;\n\tvar curchunk, chunkdur, insert, inserttime, insertdur, cursize, newnotes;\tcursize = score.notes.size;\n\twhile({\n\t\tcursize < len\n\t\t}, {\t\t\n\t\tinsert = 0.rrand(cursize - 1);\n\t\tinserttime = score.notes[insert].starttime;\n\t\tinsertdur = score.notes[insert].duration;\n\t\t#curchunk, chunkdur = chunk.value(inserttime + insertdur);\n\t\tscore.notes[(insert+1)..(cursize-1)].do({arg me; \n\t\t\tme.setStarttime(me.starttime + chunkdur)});\n\t\tscore = score.add(curchunk);\n\t\t(score.notes.size > len).if({\n\t\t\tscore.notes.do({arg me, i;\n\t\t\t\t(i > (len - 1)).if({score.notes.remove(me)});\n\t\t\t\t})\n\t\t\t});\n\t\tcursize = score.notes.size;\n\t\t});\n\t};\n\n// rangemap will place the melodic material within a certain range. The user passes \n// in an envelope that will describe the center pitch in an octave range\n\nrangemap = {arg center;\n\tscore.notes.do({arg me;\n\t\tme.key_(me.key.mapIntoRange(12, center[me.starttime]));\n\t\t})\n\t};\n\t\t\n// expand it to 100 notes\nexpander.value(100);\n\n// describe a new range of pitches\nrangemap.value(Env([60, 96], [20]));\n\n// finally, play the CtkScore\n\nscore.play;\n)\n/* End Figure 18.8 */\n/* Figure 18.9 */\n\n(\nvar score, grain, now, thisdur;\nvar ampmap, double;\n\ngrain = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg freq, amp, dur, pan = 0;\n\t\tvar src, env;\n\t\tenv = EnvGen.ar(\n\t\t\tEnv([0, 1, 0], [0.5, 0.5], \\sin),\n\t\t\ttimeScale: dur, levelScale: amp);\n\t\tsrc = SinOsc.ar(freq, 0, env);\n\t\tOffsetOut.ar(0, Pan2.ar(src, pan));\n\t\t})\n\t);\n\t\nscore = CtkScore.new;\n\nnow = 0;\n\n// create a 3 second granular gesture\n\nwhile({\n\tthisdur = 0.05.rrand(0.1);\n\tscore.add(\n\t\tgrain.new(now, thisdur).freq_(440.rrand(880)).amp_(0.05).dur_(thisdur).pan_(0));\n\tnow = now + 0.01;\n\tnow < 3;\n\t});\n\n// a function to later map the amplitude to a given shape\n// envtimes should be scaled to 1\nampmap = {arg aScore, env;\n\t// caled the envs times by the CtkScore's duration\n\tenv.times = env.times * aScore.endtime;\n\taScore.notes.do({arg thisNote;\n\t\tvar curtime;\n\t\tcurtime = thisNote.starttime;\n\t\tthisNote.amp_(env[curtime]);\n\t\t});\n\t};\n\n// returns a new copy of the CtkScore with notes\n// double an octave higher\ndouble = {arg aScore, shift = 2;\n\tvar thisScore;\n\tthisScore = aScore.copy;\n\tthisScore.notes.do({arg thisNote;\n\t\tthisNote.freq_(thisNote.freq * shift)\n\t\t});\n\tthisScore;\n\t};\n\t\t\n// a Routine to play the examples\nRoutine.run({\n\tvar scoreDouble;\n\t// play the CtkScore;\n\tscore.play;\n\tscore.endtime.wait;\n\t// remap the amplitudes\n\tampmap.value(score, Env([0, 0.2, 0], [0.1, 0.9], [4, -2]));\n\t1.wait; // pause for a moment\n\t// play it again!\n\tscore.play;\n\tscore.endtime.wait;\n\t// add the CtkScore that octaveDouble returns\n\tscoreDouble = double.value(score, 19.midiratio);\n\tampmap.value(scoreDouble, Env([0, 0.25, 0], [0.6, 0.4], [4, -2]));\n\tscore.add(scoreDouble);\n\t1.wait;\n\tscore.play;\n\tscore.endtime.wait;\n\t// don't like the second version? remove double\n\tscore.ctkscores.remove(scoreDouble);\n\tampmap.value(score, Env([0.15, 0.05], [1]));\n\t1.wait;\n\tscore.play;\n\t}).randSeed_(123)\n)\n\n\n/* End Figure 18.9 */\n/* Figure 18.10 */\ns = Server.local;\ns.boot;\n\n~sinosc = CtkSynthDef.new(\\NRT_sinosc, \n\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t}\n);\n\n(\nvar score;\nvar baseNote = 75;\nvar slopeTime = 0.25;\nvar curve = \\sine;\nvar firstPitch = (baseNote + 0).midicps;\nvar firstStart = 0.0;\nvar firstDur = 5.0;\nvar firstAttackTime = slopeTime * 0.5;\nvar firstDecayTime  = slopeTime - firstAttackTime;\nvar firstVibDepth = 0.21;\nvar firstVibRate = 2.3;\nvar firstPeakAmp = 0.25;\nvar firstDecayAmp = 0.01;\nvar secondPitch = (baseNote - 4).midicps;\nvar secondStart = 2.2;\nvar secondDur = 4.0;\nvar secondAttackTime = slopeTime * 0.5;\nvar secondDecayTime  = slopeTime - secondAttackTime;\nvar secondVibDepth = 0.15;\nvar secondVibRate = 1.7;\nvar secondPeakAmp = 0.25;\nvar secondDecayAmp = 0.01;\nvar thirdPitch = (baseNote + 7).midicps;\nvar thirdStart = 3.1;\nvar thirdDur = 3.75;\nvar thirdAttackTime = slopeTime * 0.5;\nvar thirdDecayTime  = slopeTime - thirdAttackTime;\nvar thirdVibDepth = 0.21;\nvar thirdVibRate = 4;\nvar thirdPeakAmp = 0.2;\nvar thirdDecayAmp = 0.25;\n\nscore = CtkScore.new(\n\t~firstGroup = CtkGroup.new(firstStart, firstDur, server: s),\n\t~sinosc.new(firstStart, firstDur, \\tail, ~firstGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, firstVibRate, \n\t\t\t(firstPitch - ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (1/3)))), \n\t\t\t(firstPitch + ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (2/3)))), \n\t\t\tduration: firstDur, addAction: \\head, target: ~firstGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, firstPeakAmp, firstDecayAmp, 0], [firstAttackTime, \n\t\t\t\tfirstDur - (firstAttackTime + firstDecayTime), firstDecayTime], curve), \n\t\t\taddAction: \\head, target: ~firstGroup, server: s)),\n\t~secondGroup = CtkGroup.new(secondStart, secondDur, server: s),\n\t~sinosc.new(secondStart, secondDur, \\tail, ~secondGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, secondVibRate, \n\t\t\t(secondPitch - ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (1/3)))), \n\t\t\t(secondPitch + ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (2/3)))), \n\t\t\tduration: secondDur, addAction: \\head, target: ~secondGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, secondPeakAmp, secondDecayAmp, 0], [secondAttackTime, \n\t\t\t\tsecondDur - (secondAttackTime + secondDecayTime), secondDecayTime], curve), \n\t\t\taddAction: \\head, target: ~secondGroup, server: s)),\n\t~thirdGroup = CtkGroup.new(thirdStart, thirdDur, server: s),\n\t~sinosc.new(thirdStart, thirdDur, \\tail, ~thirdGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, thirdVibRate, \n\t\t\t(thirdPitch - ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (1/3)))), \n\t\t\t(thirdPitch + ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (2/3)))), \n\t\t\tduration: thirdDur, addAction: \\head, target: ~thirdGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, thirdPeakAmp, thirdDecayAmp, 0], [thirdAttackTime, \n\t\t\t\tthirdDur - (thirdAttackTime + thirdDecayTime), thirdDecayTime], curve), \n\t\t\taddAction: \\head, target: ~thirdGroup, server: s))\n);\n\nscore.play;\n)\n/* End Figure 18.10 */\n/* Figure 18.11 */\nVSO_Vib {\n\n\tvar <pitch, <depth, <rate, <control;\n\n\t*new {arg start = 0.0, dur = nil, freq = 1, vibDepth = 0.21, vibRate = 1, \n\t\taddAction = 0, target = 1, server;\n\t\t^super.new.initVSO_Vib(start, dur, freq, vibDepth, vibRate, addAction, \n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_Vib {arg start, dur, freq, vibDepth, vibRate, add = 0, tgt = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tpitch = freq;\n\t\tdepth = vibDepth;\n\t\trate = vibRate;\n\t\tcontrol = CtkControl.lfo(SinOsc, rate, this.getLowerValue,\n\t\t\tthis.getUpperValue, 0, start, dur, add, tgt, server: server);\n\t\n\t}\n\t\n\tgetLowerValue {\n\t\t^(pitch - ((pitch / (pitch.log2)) * (depth * (1/3))));\n\t}\n\n\tgetUpperValue {\n\t\t^(pitch + ((pitch / (pitch.log2)) * (depth * (2/3))));\n\t}\n}\n/* End Figure 18.11 */\n/* Figure 18.12 */\nVSO_ADR {\n\n\tvar <control, <attackDur, <releaseDur, <totalDur;\n\n\t*new {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, attackDur = 0.125, \n\t\treleaseDur = 0.125, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO_ADR(start, dur, peak, decay, attackDur, releaseDur, addAction,\n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_ADR {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, aDur = 0.125, \n\t\trDur = 0.125, addAction = 0, target = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tattackDur = aDur;\n\t\treleaseDur = rDur;\n\t\ttotalDur = dur;\n\t\tcontrol = CtkControl.env(Env.new([0, peak, decay, 0], \n\t\t\t[attackDur, this.decayDur, releaseDur], \\sine), \n\t\t\tstart, addAction, target, server: server, doneAction: 0);\n\t}\n\t\n\tdecayDur {\n\t\t^(totalDur - (attackDur + releaseDur));\n\t}\n\n}\n/* End Figure 18.12 */\n/* Figure 18.13 */\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n/* End Figure 18.13 */\n/* Figure 18.14 */\nVSO {\n\n\tclassvar <sinoscdef;\n\tvar <score, group, oscil, freqCntl, <ampCntl;\n\t\n\t*new {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, ampDecayLevel = 0.01, \n\t\tvibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO(start, dur, freq, ampPeakLevel, ampDecayLevel, \n\t\t\tvibDepth, vibRate, addAction, target, server);\n\t}\n\n\t*initClass {\n\t\tsinoscdef.isNil.if({\n\t\t\tsinoscdef = CtkSynthDef.new(\\NRT_sinosc, \n\t\t\t\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\t\t\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t\t\t\t})\n\t\t\t});\n\t}\n\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n\n}\n/* End Figure 18.14 */\n/* Figure 18.15 */\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nscore = CtkScore.new(\n\t(a = VSO.new(0.0, 5.0, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(2.2, 4.0, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(3.1, 3.75, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n)\n/* End Figure 18.15 */\n/* Figure 18.16 */\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nd = [2.4, 1.7];\na = NRT_TimeFrame.new(0.0, 11);\nb = NRT_TimeFrame.new(a.starttime + d.at(0), a.endtime - (a.starttime + d.at(0)));\nc = NRT_TimeFrame.new(b.starttime + d.at(1), b.endtime - (b.starttime + d.at(1)));\n\nscore = CtkScore.new(\n\t(a = VSO.new(a.starttime, a.duration, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(b.starttime, b.duration, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(c.starttime, c.duration, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n//N.B. You may notice three \"Node not found\" warnings.\n// This is expected behavior for this version of Ctk\n)\n/* End Figure 18.16 */\n/* Figure 18.17 */\nNRT_TimeFrame {\n\n\tvar >starttime, >duration;\n\t\n\t*new {arg starttime, duration;\n\t\t^super.newCopyArgs(starttime, duration);\n\t}\n\n\tstarttime {\n\t\t^starttime.value;\n\t}\n\n\tduration {\n\t\t^duration.value;\n\t}\n\n\tendtime {\n\t\t^(this.starttime != nil).if({\n\t\t\t(this.duration != nil).if({\n\t\t\t\t//call the getter methods rather than accessing\n\t\t\t\t// the variables directly\n\t\t\t\tthis.starttime + this.duration;\n\t\t\t}, {nil})\n\t\t}, {nil});\n\t}\n\n}\n/* End Figure 18.17 */",
    "Ch2code.scd": "\n/* Figure 2.1 */\n\ns = Server.internal.boot;\nz = s.scope(4);\n\n// a) mono output\n(\na = SynthDef(\\UGen_ex1a, {\n\tOut.ar(0, SinOsc.ar(440, 0, 0.1))\n}).play(s);\n)\t\na.free;\n\n// b) freq input is an Array of 4 items - outputs to busses 0-3\n(\na = SynthDef(\\UGen_ex1b, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, 0.1))\n}).play(s);\n)\t\na.free;\n\n// c) Array is added to the 'mul' arg to show mapping\n(\na = SynthDef(\\UGen_ex1c, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3, 0.4]))\n}).play(s);\n)\t\na.free;\n\n// d) The output of the SinOsc above is actually an Array of four SinOscs. Sum them together\n// for an additive synthesis example.\n(\na = SynthDef(\\UGen_ex1d, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3]).sum);\n}).play(s);\n)\t\na.free;\n\nz.window.close;\n\n/* Figure 2.2 */\n\nServer.default = s = Server.internal.boot;\n\nz = s.scope;\n(\nSynthDef(\\UGen_ex2, {arg freq = 440;\n\tvar src, compressor, limiter, out;\n\t// 10 SinOsc's, mixed together. Output amplitude is controlled with an Dust UGen\n \t// wrapped in a Decay2 UGen to create a spike with an Exponential Decay\n\tsrc = SinOsc.ar(\n\t\t// a harmonic series based on freq\n\t\tArray.series(10, freq, freq),\n\t\t0, // phase\n\t\tArray.fill(10, {Decay2.ar( \n\t\t\t// Dust will create an impulse about every 2 seconds, with values between 0\n\t\t\t// and 5\n\t\t\tDust.ar(0.1, 5),\n\t\t\t// Decay2, attach time of 0.01 seconds and a decay time of 5 seconds to\n\t\t\t// allow for a build up of signal\n\t\t\t0.01, 5)});\n\t\t).sum;\n\t// compress signal about 0.5\n\tcompressor = Compander.ar(src, src, 0.5, 1, 0.1);\n\tlimiter = Limiter.ar(compressor, 0.5);\n\t// out is the compressed only signal on the left, the compressed and limited on the \n\t// right\n\tout = [DelayN.ar(compressor, 0.02, 0.02), limiter];\n\t// use Peak and poll to track the highest output values. Updates every second\n\tPeak.ar(out ++  src, Impulse.kr(1)).poll(1, [\"compressed\", \"limited\", \"src\"]);\n\tOut.ar(0, out);\n}).add;\n)\t\na = Synth(\\UGen_ex2, [\\freq, 440]);\n\na.free; z.window.close;\n\n/* Figure 2.3 */\n(\nSynthDef(\\UGen_ex3, {arg gate = 1, amp = 1, rate = 10;\n\tvar trigger, dur, carfreq, modfreq, index, pan, env;\n\ttrigger = Impulse.ar(rate);\n\tdur = rate.reciprocal;\n\tcarfreq = LFNoise2.kr.range(100, 110);\n\tmodfreq = LFTri.kr(0.1).exprange(200, 840);\n\tindex = LFCub.kr(0.2).range(4, 10);\n\tpan = WhiteNoise.ar.range(-0.1, 0.1);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1),\n\t\tgate,\n\t\tlevelScale: amp,\n\t\tdoneAction: 2);\n\tOut.ar(0,\n\t\tGrainFM.ar(2, trigger, dur, carfreq, modfreq, index,\n\t\t\tpan, -1) * env)\n}).add;\n)\na = Synth(\\UGen_ex3, [\\rate, 80, \\amp, 0.2]);\n\nb = Synth(\\UGen_ex3, [\\rate, 42, \\amp, 0.2]);\n\nc = Synth(\\UGen_ex3, [\\rate, 121, \\amp, 0.2]);\n\n[a, b, c].do({arg thisSynth; thisSynth.set(\\gate, 0)});\n\n/* Figure 2.4 */\n\n(\nSynthDef(\\UGen_ex4a, {arg id, limit = 1;\n\tvar src, pitch, hasPitch, keynum, outOfTune;\n\t// read input\n\tsrc = SoundIn.ar(0);\n\t// analyze the frequency of the input\n\t#pitch, hasPitch = Pitch.kr(src);\n\t// convert to a midi keynum, but don't round! This value will be used later.\n\tpitch = pitch.cpsmidi;\n\t// if you are within an eighth tone of an equal tempered pitch, send a trigger\n\toutOfTune = (pitch - pitch.round).abs < 0.25;\n\t// if outOfTune is true, send a trigger. Limit to 1 trigger every 'limit' seconds  \n\tSendTrig.kr(Trig.kr(outOfTune, limit), id, pitch.round);\n}).add;\n\t\nSynthDef(\\UGen_ex4b, {arg id1, id2, limit = 1, thresh = 0.5;\n\tvar src, amp, amptrig, timer;\n\tsrc = SoundIn.ar(0);\n\t// analyze the amplitude input, cause a trigger if the output is over the thresh\n\tamp = Amplitude.kr(src);\n\tamptrig = Trig.kr(amp > thresh, limit);\n\t// use amptrig to see how long it is between triggers.\n\ttimer = Timer.kr(amptrig);\n\t// send the values back with two different ids\n\tSendTrig.kr(amptrig, id1, amp);\n\tSendTrig.kr(amptrig, id2, timer);\n}).add;\n\n// plays a SinOsc of the pitch you were closest to\nSynthDef(\\UGen_ex4c, {arg freq;\n\tOut.ar(1, SinOsc.ar(freq, 0, XLine.kr(0.1, 0.00001, 0.5, doneAction: 2)))\n}).add;\n\n// modulated noise to respond to amp spikes\nSynthDef(\\UGen_ex4d, {arg freq;\n\tOut.ar(1, LFNoise1.ar(200) * SinOsc.ar(freq, 0, \n\t\tXLine.kr(0.1, 0.00001, 0.5, doneAction: 2)));\n}).add;\n\n// allocate three unique ids for the trigger ids\na = UniqueID.next;\nb = UniqueID.next;\nc = UniqueID.next;\t\n\n// an envelope to poll for amp values later\ne = Env([440, 880], [1], \\exp);\n\n// add the responder\no = OSCresponderNode(s.addr, '/tr', {arg time, responder, msg;\n\t// the msg is an array with 4 values... post them\n\tmsg.postln;\n\t// the id sent back from the SendTrig is msg[2]... use it to decide what to do\n\tcase \n\t\t// pitch trigger\n\t\t{msg[2] == a}\n\t\t// msg[3] is the rounded keynum\n\t\t{Synth(\\UGen_ex4c, [\\freq, msg[3].midicps])}\n\t\t// amp trigger\n\t\t{msg[2] == b}\n\t\t// play a noise burst, higher the amp value, higher the freq (polls the \n\t\t// Env 'e')\n\t\t{Synth(\\UGen_ex4d, [\\freq, e[msg[3]]])}\n\t\t// use the Timer value to play a delayed noise burst at 2000 Hz\n\t\t{msg[2] == c}\n\t\t{SystemClock.sched(msg[3], {\n\t\t\tSynth(\\UGen_ex4d, [\\freq, 2000]);\n\t\t\t})}\n}).add;\n\n// schedule the start our listening synths...\n// then sing or tap away on the input.\nSystemClock.sched(1.0, {\n\tSynth(\\UGen_ex4a, [\\id, a, \\limit, 1]);\n\tSynth(\\UGen_ex4b, [\\id1, b, \\id2, c, \\limit, 0.2, \\thresh, 0.25]);\n});\n\t\n// add a command period function to stop the synths and remove the responder\nCmdPeriod.doOnce({\n\to.remove; \"Removed the responder\".postln;\n})\n)\n\n/* Figure 2.5 */\n(\nSynthDef(\\UGen_ex5, {arg gate = 1, seed = 0, id = 1, amp = 1;\n\tvar src, pitchbase, freq, rq, filt, trigger, env;\n\tRandID.ir(id);\n\tRandSeed.ir(1, seed);\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = WhiteNoise.ar;\n\ttrigger = Impulse.kr(Rand.new(2, 5));\n\tpitchbase = IRand.new(4, 9) * 12;\n\tfreq = TIRand.kr(pitchbase, pitchbase + 12, trigger).midicps;\n\trq = LFDNoise3.kr(Rand.new(0.3, 0.8)).range(0.01, 0.005);\n\tfilt = Resonz.ar(src, Lag2.kr(freq), rq);\n\tOut.ar(0, Pan2.ar(filt, LFNoise1.kr(0.1)) * env * amp)\n}).add;\n)\t\na = Synth(\\UGen_ex5, [\\seed, 123]);\n\na.release;\n\n// Using the same seed, we get the same gesture\nb = Synth(\\UGen_ex5, [\\seed, 123]);\n\nb.release;\n\n// passing in different seeds\n(\nr = Routine.run({\n\tthisThread.randSeed_(123);\n\t10.do({\n\t\ta = Synth(\\UGen_ex5, [\\seed, 10000.rand.postln, \\amp, 3.dbamp]);\n\t\t1.wait;\n\t\ta.release;\n\t})\n});\n)\t\t\n/* Figure 2.6 */\n(\nSynthDef(\\UGen_ex6, {arg gate = 1, roomsize = 200, revtime = 450;\n\tvar src, env, gverb;\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = Resonz.ar(\n\t\t\tArray.fill(4, {Dust.ar(6)}),\n\t\t\t1760 * [1, 2.2, 3.95, 8.76] + \n\t\t\t\tArray.fill(4, {LFNoise2.kr(1, 20)}), \n\t\t\t0.01).sum * 30.dbamp;\n\tgverb = GVerb.ar(\n\t\tsrc,\n\t\troomsize, \n\t\trevtime, \n\t\t// feedback loop damping\n\t\t0.99,\n\t\t// input bw of signal\n\t\tLFNoise2.kr(0.1).range(0.9, 0.7),\n\t\t// spread \n\t\tLFNoise1.kr(0.2).range(0.2, 0.6),\n\t\t// almost no direct source \n\t\t-60.dbamp,\n\t\t// some early reflection\n\t\t-18.dbamp, \n\t\t// lots of the tail\n\t\t3.dbamp,\n\t\troomsize);\n\tOut.ar(0, gverb * env)\n}).add;\n)\t\na = Synth(\\UGen_ex6);\n\na.release;\n\n/* Figure 2.7 */\n(\nSynthDef(\\UGen_ex7a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.ar(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex7b, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\nSynthDef(\\UGen_ex7c, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\n\n// 56% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 39%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7b, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 35%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7c, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n/* Figure 2.8 */\n(\nSynthDef(\\UGen_ex8a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar w, x, y, out, env, decode;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tdecode = DecodeB2.ar(2, w, x, y);\n\tOut.ar(0, decode * env)\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8b, {arg outbus, freq = 440, rate = 0.2;\n\tvar w, x, y;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tOut.ar(outbus, [w, x, y])\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8c, {arg inbus, gate = 1, amp = 0.1;\n\tvar w, x, y, env, decode;\n\t#w, x, y = In.ar(inbus, 3);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 14);\n\tdecode = DecodeB2.ar(2, w, x, y) * env;\n\tReplaceOut.ar(0, decode);\n}).add;\n)\n\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex8a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n(\na = Group.new;\nz = Bus.audio(s, 3);\n\n// the 'catch-all' synth for decoding and enveloping\nSynth(\\UGen_ex8c, [\\inbus, z, \\amp, 0.001], a, \\addAfter); // add it after the Group containing the encoding synths\n\n250.do({\n\tSynth(\\UGen_ex8b, [\\freq, 440.0.rrand(1760.0), \\outbus, z, \\rate, 0.2], a)\n});\n)\n\na.release;\t\n/* Figure 2.9 */\n(\n// pass in amp in db\nSynthDef(\\UGen_ex9a, {arg gate = 1, freq = 440, amp = 0;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0, amp.dbamp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\n// pass in linear amplitude\nSynthDef(\\UGen_ex9b, {arg gate = 1, freq = 440, amp = 1;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\nSynthDef(\\UGen_ex9c, {arg gate = 1, freq = 440, amp = -3, pos = 0;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\t\n\n// 45% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9a, [\\freq, 440.0.rrand(1760.0), \\amp, -60], a)\n});\n)\na.release;\n\n// 36%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9b, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp], a)\n});\n)\na.release;\n\n// 36% (no difference from b)\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9c, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp, \\pos, 1.0.rand2], a)\n});\n)\na.release;\n\n/* Figure 2.10 */\n(\nSynthDef(\\UGen_ex10a, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10b, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10c, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\na = Synth(\\UGen_ex10a); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10b); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10c); // cubic interpolation\na.release;\n\n(\nSynthDef(\\UGen_ex10d, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10e, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\t\nSynthDef(\\UGen_ex10f, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\n// tune to a specific pitch\na = Synth(\\UGen_ex10d, [\\deltime, 100.midicps.reciprocal]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 100.midicps.reciprocal]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 100.midicps.reciprocal]); // cubic interpolation\na.release;\n\n// a much longer delay\na = Synth(\\UGen_ex10d, [\\deltime, 0.1]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 0.1]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 0.1]); // cubic interpolation\na.release;\n",
    "BufferSlicer-variant1.scd": "\n//////// First step in evolving the buffer slicer from Figure 20.9 into a more flexible prototype.\n//////// Here we add support for multiple buffers, from arrays of paths and coordinates.\n//////// A pattern, ~buffer, will choose which buffer to use for each event.\n\n// This is a copy of the Figure 20.9 prototype with additions, highlighted by comments.\n\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ |ev| ev[\\bufnum].duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\t~rate = 1;\n\t~buffer = Pfunc({ ~bufs.choose });\n\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\rate, BPStream(\\rate),\t// reference to ~rate stream\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\bufnum, BPStream(\\buffer),\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\n\t~paths = [\"sounds/a11wlk01.wav\"];\t// now an array of strings\n\t\t// [startFrame, numFrames] for each path in ~paths\n\t\t// if this array is shorter, the path index will be wrapped\n\t\t// this default will load the complete soundfile for every path\n\t~bufCoords = [[0, -1]];\n\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t~loadBufs.();\t// move buffer loading to a separate method for modularity\n\t};\n\n\t~loadBufs = {\n\t\t~bufs.do({ |buf| buf.free });\n\t\t~bufs = ~paths.collect({ |path, i|\n\t\t\t~loadOneBuf.(path, *~bufCoords.wrapAt(i));\n\t\t});\n\t};\n\t\n\t~loadOneBuf = { |path, startFrame, numFrames|\n\t\tif(thisProcess.platform.name == \\linux and: { path[..5] == \"sounds\" }) {\n\t\t\tpath = Platform.systemAppSupportDir +/+ path;\n\t\t};\n\t\t\"loading %\\n\".postf(path);\n\t\tBuffer.read(s, path, startFrame, numFrames,\n\t\t\taction: { \"done loading %\\n\".postf(path) });\n\t};\n\t\n\t\t// why not? you should be able to add and remove buffers on the fly\n\t\t// removing a buffer if a synth is using it is maybe risky, though\n\t~addBuf = { |path, startFrame, numFrames|\n\t\t~bufs = ~bufs.add(~loadOneBuf.(path, startFrame, numFrames));\n\t};\n\t\n\t~removeBufAt = { |index|\n\t\t~bufs[index].free;\n\t\t~bufs.removeAt(index);\n\t};\n\n\t~freeCleanup = {\n\t\t[~chan, ~bufs].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\nPR(\\bufSlicer).chuck(BP(\\z), parms: (paths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"]));\n\nBP(\\z).play;\n\nBP(\\z).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\nBP(\\z).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\nBP(\\z).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).buffer = Pclutch(Pfunc({ ~bufs.choose }), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).pan = sin(Ptime(inf));\n\nBP(\\z).stop;\n\nBP(\\z).free;\n",
    "BufferSlicer-variant2.scd": "\n//////// Second step in evolving the buffer slicer from Figure 20.9 into a more flexible prototype.\n//////// Upping the ante further... now we support multiple synthdefs.\n//////// The main pattern does not know in advance which streams to use,\n//////// until the specific def is chosen. So, I invent a data structure that holds\n//////// the SynthDef and patterns for each argument. At initialization, these\n//////// patterns are written into the environment and can be tweaked as in\n//////// previous examples.\n\n(\nPR(\\abstractProcess).clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~def = Pfunc({ ~defs.keys.choose });\n\t~buffer = Pfunc({ ~bufs.choose });\n\t~maxStart = Pfunc({ |ev| ev[\\bufnum].duration }) - Pkey(\\time);\n\n\t~basePattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\def, BPStream(\\def),\n\t\t\t\\instrument, Pfunc({ |ev| ~defs[ev[\\def]].name }),\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\bufnum, BPStream(\\buffer)\n\t\t)\n\t};\n\t\n\t~userPattern = { nil };\n\t\n\t~asPattern = {\n\t\tvar\tuserpat = ~userPattern.();\n\t\tuserpat.notNil.if({\n\t\t\tPchain(userpat, ~basePattern.())\n\t\t}, {\n\t\t\t~basePattern.()\n\t\t}).collect({ |ev|\n\t\t\t~defs[ev[\\def]].argStreams.pairsDo({ |name, value|\n\t\t\t\tev.put(name, value.next(ev));\n\t\t\t});\n\t\t\tev\n\t\t});\n\t};\n\n\t~paths = [\"sounds/a11wlk01.wav\"];\n\t~bufCoords = [[0, -1]];\n\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t~loadBufs.();\n\t\t~initSynthDefs.();\n\t};\n\n\t~loadBufs = {\n\t\t~bufs.do({ |buf| buf.free });\n\t\t~bufs = ~paths.collect({ |path, i|\n\t\t\t~loadOneBuf.(path, *~bufCoords.wrapAt(i));\n\t\t});\n\t};\n\t~loadOneBuf = { |path, startFrame, numFrames|\n\t\tif(thisProcess.platform.name == \\linux and: { path[..5] == \"sounds\" }) {\n\t\t\tpath = Platform.systemAppSupportDir +/+ path;\n\t\t};\n\t\t\"loading %\\n\".postf(path);\n\t\tBuffer.read(s, path, startFrame, numFrames,\n\t\t\taction: { \"done loading %\\n\".postf(path) });\n\t};\n\t~addBuf = { |path, startFrame, numFrames|\n\t\t~bufs = ~bufs.add(~loadOneBuf.(path, startFrame, numFrames));\n\t};\n\t~removeBufAt = { |index|\n\t\t~bufs[index].free;\n\t\t~bufs.removeAt(index);\n\t};\n\n\t~initSynthDefs = {\n\t\tvar\tsdef;\n\t\t~defs = ~defs.value;\n\t\t~defs.keysValuesDo({ |id, defDict|\n\t\t\tsdef = defDict[\\def];\n\t\t\tdefDict[\\name] = sdef.tryPerform(\\name) ? sdef;\n\t\t\tsdef.tryPerform(\\send, ~chan.server);\n\t\t\tsdef.tryPerform(\\add);\n\t\t\t~initArgsForSynthDef.(id);\n\t\t});\n\t};\n\t\n\t~initArgsForSynthDef = { |id|\n\t\tvar\tstreamarray = Array.new(~defs[id][\\args].size), fullname;\n\t\t~defs[id][\\args].pairsDo({ |name, pattern|\n\t\t\t\t// assigning a Pattern to a BP environment variable automatically creates the stream\n\t\t\tfullname = (id ++ name).asSymbol;\n\t\t\tfullname.envirPut(pattern.asPattern);\n\t\t\tstreamarray.add(name).add(BPStream(fullname).asStream);\n\t\t});\n\t\t~defs[id][\\argStreams] = streamarray;\n\t};\n\t\n\t~defs = (\n\t\tbasic: (def: SynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\t\t\t\t\tattack = 0.001, decay = 0.02, outbus|\n\t\t\t\t\tvar sig;\n\t\t\t\t\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t\t\t\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\t\t\t\t\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n\t\t\t\t}),\n\t\t\targs: [\n\t\t\t\trate: 1,\n\t\t\t\ttfactor: 1,\n\t\t\t\ttime: Pkey(\\tfactor) * Pkey(\\delta),\n\t\t\t\tstartSec: Pwhite(0.0, BPStream(\\maxStart), inf),\n\t\t\t\tstart: Pkey(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\tpan: Pwhite(-1.0, 1.0, inf),\n\t\t\t\tamp: 1\n\t\t\t]),\n\t\tstretch: (def: SynthDef(\\bufStretch, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\t\t\t\t\tstretch = 1, attack = 0.001, decay = 0.02, outbus|\n\t\t\t\t\tvar sig;\n\t\t\t\t\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum) / stretch, 1, start, 0);\n\t\t\t\t\tsig = PitchShift.ar(sig, pitchRatio: stretch)\n\t\t\t\t\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\t\t\t\t\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n\t\t\t\t}),\n\t\t\targs: [\n\t\t\t\trate: 1,\n\t\t\t\ttfactor: 1,\n\t\t\t\tstretch: Pexprand(2.0, 4.0, inf),\n\t\t\t\tdelta: Pkey(\\delta) * Pkey(\\stretch),\n\t\t\t\ttime: Pkey(\\tfactor) * Pkey(\\delta),\n\t\t\t\tstartSec: Pwhite(0.0, Pfunc({ |ev| ev[\\bufnum].duration }) - (Pkey(\\time) / Pkey(\\stretch))),\n\t\t\t\tstart: Pkey(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\tpan: Pwhite(-1.0, 1.0, inf),\n\t\t\t\tamp: 1\n\t\t\t])\n\t);\n\n\t~freeCleanup = {\n\t\t[~chan, ~bufs].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\nPR(\\bufSlicer).chuck(BP(\\z), parms: (paths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"]));\n\nBP(\\z).play;\n\nBP(\\z).def = Pwrand(#[basic, stretch], [0.9, 0.1], inf);\n\n// tfactor, startSec and pan are defined separately for each synthdef\n// so, based on the Proto definition, I must prepend the synthdef's key\n// delta and buffer are global for all synthdefs, so no prepend\nBP(\\z).basictfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\nBP(\\z).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\nBP(\\z).basicstartSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).buffer = Pclutch(Pfunc({ ~bufs.choose }), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).basicpan = sin(Ptime(inf));\n\nBP(\\z).stop;\n\nBP(\\z).free;\n\n\n/*\nHere, the chucking parms dictionary is used to add a new synthdef, not as part of the prototype but just in the instance. To avoid polluting the original defs dictionary, the parameter should copy the original and put new item(s) into it -- PR(\\bufSlicer).defs.copy.put(\\grains, ...).\n*/\n\n(\nPR(\\bufSlicer).chuck(BP(\\z), parms: (\n\tpaths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"],\n\tdefs: PR(\\bufSlicer).defs.copy.put(\n\t\t\\grains, (def: SynthDef(\\grainspray, { |center = 0.5, width = 0.1,\n\t\t\t\tdurStart = 0.01, durEnd = 0.01, density = 5,\n\t\t\t\tattack = 0.001, time = 1, decay = 0.02, amp = 1, bufnum, outbus|\n\t\t\tvar\ttrig = Dust.kr(density),\n\t\t\t\trate = TExpRand.kr(0.25, 4.0, trig),\n\t\t\t\tdur = XLine.kr(durStart, durEnd, time),\n\t\t\t\tpan = TRand.kr(-1.0, 1.0, trig),\n\t\t\t\tposRand = TRand.kr(width.neg, width, trig),\n\t\t\t\tsig = TGrains.ar(2, trig, bufnum, rate, center * BufDur.kr(bufnum) + posRand,\n\t\t\t\t\tdur, pan, amp);\n\t\t\tOut.ar(outbus, sig * EnvGen.kr(Env.linen(attack, time, decay), doneAction: 2))\n\t\t}),\n\t\targs: [\n\t\t\tcenter: Pwhite(0.05, 0.95, inf),\n\t\t\twidth: min(Pwhite(0.05, 0.2, inf), min(Pkey(\\center), 1.0 - Pkey(\\center))),\n\t\t\ttime: Pkey(\\delta),\n\t\t\tdensity: Pwhite(20.0, 50.0, inf)\n\t\t])\n\t)\n));\n)\n\nBP(\\z).play;\n\nBP(\\z).def = Pwrand(#[basic, stretch, grains], [0.8, 0.15, 0.05], inf);\n\n// Manipulating other streams is an exercise for the reader.\n\nBP(\\z).stop;\n\nBP(\\z).free;\n",
    "Chapter20-examples.scd": "/*****\n\nThis file contains all the code examples from Chapter 20 of The SuperCollider Book.\n\nMost of them require the server to be started. A few use graphics -- if you are using SwingOSC, make sure the SwingOSC server is booted as well.\n\nIMPORTANT NOTE FOR SWINGOSC USERS:\nPlease also execute this line before running the code examples. Otherwise, some '.gui' statements will fail.\n\nQuarks.install(\"ddwGUIEnhancementsForSwingOSC\");\n\nMacintosh users should *not* install the GUI enhancements for SwingOSC.\n\n\nSee also the example files BufferSlicer-variant1.sc and BufferSlicer-variant2.sc, which take the buffer slicer process (Figure 20.9) to a higher degree of complexity and reusability.\n\nFigure numbers missing from this file are graphics.\n\n--- H. James Harkins\n\n*****/\n\n\n\n////////////////////////////////////////\n//////// Figure 20.1.\n//////// MixerChannel creation, SynthDef conventions, Synth playing\n\n// create the mixer: one channel in, two channels out\ns.boot;\n\nm = MixerChannel(\\fig1, s, 1, 2);\n\n// bring up a mixing board -- you can play with the level and panning controls\n// closing the window, or freeing all of its channels, removes the MixingBoard\nb = MixingBoard(\\Fig1, nil, m);\n\n// a SynthDef should include an outbus (or out) argument\n// so that the MixerChannel can tell it where to write its output\n(\nSynthDef(\\fig1, { |out, lowfreq = 220, hifreq = 1200, decay = 0.05|\n\tvar\ttrig = Impulse.kr(8);\n\t\t// Do not hard-code the outbus here!\n\t\t// Out.ar(0, ...) is not OK. Out.ar(outbus, ...) is good.\n\tOut.ar(out, SinOsc.ar(TExpRand.kr(lowfreq, hifreq, trig)) * Decay2.kr(trig, 0.01, decay));\n}).add;\n)\n\na = m.play(\\fig1, [lowfreq: 100, hifreq: 2000, decay: 0.1]);\n\n// automate panning - this is done with a control-rate synth\nm.automate(\\pan, { SinOsc.kr(LFNoise1.kr(0.5).exprange(0.4, 5.0)) });\n\n// the GUI can show the automation\nm.watch(\\pan);\n\n// add reverb using post-fader send\n// auto-play the reverb synth in the completion function\n(\nr = MixerChannel(\\rvb, s, 2, 2, level:1, completionFunc: { |chan|\n\t\"creating reverb synth\".postln;\n\tchan.playfx({ |outbus|\n\t\tvar\tsig = In.ar(outbus, 2);  // read from channel's bus\n\t\tFreeVerb2.ar(sig[0], sig[1], 1, 0.6, 0.5)\n\t});\n});\n\nb.add(r);  // add to MixingBoard\n)\n\n// feed the signal into the reverb\nm.newPostSend(r, 0.6);\n\n// prints out current state of all mixers in the board\n// the board is accessible also by MixingBoard.at(0)\nb.postSettings;\n\n// fade to black\nm.levelTo(0, 15);\n\n// and release\n// note that on m.free, the synth 'a' is removed also\n// freeing the last MixerChannel in the MixingBoard closes the window\nm.free;\nr.free;\n\n\n\n////////////////////////////////////////\n//////// Figure 20.3.\n//////// Basic Voicer creation; triggering and gating notes.\n\n// Voicer(voices, things, args, bus, target, addAction)\n// target may be a Group, Server, or MixerChannel\nv = Voicer(10, \\default);\n\nv.trigger(440, 1);  // v.trigger(freq, gate, args, latency)\nv.release(440);\n\nv.gate(440, 2.0, 1, [pan: -0.5]);  // v.gate(freq, dur, gate, args, latency)\n\nr = fork {\n\tloop {\n\t\t\t// play over a C major scale\n\t\t[60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|\n\t\t\tv.gate(midi.midicps, 0.1, 1, [amp: rrand(0.05, 0.15)],\n\t\t\t\tlat: 0.1);\n\t\t\t0.125.wait;\n\t\t});\n\t}\n};\n\nr.stop;\n\nv.free;\n\n\n\n////////////////////////////////////////\n//////// Figure 20.4.\n//////// Global controls and GUI.\n\n// let's put a pan global control on the voicer\n\nv = Voicer(10, \\default);\nv.mapGlobal(\\pan, nil, 0, \\bipolar);\t// v.mapGlobal(name, bus, value, spec, allowGUI)\n\nv.gui;\n\n// Pbind works with voicer, using 'voicerNote' event type\n(\np = Pbind(\n\t\\type, \\voicerNote,\n\t\\voicer, v,\n\t\\degree, Pn(Pseries(0, 1, 8), inf),\n\t\\amp, Pwhite(0.05, 0.15, inf),\n\t\\dur, 0.125,\n\t\\legato, 0.8\n).play;\n)\n\n// Try moving the slider in the Voicer window\n\np.stop;\n\n// Note, freeing the Voicer does not close the window\n// because you might want to reuse the GUI\n// But the Voicer area becomes \"inactive\"\nv.free;\n\n\n\n////////////////////////////////////////\n//////// Figure 20.5.\n//////// VoicerMIDISocket.\n\nv = Voicer(10, \\default);\n\n// 0 = device 0, channel 0\n// for a different device, use [device index, channel]\n// after this, you can play on your keyboard\nk = VoicerMIDISocket(0, v);\n\n// modwheel to control pan\nk.addControl(1, \\pan, 0, \\bipolar);\nv.gui;\t// pan is identified by '1' in the gui - MIDI controller ID\n\n// a homegrown variety of just intonation\n// release all notes before executing this!\nk.midiToFreq = TuningRatios(12, tunings: [1, 135/128, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 14/9, 27/16, 16/9, 15/8]);\n\n// If some notes got stuck by changing the tuning, do this:\nv.panic;\n\n// per-note argument generation using a Pbind\n// here used to map velocity data onto the amp input\nk.noteOnArgsPat = Pbind(\\amp, Pkey(\\velocity).linlin(0, 127, 0.01, 0.2));\n\n// if you have a footswitch (controller number 64), this handles it properly\n// make sure to use the same device:\n// if you used [1, 0] for the channel ID before, use [1, 0] here\nl = VoicerSusPedal(0, 64, v);\n\n// by default, freeing the voicer automatically frees the socket and all attached MIDI controllers\nv.free;\n\n\n\n////////////////////////////////////////\n//////// Figure 20.6.\n//////// Proto for prototypes.\n\n// standard \"Hello World\" greeter classes\n\n(\n~greeter = Proto({\n\t~sayhi = { |name|\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n});\n\n// make a subclass with .clone\n~frenchGreeter = ~greeter.clone({\n\t~greeting = \"Bonjour\";\n});\n\n~timeAwareFrenchGreeter = ~frenchGreeter.clone({\n\t~greeting = {\n\t\tvar\thour;\n\t\tif(thisProcess.platform.name != \\windows) {\n\t\t\thour = Date.getDate.hour;\n\t\t\tif(hour < 18) { ~dayGreeting } { ~eveningGreeting };\n\t\t} { ~dayGreeting };\n\t};\n\t~dayGreeting = \"Bonjour\";\n\t~eveningGreeting = \"Bon soir\";\n});\n)\n\n// Use the objects:\n~greeter.sayhi;\n~greeter.sayhi(\"Bob\");\n~frenchGreeter.sayhi(\"Isabelle\");\n\t// note: Date does not work in Windows\n\t// this code ignores time check in Windows\n~timeAwareFrenchGreeter.sayhi(\"Eric\");\n\n\n\n////////////////////////////////////////\n//////// Figure 20.7.\n//////// Greeter as a PR prototype, and usage through BP instances.\n\n(\n\t// define PR prototype - Proto(...) => PR(\\name)\nProto({\n\t~sayhi = { |name|\n\t\t\t// ~greeting.value is an internal pseudomethod call\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n}) => PR(\\greeter);\n)\n\n// make working instance as BP\nPR(\\greeter) => BP(\\greeter);\nBP(\\greeter).sayhi(\"Jacqueline\");\nBP(\\greeter).name = \"Zsa Zsa\";\nBP(\\greeter).sayhi;\n\t// changing name in BP does not affect PR\nPR(\\greeter).name;\n\n// override default at chuck time\n// now this greeter belongs just to Bob\nPR(\\greeter).chuck(BP(\\greetBob), parms: (name: \"Bob\"));\nBP(\\greetBob).name;\t// ~name variable is overridden\nBP(\\greetBob).sayhi;\n\n// remove both instances from the repository\nBP([\\greeter, \\greetBob]).free;\n\n\n\n////////////////////////////////////////\n//////// Figure 20.9.\n//////// Interactive session to build a soundfile slicer.\n\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t\t// BEHAVIORAL components\n\t\t// eventKey refers to ProtoEvent(\\singleSynthPlayer)\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\t\t// here, manufacture the pattern to play\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\bufnum, ~buf.bufnum,\n\t\t\t\\delta, BPStream(\\delta),\t// reference to ~delta stream\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * ~buf.sampleRate,\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\t\t// default Pbind streams\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ ~buf.duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\n\t\t// ARCHITECTURAL components\n\t\t// default soundfile\n\t~path = Platform.case(\n\t\t\\linux, { Platform.systemAppSupportDir +/+ \"sounds/a11wlk01.wav\" },\n\t\t{ \"sounds/a11wlk01.wav\" }\n\t);\n\n\t~startFrame = 0;\n\t~numFrames = -1;\n\t\t// constructor: auto-load soundfile and create mixer\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t\"loading %\\n\".postf(~path);\n\t\t~buf = Buffer.read(s, ~path, ~startFrame, ~numFrames,\n\t\t\taction: { \"done loading buffer\".postln });\n\t};\n\t\t// destructor, called on .free\n\t~freeCleanup = {\n\t\t[~chan, ~buf].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\n// That was the definition. In performance you only need this to play it.\n\nPR(\\bufSlicer) => BP(\\columbia);\nBP(\\columbia).play;\n\n// change process's stream references while it is playing\nBP(\\columbia).tfactor = 0.25;\n\nBP(\\columbia).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\n\nBP(\\columbia).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\n\nBP(\\columbia).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\n\n// also valid to chuck patterns into a BP\n// \".pan\" is an adverb indicating which variable to replace\nsin(Ptime(inf)) =>.pan BP(\\columbia);\n\nBP(\\columbia).stop;\nBP(\\columbia).free;\t// MixerChannel and Buffer go away also\n\n\n\n////////////////////////////////////////\n//////// Figure 20.10.\n//////// Factories for two variants of the buffer slicer process.\n\n// In the definition file:\n(\n(make: { |name|\n\tPR(\\bufSlicer) => BP(name);\n}, type: \\bp) => Fact(\\basic);\n\n(make: { |name|\n\tPR(\\bufSlicer).chuck(BP(name), parms: (\n\t\tpath: PR(\\bufSlicer)[\\path].dirname +/+ \"a11wlk01-44_1.aiff\",\n\t\ttfactor: sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55,\n\t\tdelta: Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf)),\n\t\tstartSec: Pclutch(Pwhite(0.0, Pfunc({ ~buf.duration }) - Pkey(\\time)), Pdiff(Pkey(\\delta)).abs > 0),\n\t\tpan: sin(Ptime(inf)),\n\t\tquant: 1\t// quantize to next beat\n\t))\n}, type: \\bp) => Fact(\\fancy);\n)\n\n// In the performance script:\nFact(\\basic) => BP(\\basic);\n\nBP(\\basic).play;\n\nFact(\\fancy) => BP(\\fancy);\n\nBP(\\fancy).play;\n\nBP([\\basic, \\fancy]).stop;\n\nBP([\\basic, \\fancy]).free;\n",
    "devEnvironment.scd": "\n// set up guis etc. for composition development\n\nvar\tmasterLayout, chuckKeyCtl, composeDocKeyResp,\n\toriginalDocInit;\t// must maintain independent of environment\n\nvar\tpath;\n\nLibrary.at(\\mixer, \\smallskin).isNil.if({\n\tLibrary.put(\\mixer, \\smallskin, MixerSkin.new.maxAcross_(1));\n});\n\n~toolbarFlow.isNil.if({\n\nAbstractChuckArray.loadFromChuckDirectories(\"devPreMIDIcfg.scd\");\n\nMIDIPort.init(~srcInports);\nMIDIPort.resetAll;\nMIDIPort.autoFreeSockets = false;\t// protect midi controllers from being destroyed accidentally\n\ns.boot;\n\n~statusW = GUI.window.new(\"Building GUI, please wait...\",\n\tRect(GUI.window.screenBounds.width - 250 div: 2,\n\tGUI.window.screenBounds.height - 40 div: 2,\n\t250, 40));\n~statusSl = GUI.rangeSlider.new(~statusW, Rect(10, 15, 230, 10))\n\t.lo_(0).hi_(0);\n~numUpdates = (~voicerRows * ~voicerColumns) + 6;\n~currentUpdate = 0;\n~advanceStatus = {\n\t~currentUpdate = ~currentUpdate + 1;\n\t~statusSl.hi_(~currentUpdate / ~numUpdates);\n};\n~statusW.front;\n\n\n~masterLayout = ResizeFlowWindow(\"control panel\");\nmasterLayout = ~masterLayout;\n\n~toolbarFlow = FlowView(~masterLayout.view, Rect(0, 0, 290, GUI.window.screenBounds.height-5), margin: 2@2);\n(~useScroll ? false).if({\n\t~voicerScroll = GUI.scrollView.new(~masterLayout.view, Rect(0, 0, 450 * ~voicerColumns,\n\t\tGUI.window.screenBounds.height-50)).hasHorizontalScroller_(false);\n}, {\n\t~voicerScroll = ~masterLayout.view;\n});\n~voicerFlow = FlowView(~voicerScroll, Rect(0, 0, 450 * ~voicerColumns, 20000), margin: 2@2);\n\nGUI.staticText.new(~toolbarFlow, Rect(0, 0, 280, 20)).string_(\"Toolbar\").align_(\\center);\n\n// voicerproxies -- creating this gui is time sensitive\n// thus the remainder of the gui building is wrapped in a routine that is run on AppClock\nRoutine({\n\tvar\tcount = 0;\n\t(~voicerRows * ~voicerColumns).do({ |i|\n\t\tVoicerProxy.new => VP.prNew(i);\n\t\t\t// first proxy has 4 controls, the rest have 3\n\t\t(3 + (count < ~voicersWith4Controls).binaryValue).do({\n\t\t\tVP(i).v.addControlProxy(nil, true)\n\t\t});\n\t\tcount = count + 1;\n\t\tVP(i).v.maxControlProxies = VP(i).v.controlProxies.size;\n\t\tVP(i).v.smallGui(~voicerFlow, nil, nil, nil, nil, false);\n\t\t0.2.wait;\n\t\t~advanceStatus.();\n\t\t(i+1 % ~voicerColumns == 0).if({ ~voicerFlow.startRow; });\n\t});\n\n~voicerFlow.recursiveResize;\n\n\n// MIDI bufs\n\nMIDIBufManager(nil, 0) => MBM.prNew(0);\nMBM(0).v.gui(~toolbarFlow, Rect(0, 0, 290, 300));\n\n// midi trigger\n~toolbarFlow.startRow;\nMT(1).gui(~toolbarFlow);\n\n0.2.wait;\n~advanceStatus.();\n\n~midiControlFlow = FlowView.new(~toolbarFlow, Rect(0, 0, 80, 250), margin: 2@2);\nVoicerMIDIController.defaultDest = VoicerGCDummy;\n((\\knob ! 8) ++ #[\\mw, \\pb, \\touch, \\xtouch, \\ytouch]).do({ |type|\n\tvar mc;\n\tmc = VoicerMIDIController(\\omni, type);\n\tGUI.dragBoth.new(~midiControlFlow, Rect(0, 0, 30, 20))\n\t\t.align_(\\center)\n\t\t.object_(mc).string_(mc.ccnum.shortName)\n\t\t.beginDragAction_({ |drag| drag.object })\n\t\t.action_({ |drag|\n\t\t\ttry { drag.string_(mc.ccnum.shortName) }\n\t\t});\n\tmc => CC.prNew(mc.ccnum.shortName.asSymbol);\n});\n\n~midiControlFlow.startRow;\n\nGUI.dragSink.new(~midiControlFlow, 80@20).string_(\"reset\").align_(\\center)\n\t.background_(Color.new255(190, 198, 225)).stringColor_(Color.new255(191, 0, 0))\n\t.action_({ |drag|\n\t\ttry { drag.object.reset };\n\t\tdrag.string = \"reset\";\n\t});\n\nGUI.dragSink.new(~midiControlFlow, 80@20).string_(\"free\").align_(\\center)\n\t.background_(Color.new255(190, 198, 225)).stringColor_(Color.new255(191, 0, 0))\n\t.action_({ |drag|\n\t\tvar\tvc, vp;\n\t\t(drag.object.class == VoicerProxy).if({\n\t\t\tvp = drag.object;\n\t\t\tvc = VC.collection.detect({ |vc| vc.v === vp.voicer });\n\t\t\ttry { vc.free }\n\t\t}, {\n\t\t\ttry { drag.object.free };\n\t\t});\n\t\tdrag.string = \"free\";\n\t});\n\nGUI.button.new(~midiControlFlow, 80@20)\n\t.states_([\n\t\t[\"use VProxy\", Color.new255(191, 0, 0), Color.new255(190, 198, 225)],\n\t\t[\"use Voicer\", Color.new255(191, 0, 0), Color.new255(190, 198, 225)],\n\t])\n\t.value_(1)\n\t.action_({ |view|\n\t\tBP.useVoicerProxy = (view.value == 0);\n\t});\nBP.useVoicerProxy = false;\n\n0.2.wait;\n~advanceStatus.();\n\n~toolbarFlow.startRow;\ns.gui(~toolbarFlow);\n\n~toolbarFlow.startRow;\n\n~chuckBrowser = ChuckableBrowser(~toolbarFlow);\n~chuckKeyCtl = ChuckBrowserKeyController(~chuckBrowser);\nchuckKeyCtl = ~chuckKeyCtl;\n\n\t// ctrl-` from gui switches focus to current document\n\t// any other key, if not caught by a view, switches focus back to the chuck key controller\n\t// and passes key thru\n~masterLayout.view.keyDownAction_({ |view, char, mods, unicode, keycode|\n\t(unicode == 30 and: { (mods bitAnd: 0x40000) > 0 }).if({\n\t\tDocument.current.front;\n\t}, {\n\t\tchuckKeyCtl.focus.doKey(view, char, mods, unicode, keycode);\n\t});\n});\n\n0.2.wait;\n~advanceStatus.();\n\n// fix views with nil keyDownActions so that bubbling will be right\n// defaultKeyDownAction returns nil if it should bubble, so func should just pass the return thru\nf = { |view|\n\t\t// MIDIBufManager gui uses a toggletextfield - this change to key down action breaks it\n\t(view.class.name != 'ToggleTextField').if({\n\t\t(view.respondsTo(\\keyDownAction) and: { view.keyDownAction.isNil }).if({\n\t\t\tview.keyDownAction = { |view, char, modifiers, unicode, keycode|\n\t\t\t\tview.defaultKeyDownAction(char, modifiers, unicode, keycode)\n\t\t\t};\n\t\t});\n\t\t\t// nil-do is its own nil check\n\t\tview.tryPerform(\\children).do(f.value(_));\n\t});\n};\n\nf.value(~masterLayout.view);\nf = nil;\n\n~toolbarFlow.recursiveResize;\n\n0.2.wait;\n~advanceStatus.();\n\n//~masterLayout.recursiveResize.front;\n\n// mixer gui slots\n~board = MixingBoard(\"mixer control pool\", Library.at(\\mixer, \\smallskin));\n8.do({ |i| MixerChannelGUI(nil, ~board) => MCG.prNew(i);\n\tMixerMIDIControl(\\omni, nil, MCG(i).v);\n\t~board.add(MCG(i).v);\n});\n1.0.wait;\n~advanceStatus.();\n~board.refresh;\n1.0.wait;\n~advanceStatus.();\n\n~masterLayout.window.bounds = ~controlpanelBounds;\n\t// test scrollability\n(~voicerScroll.respondsTo(\\visibleOrigin)).if({\n\t~voicerScroll.bounds = ~voicerScroll.bounds.width_(305)\n});\n~board.w.bounds = ~mixerBounds;\n\nLibrary.put(\\codeBounds, ~codedocBounds);\n\n// if Document.current is nil, then you can't do anything programmatic with documents\n// so this whole bit should be skipped\n\nif(Document.current.notNil) {\n\t~codedoc = Document.new(\"type code\").bounds_(~codedocBounds);\n\tDocument.listener.bounds = ~postwindowBounds;\n\t\n\tcomposeDocKeyResp = { |doc|\n\t\tvar\toldKeyResp;\n\t\toldKeyResp = doc.keyDownAction;\n\t\tdoc.keyDownAction = { |doc, char, modifiers, keycode|\n\t\t\t(char.ascii == 30 and: { modifiers.bitAnd(0x40000) > 0 }).if({\n\t\t\t\tmasterLayout.front;\n\t\t\t}, {\n\t\t\t\toldKeyResp.value(doc, char, modifiers, keycode);\n\t\t\t});\n\t\t};\n\t};\n\t\n\t// enable ctrl-` for all open documents\n\tDocument.allDocuments.do({ |doc|\n\t\tdoc.isListener.not.if({\n\t\t\tcomposeDocKeyResp.(doc);\n\t\t});\n\t});\n\t\n\t// enable ctrl-` for new documents\n\toriginalDocInit = Document.initAction;\n\tDocument.initAction_({ |doc|\n\t\toriginalDocInit.value(doc);\n\t//\tdoc.autoComplete;\n\t\tcomposeDocKeyResp.(doc);\n\t});\n};\n\n~statusW.close;\n~statusW = ~statusSl = ~numUpdates = ~currentUpdate = ~advanceStatus = nil;\n~masterLayout.front.refresh;\n\n}).play(AppClock);\n\n}, {\n\t\"gui already loaded\".warn;\n});\n",
    "devPreMIDIcfg.scd": "\n// runs before initializing default midi responders\n// must make sure the right device is set up as the first port\n\nvar\tindex;\n\nMIDIClient.initialized.not.if({\n\tMIDIClient.init(MIDIPort.numPorts, MIDIPort.numPorts);\n\n\tif(Library.at(\\chucklib, \\midiSearches).isNil) {\n\t\tLibrary.put(\\chucklib, \\midiSearches, #[\"ultralite\", \"828\"]);\n\t};\n\n\tblock { |break|\n\t\tLibrary.at(\\chucklib, \\midiSearches).do({ |string|\n\t\t\tindex = MIDIClient.sources.detectIndex({ |item|\n\t\t\t\titem.device.find(string, true).notNil\n\t\t\t});\n\t\t\tif(index.notNil) { break.(index) };\n\t\t});\n\t};\n\t\n\tindex.notNil.if({\n\t\t~srcInports = [index];\n\t}, {\n\t\t~srcInports = nil;\n\t});\n\t\n\t~srcInports.debug(\"Index of default MIDI device\");\n}, {\n\t\"MIDIClient already initialized.\".postln;\n});\n\n~srcInports ?? { [] };",
    "startup00-ddwSynths.scd": "// General-use synthdefs\n// I will keep them in a separate SynthDescLib as well as the global one\n\nSynthDescLib(\\ddwSynths, { Server.default });\n\n~mylib = SynthDescLib.all[\\ddwSynths];\n\nSynthDef(\\ctlPoint, { |outbus, value, time, curve|\n\tvar\tstart = In.kr(outbus, 1);\n\tReplaceOut.kr(outbus, EnvGen.kr(Env([start, value], [time], curve), doneAction: 2));\n}).add(\\ddwSynths);\n\n// formerly stock synthdefs were written into the synthdefs/ folder\n// but it's better to send synthdefs on demand\n// so now they are stored in SynthDescLib.global\n// and recalled by name when needed\n\nSynthDef(\\bufGrain, { |start, time, bufnum, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, sig * amp);\n}).add(\\ddwSynths);\n\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add(\\ddwSynths);\n\nSynthDef(\\bufGrain2, { |start, time, bufnum, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(2, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, sig * amp);\n}).add(\\ddwSynths);\n\nSynthDef(\\bufGrainPan2, { |start, time, bufnum, rate = 1, pan, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar l, r;\n\t#l, r = PlayBuf.ar(2, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Balance2.ar(l, r, pan, amp));\n}).add(\\ddwSynths);\n\n// use a pair of enveloped PlayBufs to avoid clicks when looping back on the sample\n\nSynthDef(\\bufRoll, { |start, time = 1, bufnum, rate = 1, amp = 1, strokesPerSec = 18,\n\t\tattack = 0.002, decay = 0.01,\t// attack and decay of individual stroke\n\t\toutbus|\n\tvar\tsig, envDefault, env,\n\t\ttrig = Impulse.ar(strokesPerSec),\n\t\ttrigs = PulseDivider.ar(trig, 2, (0..1)),\n\t\tstrokeEnv = EnvGen.ar(Env.linen(attack, strokesPerSec.reciprocal - attack - decay, decay), trigs);\n\t\t// time of this env must add up to 1.0 sec\n\tenvDefault = Env(#[0, 1, 0], #[0.001, 0.999], -4);\n\t\t// 40 == 10 possible envelope segments (which is a lot, really)\n\tenv = Control.names(\\env).kr((0 ! 40).overWrite(envDefault.asArray, 0));\n\tsig = (PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), trigs, start, 1) * strokeEnv).sum\n\t\t* EnvGen.ar(env, timeScale: time, doneAction:2);\n\tOut.ar(outbus, sig * amp);\n}).add(\\ddwSynths);\n\nSynthDef(\\bufRollPan, { |start, time = 1, bufnum, rate = 1, amp = 1, strokesPerSec = 18, pan = 0,\n\t\tattack = 0.002, decay = 0.01,\t// attack and decay of individual stroke\n\t\toutbus|\n\tvar\tsig, envDefault, env,\n\t\ttrig = Impulse.ar(strokesPerSec),\n\t\ttrigs = PulseDivider.ar(trig, 2, (0..1)),\n\t\tstrokeEnv = EnvGen.ar(Env.linen(attack, strokesPerSec.reciprocal - attack - decay, decay), trigs);\n\t\t// time of this env must add up to 1.0 sec\n\tenvDefault = Env(#[0, 1, 0], #[0.001, 0.999], -4);\n\t\t// 40 == 10 possible envelope segments (which is a lot, really)\n\tenv = Control.names(\\env).kr((0 ! 40).overWrite(envDefault.asArray, 0));\n\tsig = (PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), trigs, start, 1) * strokeEnv).sum\n\t\t* EnvGen.ar(env, timeScale: time, doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add(\\ddwSynths);\n\nSynthDef(\\bufRollPanMove, { |start, time = 1, bufnum, rate = 1, amp = 1, strokesPerSec = 18,\n\t\tattack = 0.002, decay = 0.01,\t// attack and decay of individual stroke\n\t\tpanStart = 0, panEnd = 0,\toutbus|\n\tvar\tsig, envDefault, env,\n\t\ttrig = Impulse.ar(strokesPerSec),\n\t\ttrigs = PulseDivider.ar(trig, 2, (0..1)),\n\t\tstrokeEnv = EnvGen.ar(Env.linen(attack, strokesPerSec.reciprocal - attack - decay, decay), trigs);\n\t\t// time of this env must add up to 1.0 sec\n\tenvDefault = Env(#[0, 1, 0], #[0.001, 0.999], -4);\n\t\t// 40 == 10 possible envelope segments (which is a lot, really)\n\tenv = Control.names(\\env).kr((0 ! 40).overWrite(envDefault.asArray, 0));\n\tsig = (PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), trigs, start, 1) * strokeEnv).sum\n\t\t* EnvGen.ar(env, timeScale: time, doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, Line.kr(panStart, panEnd, time), amp));\n}).add(\\ddwSynths);\n\nSynthDef(\\bufRollPanChangeRate, { |start, time = 1, bufnum, rate = 1, amp = 1,\n\t\tstrokeRateStart = 18, strokeRateEnd = 18,\n\t\tattack = 0.002, decay = 0.01,\t// attack and decay of individual stroke\n\t\tpanStart = 0, panEnd = 0,\toutbus|\n\tvar\tsig, envDefault, env,\n\t\tstrokesPerSec = XLine.kr(strokeRateStart, strokeRateEnd, time),\n\t\ttrig = Impulse.ar(strokesPerSec),\n\t\ttrigs = PulseDivider.ar(trig, 2, (0..1)),\n\t\tstrokeEnv = EnvGen.ar(Env.linen(attack, strokesPerSec.reciprocal - attack - decay, decay), trigs);\n\t\t// time of this env must add up to 1.0 sec\n\tenvDefault = Env(#[0, 1, 0], #[0.001, 0.999], -4);\n\t\t// 40 == 10 possible envelope segments (which is a lot, really)\n\tenv = Control.names(\\env).kr((0 ! 40).overWrite(envDefault.asArray, 0));\n\tsig = (PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), trigs, start, 1) * strokeEnv).sum\n\t\t* EnvGen.ar(env, timeScale: time, doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, Line.kr(panStart, panEnd, time), amp));\n}).add(\\ddwSynths);\n\n\nSynthDef(\\bufGrainRLPF, { |start, time, bufnum, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, ffreq = 2000, rq = 1, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tsig = RLPF.ar(sig, ffreq, rq);\n\tOut.ar(outbus, sig * amp);\n}).add(\\ddwSynths);\n\nSynthDef(\\bufGrainRLPF2, { |start, time, bufnum, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, ffreq = 2000, rq = 1, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(2, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tsig = RLPF.ar(sig, ffreq, rq);\n\tOut.ar(outbus, sig * amp);\n}).add(\\ddwSynths);\n\nSynthDef(\\bufGrainRLPFPan, { |start, time, bufnum, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, pan = 0, ffreq = 2000, rq = 1, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tsig = RLPF.ar(sig, ffreq, rq);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add(\\ddwSynths);\n\n\n// figure out rollPan and 2-channel versions later\n\nSynthDescLib.all[\\ddwSynths].synthDescs.do({ |desc|\n\tSynthDescLib.global.add(desc);\t\t// copy into the global lib\n});\n\n\n// Initially my idea is that the user would be responsible for sending the defs\n// to the server when needed. But this broke too many of my tracks,\n// so I'm adding a dependant to servers to send the synthdefs on boot.\n// Feel free to comment this out if you don't like it.\n\nUpdater(Server, { |obj, what, newServer|\n\tif(what == \\serverAdded) {\n\t\tUpdater(newServer, { |obj, what|\n\t\t\tif(what == \\serverRunning and: { obj.serverRunning }) {\n\t\t\t\tSynthDescLib.all[\\ddwSynths].synthDescs.do({ |desc|\n\t\t\t\t\tdesc.def.send(obj);\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t};\n});\n\nServer.named.do({ |svr| Server.changed(\\serverAdded, svr) });\n",
    "startup01-events.scd": "\n// check SynthDescLib behavior for polySynthPlayer\n// polysynthplayer / trigger support for array args\n// voicer note must either have delta, length, gate specified or a single note as input - trying to get parms from array notes breaks\n// add repetition-factor metric to adaptSeg\n// note for doc: asNotePattern is needed because sometimes I want streams that return SequenceNotes,\n// not events\n\n\n// process prototypes\n\n// start with the abstract\n\nProto({\n\t// environment variables supplied by \"subclasses\"\n\t// ~event, ~prep, ~stopCleanup, ~freeCleanup, ~preparePlay\n\n\t~event = (eventKey: \\default);\n\n\t~bindPatDefault = \\a;\t// aPattern, aStream -- clones should override\n\n\t\t// mainly used for adaptPattern, but other uses are conceivable\n\t~bindPattern = #{ |pat, adverb|\n\t\tadverb = adverb ? ~bindPatDefault;\n\t\tcurrentEnvironment.put(adverb.asSymbol, pat = pat.asPattern);\n\t\tcurrentEnvironment.put((adverb ++ \"Stream\").asSymbol, pat.asStream);\n\t\tcurrentEnvironment\n\t};\n\n\t~bindSymbol = #{ |sym, adverb|\n\t\tvar\tpat;\n\t\t((pat = Pdefn(sym)).pattern != Pdefn.default).if({\n\t\t\t\t// asPattern gets called in ~bindPattern\n\t\t\t~bindPattern.value(pat, adverb)\n\t\t}, {\n\t\t\t~bindPattern.value(sym, adverb)\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t\t// special case for Synth Args\n\t~bindSA = #{ |sa, adverb|\n\t\t~argsStream = sa.asPattern.asStream;\n\t\t~argKeys = sa.argKeys;\n\t\tcurrentEnvironment\n\t};\n\n\t\t// these next two are deprecated -- BPStream(key) is a better solution\n\t\t// retained for backward compatibility\n\n\t~makeStreamForKey = #{ |key, streamKey|\n\t\t\t// output, and stream gets replaced so that playing stream picks it up:\n\t\t(streamKey = streamKey ?? { key ++ \"Stream\" }).asSymbol.envirPut(key.envirGet.asStream)\n\t};\n\n\t~makeProut = #{ |key, reset|\n\t\tvar\tstreamKey;\n\t\t\t// create stream if it doesn't exist\n\t\tstreamKey = (key ++ \"Stream\").asSymbol;\n\t\t(streamKey.envirGet.isNil or: { reset ? true }).if({\n\t\t\t~makeStreamForKey.value(key, streamKey);\n\t\t});\n\n\t\tPrt({ |inEvent|\n\t\t\t{ inEvent = streamKey.envirGet.next(inEvent).yield }.loop\n\t\t});\n\t};\n\t\n\t\t// temporary override of a pattern used with BPStream\n\t\t// ref means, if the pattern returns a symbol, look up the target stream\n\t\t// revertAction is run when control returns to the main stream\n\t~override = { |key, pat, ref = true, revertAction|\n\t\tvar\tstreamkey = (key ++ \"Stream\").asSymbol,\n\t\t\tsavekey = (\"save\" ++ streamkey).asSymbol,\n\t\t\toverkey = (\"override\" ++ streamkey).asSymbol,\n\t\t\toverstream;\n\n\t\tsavekey.envirGet.isNil.if({\n\t\t\tsavekey.envirPut(streamkey.envirGet);\n\t\t});\n\t\t\n\t\toverkey.envirPut(pat.asStream);\n\n\t\t\t// need a variant on cleanupstream that will seamlessly hand control back\n\t\t\t// to the original stream; cleanupstream returns nil and stops the parent stream\n\t\toverstream = Routine({ |inval|\n\t\t\tvar\tnextval;\n\t\t\twhile { (nextval = overkey.envirGet.next(inval)).notNil }\n\t\t\t\t{\tref.if({\n\t\t\t\t\t\t(nextval.isSymbol and: { nextval.envirGet.notNil }).if({\n\t\t\t\t\t\t\tinval = nextval.envirGet.next(inval).yield;\n\t\t\t\t\t\t}, { inval = nextval.yield; });\n\t\t\t\t\t}, {\n\t\t\t\t\t\tinval = nextval.yield;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t\t// end of the line; restore the original stream\n\t\t\t\t\t// and return 1 valid value so that the main pattern doesn't die\n\t\t\t\t\t// after substitution, this routine will not get called again\n\t\t\tstreamkey.envirPut(savekey.envirGet);\n\t\t\tsavekey.envirPut(nil);\n\t\t\toverkey.envirPut(nil);\n\t\t\trevertAction.value;\n\t\t\tstreamkey.envirGet.next(inval).yield;\n\t\t});\n\t\t\n\t\tstreamkey.envirPut(overstream);\n\n\t\tcurrentEnvironment\n\t};\n\n\t~midiParse = true;\t\t// flag whether to group notes together or use the midi buf as is\n\t\t\t\t\t\t// parsing is better for adaptive sequencing objects\n\n\t~canWrap = false;\n\t\n\t~isPlaying = false;\n\t~isWaiting = false;\n\t~isDriven = false;\n\n}) => PR(\\abstractProcess);\n\n\n// one shot PR - sets a base barline in the global library\n\nProto({\n\t~barLength = 4;\n\t~path = #[baseBeat];\t// may override\n\t\t// run this action when resuming rhythmic patterns\n\t~doAction = { |path|\n\t\tvar\tbeats = ~barLength.nextTimeOnGrid(thisThread.clock);\n\t\tLibrary.global.putAtPath(path ? ~path, beats);\n\t\tthisThread.clock.setMeterAtBeat(~barLength, beats);\n\t};\n\t~freeCleanup = { \n\t\tLibrary.global.removeAtPath(~path)\n\t};\n}) => PR(\\setBase);\n\n\n// basic events first\n\n(play:0) => ProtoEvent(\\dummy);\n\n// the default event handles latency differently from BP\nEvent.default.copy => ProtoEvent(\\default);\n\n// Event uses functions to schedule message sends according to timingOffset\n// copy these functions into Func repository for these events\n\nEvent.default[\\schedBundle] => Func(\\basicSchedBundle).subType_(\\eventHelper);\nEvent.default[\\schedBundleArray] => Func(\\basicSchedBundleArray).subType_(\\eventHelper);\nEvent.default[\\schedStrummedNote] => Func(\\basicSchedStrummedNote).subType_(\\eventHelper);\n\n\n{ |lag, offset, server ...bundle|\n\t(~immediateOSC ? false).if({\n\t\tserver.sendBundle(nil, *bundle)\n\t}, {\n\t\tFunc(\\basicSchedBundleArray).value(lag, offset, server, bundle)\n\t});\n} => Func(\\schedEventBundle).subType_(\\eventHelper);\n\n{ |lag, offset, server, bundleArray|\n\t(~immediateOSC ? false).if({\n\t\tserver.sendBundle(nil, *bundleArray)\n\t}, {\n\t\tFunc(\\basicSchedBundleArray).value(lag, offset, server, bundleArray)\n\t});\n} => Func(\\schedEventBundleArray).subType_(\\eventHelper);\n\nEvent.default[\\schedStrummedNote] => Func(\\schedEventStrummedNote).subType_(\\eventHelper);\n\n\n(grain: false,\ntimingOffset: 0,\nsetTarget: {\n\t~chan.notNil.if({\n\t\t~target = (~isFx ? false).if({ ~chan.effectgroup },\n\t\t\t{ ~chan.synthgroup });\n\t\t~server = ~target.server;\n\t\t~bus = ~chan.inbus;\n\t\t~busindex = ~bus.index;\n\t}, {\n\t\t~target.isNil.if({\n\t\t\t~target = Server.default.asTarget;\n\t\t});\n\t\t~server = ~target.server;\n\t\t~bus.notNil.if({\n\t\t\t~bus = ~bus.asBus;\n\t\t\t~busindex = ~bus.index;\n\t\t}, {\n\t\t\t~busindex = 0;\n\t\t});\n\t});\n},\nsetArgs: {\n\tvar\targs, soloargs, polyargs, lib, desc;\n\t((lib = SynthDescLib.all[~lib ? \\global]).notNil\n\t\t\tand: { (desc = lib[~instrument.asSymbol]).notNil }).if({\n\t\t~hasGate = desc.hasGate;\n\t\targs = desc.msgFunc.valueEnvir;\t// not .flopping because this is SINGLE synth player\n\t}, {\n\t\targs = Array.new(currentEnvironment.size*2);\n\t\tcurrentEnvironment.keysValuesDo({ |key, value|\n\t\t\tvalue.isValidSynthArg.if({ args.add(key).add(value) });\n\t\t});\n\t});\n\t~args = args.asOSCArgArray;\n},\nmakeNode: {\n\tvar\targs, nodeID, server, sustain,\n\t\ttempo = ~clock.tryPerform(\\tempo) ? 1.0,\n\t\tbundle,\n\t\tlag = ~lag ? 0,\n\t\toffset = ~timingOffset ? 0,\n\t\treleaseGate = ~releaseGate ? 0;\n\t((~instrument != \\rest) and: { ~freq != \\rest and: { ~type != \\rest } }).if({\n\t\t~setTarget.value;\n\t\t~busindex.notNil.if({\n\t\t\tserver = ~server;\t// for ~trace == true\n\t\t\t~setArgs.value;\n(~debug == true).if({\n//thisThread.clock.debug(\"my clock\");\n thisThread.clock.beats.debug(\"\\nnow\"); ~args.debug(\"singleSynthPlayer\"); });\n\t\t\t~grain = ~grain ? false;\n\t\t\tnodeID = ~grain.if({ -1 }, { ~server.nextNodeID });\n\t\t\t~node = Synth.basicNew(~instrument, ~server, nodeID);\n\t\t\tbundle = [~node.newMsg(~target, ~args ++ [\\outbus, ~busindex, \\out, ~busindex,\n\t\t\t\t\\i_out, ~busindex], \\addToTail)];\n\t\t\tFunc(\\schedEventBundleArray).doAction(lag, offset, server, bundle);\n(~trace == true).if({\n\tFunc(\\schedEventBundle).doAction(lag + 0.05, ~timingOffset, server, [\\n_trace, nodeID]);\n});\n\t\t\t(~grain.not and: { ~hasGate ? false and: { (sustain = ~sustain.value).notNil } }).if({\n\t\t\t\tthisThread.clock.sched(sustain, {\n\t\t\t\t\tFunc(\\schedEventBundle).doAction(lag, offset, server,\n\t\t\t\t\t\t[\\n_set, nodeID, \\gate, releaseGate]);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n},\nplay: {\n\t~makeNode.value;\n\t(~collIndex.notNil and: { ~grain.not }).if({\n\t\t~notifyDependents.value;\n\t});\n}) => ProtoEvent(\\singleSynthPlayer);\n\nProtoEvent(\\singleSynthPlayer).v.copy.putAll((\n\tnotifyDependents: {\n\t\tBP(~collIndex).v.recvEventNotify(~node, currentEnvironment);\n\t}\n)) => ProtoEvent(\\singleSynthPlayNotify);\n\n\t// backward compatibility\nProtoEvent(\\singleSynthPlayNotify).v => ProtoEvent(\\bufStatusUpdate);\n\n\nProtoEvent(\\singleSynthPlayer).v.copy.putAll((play: {\n\tvar args, nodeID, msg, bundle, tempo = ~clock.tryPerform(\\tempo) ? 1.0;\n\t\t// the full condition is needed for Ppar which uses ~freq == \\rest\n\t(~node != \\rest and: { ~instrument != \\rest and: { ~freq != \\rest and: { ~type != \\rest } } }).if({\n\t\t~lag ?? { ~lag = 0 };\n\t\t~node = ~node.value;\n\t\t~instrument = ~node.defName;\n\t\t~setArgs.value;\n\t\tmsg = [~node.setMsg(*~args)];\n\t\tFunc(\\schedEventBundleArray).doAction(~lag, ~timingOffset, ~node.server, msg);\n\t\t(~debug ? false).if({\n\t\t\tmsg.debug(\"singleSynthTrigger\")\n\t\t});\n\t})\n})) => ProtoEvent(\\singleSynthTrigger);\n\nProtoEvent(\\singleSynthPlayer).v.copy.putAll((\nsetArgs: {\n\tvar\targs, lib, desc;\n\t((lib = SynthDescLib.all[~lib ? \\global]).notNil\n\t\t\tand: { (desc = lib[~instrument.asSymbol]).notNil }).if({\n\t\t~args = desc.msgFunc.valueEnvir.clump(2);\n\t}, {\n\t\targs = Array.new(currentEnvironment.size);\n\t\t\t// note that this is a clumped array --\n\t\t\t// that's necessary for flopping (multichannel expanding) the args out in makeNode\n\t\tcurrentEnvironment.keysValuesDo({ |key, value|\n\t\t\tvalue.isValidVoicerArg.if({ args.add([key, value]) });\n\t\t});\n\t\t~args = args;\n\t});\n},\nplay: { var args, nodeID;\n\t(~node != \\rest and: { ~instrument != \\rest and: { ~freq != \\rest and: { ~type != \\rest } } }).if({\n\t\t~lag ?? { ~lag = 0 };\n\t\t~node = ~node.value;\n\t\t\t// assumed to be the same synthdef for each\n\t\t\t// maybe not a safe assumption but a reasonable limitation for now\n\t\t~instrument ?? { ~instrument = ~node.asArray.first.defName };\n\t\t~setArgs.value;\n\t\t~args = ~args.collect(_.flop).flop.collect({ |subarray| subarray.flatten(1).asOSCArgArray });\n\t\t~node.do({ |node, i|\n\t\t\tFunc(\\schedEventBundle).doAction(~lag, ~timingOffset, node.server,\n\t\t\t\tnode.setMsg(*~args.wrapAt(i)));\n\t\t});\n\t})\n})) => ProtoEvent(\\polySynthTrigger);\n\n\n// Seems to work but might need some more testing\n// currently does not support multiple output buses - maybe it does now?\n// but there should be just 1 instrument\n\nProtoEvent(\\singleSynthPlayer).v.copy.putAll((\n\tsetTarget: {\n\t\t~chan.notNil.if({\n\t\t\t~chan = ~chan.asArray;\n\t\t\t~target = ~chan.collect({ |chan|\n\t\t\t\t(~isFx ? false).if({ chan.effectgroup },\n\t\t\t\t\t{ chan.synthgroup });\n\t\t\t});\n\t\t\t~server = ~target.collect(_.server);\n\t\t\t~bus = ~chan.collect(_.inbus);\n\t\t}, {\n\t\t\t~target.isNil.if({\n\t\t\t\t~target = Server.default.asTarget;\n\t\t\t});\n\t\t\t~target = ~target.asArray;\n\t\t\t~server = ~target.collect(_.server);\n\t\t\t~bus.notNil.if({\n\t\t\t\t~bus = ~bus.asArray.collect(_.asBus);\n\t\t\t}, {\n\t\t\t\t~bus = ~server.collect({ |server| Bus(\\audio, 0, 2, server) });\n\t\t\t});\n\t\t});\n\t},\n\tcheckbuses: {\n\t\tblock { |break|\n\t\t\t~bus.do({ |bus|\n\t\t\t\tbus.tryPerform(\\index).isNumber.not.if({ break.(false) });\n\t\t\t});\n\t\t\ttrue\n\t\t}\n\t},\n\tsetArgs: {\n\t\tvar\targs, lib, desc;\n\t\t((lib = SynthDescLib.all[~lib ? \\global]).notNil\n\t\t\t\tand: { (desc = lib[~instrument.asSymbol]).notNil }).if({\n\t\t\t~args = desc.msgFunc.valueEnvir.clump(2);\n\t\t\t~hasGate = desc.hasGate;\n\t\t}, {\n\t\t\targs = Array.new(currentEnvironment.size);\n\t\t\t\t// note that this is a clumped array --\n\t\t\t\t// that's necessary for flopping (multichannel expanding) the args out in makeNode\n\t\t\tcurrentEnvironment.keysValuesDo({ |key, value|\n\t\t\t\tvalue.isValidVoicerArg.if({ args.add([key, value]) });\n\t\t\t});\n\t\t\t~args = args;\n\t\t});\n\t},\n\tmakeOneNode: { |i, strum|\n\t\tvar\tinstr, nodeID, latency, sustain, server = ~server.wrapAt(i), offset = ~timingOffset ? 0,\n\t\t\treleaseGate = ~releaseGate ? 0;\n\t\t((instr = ~instrument/*.wrapAt(i)*/) != \\rest).if({\n\t\t\tnodeID = ~grain.if({ -1 }, { server.nextNodeID });\n\t\t\t~node[i] = Synth.basicNew(instr, server, nodeID);\n\t\t\tlatency = (strum*i) + ~lag;\n\t\t\tFunc(\\schedEventBundle).doAction(latency, offset, server,\n\t\t\t\t~node[i].newMsg(~target.wrapAt(i), \n\t\t\t\t\t~args.wrapAt(i) ++ [\\out, ~bus.wrapAt(i).index,\n\t\t\t\t\t\\i_out, ~bus.wrapAt(i).index, \\outbus, ~bus.wrapAt(i).index],\n\t\t\t\t\t\\addToTail)\n\t\t\t);\n\t\t\t(~grain.not and: { (~hasGate ? false) and: { (sustain = ~sustain.value).notNil } }).if({\n\t\t\t\tthisThread.clock.sched(sustain, {\n\t\t\t\t\tFunc(\\schedEventBundle).doAction(latency, offset, server,\n\t\t\t\t\t\t[\\n_set, nodeID, \\gate, releaseGate]);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t},\n\tmakeNode: {\n\t\tvar args, instr, nodeID, strum, latency;\n\t\t(~instrument != \\rest and: { ~type != \\rest }).if({\n\t\t\t~lag ?? { ~lag = 0 };\n\t\t\t~setTarget.value;\n\t\t\t~checkbuses.value.if({\n//\t\t\t\t~instrument = ~instrument.asArray;\n\t\t\t\t~setArgs.value;\n\t\t\t\t~args = ~args.collect(_.flop).flop.collect({ |subarray| subarray.flatten(1).asOSCArgArray });\n\t\t\t\tstrum = ~strum ? 0;\n\t\t\t\t~grain = ~grain ? false;\n\t\t\t\t~node = Array.newClear([/*~instrument.size,*/ ~args.size, ~bus.size,\n\t\t\t\t\t~target.size].maxItem);\n\t\t\t\t\t// ~makeOneNode populates the right slot in ~node array\n\t\t\t\t~node.size.do({ |i| ~makeOneNode.(i, strum) });\n\t\t\t});\n\t\t});\n\t}\n)) => ProtoEvent(\\polySynthPlayer);\n\nProtoEvent(\\polySynthPlayer).v.copy.putAll((\n\tnotifyDependents: {\n\t\tBP(~collIndex).v.recvEventNotify(~node, currentEnvironment);\n\t}\n)) => ProtoEvent(\\polySynthPlayNotify);\n\n// voicer events (for ai sequencing):\n\n(\ttimingOffset: 0,\n\tstretch: 1.0,\n\t// args: [],\n\t\t// maybe you want to use non-equal-temperament. override this func\n\t\t// or, if you are using modally-mapped values, include the cpsFunc or EqualTemperament derivative\n\t\t// in the ModalSpec itself\n\tmidiNoteToFreq: #{ |notenum|\n\t\t~mode.notNil.if({ ~mode.asMode.cpsFunc.value(notenum) },\n\t\t\t{ notenum.midicps });\n\t},\n\t\n\tprepNote: #{\n\t\tvar i, args, argval, thisEvent = currentEnvironment;\n\t\t~newFreq = ~freq ?? { ~note.asFloat };\n\t\t~mtranspose.notNil.if({ ~newFreq = ~newFreq + ~mtranspose });\n\t\t(~midi ? false).not.if({ ~newFreq = ~newFreq.unmapMode(~mode.asMode) });\n\t\t~ctranspose.notNil.if({ ~newFreq = ~newFreq + ~ctranspose });\n\n\t\t~newFreq = ~midiNoteToFreq.value(~newFreq).asArray;\n\t\t~dur = ~dur ?? { ~delta ?? { ~note.dur } };\n\t\t~length = (~length ?? { ~note.length }).asArray;\n\t\t\n\t\t\t// some patterns (e.g. Pfindur) might shorten the delta\n\t\t\t// in which case length could be too long\n\t\t\t// but this really applies only to MonoPortaVoicers,\n\t\t\t// hence the adjust... test\n\t\tif(~adjustLengthToRealDelta.value and: { ~dur != currentEnvironment.delta }) {\n\t\t\t~length = ~length * currentEnvironment.delta / ~dur;\n\t\t};\n\t\t\n\t\t~args = ~args ?? { [~note.tryPerform(\\args)].tryPerform(\\flatten, 1) } ?? { [] };\n\t\ti = 0;\t// args should be key value pairs, but might be an array of velocities\n\t\t\t\t// drop pairs that are not \\symbol, value\n\t\t{ i < ~args.size }.while({\n\t\t\t~args[i].isSymbol.not.if({\n\t\t\t\ttry { ~args.removeAt(i); ~args.removeAt(i); };\n\t\t\t}, {\n\t\t\t\ti = i + 2;\t// should increment only if not removing an item\n\t\t\t});\n\t\t});\n\t\t\n\t\t~gate = (~gate ?? { ~note.gate }).asArray;\n\t\t\n\t\t\t// for args array to be valid (argName, value pairs), must have at least 2 items\n\t\t(~args.size < 2).if({ ~args = nil });\n\t\t~voicer !? {\n\t\t\t~nodes = ~voicer.prGetNodes(max(~newFreq.size, max(~length.size, ~gate.size)));\n\t\t\t~voicer.setArgsInEvent(currentEnvironment);\n\t\t};\n\t\t~bassID.notNil.if({\n\t\t\t~note ?? { ~note = SequenceNote(~freq, ~dur, ~length[0], ~gate[0]) };\n\t\t\tLibrary.put(~bassID, ~note);\n\t\t\t\t// allow this thread to finish before alerting dependents\n\t\t\tthisThread.clock.sched(0, { BP.changed(thisEvent[\\bassID], thisEvent); });\n\t\t});\n\t},\n\t\n\tplay: #{\n\t\tvar\tlag = ~lag ? 0,  // ~timingOffset !? { ~timingOffset / ~clock.tempo };\n\t\t\ttimingOffset = ~timingOffset ? 0,\n\t\t\tclock = ~clock,\n\t\t\tvoicer = ~voicer,\n\t\t\tbundle, releaseGate;\n\t\t(~debug == true).if({\n\t\t\t\"\\n\".debug;\n\t\t\t[\"voicerNote event\", ~clock.beats, ~clock.tempo].debug;\n\t\t\tcurrentEnvironment.collect({ |value| value.isFunction.not.if(value, nil) }).postcs;\n\t\t});\n\t\t~prepNote.value;\n\t\t~finish.value;\t// user-definable\n\t\treleaseGate = (~releaseGate ? 0).asArray;\n\t\t~nodes.do({ |node, i|\n\t\t\tvar\tfreq = ~newFreq.wrapAt(i), length = ~length.wrapAt(i);\n\t\t\tFunc(\\schedEventBundleArray).doAction(lag, ~timingOffset, node.server,\n\t\t\t\tnode.server.makeBundle(false, {\n\t\t\t\t\tnode.trigger(freq, ~gate.wrapAt(i), ~args.wrapAt(i), node.server.latency);\n\t\t\t\t}));\n\t\t\t(length.notNil and: { length != inf }).if({\n\t\t\t\t\t// can't use schedEventBundle\n\t\t\t\t\t// because you must not release the VoicerNode\n\t\t\t\t\t// until the proper time comes\n\t\t\t\tthisThread.clock.sched(length + timingOffset, {\n\t\t\t\t\tvoicer.releaseNode(node, freq, releaseGate.wrapAt(i),\n\t\t\t\t\t\tlag + (node.server.latency ? 0));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t},\n\t\t// for live midi input -- assumes midi note has been put into ~note\n\treleaseNote: #{\n\t\t((~immediateOSC ? false) or: { ~voicer.target.server.latency.isNil }).if({\n\t\t\t~voicer.release(~newFreq);\n\t\t}, {\n\t\t\t~voicer.release(~newFreq,\n\t\t\t\t((~lag + ~timingOffset) / ~clock.tempo) + ~voicer.target.server.latency);\n\t\t});\n\t},\n\t\n\t\t// you could override this\n\tadjustLengthToRealDelta: { ~voicer.isKindOfByName(\\MonoPortaVoicer) },\n\t\n\tkeysToPropagate: #[\\voicer, \\midi, \\mode, \\timingOffset, \\argKeys, \\immediateOSC]\n) => ProtoEvent(\\voicerNote);\n\n// synthNote\nProtoEvent(\\voicerNote).v.copy.putAll((\n\tplay: #{\n\t\tvar\tsynthLib;\n\t\t\t// cribbed from Event.default\n\t\tif (~msgFunc.isNil) {\n\t\t\tsynthLib = ~synthLib ?? { SynthDescLib.global };\n\t\t\t~desc = synthLib.synthDescs[~instrument];\n\t\t\tif (~desc.notNil) { \n\t\t\t\t~hasGate = ~desc.hasGate;\n\t\t\t\t~msgFunc = ~desc.msgFunc;\n\t\t\t}{\n\t\t\t\t~hasGate = ~hasGate ? true;\n\t\t\t\t~msgFunc = ~defaultMsgFunc;\n\t\t\t};\n\t\t}{\n\t\t\t~hasGate = ~hasGate ? true;\n\t\t};\t// end crib\n\t\t~prepNote.value;\n\t\t~finish.value;\t// user-definable\n\t\t~lag ?? { ~lag = 0 };\n\t\t(~freq.isSymbol.not and: { ~desc.notNil }).if({\n\t\t\t(~freq.size > 0).if({\n\t\t\t\t(~gate.size == 0).if({ ~gate = [~gate] });\n\t\t\t\t(~length.size == 0).if({ ~length = [~length] });\n\t\t\t\t~freq.do({ |freq, i|\n\t\t\t\t\t~playOneNote.value(freq, ~gate.wrapAt(i), ~length.wrapAt(i));\n\t\t\t\t});\n\t\t\t}, {\n\t\t\t\t~playOneNote.value(~freq, ~gate, ~length)\n\t\t\t});\n\t\t});\n\t},\n\t\n\tplayOneNote: #{ |freq, gate, length|\n\t\tvar\tsynth, server, groupbus;\n\t\tserver = ~server ? ~target.server;\n\t\tsynth = Synth.basicNew(~instrument, server);\n\t\t\t// if groupbus is not nil, then ~target is a MixerChannel\n\t\t(groupbus = ~target.tryPerform(\\groupBusInfo)).notNil.if({\n\t\t\tFunc(\\schedEventBundle).doAction(~lag, ~timingOffset, server, synth.newMsg(groupbus[0],\n\t\t\t\t\t~args ++ [\\outbus, groupbus[1], \\out, groupbus[1],\n\t\t\t\t\t\\freq, freq, \\gate, gate], \\addToTail));\n\t\t}, {\n\t\t\tFunc(\\schedEventBundle).doAction(~lag, ~timingOffset, server, synth.newMsg(~target,\n\t\t\t\t\t~args ++ [\\outbus, ~out, \\out, ~out, \\freq, freq, \\gate, gate], \\addToTail));\n\t\t});\n\t\t~hasGate.if({\n\t\t\tFunc(\\schedEventBundle).doAction(~lag + length, ~timingOffset, synth.server,\n\t\t\t\tsynth.setMsg(\\gate, ~releaseGate ? 0));\n\t\t});\n\t},\n\t\n\treleaseNote: nil,\n\t\n\tkeysToPropagate: #[\\instrument, \\target, \\midi, \\mode, \\timingOffset]\n)) => ProtoEvent(\\synthNote);\n\n\n// event for a melody wrapper\n(\tplay: #{\n\t\t(~debug == true).if({\n\t\t\tthisThread.beats.debug(\"\\nchord trigger event\"); currentEnvironment.debug;\n\t\t});\n\t\t~preAction.value;\t// maybe some kind of cleanup?\n\t\t~getTopNoteNum.value;\n\t\t\t// nil is legit if there is no topnote pattern\n\t\t(~topNoteNum.isNumber or: { ~topNoteNum.isNil }).if({\n\t\t\t(~midi ? false).if({\n\t\t\t\t~length = inf;\t// should not terminate except by midi note\n\t\t\t}, {\n\t\t\t\t\t// not needed here but included for subclasses\n\t\t\t\t\t// if previous child stream needs to be stopped, do it in ~finish\n\t\t\t\t~finish.value;\n\t\t\t\t~length = ~length ? ~delta;\n\t\t\t});\n\t\t\t\t// start it at the current logical time\n\t\t\t~clock.sched(0, ~makeChildStream.value);\n\t\t\tNotificationCenter.notify(~child, \\runChild, currentEnvironment);\n\t\t});\n\t},\n\tgetTopNoteNum: {\n\t\t~topNoteNum = ~top.tryPerform(\\at, \\freq)\n\t\t\t?? { ~top.tryPerform(\\at, \\note).tryPerform(\\freq) };\n\t},\n\tmakeChildStream: {\n\t\tvar childStreamTemp, childEvent, child = ~child;\n\t\t\t// create a new stream and put it in the environment\n\t\t\t// child stream needs to know the current event, so it's passed to asPattern\n\n\t\t\t// downward propagation - responsibility of wrapper\n\t\t~propagateDownward.value;\n\t\t(childEvent = ~child[\\event]).parent = ProtoEvent(childEvent[\\eventKey]).v;\n\n\t\t~child.preparePlay;\n\t\tchildStreamTemp = ~wrapPattern.value(~child.asPattern(currentEnvironment));\n\t\t\t// child stream should run within the child environment\n\t\t~child.use({ childStreamTemp = childStreamTemp.asStream });\n\t\t~child.put(\\eventStream, CleanupStream(childStreamTemp,\n\t\t\t\t// maybe somebody else needs to know that you stopped?\n\t\t\t\t// this doesn't handle manual stop, but parent should stop too\n\t\t\t{ NotificationCenter.notify(child, \\childStop); }\n\t\t));\n\n\t\t~child.put(\\eventStreamPlayer, childStreamTemp = EventStreamPlayer(\n\t\t\t~child.eventStream,\n\t\t\tchildEvent\n\t\t).refresh);\n\t\tchildStreamTemp\t// return new ESP\n\t},\n\tfinish: #{\n\t\t(~stopChild ? true).if({\n\t\t\t~child.eventStreamPlayer.stop;\n\t\t});\n\t},\n\twrapPattern: #{ |pattern|\n\t\tpattern\t// simply return pattern, unmodified\n\t},\n\tkeysToPropagate: #[\\midi]\n) => ProtoEvent(\\melWrap);\n\n\n// melody wrapper event that pauses the parent\n// the parent must register a notification for the childStop event so that it can resume when the child is done\n// this supports wrapping a melody whose length is not known at play start time\n\nProtoEvent(\\melWrap).v.copy.make({\n\t~finishSuper = ~finish;\n\t~finish = {\n\t\t~finishSuper.value;\n\t\t\t// user must supply eventstreamplayer\n\t\t\t// this breaks the contract vis-a-vis circular references\n\t\t~myThread.pause;\n\t};\n}) => ProtoEvent(\\melWrapEmbed);\n\n\n// macrorhythm protoevent\n// dur and length should be populated\n// note may contain topNote, but it's up to the child process to use it\n// how to use inheritance on a protoevent:\nProtoEvent(\\melWrap).v.copy.make({\n\t\t// should only be called inside the event\n\t~wrapPattern = #{ |pattern|\n\t\t(~length != inf).if({\n\t\t\tpattern = Pfindur(~length-0.01, pattern);\n\t\t}, {\n\t\t\tpattern\n\t\t});\n\t};\n\t\n\t~getChord = true;\t// default; midi input may override -- used??\n\t\n\t~keysToPropagate = #[\\mode, \\midi];\n}) => ProtoEvent(\\macroRh);\n\n\n// a general-purpose singleSynthPlayer process\n\nPR(\\abstractProcess).v.clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\n\t~inChannels = 2;\n\t~outChannels = 2;\n\t\t// you may specify a server at chuck time\n\t\t// but DO NOT save a server into a prototype\n\t\t// because, when you do PR => BP, the server gets copied\n\t\t// and that messes up a whole lot of stuff\n\t\t// to avoid that trouble, give the server as a Function\n\t\t// because a Function's return value isn't copied\n\t\t// this is used for initialization only,\n\t\t// and not used if you give a MixerChannel as ~master\n//\t~server = { Server.default };\n\n\t\t// synthdef preparation might depend on the mixerchannel and user-defined resources\n\t\t// note the order of initialization carefully\n\t~prep = {\n\t\tvar\tserver = ~master.tryPerform(\\server) ?? {\n\t\t\t\t~server.value ?? { Server.default } };\n\t\tif(SynthDescLib.global.servers.value.asArray.includes(server).not) {\n\t\t\tSynthDescLib.global.addServer(server);\n\t\t};\n\t\tif(~chan.isNil) {\n\t\t\t~chan = MixerChannel(~collIndex, server, ~inChannels, ~outChannels,\n\t\t\t\toutbus: ~master, completionFunc: { |chan|\n\t\t\t\t\t~userpreps.do(_.value);\n\t\t\t\t\t~userprep.value;\t\t// preparation specified in chuck parameters\n\t\t\t\t\t~makeSynthDefs.value;\n\t\t\t\t});\n\t\t} {\n\t\t\t~iMadeChan = false;\n\t\t\t~userpreps.do(_.value);\n\t\t\t~userprep.value;\t\t// preparation specified in chuck parameters\n\t\t\t~makeSynthDefs.value;\n\t\t};\n\t};\n\n\t~delta = 1.0;\n\t\t// by default, delta and sustain will have the same value\n\t~sustain = Pkey(\\delta);\n\t~synth = Pfunc({ ~objects.keys.choose });\n\t\n\t\t// when you clone, if you need extra preparation, do ~userpreps = ~userpreps.copy.add({  ... });\n\t~userpreps = List.new;\n\t\n\t\t// chuck-time parameter for user preparation\n\t~userprep = nil;\n\t\n\t\t// ~objects is a dictionary\n\t\t// key --> dict; outer key is the identifier for the synth that will be used in the synth pattern\n\t\t// dict = (def: definition, args: [arg1: Pattern1, arg2: pattern2...])\n\t\t// definition is a function, Patch or SynthDef\n\t~objects = (\n\t\tdefault: (def: \\default, args: [\n\t\t\tfreq: PdegreeToKey(Pwhite(35, 50, inf), #[0, 2, 4, 5, 7, 9, 11], 12).midicps\n\t\t])\n\t);\n\n\t\t// support code follows\n\t~makeSynthDefs = { \n\t\t~objects = ~objects.value;\n\t\t~objects.keysValuesDo({ |id, def|\n\t\t\tdef[\\synthdef].isNil.if({\n\t\t\t\t~makeOneSynthDef.(id, def);\n\t\t\t});\n\t\t});\n\t};\n\n\t~makeOneSynthDef = { |id, def|\n\t\tvar\tsdef, reference;\n\t\t\t// allow references to other items in ~objects\n\t\t\t// that is, you can reuse a patch but supply a different argument array\n\t\tif(def[\\def].isSymbol\n\t\t\t\tand: { (reference = ~objects[def[\\def]]).notNil\n\t\t\t\tand: { reference !== def } }) {\n\t\t\t\t// has the reference already been prepared?\n\t\t\treference[\\synthdef].isNil.if({\n\t\t\t\t~makeOneSynthDef.(def[\\def], reference);\n\t\t\t});\n\t\t\tdef[\\synthdef] = reference[\\synthdef];\n\t\t\tdef[\\name] = reference[\\name];\n\t\t\t\t// no need to resend synthdef\n\t\t} {\n\t\t\tsdef = ~makeDefForObject.(def[\\def], id);\n\t\t\tdef[\\synthdef] = sdef;\n\t\t\tdef[\\name] = sdef.tryPerform(\\name) ? sdef;\n\t\t\tsdef.tryPerform(\\send, ~chan.server);\n\t\t\tsdef.tryPerform(\\add);\n\t\t};\n\t\t~prepareArgsForOneDef.(id);\n\t};\n\n\t~makeDefForObject = #{ |obj, id|\n\t\tvar return, reference;\n\t\t(return = ~classActions[obj.class.name]).notNil.if({\n\t\t\treturn = return.envirGet.(obj, id)\n\t\t});\n\t\treturn ?? { obj }\t// if nothing, return the object itcurrentEnvironment\n\t};\n\t~makeFnDef = #{ |fn|\n\t\tfn.asSynthDef(outClass: (~isFx ? false).if({ \\ReplaceOut }, { \\Out }));\n\t};\n\t~makePatchDef = #{ |patch, id|\n\t\tvar\tsdef; // = patch.asSynthDef;\n\t\tsdef = patch.asSynthDef;\n\t\t\t// I saw a scenario where InstrSynthDef did not come up with a unique name based on args\n\t\t\t// dictionary id must be unique to this BP\n\t\t\t// might have the same ID with different args in different BPs, so add the BP's ID\n\t\tsdef.name = ~collIndex ++ id;\n\t\tsdef\n\t};\n\t~makeSynthDef = #{ |def| def };\n\t~classActions = IdentityDictionary[\n\t\t'SynthDef' -> \\makeSynthDef,\n\t\t'Function' -> \\makeFnDef,\n\t\t'Patch' -> \\makePatchDef,\n\t\t'WrapPatch' -> \\makePatchDef,\n\t\t'FxPatch' -> \\makePatchDef\n\t];\n\n\t~prepareArgsForOneDef = { |id|\n\t\tvar\tstreamarray = Array.new(~objects[id][\\args].size), fullname;\n\t\t~objects[id][\\args].pairsDo({ |name, pattern|\n\t\t\t\t// assigning a Pattern to a BP environment variable automatically creates the stream\n\t\t\tfullname = (id ++ name).asSymbol;\n\t\t\tfullname.envirPut(pattern.asPattern);\n\t\t\tstreamarray.add(name).add(BPStream(fullname).asStream);\n\t\t});\n\t\t~objects[id][\\argStreams] = streamarray;\n\t};\n\n\t~basePattern = { \n\t\t(~debug ? false).if(DebugPbind, Pbind)\n\t\t.new(\n\t\t\t\\synthKey, BPStream(\\synth),\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\sustain, BPStream(\\sustain),\n\t\t\t\\instrument, Pfunc({ |ev|\n\t\t\t\t(ev[\\synthKey] == \\rest).if({ \\rest },\n\t\t\t\t\t{ ~objects[ev[\\synthKey]].tryPerform(\\at, \\name) ? \\rest })\n\t\t\t}),\n\t\t\t\\chan, ~chan\n\t\t)\n\t};\n\n\t~asPattern = { \n\t\t~basePattern.value.collect({ |ev|\n\t\t\t(ev[\\synthKey] != \\rest).if({\n\t\t\t\t~getUserArgs.(ev);\n\t\t\t}, { ev });\n\t\t});\n\t};\n\t\n\t~getUserArgs = { |event|\n\t\tvar key = event[\\synthKey], streamout;\n\t\tblock { |break|\n\t\t\t~objects[key][\\argStreams].pairsDo({ |name, stream|\n\t\t\t\t(streamout = stream.next(event)).isNil.if({\n\t\t\t\t\tif(~debug ? false) {\n\t\t\t\t\t\t\"% stream was nil, stopping\".format(name.asCompileString).warn;\n\t\t\t\t\t};\n\t\t\t\t\tbreak.(nil);\t// early exit with nil result to stop main stream\n\t\t\t\t}, {\n\t\t\t\t\t(~debug ? false).if({\n\t\t\t\t\t\t[name, streamout].debug(\"user arg\");\n\t\t\t\t\t});\n\t\t\t\t\t(name.isSequenceableCollection).if({\n\t\t\t\t\t\tname.do({ |n, i| event[n] = streamout[i] })\n\t\t\t\t\t}, {\n\t\t\t\t\t\tevent[name] = streamout;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\tevent\n\t\t}\n\t};\n\t\n\t\t// when you clone, if you need extra preparation, do ~userfrees = ~userfrees.copy.add({  ... });\n\t~userfrees = List.new;\n\t\n\t\t// chuck-time parameter for user preparation\n\t~userfree = nil;\n\t\n\t~freeCleanup = { \n\t\tif(~iMadeChan ? true) { ~chan.free };\n\t\t\t// should free patches\n\t\t~objects.do({ |def|\n\t\t\ttry {\n\t\t\t\tdef[\\def].isKindOf(AbstractPlayer).if({ def[\\def].free });\n\t\t\t};\n\t\t});\n\t\t~userfree.value;\n\t\t~userfrees.do(_.value);\n\t};\n\n}) => PR(\\basicSynthChooser);\n",
    "startup02-melodicStorage.scd": "\n// framework for adaptive processes\n\nvar saveSubType = AbstractChuckArray.defaultSubType;\nAbstractChuckArray.defaultSubType = \\melodyStorage;\n\n// first, handler for a single segment -- this will be analyzed modally\nProto({\n\t\t// canPauseAfter is deprecated for a more OO solution\n\t~prepare = #{ |notes, nextNote, storage, parms, rawMIDI = true|\n\t\t\t// notes should be in the format [note, note, note]\n\t\tvar\tmode = parms.atBackup(\\mode, storage) ? \\default;\n\t\t~notes = notes.asArray;\n\t\t~nextNote = nextNote;\t// final interval should be calculated relative to the next note\n\t\t{ (rawMIDI ? true).if({ ~mapToMode.value(mode) }, {\n\t\t\t~mode = (mode.size > 0).if({ mode[0] }, { mode });\n\t\t\t});\n\t\t}.try({ |error|\n\t\t\tError(\"Error translating MIDI to modal. Check to see if default mode is defined.\")\n\t\t\t\t.throw;\n\t\t});\n\t\t~modeSubstitution = parms.atBackup(\\modeSub, storage);\n\t\t~analyzeNotes.value(rawMIDI);\t// collect stats on chord -- user definable\n\t\tcurrentEnvironment\n\t};\n\t\n\t~mapToMode = #{ |mode|\n\t\tvar\tbestMode, bestFit = -1e10, bestMap, modeFit, notesTemp, modeObj;\n\t\tmode = mode ? \\default; \t// keep symbol for storage\n\t\tmodeObj = mode.asMode;\n\t\t\t// is it a single mode, or a mode pool?\n\t\tif(modeObj.size > 0) {\n\t\t\tmodeObj.do({ |mode, i|\n\t\t\t\tnotesTemp = ~notes.mapMode(mode);\n\t\t\t\t((modeFit = Func(\\chModeFit).doAction(notesTemp)) > bestFit).if({\n\t\t\t\t\tbestMode = mode;\n\t\t\t\t\tbestFit = modeFit;\n\t\t\t\t\tbestMap = notesTemp;\n\t\t\t\t});\n\t\t\t});\n\t\t\t~mode = bestMode;\n\t\t\t~notes = bestMap;\n\t\t\t~nextNote = ~nextNote.mapMode(bestMode)\n\t\t}{\n\t\t\t~notes = ~notes.mapMode(mode);\n\t\t\t~nextNote = ~nextNote.mapMode(mode);\n\t\t\t~mode = mode;\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\t\n\t~mapToMIDI = #{ |mode|\n\t\t~notes = ~notes.unmapMode(mode ?? { ~mode ? \\default });\n\t\t~nextNote = ~nextNote.unmapMode(mode ?? { ~mode ? \\default });\n\t\tcurrentEnvironment\n\t};\n\t\n// subclasses must implement:\n//\t~analyzeNotes (if needed)\n//\t~asPattern\n}) => PR(\\abstractModeSeg);\n\nPR(\\abstractModeSeg).v.clone({\n\t~analyzeNotes = #{ |rawMIDI|\n\t\tcurrentEnvironment\n\t};\n\n\t\t// rhythm profile must act on grace notes before the notes are embedded in the stream\n\t\t// thus, PseqFunc\n\t\t\n\t\t// change in ~useRh will take effect only at segment boundaries\n\t\t\n\t~asNotePattern = #{ |passInValue|\n\t\tvar dur, length, rhy, out;\n\t\tout = (passInValue[\\useRh] and: { (rhy = passInValue[\\rhythmStream]).notNil }).if({\n\t\t\tPseqFunc(~notes, 1, func: { |note|\n\t\t\t\t#dur, length = rhy.next(note);\n\t\t\t\tnote.copy.dur_(dur).length_(length);\n\t\t\t})\n\t\t}, { Pseq(~notes, 1) });\n\t};\n\n\t\t// all modal patterns must return modally-mapped notes\n\t\t// conversion to midinotes will be made in the note event\n\t~asPattern = #{ |passInValue|\n\t\tvar\tpat;\n\t\tpat = Pbind([\\note, \\delta], ~asNotePattern.value(passInValue)\n\t\t\t\t.collect({ |n| [n, n.dur] }));\n\t\t~mode.notNil.if({\n\t\t\tpat.patternpairs = pat.patternpairs ++\n\t\t\t\t[\\mode, ~modeSubstitution.notNil.if({ ~modeSubstitution.value }, { ~mode })];\n\t\t});\n\t\tpat\n\t};\n\n\t\t// combine a series of metrics to compare different segments\n\t\t// ~qkeys and ~qnormals should be populated in the subclass\n\t\t// usage: seg1.qualities.sum.absdif(seg2.qualities.sum) -- lower absdif, more similar\n\t~qualities = #{\n\t\t(~qkeys.collect({ |k, i| k.envirGet * ~qnormals[i] })) ? 0\n\t};\n}) => PR(\\melModeSeg);\n\nPR(\\melModeSeg).v.clone({\n\t~analyzeNotes = #{ |rawMIDI|\n\t\tvar notes, temp, tempdur;\t// temp variable for calculations\n\t\t\t// some analysis funcs in here\n\t\t\t// start with pitch material\n\n\t\ttemp = ~notes\n\t\t\t.reject({ |item| item.isSymbol or: { item.tryPerform(\\freq).isSymbol } })\n\t\t\t.collect(_.asFloat)\n\t\t\t.select({ |item| item.isNumber });\n\n\t\t~intervals = Array.new(temp.size);\n\n\t\ttemp.doAdjacentPairs({ |note1, note2, i|\n\t\t\t~intervals.add(note2 - note1)\n\t\t});\n\t\t(temp.size > 1).if({\n\t\t\t~intervals.add(~nextNote.asFloat - temp.last);\n\t\t\t~angularity = ~intervals.abs.mean / (~intervals.mean.abs.nz(1));\n\t\t}, {\n\t\t\t~angularity = 0;\t// 1 note, can't be angular\n\t\t});\n\n\t\t~hiNote = temp.maxItem;\n\t\t~loNote = temp.minItem;\n\t\t~range = ~hiNote - ~loNote;\n\t\t\t// 0 = lowest, 1 = highest for center (ratio of median to range)\n\t\t~center = (temp.copy.median - temp.minItem) / ~range.nz(1);\n\t\t~lastNote = temp.last;\n\t\t~firstNote = temp.first;\n\t\t~direction = ~lastNote - ~firstNote;\n\t\t\n\t\t\t// lots of notes shorter than their deltas will drive this metric down\n\t\t~rhythmSustain = ~notes.sum(_.length) / ~notes.sum(_.dur);\n// add repetition factor? how to compute quickly?\n\t\t\n\t\t~metric = ~qualities.value.sum;\n\t\t\n\t\tcurrentEnvironment\n\t};\n\n\t~qkeys = #[\\angularity, \\direction, \\range, \\center, \\hiNote, \\loNote];\n\t~qnormals = #[1, 1, 1, 8, 0.25, 0.25];\t// factors used for normalizing analysis values\n\n}, nil, #[\\qkeys, \\qnormals]) => PR(\\melAdaptSeg);\n\n\n// holds a single melodic segment along with its adaptations\nPR(\\abstractProcess).v.clone({\n\t~segProto = \\melAdaptSeg;\n\t~adaptable = true;\t\t// can specify some segments never to adapt\n\t\n\t~prepare = #{ |notes, nextNote, storage, parms, rawMIDI = true|\n\t\t~segs = List.with(PR(~segProto).v.copy\n\t\t\t.prepare(notes, nextNote, storage, parms, rawMIDI));\n\t\t~nextNote = nextNote;\n\t\t~mode = parms.atBackup(\\mode, storage) ? \\default;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~main = #{  ~segs[0] };\n\t\n\t~addAdapt = #{ |notes, parms, rawMIDI = false|\n\t\t\t// if there is no mode in parms, use the one given at creation\n\t\tparms[\\mode].isNil.if({ parms[\\mode] = ~mode });\n\t\t~segs.add(PR(~segProto).v.copy\n\t\t\t.prepare(notes, ~nextNote, nil, parms, rawMIDI));  // not passing in storage object\n\t\tcurrentEnvironment\n\t};\n\t\n\t~removeAt = #{ |index| ~segs.removeAt(index) \n\t};\n\t\n\t~asPattern = #{ |rhythmProfile|\n\t\t~segs.choose.asPattern(rhythmProfile)\n\t};\n\n\t~asNotePattern = #{ |rhythmProfile|\n\t\t~segs.choose.asNotePattern(rhythmProfile)\n\t};\n\t\n\t~clearAdapt = #{\n\t\t(~segs.size > 0).if({\n\t\t\t~segs = List.with(~segs[0]);\n\t\t});\n\t};\n\t\n}, nil, #[\\segProto]) => PR(\\melSegWithAdapt);\n\nPR(\\abstractProcess).v.clone({\n\t~segProto = \\melSegWithAdapt;\n\t~segFunc = \\defaultMelSegmenter;\n\t~minSegSize = 4;\n\t\n\t~prepare = #{ |notes, nextNote, rawMIDI = true,\n\t\t\tintervals, avgInterval, avgDelta, storage, parms|\n\t\tvar subsegs;\n\t\t\n\t\t~parms = parms;\t// save for adding variations\n\n\t\t\t// these are needed to analyze future input materials\n\t\t~avgInterval = avgInterval;\n\t\t~avgDelta = avgDelta;\n\n\t\tnotes = Func(parms.atBackup(\\segFunc, currentEnvironment))\n\t\t\t.doAction(notes, /*currentEnvironment,*/ nextNote, intervals, \n\t\t\t\tparms.atBackup(\\minSegSize, storage, currentEnvironment), parms);\n\n\t\tsubsegs = Array.new(notes.size);\n\t\tnotes.do({ |seg, i|\n\t\t\tsubsegs.add(PR(~segProto).v.copy.prepare(seg,\n\t\t\t\t\t// if there's a later segment, give first note of next segment\n\t\t\t\t\t// if this is the last, give first for wraparound interval\n\t\t\t\t(i < (notes.size-1)).if({ notes[i+1][0] }, { notes[0][0] }),\n\t\t\t\tstorage, parms\n\t\t\t));\n\t\t});\n\t\t~mel = subsegs;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~patternBase = #{ \n\t\tPseq(~mel, 1)\n\t};\n\t\n\t~asPattern = #{ |passInValue|\n\t\t~addAdaptCollect.value(~patternBase.value, passInValue, \\asPattern)\n\t};\n\n\t~asNotePattern = #{ |passInValue|\n\t\t~addAdaptCollect.value(~patternBase.value, passInValue, \\asNotePattern)\n\t};\n\t\n\t~addAdaptCollect = #{ |pattern, passInValue, asPatSelector = \\asPattern|\n\t\tpattern.collect(e { |seg|\n\t\t\tpassInValue[\\adaptProb].coin.if({\n\t\t\t\t~doAdapt.value(seg, passInValue);\n\t\t\t\t(seg.segs.size > passInValue[\\variantThreshold]).if({\n\t\t\t\t\t~eugenicize.value(seg, passInValue);\n\t\t\t\t});\n\t\t\t});\n\t\t\tseg.perform(asPatSelector, passInValue);\n\t\t})\n\t};\n\n\t\t// source and cross are Lists ([0] is original, [1..x] are variants)\n\t~doAdapt = #{ |source, passInValue|\n\t\tvar srcSeg, crsSeg, fitness, fitnessmean, qtemp, result, adaptTemp;\n\t\t\t// choose source segment -- if too different from original, don't adapt further\n\t\t\t// source is melSegWithAdapt\n\t\tsrcSeg = source.segs.choose;\n\t\t(~adaptMel.size > 0 and: { source.adaptable ? true }).if({\n\t\t\tcrsSeg = ~adaptMel.choose;\n\t\t\tfitness = passInValue[\\adaptStream].next(srcSeg);\n\t\t\tFunc.exists(fitness).if({\n\t\t\t\t(result = Func(fitness).doAction(srcSeg, crsSeg, passInValue)).notNil.if({\n\t\t\t\t\tsource.addAdapt(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\t~parms,\t// uses parms from creation time (no subsequent updates)\n\t\t\t\t\t\tfalse  // rawmidi should now be false\n\t\t\t\t\t);\n\t\t\t\t\t\t// it may be a bad adaptation -- kill it preemptively if so\n\t\t\t\t\tFunc(passInValue[\\eugTest])\n\t\t\t\t\t\t.doAction(source.segs[0], source.segs.last, passInValue).notNil.if({\n\t\t\t\t\t\t\tsource.removeAt(source.segs.size-1)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, {\n\t\t\t\tfitness.notNil.if({\n\t\t\t\t\tformat(\"Func(%) does not exist. No adaptation.\",\n\t\t\t\t\t\tfitness.asCompileString).warn;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~tryEugenicize = #{ |variantThreshold|\n\t\tvar\tseg;\n\t\t(seg = ~mel.select({ |seg| seg.mel.size > variantThreshold }).choose)\n\t\t\t!? { ~eugenicize.value(seg); };\n\t};\n\t\n\t\t// choose worst fit (or oldest) out of source and kill it\n\t\t// ok to have this in phrase b/c it doesn't involve adapt material\n\t~eugenicize = #{ |source, passInValue|\n\t\tvar\tfits, orig;\n\n\t\torig = source.segs[0];\n\t\tfits = Array.newClear(source.segs.size-1);\n\t\tfor(1, source.segs.size-1, { |i|\n\t\t\tfits.put(i-1, [Func(passInValue[\\eugTest])\n\t\t\t\t.doAction(orig, source.segs[i], passInValue), i]);\n\t\t});\n\t\tfits = fits.reject({ |fit| fit[0].isNil });\t// nil values are OK by test func\n\t\t\t// if any segment is left, kill the worst of them\n\t\t(fits.size > 0).if({\n\t\t\t\t// sort descending order of fit\n\t\t\tfits = fits.sort({ |a, b| a[0] > b[0] });\n\t\t\tsource.removeAt(fits[0][1])\n\t\t}, {\t\t// otherwise use age to determine which to drop\n\t\t\t\t// nature of list is that earliest items should be older\n\t\t\t\t// keep the original [0] and drop the oldest\n\t\t\tsource.removeAt(1)\n\t\t});\n\t};\n\t\n\t\t// returns flat array of original segments -- used for adaptation\n\t~asSegArray = #{  ~mel.collect({ |seg| seg.segs[0] }) };\n\t\n\t~clearAdapt = #{\n\t\t~mel.do(_.clearAdapt);\n\t\t~adaptMel = nil;\n\t};\n\n}, nil, #[\\segProto]) => PR(\\melAdaptPhrase);\n\n// container to hold a number of melodic segments\n// this maintains segments, adaptation, and holds current playback state (which seg)\n// pattern to retrieve segments will be user-definable\n// no need to hold index anymore -- if you want to change melodies,\n// save this object and pop in a new \\melodyStorage object\n\nProto({\n\t~segProto = \\melAdaptPhrase;\n\t~midiParse = true;\n\t~splitFunc = \\noSplit;\n\t~rhythmQuant = 0.25;\t// default, quantize to 16th\n\t~adaptProb = 1; //0.4;\n\t~variantThreshold = 4;\t// when more than 4 variants, drop some; see ~eugenicize\n\t~useRh = false;\n\t\n\t\t// these are keys that will be chucked into BP but need to be passed into mel\n\t\t// range is used for eug testing: NumericRange(lo, hi)\n\t~keysFromParent = #[\\mode, \\rhythmStream, \\adaptStream, \\adaptProb,\n\t\t\\variantThreshold, \\repeats, \\preSplitFunc, \\useRh, \\adTest, \\eugTest, \\splitFunc,\n\t\t\\resetSeg, \\resetPhr, \\range];\n\t\n\t~repeats = inf;\n\t~adaptPattern = \\absSplice;\t\t// this may be a pattern\n\n\t~preSplitFunc = #{ |notes| notes };\n\n\t~clearParms = { ~parms = nil; };\n\t\n\t~prepareSequence = #{ |key, buf, storage, parms|\n\t\t\t// maintain an aggregate of passed-in parameters\n\t\t~parms = (~parms ?? { () }).putAll(parms);\n\t\tkey.envirPut((key ++ \"PrepareSequence\").asSymbol.envirGet\n\t\t\t.value(buf, storage, ~parms));\n\t\tcurrentEnvironment\n\t};\n\n\t\t// generate metrics for adaptation segments\n\t~melPrepareSequence = #{ |buf, storage, parms|\n\t\tvar\tnotes, temp, intervals;\n\t\tnotes = buf.notes;\n\t\t\t// calc this for splitting the phrases into subsegments\n\t\tintervals = Array.new(notes.size - 1);\n\t\tnotes.doAdjacentPairs({ |note1, note2|\n\t\t\tintervals = intervals.add(note2 - note1);\n\t\t});\n\n\t\t~avgInterval = intervals.abs.mean;\n\t\t~avgDelta = buf.durs.mean;\t// also need note deltas\n\n\t\t\t// function composition: maybe you want to do mode or some other conversion here\n\t\ttemp = ~preSplitFunc.value(buf.notes);\n\n\t\tnotes = Func(parms.atBackup(\\splitFunc, storage, currentEnvironment).debug(\"splitfunc\"))\n\t\t\t.doAction(temp, /*currentEnvironment,*/ parms);\n\n\t\t\t// must be array now because eventually, this will be a collection of phrases\n\t\t(temp == notes).if({ notes = [notes] });\n\n\t\t\t// return value\n\t\tnotes.collect({ |phrNotes, i|\n\t\t\tPR(~segProto).v.copy.prepare(phrNotes, \n\t\t\t\t(i == (notes.size-1)).if({ notes[0][0] }, { notes[i+1][0] }), \n\t\t\t\ttrue, intervals, ~avgInterval, ~avgDelta, storage, parms)\n\t\t});\n\t};\n\n\t~adaptPrepareSequence = #{ |buf, storage, parms|\n\t\tvar temp;\n\t\t\t// adaptation should just be a set of segments, so change split type\n\t\tparms[\\splitFunc].isNil.if({\n\t\t\tparms = parms.copy.put(\\splitFunc, \\noSplit)\n\t\t});\n\t\t~melPrepareSequence.value(buf, storage, parms)\n\t\t\t.collect({ |phr, i|\n\t\t\t\tphr.mel.collect({ |seg, i| seg.main })\n\t\t\t}).flat;\n\t};\n\t\n\t~clearAdapt = #{\n\t\t~adapt = nil;\n\t\t~mel.do(_.clearAdapt);\n\t};\n\n\t\t// pattern maker needs to be modularized so you can override\n\t~makePhrPattern = #{ |passInValue|\n\t\tpassInValue = passInValue ?? { ~passInValue };\n\t\t~phrPattern = Pseq(~mel, passInValue[\\repeats] ? inf)\n\t};\n\t\n\t\t// run each melody segment successively\n\t~asSegPattern = #{ |asPatSelector, passInValue|\n\t\tpassInValue = passInValue ?? { ~passInValue };\n\t\t~makePhrPattern.value(passInValue).collect(e { |phr|\n\t\t\tphr.notNil.if({\n\t\t\t\t\t\t// populate adaptation values in phrase, to simplify API\n\t\t\t\tphr.putAll((adaptMel: ~adapt));\n\t\t\t}, {\n\t\t\t\tnil\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~asSegStream = #{ |asPatSelector, passInValue|\n\t\tpassInValue = passInValue ?? { ~passInValue };\n\t\t(~segStream.isNil or: { passInValue[\\resetPhr] ? true }).if({\n\t\t\t~segStream = CleanupStream(~asSegPattern.value(asPatSelector, passInValue)\n\t\t\t\t.asStream, e {\n\t\t\t\t\tcurrentEnvironment.put(\\segStream, nil);  // allow reset next time\n\t\t\t\t});\n\t\t});\n\t\t~segStream\n\t};\n\n}, nil, #[\\segProto]) => PR(\\melodyStorage);\n\n// subclass that plays phrases in random order\nPR(\\melodyStorage).v.clone({\n\t~makePhrPattern = #{ |passInValue|\n\t\t~phrPattern = Pxrand(~mel, passInValue[\\repeats] ? ~repeats ? inf)\n//.collect({ |val| \"\\nmelstore-phrase pattern\".postln; val.postcs })\n\t};\n}) => PR(\\melRandStorage);\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup03-chordalStorage.scd": "",
    "startup04-rhythmProfiles.scd": "\nvar saveSubType = AbstractChuckArray.defaultSubType;\n\n// rhythm profiles\n// each return value from the pattern should be of the form [delta, length]\n// rhythm is applied in PR(\\melModeSeg).v[\\asNotePattern]\n// calls to the pattern with next will be passed the SequenceNote object\nAbstractChuckArray.defaultSubType = \\rhythmProfile;\n\nPR(\\abstractProcess).v.clone({\n\t\t// getQuant calls a method\n\t~keysFromParent = #[rhythmQuant, getQuant, midiParse, rhythmProfileReset, beatsPerBar];\n\n\t~prepare = #{ |buf, passInValue, parms, melBP|\n\t\tvar \tquant = parms.atBackup(\\rhythmQuant, passInValue),\n\t\t\tbeatsPerBar = passInValue[\\beatsPerBar] ??\n\t\t\t\t{ (parms[\\quant] ?? { passInValue[\\getQuant] }).quant },\n\t\t\tneedToParse = parms.atBackup(\\midiParse, passInValue).not,\n\t\t\treset = parms.atBackup(\\rhythmProfileReset, passInValue);\n\n\t\t(needToParse ? false).if({ buf = buf.parse });  // assumes buffer has already been parsed\n\t\tbuf = buf.quantize(quant, beatsPerBar);  // simple quantize; deal w/ flexQuantize later?\n\t\t~durLen = [buf.durs, buf.lengths].flop;\n\t\tcurrentEnvironment\n\t};\n\n\t~asPattern = { \n\t\tPrand(~durLen, inf)\n\t};\n}) => PR(\\randRhythm);\n\nPR(\\randRhythm).v.clone({\n\t~prepare = #{ |buf, passInValue, parms|\n\t\tvar \tquant = parms.atBackup(\\rhythmQuant, passInValue),\n\t\t\tbeatsPerBar = passInValue[\\beatsPerBar] ??\n\t\t\t\t{ (parms[\\quant] ?? { passInValue[\\getQuant] }).quant },\n\t\t\tneedToParse = parms.atBackup(\\midiParse, passInValue).not,\n\t\t\treset = parms.atBackup(\\rhythmProfileReset, passInValue);\n\n\t\t(needToParse ? false).if({ buf = buf.parse });  // assumes buffer has already been parsed\n\t\tbuf = buf.quantize(quant, beatsPerBar);  // simple quantize; deal w/ flexQuantize later?\n\n\t\t\t// may chuck in new material without overwriting previous analyses\n\t\t(~durMarkov.isNil or: { reset ? false }).if({\n\t\t\t~durMarkov = MarkovSet.new(updateSeeds: true);\n\t\t\t~lenMarkov = MarkovSet.new(updateSeeds: true);\n\t\t});\n\n\t\t~durMarkov.parse(Pseq(buf.durs, inf), buf.size+1);\n\t\t\t// associate dur to length\n\t\tbuf.notes.do({ |note| \n\t\t\t~lenMarkov.read(note.dur, note.length)\n\t\t});\n\t\t~durStream = ~durMarkov.asStream;\n\t\tcurrentEnvironment\n\t};\n\n\t~asPattern = #{ \n\t\tvar dur;\n\t\tPfunc(e {\n\t\t\t[dur = ~durStream.next, ~lenMarkov.next(dur)]  // .debug(\"markovRhythm output\")\n\t\t})\n\t};\n\t\n}) => PR(\\markovRhythm);\n\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup10-melodic.scd": "\nvar saveSubType = AbstractChuckArray.defaultSubType;\nAbstractChuckArray.defaultSubType = \\melodyPlayer;\n\n// simple, raw-midi melody player, no adaptive functionality\nPR(\\abstractProcess).v.clone({\n\t~event = (midi: true, eventKey: \\voicerNote);\n\t~requiredKeys = #[\\sequence];\n\t~index = 0;\n\n\t\t// each sequence type is responsible for its own code to receive a sequence\n\t\t// should not mix types: if a chord sequence needs to own a melody sequence,\n\t\t// it should contain a separate object and delegate melody functions to it\n\t~acceptMIDIBuf = #{ |buf, adverb|\n\t\t~sequence = buf;\n\t\t\t// necessary because buf can change while sequence is playing\n\t\t(~index >= buf.size).if({\n\t\t\t~index = ~index % buf.size;\t// or should this just be 0?\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t~asNotePattern = #{ \n\t\t~index = 0;\n\t\t\t// Pfunc is roughly 6.7 times SLOWER than Proutine\n\t\tProutine({ |inval|\n\t\t\t{\tinval = ~sequence[~index].embedInStream(inval);  // output\n\t\t\t\t((~index = ~index+1) >= ~sequence.size).if({ ~index = 0 });\n\t\t\t}.loop;\n\t\t});\n\t};\n\t\n\t~asPattern = #{ \n\t\tPbind([\\note, \\delta], ~asNotePattern.value.collect({ |n| [n, n.dur] }));\n\t};\n}, nil, #[\\requiredKeys]) => PR(\\mel1);\n\n// melodic process that uses melAdaptSegs\nPR(\\abstractProcess).v.clone({\n\t~storageProto = \\melodyStorage;\n\t~useRh = false;\t// useRhythmProfile -- but this is a performance parm so I'm shortening it\n\t~rhythmProfileProto = nil; // \\randRhythm;\n\t~rhythmProfileReset = false;\n\t~rhythmQuant = 0.25;\t// default, quantize to 16th\n\t~event = ~event.copy.put(\\eventKey, \\voicerNote);\n\t~resetSeg = true;\t// by default, when resetting, start from the beginning\n\t~requiredKeys = #[\\mel];\n\t~adTest = \\adTest;\t\t// this is a default, can change -- currently unused\n\t~eugTest = \\dummyEugTest;\n\t~adaptProb = 1; //0.4;\n\t~variantThreshold = 4;\t// when more than 4 variants, drop some; see ~eugenicize\n\t~splitFunc = \\noSplit;\t// specify using buf.chuck(aBP, mel, (splitFunc: \\xxx))\n\t~defaultMIDIType = \\mel;\n\t\n\t~newMelFlag = false;\t// internal flag: when a new melody is given, this becomes true\n\n\t~acceptMIDIBuf = #{ |buf, adverb, parms|\n\t\tvar\tresult, temp;\n\t\tparms.isNil.if({\n\t\t\tparms = buf.tryPerform(\\properties).copy ?? { () };\n\t\t}, {\n\t\t\t(temp = buf.tryPerform(\\properties)).notNil.if({\n\t\t\t\t\t// should not overwrite parms for values already populated in parms\n\t\t\t\t\t// if properties includes a mode, this allows you to override the mode\n\t\t\t\t\t// at chuck time\n\t\t\t\tparms = temp.copy.putAll(parms);\t// is this functionally equivalent?\n\t\t\t});\n\t\t});\n\t\t\t// not entirely sure about this for splitFunc\n\t\tparms.keysValuesDo({ |k, v|\n\t\t\tv.notNil.if({ currentEnvironment.put(k, v) });\n\t\t});\n\t\t\n\t\t\t// get the proper action, either from supplied adverb or buf type\n\t\tadverb = adverb ?? { parms[\\type] ? \\mel };\n\n\t\t(adverb != \\rhythm).if({\n\t\t\tresult = (adverb ++ \"PrepareSequence\").asSymbol.envirGet\n\t\t\t\t.value(~midiParse.if({ buf = buf.parse }, { buf }), parms);\n\t\t\t\t// boy, this is an ugly workaround -\n\t\t\t\t// but without it, adaptation data were incorrectly stored in this rather than storage obj\n\t\t\t(adverb == \\mel).if({\n\t\t\t\tadverb.envirPut(result);\n\t\t\t});\n\t\t}, {\n\t\t\t~rhythm = ~rhythmPrepareSequence.value(buf, parms);\n\t\t});\t\t\t\n\n\t\t\t// populate rhythm profile if there isn't one and I'm receiving a melody\n\t\t(~rhythmProfileProto.notNil and: ~rhythm.isNil and: (adverb == \\mel)).if({\n\t\t\t~rhythm = ~rhythmPrepareSequence.value(buf, parms);\n\t\t});\n\t\t\n\t\tcurrentEnvironment\n\t};\n\t\n\t\t// should always return a new mel object, but should keep adapt (and other stuff?)\n\t\t// why always a new object? -- to save mel and reuse it\n\t~melPrepareSequence = #{ |buf, parms|\n\t\tvar\tsaveMel = ~mel;\n\t\t(~mel = PR(~storageProto).v.copy)\n\t\t\t.prepareSequence(\\mel, buf, currentEnvironment, parms);\n\t\tsaveMel.tryPerform(\\adapt).notNil.if({\n\t\t\t~mel[\\adapt] = saveMel[\\adapt];\n\t\t});\n\t\t~passInValue !? { ~mel[\\passInValue] = ~passInValue };\n\t\t~newMelFlag = true;\n\t\t~mel\n\t};\n\t\n\t\t// add adaptation data to current melody if it exists\n\t~adaptPrepareSequence = #{ |buf, parms|\n\t\t~mel.isNil.if({\n\t\t\t~mel = PR(~storageProto).v.copy;\n\t\t});\n\t\t~mel.prepareSequence(\\adapt, buf, currentEnvironment, parms);\n\t};\n\t\n\t~rhythmPrepareSequence = #{ |buf, parms|\n\t\t\t// create a new rhythm profiler only if needed\n\t\t(~rhythm ?? { PR(~rhythmProfileProto).v.copy })\n\t\t\t.prepare(buf, ~getPassInValue.(PR(~rhythmProfileProto).v.keysFromParent, false),\n\t\t\t\tparms, currentEnvironment)\n\t};\n\t\n\t~dumpSegments = { \n\t\t~mel.mel.do({ |phr, i|\n\t\t\t\"Phrase %\\n\".postf(i);\n\t\t\tphr.mel.do({ |seg, j|\n\t\t\t\t\"\\tSegment %\\n\".postf(j);\n\t\t\t\tseg.segs.do({ |adapt, k|\n\t\t\t\t\t\"\\t\\tAdaptation %\\n\".postf(k);\n\t\t\t\t\tadapt.notes.do({ |note|\n\t\t\t\t\t\t\"\\t\\t%\\n\".postf(note.asCompileString);\n\t\t\t\t\t});\n\t\t\t\t\t$\\n.post;\n\t\t\t\t});\n\t\t\t\t$\\n.post;\n\t\t\t});\n\t\t\t$\\n.post;\n\t\t\t$\\n.post;\n\t\t});\n\t};\t\t\t\t\n\t\n// potential problem: do some numeric parms belong to melodyStorage?\n// yes: repeats, adaptProb, eugenicizeProb, variantThreshold, rhythmQuant\n\t~bindSimpleNumber = #{ |num, adverb|\n\t\tadverb.envirPut(num);\n\t};\n\t\n\t~clearAdapt = #{\n\t\t~mel.clearAdapt;\n\t};\n\n\t~getMode = #{  ~mode ? \\default };\n\t~mode_ = #{ |mode|\n\t\tmode = mode.tryPerform(\\collIndex) ? mode ? \\default;  // pass a symbol in as the mode\n\t\tcurrentEnvironment.put(\\mode, mode);\n\t\t~mel !? { ~mel.mode = mode };\n\t\t~event.put(\\mode, ~mode.value);\n\t\tcurrentEnvironment\n\t};\n\t\n// function test breaks the possibility of passing a function as such\n\t~getPassInValue = #{ |keys, save = false|\n\t\tvar\tout;\n\t\tout = ();\n\t\tkeys.do({ |key|\n\t\t\tout.put(key, key.envirGet.isFunction.if({ key.envirGet.value }, { key.envirGet }));\n\t\t});\n\t\t(save ? false).if({ ~passInValue = out; });\n\t\tout\n\t};\n\t\n\t~asPattern = #{ \n\t\tvar rhythm;\n\t\t~event.put(\\mode, ~mode.value);  // ensure event knows its mode\n\t\t~rhythmStream = ~rhythm.asPattern.asStream;\n\t\t\t// need to pass in repeats among other parms\n\t\t\t// true = save the passinvalue in the main BP environment\n\t\t~mel.asSegStream(\\asPattern, ~getPassInValue.(~mel.keysFromParent, true));\n\t\t~newMelFlag = false;\n\t\tPrt({ |inval|\n\t\t\tvar phrase, phraseStream, seg, rhy;\n\t\t\t\t// try to get phrase; if nil, is this a new melody object?\n\t\t\t{ ((phrase = ~mel[\\segStream].next).isNil and: { ~newMelFlag }).if({\n\t\t\t\t\t\t// new melody object -- make the phrase stream\n\t\t\t\t\t~mel.asSegStream(\\asPattern,\n\t\t\t\t\t\t~getPassInValue.(~mel.keysFromParent, true));\n\t\t\t\t\t~newMelFlag = false;\n\t\t\t\t\tphrase = ~mel[\\segStream].next;\n\t\t\t\t});\n\t\t\t\tphrase.notNil  // if that fails, nothing to do\n\t\t\t}.while({\n\t\t\t\tphraseStream = phrase  //.asStream(~getPassInValue.value);\n\t\t\t\t\t.perform(\\asPattern,\n\t\t\t\t\t\t~getPassInValue.(~mel[\\keysFromParent])).asStream;\n\t\t\t\t{ (seg = phraseStream.next).notNil }.while({\n\t\t\t\t\tinval = seg.embedInStream(inval)\n\t\t\t\t});\n\t\t\t\t\t// stick in rest if available\n\t\t\t\t\t// passing in currentEnvironment so pattern can get clock\n\t\t\t\t\t// passing in phr because (sometime) phrase will contain metric alignment\n\t\t\t\t\t// last bit is not implemented now\n\t\t\t\t(rhy = ~macroStream.next(phrase)).notNil.if({\n\t\t\t\t\t(type: \\rest, delta: rhy).yield\n\t\t\t\t});\n\t\t\t});\n\t\t})\n\t\t.collect(e { |ev|\t// apply extra synth args, if available\n\t\t\t~argsStream.notNil.if({\n\t\t\t\t~argsStream.next(ev).put(\\argKeys, ~argKeys)\n\t\t\t}, { ev })\n\t\t})\n\t};\n\n// asNotePattern MIGHT BE BROKEN, pretty much deprecated\n\n\t~asNotePattern = #{ \n\t\t~mel.asSegStream(\\asNotePattern);\n\t\t~newMelFlag = false;\n\t\tPrt({ |inval|\n\t\t\tvar phrase, phraseStream, seg;\n\t\t\t{ ((phrase = ~mel[\\segStream].next).isNil and: { ~newMelFlag }).if({\n\t\t\t\t\t\t// new melody object -- make the phrase stream\n\t\t\t\t\t~mel.asSegStream(\\asPattern/*, ~rhythmStream*/);\n\t\t\t\t\t~newMelFlag = false;\n\t\t\t\t\tphrase = ~mel[\\segStream].next;\n\t\t\t\t});\n\t\t\t\tphrase.notNil  // if that fails, nothing to do\n\t\t\t}.while({\n\t\t\t\tphraseStream = phrase\n\t\t\t\t\t.perform(\\asNotePattern, ~getPassInValue.value)\n\t\t\t\t\t.asStream;\n\t\t\t\t{ (seg = phraseStream.next).notNil }.while({\n\t\t\t\t\tseg.embedInStream(inval)\n\t\t\t\t});\n\t\t\t});\n\t\t})\n\t};\t\t\n\n\t~bindPatDefault = \\adapt;\n}) => PR(\\aiMel);\n\nPR(\\aiMel).v.clone({\n\t~event = ~event.copy.put(\\eventKey, \\synthNote);\n}) => PR(\\aiMelSynth);\n\nPR(\\aiMel).v.clone({\n\t~storageProto = \\melRandStorage;\n}, nil, #[\\storageProto]) => PR(\\aiMelRand);\n\nPR(\\aiMel).v.clone({\n\t\t// rename some methods (effectively, to allow super.asPattern)\n\t~asBasePattern = ~asPattern;\n\t~asBaseNotePattern = ~asNotePattern;\n\n\t\t// defaults\n\t~bassID = \\currentBassNote;\n\t~bassIDStream = \\currentBassNote;\n\n\t\t// ProtoEvent(\\voicerNote) issues the dependency notification\n\t~asPattern = #{ \n\t\t~asBasePattern.value\n\t\t\t.collect(e { |ev| ev.put(\\bassID, ~bassIDStream.next(ev)) });\n\t};\n}) => PR(\\aiBass);\n\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup11-chordal.scd": "\nvar saveSubType = AbstractChuckArray.defaultSubType;\nAbstractChuckArray.defaultSubType = \\chordStorage;\n\n// chord processes\n\n// chord segment\n// no modal stuff, just raw midi notes\nPR(\\abstractProcess).v.clone({\n\t~prepare = #{ |notes, modeOverride|\n\t\t\t// notes should be in the format [note, note, note]\n\t\t\t// but they might come in as [SeqChordNote(..., [....]), ...]\n\t\t~modeOverride = modeOverride;\n\t\t~notes = notes.asArray.collect({ |n| n.asNoteArray }).flat;\n\t\tcurrentEnvironment\n\t};\n\t\n\t\t// subclasses will use keys in inEvent to adapt to topnote, etc.\n\t~asPattern = #{ |inEvent|\n\t\tArpegPat(inEvent[\\arpegType]).asPattern(~notes, inEvent)\n\t};\n}) => PR(\\basicChordSeg);\n\n// modal chord segment that adapts itcurrentEnvironment to bass and topnote\n\n// fitnesses of chord notes, assuming root is 0\n// you can set this in a chordsegment instance to override.\n// To change the default, put something else in the library.\n\nLibrary.put(\\fitFactors, Dictionary[\n\t0 -> 10,\n\t1.0 -> 6,  // 2nd\n\t2.0 -> 10, // 3rd -- note, privileging triadic notes\n\t3.0 -> 4,\n\t4.0 -> 10,\n\t5.0 -> -10,\t// 6th degree makes chord root perception ambiguous; thus, it's punished\n\t6.0 -> 3,\n\t0.5 -> -5,\t// non-diatonic notes\n\t1.5 -> -5,\n\t2.5 -> -5,\n\t3.5 -> 3,\t\t// #4 or b5 OK\n\t4.5 -> -1,\t// not preferred, but not completely evil either\n\t5.5 -> 0,\t\t// b7 neutral\n\t6.5 -> 0,\t\t// #7 neutral\n]);\n\nPR(\\abstractModeSeg).v.clone({\n\t\t// by default, use the mode of the calling event\n\t\t// set to true to force the notes to play back using the mode analyzed here\n\t~useOwnMode = false;\n\t~prepare = #{ |notes, mode, rawMIDI = true, parms|\n\t\t\t// notes should be in the format [note, note, note]\n\t\t~rawNotes = ~notes = notes.asArray;\n\t\t~rawMIDI = rawMIDI ? true;\n\t\t~rawMIDI.if({ ~mapToMode.value(mode) });\n\t\t~analyzeNotes.value(~rawMIDI);\t// collect stats on chord -- user definable\n\t\t~useOwnMode = parms.atBackup(\\useOwnMode, currentEnvironment);\n\t\tcurrentEnvironment\n\t};\n\t\n\t~mapToMode = #{ |mode|\n\t\tvar\tbestMode, bestFit = -1e10, bestMap, modeFit, notesTemp, modeObj;\n\t\t\t// is it a single mode, or a mode pool?\n\t\tmode = mode ? \\default;\n\t\tmodeObj = mode.asMode.value;\n\t\tif(modeObj.size > 0) {\n\t\t\tmodeObj.do({ |mode, i|\n\t\t\t\tnotesTemp = ~rawNotes.mapMode(mode);\n\t\t\t\t((modeFit = Func(\\chModeFit).doAction(notesTemp)) > bestFit).if({\n\t\t\t\t\tbestMode = mode;\n\t\t\t\t\tbestFit = modeFit;\n\t\t\t\t\tbestMap = notesTemp;\n\t\t\t\t});\n\t\t\t});\n\t\t\t~mode = bestMode;\n\t\t\t~notes = bestMap;\n\t\t}{\n\t\t\t~notes = ~notes.mapMode(mode);\n\t\t\t~mode = mode;\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\t\n\t~mapToMIDI = #{ |mode|\n\t\t~notes = ~notes.unmapMode(mode);\n\t\tcurrentEnvironment\n\t};\n\t\n\t~analyzeNotes = #{ \n\t\t~hiNote = ~notes.maxItem;\n\t\t~loNote = ~notes.minItem;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~modeForEvent = { |ev|\n\t\t~modeOverride ?? { ~useOwnMode.if({ ~mode }, { ev[\\mode] }) };\n\t};\n\t\n\t~modeOverride_ = { |mode|\n\t\t(mode !== ~modeOverride).if({\n\t\t\t~modeOverride = mode;\n\t\t\t~mapToMode.(mode ? ~mode);\n\t\t});\n\t};\n\n\t~getFit = #{ ~fitFactors ? Library.at(\\fitFactors); };\n\n\t~asPattern = #{ |inEvent, fitFunc|\n\t\tvar result = Func(fitFunc).doAction(currentEnvironment, inEvent,\n\t\t\tinEvent[\\fitnessOverride] ?? { ~getFit.value });\n\t\tresult.notNil.if({\n\t\t\t~lastFitNotes = result;\n\t\t\tArpegPat(inEvent[\\arpegType]).asPattern(result, inEvent)\n\t\t}, {\n\t\t\tError(\"Fatal error arpeggiating chord: Func(%) returned nil.\"\n\t\t\t\t.format(fitFunc.asCompileString)).throw\n\t\t});\n\t};\n}) => PR(\\chordModeSeg);\n\n// for more flexible analysis: user provides a \"modepool\" (array of ModalSpecs)\n// each individual chord tries each option and chooses the one that fits best\n// allows sensible chromatic inflections of minor modes, for instance\n\n// deprecated -- chordModeSeg handles this on its own\n// stub retained for backward compatibility\n\nPR(\\chordModeSeg).v.clone(nil) => PR(\\chordModePoolSeg);\n\n// first, basic arpeggiator (child process)\n\nAbstractChuckArray.defaultSubType = \\chordChildProc;\n\nPR(\\abstractProcess).v.clone({\n\t\t// give keys for prototypes\n\t~chordProto = \\chordModeSeg;\n\t~mode = \\default;\n\t\n\t~event = (eventKey: \\voicerNote);\n\t\n\t~preparePlay = #{ \n\t\t~chordStream = ~chordStream ?? { ~makeChordPattern.value.asStream };\n\t\tcurrentEnvironment\n\t};\n\t\n\t~reset = #{ \n\t\t~chordStream = nil;\n\t\t~preparePlay.value;\t// should return currentEnvironment\n\t};\n\n\t~getFit = #{ ~fitFactors ? Library.at(\\fitFactors); };\n\n\t~makeChordPattern = #{ Pseq(~chords, inf) };\n\t~makeChordPattern_ = { |func|\n\t\t~makeChordPattern = func;\n\t\t~reset.value;\n\t\tcurrentEnvironment\n\t};\n\n\t\t// you can change fitToBassAndTop behavior by changing this symbol\n\t\t// funcs are defined in Func()\n\t\t// this may also be a function, which is passed the chord Proto\n\t\t// ~fitFunc = { |chordProto| ... return fitFunc symbol ... };\n\t~fitFunc = \\asis;\n\n// what if this is in response to a bass note (no inEvent)? address in subclass\n// update method should modify the value of ~noteStream without updating anything else\n\t~nextNotePattern = #{ |inEvent|\n\t\t\t// if there is an event, we need to move to the next chord\n\t\t(inEvent.size > 0).if({\n\t\t\t~currentChord = ~chordStream.next(inEvent);\n\t\t});\n\t};\n\t\n\t~updateNoteStream = #{ |inEvent, bassID|\n\t\tbassID !? { inEvent.put(\\bassID, bassID) };\n\t\t~noteStream = (~notePattern = ~currentChord.asPattern(inEvent, ~fitFunc.value(~currentChord)))\n\t\t\t.asStream;\n\t};\n\t\n\t~updateBass = #{ |lastEvent, bassID|\n\t\t\t// maybe you don't want the process to update every bass note\n\t\t(lastEvent.tryPerform(\\at, \\updateOnBass) ? true).if({\n\t\t\t~updateNoteStream.value(lastEvent, bassID)\n\t\t});\n\t};\n\t\n\t~nextNoteStream = #{ |inEvent|\n\t\t~nextNotePattern.value(inEvent);\n\t\t~updateNoteStream.value(inEvent);\n\t\tPrt({ |event|\n\t\t\t{ event = ~noteStream.next(event).yield }.loop\n\t\t});\n\t};\n\n\t~asPattern = #{ |inEvent|\n\t\tvar\tout, argPairs;\n\t\tif(~fitFactors.notNil) {\n\t\t\tinEvent = inEvent.copy.put(\\fitnessOverride, ~fitFactors);\n\t\t};\n\t\tout = Pbind(\n\t\t\t\\note, inEvent[\\chNotes].isNil.if({\n\t\t\t\t(~chords.size == 0).if({\n\t\t\t\t\tError(\"Cannot play -- no chords have been provided to arpeg process\").throw;\n\t\t\t\t}, {\n\t\t\t\t\t~nextNoteStream.value(inEvent)\n\t\t\t\t});\n\t\t\t}, {\n\t\t\t\t\t// fall back for midi input\n\t\t\t\tout = (notes:~notes);\n\t\t\t\tArpegPat(inEvent[\\arpegType]).asPattern(\n\t\t\t\t\tFunc(~fitFunc.value(out)).doAction(out, inEvent, ~getFit.value),\n\t\t\t\t\tinEvent)\n\t\t\t}),\n\t\t\t#[\\dur, \\length, \\gate], MicRh(inEvent[\\microRhythm])\n\t\t\t\t.asPattern(~notePattern, inEvent),\n\t\t\t\\mode, (Pfunc({\n\t\t\t\t~currentChord.modeForEvent(inEvent)\n\t\t\t}))\n\t\t);\n\t\t\t// note, argpairs will reset every chord -- is that a good idea?\n\t\targPairs = ~argPairs.(inEvent);\t\t// if simple array, this will have no effect\n\t\t(argPairs.size > 0).if({\n\t\t\tout = Pbindf(out, \\argKeys, argPairs[0, 2..], *argPairs)\n\t\t});\n\t\tout\n\t};\n\t\n\t~acceptMIDIBuf = #{ |buf, adverb, parms|\n\t\t~chords = ~prepareSequence.value(buf, parms);\n\t\t~chordStream = ~makeChordPattern.value.asStream;   // reset the chord stream\n\t};\n\t\n\t~prepareSequence = #{ |buf, parms|\n\t\tvar \tnotes, avgDur;\n\t\t\t// why I'm using a parms dictionary: grab more parameters without changing method args\n\t\tparms.tryPerform(\\at, \\fitFunc).notNil.if({ ~fitFunc = parms[\\fitFunc] });\n\t\t\t// partition on rhythm - in general, notes belonging to the same chord will have\n\t\t\t// a duration less than the mean\n\t\tavgDur = buf.durs.mean;\n\t\t\t// if note is a SeqChordNote, it's a chord unto itself\n\t\t\t// otherwise, use average duration to determine when to break\n\t\t\t// should be possible to play slowly arpeggiated chords with some gracenotes\n\t\t\t// and have them preserved\n\t\tnotes = buf.notes.separate({ |a, b| a.isChord or: { a.dur > avgDur } });\n\t\t\t// now make a chord object for each set of notes - this is function output\n\t\tnotes.collect({ |ch|\n\t\t\t\t// true = unmap notes to mode\n\t\t\tPR(~chordProto).v.copy.prepare(ch.asNoteArray,\n\t\t\t\tparms.atBackup(\\mode, buf.properties, currentEnvironment),\n\t\t\t\tparms.tryPerform(\\at, \\rawMIDI) ? true, parms)\n\t\t})\n\t};\n}, nil, #[\\chordProto]) => PR(\\arpeg1);\n\n// behaves the same as \\arpeg1 but uses the synthNote event instead of voicerNote\nPR(\\arpeg1).v.clone({\n\t~event = ~event.copy.put(\\eventKey, \\synthNote);\n}) => PR(\\arpegSynth);\n\n// uses modepool\nPR(\\arpeg1).v.clone({\n\t~chordProto = \\chordModePoolSeg;\n}, nil, #[\\chordProto]) => PR(\\arpeg2);\n\nPR(\\arpegSynth).v.clone({\n\t~chordProto = \\chordModePoolSeg;\n}, nil, #[\\chordProto]) => PR(\\arpeg2Synth);\n\n// macrorhythm process - no topnote\n\nAbstractChuckArray.defaultSubType = \\chordPlayer;\n\nPR(\\abstractProcess).v.clone({\n\t~canWrap = true;\n\t~respondsToBass = false;\n\t~updaters = ();\t\t// see ~update below -- for user-extensible notifications\n\n\t~acceptMIDIBuf = #{ |buf, adverb, parms|\n\t\t(#[\\ch, nil].includes(adverb)).if({\n\t\t\t\t// true == rawMIDI\n\t\t\t~child.acceptMIDIBuf(buf, adverb, parms);\n\t\t}, {\n\t\t\t\"This process does not accept a melody sequence.\".warn;\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t~update = #{ |obj, changer ... args|\n\t\tif(~updaters.tryPerform(\\at, changer).notNil) {\n\t\t\t~updaters[changer].value(obj, changer, *args)\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\n\t~updateBassID = { |obj, changer|\n\t\t(~isPlaying and: { changer == ~bassID and: { ~lastEvent.notNil } })\n\t\t.if({\n\t\t\t~child.updateBass(~lastEvent, changer);\n\t\t});\n\t};\n\t\n\t~bassID_ = { |bassID|\n\t\tif(~updaters.tryPerform(\\at, ~bassID).notNil) {\n\t\t\t~updaters.removeAt(~bassID);\n\t\t};\n\t\t~bassID = bassID;\n\t\tif(bassID.notNil) {\n\t\t\t~updaters[bassID] = ~updateBassID;\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\t\n\t~bindSimpleNumber = #{ |num, adverb|\n\t\tadverb.envirPut(num);\n\t};\n\t\n\t~makeStreamForKey = #{ |key, streamKey, envir|\n\t\tvar\tstream = key.envirGet;\n\t\tenvir.notNil.if({\n\t\t\tstream = envir.use({ stream = stream.asStream });\n\t\t}, {\n\t\t\tstream = stream.asStream\n\t\t});\n\t\t\t// output, and stream gets replaced so that playing stream picks it up:\n\t\t(streamKey = streamKey ?? { key ++ \"Stream\" }).asSymbol.envirPut(stream)\n\t};\n\n\t\t// to allow streams to be changed behind the scenes\n\t~makeProut = #{ |key, protoEvent, envir|\n\t\tvar\tstreamKey;\n\t\t\t// create stream if it doesn't exist\n\t\t~makeStreamForKey.value(key, streamKey = (key ++ \"Stream\").asSymbol, envir);\n\t\t\t// if a protoevent is supplied, use it in next()\n\t\t\t// that's for topNote (not in this process, but subclasses)\n\t\t\t// otherwise use the event passed at evaluation time\n\t\tprotoEvent.notNil.if({\n\t\t\tPrt({\n\t\t\t\t{ streamKey.envirGet.next(protoEvent).yield }.loop\n\t\t\t});\n\t\t}, {\n\t\t\tPrt({ |inEvent|\n\t\t\t\t{ inEvent = streamKey.envirGet.next(inEvent).yield }.loop\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~preparePlay = #{ \n\t\t~child.tryPerform(\\preparePlay);\n\t\tcurrentEnvironment\n\t};\n\t~reset = #{ \n\t\t~child.reset;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~event = (eventKey: \\macroRh);\n\n\t~requiredKeys = #[\\macro, \\micro, \\arpeg];\n\t~rewrapKeys = ~requiredKeys;\n\t\n\t~asPattern = #{ |inEvent|\n\t\tvar\tout;\n\t\t\t// if length is nil, it picks up delta; sim. for arpegType\n\t\tPbindMultiChan(#[\\delta, \\length], ~makeProut.value(\\macro),\n\t\t\t#[\\microRhythm, \\arpegType], Ptuple([\n\t\t\t\t~makeProut.value(\\micro),\n\t\t\t\t~makeProut.value(\\arpeg)], inf))\n\t\t.collect(e { |ev| currentEnvironment.put(\\lastEvent, ev); ev });\n\t\t(~argPairs.size > 0).if({\n\t\t\tPbindf(out, \\argKeys, ~argPairs[0, 2..], * ~argPairs)\n\t\t}, { out });\n\t};\n\t\n}, nil, #[\\rewrapKeys, \\requiredKeys]) => PR(\\basicMacroRh);\n\n\t// macrorhythm with topnote and bass\nPR(\\basicMacroRh).v.clone({\n\t~melodyProto = \\aiMel;\n\t~respondsToBass = true;\n\t~bassUpdate = true;\n\n\t~acceptMIDIBuf = #{ |buf, adverb, parms|\n\t\tvar\tparmsplus;\n\t\t\t// buffer properties are base parms; can override with chuck parms\n\t\tbuf.properties.respondsTo(\\putAll).if({\n\t\t\tparmsplus = buf.properties.copy.tryPerform(\\putAll, parms ?? { () });\n\t\t}, {\n\t\t\tparmsplus = parms;\n\t\t});\n\t\tadverb = adverb ?? { parmsplus.tryPerform(\\at, \\type) ? \\ch };\n\t\tcase { adverb.isNil or: (adverb == \\ch) }\n\t\t\t\t{ ~child.acceptMIDIBuf(buf, adverb, parmsplus) }\n\t\t\t{ #[\\mel, \\adapt].includes(adverb) }\n\t\t\t\t{\t~topNote.isNil.if({ ~topNote = PR(~melodyProto).v.copy });\n\t\t\t\t\t~topNote.mode = parms.atBackup(\\mode, currentEnvironment);\n\t\t\t\t\t~topNote.acceptMIDIBuf(buf, adverb, parmsplus)\n\t\t\t\t}\n\t\t\t{ \"Invalid adverb.\".warn; };\n\t\tcurrentEnvironment\n\t};\n\n\t~bindPattern = #{ |pattern, adverb|\n\t\tcase { adverb == \\adapt } { ~topNote.notNil.if({ ~topNote.bindPattern(pattern, adverb) }) }\n\t\t\t{\tadverb.envirPut(pattern.asPattern);\n\t\t\t\t~makeStreamForKey.value(adverb);\n\t\t\t};\n\t\tcurrentEnvironment\t\t// return\n\t};\n\t\n\t~getMode = PR(\\aiMel).v[\\getMode];\n\t~mode_ = #{ |mode|\n\t\tmode = mode.tryPerform(\\collIndex) ? mode ? \\default;  // pass a symbol in as the mode\n\t\t~child !? { ~child.mode = mode };\n\t\tcurrentEnvironment.put(\\mode, mode);\n\t};\n\t\n\t~rewrapKeys = ~requiredKeys ++ [\\topNote];\n\t\n\t~clearAdapt = #{ ~topNote.clearAdapt };\n\n\t\t// more modularization\n\t\t// sans top is to allow MIDI input when top melody is not already given\n\t~patternSansTop = #{\n\t\tPbindMultiChan(#[\\delta, \\length], ~makeProut.value(\\macro),\n\t\t\t\\arpegType, ~makeProut.value(\\arpeg),\n\t\t\t\\microRhythm,\t~makeProut.value(\\micro),\n\t\t\t\\bassID, Pfunc({ ~bassID ? \\currentBassNote }),\n\t\t\t\\updateOnBass, Pfunc({ ~bassUpdate }),\n\t\t\t\\convertTopFunc, Pfunc({ ~convertTopFunc ? \\convertMode }),\n\t\t\t\\mode, Pfunc({ ~getMode.value }))\n\t\t.collect(e { |ev| currentEnvironment.put(\\lastEvent, ev); ev });\n\t};\n\t\n\t~patternAvecTop = #{\n\t\t~topNotePattern = ~topNote.asPattern;\n\t\tPbindMultiChan(#[\\delta, \\length], ~makeProut.value(\\macro),\n\t\t\t\\arpegType, ~makeProut.value(\\arpeg),\n\t\t\t\\microRhythm,\t~makeProut.value(\\micro),\n\t\t\t\\top, ~makeProut.value(\\topNotePattern, ~topNote[\\event], ~topNote),\n\t\t\t\\bassID, Pfunc({ ~bassID ? \\currentBassNote }),\n\t\t\t\\updateOnBass, Pfunc({ ~bassUpdate }),\n\t\t\t\\convertTopFunc, Pfunc({ ~convertTopFunc ? \\convertMode }),\n\t\t\t\\mode, Pfunc({ ~getMode.value }))\n\t\t.collect(e { |ev|\n\t\t\t~lastEvent = ev;\n\t\t\tev\n\t\t});\n\t};\n\n\t~asPattern = #{\n\t\tvar\tout;\n\t\t\t// topNote may be supplied by MIDI; in that case, don't include in Pbind\n\t\t~topNote.isNil.if({\n\t\t\tout = ~patternSansTop.value\n\t\t}, {\n\t\t\tout = ~patternAvecTop.value\n\t\t});\n\t\t(~argPairs.size > 0).if({\n\t\t\t\t// ~argPairs[0, 2..] gets every even index (e.g. symbolic keys)\n\t\t\tPbindf(out, \\argKeys, ~argPairs[0, 2..], * ~argPairs)\n\t\t}, { out })\n\t};\n\t\n}, nil, #[\\rewrapKeys, \\requiredKeys]) => PR(\\macroRh);\n\nPR(\\macroRh).v.clone({\n\t~requiredKeys = ~requiredKeys.copy;\n\t~requiredKeys.remove(\\macro);\n\t~patternSansTop = #{\n\t\tPbindMultiChan(#[\\delta, \\length], [0.1, inf],\t// for midi input, we don't know the length yet\n\t\t\t\\arpegType, ~makeProut.value(\\arpeg),\n\t\t\t\\microRhythm,\t~makeProut.value(\\micro),\n\t\t\t\\bassID, Pfunc({ ~bassID ? \\currentBassNote }),\n\t\t\t\\updateOnBass, Pfunc({ ~bassUpdate }),\n\t\t\t\\convertTopFunc, Pfunc({ ~convertTopFunc ? \\convertMode }),\n\t\t\t\\mode, Pfunc({ ~getMode.value }))\n\t\t.collect(e { |ev| currentEnvironment.put(\\lastEvent, ev); ev });\n\t};\n\t\n\t~patternAvecTop = #{\n\t\t~topNotePattern = ~topNote.asPattern;\n\t\tPbindMultiChan(\n\t\t\t#[\\top, \\delta, \\length], ~makeProut.value(\\topNotePattern,\n\t\t\t\t~topNote[\\event], ~topNote)\n\t\t\t\t.collect({ |ev|\t// from topEvent, make an array with delta and length\n\t\t\t\t\t[ev, ev[\\delta], ev[\\length] ?? { ev[\\note].length }]\n\t\t\t\t}),\n\t\t\t\\arpegType, ~makeProut.value(\\arpeg),\n\t\t\t\\microRhythm,\t~makeProut.value(\\micro),\n\t\t\t\\bassID, Pfunc({ ~bassID ? \\currentBassNote }),\n\t\t\t\\updateOnBass, Pfunc({ ~bassUpdate }),\n\t\t\t\\convertTopFunc, Pfunc({ ~convertTopFunc ? \\convertMode }),\n\t\t\t\\mode, Pfunc({ ~getMode.value }))\n\t\t.collect(e { |ev| currentEnvironment.put(\\lastEvent, ev); ev });\n\t};\t\t\t\n}) => PR(\\chTop);\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup12-MIDIInput.scd": "// this guy interrupts a playing stream to allow midi input\nvar saveSubType = AbstractChuckArray.defaultSubType;\nAbstractChuckArray.defaultSubType = \\midiInputWrapper;\n\nPR(\\abstractProcess).v.clone({\n\t\t// if true, using this as a wrapper will stop the child immediately\n\t\t// really what you want it to do is wait for the first MIDI event before overriding\n\t~event = (eventKey: \\dummy);\n\t~doReplay = false;\n\t~canWrap = true;\n\t~replayTimeSpec = BasicTimeSpec(1);\n\t~parseBuf = true;\n\n\t~postRecFunc = #{ |buf, process|\n\t\t(buf.properties.tryPerform(\\at, \\parse) ? ~parseBuf).if({ buf = buf.parse; });\n\t\t\t// output:\n\t\tbuf.hasQuantizeProperties.if({ buf.quantize },\n\t\t\t{ buf });\n\t};\n}) => PR(\\abstractMIDIInput);\n\nPR(\\abstractMIDIInput).v.clone({\n\t~defaultMIDIType = \\mel;\n\t~preparePlay = #{\n\t\t~midiNotesOn = IdentitySet.new;\n\t};\n\t~getMIDIParser = #{ |socket|\n\t\t~parser = MelodyParser(nil, currentEnvironment, socket, ~child.clock)\n\t};\n\n\t~midiCleanup = #{ \n\t\tvar\tbp = BP(~collIndex), buf, quant;\n\t\tbp.unwrap(false);\n\t\t\t// insert your own processing here -- parsing, quantization\n\t\tbuf = ~postRecFunc.value(~parser.recSocket.buf, bp);\n\t\tbp.bindMIDIRecBuf(buf, ~defaultMIDIType);\n\t\tquant = ~replayTimeSpec.asTimeSpec;\n\t\tbp.clock.schedAbs(\n\t\t\tquant.adjustTimeForLatency(quant.nextTimeOnGrid(bp.clock), bp.leadTime, bp.clock) - 0.05,\n\t\t\t{ bp.stopNow });\n\t\t(~doReplay ? false).if({\n\t\t\tbp.clock.schedAbs(quant.adjustTimeForLatency(quant.nextTimeOnGrid(bp.clock),\n\t\t\t\t\tbp.leadTime, bp.clock), {\n\t\t\t\tbp.play(NilTimeSpec.new, doReset:true);\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~melNoteOn = #{ |note|\n\t\t~child.eventStreamPlayer.stop;\n\t\t\t// save this note -- when a note is released, this goes into that event\n\t\t\t// so that event can check for overlapping notes\n\t\t~midiNotesOn.add(note.asFloat);\n\t\t~lastMIDINoteOn = note.asFloat;\n\t\t\t// let child process determine how to handle the note\n\t\t\t// by setting length to nil, we tell child process the note will be terminated later\n\t\t~preparePlayEvent.value(note);\n\t};\n\n\t~preparePlayEvent = #{ |note|\n\t\t~child.event.copy.put(\\note, note.copy.length_(nil))\n\t\t\t.put(\\midi, true)\n\t\t\t.put(\\immediateOSC, true)\n\t\t\t.play;\n\t};\n\t\t// should be able to receive an array of notes\n\t~melNoteOff = #{ |note|\n\t\t~midiNotesOn.remove(note.asFloat);\n\t\t~child.event.copy\n\t\t\t.put(\\note, note)\n\t\t\t.put(\\immediateOSC, true)\n\t\t\t.use({ ~releaseNote.value; });\n\t};\n}, nil, #[\\defaultMIDIType]) => PR(\\melMIDI);\n\nPR(\\melMIDI).v.clone({\n\t~defaultMIDIType = \\adapt;\n}, nil, #[\\defaultMIDIType]) => PR(\\adaptMIDI);\n\nPR(\\abstractMIDIInput).v.clone({\n\t~defaultMIDIType = \\ch;\n\t~preparePlay = #{  currentEnvironment };\n\t~getMIDIParser = #{ |socket|\n\t\t~parser = ChordParser(nil, currentEnvironment, socket, ~child.clock,\n\t\t\t~deltaThresh ? 0.1, ~lengthThresh ? 0.1)\n\t};\n\t~chordNoteOn = #{ |note|\n\t\t~child.eventStreamPlayer.notNil.if({\n\t\t\tBP(~collIndex).stopNow;\n\t\t});\n\t\t\t// let child process determine how to handle the note\n\n\t\t\t// get additional parameters from child (wrapper) process\n\t\t\t// this assumes child is already playing\n\t\t~preparePlayEvent.value(note);\n\t};\n\t~preparePlayEvent = #{ |note|\n\t\t~child.eventStream.next(~child.event.copy)\n\t\t\t.put(\\chNotes, note.mapMode(~child.mode))\n\t\t\t.put(\\length, inf)\t\t// child should not cut off on its own\n\t\t\t.put(\\midi, false)\t\t// this only works on mapped data\n\t\t\t.play;\n\t};\n\t\t// should be able to receive an array of notes\n\t~chordNoteOff = #{ |note|\n\t\t~child.event.copy.put(\\chNotes, note).use({\n\t\t\t~releaseNote.value;\n\t\t});\n\t};\n}).import((melMIDI: \\midiCleanup)) => PR(\\chMIDI);\n\nPR(\\melMIDI).v.clone({\n\t~defaultMIDIType = \\mel;\t// chord processes place mel into topNote\n\t~preparePlayEvent = #{ |note|\n\t\tvar\tmode = ~parser.recSocket.buf.properties.tryPerform(\\at, \\mode) ?? { ~child.mode ? \\default };\n\t\t~melNoteOff.(note);\t// polyphony is not allowed\n\t\t~child.eventStream.next(~child.event.copy)\n\t\t\t.put(\\delta, 0.1)\n\t\t\t.put(\\length, inf)\n\t\t\t.put(\\immediateOSC, true)\n\t\t\t.put(\\top, (note: note.copy.mapMode(mode), mode: mode))\n\t\t\t.put(\\midi, false)\n\t\t\t.play;\n\t};\n\n\t\t// this one should only stop the stream if releasing the last played note\n\t~melNoteOff = #{ |note|\n\t\tvar\tcurrentChord = ~child.child.currentChord, notes;\n\t\tcurrentChord.notNil.if({\n\t\t\tnotes = currentChord.lastFitNotes.asFloat\n\t\t\t\t.unmapMode(currentChord.modeForEvent(~child.lastEvent));\n\t\t\t(~lastMIDINoteOn == note.asFloat).if({\n\t\t\t\t~child.child.event.copy\n\t\t\t\t\t.put(\\freq, notes)\n\t\t\t\t\t.put(\\immediateOSC, true)\n\t\t\t\t\t.use({ ~releaseNote.value; });\n\t\t\t});\n\t\t});\n\t\t~midiNotesOn.remove(note.asFloat);\n\t};\n}) => PR(\\topMIDI);\n\n// chord and topnote melody input simultaneously\nPR(\\chMIDI).v.clone({\n\t~preparePlayEvent = #{ |note|\n\t\t~child.eventStream.next(~child.event.copy)\n\t\t\t.put(\\chNotes, note.mapMode(~child.mode))\n\t\t\t.put(\\top, note.maxItem.postln.mapMode(~child.mode).postln)\n\t\t\t.put(\\length, inf)\t\t// child should not cut off on its own\n\t\t\t.put(\\midi, false)\t\t// this only works on mapped data\n\t\t\t.put(\\getChord, false)\n\t\t\t.play;\n\t};\n\n\t~midiCleanup = #{ \n\t\tvar\tbp, buf;\n\t\tbp = BP(~collIndex);\n\t\tbp.unwrap(false);\n\t\t\t// insert your own processing here -- parsing, quantization\n\t\tbuf = ~postRecFunc.value(~parser.recSocket.buf, bp);\n\t\tbp.bindMIDIRecBuf(buf, \\ch);\n\t\tbp.bindMIDIRecBuf(buf.copyTopNotes, \\mel);\n\t\tbp.stopNow;\n\t\tbp.play(~replayTimeSpec.applyLatency(bp.latency), doReset:true);\n\t};\n\t\n}) => PR(\\chmelMIDI);\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup13-adaptation.scd": "\n// adaptation functions\nvar saveSubType = AbstractChuckArray.defaultSubType;\n\n// first, evaluate fitness\n// these are very basic defaults, user can customize them for certain materials\n\n// write adTest later\n\n#{ |orig, test|\n\tvar\tout;\n\tout = orig.metric.absdif(test.metric);\n\t(out > (orig.metric*0.25)).if(out);\t// otherwise nil\n} => Func(\\eugTest).subType_(\\eugTest);\n\n#{ nil } => Func(\\dummyEugTest).subType_(\\eugTest);\n\n// first checks range as a hard limit\n// BP(\\melodicProcess).v.range = NumericRange(lo, hi)\n{ |orig, test, passInValue|\n\tvar\trange;\n\t((range = passInValue[\\range]).notNil and: {\n\t\t\ttest.loNote < range.lo or: { test.hiNote > range.hi } }).if(100);\n} => Func(\\eugRangeOnlyTest).subType_(\\eugTest);\n\n// if in range, returns result of eugTest; otherwise, 100 to guarantee failure\n{ |orig, test, passInValue|\n\tvar\tout;\n\t(out = Func(\\eugRangeOnlyTest).doAction(orig, test, passInValue)).isNil.if({\n\t\tout = Func(\\eugTest).doAction(orig, test, passInValue)\n\t});\n\tout\n} => Func(\\eugRangeTest).subType_(\\eugTest);\n\n\n// design may change if I need to pass extra args in\n\n// material should always be in array form -- make those changes later\n\nAbstractChuckArray.defaultSubType = \\melAdapt;\n\n#{ |source, cross|\t// absolute splice\n\tvar\ts1, s2, newSeg, splice, spl2size, spl2;\n\ts1 = source.notes;\t\t// not worrying about weighting b/c poor adaptations\n\ts2 = cross.notes;\t\t// will die after a few generations\n\tsplice = ((s1.size-2).rand + 1).max(1);\t// splice coordinates\n\tspl2size = rrand(3, (s2.size * 0.7).roundUp.asInteger);\n\tspl2 = (s2.size - spl2size).rand;\n\tnewSeg = s1.copyRange(0, splice-1);\n\tnewSeg = newSeg ++ s2.copyRange(spl2, spl2 + spl2size);\n\tnewSeg ++ s1.copyRange(splice, s1.size - 1);\n} => Func(\\absSplice);\n\n#{ |source, cross|\n\t// diatonic splice -- take part of s1 as is, insert intervals from part of s2,\n\t// and finish with s1\n\tvar s1, s2, temp, s1ang, splice, current, new, spl2, spl2size;\n\tsplice = ((source.notes.size-2).rand + 1).max(1);\n\tspl2size = rrand(3, (cross.notes.size * 0.7).round.asInteger);\n\tspl2 = (cross.notes.size - spl2size).rand.max(1);\n\t(spl2size + spl2 >= cross.notes.size).if({ spl2size = cross.notes.size - spl2 });\n\t\n\t(spl2size >= 2).if({\n\t\tnew = source.notes.copyRange(0, splice-1);\n\t\t\t// last diatonically mapped note + first spliced interval - s2 dia map note\n\t\tcurrent = (source.notes[splice-1] + cross.intervals[spl2 - 1] - \n\t\t\tcross.notes[spl2].freq).asFloat;\n\t\tnew = new ++ (cross.notes.copyRange(spl2, spl2 + spl2size - 1) + current);\n\t\t\t// last note copied + transposition + next interval from source - next note (source)\n\t\t\t// algebraically simplifies to last note(s2) + transposition - last note (source)\n\t\tcurrent = cross.notes[spl2 + spl2size - 1].freq + current - source.notes[splice-1].freq;\n\t\tnew ++ (source.notes.copyRange(splice, source.notes.size - 1) + current);\n\t});\n} => Func(\\intSplice);\n\n// delete some notes randomly from the segment\n#{ |source|\n\tvar\thalfSize, deleteFrom, deleteTo;\n\t(source.notes.size > 6).if({\n\t\thalfSize = source.notes.size >> 1;\n\t\tdeleteFrom = halfSize.rand;\n\t\tdeleteTo = halfSize.rand + halfSize;\n\t\tsource.notes[0..deleteFrom] ++ source.notes[deleteTo..source.notes.size-1]\n\t});\t// else return nil (failed)\n} => Func(\\delete);\n\n// delete some notes, keeping the segment duration the same\n// issue: how to determine whether to sustain the previous note, or leave a rest?\n// for now just leave a rest\n#{ |source|\n\tvar\tlo, hi, numToDrop, newNote;\n\tsource = source.notes.copy;\t// must copy array before modifying\n\tlo = rand(source.size-1)+1;\t// can't drop first note\n\tnumToDrop = rand((source.size - 1).min((source.size * 0.25).asInteger));\n\thi = (lo + numToDrop).min(source.size-1);\n\t\t// copy the note before modifying\n\tsource.put(lo-1, source[lo-1].copy);\n\t\t// add the deleted notes' deltas to the new note's delta\n\tfor(lo, hi, { |i|\n\t\tsource[lo-1].dur = source[lo-1].dur + source[i].dur;\n\t});\n\t(source[0..lo-1] ++ source[hi+1..source.size-1])\n} => Func(\\delHoldDur);\n\n// fixed-duration splice: output will be exactly as long as source.notes\n{ |source, cross|\n\tvar\ts1, s2, newSeg, splice, spl2size, spl2, dur1, dur2, i, notetemp;\n\ts1 = source.notes;\n\ts2 = cross.notes;\n\tsplice = ((s1.size-2).rand + 1).max(1);\n\tspl2size = rrand((s2.size * 0.2).round.asInteger, (s2.size * 0.7).round.asInteger);\n\tspl2 = (s2.size - spl2size).rand.max(0);\n\tdur2 = s2[spl2 .. spl2 + spl2size].collect(_.dur).sum;\n\t\n\t\t// calc coordinates in s1 matching that dur\n\tdur1 = 0;\n\ti = splice;\n\t{ (i < s1.size) and: { dur1 < dur2 } }.while({\n\t\tdur1 = dur1 + s1[i].dur;\n\t\ti = i + 1;\n\t});\n\t\t// if durs are equal, no problem\n\t\t// if dur1 is shorter, remove notes from spl2 until dur1 is longer or only one note is left\n\t(dur1 < dur2).if({\n\t\t{ spl2size > 0 and: { dur2 > dur1 } }.while({\n\t\t\tdur2 = dur2 - s2[spl2 + spl2size].dur;\n\t\t\tspl2size = spl2size - 1;\n\t\t});\n\t});\n\n\t\t// if dur1 is longer, adjust length of last splice note\n\t(dur1 != dur2).if({\n\t\ts2 = s2.copy.put(spl2 + spl2size, (notetemp = s2[spl2 + spl2size].copy).dur_(notetemp.dur + dur1 - dur2));\n\t});\n\t\n\tnewSeg = s1.copyRange(0, splice-1);\n\tnewSeg = newSeg ++ s2.copyRange(spl2, spl2 + spl2size);\n\t(i < s1.size).if({\n\t\tnewSeg = newSeg ++ s1.copyRange(i, s1.size - 1);\n\t}, { newSeg });\n} => Func(\\fixedSplice);\n\n// a few simple ones\n{ |source| var size = source.notes.size, i, notes;\n\tnotes = source.notes.copy.swap(i = size.rand, (i + (size-1).rand).wrap(0, size-1));\n} => Func(\\noteSwap);\n\n// delete 1 note\n{ |source| var i = (source.notes.size - 1).rand, out;\n\t(source.notes.size > 4).if({\n\t\t(out = source.notes.copy).put(i, out[i].copy.dur_(out[i].dur + out[i+1].dur));\n\t\tout.removeAt(i+1);\n\t\tout\n\t}, { nil })\n} => Func(\\dropNote);\n\n// pick a note, split it in 2 (choose a note randomly in range of source)\n{ |source| var i = source.notes.size.rand, out, dur;\n\tout = source.notes.copy;\n\tdur = out[i].dur;\n\tout[i] = out[i].copy.dur_(rrand(0.25, dur).round(0.25));\n\t(out[i].dur != dur).if({\n\t\tout = out.insert(i+1, SequenceNote(rrand(source.loNote, source.hiNote).round, dur = dur - out[i].dur, dur + rrand(-0.1, 0.1), out[i].args));\n\t\tout\n\t}, { nil });\t// nil == no adaptation\n} => Func(\\splitNote);\n\n// variation: choose note just outside range\n{ |source| var i = source.notes.size.rand, out, dur;\n\tout = source.notes.copy;\n\tdur = out[i].dur;\n\tout[i] = out[i].copy.dur_(rrand(0.25, dur).round(0.25));\n\t(out[i].dur != dur).if({\n\t\tout = out.insert(i+1, SequenceNote(rrand(source.loNote - 3, source.hiNote + 3).round, dur = dur - out[i].dur, dur + rrand(-0.1, 0.1), out[i].args));\n\t\tout\n\t}, { nil });\t// nil == no adaptation\n} => Func(\\splitNote2);\n\n\n// chordal adaptation -- currently only fitToBassAndTop and support funcs\n\nAbstractChuckArray.defaultSubType = \\chordFit;\n\n// couple of very simple cases\n// return notes, no modification\n#{ |source| source[\\notes] } => Func(\\asis);\n\n// return notes transposed to topnote\n#{ |source, inEvent|\n\tvar\tsourceTop, inTop, mode, topEvent, top, topMode, root, notes;\n\t#mode, topEvent, top, topMode, root, notes =\n\t\tFunc(\\getValuesFromEvent).doAction(source, inEvent);\n\tinEvent[\\top].notNil.if({\n\t\tsourceTop = source[\\notes].maxItem;\n\t\tsource[\\notes] + (top.asFloat - sourceTop.asFloat)\n\t}, {\n\t\tsource[\\notes]\t// no topnote given, return input notes\n\t});\n} => Func(\\fitToTop);\n\n{ |source, inEvent|\n\t\t// see Func(\\getValuesFromEvent) - I don't need all the values so I take only this one\n\tvar\troot = (Library.[inEvent[\\bassID] ? \\currentBassNote].value(inEvent) ? 0).asFloat,\n\t\tnotes = source[\\notes],\n\t\tlowNote = notes.minItem.asFloat;\n\tnotes + (root - lowNote);\n} => Func(\\fitToBass);\n\n\t// caller should supply the correct mode, for speed\n#{ |noteArray, top, root, mode, fitFactors|\n\tvar\tdegreesPerOctave, lowNote, fitIndex;\n\tmode = mode.asMode;\n\tdegreesPerOctave = mode.scale.size;\n\tlowNote = noteArray.minItem.asFloat;\n\tnoteArray.collect({ |n, i|\n\t\t\t// this should handle all floats\n\t\t\t// if not, the note will be sorely punished (-20)\n\t\t\t// multiply by a scaling factor to reduce the influence of higher notes\n\t\tfitIndex = ((n = n.asFloat) - root).round(0.1) % degreesPerOctave;\n\t\t\t// needed b/c you may get fitIndex === -0.0\n\t\t(fitIndex == 0).if({ fitFactors[0] }, {\n\t\t\t(fitFactors[fitIndex] ? -20)\n\t\t}) * ((1 - ((n-lowNote) / 14)).clip(0, 1));\n\t}).mean;\t// use mean so that chords with lots of notes won't overwhelm thinner chords\n} => Func(\\chPitchFit).subType_(\\chFitAnalysis);\n\n// measures whether a set of notes belong to the mode into which they were mapped\n// chromatic notes are punished\n#{ |noteArray|\n\tnoteArray.collect({ |n, i|\n\t\t((n = n.asFloat) == n.asInteger).if({ 1 }, { -1 });\n\t}).mean;\t// use mean so that chords with lots of notes won't overwhelm thinner chords\n} => Func(\\chModeFit).subType_(\\chFitAnalysis);\n\t\n#{ |notes, top, mode|\n\tvar degreesPerOctave, numBelowTop, numAboveTop, transposeBelow;\n\tmode = mode.asMode;\n\tdegreesPerOctave = mode.scale.size;\n\tnumAboveTop = numBelowTop = 0;\n\tnotes.do({ |n| \n\t\t(n > top).if({ numAboveTop = numAboveTop + 1 });\n\t\t(n < top).if({ numBelowTop = numBelowTop + 1 });\n\t});\n\t\t// if more notes are above than below top, notes below top need to be dropped 1 oct.\n\ttransposeBelow = (numAboveTop > numBelowTop).if(degreesPerOctave, 0);\n\tnotes.collect({ |n|\n\t\t(n > top).if({\n\t\t\tn - (degreesPerOctave *   // notes in an octave *\n\t\t\t\t(((n - top) / degreesPerOctave).roundUp))  // octaves to transpose\n\t\t}, {\n\t\t\t(n < top).if({ n - transposeBelow }, { n });\n\t\t});\n\t});\n} => Func(\\fixNotesAboveTop).subType_(\\chFitAnalysis);\n\n// convert a note from mode1 to mode2\n#{ |note, mode1, mode2|\n\t(note.unmapMode(mode1) - mode1.asMode.tuning).mapMode(mode2)\n} => Func(\\convertMode).subType_(\\chFitAnalysis);\n\n#{ |note, mode1, mode2|\n\t(Func(\\convertMode).doAction(note, mode1, mode2) /*+ 0.1.rand2*/).round\n} => Func(\\convertNearestInMode).subType_(\\chFitAnalysis);\n\n// returns an array with important values for chord fitting\n#{ |source, inEvent|\n\tvar\tmode, topEvent, top, topMode, root, notes, chordMode;\n\n\tmode = (inEvent[\\mode] ? \\default)/*.asMode*/;\n\n\t\t// mode might be a mode pool (array of Mode IDs) -- if so, revert to the mode stored in the chord\n\t(mode.asMode.value.size > 0).if({\n\t\tmode = source[\\mode];\n\t});\n\n\t\t// midi input will be in the event - use it if present\n\tnotes = inEvent[\\chNotes] ? source[\\notes];\n\t(topEvent = inEvent[\\top]).notNil.if({\n\t\ttop = topEvent[\\freq] ?? { topEvent[\\note].asFloat };\n\t\ttopMode = topEvent[\\mode]/*.asMode*/;\n\t}, {\n\t\ttop = notes.asFloat.maxItem;\n\t\ttopMode = mode;\n\t});\n\t(mode != topMode).if({\n\t\ttop = Func(inEvent[\\convertTopFunc] ? \\convertMode).doAction(top, topMode, mode);\n\t});\n\t\t\n\t\t// .value(inEvent) means that the Library item can generate a new root when called\n\troot = (Library.at(inEvent[\\bassID] ? \\currentBassNote).value(inEvent) ? 0).asFloat;\n\n\t[mode, topEvent, top, topMode, root, notes]\t// return val\n} => Func(\\getValuesFromEvent).subType_(\\chFitAnalysis);\n\n\t\t// should return notes array\n\t\t// \"match by notes\" strategy: calculate all possible transpositions of this chord\n\t\t// containing the top note; measure the fitness of each, and choose one of the\n\t\t// best fitting chords\n#{ |source, inEvent, fitFactors|\n\tvar\ttransposeStats,  // [[xpose1, fitness1], [xpose2, fitness2]...]\n\t\txposeBy, mode, topEvent, top, topMode, root, notes;\n\n\t#mode, topEvent, top, topMode, root, notes =\n\t\tFunc(\\getValuesFromEvent).doAction(source, inEvent);\n\n\t\t// transpose and evaluate for each note\n\ttransposeStats = notes.collect({ |n|\n\t\t[xposeBy = (top - n).asFloat,\n\t\t Func(\\chPitchFit).doAction(notes + xposeBy, top, root, mode, fitFactors)];\n\t}).sort({ |a, b| a[1] > b[1] });  // sort fitnesses descending\n\t\t// transpose the whole chord\n\tFunc(\\fixNotesAboveTop).doAction(notes + transposeStats[0][0], top, mode);\n} => Func(\\chordFitNotes);\n\n// interval strategy -- produce final chord forms by traversing the intervals in a tree structure\n#{ |source, inEvent, fitFactors|\n\tvar resultList = Func(\\collectChordsByInt).doAction(source, inEvent, fitFactors),\n\t\tfitness,\t\t// [[0, fitness0], [1, fitness1]]\n\t\tmode, topEvent, top, topMode, root, notes;\n\n\t#mode, topEvent, top, topMode, root, notes =\n\t\tFunc(\\getValuesFromEvent).doAction(source, inEvent);\n\n\tfitness = resultList.collect({ |ch, i|\n\t\t[i, Func(\\chPitchFit).doAction(ch, top, root, mode, fitFactors)]\n\t}).sort({ |a, b| a[1] > b[1] });\n\t\n\t\t// output -- fitness[0] is best fit, second [0] gets index into resultList\n\t\t// dur and length should be replaced by microrhythm\n\tresultList[fitness[0][0]].collect({ |freq| SequenceNote(freq, 1, 1) })\n} => Func(\\chordFitInt);\n\n// more code, but faster...\n#{ |source, inEvent, fitFactors|\n\tvar\tparms = Func(\\getValuesFromEvent).doAction(source, inEvent),\n\t\tsortedNotes = parms[5].copy.sort({ |a, b| a > b }),\t// descending order by pitch\n\t\tintervals = Array.new(sortedNotes.size-1),\n\t\tresult,\n\t\tcurrent = parms[2];\n\n\tsortedNotes.asFloat.doAdjacentPairs({ |a, b| intervals.add((b - a)) });\n\tintervals = intervals.scramble;\n\t\n\tresult = Array(sortedNotes.size).add(SequenceNote(current, 1, 1));\n\tintervals.do({ |int|\n\t\tcurrent = current + int;  // intervals are negative so this is actually descending\n\t\tresult.add(SequenceNote(current, 1, 1));\n\t});\n\tresult\n} => Func(\\chordRandInt);\n\n{ |source, inEvent, fitFactors|\n\tvar\tresultList,\t// chords resulting from tree traversal\n\t\tnotes, sortedNotes, intervals,\n\t\tmode, topEvent, top, topMode, root;\n\n\t#mode, topEvent, top, topMode, root, notes =\n\t\tFunc(\\getValuesFromEvent).doAction(source, inEvent);\n\n\t\t// define traverse function\n\tresultList = List.new;\n\tsortedNotes = notes.copy.sort({ |a, b| a > b });\t// descending order by pitch\n\tintervals = Array.new(sortedNotes.size-1);\n\t\t// .asFloat is needed to be sure removeDups in traverse func works\n\tsortedNotes.asFloat.doAdjacentPairs({ |a, b| intervals.add((b - a)) });\n\tFunc(\\traverseIntervalTree).doAction([top], intervals, resultList);\n\tresultList\n} => Func(\\collectChordsByInt);\n\n{ |current, intervals, resultList|\n\tvar\ttempIntervals;\n\t(intervals.size > 0).if({\n\t\t\t// removeDups because it isn't necessary to process the same interval\n\t\t\t// multiple times in the same recursion level\n\t\tintervals.removeDups.do({ |interval|\n\t\t\t(tempIntervals = intervals.copy).remove(interval);\n\t\t\tFunc(\\traverseIntervalTree).doAction(current.copy.add(current.last + interval),\n\t\t\t\ttempIntervals, resultList);\n\t\t});\n\t}, {\n\t\tresultList.add(current)\n\t});\n} => Func(\\traverseIntervalTree);\n\n\n\n// convenience stuff\n\n// making a chord process is too hard, requiring 7 or more chucks\n// this sets the basic parameters in one go, puts in a BP, and returns the BP\n#{ |newBPname, childName, parentName, chordMIDIBuf, topMelodyMIDIBuf, macrorhythm, microrhythmSelector, arpegPatSelector, adaptKeysForTopMelody, mode, parms|\n\tvar\tnew;\n\tBP.exists(newBPname).not.if({\n\t\tnew = PR(parentName).chuck(PR(childName).chuck(BP(newBPname), nil, parms), nil, parms);\n\t\t\t// short form for ch.notNil.if({ ... })\n\t\tmode.asMode !? { mode.asMode => new };\n\t\tchordMIDIBuf !? { chordMIDIBuf =>.ch new };\n\t\ttopMelodyMIDIBuf !? { topMelodyMIDIBuf =>.mel new };\n\t\tmacrorhythm !? { macrorhythm =>.macro new };\n\t\tmicrorhythmSelector !? { microrhythmSelector =>.micro new };\n\t\tarpegPatSelector !? { arpegPatSelector =>.arpeg new };\n\t\tadaptKeysForTopMelody !? { adaptKeysForTopMelody =>.adapt new };\n\t\tnew\n\t}, {\n\t\t(\"BP(\" ++ newBPname.asCompileString ++ \") already exists. Using existing BP.\").warn;\n\t});\n\tBP(newBPname)\n} => Func(\\makeCh).subType_(\\factory);\n\n// same as makeCh, but frees the BP first\n#{ |newBPname, childName, parentName, chordMIDIBuf, topMelodyMIDIBuf, macrorhythm, microrhythmSelector, arpegPatSelector, adaptKeysForTopMelody, mode, parms|\n\tvar\tnew;\n\tBP.exists(newBPname).if({ BP(newBPname).free });\n\tFunc(\\makeCh).doAction(newBPname, childName, parentName, chordMIDIBuf, topMelodyMIDIBuf, macrorhythm, microrhythmSelector, arpegPatSelector, adaptKeysForTopMelody, mode, parms);\n} => Func(\\newCh).subType_(\\factory);\n\n\n// for melodic processes\n// intra-phrase segmenter\n// notes, currentEnvironment is a bit odd, but necessary for error protection\n#{ |notes, nextNote, intervals, minSegSize, parms|\n\t\tvar\tdurs;\n\t\tvar\tlastTrueIndex, largeInterval;\n\n\t\tminSegSize = minSegSize ? 4;\n\t\tdurs = notes.collect(_.dur);\n\n\t\t\t// split phrase into segments\n\t\tlastTrueIndex = -1;\t\t// to ensure that true isn't returned too often\n\t\t\t\t\t\t\t\t// has to be -1 because separate splits AFTER it sees true\n\t\tlargeInterval = { |i|\t\t// determine if this is a large interval\n\t\t\t(i < intervals.size).if({\n\t\t\t\t(intervals[i].abs > ~avgInterval) or: { durs[i] > ~avgDelta }\n\t\t\t}, {\n\t\t\t\ttrue\t\t// maybe this should be false?\n\t\t\t});\n\t\t};\n\n\t\tnotes = notes.separate({ |note1, note2, i|\n\t\t\t\t// do not start a new segment if less than minsegsize\n\t\t\t(i - lastTrueIndex < minSegSize).if({ false }, {\n\t\t\t\t\t// start a new seg if this is a big interval and next is not\n\t\t\t\t\t// otherwise, keep rollin'\n\t\t\t\t(largeInterval.value(i) and: largeInterval.value(i+1).not).if({\n\t\t\t\t\tlastTrueIndex = i;\n\t\t\t\t\ttrue\n\t\t\t\t}, { false });\n\t\t\t});\n\t\t});\n} => Func(\\defaultMelSegmenter).subType_(\\melPartition);\n\n// phrase splitter\n{ |notes|\n\tvar subsegs, phraseScores, avgScore, splitIndices;\n\t\t\t// partition the melody into phrases\n\t\t\t// metric is (delta - avgDelta) * (rest / delta)\n\t\tphraseScores = notes.collect({ |n|\n\t\t\t(n.dur < ~avgDelta or: { n.length > n.dur }).if({ -inf },\n\t\t\t\t{ (n.dur - ~avgDelta) * ((n.dur - n.length) / n.dur) });\n\t\t});\n\t\tavgScore = phraseScores.reject(_ < 0).mean;\n\t\tsplitIndices = Array.new(notes.size).add(0);\n\t\tphraseScores.do({ |score, i|\n\t\t\t(score > avgScore).if({ splitIndices.add(i) });\n\t\t});\n\t\tsplitIndices.add(notes.size-1);\n\t\t\t// do you want to join with the preceding or following phrase? dunno, assuming earlier\n\t\tsplitIndices.doAdjacentPairs({ |a, b, i|\n\t\t\t(b-a < 3).if({ phraseScores[a] = -inf });\n\t\t});\n\t\tnotes = notes.separate({ |a, b, i| phraseScores[i] > avgScore });\n} => Func(\\defaultMelSplit).subType_(\\melPartition);\n\n// split notes into equal-length phrases\n// corner case not covered: if last phrase is too short, what do we do?\n// or, if last note exceeds bar length, there will be no compensation\n{ |notes, parms|\n\tvar\telapsed = 0, result = List.with(List.new),\n\t\tbarlength = parms.atBackup(\\barLength, currentEnvironment) ? 4.0,\n\t\toverflow;\n\tnotes.do({ |note, i|\n\t\tresult.last.add(note);\n\t\telapsed = elapsed + note.dur;\n\t\t(elapsed >= barlength and: { i < (notes.size - 1) }).if({\n\t\t\tresult.add(List.new);\n\t\t\telapsed = elapsed - barlength;\n\t\t});\n\t});\n\tresult.doAdjacentPairs({ |a, b|\n\t\t((overflow = a.collect(_.dur).sum - barlength) > 0).if({\n\t\t\ta[a.size-1] = a.last.copy.dur_(a.last.dur - overflow);\n\t\t\t\t// empty array is how to indicate a rest to a voicer\n\t\t\t\t// will update later for symbols e.g. \\rest\n\t\t\tb.insert(0, SequenceNote(\\rest, overflow, 0.1, 0.5));\n\t\t});\n\t});\n\t\t// more efficient to call asArray first on the outer list, saves an object\n\tresult.asArray.collect(_.asArray);\n} => Func(\\barMelSplit).subType_(\\melPartition);\n\n{ |notes| [notes] } => Func(\\noSplit).subType_(\\melPartition);\n\n// user-defined phrase splits\n// give the size of each clump of notes\n{ |notes, parms|\n\tvar\tsplitsizes = parms.atBackup(\\phrSplits, currentEnvironment);\n\t(splitsizes.size > 0).if({\n\t\tnotes.clumps(splitsizes)\n\t});\t// ok to return nil on failure; Func will substitute the original note array\n} => Func(\\userSplit).subType_(\\melPartition);\n\n\n// helper functions to use drum sequencers with a coordinator\n// that produces keys to choose generators\n\nAbstractChuckArray.defaultSubType = \\drumgenhelpers;\n\n{\tvar\tresult, shortIndex;\n\t~usedKeys.do({ |key|\n\t\t(key != \\amps).if({\n\t\t\tresult = Array.fill(~amps.size, -1);\n\t\t\tshortIndex = 0;\n\t\t\t~amps.do({ |amp, longIndex|\n\t\t\t\t(amp > 0).if({\n\t\t\t\t\tresult[longIndex] = key.envirGet.wrapAt(shortIndex);\n\t\t\t\t\tshortIndex = shortIndex + 1;\n\t\t\t\t});\n\t\t\t});\n\t\t\tkey.envirPut(result);\n\t\t});\n\t});\n} => Func(\\expandKeys);\n\n{\tvar\tnonrests = ~amps.collectIndices(_ > 0);\n\t~usedKeys.do({ |key|\n\t\t(key != \\amps).if({\n\t\t\tkey.envirPut(key.envirGet.asArray.wrapAt(nonrests));\n\t\t\t(key.envirGet.size == 0).if({\n\t\t\t\tkey.envirPut(#[0]);\n\t\t\t});\n\t\t});\n\t});\n} => Func(\\shrinkKeys);\n\n{ |i, override|\n\tvar\ttemp;\n\t~usedKeys.do({ |key|\n\t\t(temp = (override ?? { (key ++ \"genStream\").asSymbol.envirGet }).value(i)).notNil.if({\n\t\t\tkey.envirGet[i] = temp;\n\t\t});\n\t});\n} => Func(\\insertIntoKeys);\n\n{\tvar\tbasekey;\n\t~usedKeys.do({ |key|\n\t\t(basekey = (key ++ \"base\").asSymbol).envirGet.notNil.if({\n\t\t\tkey.envirPut(basekey.envirGet.copy)\n\t\t}, {\n\t\t\t~base.notNil.if({\n\t\t\t\tkey.envirPut(~base.copy)\n\t\t\t}, {\n\t\t\t\tkey.envirPut(Array.fill(0, ~ampsSize.value))\n\t\t\t});\n\t\t});\n\t});\n} => Func(\\initKeys);\n\n{ ~amps.collectIndicesOfItem(0) } => Func(\\getRests);\n\n{  ~genBase.value; } => Func(\\drumBasicPre);\n\n{ \n\tvar\taction = ~driverEvent.tryPerform(\\at, ~collIndex), func;\n\t~genBase.value;\n\tFunc.exists(action).if({\n\t\tFunc(action).doAction;\n\t});\n\t~driverEvent = nil;\n} => Func(\\drumRespDriver);\n\n\n\n// for a rhythmic-adaptation prototype\n// this func assumes your process is modeled after flutefx and has the required variables\n\n{ |source, cross|\n\tvar\tnew, adaptKey;\n\t(adaptKey = ~adaptStream.next(source)).notNil.if({\n\t\t(new = Func(adaptKey).doAction(source, cross)).notNil.if({\n\t\t\t~rhythms.add(new);\n\t\t\t(~rhythms.size > (3 * ~originalRhythms)).if({\n\t\t\t\t~rhythms.removeAt(((~rhythms.size * 0.25).asInteger.rand\n\t\t\t\t\t+ ~originalRhythms).clip(~originalRhythms, ~rhythms.size-1));\n\t\t\t});\n\t\t});\n\t});\n\tnew\n} => Func(\\adaptRhythmArray);\n\n{ |source, cross|\n\tvar\tnew, spliceIndex, spliceStart, spliceEnd, temp;\n\tsource = source;\n\tcross = cross;\n\tspliceIndex = source.size.rand;\n\tspliceStart = cross.size.rand;\n\tspliceEnd = (spliceStart + (spliceStart * 0.3).asInteger.rand2).clip(0, cross.size-1);\n\t(spliceIndex > 0).if({\n\t\tnew = source[0..spliceIndex-1];\n\t});\n\tnew = new ++ cross[spliceStart .. spliceEnd] ++ source[spliceIndex..];\n\tnew\n} => Func(\\spliceRhythmArray);\n\n{ |source|\n\tvar\tnew, spliceStart, spliceEnd, temp;\n\t(source.size > 4).if({\n\t\tsource = source;\n\t\tspliceStart = source.size.rand;\n\t\ttemp = source.size.rand;\n\t\tspliceEnd = max(spliceStart, temp);\n\t\tspliceStart = min(spliceStart, temp);\n\t\t(spliceStart > 0).if({\n\t\t\tnew = source[0..spliceStart-1];\n\t\t});\n\t\t(spliceEnd < (source.size - 1)).if({\n\t\t\tnew = new ++ source[spliceEnd+1..];\n\t\t});\n\t\tnew\n\t});\n} => Func(\\deleteRhythmArray);\n\n\nAbstractChuckArray.defaultSubType = saveSubType;\n",
    "startup14-perc.scd": "\n// need iMadeDef for defPerc -- per def\n\n// percussion process templates\n// first, generic synthdefs\n\nvar saveSubType = AbstractChuckArray.defaultSubType;\n\n\n\n// abstract process based on buffers\n// the process generates a new Pbind per cycle\n// amp pattern is specified in terms of subdivisions:\n// #[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0] will sound on beats 2 and 4\n// if ~division = 0.25\n\n// other arrays are per event, using wrapAt\nAbstractChuckArray.defaultSubType = \\drumSequencer;\n\nPR(\\abstractProcess).v.clone({\n\t\t// grain: true means don't generate a new node id each time (use -1)\n\t~event = (grain: true, eventKey: \\singleSynthPlayer);\n\t~requiredKeys = #[\\amps, \\bufPaths];\n\t~inChannels = 1;\n\t~outChannels = 2;\n\t\n//\t~bufPaths = #[path0, path1...];\t// files to load\n//\t~bufCoords = #[[start0, len0], [start1, len1]...];\t// which portions\n\n\t~bufCoords = #[[0, -1]];\t// default load whole soundfile for each file\n\t\n\t~bufs = #[0];\t\t// default: use only first buffer\n\t~rates = #[1];\t// default: play at normal speed\n\t~deltaAdjust = #[0];\t// push samples ahead (-) or behind (+) to compensate for transient time\n\t\t\t\t\t\t// this array's elements correspond to buffers\n\t\t\t\t\t\t// adjustments given in seconds\n\t\t\t\t\t\t// adjustment.neg <= thisBP.leadTime - MUST BE TRUE\n\t~divCycle = 0.25;\t// or #[0.3, 0.2] for swing\n\t~beatsPerBar = { (~clock ?? { BP.defaultClock }).beatsPerBar };\n\t~def = \\bufGrain;\n\t~argPairs = nil;\t// you may specify other arg keys as an array: [key, value, key, value]\n\t\t\t\t\t// if the key's value is not a pattern, a pattern will be made for it\n\t\t\t\t\t// using makePattern\n\n\t~attack = 0.001;\n\t~decay = 0.02;\n\t~mono = false;\t// true = automatically prevent note overlaps\n\t~compensateEnv = false;\t\t// true = subtract attack and decay time from time value\n\t\t\t\t\t\t\t// so that the synth plays for exactly \"time\" seconds\n\t\t// compensate sensitivity: 1.0 = subtract whole attack/decay duration\n\t\t// 0.0 = subtract none (just like ~compensateEnv = false)\n\t\t// 0.5 = subtract *half* of attack + decay\n\t~compensateAmount = 1.0;\n\n\t~compactPatterns = true;\n\n\t~iMadeMixer = false;\n\n\t~prep = #{ \n\t\t\t// user may supply a mixerchannel\n\t\t\t// if so, ~iMadeMixer flag means the channel won't be freed\n\t\t~chan.isNil.if({\n\t\t\t~iMadeMixer = true;\n\t\t\t~chan = MixerChannel(~collIndex, ~master.tryPerform(\\server) ?? { Server.default },\n\t\t\t\t~inChannels ? 1, ~outChannels ? 2, outbus:~master);\n\t\t});\n\t\t\t// this func is environment safe\n\t\t\t// loadbufs is here for defPerc, which may need resources from postMCCreation\n\t\t~chan.doWhenReady({ |chan|\n\t\t\t~postMCCreation.(chan);\n\t\t\t~loadBufs.value;\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t~postMCCreation = nil;\t// pre-buffer exit point to put in your own initialization\n\t~postBufferLoad = nil;\t// post-buffer exit point\n\t~loadBufs = #{ \n\t\t~buffers.notNil.if({ ~buffers.free });\n\t\t~bufTimes = Array.newClear(~bufPaths.size);\n\t\t~buffers = ~bufPaths.collect({ |path, i|\n\t\t\tBuffer.readAndQuery(~chan.server, path, \n\t\t\t\t~bufCoords.wrapAt(i)[0], ~bufCoords.wrapAt(i)[1],\n\t\t\t\tcompletionFunc: e { |buf|\n\t\t\t\t\t~fixBufTime.(i, buf);\n\t\t\t\t\tif(i == (~bufPaths.size - 1)) { ~postBufferLoad.() };\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~listBufs = { \n\t\t~buffers.do({ |buf, i| \"%: %\\n\".postf(i, buf) })\n\t};\n\t\n\t~replaceBuf = { |i, path, startFrame, numFrames|\n\t\t(i >= ~buffers.size).if({\n\t\t\t~addBuf.(path, startFrame, numFrames);\n\t\t}, {\n\t\t\t~buffers[i].free;\n\t\t\t~buffers[i] = Buffer.readAndQuery(~chan.server, path, startFrame, numFrames, e { |buf|\n\t\t\t\t~fixBufTime.(i, buf)\n\t\t\t});\n\t\t\t~buffers[i]\n\t\t});\n\t};\n\t\n\t~addBuf = {  \"Not yet implemented.\".warn; };\n\t\n\t~fixBufTime = { |i, buf|\n\t\t\t// try b/c a failure here shouldn't kill the buffer queue\n\t\ttry { ~bufTimes[i] = buf.numFrames / buf.sampleRate }\n\t\t\t{ |error| error.reportError; }  // display error but continue\n\t};\n\t\n\t~ampsSize = {\n\t\tvar\tdivCycleArray = ~divCycle.asArray;\n\t\t~beatsPerBar.value / divCycleArray.sum * divCycleArray.size\n\t};\n\t\n\t~makeDeltaPattern = #{ \n\t\tvar\tcurrent = 0, thisDelta, totalDelta, dStream, deltas;\n\t\t~compactPatterns.if({\n\t\t\tdeltas = Array.new(~amps.size);\n\t\t\tdStream = Pn(~divCycle.asPattern, inf).asStream;\n\t\t\tthisDelta = totalDelta = 0;\n\t\t\t~amps.do({ |step, i|\n\t\t\t\t(step > 0).if({\t// there's a note here\n\t\t\t\t\t(thisDelta > 0).if({\n\t\t\t\t\t\tdeltas.add(thisDelta);\n\t\t\t\t\t\ttotalDelta = totalDelta + thisDelta;\n\t\t\t\t\t\tthisDelta = 0;\n\t\t\t\t\t\tcurrent = current + 1;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tthisDelta = thisDelta + dStream.next;\n\t\t\t});\n\t\t\t(totalDelta < ~beatsPerBar.value).if({\n\t\t\t\tdeltas.add(~beatsPerBar.value - totalDelta);\n\t\t\t});\n\t\t\tPseq(deltas, 1)\n\t\t}, { Pfinval(~amps.size, Pn(~divCycle.asPattern, inf)) });\n\t};\n\t~makeAmpPattern = #{ \n\t\t~compactPatterns.if({\n\t\t\tPseq(((~amps[0] == 0).if({ #[0] })) ++ ~amps.select(_ > 0), 1);\n\t\t}, {\n\t\t\tPseq(~amps, 1)\n\t\t});\n\t};\n\t~makeDefPattern = #{ |repeats = 1|\n\t\tvar\toutArray = Array.new(~amps.size), array = ~def.asArray;\n\t\t~amps.do({ |amp, i|\n\t\t\t(amp > 0).if({\n\t\t\t\toutArray.add(array.wrapAt(i));\n\t\t\t});\n\t\t});\n\t\tif(outArray.size == 0) { outArray.add(\\rest) };\n\t\tPseq(outArray, repeats)\n\t};\n\t~makePatternFromArray = #{ |array, repeats, sourceKey|\n\t\tvar amps, outArray, i = 0;\n\t\t(~compactPatterns or: { sourceKey == \\def }).if({\n\t\t\tamps = ~amps;\n\t\t\toutArray = Array.new(amps.size);\n\t\t\t\t// if first is a rest, need a placeholder\n\t\t\t(sourceKey != \\def and: { amps[0] == 0 }).if({ outArray.add(0) });\n\t\t\tamps.do({ |amp|\n\t\t\t\t(amp > 0).if({\n\t\t\t\t\toutArray.add(array.wrapAt(i));\n\t\t\t\t\ti = i + 1;\n\t\t\t\t});\n\t\t\t});\n\t\t\tPseq(outArray, repeats)\n\t\t}, {\n\t\t\tPseq(array, repeats)\n\t\t});\n\t};\n\t~makePattern = #{ |sourceKey, repeats|\n//[sourceKey, ~collIndex, currentEnvironment[sourceKey].asArray].debug(\"making pattern for\");\n\t\t~makePatternFromArray.(currentEnvironment[sourceKey].asArray, repeats ? 1, sourceKey);\n\t};\n\t~addArgPairs = { |out|\n\t\tvar\targPairs = ~argPairs.value(out);\n\t\tif(argPairs.size > 0) {\n\t\t\tout = out.grow(argPairs.size);\n\t\t\targPairs.pairsDo({ |key, value|\n\t\t\t\tout.add(key);\n\t\t\t\t\t// if you say nil, look for the key in the envir\n\t\t\t\tvalue.isNil.if({ value = key.envirGet });\n\t\t\t\t\t// temporarily removing this\n\t\t\t\t\t// it prevents use of asMap\n//\t\t\t\tvalue.isSymbol.if({ value = value.envirGet });\n\t\t\t\t\t// this is the only way to get values from the environment\n\t\t\t\t\t// while the pattern is running\n\t\t\t\tvalue.isFunction.if({ value = value.(out) });\n\t\t\t\t(value.size > 0).if({\t// assume it's an array, use makePattern\n\t\t\t\t\tvalue = ~makePatternFromArray.(value, 1)\n\t\t\t\t});\n\t\t\t\tout.add(value);\n\t\t\t});\n\t\t};\n\t\tout\n\t};\n\t\n\t~makePbindArray = { \n//\t\t~def = ~def.asArray;\n\t\t[\\amp, ~makeAmpPattern.value,\n\t\t\t\\bufIndex, ~makePattern.(\\bufs, inf),\n\t\t\t\\bufnum, Pfunc({ |ev|\n\t\t\t\t~buffers.wrapAt(ev[\\bufIndex]).bufnum\n\t\t\t}),\n\t\t\t\\rate, ~makePattern.(\\rates, inf),\n// if user specifies times, they should be in beats. default (whole-buffer) times are in seconds\n\t\t\t\\time, ~times.notNil.if({\n\t\t\t\t(~makePattern.(\\times, inf) / thisThread.clock.tempo)\n\t\t\t}, {\n\t\t\t\tPfunc({ |ev|\n\t\t\t\t\t~bufTimes.wrapAt(ev[\\bufIndex]) / ev[\\rate]\n\t\t\t\t});\n\t\t\t}),\n\t\t\t\t// rest if 0, else give synthdef name\n//\t\t\t\\instrument, Pif(Pkey(\\amp) > 0, ~makePattern.(\\def, inf), \\rest),\n\t\t\t\\instrument, Pif(Pkey(\\amp) > 0, ~makeDefPattern.(inf), \\rest),\n\t\t\t\\chan, Pfunc({ ~chan }),\n\t\t\t\\latencyAdjust, Pfunc({ |ev| ~deltaAdjust.wrapAt(ev[\\bufIndex])\n\t\t\t\t* thisThread.clock.tempo }),\n\t\t\t\\timingOffset, Pfunc({ |ev| (ev[\\timingOffset] ? 0) + (ev[\\latencyAdjust] ? 0) }),\n\t\t\t\\delta, ~makeDeltaPattern.value,\n\t\t\t\\attack, ~makePattern.(\\attack, inf), // Pfunc({ ~attack }),\n\t\t\t\\decay, ~makePattern.(\\decay, inf), // Pfunc({ ~decay }),\n\t\t\t\\time, Pfunc({ |ev|\t// check for overlap if mono flag is true\n\t\t\t\tvar time = ev[\\time];\n\t\t\t\t\t// negative time value defaults to entire buffer dur\n\t\t\t\t(time < 0).if({ time = ~bufTimes.wrapAt(ev[\\bufIndex]) / ev[\\rate] });\n\t\t\t\t\t// compensate for env ramp in/out\n\t\t\t\t~mono.if({\n\t\t\t\t\ttime = min(time, ev[\\delta] / thisThread.clock.tempo)\n\t\t\t\t});\n\t\t\t\t~compensateEnv.if({\n\t\t\t\t\t(time - ((ev[\\attack] - ev[\\decay]) * ~compensateAmount)).max(0.001)\n\t\t\t\t}, { time });\n\t\t\t})\n\t\t]\n\t};\n\t\n\t~pbindPreAction = nil;\t\t// custom action to run before building Pbind can be written here\n\t~pbindPostAction = nil;\t\t// same, after building Pbind\n\n\t~doPreAction = { \n\t\tFunc.exists(~pbindPreAction).if({\n\t\t\tFunc(~pbindPreAction).doAction\n\t\t}, {\n\t\t\t~pbindPreAction.value\n\t\t});\n\t};\n\n\t~doPostAction = { |out|\n\t\tFunc.exists(~pbindPostAction).if({\n\t\t\tFunc(~pbindPostAction).doAction(out)\n\t\t}, {\n\t\t\t~pbindPostAction.(out)\n\t\t});\n\t};\n\t\n\t~sendSynthDef = {\n\t\tvar\tsynthdesc;\n\t\t~def.do({ |def|\n\t\t\tif((synthdesc = SynthDescLib.global[def]).notNil) {\n\t\t\t\tsynthdesc.send(s);\n\t\t\t};\n\t\t});\n\t};\n\n\t~asPattern = { \n\t\tvar\tout;\n\t\t~prepareForPlay.value;\t// one use is streams that must persist past 1 bar\n\t\t~sendSynthDef.value;\n\t\tPnNilSafe(Plazy(e {\n\t\t\t~doPreAction.value;\n\t\t\tout = ~makePbindArray.value;\n\t\t\tout = ~addArgPairs.(out);\n\t\t\tout = ~doPostAction.(out) ? out;\t// do postprocessing on pbind pairs\n\t\t\tPbind(*out);\n\t\t}), inf);\n\t};\n\t\n\t~freeCleanup = #{ \n\t\t~iMadeMixer.if({ ~chan.free });\n\t\t~buffers.free;\n\t\t~free.value\t// did you make any other resources?\n\t};\t\n}) => PR(\\bufPerc);\n\n\n// use functions to make a pack of synthdefs\n// alternately, supply synthdef names for preexisting defs\n// can also supply Patches (compound Patches are not supported yet)\n// it's assumed that the def contains a fixed-length envelope that will free the node (doneAction:2)\n\nPR(\\bufPerc).v.clone({\n\t~defs = #[0];\n\t~requiredKeys = #[\\objects, \\amps];\n\t\t// user extensible: define your own functions to add objects as synthdefs\n\t\t// String and Symbol are supported by nil\n\t~classActions = IdentityDictionary[\n\t\t'SynthDef' -> \\makeSynthDef,\t\t// as it happens, these can be the same b/c of asSynthDef\n\t\t'Function' -> \\makeFnDef,\n\t\t'Patch' -> \\makePatchDef,\n\t\t'WrapPatch' -> \\makePatchDef,\n\t\t'FxPatch' -> \\makePatchDef\n\t];\n\t~patchesToFree = List.new;\n\t\t// now, instead of loading buffers, we load synthdefs\n\t\t// using names defined in bufPerc, though\n\t~loadBufs = #{ \n\t\t~buffers.notNil.if({ ~buffers.free });\n\t\t\t// .value allows function to create objects array dynamically\n\t\t~buffers = ~objects.value.collect({ |obj| \n\t\t\t~makeDefForObject.(obj).asSymbol\n\t\t});\n\t};\n\t~makeDefForObject = #{ |obj|\n\t\tvar return;\n\t\t(return = ~classActions[obj.class.name]).notNil.if({\n\t\t\treturn = return.envirGet.(obj)\n\t\t});\n\t\treturn ?? { obj }\t// if nothing, return the object itself\n\t};\n\t~makeFnDef = #{ |fn|\n\t\tvar def;\n\t\tdef = fn.asSynthDef(outClass: \n\t\t\t(~isFx ? false).if({ \\ReplaceOut }, { \\Out })).add;\n\t\tdef.name\n\t};\n\t~makePatchDef = #{ |patch|\n\t\tvar def;\n\t\tdef = patch.asSynthDef.add;\n\t\t~patchesToFree.add(patch);\n\t\tdef.name\n\t};\n\t~makeSynthDef = #{ |def| def.add.name };\n\t~replaceDef = { |i, obj|\n\t\t(i >= ~buffers.size).if({\n\t\t\t~addBuf.(obj);\n\t\t}, {\n\t\t\t~chan.server.sendMsg(\\d_free, ~buffers[i]);\n\t\t\t~buffers[i] = ~makeDefForObject.(obj).asSymbol;\n\t\t\t~buffers[i]\n\t\t});\n\t};\n\t\n\t~addBuf = {  \"Not yet implemented.\".warn; };\n\n\t~makePbindArray = { \n\t\t[\\amp, ~makeAmpPattern.value,\n\t\t\t\t// rest if 0, else give synthdef name\n\t\t\t\\defIndex, ~makePattern.(\\defs),\n\t\t\t\\instrument, Pfunc({ |ev|\n\t\t\t\t(ev[\\amp] > 0).if({\n\t\t\t\t\t~buffers.wrapAt(ev[\\defIndex])\n\t\t\t\t}, { \\rest });\n\t\t\t}),\n\t\t\t\\chan, Pfunc({ ~chan }),\n\t\t\t\\delta, ~makeDeltaPattern.value\n\t\t]\n\t};\n\n\t~superfree = ~freeCleanup;\n\t~freeCleanup = { \n\t\t~patchesToFree.do(_.free);\n\t\t~superfree.value;\n\t};\n\n}) => PR(\\defPerc);\n\nProtoEvent.composite(#[singleSynthTrigger, singleSynthPlayNotify]) => ProtoEvent(\\defTrigEvent);\n\nPR(\\defPerc).v.clone({\n\t~event = (eventKey: \\defTrigEvent);\n\t~alwaysReset = true;\n\t~isFx = false;\n\t~superprep = ~prep;\n\t~prep = {\n\t\t~superprep.();\n\t\t\t// synthdefs are inited after MixerChannel is ready, so...\n\t\t~chan.doWhenReady({\n\t\t\t~eventInitArgs = { () } ! (~buffers.size);\n\t\t});\n\t};\n\t~makePbindArray = { \n\t\t[\\trig, ~makeAmpPattern.value,\n\t\t\t\t// rest if 0, else give synthdef name\n\t\t\t\\defIndex, ~makePattern.(\\defs),\n\t\t\t\\instrument, Pfunc({ |ev| ~buffers[ev[\\defIndex]] }),\n\t\t\t\\node, Pfunc({ |ev|\n\t\t\t\t(ev[\\trig] > 0).if({\n\t\t\t\t\t~nodes.wrapAt(ev[\\defIndex]) ?? { \\dummy }\n\t\t\t\t}, { \\rest });\n\t\t\t}),\n\t\t\t\\chan, Pfunc({ ~chan }),\n\t\t\t\\delta, ~makeDeltaPattern.value\n\t\t]\n\t};\n\t\t// SynthDesc msgFunc expects args to exist in the event\n\t\t// for simplicity they'll go in the event's proto\n\t\t// but you might have different inits for different synths\n\t\t// so the protos are kept in an array -- see the .collect\n\t\t// in asPattern for their use in playing events\n\t~setInitArgsInEvent = { |node, i|\n\t\tvar\tproto = ~eventInitArgs[i] ?? { () },\n\t\t\treturn;\n\t\t(return = ~initArgs.value(node, i)).pairsDo({ |key, val|\n\t\t\tproto.put(key, val.value);\n\t\t});\n\t\tproto.put(\\outbus, ~chan.inbus.index)\n\t\t\t.put(\\out, ~chan.inbus.index)\n\t\t\t.put(\\i_out, ~chan.inbus.index);\n\t\t~eventInitArgs[i] = proto;\n\t\treturn\n\t};\n\n\t~recvEventNotify = { |node, event|\n\t\t~nodes[event[\\defIndex]] = node;\n\t\t~nodeEventKeys[event[\\defIndex]] = \\singleSynthTrigger;\n\t};\n\n\t~asPattern = {\n\t\tPseq([\n\t\t\tPfuncn({\t// first, initialize node arrays\n\t\t\t\tvar latency;\n\t\t\t\t(~nodes.size == 0).if({\n\t\t\t\t\t\t// first event for each index must be to play the node,\n\t\t\t\t\t\t// then notify me\n\t\t\t\t\t~nodeEventKeys = \\singleSynthPlayNotify ! ~buffers.size;\n\t\t\t\t\t~nodes = Array.newClear(~buffers.size);\n\t\t\t\t});\n\t\t\t\t(play: 0, delta: 0)\n\t\t\t}, 1),\n\t\t\tPnNilSafe(Plazy(e {\n\t\t\t\tvar\tout;\n\t\t\t\t~doPreAction.value;\n\t\t\t\tout = ~makePbindArray.value;\n\t\t\t\tout = ~addArgPairs.(out);\n\t\t\t\tout = ~doPostAction.(out) ? out;\t// do postprocessing on pbind pairs\n\t\t\t\tPbind(*out);\n\t\t\t}), inf).collect({ |ev|\n\t\t\t\tev.proto = ~eventInitArgs[ev[\\defIndex]];\n\t\t\t\t\t// which one of the composite events to use?\n\t\t\t\tev.protoEvent = ~nodeEventKeys[ev[\\defIndex]];\n\t\t\t\tev\n\t\t\t});\n\t\t]);\n\t};\n\t\n\t~stopCleanup = {\n\t\tvar\tlatency, hasGate;\n\t\t(~nodes.size > 0).if({\n\t\t\tlatency = (~leadTime !? { ~leadTime / ~clock.tempo })\n\t\t\t\t+ ~chan.server.latency;\n\t\t\t~nodes.do({ |node, i|\n\t\t\t\tif(node.notNil) {\n\t\t\t\t\thasGate = SynthDescLib.global[~buffers[i]].tryPerform(\\hasGate);\n\t\t\t\t\t~chan.server.sendBundle(latency,\n\t\t\t\t\t\t(~hasGate ? false).if({ node.setMsg(\\gate, 0) }, { node.freeMsg }))\n\t\t\t\t};\n\t\t\t});\n\t\t\t~nodes = nil;\n\t\t});\n\t};\n}) => PR(\\defTrig);\n\n// loads the whole beat into 1 buffer; user specifies start positions for segments and times (beats)\n// multiple files are supported -- use bufs to select file\nPR(\\bufPerc).v.clone({\n\t~requiredKeys = #[bufPaths, amps, start];\n\t~segStart = #[[0]];\t// default, 1 segment encompassing the whole file\n\t~start = #[0];\n\t~mono = true;\n\t~compensateEnv = true;\n\t\n\t~makeStartTimes = { \n\t\t~makePatternFromArray.(~start, 1).collect(e { |st, event|\n\t\t\t~segStart.wrapAt(event[\\bufIndex]).wrapAt(st)\n\t\t});\n\t};\n\t\t\n\t~makePbindArray = { \n\t\t[\\amp, ~makeAmpPattern.value,\n\t\t\t\\bufIndex, ~makePattern.(\\bufs),\n\t\t\t\\bufnum, Pfunc({ |ev|\n\t\t\t\t~buffers[ev[\\bufIndex]].bufnum\n\t\t\t}),\n\t\t\t\\rate, ~makePattern.(\\rates),\n// if user specifies times, they should be scaled by tempo. default times are in seconds\n\t\t\t\\start, ~makeStartTimes.value,\n\t\t\t\\time, ~times.notNil.if({\n\t\t\t\t~makePattern.(\\times) / thisThread.clock.tempo\n\t\t\t}, {\n\t\t\t\tPfunc({ |ev|\n\t\t\t\t\t~bufTimes[ev[\\bufIndex]]\n\t\t\t\t});\n\t\t\t}),\n\t\t\t\t// rest if 0, else give synthdef name\n\t\t\t\\instrument, Pfunc({ |ev|\n\t\t\t\t(ev[\\amp] > 0).if({ ~def }, { \\rest });\n\t\t\t}),\n\t\t\t\\chan, Pfunc({ ~chan }),\n\t\t\t\\latencyAdjust, Pfunc({ |ev| ~deltaAdjust.wrapAt(ev[\\bufIndex]) }),\n\t\t\t\\latency, Pfunc({ |ev| (ev[\\latency] ? 0) + (ev[\\latencyAdjust] ? 0) }),\n\t\t\t\\delta, ~makeDeltaPattern.value,\n\t\t\t\\attack, ~makePattern.(\\attack), // Pfunc({ ~attack }),\n\t\t\t\\decay, ~makePattern.(\\decay), // Pfunc({ ~decay }),\n\t\t\t\\time, Pfunc({ |ev|\t// check for overlap if mono flag is true\n\t\t\t\tvar time = ev[\\time];\n\t\t\t\t\t// negative time value defaults to entire buffer dur\n\t\t\t\t(time < 0).if({ time = ~bufTimes.wrapAt(ev[\\bufIndex]) / ev[\\rate] });\n\t\t\t\t\t// compensate for env ramp in/out\n\t\t\t\t~mono.if({\n\t\t\t\t\ttime = min(time, ev[\\delta] / thisThread.clock.tempo)\n\t\t\t\t});\n\t\t\t\t~compensateEnv.if({\n\t\t\t\t\t(time - ((ev[\\attack] - ev[\\decay]) * ~compensateAmount)).max(0.001)\n\t\t\t\t}, { time });\n\t\t\t})\n\t\t]\n\t};\n}) => PR(\\break);\n\nAbstractChuckArray.defaultSubType = saveSubType;\n\n// a simple soundfile-segment player\n// uses bufPerc's buffer management methods but constructs events from streams, not arrays\n\nPR(\\abstractProcess).v.clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~requiredKeys = #[bufPaths];\n\t~def = \\bufGrain;\n\t~bufCoords = #[[0, -1]];\n\t~attack = 0.005;\n\t~decay = 0.02;\n\t~argPairs = [];\t// there must be a default or ~argPairsStream fails\n\t~postMCCreation = nil;\t\t// put in your own user preparation func here\n\t~timeConversion = { |time, ev| time };\n\t~argPairs_ = { |args|\n\t\t~argPairs = args;\n\t\t~argPairsStream = Pbind(*~argPairs).asStream;\n\t};\n\t\t// required: put in a pattern factory here\n\t~asPattern = {\n\t\t\t// assume that if we're calling asPattern, we want to reset all streams\n\t\t~sendSynthDef.value;\n\t\t~argPairsStream = Pbind(*~argPairs).asStream;\n\t\tPbind(\\instrument, BPStream(\\def),\n\t\t\t\\bufIndex, BPStream(\\bufIndex),\n\t\t\t\\bufnum, Pfunc({ |ev| ~buffers[ev[\\bufIndex]].bufnum }),\n\t\t\t\\time, BPStream(\\time).collect({ |time, ev| ~timeConversion.(time, ev) }),\n\t\t\t\\rate, BPStream(\\rate),\n\t\t\t\\start, BPStream(\\start),\n\t\t\t\\amp, BPStream(\\amp),\n\t\t\t\\attack, BPStream(\\attack),\n\t\t\t\\decay, BPStream(\\decay),\n\t\t\t\\chan, ~chan,\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\time, Pkey(\\time) / Pfunc({ thisThread.clock.tempo })\n\t\t).collect({ |ev|\n\t\t\t~argPairsStream !? { ev = ~argPairsStream.next(ev) };\n\t\t\tev\n\t\t});\n\t};\n}).import((bufPerc: #[prep, loadBufs, fixBufTime, replaceBuf, addBuf, freeCleanup]))\n\t=> PR(\\basicBufferPlayer).subType_(\\bufPlayer);\n",
    "startup15-contrapunct.scd": "\n// Basically deprecated. This scheme was too complicated and prone to break.\n// Use at your own risk. Good luck!\n\nvar saveSubtype = AbstractChuckArray.defaultSubType;\n\nAbstractChuckArray.defaultSubType = \\contrapunct;\n\n// converts event stream into event pattern so that other wrappers like Pfindur can be used\n{ |holder, driverEvent|\n\tPrt({ |inEvent|\n\t\tvar\tevent;\n\t\tloop {\n\t\t\tevent = holder.getEvent(inEvent, driverEvent);\n\t\t\tinEvent = event.yield;\n\t\t}\n\t})\n} => Func(\\defaultStreamWrapper).subType_(\\contrapunct);\n\n{ |pattern| pattern } => Func(\\defaultPatternWrapper);\n\n{ |pattern| Pfin(1, pattern) } => Func(\\oneChildEvent);\n\n// args: child event, bpholder, driver event\n{ |event| event } => Func(\\defaultEventUpdater);\n\n// a holder for a process that is being driven by another\n// most important parms:\n// modifyDriver -- a func to parse the driver event before wrapping\n// swrapPattern -- wrap the bp's stream to make it a pattern\n// pwrapPattern -- wrap the pattern to modify its output (Pfindur is applied automatically)\n// updatePattern -- modify each child event before returning\n// quant -- when to start child if coordinator is playing and child is not\nPR(\\abstractProcess).v.clone({\n\t~prepare = { |bp, parms|\n\t\tvar\tparmsToInsert;\n\t\t~bp = bp;\n\t\t\t// scorched-earth handling of parms; eventually I'll add safety checks?\n\t\tparmsToInsert = bp.v.coordParms ?? { IdentityDictionary.new };\n\t\tparms.respondsTo(\\keysValuesDo).if({ parmsToInsert.putAll(parms); });\n\t\tcurrentEnvironment.putAll(parmsToInsert);\n\t\t(bp.v.alwaysReset == true).if({ ~doReset = true });\n\t\t~makeStreamForKey.(\\swrap);\n\t\t~makeStreamForKey.(\\pwrap);\n\t\t~makeStreamForKey.(\\update);\n\t\tbp.v.isDriven = true;\n\t\t~wasPlaying = bp.isPlaying;\n\t\tbp.v.isPlaying = false;\n\t\t~inited = false;\n\t\tbp.addDependant(currentEnvironment);\t// get notifications from child process\n\t\tbp.changed(\\driven);\n\t\tcurrentEnvironment\n\t};\n\n\t~prepForPlay = { \n\t\t~inited.not.if({\n\t\t\t~bp.v.eventStreamPlayer.isNil.if({\n\t\t\t\t~bp.prepareForPlay;\n\t\t\t}, {\n\t\t\t\t~bp.populateAdhocVariables;\n\t\t\t});\n\t\t});\n\t\t~inited = true;\n\t\tcurrentEnvironment\n\t};\n\n\t\n\t~update = \\defaultEventUpdater.asPattern;\n\t~swrap = \\defaultStreamWrapper.asPattern;\n\t~pwrap = \\defaultPatternWrapper.asPattern;\n\t\n\t\t// =>.swrap for func to wrap the child stream in a pattern\n\t~wrapChildStream = { |driverEvent|\n\t\tvar\tpattern = Func(~swrapStream.next(driverEvent)).doAction(driverEvent);\n\t\t\t// if the next child event was supposed to happen some time after the sync point,\n\t\t\t// add a dummy event to compensate\n\t\t\t// nextSync is unchanged from the last driver event\n\t\t(~autoOffset and: { \n\t\t\t\t~nextChildEventTime.isNumber and: {\n\t\t\t\t~nextSync.isNumber and: {\n\t\t\t\t~nextChildEventTime > ~nextSync } } }).if({\n\t\t\tPseq([(play: 0, delta: ~nextChildEventTime - ~nextSync), pattern], 1)\n\t\t}, {\n\t\t\tpattern\n\t\t});\n\t};\n\t\n\t\t// user hook to provide a Pbindf or other processing\n\t~wrapPattern = { |pattern, driverEvent|\n\t\tpattern\n\t};\n\t\n\t\t// =>.pwrap for func to wrap the pattern holding the stream\n\t\t// modifyDriver should set offset\n\t~prWrapPattern = { |pattern, driverEvent|\n\t\tvar\tdeltaToNextSync = driverEvent.deltaToNextSync;\n\t\tpattern = Func(~pwrapStream.next(driverEvent)).doAction(pattern, driverEvent)\n\t\t\t? pattern;\n\t\tpattern = ~wrapPattern.(pattern, deltaToNextSync);\n//\t\t((~truncatePattern ? true) and: { deltaToNextSync.notNil }).if({\n\t\tdeltaToNextSync.notNil.if({\n\t\t\tPfindur(deltaToNextSync, pattern)\n\t\t}, {\n\t\t\tpattern\n\t\t});\n\t};\n\t\n\t~event = { ~bp.v.event };\n\n\t~getEvent = { |inEvent, driverEvent|\n\t\tvar\tevent = ~bp.v.eventStream.next(~event.value);\n//thisThread.clock.beats.debug(\"bpholder-getEvent\");\n//event.debug(\"bpholder-getEvent\");\n//event[\\note].postcs;\n//event[\\play].postcs;\n\t\tevent = event !? { Func(~updateStream.next(driverEvent))\n\t\t\t.doAction(event, /*currentEnvironment,*/ driverEvent)/*.debug(\"return value from func\")*/ ? event };\n\t\t~nextChildEventTime = event.notNil.if({ thisThread.clock.beats + event.delta }, { nil });\n//event.debug(\"output event\");\n\t\tevent\n\t};\n\t\n//\t~nextSync = ~nextChildEventTime = 0;\n\t~autoOffset = true;\n\t~wasTriggeredExternally = false;\n\t~offset = 0;\n\t~lastOffset = 0;\t// this is the offset from the previous event\n\n\t~doEvent = { |driverEvent, childMetaEvent|\n\t\tvar\tinEvent, /*event, */pattern;\n\n\t\t\t// processDriverEvent goes false when the child is released by .stop or .play\n\t\t\t// in that case, we should ignore the driver event\n\t\t(~processDriverEvent ? true)/*.debug(\"child event for %\".format(~bp.collIndex))*/.if({\n\t\t\t~prepForPlay.value;\n\t\t\t\t// modifyDriver must set the offset\n\t\t\t~lastDriverEventID = driverEvent[\\ID];\n\t\t\tdriverEvent = ~modifyDriver.(driverEvent.copy, childMetaEvent) ? driverEvent;\n//[thisThread.clock.beats, driverEvent.delta, ~offset, ~lastOffset, driverEvent.delta + ~offset - ~lastOffset].debug(\"now, delta, offset, lastOffset, deltaToNextSync\");\n\t\t\tdriverEvent.put(\\deltaToNextSync, driverEvent.delta + ~offset - ~lastOffset);\n//driverEvent.debug(\"driverEvent\");\n\t\t\t(driverEvent.skipChildren.tryPerform(\\includes, ~bp.collIndex) ? false).not.if({\n\t\t\t\tinEvent = ~bp.v.event.copy.put(\\driver, driverEvent);\n\t\t\t\t~bp.v.driverEvent = driverEvent;\n//inEvent.debug(\"inEvent\");\n\n\t\t\t\tpattern = ~wrapChildStream.(driverEvent, childMetaEvent);\n//pattern.asCompileString.debug(\"wrapChildStream result\");\n\t\t\t\tpattern = ~prWrapPattern.(pattern, driverEvent, childMetaEvent);\n//pattern.asCompileString.debug(\"prWrapPattern result\");\n\n// what is the termination condition? may have to use CleanupStream\n// no -- register as dependent of bp\n\t\n\t\t\t\t\t// play the child until the next sync point\n\t\t\t\tthisThread.clock.sched(0,\n\t\t\t\t\t~eventStreamPlayer = PausableEventStreamPlayer(pattern.asStream, inEvent)\n\t\t\t\t\t\t.refresh);\n\t\t\t});\n\t\t\t\n\t\t\t~lastOffset = ~offset;\n\t\t\t~nextSync = thisThread.clock.beats + driverEvent[\\deltaToNextSync];\n\n\t\t\t(process: ~bp.collIndex, delta: driverEvent.deltaToNextSync);\n\t\t});\n\t};\n\t\n\t~abortStream = {\n\t\t~eventStreamPlayer.stop;\n\t};\n\n\t~update = { |obj, changer|\n//this.dumpBackTrace;\n//[obj.asCompileString, changer].debug(\"bpholder-update\");\n\t\tcase { #[\\play, \\stop].includes(changer) } {\n\t\t\t\t\t\t// set flag to return a nil metaevent next time\n\t\t\t\t\t~processDriverEvent = false;\n\t\t\t\t\t~wasPlaying = (changer == \\play);\n\t\t\t\t\t~wasTriggeredExternally = true;\n\t\t\t\t\tcurrentEnvironment.changed(\\lostChild);\n\t\t\t\t}\n\t\t\t{ changer == \\driven } {\n\t\t\t\t\t~processDriverEvent = true;\n\t\t\t\t}\n\t\t\t{ changer == \\free } {\n\t\t\t\t\t~abortStream.value;\n\t\t\t\t\t~wasPlaying = false;\n\t\t\t\t\t~wasTriggeredExternally = true;\n\t\t\t\t\t~processDriverEvent = false;\n\t\t\t\t\tcurrentEnvironment.changed(\\lostChild);\n\t\t\t\t}\n\t};\n\t\n\t// more...\n}) => PR(\\bpHolder).subType_(\\contrapunct);\n\nPR(\\abstractProcess).v.clone({\n\t~childProto = \\bpHolder;\n\t~alwaysReset = true;\t// once I stop, my event stream is invalid\n\t~event = (eventKey: \\dummy);\n\t\t// using PQ because children may offset their sync points\n\t\t// and occur earlier or later than the next driver event\n\t~prep = { \n\t\t~children = IdentityDictionary.new;\n\t\t~queue = PriorityQueue.new;\n\t\t~driverEventID = 0;\n\t};\n\t\n\t\t// what else? prepare for play?\n\t~driver_ = { |bp|\n\t\tvar syncTime;\n\t\t(~driver !== bp).if({\n\t\t\t~driver.notNil.if({\n\t\t\t\t~releaseDriver.value;\n\t\t\t});\n\t\t\t~driver = bp;\n\t\t\t~clock.isNil.if({\n\t\t\t\t~clock = ~driver.v.clock;\n\t\t\t}, {\n\t\t\t\t(~clock != ~driver.v.clock).if({\n\t\t\t\t\t\"Clocks do not match. There may be scheduling problems.\".warn;\n\t\t\t\t});\n\t\t\t});\n\t\t\tbp.v.isDriven = true;\n\t\t\t~driverWasPlaying = bp.isPlaying;\n\t\t\tbp.v.eventStreamPlayer.isNil.if({\n\t\t\t\tbp.prepareForPlay;\n\t\t\t}, {\n\t\t\t\tbp.populateAdhocVariables;\n\t\t\t});\n\t\t\t\t// automatically play coordinator if the driver was playing and I am not\n\t\t\t\t// so that the driver proceeds seamlessly\n\t\t\t((syncTime = bp.v[\\eventStreamPlayer].tryPerform(\\nextBeat)).notNil \n\t\t\t\t\tand: { ~isPlaying.not }).if({\n\t\t\t\tBP(~collIndex).play(argQuant: AbsoluteTimeSpec(syncTime));\n\t\t\t\tbp.v.eventStreamPlayer.stop;\n\t//\t\t\tbp.stopNow(notify: false, doCleanup: false);\n\t\t\t});\n\t\t\tbp.changed(\\driven);\n\t\t\tbp.addDependant(currentEnvironment);\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t\t// release driver from control -- should not be called directly by user\n\t~releaseDriver = { |doReplay|\n\t\tvar\tsyncTime, nextEvent, oldStream;\n\t\t~driver.notNil.if({\n\t\t\t~driver.removeDependant(currentEnvironment);\n\t\t\t~driver.v.isDriven = false;\n\t\t\t~driver.v.eventStream = Pevent(Pseq([~nextEvent, ~driver.v.eventStream], 1),\n\t\t\t\t~driver.v.event).asStream;\n\t\t\t~driver.v.eventStreamPlayer = PausableEventStreamPlayer(~driver.v.eventStream,\n\t\t\t\t~driver.v.event).refresh;\n\t\t\t((doReplay ? true) and: { ~driver.v.eventStream.notNil\n\t\t\t\tand: { (syncTime = ~nextSyncTime.(~saveCurrentEvent)).notNil\n\t\t\t\tand: { syncTime >= ~driver.v.clock.beats } } }).if({\n//~nextEvent[\\note].asString.debug(\"nextevent's note\");\n//\"making new event stream\".debug;\n\t\t\t\t~driver.v.clock.schedAbs(syncTime, ~driver.v.eventStreamPlayer);\n\t\t\t\t~driver.v.isPlaying = true;\n\t\t\t}, {\n\t\t\t\t~driver.v.isPlaying = false;\n\t\t\t});\n\t\t\t~driver.changed(#[stop, play][~driver.isPlaying.binaryValue]);\n\t\t\t~driver = nil;\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t~add = { |bp, parms|\n\t\tvar\tnextSync, childObj, proto = parms.atBackup(\\childProto, currentEnvironment);\n\t\t(bp.exists and: { bp !== ~driver }).if({\n\t\t\t~children.put(bp.collIndex, childObj = PR(proto).v.copy.prepare(bp, parms));\n\t\t\tchildObj.addDependant(currentEnvironment);\n\t\t\t(~clock != bp.v.clock).if({\n\t\t\t\t\"Clocks do not match. There may be scheduling problems.\".warn;\n\t\t\t});\n\t\t\t\t// if I am playing and I know when I am going to fire next\n\t\t\t(~isPlaying and: { (nextSync = ~nextSyncTime.value).notNil }).if({\n\t\t\t\t\t// is the bp playing? if so, help it make the transition\n\t\t\t\tchildObj.wasPlaying.if({\n\t\t\t\t\t~clock.schedAbs(nextSync - 0.05, {\n\t\t\t\t\t\tchildObj.nextSync = nextSync;\n\t\t\t\t\t\tchildObj.nextChildEventTime = bp.v.eventStreamPlayer\n\t\t\t\t\t\t\t.tryPerform(\\nextBeat);\n\t\t\t\t\t\tnil\n\t\t\t\t\t});\n//nextSync.debug(\"nextSync\");\n//thisThread.clock.beats.debug(\"current LT\");\n\t\t\t\t\t~addChildToQueue.(childObj, nextSync);\n\t\t\t\t}, {\t\t// else start the child on its normal quant\n\t\t\t\t\t\t// run normally until the following sync point\n//bp.eventSchedTime(childObj.quant).debug(\"starting % play at\".format(bp.collIndex));\n\t\t\t\t\tbp.play(childObj.quant, ~clock, childObj.doReset, notify: false);\n\t\t\t\t\t~clock.schedAbs(bp.eventSchedTime(childObj.quant) - 0.05, e {\n//\t\t\t\t\t\tcurrentEnvironment.use({\n\t\t\t\t\t\t\t(nextSync = ~nextSyncTime.value).notNil.if({\n//thisThread.clock.beats.debug(\"now\");\n//nextSync.debug(\"adding child to queue for sync time\");\n\t\t\t\t\t\t\t\t~addChildToQueue.(childObj, nextSync);\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tbp.stopNow;\n\t\t\t\t\t\t\t});\n//\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}, {\n\t\t\t\"% is already the driver, can't add as child.\".format(bp.asCompileString).warn;\n\t\t});\n\t};\n\t\n\t\t// this is sufficient because routine will not refresh the child in the queue\n\t\t// if it can't find it in the ~children dictionary\n\t~removeChild = { |key, freeing|\n\t\tvar bpwrap = ~children.removeAt(key), syncTime, esp;\n\t\tbpwrap.notNil.if({\n\t\t\tbpwrap.bp.removeDependant(bpwrap);\n\t\t\tbpwrap.removeDependant(currentEnvironment);\n\t\t\tbpwrap.bp.v.isDriven = false;\n\t\t\t\t// to restart the child's native stream,\n\t\t\t\t// - I must be playing (or been freed at this logical time)\n\t\t\t\t// - the child must have been playing before becoming my slave\n\t\t\t\t//   or it must have been .played directly\n\t\t\t((~isPlaying ? false) or: { ~wasPlayingWhenFreed ? false }).if({\n\t\t\t\t(bpwrap.wasPlaying/*.debug(\"removechild-wasplaying\")*/).if({\n\t\t\t\t\t\t// wasTriggeredExternally == true on .play or .stop on the child BP\n\t\t\t\t\tbpwrap.wasTriggeredExternally/*.debug(\"wasTriggeredExternally\")*/.if({\n\t\t\t\t\t\t\t// there's some time left before the .play kicks in\n\t\t\t\t\t\t((syncTime = ~nextSyncTime.value/*.debug(\"nextSync\")*/) < bpwrap.bp.eventSchedTime/*.debug(\"eventSchedTime\")*/)\n\t\t\t\t\t\t/*.debug(\"there is time remaining\")*/.if({\n\t\t\t\t\t\t\t\t// run the stream in the interim\n\t\t\t\t\t\t\t\t// by copying the eventstreamplayer, I ensure that the\n\t\t\t\t\t\t\t\t// \"real\" eventstreamplayer can be restarted in BP-play\n// some of this should be delegated to bpholder\n\t\t\t\t\t\t\t~clock.schedAbs(syncTime - 0.03, {\n//bpwrap.nextChildEventTime.debug(\"running filler stream\");\n\t\t\t\t\t\t\t\tbpwrap.bp.v.clock.schedAbs(bpwrap.nextChildEventTime,\n\t\t\t\t\t\t\t\t\tesp = bpwrap.bp.v.eventStreamPlayer.refresh.copy);\n//(bpwrap.bp.eventSchedTime - 0.03).debug(\"will stop filler stream\");\n\t\t\t\t\t\t\t\tbpwrap.bp.v.clock.schedAbs(bpwrap.bp.eventSchedTime - 0.03,\n\t\t\t\t\t\t\t\t\t{ esp.stop; nil });\n\t\t\t\t\t\t\t\tnil\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, {\n//(bpwrap.bp.eventSchedTime - 0.03).debug(\"scheduling abortStream for\");\n\t\t\t\t\t\t\tbpwrap.bp.v.clock.schedAbs(bpwrap.bp.eventSchedTime - 0.03,\n\t\t\t\t\t\t\t\t{ bpwrap.abortStream; nil });\n\t\t\t\t\t\t});\n\t\t\t\t\t}, {\t\t// removeChild was called directly\n\t\t\t\t\t\tbpwrap.abortStream;\n\t\t\t\t\t\tbpwrap.bp.v.clock.schedAbs(bpwrap.nextChildEventTime,\n\t\t\t\t\t\t\tbpwrap.bp.v.eventStreamPlayer.refresh);\n\t\t\t\t\t\tbpwrap.bp.v.isPlaying = true;\n\t\t\t\t\t\t\t// this is ok b/c child dependencies are already gone\n\t\t\t\t\t\tbpwrap.bp.changed(\\play);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\t\t\n\t\t\tbpwrap.bp.changed(#[stop, play][bpwrap.bp.isPlaying.binaryValue]);\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t~bindBP = { |bp, adverb, parms|\n\t\t(adverb == \\driver).if({\n\t\t\t~driver_.(bp);\n\t\t}, {\n\t\t\t~add.(bp, parms);\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\t\n\t~nextSyncTime = { |event|\n\t\tevent = event ? ~currentEvent;\n\t\tevent !? {\n\t\t\tevent.nextSyncTime\n\t\t\t\t?? { ~eventStreamPlayer.tryPerform(\\nextBeat) }\n//\t\t\t\t?? { event.delta + ~eventStreamPlayer.clock.beats }\n\t\t};\n\t};\n\t\n\t~addChildToQueue = { |child, time|\n\t\tvar\tnextChildEventTime;\n\t\t\t// take the bp out of the clock's queue; don't notify dependents\n\t\t\t// but only do it if the child is still accepting events\n\t\ttime/*.debug(\"calling addChildToQueue for time\")*/.notNil.if({\n\t\t\t(child.processDriverEvent/*.debug(\"child.processDriverEvent\")*/ != false).if({\n\t\t\t\t~clock.schedAbs(time - 0.03, {\n//thisThread.clock.beats.debug(\"updating nextSync at time\");\n\t\t\t\t\t(nextChildEventTime = child.bp.v.eventStreamPlayer\n\t\t\t\t\t\t\t.tryPerform(\\nextBeat))/*.debug(\"nextChildEventTime\")*/.notNil.if({\n\t\t\t\t\t\tchild.nextChildEventTime = nextChildEventTime;\n\t\t\t\t\t\tchild.nextSync = time;\n\t\t\t\t\t});\n\t\t\t\t\t(child.wasPlaying ? false).if({\n//thisThread.clock.beats.debug(\"stopping child ESP at\");\n\t\t\t\t\t\tchild.bp.stopNow(notify: false, doCleanup: false);\n\t\t\t\t\t\tnil\n\t\t\t\t\t});\n\t\t\t\t\t(child.doReset ? false).if({ child.bp.reset });\n\t\t\t\t});\n\t\t\t});\n\t\t}, {\n\t\t\t(child.wasPlaying ? false).if({\n//thisThread.clock.beats.debug(\"stopping child ESP at\");\n\t\t\t\tchild.bp.stopNow(notify: false, doCleanup: false);\n\t\t\t});\n\t\t});\n//(time ? thisThread.clock.beats).debug(\"child is added for sync time\");\n\t\tchild.bp.v.eventSchedTime = time ? thisThread.clock.beats;\n\t\t~queue.put(child.bp.v.eventSchedTime, (process: child.bp.collIndex));\n\t};\n\n\t\t// should be called only in the context of my event stream\n\t~prepareQueue = { |time|\n\t\t~children.keysValuesDo({ |key, bp|\n\t\t\t~addChildToQueue.(bp, time ? ~nextSyncTime.value ? thisThread.clock.beats);\n\t\t});\n\t\t~stream = (~driver.v.eventStream ?? { ~driver.asStream });\n//(time ? thisThread.clock.beats).debug(\"adding driver to queue\");\n\t\t~queue.put(time ? thisThread.clock.beats, (process:\\driver));\n\t\t(play:0, delta:0)\n\t};\n\t\n\t~popEvents = { \n\t\tvar\tout = List.new, time;\n\t\t~queue.notEmpty/*.debug(\"queue has items\")*/.if({\n\t\t\t\t// if there are stray events in the queue, drop them\n\t\t\t{ thisThread.clock.beats > ~queue.topPriority }.while({\n\t\t\t\t~queue.pop/*.debug(\"dropped event\")*/;\n\t\t\t});\n\t\t\ttime = ~queue.topPriority/*.debug(\"top priority\")*/;\n\t\t\t{ time == ~queue.topPriority }.while({\n\t\t\t\tout.add(~queue.pop);\n\t\t\t});\n//\"\\n\".post;\n//out.do(_.postln);\n\t\t\t\t// driver must execute first\n\t\t\tout.sort({ |a, b|\n\t\t\t\t(a.process == \\driver).binaryValue > (b.process == \\driver).binaryValue\n\t\t\t});\n\t\t});\t// if queue is empty, return nil\n\t};\n\t\n\t~nextDriverID = { ~driverEventID = ~driverEventID + 1 };\n\t\n\t~doDriverEvent = { \n\t\tvar\tevent;\n\t\t(~driver.notNil and: { (event = ~stream.next(\n\t\t\t\t~driver.v.event.copy.put(\\children, ~children.copy))).notNil }).if({\n\t\t\tevent.put(\\ID, ~nextDriverID.value);\n\t\t\t~nextEvent.isNil.if({\n\t\t\t\t~currentEvent = event;\n\t\t\t\t~nextEvent = ~stream.next(~driver.v.event.copy.put(\\children, ~children.copy))\n\t\t\t\t\t.put(\\ID, ~nextDriverID.value);\n\t\t\t}, {\n\t\t\t\t~currentEvent = ~nextEvent;\n\t\t\t\t~nextEvent = event;\n\t\t\t});\n\t\t});\n//~currentEvent[\\note].asString.debug(\"currentevent note\");\n//~nextEvent[\\note].asString.debug(\"nextevent note\");\n\t\t~currentEvent.notNil.if({\n\t\t\t~currentEvent.play;\n\t\t\t~currentEvent.put(\\process, \\driver)\n\t\t\t\t.put(\\now, thisThread.clock.beats)\n\t\t\t\t.put(\\nextSyncTime, thisThread.clock.beats + ~currentEvent.delta);\n//~currentEvent.debug(\"\\ndriver event\");\n//thisThread.clock.beats.debug(\"now\");\n//~currentEvent.nextSyncTime.debug(\"nextSyncTime\");\n\t\t\t~currentEvent\n\t\t}, {\n\t\t\tnil.yield;\t// stop immediately when driver returns nil\n\t\t});\n\t};\n\t\n\t~doChildEvent = { |evt|\n\t\tvar\tchild = ~children[evt.process];\n\t\tchild.notNil.if({\n\t\t\t\t// child's job to return the metaevent for my PQ, including offset\n\t\t\tchild.tryPerform(\\doEvent,\n\t\t\t\t(child.lastDriverEventID == ~currentEvent[\\ID]).if(~nextEvent, ~currentEvent),\n\t\t\t\tevt);\n\t\t});\n\t};\n\n\t~asPattern = { \n\t\t// how to initialize the child streams just before play?\n\t\t~eventSchedTime/*.debug(\"bpdriver-aspattern-eventschedtime\")*/.notNil.if({\n\t\t\t~clock.schedAbs(~eventSchedTime - 0.05, e {\n//\"calling prepareQueue\".debug;\n\t\t\t\t~prepareQueue.(~eventSchedTime/*.debug(\"eventSchedTime\")*/);\n\t\t\t});\n\t\t});\n\t\tPrt({\n\t\t\tvar\tqueueList, event;\n//\t\t\t~driverWasPlaying = true;\n\t\t\tloop {\n\t\t\t\t((queueList = ~popEvents.value).size > 0).if({\n//queueList.postcs;\n\t\t\t\t\tqueueList.do({ |evt|\n\t\t\t\t\t\t(evt.process == \\driver).if({\n\t\t\t\t\t\t\tevent = ~doDriverEvent.value;\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tevent = ~doChildEvent.(evt);\n\t\t\t\t\t\t\tevent.isNil.if({\n\"removing child % because event was nil\".debug(evt.process.tryPerform(\\at, \\bp).value.tryPerform(\\at, \\collIndex));\n\t\t\t\t\t\t\t\t~removeChild.(evt.process);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// not stopping on nil event here because\n\t\t\t\t\t\t\t// the end of a child stream shouldn't affect other children\n\t\t\t\t\t\tevent.notNil.if({\n\t\t\t\t\t\t\t\t// put continuation in the queue\n\t\t\t\t\t\t\t~queue.put(thisThread.clock.beats + event.delta, event);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}, {\n\t\t\t\t\t~queue.isEmpty.if({\n\t\t\t\t\t\tnil.yield\t\t// terminate if nothing is in the queue\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t(~queue.topPriority > thisThread.clock.beats).if({\n\t\t\t\t\t(play:0, delta: ~queue.topPriority - thisThread.clock.beats).yield;\n\t\t\t\t}, {\t\t// something is wrong with the queue, so abort\n\t\t\t\t\t\"Queue top priority is %, before current time %. Aborting.\"\n\t\t\t\t\t\t.format(~queue.topPriority, thisThread.clock.beats).warn;\n\t\t\t\t\tnil.yield;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\t\n\t~stopCleanup = { |auto|\n//\"bpdriver-stopCleanup\".debug;\n//\t\tauto.if({\n//\t\t\t~resumeChildren.value;\n//\t\t});\n\t\t~children.do(_.abortStream);\n\t\t~queue.clear;  // events in the queue are now invalid\n\t\t~stopAction.value;\t// user-definable\n\t\t~saveCurrentEvent = ~currentEvent;\t// for restarting driver & children upon free\n\t\t~currentEvent = nil;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~freeCleanup = { \n\"bpdriver-freeCleanup\".debug;\n\t\t~children.keys.do({ |key|\n//key.debug(\"setting wasPlaying, removing child\");\n\t\t\t~children[key].wasPlaying = ~wasPlayingWhenFreed;\n\t\t\t~removeChild.(key, true);\t// true == removing child on free\n\t\t});\n//\"releasing driver\".debug;\n\t\t~releaseDriver.value;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~update = { |changer, what|\n\t\tswitch(what)\n\t\t\t{ \\lostChild } { \n\"removing child because of lostChild\".debug(changer.bp.collIndex);\n\t\t\t~removeChild.(changer.bp.collIndex) }\n\t\t\t{ \\reset } {   // resync current/next events\n\t\t\t\t(changer === ~driver).if({\t// but only if the driver was reset\n\t\t\t\t\t~nextEvent = nil\n\t\t\t\t})\n\t\t\t}\n\t\t\t{ \\free } {\n\t\t\t\t(changer === ~driver).if({\n\t\t\t\t\t~releaseDriver.value;\n\t\t\t\t});\n\t\t\t}\n\t};\n}) => PR(\\bpDriver).subType_(\\contrapunct);\n\n\nPR(\\bpHolder).v.clone({\n\t\t// child processes should not have .prepareForPlay called on them\n\t~prepForPlay = {\n\t\t(~inited ? false).not.if({\n\t\t\t~bp.v.event = ~bp.prepareEvent;\n\t\t\t~bp.populateAdhocVariables(thisThread.clock);\n\t\t});\n\t\t~inited = true;\n\t};\n\t\n\t~doEvent = { |driverEvent, childMetaEvent|\n\t\tvar\tinEvent, pattern;\n\n\t\t\t// processDriverEvent goes false when the child is released by .stop or .play\n\t\t\t// in that case, we should ignore the driver event\n\t\t(~processDriverEvent ? true).if({\n\t\t\t~prepForPlay.value;\n\t\t\t\t// modifyDriver must set the offset\n\t\t\t~lastDriverEventID = driverEvent[\\ID];\n\t\t\tdriverEvent = ~modifyDriver.(driverEvent.copy, childMetaEvent) ? driverEvent;\n\t\t\tdriverEvent.put(\\deltaToNextSync, driverEvent.delta + ~offset - ~lastOffset);\n\t\t\t(driverEvent.skipChildren.tryPerform(\\includes, ~bp.collIndex) ? false).not.if({\n\t\t\t\tinEvent = ~bp.v.event.copy.put(\\driver, driverEvent);\n\t\t\t\t~bp.v.driverEvent = driverEvent;\n\t\t\t\t\n\t\t\t\t~bp.v.preparePlay;\n\t\t\t\t~bp.v.eventStream = ~bp.v.asPattern(driverEvent).asStream;\n\n\t\t\t\tpattern = ~wrapChildStream.(driverEvent, childMetaEvent);\n\t\t\t\tpattern = ~prWrapPattern.(pattern, driverEvent, childMetaEvent);\n\n\t\t\t\t\t// play the child until the next sync point\n\t\t\t\tthisThread.clock.sched(0,\n\t\t\t\t\t~eventStreamPlayer = PausableEventStreamPlayer(pattern.asStream, inEvent)\n\t\t\t\t\t\t.refresh);\n\t\t\t});\n\t\t\t\n\t\t\t~lastOffset = ~offset;\n\t\t\t~nextSync = thisThread.clock.beats + driverEvent[\\deltaToNextSync];\n\n\t\t\t(process: ~bp.collIndex, delta: driverEvent.deltaToNextSync);\n\t\t});\n\t};\n}) => PR(\\bpArpegHolder).subType_(\\contrapunct);\n\n\nAbstractChuckArray.defaultSubType = saveSubtype;\n",
    "startup20-basicChordBits.scd": "\n// other basic functions\n\n// make a set of wavetables for vosc3map to avoid aliasing\n// user's responsibility to set numbufs and lowMidi appropriately\n\n{ |numbufs, server, numFrames, lowMidi, spectrumFunc|\n\tnumbufs = numbufs ? 8;\n\tserver = server ? Server.default;\n\tnumFrames = numFrames ? 2048;\n\t\t// default is sawtooth\n\tspectrumFunc = spectrumFunc ? { |numharm| (1..numharm).reciprocal };\n\tlowMidi = (lowMidi ? 48) / 12;\n\t\n\tBuffer.allocConsecutive(numbufs, server, numFrames, 1, { |buf, i|\n\t\tvar\tbase = (i + lowMidi) * 12,\n\t\t\tnumharm = (20000 / base.midicps).asInteger;\n\t\tbuf.sine1Msg(spectrumFunc.(numharm));\n\t});\n} => Func(\\makeWavetables);\n\n\n// basic arpeggiators, macro- and micro-rhythms\n\n// C major\nModalSpec(#[0, 2, 4, 5, 7, 9, 11], 12, 0) => Mode(\\default);\nModalSpec(#[0, 2, 3, 5, 7, 8, 10], 12, 0) => Mode(\\cmin);\n\n// arpeggiation patterns\n\n#{ |notes| Pseq(notes, inf) } => ArpegPat(\\asis);\n#{ |notes|\n\tnotes.isArray.if({\n\t\tPn(notes.asChord, 1)\n\t}, {\n\t\tPn(notes, 1)\n\t});\n} => ArpegPat(\\block);\n#{ |notes| Pxrand(notes, inf) } => ArpegPat(\\xrand);\n#{ |notes| Pseq(notes.sort, inf) } => ArpegPat(\\up);\n#{ |notes| Pseq(notes.sort({ |a, b| a > b }), inf) } => ArpegPat(\\down);\n#{ |notes| Pseq([notes.sort, notes+7, notes+7, notes+14, notes+14].flat, 1) } => ArpegPat(\\bubbleup);\n#{ |notes| Pseq([(notes = notes.sort.reverse) + 14, notes+7, notes].flat, 1) } => ArpegPat(\\bubbledown);\n\n#{ |notes| Pseq(notes.sort, 1) } => ArpegPat(\\up1);\n#{ |notes| Pseq(notes.sort({ |a, b| a > b }), 1) } => ArpegPat(\\down1);\n\n{ |notes| Pshuf(notes, 1) } => ArpegPat(\\shuf1);\n{ |notes| Pshuf(notes, inf) } => ArpegPat(\\shuf);\n\n// microrhythms\n\n#{ |notes, event|\n\tvar topNote, gateIndex, gate;\n\ttopNote = event[\\top];\n\tPn([event.delta, event[\\length], topNote.tryPerform(\\gate) ? 0.5], 1)\n} => MicRh(\\blockFollow);\n\n#{ |notepat| Pn(#[0.25, 0.2, 0.5], notepat.estimateLength) } => MicRh('16th');\n#{ |notepat| Proutine({\n\tvar delta;\n\tnotepat.estimateLength.do({ |i|\n\t\t[delta = 0.2 - ((i * 2pi/25).sin * 0.125), delta, 0.75-delta].yield;\n\t});\n}) } => MicRh(\\sine);\n\n// macrorhythms\nPn(12, inf) => MacRh(\\m3);\n\n\n// pattern-based topnote process\n// usage:\n// ... make chord process in BP(\\ch) ...\n// BP(\\ch).v.topNote = PR(\\patternTop).v.copy.make({\n//\t~deg = pattern;\n//\t~delta = pattern;\t// may be omitted if you use macrorhythm\n//\t~length = pattern;\t// may be omitted if you use macrorhythm\n// });\n\nPR(\\abstractProcess).v.clone({\n\t~mode = \\default;\n\t~delta = 1;\t// need defaults (will be ignored for macrorhythm chord processes)\n\t~length = 1;\n\t~gate = 0.5;\n\t~asPattern = { \n\t\tPbind(\n\t\t\t\\freq, BPStream(\\deg),\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\length, BPStream(\\length),\n\t\t\t\\mode, Pfunc({ ~mode }),\n\t\t\t\\gate, BPStream(\\gate)\n\t\t);\n\t};\n}) => PR(\\patternTop);\n\n",
    "startup21-clientfft.scd": "\nvar\tsubtype = AbstractChuckArray.defaultSubType;\nAbstractChuckArray.defaultSubType = \\fftTransient;\n\nProto({\n\t~keysFromParent = #[checkMinPeak, minPeak, window, imag, cos, melfreqsize, melmap,\n\t\tfftsmooth, slopedist, slopesmooth, halffft];\n\t\n\t\t// note, parent must NOT be stored in this environment\n\t\t// it's used only to get the shared variables\n\t~prep = { |audio, index, parent|\n\t\t~audio = audio;\n\t\t~index = index;\n\t\t~keysFromParent.do({ |key| key.envirPut(parent[key]) });\n\t\tcurrentEnvironment\n\t};\n\t\n\t\t// buf will be used in the buffer-based version\n\t~getfft = { \n\t\tvar\tsrcfft, peak, melfft;\n\n\t\t~peak = ~audio.abs.maxItem;\n\t\t((~checkMinPeak and: { ~peak >= ~minPeak }) or:\n\t\t\t\t{ ~checkMinPeak.not and: { ~peak > 0 } }).if({\n\t\t\t~fhzfft = ~audio / ~peak * ~window;\n\t\t\t~fhzfft = ~fhzfft.as(Signal).fft(~imag, ~cos);\n\t\t\t~fhzfft = ~fhzfft.magnitude[..~halffft-1];\n\t\t\t~srcfft = Array(~melfreqsize);\n\t\t\t~melmap.doAdjacentPairs({ |a, b|\n\t\t\t\t~srcfft.add(~fhzfft[a..b-1].mean);\n\t\t\t});\n\t\t\t~srcfft = ~srcfft.avgsmooth(~fftsmooth);\n\t\t\t\n\t\t\tcurrentEnvironment\n\t\t});\t// returns nil if peak condition not met\n\t};\n\t\n\t~fftPostProcessing = { \n\t\tvar\tfft = ~srcfft,\n\t\t\tslopes = Array.new(fft.size - ~slopedist),\n\t\t\tpeaks = List.new,\t// stores index and magnitude of peak\n\t\t\tpeakIndices = List.new;\n\n\t\t\t// (crudely) differentiate the fft magnitudes and smooth the curve\n\t\t(fft.size - ~slopedist).do({ |i|\n\t\t\tslopes.add(fft[i + ~slopedist-1] - fft[i]);\n\t\t});\n\t\tslopes = slopes.avgsmooth(~slopesmooth);\n\n\t\t\t// identify where slope changes from + to -\n\t\t\t// a peak will be roughly around that index + (slopediff+slopesmooth / 2)\n\t\t\t// if i == 0, compareData will return inf no matter what the comparand\n\t\tslopes.doAdjacentPairs({ |a, b, i|\n\t\t\t((a >= 0) and: { b < 0 and: { i > 0 } }).if({\n\t\t\t\tpeaks.add((index: i, magnitude: fft[i .. i+~slopedist+~slopesmooth].maxItem));\n\t\t\t\tpeakIndices.add(i);\n\t\t\t});\n\t\t});\n\t\t\n\t\t\t// save data in the right place\n\t\t~slopes = slopes;\n\t\t~peaks = peaks.array;\n\t\t~peakIndices = peakIndices.array;\n\t\tcurrentEnvironment\n\t};\n\t\n\t~absRatio = { |a, b|\n\t\t(a.abs > b.abs).if({ a / b }, { b / a });\n\t};\n\n\t\t// a replacement for nearestInList that does not permit repeated matches\n\t\t// returns elements in b that are closest to elements in a\n\t\t// a.size <= b.size or the method will fail\n\t~nearInListExclusive = { |a, b|\n\t\tvar\tout, index;\n\t\t(a.size <= b.size).if({\n\t\t\tout = Array.new(a.size);\n\t\t\tb = b.copy;\t// array will be changed\n\t\t\ta.do({ |item|\n\t\t\t\t(index = b.indexIn(item)).notNil.if({\n\t\t\t\t\tout.add(b[index]);\n\t\t\t\t\tb.removeAt(index);\n\t\t\t\t}, {\n\t\t\t\t\tError(\"nearInListExclusive failed, no match for % in %.\"\n\t\t\t\t\t\t.format(item, b)).throw;\n\t\t\t\t});\n\t\t\t});\n\t\t\tout\n\t\t}, {\n\t\t\tError(\"nearInListExclusive failed, a must be shorter than b.\").throw;\n\t\t});\n\t};\n\n\t~compareData = { |comparisonfft|\n\t\tvar\tdata1, data2, matchedIndices, matchedPeaks, out = 0;\n\n\t\t\t// which is shorter?\n\t\t(~peaks.size <= comparisonfft.peaks.size).if({\n\t\t\tdata1 = currentEnvironment;\n\t\t\tdata2 = comparisonfft;\n\t\t}, {\n\t\t\tdata1 = comparisonfft;\n\t\t\tdata2 = currentEnvironment;\n\t\t});\n\n\t\t\t// peak indices in data2 that are closest to the indices in data1\n\t\tmatchedIndices = ~nearInListExclusive.(data1.peakIndices, data2.peakIndices);\n\t\t\t// peak objects at those indices\n\t\tmatchedPeaks = data2.peaks[matchedIndices.collectIndicesFromArray(data2.peakIndices)];\n\n\t\t\t// now some numeric hackery\n\t\t\t// divide larger by smaller and take average of quotients\n\t\t\t// weight by quotient of peak magnitudes\n\t\tdata1.peaks.do({ |p1, i|\n\t\t\tvar\tind = ~absRatio.(p1.index, matchedPeaks[i].index),\n\t\t\t\tmag = ~absRatio.(p1.magnitude, matchedPeaks[i].magnitude);\n\t\t\tout = out + (ind * mag * (data1.peaks.size - i));\n\t\t});\n\t\t\n\t\t\t// if no peaks, this will be 0 / 0, replace with inf\n\t\t\t// just return, parent's job to save into the matrix\n\t\t(out = (out / matchedPeaks.size * ~absRatio.(data1.peaks.size, data2.peaks.size)))\n\t\t\t.isNaN.if(inf, out);\n\t};\n\t\n\t\t// remove most expensive memory consumers\n\t\t// preserve data (peaks, peakIndices) needed for comparison\n\t\t// usually you should collect garbage UNLESS you are debugging\n\t~collectGarbage = { |doGC|\n\t\t(doGC ? true).if({\n\t\t\t~fhzfft = nil;\n\t\t\t~srcfft = nil;\n\t\t\t~slopes = nil;\n\t\t\t~audio = nil;\n\t\t\t~keysFromParent.do({ |key|\n\t\t\t\tcurrentEnvironment.removeAt(key);\n\t\t\t});\n\t\t});\n\t};\n\n}) => PR(\\fftDataProto);\n\nPR(\\abstractProcess).v.clone({\n\t~event = (eventKey: \\dummy);\n\n\t\t// can add stuff here\n\t~dataProto = \\fftDataProto;\n\n\t~fftsmooth = 8;\n\t~slopedist = 3;\n\t~slopesmooth = 5;\n\t\n\t~minPeak = 0.1;\n\t\t// this is, checkMinPeak of each time point -- the peak of the whole buffer is always checked\n\t~checkMinPeak = false;\n\t\n\t~postProgress = false;\t// post status updates?\n\t~garbageCollection = true;\n\n\t\t// getfft converts to mel frequencies for better analysis\n\t~freqToMel = { |fhz|\n\t\t1127.01048 * log(1 + (fhz/700))\n\t};\n\t\n\t~melToFreq = { |mel|\n\t\texp(mel / 1127.01048) - 1 * 700\n\t};\n\n\t~fftwait = 0.001;\n\t~cmpwait = 0.0000001;\n\t~clock = AppClock;\t\t// do not need musical precision\n\t~quant = NilTimeSpec.new;\n\t~reuseCleanup = true;\n\t\n\t~startAnalysis = { |path, pts, fftsize|\n\t\t~isPlaying.if({\n\t\t\t\"BP(%) is still analyzing %. Cannot start a new file.\"\n\t\t\t\t.format(~collIndex.asCompileString, ~path);\n\t\t}, {\n\t\t\t~path = path;\n\t\t\t~pts = pts;\n\t\t\t~fftsize = fftsize ? 2048;\n\t\t\tBP(~collIndex).play(doReset: true);\n\t\t});\n\t};\n\t\n\t~asyncHang = { \n\t\t~saveEventStreamPlayer = ~eventStreamPlayer;\n\t\tnil.yield;\n\t};\n\t\n\t~asyncUnhang = { \n\t\t~eventStreamPlayer = ~saveEventStreamPlayer;\n\t\t~clock.sched(0, ~eventStreamPlayer.refresh);\n\t\t~isPlaying = true;\n\t};\n\n\t\t// SoundFile-based is synchronous but buffers might be async\n\t\t// getAudioData should send the messages to get the data, then call ~asyncHang\n\t\t// the following method is synchronous\n\t~getAudioData = { |time|\n\t\tvar\tresult;\n\t\t~file.seek(time * ~sampleRate.value, 0);\n\t\tresult = FloatArray.newClear(~fftsize);\n\t\t~file.readData(result);\n\t\t(result.size == ~fftsize).if({\n\t\t\tresult\n\t\t}, {\n\t\t\t\"Soundfile read failed, asked for % samples and got %.\"\n\t\t\t\t.format(~fftsize, result.size).warn;\n\t\t\tnil\n\t\t});\n\t};\n\n\t~initIndexPair = {\n\t\t~indexpair = Routine({\n\t\t\t(~pts.size - 1).do({ |i|\n\t\t\t\t(i+1 .. ~pts.size - 1).do({ |j|\n\t\t\t\t\t[i, j].yield;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\t~makeWindow = {  Signal.hanningWindow(~fftsize) };\n\n\t~sampleRate = {  ~file.sampleRate };\n\n\t~preparePlay = { \n\t\tvar\tresolution, melreso, mel, fhz, melNyquist;\n\n\t\t~path !? { ~file = SoundFile.openRead(~path) };\n\n\t\t~fftsize = nextPowerOfTwo(~fftsize);\n\t\t~halffft = ~fftsize div: 2;\n\t\t~imag = Signal.fill(~fftsize, 0);\n\t\t~cos = Signal.fftCosTable(~fftsize);\n\t\t\n\t\tresolution = ~sampleRate.value / ~fftsize;\n\t\t~melfreqsize = (~fftsize * 0.125).nextPowerOfTwo.asInteger;\n\t\tmelreso = ~freqToMel.(~sampleRate.value * 0.5) / ~melfreqsize;\n\t\t\n\t\t\t// melmap[mel_bin_index] == first bin index into fft\n\t\t~melmap = Array.fill(~melfreqsize+1, { |i|\n\t\t\tfhz = ~melToFreq.(melreso * i);\n\t\t\t((fhz + (resolution * 0.5)) / resolution).asInteger\n\t\t});\n\t\t\n\t\t~window = ~makeWindow.value;\n\t\t\n\t\t~analysisComplete = false;\n\t};\n\n\t~initMatrix = { \n\t\t~matrix = Array.fill(~pts.size, { Array.newClear(~pts.size) });\n\t};\n\t\n\t~addToMatrix = { |metric, refindex, cmpindex, matrix, ffts, pts|\n\t\tmatrix = matrix ? ~matrix;\n\t\tffts = ffts ? ~ffts;\n\t\tpts = pts ? ~pts;\n\t\tmatrix[refindex][cmpindex] = (metric: metric, peak: ffts[cmpindex].peak,\n\t\t\ttime: pts[cmpindex], refindex: refindex, index: cmpindex);\n\t\tmatrix[cmpindex][refindex] = (metric: metric, peak: ffts[refindex].peak,\n\t\t\ttime: pts[refindex], refindex: cmpindex, index: refindex);\n\t};\t\t\n\n\t\t// by now matrix is mostly built, need to fill in the [i, i] diagonal\n\t~buildMatrix = { \n\t\t~matrix.size.do({ |i|\n\t\t\t~matrix[i][i] = (metric: 1, index: i, refindex: i, peak: ~ffts[i].peak,\n\t\t\t\ttime: ~pts[i]);\n\t\t});\n\t\t~matrix\n\t};\n\n\t~asPattern = { \n\t\t\t// normally this should be a pattern but routines made from patterns\n\t\t\t// can't be hung and unhung for async use\n\t\t\t// Routine().asStream === Routine() so it should be OK\n\t\tRoutine({\n\t\t\tvar\taudio, srcfft, pair, metric, failed = 0, lastPair0;\n\n\t\t\t~postProgress.if({\n\t\t\t\t\"BP(%): Calculating ffts and peaks\\n\".postf(~collIndex.asCompileString);\n\t\t\t});\n\t\t\t~ffts = Array.new(~pts.size);\n\t\t\t~pts = ~pts.copy;\n\t\t\t~pts.copy.do({ |time, i|\n\t\t\t\t(play: 0, delta: ~fftwait).yield;\n\t\t\t\t\t// ~buffer is nil in the file version, but won't be in the buffer version\n\t\t\t\taudio = ~getAudioData.(time, ~buffer);\n\t\t\t\taudio.notNil.if({\n\t\t\t\t\tsrcfft = PR(~dataProto).v.copy.prep(audio, i-failed, currentEnvironment);\n\t\t\t\t\t\t// nil indicates peak check for the clip failed\n\t\t\t\t\tsrcfft.getfft.notNil.if({\n\t\t\t\t\t\t~ffts.add(srcfft.fftPostProcessing);\n\t\t\t\t\t\tsrcfft.collectGarbage(~garbageCollection);\n\t\t\t\t\t}, {\n\t\t\t\t\t\t~postProgress.if({\n\t\t\t\t\t\t\t\"BP(%): Timepoint % is not valid.\\n\"\n\t\t\t\t\t\t\t\t.postf(~collIndex.asCompileString, time)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t~pts.removeAt(i - failed);\n\t\t\t\t\t\tfailed = failed + 1;\n\t\t\t\t\t});\n\t\t\t\t}, {\n\t\t\t\t\t~postProgress.if({\n\t\t\t\t\t\t\"BP(%): Timepoint % is not valid.\\n\"\n\t\t\t\t\t\t\t.postf(~collIndex.asCompileString, time)\n\t\t\t\t\t});\n\t\t\t\t\t~pts.removeAt(i - failed);\n\t\t\t\t\tfailed = failed + 1;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t~postProgress.if({\n\t\t\t\t\"BP(%): % onsets did not meet threshold.\\n\".postf(~collIndex.asCompileString,\n\t\t\t\t\tfailed);\n\t\t\t});\n\n\t\t\t~postProgress.if({\n\t\t\t\t\"BP(%): Comparing ffts\\n\".postf(~collIndex.asCompileString);\n\t\t\t});\n\t\t\t~initIndexPair.value;\n\t\t\t~initMatrix.value;\n\t\t\t{ (pair = ~indexpair.next).notNil }.while({\n\t\t\t\t\t// this func must store comparison in matrix\n\t\t\t\t(~postProgress and: { pair[0] != lastPair0 }).if({\n\t\t\t\t\t\"BP(%): Comparing index %, % comparisons.\\n\".postf(\n\t\t\t\t\t\t~collIndex.asCompileString, pair[0], ~ffts.size - pair[0] - 1);\n\t\t\t\t\tlastPair0 = pair[0];\n\t\t\t\t});\n\t\t\t\tmetric = ~ffts[pair[0]].compareData(~ffts[pair[1]]);\n\t\t\t\t~addToMatrix.(metric, pair[0], pair[1]);\n\t\t\t\t(play: 0, delta: ~cmpwait).yield;\n\t\t\t});\n\n\t\t\t~buildMatrix.value;\n\t\t\t~garbageCollection.value;\t// since these run in a routine, they may .wait\n\t\t\t~analysisComplete = true;\n\t\t\t\t// pattern will stop, control passes to ~stopCleanup\n\t\t})\n\t};\n\n\t~userStop = { \n\t\t~file.close;\n\t};\n\n\t\t// if this is called when analysisComplete is false, the thread is hanging,\n\t\t// waiting for async reply\n\t~stopCleanup = { |streamStopped|\n\t\tstreamStopped.if({\n\t\t\t(~analysisComplete ? false).if({\n\t\t\t\t\"Analysis complete. Executing action.\".postln;\n\t\t\t\t~userStop.value;\n\t\t\t\t~clearAsyncResponder.value;\n\t\t\t\t~action.(~path, ~pts, ~matrix);\n\t\t\t});\n\t\t}, {\n\t\t\t\"Analysis was aborted. Call .play to resume.\".warn;\n\t\t});\n\t};\n\t\n\t~freeCleanup = { \n\t\t~clearAsyncResponder.value;\n\t\t~userFree.value;\n\t};\n\t\n\t\t// be careful -- this is NOT threaded and will block other threads until complete\n\t\t// it's very fast, though, can write over 180,000 numbers in 1-2 seconds\n\t\t// (on a MacBook Pro :)\n\t\t// if matrix is size n, first n rows contain the metrics sequentially\n\t\t// 2 additional rows for time points and peak amplitudes\n\n\t\t// to restore, do:\n\t\t//\t\t(PR(\\transient_analysis_file) => BP(\\reader)).v.readMatrixFromCSV(path);\n\n\t~saveMatrixToCSV = { |path|\n\t\tvar\tfile = File(path = path.standardizePath, \"w\");\n\t\tfile.isOpen.if({\n\t\t\t~pts.do({ |pt, i|\n\t\t\t\tfile.write(pt.asCompileString);\n\t\t\t\t(i < (~matrix.size-1)).if({ file.write($,); });\n\t\t\t});\n\t\t\tfile.write($\\n);\n\t\t\t~matrix[0].do({ |col, i|\n\t\t\t\tfile.write(col.peak.asCompileString);\n\t\t\t\t(i < (~matrix.size-1)).if({ file.write($,); });\n\t\t\t});\n\t\t\tfile.write($\\n);\n\t\t\t~matrix.do({ |row|\n\t\t\t\trow.do({ |col, i|\n\t\t\t\t\tfile.write(col.metric.asCompileString);\n\t\t\t\t\t(i < (row.size-1)).if({ file.write($,); });\n\t\t\t\t});\n\t\t\t\tfile.write($\\n);\n\t\t\t});\n\t\t\tfile.close;\n\t\t}, {\n\t\t\tError(\"saveMatrixToCSV: Could not open % for writing.\".format(path)).throw;\n\t\t});\n\t};\n\n\t~readMatrixFromCSV = { |path|\n\t\tvar\traw = CSVFileReader.read(path.standardizePath, true, true, _.asFloat),\n\t\t\tpeaks, pts;\n\t\traw.notNil.if({\n\t\t\t~pts = raw[0];\n\t\t\tpeaks = raw[1];\n\t\t\t~matrix = { Array.newClear(raw.size-2) } ! (raw.size-2);\n\t\t\t(2..raw.size-1).do({ |i, row|\n\t\t\t\traw[i].do({ |col, j|\n\t\t\t\t\t~matrix[row][j] = (refindex: row, index: j, metric: col, peak: peaks[j],\n\t\t\t\t\t\ttime: ~pts[j]);\n\t\t\t\t});\n\t\t\t});\n\t\t\t~matrix\n\t\t});\n\t};\n\t\n\t~readMatrixFromCSVOldFormat = { |path|\n\t\tvar\traw = CSVFileReader.read(path.standardizePath, true, true, _.asFloat),\n\t\t\tpeaks, pts;\n\t\traw.notNil.if({\n\t\t\tpeaks = raw.removeAt(raw.size-1);\n\t\t\t~pts = raw.removeAt(raw.size-1);\n\t\t\t~matrix = { Array.newClear(raw.size) } ! (raw.size);\n\t\t\traw.do({ |row, i|\n\t\t\t\trow.do({ |col, j|\n\t\t\t\t\t~matrix[i][j] = (refindex: i, index: j, metric: col, peak: peaks[j],\n\t\t\t\t\t\ttime: ~pts[j]);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~readRowFromCSV = { |file|\n\t\tvar\tout = List.new,\n\t\t\tchar, string = String.new;\n\n\t\t{\tchar = file.getChar;\n\t\t\tchar.notNil and: { \"\\n\\r\".includes(char).not }\n\t\t}.while({\n\t\t\tcase { char == $, } {\n\t\t\t\t(string.size > 0).if({\n\t\t\t\t\tout.add(string.asFloat);\n\t\t\t\t\tstring = String.new;\n\t\t\t\t});\n\t\t\t}\n\t\t\t{ string = string.add(char) };\n\t\t});\n\t\t(string.size > 0).if({\n\t\t\tout.add(string.asFloat);\n\t\t});\n\t\tout.asArray\n\t};\n\t\n\t~asyncReadFromCSV = { |path, action|\n\t\tvar file, raw, peaks, size;\n\t\tpath = path.standardizePath;\n\t\t(file = File.new(path, \"r\")).isOpen.if({\n\t\t\tAppClock.sched(0, Routine({\n\t\t\t\tprotect {\n\t\t\t\t\t~pts = ~readRowFromCSV.(file);\n\t\t\t\t\t0.01.yield;\n\t\t\t\t\tpeaks = ~readRowFromCSV.(file);\n\t\t\t\t\tsize = ~pts.size;\n\t\t\t\t\t~matrix = Array.new(size);\n\t\t\t\t\tsize.do({ |i|\n\t\t\t\t\t\t0.01.yield;\n\t\t\t\t\t\traw = ~readRowFromCSV.(file);\n\t\t\t\t\t\t~matrix.add(\n\t\t\t\t\t\t\traw.collect({ |col, j|\n\t\t\t\t\t\t\t\t(refindex: i, index: j, metric: col, peak: peaks[j],\n\t\t\t\t\t\t\t\t\ttime: ~pts[j])\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\taction.value(~matrix);\n\t\t\t\t} {\n\t\t\t\t\tfile.close;\n\t\t\t\t};\n\t\t\t}))\n\t\t}, {\n\t\t\t\"% could not be opened.\".format(path).error\n\t\t});\n\t};\n}) => PR(\\transient_analysis_file);\n\nPR(\\transient_analysis_file).v.clone({\n\t~sampleRate = {  ~buffer.sampleRate };\n\n\t~startAnalysis = { |buffer, pts, fftsize|\n\t\t~isPlaying.if({\n\t\t\t\"BP(%) is still analyzing %. Cannot start a new file.\"\n\t\t\t\t.format(~collIndex.asCompileString, ~buffer);\n\t\t}, {\n\t\t\t~buffer = buffer;\n\t\t\t~pts = pts;\n\t\t\t~fftsize = fftsize ? 2048;\n\t\t\tBP(~collIndex).play(doReset: true);\n\t\t});\n\t};\n\n\t\t// asynchronous version to read from a buffer\n\t\t// note, if getToFloatArray fails, the thread will stop with error\n\t~getAudioData = { |time, buffer|\n\t\tvar\tresult, startFrame = (time * buffer.sampleRate).asInteger;\n\t\t(startFrame < (buffer.numFrames - ~fftsize)).if({\n\t\t\tbuffer.getToFloatArray(startFrame, ~fftsize, action: e { |v|\n\t\t\t\tresult = v;\n\t\t\t\t~asyncUnhang.value;\t// getToFloatArray action is not environment-safe\n\t\t\t});\n\t\t\t~asyncHang.value;\n\t\t\t(result.size == ~fftsize).if({\n\t\t\t\tresult\n\t\t\t}, {\n\t\t\t\t\"Buffer read failed, asked for % samples and got %.\"\n\t\t\t\t\t.format(~fftsize, result.size).warn;\n\t\t\t\tnil\n\t\t\t});\n\t\t});\n\t};\n\n\t~userStop = 0;\n}) => PR(\\transient_analysis_buffer);\n\n// an incremental version for live analysis\n// simultaneously receives audio from file or mic, records to a buffer,\n// runs a feature detector to get triggers, and queues fft and comparison analyses\n// in theory, after recording stops, the matrix should be ready within moments\n// used a lot of code from my track \"Got an itch to scratch\" for multi-buffer support\n// \"clients\" for these buffers can register as dependents of the BP\n// and get status updates on the bufs\n\nPR(\\transient_analysis_buffer).v.clone({\n\t~fftID = 0;\t\t// queue elements must have a sequential ID\n\t~cmpID = 0;\n\t~errorRecovery = true;\t\t// if an error occurs during comparisons, find and fix afterward\n\t~iMadeMixer = false;\n\t~numBufs = 5;\n\t~bufDur = 10;\n\t~recording = false;\n\t~quant = 1;\n\t~onsetRejectLimit = 0.15;\n\t~minPeak = 0.175;\t\t\t// reject a recording if its peak <= this\n\t~recordActive = true;\n\t~audioThru = false;\t\t// allow audio from another bus when not recording\n\t\t\t\t\t\t\t// (always plays thru during recording)\n\t~audioThruLevel = 1;\t\t// level of audio allowed through (0 will suppress)\n\t~mixerOutChannels = 2;\n\t\n\t~midiTriggerChan = \\omni;\n\t~midiTriggerCtlNum = 64;\n\n\t~bufStateProto = (status: \\idle, dur: nil, peak: nil, recTime: 0, playCount: 0,\n\t\tactionDone: false)\n\t\t.parent_(\n\t\t\t(status_: { |thisBufState, status|\n\t\t\t\tthisBufState[\\status] = status;\n\t\t\t\tthisBufState.changed(\\status, status);  // dependents should know when status changes\n\t\t\t})\n\t\t);\n\n//////// INITIALIZATION ////////\n\t\n\t~sampleRate = {  ~bufs[0].buf.sampleRate };\n\n\t~prep = { \n\t\t~chan.isNil.if({\n\t\t\t~chan = MixerChannel(~collIndex, s, 1, ~mixerOutChannels, postSendReady: true,\n\t\t\t\toutbus: ~master);\n\t\t\t~iMadeMixer = true;\n\t\t});\n\n\t\t~bufs = { ~bufStateProto.copy\n\t\t\t.put(\\buf, Buffer.alloc(s, (~bufDur ? 10) * s.sampleRate, 1))\n\t\t\t.put(\\status, \\idle) } ! ~numBufs;\n\n\t\t~fftqueue = PriorityQueue.new;\n\t\t~cmpqueue = PriorityQueue.new;\n\t\t\n\t\t~fftbuf = Buffer.alloc(s, 256, 1);\n\n\t\t~watcher = NodeWatcher.newFrom(s);\n\n\t\t~resp = OSCresponderNode(s.addr, '/tr', e { |t, r, m|\n\t\t\tvar\tbuf;\n\t\t\t\t// ignore if I don't know about the node\n\t\t\tbuf = ~bufs.detect({ |buf| m[1] == buf.node.tryPerform(\\nodeID) });\n\t\t\tbuf.notNil.if({\n\t\t\t\tswitch(m[2])\t// switch is based on SendTrig id arg\n\t\t\t\t\t{ -1 } {\n\t\t\t\t\t\tbuf.status = \\record;\n\t\t\t\t\t\tbuf.dur = nil;\t// set flags so we know when all messages\n\t\t\t\t\t\tbuf.peak = nil;\t// have come in\n\t\t\t\t\t\tbuf.ontimes = List.new;\n\t\t\t\t\t\t~doOnRecord.(buf);\n\t\t\t\t\t}\n\t\t\t\t\t{ 0 } {\n\t\t\t\t\t\tbuf.status = \\stopRec;\n\t\t\t\t\t\tbuf.peak = m[3].max(0.01);\n\t\t\t\t\t\tbuf.dur.notNil.if({ ~closeRecording.(buf) });\n\t\t\t\t\t}\n\t\t\t\t\t{ 1 } {\n\t\t\t\t\t\tbuf.status = \\stopRec;\n\t\t\t\t\t\tbuf.dur = m[3];\n\t\t\t\t\t\tbuf.recTime = Main.elapsedTime;\n\t\t\t\t\t\tbuf.peak.notNil.if({ ~closeRecording.(buf) });\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tbuf = ~bufs.detect({ |buf| m[1] == buf.detectnode.tryPerform(\\nodeID) });\n\t\t\t\t(buf.notNil and: { m[2] == 32 and: { buf.status == \\record\n\t\t\t\t\t\tand: { m[3] > 0 } } }).if({\n\t\t\t\t\tbuf.ontimes.add(m[3]);\n\t\t\t\t\t~queueOnsetTime.(buf, m[3], buf.ontimes.size-1);\n\t\t\t\t});\n\t\t\t});\n\t\t}).add;\n\n\t\t~featuredef = ~makeFeatureDetector.value.send(s);\n\t\t~inputdef = ~makeInputSource.value.send(s);\n\n\t\t~userprep.value;\n\n\t\t~initFFT.value;\n\n\t\t~triggerdevice = ~makeTrigger.value;\n\t\t~startRecord.(~recordActive);\n\t\t~lastTrigTime = 0;\n\t};\n\n\t~makeTrigger = { \n\t\t\t// asClass is used here because you might not have installed the ddwMIDI quark\n\t\t\t// rather than make chucklib depend on the whole MIDI framework,\n\t\t\t// I will use this technique to avoid an error on recompile\n\t\t'BasicMIDIControl'.asClass.new(~midiTriggerChan, ~midiTriggerCtlNum, e { |value|\n\t\t\t\t// seems we need to trap very rapid triggers\n\t\t\t(value > 0 and: { (Main.elapsedTime - ~lastTrigTime) > 1.0 }).if({\n\t\t\t\t~sendTrigger.value;\n\t\t\t});\n\t\t});\n\t};\n\t\n\t~sendTrigger = { \n\t\ts.makeBundle(nil, {\n\t\t\t~recNode !? { ~recNode.set(\\t_trig, 1) };\n\t\t\t~detectNode !? { ~detectNode.set(\\t_trig, 1) };\n\t\t});\n\t\t~lastTrigTime = Main.elapsedTime;\n\t};\n\n\t~makeFeatureDetector = {\n\t\tSynthDef(\\pv_jensen, { |outbus, fftbuf, bufnum, t_trig, faststop = 0,\n\t\t\tpropsc = 0.75581395348837, prophfe = 0.43023255813953, prophfc = 0.63953488372093,\n\t\t\t\tpropsf = 0.54651162790698, threshold = 0.058139534883721,\n\t\t\t\twaittime = 0.15116279069767,\n\t\t\t\ti_fftwait = 0.05|  // can't do fft analysis until the whole frame is recorded\n\n\t\t\tvar\tpc = PulseCount.kr(t_trig),\n\t\t\t\tstart = BinaryOpUGen.new1(\\control, '==', pc, 1),\n\t\t\t\tstop = BinaryOpUGen.new1(\\control, '==', pc, 2),\n\t\t\t\tstarted = (pc > 0),\n\t\t\t\tsig = In.ar(outbus, 1),\n\t\t\t\tfft = FFT(fftbuf, sig),\n\t\t\t\tdur = Phasor.ar(start, SampleDur.ir, 0, 1000),\n\t\t\t\tonsettrig;\n\n\t\t\t\t// event onset\n\t\t\tonsettrig = PV_JensenAndersen.ar(fft, propsc, prophfe, prophfc, propsf,\n\t\t\t\tthreshold, waittime);\n\t\t\t\t\t// delayed to allow entire client fft frame to be recorded before analysis\n\t\t\t\t\t// BufDur.kr(fftbuf) * 0.5 is a correction for PV_Jensen's trigger lag\n\t\t\tSendTrig.kr(DelayN.kr(onsettrig, i_fftwait, i_fftwait), 32,\n\t\t\t\tdur - i_fftwait - (BufDur.kr(fftbuf) * 0.5));\n\n\t\t\tstop = stop + (started * A2K.kr(dur > BufDur.ir(bufnum))) + faststop;\n\t\t\tFreeSelf.kr(stop);\n\t\t});\n\t};\n\t\n\t~detectParms = { |buf| \n\t\t[bufnum: buf.buf.bufnum, fftbuf: ~fftbuf.bufnum, \n\t\t\ti_fftwait: ~fftsize / ~sampleRate.value, waittime: ~onsetRejectLimit]\n\t};\n\t\n\t~makeInputSource = {\n\t\tSynthDef(\\trigrecfft, { |bufnum, t_trig, inbus, outbus,\n\t\t\t\tcmpgain = 1, cmpclamp = 0.02, cmprelax = 0.1, cmpthresh = 0.4,\n\t\t\t\tcmpratio = 1.0, cmpgateratio = 1.0, hardgate = 0.01,\n\t\t\t\taudiothru = 0, faststop = 0|\n\t\t\tvar\tpc = PulseCount.kr(t_trig),\n\t\t\t\tstart = BinaryOpUGen.new1(\\control, '==', pc, 1),\n\t\t\t\tstop = BinaryOpUGen.new1(\\control, '==', pc, 2),\n\t\t\t\tstarted = (pc > 0),\n\t\t\t\tsig = In.ar(inbus, 1),\n\t\t\t\tpeak = Peak.ar(sig * started),\n\t\t\t\tdur;\n\t\t\t\n\t\t\tsig = sig * (Amplitude.kr(sig, cmpclamp, cmprelax) >= hardgate);\n\t\t\tsig = CompanderD.ar(sig, cmpthresh, cmpgateratio, cmpratio, cmpclamp, cmprelax,\n\t\t\t\tcmpgain);\n\t\t\t\n\t\t\t\t// trigger should ensure recording waits until trigger rec'd\n\t\t\tRecordBuf.ar(sig, bufnum, 0, 1, 0, started - stop, 0, 0);\n\t\t\n\t\t\tdur = Phasor.ar(start, SampleDur.ir, 0, 1000);\n\t\t\tstop = stop + (started * A2K.kr(dur > BufDur.ir(bufnum))) + faststop;\n\t\t\t\n\t\t\tSendTrig.kr(start, -1, 1);\t\t// \"started recording\" message\n\t\t\tSendTrig.kr(stop, 0, peak);\t\t// \"stopped recording\"\n\t\t\tSendTrig.kr(stop, 1, dur);\t\t// \"how long recording?\"\n\n\t\t\t\t// delay the stop trigger in the EnvGen to avoid glitch\n\t\t\tOut.ar(outbus, sig\n\t\t\t\t* EnvGen.kr(Env.asr(0.05, 1, 0.05),\n\t\t\t\t\tDelayN.kr((started + audiothru) * (1 - stop), cmpclamp, cmpclamp),\n\t\t\t\t\tdoneAction:2)\n\t\t\t);\n\t\t});\n\n\t};\n\t\n\t~inputParms = [];\n\n\t\t// call from outside when a new node is using one of my buffers\n\t\t// watch for the node to stop and allow the buf to be reused when no one is using it\n\t\t// if node is nil, it's the user's responsibility to release the buffer (next method)\n\t~bufferPlayingNewNode = { |buffer, node|\n\t\tbuffer.status = \\play;\n\t\tbuffer.playCount = buffer.playCount + 1;\n\t\tnode.notNil.if({\n\t\t\t~watcher.register(node);\n\t\t\tUpdater(node, e { |node, msg|\n\t\t\t\t(msg == \\n_end).if({\n\t\t\t\t\tnode.releaseDependants;\n\t\t\t\t\t~releaseBufferFromPlay.(buffer);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\t\t// should be called from outside to release a buffer from play\n\t~releaseBufferFromPlay = { |buffer|\n\t\tbuffer.playCount = buffer.playCount - 1;\n\t\t(buffer.playCount == 0).if({\n\t\t\tbuffer.status = \\ready;\n\t\t\t~startRecord.(~recordActive);\t// if already recording, this will not fire\n\t\t});\n\t};\n\t\n//////// RECORDING CONTROL ////////\n\n\t~inputBusIndex = s.options.numOutputBusChannels;\n\n\t~startRecord = { |recActive|\n\t\tvar\tbuf = ~oldestBuffer.(#[idle, ready]),  // ready means not playing\n\t\t\tbundle;\n\t\trecActive = recActive ? true;\t// if nil, start every time (if user calls directly)\n\t\t(recActive and: { ~recording.not and: { buf.notNil } }).if({\n\t\t\tbuf.status = \\recordPending;\n\t\t\tbuf.actionDone = false;\n\t\t\tbuf.ontimes = List.new;\n\t\t\tbuf.ffts = List.new;\n\t\t\tbuf.matrix = Array.new;\n\t\t\tbundle = s.makeBundle(false, {\n\t\t\t\tbuf.node = ~chan.play(~inputdef.name, [\\bufnum, buf.buf.bufnum,\n\t\t\t\t\t\\inbus, ~inputBusIndex, \\t_trig, 0, \\audiothru, ~audioThru.binaryValue]\n\t\t\t\t\t++ ~inputParms.(buf));\n\t\t\t\tbuf.detectnode = ~chan.playfx(~featuredef.name, [t_trig: 0]\n\t\t\t\t\t++ ~detectParms.(buf));\n\t\t\t});\n\t\t\t~recNode = buf.node;\n\t\t\t~detectNode = buf.detectnode;\n\t\t\t~chan.doWhenReady({\n\t\t\t\ts.listSendBundle(nil, bundle);\n\t\t\t});\n\t\t\t~recording = true;\n\t\t\t~recordActive = true;\n\t\t\t~currentBuf = buf;\n\t\t\t\"\\n\\n\\nRecording is paused.\".postln;\n\t\t\tBP(~collIndex).changed(\\bufRecord, buf);\n\t\t});\n\t};\n\n\t~oldestBuffer = { |status|\n\t\t~bufs.sort({ |a, b| a.recTime < b.recTime })\n\t\t\t.detect({ |buf| status.matchItem(buf.status) })\n\t};\n\t\n\t~closeRecording = { |buf, startRec|\n\t\t\t// update gui status if I'm in an MT\n\t\t~isPlaying = false;\n\t\tBP(~collIndex).changed(\\stop);\n\n\t\t\t// if nothing was recorded on stopRecord, buf.peak is nil so guarantee failure with -1\n\t\t((buf.peak ? -1) >= ~minPeak).if({\n\t\t\tbuf.status = switch(buf.status)\n\t\t\t\t{ \\recordPending } { \\idle }\n\t\t\t\t{ \\record } { \\ready }\n\t\t\t\t{ \\stopRec } { \\ready }\n\t\t\t\t{ \\idle };\n\t\t}, {\n\t\t\t\"Recording rejected, amplitude (%) didn't meet threshold (%).\"\n\t\t\t\t.format(buf.peak, ~minPeak)\n\t\t\t\t.warn;\n\t\t\tbuf.status = \\idle;\n\t\t\tbuf.recTime = -1;\t// force next record to use this buffer\n\t\t});\n\t\tbuf.node = nil;\n\n\t\t\t// kindly release the node -- buf.node is already nil so oscresp won't match\n\t\t(startRec ? true).not.if({\n\t\t\t~recNode.set(\\faststop, 1);\n\t\t});\n\t\t~recNode = nil;\n\t\t~detectNode.free;\t// detectNode should not be outputting audio, can kill brutally\n\t\t~detectNode = nil;\n\t\t~recording = false;\n\t\t~lastTrigTime = Main.elapsedTime;  // to avoid accidental record restart\n\t\t(startRec ? true).if({\n\t\t\t~startRecord.(~recordActive);\n\t\t});\n\t\t~cmpqueue.isEmpty.if({\n\t\t\t~doAction.(buf);\n\t\t});\n\t};\n\n\t~doOnRecord = { |buf|\n\t\t\"\\n\\n\\n>>>>> RECORDING IS ACTIVE. <<<<<\".postln;\n\t\t\t// update gui status if I'm in an MT\n\t\t~isPlaying = true;\n\t\tBP(~collIndex).changed(\\play);\n\t};\n\t\n\t\t// dummy action, replace to call another BP to use the buffer\n\t~doAction = { |buf|\n\t\t(buf.actionDone.not and: { buf.peak >= ~minPeak }).if({\n\t\t\t\"Analysis complete. Last buffer stored in BP(%).v.lastBuf.\\n\"\n\t\t\t\t.postf(~collIndex.asCompileString);\n\t\t\t~lastBuf = buf;\n\t\t\tbuf.actionDone = true;\n\t\t\tBP(~collIndex).changed(\\bufReady, buf);\n\t\t});\n\t\tcurrentEnvironment\n\t};\n\n//////// FFT ANALYSIS CONTROL ////////\n\n\t~fftThreadActive = false;\n\t~fftThreadWaiting = false;\n\t~cmpThreadActive = false;\n\n\t~queueOnsetTime = { |buf, time|\n\t\t~fftID = ~fftID + 1;\n\t\t~fftqueue.put(~fftID, (buf: buf, time: time, index: buf.ffts.size));\n\t\t~activateFFTThread.value;\n\t};\n\t\n\t~activateFFTThread = { \n\t\t~fftThread.isNil.if({ ~makeFFTThread.value });\n\t\t~fftThreadActive.not.if({\n\t\t\tAppClock.sched(0, ~fftThread);\n\t\t\t~fftThreadActive = true;\n\t\t});\n\t};\n\t\n\t~makeFFTThread = { \n\t\t~fftThread = HJHCleanupStream(\n\t\t\tRoutine({\n\t\t\t\tvar\taudio, srcfft, spec;\n\t\t\t\tloop {\n\t\t\t\t\tspec = ~fftqueue.pop;\n\t\t\t\t\tspec.notNil.if({\n\t\t\t\t\t\t\t// spec.buf.ffts.size == index of next fft to add\n\t\t\t\t\t\t\t// spec has an index but if a previous fft failed, it may be wrong\n\t\t\t\t\t\tspec.index = spec.buf.ffts.size;\n\t\t\t\t\t\taudio = ~getAudioData.(spec.time, spec.buf.buf);\n\t\t\t\t\t\taudio.notNil.if({\n\t\t\t\t\t\t\tsrcfft = PR(~dataProto).v.copy\n\t\t\t\t\t\t\t\t.prep(audio, spec.index, currentEnvironment);\n\t\t\t\t\t\t\tsrcfft.getfft.notNil.if({\n\t\t\t\t\t\t\t\t~postProgress.if({\n\t\t\t\t\t\t\t\t\t\"BP(%): got valid time %\\n\".postf(\n\t\t\t\t\t\t\t\t\t\t~collIndex.asCompileString, spec.time);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t~ffts.add(srcfft.fftPostProcessing);\n\t\t\t\t\t\t\t\tsrcfft.collectGarbage(~garbageCollection);\n\t\t\t\t\t\t\t\tspec.buf.ffts.add(srcfft);\n\t\t\t\t\t\t\t\t~queueComparisons.(spec);\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tspec.buf.ontimes.removeAt(spec.index);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tspec.buf.ontimes.removeAt(spec.index);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t~fftwait.wait;\n\t\t\t\t\t}, {\n\t\t\t\t\t\tnil.yield;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}),\n\t\t\te { ~fftThreadWaiting.not.if({ ~fftThreadActive = false }); },\n\t\t\ttrue);\n\t};\n\t\n\t~queueComparisons = { |fftspec|\n\t\tvar\tmatrix = fftspec.buf.matrix, index = fftspec.index;\n\t\t\t// make sure matrix is large enough to handle the comparisons\n\t\t(matrix.size < (index+1)).if({\n\t\t\tmatrix = matrix.extend(index+1, Array.new(index+1));\n\t\t\tmatrix.do({ |row, i|\n\t\t\t\t(row.size < (index+1)).if({ matrix[i] = row.extend(index+1); });\n\t\t\t});\n\t\t});\n\t\t\t// no comparison needed for diagonal\n\t\tmatrix[index][index] = (metric: 1, refindex: index, index: index,\n\t\t\tpeak: fftspec.buf.ffts[index].peak, time: fftspec.time);\n\t\tfftspec.buf.matrix = matrix;\n\n\t\t(index > 0).if({\n\t\t\tindex.do({ |i|\n\t\t\t\t~cmpID = ~cmpID + 1;\n\t\t\t\t~cmpqueue.put(~cmpID, fftspec.copy.put(\\cmpindex, i));\n\t\t\t});\n\t\t\t~activateCmpThread.value;\n\t\t});\n\t};\n\n\t~activateCmpThread = { \n\t\t~cmpThread.isNil.if({ ~makeCmpThread.value });\n\t\t~cmpThreadActive.not.if({\n\t\t\tAppClock.sched(0, ~cmpThread);\n\t\t\t~cmpThreadActive = true;\n\t\t});\n\t};\n\t\n\t~makeCmpThread = { \n\t\t~cmpThread = HJHCleanupStream(\n\t\t\tRoutine({\n\t\t\t\tvar\tspec, lastspec, errors = 0, recoveredFrom;\n\t\t\t\tloop {\n\t\t\t\t\tspec = ~cmpqueue.pop;\n\t\t\t\t\tspec.notNil.if({\n\t\t\t\t\t\tlastspec = spec;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t~doComparison.(spec);\n\t\t\t\t\t\t} { |error|\n\t\t\t\t\t\t\t\"\\n\\n\\nERROR IN COMPARISON\\n\\n\".postln;\n\t\t\t\t\t\t\terror.reportError;\n\t\t\t\t\t\t\tspec.postln;\n\t\t\t\t\t\t\terrors = errors + 1;\n\t\t\t\t\t\t\t\"\\n\\nComparison error noted. % error% so far.\\n\"\n\t\t\t\t\t\t\t\t.postf(errors, (errors != 1).if($s, \"\"));\n\t\t\t\t\t\t};\n\t\t\t\t\t\t~cmpwait.wait;\n\t\t\t\t\t}, {\n\t\t\t\t\t\t(~errorRecovery and: { errors > 0 }).if({\n\t\t\t\t\t\t\t~postProgress.if({\n\t\t\t\t\t\t\t\t\"BP(%): Recovering from % error%.\\n\"\n\t\t\t\t\t\t\t\t\t.postf(~collIndex.asCompileString, errors,\n\t\t\t\t\t\t\t\t\t\t(errors != 1).if($s, \"\"));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\trecoveredFrom = ~recoverErrors.(lastspec.buf);\n\t\t\t\t\t\t\terrors = errors - recoveredFrom;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t(errors > 0).if({\n\t\t\t\t\t\t\t\"BP(%): Did not recover from % error%.\\n\"\n\t\t\t\t\t\t\t\t.postf(~collIndex.asCompileString, errors,\n\t\t\t\t\t\t\t\t\t(errors != 1).if($s, \"\"));\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\t// if recording is over and cmpqueue is empty,\n\t\t\t\t\t\t\t// pass to the play action\n\t\t\t\t\t\t(lastspec.buf.status == \\ready).if({\n\t\t\t\t\t\t\t~doAction.(lastspec.buf);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnil.yield;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}),\n\t\t\te { ~cmpThreadActive = false; },\n\t\t\ttrue);\n\t};\n\t\n\t~recoveryTests = 100;\t// number of tests to perform in one wake of the recovery thread\n\t\n\t\t// PRIVATE METHOD -- must be called only in the context of the comparison thread\n\t\t// can't think of a better way than brute force -- but, the nil check is very fast\n\t~recoverErrors = { |buf|\n\t\tvar\tsuccess = 0, matrix, matrixsize, testsdone = 0, ok;\n\t\t(matrix = buf.tryPerform(\\at, \\matrix)).notNil.if({\n\t\t\tmatrixsize = matrix.size;\t// matrix may be extended while this is running\n\t\t\t(matrixsize - 1).do({ |row|\n\t\t\t\tfor(row + 1, matrixsize - 1, { |col|\n\t\t\t\t\tmatrix[row][col].tryPerform(\\at, \\metric).isNil.if({\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t~doComparison.((buf: buf, index: row, cmpindex: col));\n\t\t\t\t\t\t\tsuccess = success + 1;\n\t\t\t\t\t\t};\t// if comparison fails again, second error is swallowed\n\t\t\t\t\t\ttestsdone = 0;\t// reset and yield\n\t\t\t\t\t\t~cmpwait.wait;\n\t\t\t\t\t}, {\n\t\t\t\t\t\t((testsdone = testsdone + 1) == ~recoveryTests).if({\n\t\t\t\t\t\t\ttestsdone = 0;\n\t\t\t\t\t\t\t~cmpwait.wait;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tsuccess\t// return value\n\t};\n\n\t\t// note, this should be called only within the fftThread\n\t~asyncHang = { \n\t\t~saveFFTThread = ~fftThread;\n\t\t~fftThreadWaiting = true;\n\t\tnil.yield;\n\t};\n\t\n\t~asyncUnhang = { \n\t\t~fftThread = ~saveFFTThread;\n\t\t~clock.sched(0, ~fftThread);\n\t\t~fftThreadWaiting = false;\n\t};\n\n//////// FFT ANALYSIS ////////\n\n\t~initFFT = { \n\t\tvar\tresolution, melreso, mel, fhz, melNyquist;\n\n\t\t~fftsize = nextPowerOfTwo(~fftsize ? 2048);\n\t\t~halffft = ~fftsize div: 2;\n\t\t~imag = Signal.fill(~fftsize, 0);\n\t\t~cos = Signal.fftCosTable(~fftsize);\n\t\t\n\t\tresolution = ~sampleRate.value / ~fftsize;\n\t\t~melfreqsize = (~fftsize * 0.125).nextPowerOfTwo.asInteger;\n\t\tmelreso = ~freqToMel.(~sampleRate.value * 0.5) / ~melfreqsize;\n\t\t\n\t\t\t// melmap[mel_bin_index] == first bin index into fft\n\t\t~melmap = Array.fill(~melfreqsize+1, { |i|\n\t\t\tfhz = ~melToFreq.(melreso * i);\n\t\t\t((fhz + (resolution * 0.5)) / resolution).asInteger\n\t\t});\n\t\t\n\t\t~window = ~makeWindow.value;\n\t};\n\n\t~doComparison = { |cmpspec|\n\t\tvar\tmetric = cmpspec.buf.ffts[cmpspec.index]\n\t\t\t.compareData(cmpspec.buf.ffts[cmpspec.cmpindex]);\n\t\t~addToMatrix.(metric, cmpspec.index, cmpspec.cmpindex, cmpspec.buf.matrix,\n\t\t\tcmpspec.buf.ffts, cmpspec.buf.ontimes);\n\t};\n\n//////// DESTRUCTOR ////////\n\n\t~freeCleanup = { \n\t\t~clearAsyncResponder.value;\n\t\t~iMadeMixer.if({ ~chan.free });\n\t\t~userFree.value;\n\t\t~bufs.do({ |b| b.buf.free });\n\t\t[~fftbuf, ~triggerdevice].free;\n\t\t~resp.remove;\n\t};\n}) => PR(\\transient_analysis_incr);\n\n\nAbstractChuckArray.defaultSubType = subtype;\n",
    "windowbounds1024.scd": "\n// set gui window bounds for old 1024x768 layout\n\n~controlpanelBounds = Rect(428, 11, 762, 713);\n~mixerBounds = Rect(-7, -26, 435, 262);\n~codedocBounds = Rect(2, 259, 432, 316);\n~postwindowBounds = Rect(2, 574, 712, 172);\n\n// mixing board gui def\n\n// replace default definition with small skin (horizontal)\nMixerChannelGUI.defaultDef = MixerGUIDef(Point(440, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerPanWidget, MixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 15, 20),\n\t\tRect(25, 5, 15, 20),\n\t\tRect(45, 10, 50, 15),\n\t\tRect(100, 0, 50, 20),\n\t\tRect(155, 10, 40, 15),\n\t\tRect(200, 10, 65, 15),\n\t\tRect(270, 10, 40, 15),\n\t\tRect(315, 0, 50, 20),\n\t\tRect(370, 10, 50, 15)\n\t]);\n\nMixerChannelDef.at(\\mix1x1).guidef = MixerGUIDef(Point(440, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 15, 20),\n\t\tRect(25, 5, 15, 20),\n\t\tRect(45, 10, 50, 15),\n\t\tRect(100, 0, 50, 25),\n\t\tRect(200, 10, 65, 15),\n\t\tRect(270, 10, 40, 15),\n\t\tRect(315, 0, 50, 20),\n\t\tRect(370, 10, 50, 15)\n//\t\tRect(200, 10, 80, 15),\t// old, deprecated\n//\t\tRect(285, 10, 40, 15),\n//\t\tRect(330, 0, 50, 25),\n//\t\tRect(385, 10, 50, 15)\n\t]);\n\nMixerPresendWidget.defaultSliderBounds = Rect(0, 2, 50, 5);\nMixerPresendWidget.defaultMenuBounds = Rect(0, 10, 50, 15);\n\n\n// parameterize VP creation: multiple columns?\n\n~voicerColumns = 1;\n~voicerRows = 6;\n~voicersWith4Controls = 1;\n",
    "windowbounds1280.scd": "\n// set gui window bounds for acer 1280x1024 layout\n\n~controlpanelBounds = Rect(676, 4, 650, 976);\n~mixerBounds = Rect(-1, -26, 676, 264);\t// change\n~codedocBounds = Rect(1, 261, 674, 450);\n~postwindowBounds = Rect(1, 712, 674, 290);\n\n// replace default definition with small skin (horizontal)\nMixerChannelGUI.defaultDef = MixerGUIDef(Point(685, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerPanWidget, MixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 20, 20),\n\t\tRect(30, 5, 20, 20),\n\t\tRect(55, 10, 70, 15),  // 115\n\t\tRect(130, 0, 75, 20),  // 190\n\t\tRect(210, 10, 80, 15), // 245\n\t\tRect(295, 10, 160, 15), // 340\n\t\tRect(460, 10, 50, 15), // 395\n\t\tRect(515, 0, 75, 20),  // 470\n\t\tRect(595, 10, 80, 15)  // 535\n\t]);\n\nMixerChannelDef.at(\\mix1x1).guidef = MixerGUIDef(Point(685, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 20, 20),\n\t\tRect(30, 5, 20, 20),\n\t\tRect(55, 10, 70, 15),  // 115\n\t\tRect(130, 0, 75, 20),  // 190\n\t\tRect(295, 10, 160, 15), // 340\n\t\tRect(460, 10, 50, 15), // 395\n\t\tRect(515, 0, 75, 20),  // 470\n\t\tRect(595, 10, 80, 15)  // 535\n\t]);\n\nMixerPresendWidget.defaultSliderBounds = Rect(0, 2, 75, 5);\nMixerPresendWidget.defaultMenuBounds = Rect(0, 10, 75, 15);\n\n\n// parameterize VP creation: multiple columns?\n\n//~voicerColumns = 1;\n//~voicerRows = 8;\n//~voicersWith4Controls = 4;\n\n\n// experimental, using scroll view\n\n~voicerColumns = 1;\n~voicerRows = 14;\n~voicersWith4Controls = 6;\n~useScroll = true;\n",
    "windowbounds1440.scd": "\n// set gui window bounds for mbp 1440x900 layout\n\n~controlpanelBounds = Rect(534, 4, 916, 852);\n~mixerBounds = Rect(-6, -27, 546, 264);\t// change\n~codedocBounds = Rect(1, 260, 534, 397);\n~postwindowBounds = Rect(1, 658, 675, 220);\n\n// replace default definition with small skin (horizontal)\nMixerChannelGUI.defaultDef = MixerGUIDef(Point(540, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerPanWidget, MixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 20, 20),\n\t\tRect(30, 5, 20, 20),\n\t\tRect(55, 10, 60, 15),  // 115\n\t\tRect(120, 0, 60, 20),  // 190\n\t\tRect(185, 10, 50, 15), // 245\n\t\tRect(240, 10, 100, 15), // 340\n\t\tRect(345, 10, 50, 15), // 395\n\t\tRect(400, 0, 70, 20),  // 470\n\t\tRect(475, 10, 60, 15)  // 535\n\t]);\n\nMixerChannelDef.at(\\mix1x1).guidef = MixerGUIDef(Point(440, 25),\n\t[MixerMuteWidget, MixerRecordWidget, MixerNameWidget, MixerPresendWidget,\n\t\tMixerLevelSliderH, MixerLevelNumber, MixerPostsendWidget,\n\t\tMixerOutbusWidget],\n\t[\tRect(5, 5, 20, 20),\n\t\tRect(30, 5, 20, 20),\n\t\tRect(55, 10, 60, 15),  // 115\n\t\tRect(120, 0, 60, 20),  // 190\n\t\tRect(240, 10, 100, 15), // 340\n\t\tRect(345, 10, 50, 15), // 395\n\t\tRect(400, 0, 70, 20),  // 470\n\t\tRect(475, 10, 60, 15)  // 535\n\t]);\n\nMixerPresendWidget.defaultSliderBounds = Rect(0, 2, 60, 5);\nMixerPresendWidget.defaultMenuBounds = Rect(0, 10, 60, 15);\n\n\n// parameterize VP creation: multiple columns?\n\n~voicerColumns = 2;\n~voicerRows = 7;\n~voicersWith4Controls = 6;\n",
    "proto-cmds.scd": "// need a way for iterator to tell bpcmd whether it stopped automatically or is manually killed\n\n// setcmd doesn't handle synthdesc right\n\n// h. james harkins - jamshark70@dewdrop-world.net\n// not ready for prime time!\n\n// important safety tip: setDoneSignal should not populate the doneSignal variable in a deferred function\n\nvar\tsaveSubType = AbstractChuckArray.defaultSubType;\n\nAbstractChuckArray.defaultSubType = \\tlCmd;\n\nprotect {\n\nProto({\n\t// subclasses should have methods\n\t// ~prep\n\t// ~fire\n\t// ~done\n\t// ~setDoneSignal (optional)\n\t// ~clearDoneSignal (optional)\n\t// ~free (optional)\n\t\n\t~isRunning = false;\n\t\n\t\t// parameters that one might want to override must be included in parentKeys below\n\t~isTLCommand = true;\n\t\t// if true, this command will be included in \\sync or \\cmdSync instructions\n\t~shouldSync = true;\n\t\n\t~play = { |parms|\n//thisThread.clock.beats.debug(\">> %: play\".format(~collIndex));\n\t\tif(~isRunning.not) {\n\t\t\t~setParms.(parms);\n\t\t\t~isRunning = true;\n//~setDoneSignal.postcs;\n//\"calling setDoneSignal\".debug;\n\t\t\t~setDoneSignal.(parms);\n//\"calling fire\".debug;\n\t\t\t~fire.(parms);\n//\t\t\tcurrentEnvironment.changed(\\play, parms);\n\t\t\tNotificationCenter.notify(currentEnvironment, \\play, [parms]);\n\t\t\t~schedDone.(parms);\n\t\t};\n//thisThread.clock.beats.debug(\"<< abstractcmd: play\");\n\t\tcurrentEnvironment\n\t};\n\t~schedDone = { |parms|\n\t\tif(~doneSignal.isNil) {\n\t\t\tthisThread.clock.sched((~dur.value(parms) ? 0), e { ~stop.value });\n\t\t};\n\t};\n\t~stop = { |parms|\n\t\tvar\tnotifyTime;\n\n//currentEnvironment.env.debug(\"abstractcmd: stop\");\n\n\t\tif(~isRunning) {\n\t\t\t~done.(parms);\n\t\t\t~clearDoneSignal.(parms);\n//\"setting isRunning false\".debug;\n\t\t\t~isRunning = false;\n//\"\\nsending done notification\".debug;\n//currentEnvironment.listVars;\n\n\t\t\tif((notifyTime = parms.tryPerform(\\at, \\notifyTime)).notNil) {\n\t\t\t\tthisThread.clock.schedAbs(notifyTime, e {\n\t\t\t\t\tNotificationCenter.notify(currentEnvironment, \\done, [parms]);\n\t\t\t\t});\n\t\t\t} {\n\t\t\t\tNotificationCenter.notify(currentEnvironment, \\done, [parms]);\n\t\t\t};\n//\t\t\tcurrentEnvironment.changed(\\done, parms);\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\t~setParms = { |parms|\n\t\tvar\te = currentEnvironment.env;\n\t\tif(e.proto.isNil) {\n\t\t\te.proto = ();\n\t\t};\n\t\tparms.respondsTo(\\keysValuesDo).if({\n\t\t\te.proto.putAll(parms);\n\t\t});\n\t};\n}, parentKeys: #[isTLCommand, shouldSync]) => PR(\\abstractTLCommand);\n\nPR(\\abstractTLCommand).clone({\n\t~id = 0;\n\t~fire = { |parms|\n\t\tthisThread.clock.beats.debug(\"firing %\".format(~id));\n\t\tcurrentEnvironment\n\t};\n\t~done = { |parms|\n\t\tthisThread.clock.beats.debug(\"done %\".format(~id));\n\t\tcurrentEnvironment\n\t};\n}, parentKeys: #[id]) => PR(\\testTLCmd);\n\n// run an arbitrary function\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\tcurrentEnvironment.env.use({ ~func.valueEnvir });\n\t};\n}) => PR(\\funcCmd);\n\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\tvar\tschedTime;\n\t\t~server ?? { ~server = Server.default };\n\t\t~node = Synth.basicNew(~name, ~server, ~id);\n\t\t~id = ~node.nodeID;\t\t// nil is replaced in basicNew\n\t\t~latency ?? { ~latency = ~server.latency };\n\t\t~args = ~getArgs.value(parms);\n\t\t~quant ?? { ~quant = 0 };\n\t\t~schedTime = ~quant.nextTimeOnGrid(thisThread.clock);\n\t\tthisThread.clock.schedAbs(~schedTime, e {\n\t\t\tif(~latency == 0) {\n\t\t\t\ts.sendBundle(nil, ~node.newMsg(~target, ~args, ~addAction ? \\addToHead))\n\t\t\t} {\n\t\t\t\ts.sendBundle(~latency, ~node.newMsg(~target, ~args, ~addAction ? \\addToHead))\n\t\t\t};\n\t\t});\n\t\tNodeWatcher.register(~node, true);  // true == assumePlaying\n\t\t~node.addDependant(currentEnvironment);\n\t};\n\t~getArgs = { |parms|\n\t\tvar\tresult;\n\t\t~synthDesc ?? {\n\t\t\t~synthDesc = (~descLib ?? SynthDescLib.global).at(~name.asSymbol);\n\t\t};\n\t\t~synthDesc.notNil.if({\n\t\t\tcurrentEnvironment.env.use({ ~synthDesc.msgFunc.valueEnvir });\n\t\t}, {\n\t\t\tparms.tryPerform(\\keysValuesDo, { |key, value|\n\t\t\t\tif(value.isValidUGenInput) {\n\t\t\t\t\tresult = result.add(key).add(value);\n\t\t\t\t};\n\t\t\t});\n\t\t\tresult\n\t\t});\n\t};\n\t~schedDone = { |parms|\n\t\tif(~dur.notNil and: { ~synthDesc.tryPerform(\\hasGate) ? false }) {\n//\"synthCmd scheduling release\".debug;\n\t\t\tthisThread.clock.schedAbs(~schedTime + ~dur, e { ~stop.(parms) });\n\t\t};\t// else -- node had better end on its own and trigger ~update\n\t};\n\t~done = { |parms|\n\t\tvar\tmsg;\n//\">> synthCmd:done\".debug;\n\t\tif(~node.isPlaying) {\n//\"sending release message\".debug;\n\t\t\tif(~synthDesc.notNil and: { ~synthDesc.hasGate }) {\n\t\t\t\tmsg = ~node.setMsg(\\gate, 0);\n\t\t\t} {\n\t\t\t\tmsg = ~node.freeMsg;\n\t\t\t};\n\t\t\tif(~latency != 0) {\n\t\t\t\ts.sendBundle(~latency, msg);\n\t\t\t} {\n\t\t\t\ts.sendBundle(nil, msg);\n\t\t\t};\n\t\t};\n\t\t~node.removeDependant(currentEnvironment);\n//\"<< synthCmd:done\".debug;\n\t};\n\t~update = { |obj, msg|\n\t\tif(obj == ~node and: { msg == \\n_end }) {\n\t\t\t~stop.value;\n\t\t};\n\t};\n\t~isSynth = true;\n}) => PR(\\synthCmd);\n\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n\t\tvar\tsynthDesc;\n//\t\t~setParms.(parms);\n\t\t~nodes = ~iterator.activeCmds.select({ |cmd|\n\t\t\tcmd.tryPerform(\\isSynth) ? false\n\t\t});\n\t\tif(~nodes.size > 0) {\n\t\t\t~nodes.do({ |node|\n\t\t\t\tsynthDesc = node.synthDesc;\n\t\t\t\t~args = ~getArgs.(parms);\n\t\t\t\tif(node.latency == 0) {\n\t\t\t\t\tnode.node.set(*~args);\n\t\t\t\t} {\n\t\t\t\t\tnode.server.sendBundle(node.latency, node.node.setMsg(*~args))\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\t\t~dur = 0;\n\t};\n}).import((synthCmd: #[getArgs, setParms])) => PR(\\setCmd);\n\n\n// Pdef player\n\nPR(\\abstractTLCommand).clone({\n\t~quant = Quant(0);\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\t~name = ~name.asArray;\n\t\t~pdefs = Array(~name.size);\n\t\t~players = Array(~name.size);\n\t\t~name.do({ |name|\n\t\t\tif(Pdef(name).isActive) {\n\t\t\t\t\"Pdef(%) is already playing; ignored\".format(name.asCompileString).warn;\n\t\t\t} {\n\t\t\t\t~pdefs.add(Pdef(name));\n\t\t\t\tif(Pdef(name).clock !== thisThread.clock) {\n\t\t\t\t\tPdef(name).clock = thisThread.clock;\n\t\t\t\t};\n\t\t\t\t\t// user hook to manipulate Pdef before play\n\t\t\t\t~preparePdef.(Pdef(name));\n//name.debug(\"Pdefcmd - playing\");\n//[thisThread.clock.beats, Pdef(name).eventSchedTime(~quant)].debug(\"now, go time\");\n//~quant.dump;\n\t\t\t\tPdef(name).play(thisThread.clock, ~protoEvent, ~quant, ~doReset ? false);\n\t\t\t\t~players.add(Pdef(name).player);\n\t\t\t};\n\t\t});\n\t\tif(~waitForStop == nil) {\n\t\t\t~waitForStop = ~pdefs.collect(_.key);\n\t\t} {\n\t\t\t\t// could be immutable as input\n\t\t\t~waitForStop = ~waitForStop.copy;\n\t\t};\n\t};\n\t~schedDone = { |parms|\n\t\tvar\tstopTime;\n\t\t\t// nothing played\n\t\tif(~pdefs.size == 0) {\n\t\t\t~stop.value;\n\t\t} {\n\t\t\t~pdefs.do({ |pdef| pdef.player.addDependant(currentEnvironment) });\n\t\t\tif(~dur.isNumber and: { ~dur.isStrictlyPositive }) {\n\t\t\t\tstopTime = thisThread.clock.beats + ~dur;\n\t\t\t\tthisThread.clock.sched(~dur - 0.001, e {\n\t\t\t\t\t~stop.value((notifyTime: stopTime));\n\t\t\t\t});\n\t\t\t};\n\t\t};\n\t};\n\t~done = { |parms|\n\t\t\t// if iterator stops automatically and this command should NOT sync,\n\t\t\t// then we don't want the pdefs to stop\n//[~name, parms].debug(\"Pdefcmd:done\");\n\t\tif(~shouldSync or: { parms.tryPerform(\\at, \\manualStop) == true }) {\n//\"stopping pdefs\".debug;\n\t\t\t\t// pdefs will be removed from this array on each stopNow\n\t\t\t\t// so copying the array is necessary\n\t\t\t\t// also at end, this process might be responsible for stopping everything\n\t\t\tif(~stopAll == true, { Pdef.all }, { ~pdefs.copy })\n\t\t\t.do({ |pdef| pdef.stop });\n\t\t}\n\t};\n\t~update = { |obj, what, how|\n\t\tvar\tindex;\n//[obj, what, how].debug(\"Pdefcmd got update\");\n\t\tif(what == \\stopped and: { (index = ~players.indexOf(obj)).notNil }) {\n\t\t\t\t// user hook to reset Pdef after completion\n\t\t\t~pdefs[index].stop;\n\t\t\t~resetPdef.(obj);\n\t\t\t\t// the Pdef has already forgotten about its player\n\t\t\t\t// but I haven't\n\t\t\t~players[index].removeDependant(currentEnvironment);\n\t\t\t~waitForStop.remove(~pdefs[index].key);\n\t\t\t~pdefs.removeAt(index);\n\t\t\t~players.removeAt(index);\n\t\t\tif(~waitForStop.size == 0) {\n\t\t\t\t~stop.value;\n\t\t\t};\n\t\t};\n\t};\t\n}) => PR(\\pdefCmd);\n\n\n// bp command\n\nPR(\\abstractTLCommand).clone({\n\t~quant = NilTimeSpec.new;\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\t~name = ~name.asArray;\n\t\t~bps = Array(~name.size);\n\t\t~name.do({ |name|\n\t\t\tif(BP(name).isPlaying) {\n\t\t\t\t\"BP(%) is already playing; ignored\".format(name.asCompileString).warn;\n\t\t\t} {\n\t\t\t\t~bps.add(BP(name));\n\t\t\t\tif(BP(name).clock !== thisThread.clock) {\n\t\t\t\t\tthisThread.clock => BP(name);\n\t\t\t\t};\n\t\t\t\t\t// user hook to manipulate BP before play\n\t\t\t\t~prepareBP.(BP(name));\n//name.debug(\"bpcmd - playing\");\n//[thisThread.clock.beats, thisThread.clock.baseBarBeat, BP(name).eventSchedTime(~quant)].debug(\"now, basebar, go time\");\n//~quant.dump;\n\t\t\t\tthisThread.clock.schedAbs(BP(name).eventSchedTime(~quant), e {\n\t\t\t\t\t\t// if not running, cmd was stopped before BP fired\n\t\t\t\t\t\t// so skip the .play\n\t\t\t\t\tif(~isRunning) {\n//[~name, thisThread.clock.beats].debug(\"playing bps now\");\n\t\t\t\t\t\tBP(name).play(NilTimeSpec.new, nil, doReset: ~doReset ? false);\n\t\t\t\t\t} {\n\t\t\t\t\t\tBP(name).removeDependant(currentEnvironment);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t\tif(~waitForStop == nil) {\n\t\t\t~waitForStop = ~bps.collect(_.collIndex);\n\t\t} {\n\t\t\t\t// could be immutable as input\n\t\t\t~waitForStop = ~waitForStop.copy;\n\t\t};\n\t};\n\t~schedDone = { |parms|\n\t\tvar\tstopTime;\n\t\t\t// nothing played\n\t\tif(~bps.size == 0) {\n\t\t\t~stop.value;\n\t\t} {\n\t\t\t~bps.do({ |bp| bp.addDependant(currentEnvironment) });\n\t\t\tif(~dur.isNumber and: { ~dur.isStrictlyPositive }) {\n\t\t\t\tstopTime = thisThread.clock.beats + ~dur;\n\t\t\t\tthisThread.clock.sched(~dur - 0.001, e {\n\t\t\t\t\t~bps.copy.do({ |bp| bp.stopNow(notifyTime: stopTime); });\n\t\t\t\t});\n\t\t\t};\n\t\t};\n\t};\n\t~done = { |parms|\n\t\t\t// if iterator stops automatically and this command should NOT sync,\n\t\t\t// then we don't want the bps to stop\n\t\tvar\ttimeSpecForStop = if(~stopAll != true) { NilTimeSpec.new };\n//[~name, parms].debug(\"\\n\\nbpcmd:done\");\n//thisThread.dumpBackTrace;\n\t\tif(~shouldSync or: { parms.tryPerform(\\at, \\manualStop) == true }) {\n//\"stopping bps\".debug;\n\t\t\t\t// bps will be removed from this array on each stopNow\n\t\t\t\t// so copying the array is necessary\n\t\t\t\t// also at end, this process might be responsible for stopping everything\n\t\t\tif(~stopAll == true, { BP.all }, { ~bps.copy })\n\t\t\t.do({ |bp| bp.stopNow(quant: timeSpecForStop) });\n\t\t}\n\t};\n\t~update = { |obj, what, how|\n//[obj.tryPerform(\\collIndex), what, how].debug(\"bpcmd got update\");\n\t\tif(what == \\stop and: { how == \\stopped and: { ~bps.includes(obj) } }) {\n\t\t\t\t// user hook to reset BP after completion\n\t\t\t~resetBP.(obj);\n\t\t\t~bps.remove(obj);\n\t\t\t~waitForStop.remove(obj.collIndex);\n\t\t\tobj.removeDependant(currentEnvironment);\n\t\t\tif(~waitForStop.size == 0) {\n\t\t\t\t~stop.value;\n\t\t\t};\n\t\t};\n\t};\t\n}, parentKeys: #[quant]) => PR(\\bpCmd);\n\n// this command triggers one event in the registered bp's\n// it must be non-syncing and have a cleanup function saved in ~done\nPR(\\abstractTLCommand).clone({\n\t~shouldSync = false;\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\t~name = ~name.asArray;\n\t\t~bps = Array(~name.size);\n\t\t~name.do({ |name|\n\t\t\tif(BP(name).isPlaying) {\n\t\t\t\t\"BP(%) is playing; can't trigger one event\".format(name.asCompileString).warn;\n\t\t\t} {\n\t\t\t\t~bps.add(BP(name));\n\t\t\t\tBP(name).addDependant(currentEnvironment);\n\t\t\t\tif(BP(name).clock !== thisThread.clock) {\n\t\t\t\t\tthisThread.clock => BP(name);\n\t\t\t\t};\n\t\t\t\t\t// user hook to manipulate BP before play\n\t\t\t\t~prepareBP.(BP(name));\n\t\t\t\tthisThread.clock.schedAbs(BP(name).eventSchedTime(~quant), {\n\t\t\t\t\tBP(name).triggerOneEvent(NilTimeSpec.new, nil, doReset: ~doReset ? false);\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t};\n\t~done = { |parms|\n\t\t~cleanup.(parms);\n\t\tif(parms.tryPerform(\\at, \\manualStop) ? false) {\n\t\t\t~bps.do(_.stopNow);\n\t\t};\n\t\t~bps.do({ |bp| bp.removeDependant(currentEnvironment) });\n\t};\n\t~update = { |obj, what, how|\n//[obj.tryPerform(\\collIndex), what, how].debug(\"bp1eventCmd got update\");\n\t\tobj.removeDependant(currentEnvironment);\n\t\tswitch(what)\n\t\t\t\t// triggerOneEvent failed\n\t\t\t{ \\oneEventEmpty } { ~stop.value }\n\t\t\t\t// somebody else started playing the process - this guy is dead now\n\t\t\t{ \\play } { ~stop.value };\n\t};\t\n}, #[shouldSync]) => PR(\\bp1eventCmd);\n\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\tthisThread.clock.setMeterNextBar(~beatsPerBar);\n\t\t~stop.();\n\t};\n}) => PR(\\meterCmd);\n\n// REALLY experimental: flow-of-control commands\n\n// looping over a whole array\n// how to stop: same as others, set a user signal or specify a duration\n\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n//\t\t~setParms.(parms);\n\t\t~myIterator = TLSequenceIterator(~cmds, autoSync: true);\n\t\t\t// looping works by receiving \"stop\" signal, then restarting upon that signal\n\t\t~myIterator.addDependant(currentEnvironment);\n\t\t~myIterator.play;\n\t};\n\t~done = { |parms|\n\t\t~myIterator.stop;\n\t};\n\t~update = { |obj, what|\n\t\tif((~isRunning ? false) and: { what == \\done }) {\n\t\t\t\"got done notification; looping back\".postln;\n\t\t\t~myIterator.play;\n\t\t};\n\t};\n}) => PR(\\loopCmd);\n\n// send user-defined notification from the iterator\nPR(\\abstractTLCommand).clone({\n\t~fire = { |parms|\n//[~iterator, parms.atBackup(\\notification, currentEnvironment), parms].debug(\"notifyCmd\");\n\t\tparms[\\iterator].changed(parms.atBackup(\\notification, currentEnvironment),\n\t\t\tparms ?? ~parms);\n\t};\n}) => PR(\\notifyCmd);\n\n\n// SECTION object\n// responsible for saving bp states and selecting sequences (if needed) by user input\n\nProto({\n\t~name = \"\";\t\t// to display in GUI\n\t~autoRestoreStates = true;\n\t~bps = nil;\t// fill in with an array of BP names (symbols)\n\t~status = \\idle;\n\t~autoSync = true;\t// passed into TLSequenceIterator\n\n\t~isLoaded = false;\n\n\t\t// parent will call this one\n\t~prInitProc = {\n\t\tif(~isLoaded.not) {\n\t\t\t~initProcesses.();\n\t\t\t~isLoaded = true;\n\t\t};\n\t};\n\t\n\t~prUnload = {\n\t\tif(~isLoaded) {\n\t\t\t~unloadProcesses.();\n\t\t\t~isLoaded = false;\n\t\t};\n\t};\n\n\t~initProcesses = nil;\t\t// user-supplied function to load resources\n\t~unloadProcesses = nil;\n\n\t~play = { |savedCmds|\n\t\tif(~isRunning.().not) {\n\t\t\t~savedCmds = savedCmds;\n//savedCmds.debug(\"section:play - savedcmds\");\n\t\t\t~clock ?? { ~clock = TempoClock.default };\n\t\t\t~initStates.();\n\t\t\t~preparePlay.();\n\t\t\t~seqPlayer = ~makeSeqPlayer.();\n\t\t\t~clock.sched(0, ~seqPlayer);\n\t\t\t~status = \\running;\n\t\t\tcurrentEnvironment.changed(\\play);\n\t\t\t~schedDone.();\n\t\t};\n\t};\n\t~schedDone = {\n\t\tvar\tnow = thisThread.clock.beats;\n\t\tif(~dur.notNil) {\n\t\t\t~clock.sched(~dur - 0.001, e { ~stop.(now + ~dur) });\n\t\t}\t// else, there should be a user input trigger to move to the next section\n\t};\n\t~stop = { |notifyTime, manualStop = true|\n\t\tif(~isRunning.()) {\n\t\t\t~status = \\idle;\n\t\t\t~currentIterator.stop((manualStop: manualStop ? true));\n\t\t\t~done.();\n\t\t\t~clearDoneSignal.();\n\t\t\t~clock.schedAbs((notifyTime ?? { ~clock.beats }), e {\n//~clock.beats.debug(\"sending done notification at\");\n//~savedCmds.debug(\"with these saved commands\");\n\t\t\t\tcurrentEnvironment.changed(\\done, ~savedCmds);\n\t\t\t});\n\t\t\tif(thisThread === ~seqPlayer) {\n\t\t\t\tnil.yield\n\t\t\t} {\n\t\t\t\t~seqPlayer.stop;\n\t\t\t};\n\t\t};\n\t\tcurrentEnvironment\n\t};\n\t~done = {\n\t};\n\t\n\t~isRunning = { ~status != \\idle };\n\t\n//\t~saveStates = {\n//\t\tvar\tbps;\n//\t\tbps = ~bps ?? { BP.keys };\n//\t\t~states ?? { ~states = IdentityDictionary.new };\n//\t\tbps.do({ |bp|\n//\t\t\t~states.put(bp, BP(bp).archiveState);\n//\t\t});\n//\t};\n//\t~restoreStates = {\n//\t\tif(~states.notNil) {\n//\t\t\t~states.keysValuesDo({ |bpname, archive|\n//\t\t\t\tBP(bpname).restoreArchive(archive);\n//\t\t\t})\n//\t\t};\n//\t};\n//\t\n//\t~initStates = {\n//\t\tif(~states.isNil) {\n//\t\t\t~saveStates.()\n//\t\t} {\n//\t\t\tif(~autoRestoreStates) {\n//\t\t\t\t~restoreStates.();\n//\t\t\t};\n//\t\t};\n//\t};\n\n\t~makeSeqPlayer = {\n//\t\t~seqStream ?? { ~seqStream = ~seqPattern.().asStream };\n\t\t\t// should always reset: start from beginning of section every time you play\n\t\t~seqStream = ~seqPattern.().asStream;\n\t\t\t// ~condition is used elsewhere, not here, but needs to exist\n\t\t~condition ?? { ~condition = Condition.new };\n\t\tRoutine({ |inval|\n\t\t\tvar\titem, delta;\n\t\t\tloop {\n\t\t\t\titem = ~seqStream.next(~seqEventProto);\n\t\t\t\tif(item.notNil) {\n\t\t\t\t\tdelta = ~playItem.(item);\n\t\t\t\t\tdelta.yield;\t// playItem returns time to wait\n\t\t\t\t} {\n\t\t\t\t\t~stop.(nil, false)\n\t\t\t\t};\n\t\t\t}\n\t\t})\n\t};\n\t\n\t~update = { |obj, what, args|\n//[obj, what, args].debug(\"section % received update\".format(~name));\n\t\tif(obj === ~currentIterator) {\n\t\t\tswitch(what)\n\t\t\t\t{ \\done } {\n\t\t\t\t\tobj.removeDependant(currentEnvironment);\n\t\t\t\t\t\t// iterator might remove commands after this happens\n\t\t\t\t\t~savedCmds = args.copy;\n//args.debug(\"section:update - savedcmds\");\n//~savedCmds.debug(\"savedCmds variable\");\n\t\t\t\t\tif(~status == \\sync) { ~condition.unhang };\n\t\t\t\t}\n\t\t};\n\t\t\t// a command might send a notification that's really meant for the section sequencer\n\t\t\t// it can set the passthru flag\n\t\t\t// try returns nil if there's an error\n\t\tif(try { args[\\passthru] } == true) {\n//\"passing notification thru\".debug;\n\t\t\tcurrentEnvironment.changed(what, args)\n\t\t};\n\t};\n\t\n\t~playItem = { |item|\n\t\tvar\tseq = item[\\sequence], dur = item[\\dur],\n\t\t\titerator, /*updater, */quant;\n\t\tif(seq.size > 0) {\n\t\t\t~currentIterator = iterator = TLSequenceIterator(seq, currentEnvironment,\n\t\t\t\tautoSync: ~autoSync).play(0, ~clock, ~savedCmds);\n\t\t\t~savedCmds = nil;\n//\"section playItem: set savedCmds to nil\".debug;\n\t\t\titerator.addDependant(currentEnvironment);\n\t\t};\n\t\tcase\n\t\t\t{ dur.isNumber and: { dur >= 0.001 } } {\n\t\t\t\t~clock.sched(dur - 0.001, {\n\t\t\t\t\titerator.removeDependant(currentEnvironment);\n\t\t\t\t\titerator.stop;\n\t\t\t\t});\n\t\t\t\tdur\t// return value\n\t\t\t}\n\t\t\t\t// cannot sync if there's nothing to play\n\t\t\t{ dur == \\sync and: { iterator.notNil } } {\n\t\t\t\t~status = \\sync;\n\t\t\t\t~condition.hang;\n\t\t\t\t~status = \\running;\n\t\t\t\t0\t// after waking up, go immediately\n\t\t\t}\n\t\t\t{ dur == \\trigger } {\n\t\t\t\t~setTrigger.(item);\n\t\t\t\t~status = \\waitForTrigger;\n\t\t\t\t~condition.hang;\n\t\t\t\t~status = \\running;\n\t\t\t\titem[\\quant].asQuant.nextTimeOnGrid(~clock) - ~clock.beats\n//\t\t\t\t0\t// after waking up, go immediately\n\t\t\t}\n\t\t\t{ (quant = dur.tryPerform(\\asQuant)).notNil } {\n\t\t\t\tquant = quant.nextTimeOnGrid(~clock) - ~clock.beats;\n\t\t\t\t~clock.sched(quant - 0.001, {\n\t\t\t\t\titerator.removeDependant(currentEnvironment);\n\t\t\t\t\titerator.stop;\n\t\t\t\t});\n\t\t\t\tquant\n\t\t\t}\n\t\t\t{ seq == \\initNext } {\n\t\t\t\tcurrentEnvironment.changed(\\initNext);\n\t\t\t\tdur\n\t\t\t}\n\t\t\t\t// default case: invalid object - stop rather than loop infinitely\n\t\t\t{\n\t\t\t\tMethodError(\"Invalid item in section\", item).throw\n\t\t\t}\n\t};\n\n\t~setTrigger = { |item|\n\t\tif(~currentTriggerItem.isNil) {\n\t\t\t~currentTriggerItem = item;\n\t\t\titem[\\init].(item);\n\t\t} {\n\t\t\t\"Another trigger is already active. Ignored.\".warn;\n\t\t};\n\t};\n\t~cleanupTrigger = { |triggerID, parms|\n\t\tif(~currentTriggerItem.notNil) {\n\t\t\t~currentIterator.stop;\n\t\t\t~currentTriggerItem[\\clear].(~currentTriggerItem, triggerID, parms);\n\t\t\t~currentTriggerItem = nil;\n\t\t};\n\t};\n\t~doTrigger = { |triggerID, parms|\n\t\tif(~status == \\waitForTrigger) {\n\t\t\tif(~receivedTrigger.(triggerID, parms)) {\n\t\t\t\t~status = \\running;\n\t\t\t\t~cleanupTrigger.(triggerID, parms);\n\t\t\t\t~condition.unhang;\n\t\t\t} {\n\t\t\t\t\"Received inactive trigger %; ignored.\".format(triggerID).warn;\n\t\t\t};\n\t\t} {\n\t\t\t\"Section is not waiting for user trigger. Cannot ~doTrigger now.\".warn;\n\t\t};\n\t};\n\t~receivedTrigger = { |triggerID, parms|\n\t\t~currentTriggerItem[\\id].matchItem(triggerID)\n\t\t\tand: { ~currentTriggerItem[\\verify].(~currentTriggerItem, parms) ? true }\n\t};\n\t\t// SEQUENCE SELECTION\n\t\t// up to you to decide how to store sequences\n\t\t// pattern must return events (i.e., you can use Pbind) with\n\t\t// (sequence: array for TLSeqIt, dur: timing info)\n\t\t// sequence = nil means pause based on timing\n\t\t// dur = number, run sequence for exactly dur beats (Quant OK too)\n\t\t// dur = \\sync, resume section when sequence stops\n\t\t// dur = \\trigger (or nil), wait for some user signal - user's responsibility to maintain\n\t~seqPattern = {};\t// you supply!\n\t~seqEventProto = ();\n}) => PR(\\tlSection);\n\nProto({\n\t\t// should send .changed(\\section, sectionIndex) when moving to a new section\n\n\t~sections = [];\t// supply array of sections\n\t~status = \\idle;\n\t\n\t~currentSection = 0;\n\t\n\t~countOffBeats = 4;\n\t~clock = TempoClock.default;\n\t~quant = Quant(1);\t// start (to count off) on next whole bar\n\t~sectionLeadTime = 0.9;\t// how many beats before barline to kick off the section\n\t\n\t~autoReset = true;\t// automatically reset all BPs?\n\t~doNotReset = nil;\t// collection of bp names NOT to reset\n\t\n\t~condition = Condition.new;\n\t\n\t~isRunning = { ~status != \\idle };\n\t\n\t~recvPlayButton = { |section|\n\t\tif(~isRunning.()) { ~stop.() }\n\t\t\t{ ~currentSection = section ?? { ~currentSection }; ~play.() };\n\t};\n\t\n\t~play = {\n//\">> sectionSequencer:play\".debug;\n\t\tif(~autoReset) {\n\t\t\t~doReset.();\n\t\t};\n\t\t~startingSection = ~currentSection;\n\t\t~loadResources.(~currentSection);\n\t\t~countOffAndGo.();\n//\t\t~status = \\playing;\n\t\tcurrentEnvironment.changed(\\play);\n//\"<< sectionSequencer:play\".debug;\n\t};\n\t\n\t~stop = { |lastSection = false|\n//lastSection.debug(\">> sectionSequencer:stop\");\n\t\tif(~status == \\countingOff) {\n\t\t\t~status = \\idle;\n\t\t\t~countOffRoutine.stop;\n\t\t\tcurrentEnvironment.changed(\\stop);\n\t\t\tcurrentEnvironment.changed(\\countoff, nil);\n\t\t} {\n\t\t\t~sections[~currentSection].stop/*(nil, manualStop)*/;\n\t\t\t\t// must force manual stop for last section at end of piece\n\t\t\t\t// but this didn't work\n\t\t\tif(lastSection ? false) { ~sections.last.stop(nil, true) };\n//\t\t\tif(thisThread === ~sectionRoutine) { nil.yield }\n//\t\t\t\t{ ~sectionRoutine.stop };\n\t\t\t~status = \\idle;\n\t\t\t~currentSection = ~startingSection;\n\t\t\tcurrentEnvironment.changed(\\stop);\n\t\t\tcurrentEnvironment.changed(\\section, ~currentSection);\n\t\t\t~savedCmds = nil;\n\t\t\t~sectionRoutine.stop;\n\t\t\t~sectionRoutine = nil;\n\t\t};\n//\"<< sectionSequencer:stop\".debug;\n\t};\n\t\n\t~loadResources = { |section|\n//section.debug(\">> loadResources\");\n\t\t\t// must add 1 because do runs from 0 to n-1\n\t\t(section+1).do({ |sect|\n\t\t\tif(~sections[sect].isLoaded.not.debug(\"section % needs to load\".format(sect))) {\n\t\t\t\t~sections[sect].prInitProc;\n\t\t\t};\n\t\t});\n//debug(\"<< loadResources\");\n\t};\n\t\n\t~countOffAndGo = {\n\t\tvar\tgoTime = ~quant.nextTimeOnGrid(~clock) + ~countOffBeats - ~sectionLeadTime,\n\t\t\tstarted = false;\n\n//[~clock.baseBarBeat, ~clock.beats, ~quant.nextTimeOnGrid(~clock), goTime].debug(\"starting countoff - base beat, now, quant time, go time\");\n\n\t\t~status = \\countingOff;\n\t\t~clock.schedAbs(~quant.nextTimeOnGrid(~clock), ~countOffRoutine = Routine({\n\t\t\tcurrentEnvironment.changed(\\countoff, \\init);\n\t\t\t\t// count off first\n\t\t\t~countOffBeats.do({ |count|\n\t\t\t\tcurrentEnvironment.changed(\\countoff, count + 1);\n\t\t\t\tif(started.not and: { goTime - thisThread.clock.beats < ~sectionLeadTime }) {\n\t\t\t\t\tstarted = true;\n\n//[~clock.beats, goTime].debug(\"starting section player - now, go time\");\n\n\t\t\t\t\tthisThread.clock.schedAbs(goTime, ~sectionRoutine = Routine({\n\t\t\t\t\t\t~status = \\playing;\n\t\t\t\t\t\twhile { ~isRunning.() and: { ~currentSection < ~sections.size } } {\n//~savedCmds.debug(\"playing section % with saved cmds\".format(~sections[~currentSection].name));\n\t\t\t\t\t\t\t~sections[~currentSection].play(~savedCmds);\n//\"section sequencer: set savedCmds to nil\".debug;\n\t\t\t\t\t\t\t~savedCmds = nil;\n\t\t\t\t\t\t\t\t// ~update method below will catch notifications\n\t\t\t\t\t\t\t~sections[~currentSection].addDependant(currentEnvironment);\n\t\t\t\t\t\t\t~condition.hang;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t~stop.(true);\t// stop last section\n\t\t\t\t\t}));\n\t\t\t\t};\n\t\t\t\t1.0.wait;\n\t\t\t});\n\t\t\t~countOffRoutine = nil;\n\t\t\tcurrentEnvironment.changed(\\countoff, nil);\n\t\t\t\t// removing initial meter\n\t\t\t\t// section should run its own conductor slightly in advance of the true barline\n\t\t\t\n//\t\t\t\t// in theory nothing should be playing now\n//\t\t\t\t// so it should be OK to set this even off the barline\n//\t\t\tthisThread.clock.setMeterAtBeat(~sections[~currentSection].startBeatsPerBar,\n//\t\t\t\tthisThread.clock.beats);\n//[~clock.beatsPerBar, ~clock.baseBar, ~clock.baseBarBeat].debug(\"after setting initial meter\");\n\t\t}));\n\t};\n\t\n\t~doReset = {\n\t\t(BP.keys - ~doNotReset.as(IdentitySet)).do({ |name|\n\t\t\tBP(name).reset;\n\t\t});\n\t};\n\t\n\t~gotoSection = { |section|\n\t\tif(~isRunning.()) {\n\t\t\tMethodError(\"Cannot change section while playing\", currentEnvironment).throw;\n\t\t} {\n\t\t\t~currentSection = section;\n\t\t\tcurrentEnvironment.changed(\\section, section);\n\t\t};\n\t};\n\t~currentSection_ = { |section| ~gotoSection.(section) };\n\t\n\t~countOffBeats_ = { |beats|\n\t\t~countOffBeats = beats;\n\t\tcurrentEnvironment.changed(\\countOffBeats, beats);\n\t};\n\t\n\t~autoReset_ = { |autoReset|\n\t\t~autoReset = autoReset;\n\t\tcurrentEnvironment.changed(\\autoReset, autoReset);\n\t};\n\t\n\t~update = { |obj, what, args|\n//[obj, what, args].debug(\"section sequencer got update\");\n\t\tvar\tsection;\n\t\tif(obj === ~sections[~currentSection]) {\n\t\t\tswitch(what)\n\t\t\t\t{ \\done } {\n//args.debug(\"section sequencer update - savedCmds\");\n\t\t\t\t\t~savedCmds = args;\n\t\t\t\t\tobj.removeDependant(currentEnvironment);\n\t\t\t\t\tif(~isRunning.()) {\n\t\t\t\t\t\t~currentSection = ~currentSection + 1;\n//~currentSection.debug(\"section done, moving to\");\n\t\t\t\t\t\tcurrentEnvironment.changed(\\section, ~currentSection);\n\t\t\t\t\t\t~condition.unhang;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t{ \\initNext } {\n\t\t\t\t\tif(~sections[~currentSection + 1].notNil) {\n\t\t\t\t\t\t~sections[~currentSection + 1].prInitProc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{ \\unload } {\n//[obj, what, args].debug(\"got unload message\");\n\t\t\t\t\targs.tryPerform(\\at, \\name).asArray.do { |sectName|\n//sectName.debug(\"checking\");\n\t\t\t\t\t\tif((section = ~sections.detect { |sct| sct.name == sectName }).notNil) {\n//sectName.debug(\"unloading one\");\n\t\t\t\t\t\t\tsection.prUnload;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t};\n\t};\n\t~sectionNames = { ~sections.collect({ |sect, i| \"%: %\".format(i+1, sect.name) }) };\n}) => PR(\\sectionSequencer);\n\nPR.allOfType(\\tlCmd).do({ |pr|\n\tpr.value.put(\\collIndex, pr.collIndex)\n});\n\n} { AbstractChuckArray.defaultSubType = saveSubType; };\n",
    "noodle-init.scd": "\n//////// Algorithmic Noodling - H. James Harkins\n//////// Definition file - load once at beginning of performance\n\n\n\n// For ease of clean-up, all these objects will be identified with the subType \\noodle\n// future object creation should not be affected, so I have to save the current subType\nvar\tsaveSubtype = AbstractChuckArray.defaultSubType, master;\n\nAbstractChuckArray.defaultSubType = \\noodle;\n\nprotect {\t// to reset the subType even in case of error\n\n// I always keep a single master MixerChannel\n// a previous piece in the same performance might have created it,\n// so check before making a new one\nmaster = ~master = ~master ?? { MixerChannel(\\master, s, 2, 2, level: 1) };\n\n// The separate environment is for shared resources.\n// See the performance script file to see how it's used.\n~noodle = Environment.make({\n\n~master = master;\t// master needs to be in this environment as well as topEnvironment\n\n~rvbmc = MixerChannel(\\reverb, s, 2, 2, level: 1, outbus: ~master, completionFunc: { |chan|\n\tchan.playfx({ |outbus|\n\t\tvar\tl, r;\n\t\t#l, r = In.ar(outbus, 2);\n\t\tFreeVerb2.ar(l, r, 1.0, 0.6, 0.5)\n\t});\n});\n\n// I know the path of the audio files relative to this file\n// this gets the directory where this file is located\n~root = PathName(thisProcess.nowExecutingPath).pathOnly;\n\nTempoClock.default.tempo = 76/60;\n\n//////// VOICER FACTORIES\n\n/***\nThe factory contains an environment. When you instantiate the factory, the environment is copied and new resources, such as ~target, ~cbuf, ~mbuf in the first factory here, are saved into this environment. Both the voicer and the environment go into the VC storage object. When the voicer is no longer needed, the VC can enter its unique environment and call the ~free function to clean up these other objects as well.\n***/\n\n// \"keys\" are environment variables in the current environment to pass into the factory at creation time\n(keys: #[master, rvbmc], make: {\n\tvar\tout;\n\t\t// ~master, one of the keys, is used here\n\t\t// the Voicer's output MixerChannel should always be called ~target in the factory\n\t~target = MixerChannel(\\bass, s, 1, 2, level: -11.dbamp, outbus: ~master);\n\t~target.newPostSend(~rvbmc, 0.368);\n\t\t// other resources stored in the factory environment\n\t~cbuf = Buffer.alloc(s, 1024, 1, completionMessage: { |buf|\n\t\tbuf.sine1Msg(#[1]);\n\t});\n\t~mbuf = Buffer.alloc(s, 1024, 1, completionMessage: { |buf|\n\t\tbuf.sine1Msg(#[1, 1]);\n\t});\n\t\t// fm is more pronounced in a higher register\n\t\t// this SynthDef compensates by scaling mod_lev according to note frequency\n\t\t// if f = frequency, b = base frequency, m = mod lev, and k = scaling sensitivity,\n\t\t// scaled modulation is m / (((f / b) - 1) * k + 1)\n\t\t// fewer UGens as the algebraic equivalent m * b / ((f * k) + (b * (1-k)))\n\t\t// here b=102.2 and k=0.5 are hardcoded\n\tSynthDef(\\fmbass, { |freq, gate, freqlag, cbuf, mbuf, mod_ratio, mod_lev, detune, car_vs, mod_vs, outbus|\n\t\tvar sig, mod, car_amp, mod_amp;\n\t\tfreq = Lag.kr(freq, freqlag);\t// for monophonic portamento\n\t\tmod_lev = mod_lev * 102.2 / ((freq * 0.5) + (102.2*0.5));\n\t\t\t// \"sensitivity\" formula - scaling relative to 1.0, not 0\n\t\t\t// see the ddwSensitivity quark\n\t\tcar_amp = Latch.kr((gate-1) * car_vs + 1, gate);\n\t\tmod_amp = Latch.kr((gate-1) * mod_vs + 1, gate)\n\t\t\t* EnvGen.kr(Env.adsr(0.01, 0.2, 0.4, 0.21), gate);\n\t\tmod = Osc.ar(mbuf, freq * mod_ratio + detune, 0, mod_amp * mod_lev);\n\t\tsig = Osc.ar(cbuf, freq + (mod * freq), 0, car_amp)\n\t\t\t* EnvGen.kr(Env.adsr(0.01, 1, 0.9, 0.05), gate, doneAction:2);\n\t\tOut.ar(outbus, sig);\n\t}).add;\n\tout = MonoPortaVoicer(1, \\fmbass, [cbuf: ~cbuf, mbuf: ~mbuf, mod_ratio: 0.5,\n\t\tdetune: 0.35, car_vs: 0.37, mod_vs: 0.56], target: ~target)\n\t\t.portaTime_(0.08);\n\tout.mapGlobal(\\mod_lev, nil, 3.3, #[1.0, 12.0, \\exp]);\n\tout\t// ~make function must return the Voicer itself\n}, free: { [~target, ~cbuf, ~mbuf].free }, type: \\voicer) => Fact(\\bass_v);\n\n\n(keys: #[master, rvbmc], make: {\n\tvar\tf;\n\t~target = MixerChannel(\\jumpy, s, 2, 2, -14.dbamp, outbus: ~master, completionFunc: nil);\n\t~target.newPostSend(~rvbmc, 0.9);\n\t\n\tf = { |i| (i / 14) * 0.3pi - 0.2 };\n\t~bufs = Buffer.allocConsecutive(6, s, 2048, 1, completionMessage: { |buf, j|\n\t\tbuf.sine1Msg({ |i| (i%6 == j).if(0, { cos(f.(i)) }) } ! 14);\n\t});\n\t\n\tSynthDef(\\jumpy, { arg freq, gate, bufbase, bufmod, vsens, detune, pan,\n\t\t\tffreq, rq, lag = 0.1, outbus;\n\t\tvar sig, amp, buf;\n\t\tamp = Latch.kr((gate-1) * vsens + 1, gate);\n\t\t\t// the bufenv should know how many buffers it's covering\n\t\tbuf = bufbase + bufmod;\n\t\tsig = VOsc3.ar(buf, freq/detune, freq, freq*detune, amp)\n\t\t\t* EnvGen.kr(Env.adsr(0.01, 0.07, 0.4, 0.08), gate, doneAction:2);\n\t\tffreq = Lag.kr(ffreq, lag);\n\t\trq = Lag.kr(rq, lag);\n\t\tpan = Lag.kr(pan, lag);\n\t\tOut.ar(outbus, Pan2.ar(RLPF.ar(sig, ffreq, rq), pan));\n\t}).add;\n\t\n\tMonoPortaVoicer(1, \\jumpy, [bufbase: ~bufs.first, vsens: 0.677, detune: 0.99606], target:~target).portaTime_(0.1);\n}, free: { [~target, ~bufs].free }, type: \\voicer) => Fact(\\jumpy_v);\n\n\n(keys: #[master, rvbmc], make: {\n\tvar\tout;\n\t~target = MixerChannel(\\pad, s, 2, 2, level: -20.dbamp, outbus: ~master, completionFunc: { |chan|\n//\t\tchan.playfx(Instr(\"busfx.chorus2\"), [20, 1, 2, 3, 0.0099076721080885, 0.12388629239938, 0.0026448039935914, 0.7306029426953, 0.4]);\n\t\t\t\t// standard mono-to-stereo chorusing technique\n\t\tvar\tchorus = chan.playfx({ |outbus|\n\t\t\tvar\tsig = In.ar(outbus, 1) * 0.4,\n\t\t\t\tmods = { |i|\n\t\t\t\t\tSinOsc.kr(0.12388629239938 * rrand(0.9, 1.1),\n\t\t\t\t\t\t0.7306029426953 * i,\n\t\t\t\t\t\t0.0026448039935914, 0.0099076721080885);\n\t\t\t\t} ! (3 * 2);\n\t\t\tsig = DelayC.ar(sig, 0.5, mods);\n\t\t\tMix(sig.clump(2))\n\t\t});\n\t\tchan.newPostSend(~rvbmc, 0.6);\n\t\t\t// \"set it and forget it\" multiband EQ class in my library\n\t\t\t// there is also MultiEQ for EQs whose parameters you'll need to change\n\t\tStaticEQ.new(2, \\eq, 551.972, -6.383.dbamp, 1.054, \\hishelf, 1944.083, 4.681.dbamp, 1)\n\t\t\t.play(chan);\n\t\t\t// make sure chorus precedes EQ\n\t\tSystemClock.sched(0.5, { chorus.moveToHead(chan.effectgroup) });\n\t});\n\t\n\t\t// This is a trick I like to use to save CPU for pads.\n\t\t// Usually you play thick chords on pads, and band limited oscillators \n\t\t// are not CPU cheap. But, wavetable oscillators alias at higher\n\t\t// frequencies. This technique uses an array of wavetables, with\n\t\t// successively decreasing harmonic content. Note frequency\n\t\t//maps onto the buffer with the right number of partials,\n\t\t// so you get speed and a clean sound.\n\t~bufs = Buffer.allocConsecutive(8, s, 2048, 1, completionMessage: { |buf, i|\n\t\tvar\tbase = 48 + (i * 12),\t\t// max here is 132, just above highest MIDI note number\n\t\t\tnumHarmonics = (20000 / base.midicps).asInteger;\n\t\tbuf.sine1Msg((1..numHarmonics).reciprocal)\n\t});\n\t\n\tSynthDef(\\padmap, { |freq, gate, bufbase, numbufs, vsens, detune,\n\t\t\tffreq, rq, outbus|\n\t\tvar\tamp = Latch.kr((gate-1) * vsens + 1, gate),\n\t\t\ttop = (127.midicps / 48.midicps).log2,\n\t\t\tfreqmap = (freq / 48.midicps).log2,\n\t\t\tbufmod = LinLin.kr(freqmap, 0, top, 0, numbufs-1).clip(0, numbufs-1.01),\n\t\t\tbuf = bufbase + bufmod,\n\t\t\tsig;\n\t\tsig = VOsc3.ar(buf, freq/detune, freq, freq*detune, amp);\n\t\tsig = RLPF.ar(sig, ffreq, rq)\n\t\t\t* EnvGen.kr(Env.adsr(0.4, 0.5, 0.8, 1.8), gate, doneAction:2);\n\t\tOut.ar(outbus, sig)\n\t}).add;\n\t\n\tout = Voicer(20, \\padmap, [bufbase: ~bufs.first, numbufs: ~bufs.size, vsens: 0.3,\n\t\tdetune: 1.00394], target: ~target);\n\tout.mapGlobal(\\ffreq, nil, 1200, \\freq);\n\tout.mapGlobal(\\rq, nil, 1.0, [1.0, 0.05, \\exp]);\n\t\n\tout\n}, free: { [~target, ~bufs].free }, type: \\voicer) => Fact(\\pad_v);\n\n\n\n//////// PROCESS FACTORIES\n\n// silent process to determine harmonic context\n// writes current bass note into Library under key \\currentBassNote\n// also sends notification -- we'll use this for a bass arpeggiator\n(make: { |name|\n\tPR(\\aiBass) => BP(name);\n\tMBM(0)[\\roots] => BP(name);\t// source melody data\n\tMBM(0)[\\rootsadp] => BP(name);\t// data for generating variations\n\tBP(name).useRh = true;\n\t\t// Normally in a melodic process, you want to preserve the original rhythm.\n\t\t// Here, the rhythm determines harmonic rhythm,\n\t\t// which I want to generate randomly within a specific range.\n\t\t// So I supply a rhythm profile, which is a Proto object that defines\n\t\t// a pattern to return durations and lengths.\n\tBP(name).rhythm = PR(\\abstractProcess).copy.make({\n\t\t~asPattern = {\n\t\t\t~deltaStream ?? { ~deltaStream = ~delta.asStream };\n\t\t\tPfunc(e { ~deltaStream.next.dup });\n\t\t};\n\t\t~delta = Pwhite(5, 14, inf) * 0.5;\t// (2.5, 3.0 .. 7.0)\n\t});\n\t\t// the adaptation techniques to use\n\tPrand(#[absSplice, intSplice], inf) =>.adapt BP(name);\n\t\t// validation: all notes in a new variation must be between\n\t\t// scale degrees 17 and 28\n\tBP(name).eugTest = \\eugRangeOnlyTest;\n\tBP(name).range = NumericRange(17, 28);\n\t\t// timing correction for data sharing - see readme\n\tBP(name).leadTime = 0.1;\t// roots must fire before everyone else\n\tBP(name)\n}, type: \\bp) => Fact(\\roots);\n\n\n// The bassline is technically an arpeggiator process that spins out figuration over the last root note chosen by the \\roots process. It is a nested process -- the inner layer, PR(\\arpeg1), generates the notes, and the outer layer, PR(\\macroRh), populates data per harmony event that \\arpeg1 needs.\n\n(make: { |name|\n\tBP(name).free;\n\tPR(\\arpeg1) => BP(name);\t// child process (inner layer)\n\t\t// Func(\\fitToBass) defines how to fit figuration to harmonic context\n\tBP(name).fitFunc = \\fitToBass;\n\tPR(\\macroRh) => BP(name);\t// wrap inner layer inside outer layer\n\tBP(name).bassUpdate = false;\n\tMBM(0)[\\bassfigs] => BP(name);\t// source \"chords\"\n\t\t// a dummy \"macrorhythm\" that reads the data from the last root note\n\tPfunc({ [~parentDelta, ~parentLength] }) =>.macro BP(name);\n\t\\bass1 =>.micro BP(name);\t// per-note rhythm\n\t\\xrand =>.arpeg BP(name);\t// order to arpeggiate notes\n\t\\gdor.asMode => BP(name);\t// mode, or \"key\"\n\tBP(name).leadTime = 0.1;\t// schedules the same as roots\n\tBP(name)\n}, type: \\bp) => Fact(\\bass);\n\n// This defines the observer process that listens for new root notes, and passes the information to the bass process.\n(make: { |name|\n\t\t// BP(\\roots) is the process whose events we're listening for\n\t\t// it must exist before initializing the link process\n\tBP(\\roots).exists.not.if({\n\t\tFact(\\roots).makev;\n\t});\n\tPR(\\basslink).chuck(BP(name), parms: (\n\t\tdriver: \\roots,\t// I'm listening to \\roots\n\t\tchildren: (\n\t\t\t\t// I could have any number of child processes\n\t\t\t\t// here there is just one, for the bass\n\t\t\t\t// quant: 0 means to trigger the base event immediately\n\t\t\t\t// when receiving the notification\n\t\t\t\t// func declares how to pass information from parent to child\n\t\t\tbass: (quant: 0, func: { |name, parentEvent|\n\t\t\t\t\t// func communicates parent event data into child\n\t\t\t\tBP(name).parentDelta = parentEvent[\\delta];\n\t\t\t\tBP(name).parentLength = parentEvent[\\delta];\n\t\t\t})\n\t\t)\n\t));\n}, type: \\bp) => Fact(\\basslink);\n\n// Pad process -- Func(\\makeCh) is a shortcut that sets the most important arpeggiator properties in one step. (I do this whole lot, so it makes sense to have a macro.)\n\n// This is not so directly tied to the root process, but it uses special techniques to make sure it starts on the next root note and remains in sync thereafter.\n(make: { |name|\n\tFunc('makeCh').doAction(name, \\arpeg1, \\macroRh, MBM(0)[\\padch], nil, MacRh(\\lagger), \\pad2, \\reshuf, nil, \\gdor);\n\n\t\t// Harmonies can, if desired, follow the contour of a top note melody\n\t\t// this can be an instance of PR(\\aiMel) for variations on given note data,\n\t\t// or, as here, a process that generates the pitches from a pattern\n\tBP(name).topNote = PR(\\patternTop).v.copy.make({\n\t\t~deg = Pvbrown(37, 52, Pwhite(1, 3, inf), inf);\n\t\t~mode = \\gdor;\n\t});\n\n\t\t// Func(\\chordFitInt) rearranges chord intervals against the top note\n\t\t// for best consonance over the current bass note\n\tBP(name).child.fitFunc = \\chordFitInt;\n\t\t// a function that calculates when to start based on the root's next event time\n\tBP(name).quant = Func(\\syncToRoot).v;\n\t\t// since the lead time is smaller than that of roots,\n\t\t// this will execute later than the root process and can use its information\n\t\t// since it's nonzero, other processes can also grab information from the pad\n\tBP(name).leadTime = 0.05;\n\tBP(name)\n}, type: \\bp) => Fact(\\pad);\n\n\n// More special techniques, not only to stay synchronized with the root, but also to play the same notes as the pad.\n(make: { |name|\n\tFunc('makeCh').doAction(name, \\arpeg1, \\macroRh, MBM(0)[\\padch], nil, MacRh(\\lagger), \\jumpy, \\xrand, nil, \\gdor);\n\tBP(name).quant = Func(\\syncToRoot).v;\n\t\t// Since the child process generates the notes,\n\t\t// we can attach arbitrary parameters for the Voicer\n\tBP(name).child.argPairs = [\\bufmod, Pwhite(0.0, 4.99, inf), \\ffreq, Pexprand(1200, 14000, inf), \\rq, Pexprand(0.05, 0.5, inf)];\n\n\t\t// look to the pad for the chord object to use\n\t\t// if that isn't populated or isn't being updated,\n\t\t// choose randomly from my own chord pool\n\tBP(name).child[\\makeChordPattern] = {\n\t\tPfunc({\n\t\t\tBP(\\pad).isPlaying.if({ BP(\\pad).child.currentChord }) ?? { ~chords.choose }\n\t\t})\n\t};\n\tBP(name).child.chordStream\u001e = nil;\t// ... and make sure it takes effect\n\tBP(name).child.reset;\n\n\t\t// to get the same notes, the top note has to match also\n\t\t// the top note pattern is kept as a fallback in case the pad isn't running\n\tBP(name).topNote = PR(\\patternTop).clone({\n\t\t~basePattern = ~asPattern;\n\t\t~deg = Pvbrown(37, 52, Pwhite(1, 3, inf), inf);\n\t\t~mode = \\gdor;\n\t\t~asPattern = {\n\t\t\tvar\tbase = ~basePattern.value.asStream;\n\t\t\tPfunc({ |inevent|\n\t\t\t\tBP(\\pad).isPlaying.if({ BP(\\pad).lastEvent.top },\n\t\t\t\t\t{ base.next(inevent) })\n\t\t\t});\n\t\t};\n\t});\n\tBP(name)\n}, type: \\bp) => Fact(\\jumpy);\n\n\n// A couple of generative drum machines to round out the ensemble.\n// All the setup takes place using the chuck operation's parameter list!\n(keys: #[master, root], make: { |name|\n\tPR(\\bufPerc).chuck(BP(name), parms: (\n\t\tmaster: ~master,\n\t\t\t// which sound file to play\n\t\t\t// one drum machine process can choose between several buffers\n\t\tbufPaths: [~root ++ \"samples/mellowbd.aif\"],\n\t\t\t// user specific initialization takes place when the MixerChannel is ready\n\t\tpostMCCreation: { |chan|\n\t\t\tStaticEQ(1, \\eq, 1879.042, 5.532.dbamp, 0.405, \\eq, 82.098, 4.681.dbamp, 1).play(chan);\n\t\t\tchan.level = -8.4.dbamp;\n\t\t},\n\t\tamps: 0,\n\t\t\t// used as the basic rhythm for the generator function\n\t\t\t// the loudest stroke will be on the first beat of the bar\n\t\tampBase: [1] ++ (0 ! 15),\n\t\t\t// This executes once per bar to generate a new rhythm.\n\t\tpbindPreAction: {\n\t\t\tvar\tpool = (1..15).scramble;\n\t\t\t~amps = ~ampBase.copy;\n\t\t\trrand(1, 5).do({ |i|\n\t\t\t\t~amps[pool[i]] = rrand(0.2, 0.7);\n\t\t\t});\n\t\t}\n\t));\n}, type: \\bp) => Fact(\\kik);\n\n(keys: #[master, root, rvbmc], make: { |name|\n\tPR(\\bufPerc).chuck(BP(name), parms: (\n\t\tmaster: ~master,\n\t\trvbmc: ~rvbmc,\n\t\tbufPaths: [~root ++ \"samples/springverb-rimshot.aif\"],\n\t\trates: [1.15],\n\t\tpostMCCreation: { |chan|\n\t\t\tStaticEQ(1, \\eq, 180.488, -14.61.dbamp, 0.052, \\eq, 287.845, -15.745.dbamp, 0.052,\n\t\t\t\t\\eq, 4180.489, 3.262.dbamp, 0.589).play(chan);\n\t\t\tchan.newPostSend(~rvbmc, 0.6);\n\t\t\tchan.level = -7.6.dbamp;\n\t\t},\n\t\tamps: 0,\n\t\tampBase:\n\t\t\t#[\t[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.4, 0, 0.8, 0, 0],\n\t\t\t\t[0, 0, 0, 0, 0, 0.4, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0],\n\t\t\t\t[0, 0, 0, 0, 0.7, 0, 1, 0, 0, 0.4, 0, 0, 0, 0, 0, 0]\n\t\t\t],\n\t\tpbindPreAction: {\n\t\t\tvar\tpool;\n\t\t\t~amps = ~ampBase.choose.copy;\n\t\t\t\t// locate rests in the base rhythm\n\t\t\tpool = ~amps.collectIndicesOfItem(0).scramble;\n\t\t\t\t// then put extra notes only in the rests\n\t\t\trrand(0, 3).do({ |i|\n\t\t\t\t~amps[pool[i]] = rrand(0.2, 0.7);\n\t\t\t});\n\t\t}\n\t));\n}, type: \\bp) => Fact(\\stick);\n\n\n//////// PROCESS PROTOTYPES\n\n// bass needs to follow root process exactly\n// this listens for the notification from \\roots and transmits info to the bass process\n// this implements the Observer design pattern\nProto({\n\t\t// set at chuck time\n\t~bassID = \\currentBassNote;\t// bass ID to listen for\n\t~children = ();\t// e.g., (childBPName: (quant: 0, func: {}), ...)\n\t~clock = TempoClock.default;\n\t\n\t~niltime = NilTimeSpec.new;\t// you should not change this\n\t\n\t~prep = {\n\t\t~clock = BP(~driver).tryPerform(\\clock) ?? { ~clock };  // clocks must match\n\t\t~registerNotify.value;\n\t};\n\t\n\t~registerNotify = {\n\t\t\t// bass note notifications go through BP class\n\t\t\t// adding currentEnvironment means ~update below will respond\n\t\tBP.addDependant(currentEnvironment);\n\t};\n\t\n\t~unregisterNotify = {\n\t\tBP.removeDependant(currentEnvironment);\n\t};\n\n\t\t// This is what makes this process into an Observer\n\t~update = { |obj, changeID, parentEvent|\n\t\t\t// notification might be from something else\n\t\t\t// reject if not the right bassID\n\t\t(changeID == ~bassID).if({\n\t\t\t~playChildren.(parentEvent);\n\t\t});\n\t};\n\n\t~playChildren = { |parentEvent|\n\t\t~children.keysValuesDo({ |bpname, spec|\n\t\t\t\t// for each child, find out when it should trigger\n\t\t\t\t// at that time, pass information across and run exactly one event\n\t\t\t~clock.schedAbs(spec[\\quant].asTimeSpec.nextTimeOnGrid(~clock), e {\n\t\t\t\tspec[\\func].value(bpname, parentEvent);\n\t\t\t\tBP(bpname).triggerOneEvent(~niltime);\n\t\t\t\tnil\n\t\t\t});\n\t\t});\n\t};\n\n\t\t// dependents should not be left around when not in use\n\t~freeCleanup = {\n\t\t~unregisterNotify.value;\n\t};\n}) => PR(\\basslink);\n\n\n//////// PROCESS COMPONENTS\n\n// The arpeggiator prototype (used above for bass, pad and jumpy) uses other objects, pulled by name from their respective repositories.\n\n// A \"microrhythm\" pattern supplies the note delta, length (for staccato or overlap) and gate (velocity) as a three element array.\nPwrand([1.0, 0.75, 0.5, Pn(0.25, 2), Pseq(#[0.25, 0.5, 0.25], 1)], #[2, 3, 2, 0.5, 0.4].normalizeSum, inf)\n.collect({ |delta|\n\t[delta,\n\tdelta * #[0.2, 0.5, 0.9, 1.001].wchoose(#[1, 2, 4, 6].normalizeSum),\n\trrand(0.2, 0.8)]\n}) => MicRh(\\bass1);\n\n{ |notes, event| [event.delta, event[\\length], 0.5] } => MicRh(\\pad);\n{ |notepat, event| Ptuple([Pwhite(0.2, 0.6, inf), Pwhite(1.0, 3.0, inf), 0.5], inf) } => MicRh(\\pad2);\n\n{ Pwrand([\n\tPn(0.125, 4),\n\tPseq(#[0.125, 0.25, 0.125], 1),\n\tPn(0.125, 2),\n\t0.25,\n\tPseq(#[0.375, 0.125], 1)\n], #[1, 2, 3, 4, 2].normalizeSum, inf).collect({ |delta|\n\t[delta, #[0.4, 0.9, 1.1].wchoose(#[1, 3, 5].normalizeSum) * delta, exprand(0.2, 0.8)]\n})\n} => MicRh(\\jumpy);\n\n\n// \"Macrorhythm\" supplies the time between chords in the arpeggiator.\n// [delta, length], where length is the amount of time to arpeggiate:\n// if length < delta, the arpeggiation will stop early and wait for the next parent event\nPfunc({ [~parentDelta, ~parentLength] }) => MacRh(\\depn);\n// This macrorhythm looks at the last bass note and returns the same amount of time\n// so that a harmony process will run in lockstep with the root changes\nPfunc({ (Library.at(\\currentBassNote).tryPerform(\\dur) ?? { rrand(8, 16) * 0.5 }).dup }) => MacRh(\\lagger);\n\n\n// This pattern determines the order in which chord notes will play out.\n{ |notes| Pn(Pshuf(notes, 1), inf) } => ArpegPat(\\reshuf);\n\n\n// Since I use this function in a couple of places, I save it in the function repository for convenience.\n// This calculates when process should start to sound in sync with the next root change.\n{ |bp|\n\tvar\trootbeat = BP(\\roots).nextBeat ?? { BP(\\roots)[\\eventSchedTime] };\n\t(rootbeat.notNil and: { rootbeat >= bp.clock.beats }).if({\n\t\tAbsoluteTimeSpec(rootbeat + BP(\\roots).leadTime - bp.leadTime)\n\t}, {\n\t\tNilTimeSpec.new\t// start now, but results might be unpredictable\n\t});\n} => Func(\\syncToRoot);\n\n\n//////// SOURCE MIDI DATA\n\n// What key?\nModalSpec(#[0, 2, 3, 5, 7, 9, 10], 12, 7) => Mode(\\gdor);\n\n// Global repository for MIDIRecBuf objects\nMBM(0) ?? { MIDIBufManager.new => MBM.prNew(0) };\n\n// given in MIDI note numbers\n// when used in a BP, the process converts them to their modal representation\nMIDIRecBuf(\\roots, [\n\t\t// midi note numbers\n\t#[31, 38, 34, 41, 36, 26, 29, 31, 24, 33, 36] + 12,\n\t\t// note deltas\n\t#[6, 4, 2, 5, 1, 6, 3, 2, 4, 5, 3],\n\t\t// note lengths\n\t#[6, 4, 2, 5, 1, 6, 3, 2, 4, 5, 3],\n\t\t// velocities/gates\n\t0.5\n\t\t// parameters:\n\t\t// mode: \\gdor --> Mode(\\gdor) for modal conversion\n\t\t// splitFunc: divides raw note stream into phrases using Func(...)\n].asNotes, (mode: \\gdor, splitFunc: \\defaultMelSplit)) => MBM(0);\n\nMIDIRecBuf(\\rootsadp, [\n\t#[36, 34, 33, 31, 33, 29, 31, 33, 38, 36] + 12,\n\t1, 1, 0.5\n\t\t// parameter type specifies how these data will be used\n\t\t// \\adapt means this is not meant to play directly,\n\t\t// but will crossbreed with the main material for new variations\n].asNotes, (mode: \\gdor, type: \\adapt)) => MBM(0);\n\nMIDIRecBuf(\\bassfigs, [\n\t#[31, 38, 41, 43,  31, 34, 36, 41,  31, 36, 38, 43], \n\t#[1, 1, 1, 2,  1, 1, 1, 2,  1, 1, 1, 2],\n\t1,\n\t1\n\t\t// type: \\ch means these are chord data\n].asNotes, (mode: \\gdor, type: \\ch)) => MBM(0);\n\nMIDIRecBuf(\\padch, [\n\t#[55, 60, 62, 65, 70,  55, 58, 64, 65, 72,  61, 65, 70, 72,  57, 67, 70, 72, 77],\n\t#[1, 1, 1, 1, 2,  1, 1, 1, 1, 2,  1, 1, 1, 2,  1, 1, 1, 1, 2],\n\t1, 1\n].asNotes, (mode: \\gdor, type: \\ch)) => MBM(0);\n\n~cleanup = { |self|\n\tself[\\rvbmc].free;\n};\n});\n\n} {\n\tAbstractChuckArray.defaultSubType = saveSubtype;\n};\n\n~noodle.know = true;\t// to facilitate cleanup, see script file\n",
    "noodle-script.scd": "//////// Algorithmic Noodling - H. James Harkins\n//////// Performance script\n\n//////// INITIALIZATION\n\n// where am I on the hard disk?\n// Windows users: See noodle-readme.html\n~root = PathName(thisProcess.nowExecutingPath).pathOnly;\n\n// open gui if desired\n// this has some MIDI dependencies so if MIDI doesn't work in your system, omit this\n(~root ++ \"support/noodle-gui.scd\").loadPath;\n\n// loading the gui takes a few seconds\n// after gui is finished loading, run this to move this window to a better location\nBP.openCodeDoc(~root ++ \"noodle-script.scd\");\n\n// if you are NOT using the gui, make sure to start the server\ns.boot;\n\n// run initialization\n(~root ++ \"noodle-init.scd\").loadPath;\n\n~noodle.push;\n\n~hasGui = VP.exists(0);\n\n// only if you have the GUI - you can put the things in the mixingboard\n~hasGui.if({ ~master => MCG(7) });\n\n// load drums\n(\nFact(\\kik) => BP(\\kik);\nFact(\\stick) => BP(\\stick);\n\n~hasGui.if({\n\tBP(\\kik) => MT(1);\n\tBP(\\stick) => MT(1);\n\tBP(\\kik) => MCG(3);\n\tBP(\\stick) => MCG(4);\n});\n)\n\n// play both at once\nBP(#[stick, kik]).play;\n\n\n// load bass voicer and process\n(\nFact(\\bass_v) => VC(\\bass);\nFact(\\roots) => BP(\\roots);\nFact(\\basslink) => BP(\\basslink);\nFact(\\bass) => BP(\\bass);\nBP(\\bass) => VC(\\bass);\n\n~hasGui.if({\n\tVC(\\bass) => VP(0);\n\tBP(\\roots) => MT(1);\n\tVC(\\bass) => MCG(0);\n});\n)\n\nBP(\\roots).play;\n\n\n// load pad\n(\nFact(\\pad_v) => VC(\\pad);\nFact(\\pad) => BP(\\pad);\nBP(\\pad) => VC(\\pad);\n\n~hasGui.if({\n\tVC(\\pad) => VP(1);\n\tBP(\\pad) => MT(1);\n\tVC(\\pad) => MCG(1);\n});\n)\n\nBP(\\pad).play;\n\n// load jumpy\n(\nFact(\\jumpy_v) => VC(\\jumpy);\nFact(\\jumpy) => BP(\\jumpy);\nBP(\\jumpy) => VC(\\jumpy);\n\n~hasGui.if({\n\tVC(\\jumpy) => VP(2);\n\tBP(\\jumpy) => MT(1);\n\tVC(\\jumpy) => MCG(2);\n});\n)\n\n// play with fadein\nVC(\\jumpy).env.target.level = 0;\nBP(\\jumpy).play;\n\nVC(\\jumpy).env.target.levelTo(-14.dbamp, 20);\n\n\n/***\nHere, you can play with starting and stopping processes.\nWith the GUI, you have more options for realtime tweaking.\n\t- You can change the mix.\n\t- A couple of synth parameters are exposed in the Voicer GUIs at right.\nOr just sit back and listen.\n***/\n\n\n// fade out jumpy\nVC(\\jumpy).env.target.levelTo(0, 20);\n\n// when done, stop it\nBP(\\jumpy).stop;\n\n// fade out bass, but keep it playing to drive the chord changes\nVC(\\bass).env.target.levelTo(0, 20);\n\n// (to save cpu, after bass is silent, you can suppress its synths by setting the process voicer to nil)\nBP(\\bass).event.voicer = nil;\n\n\n// fade it all out with master\n~master.levelTo(0, 40);\n\nBP.all.stop;\n\n\n// wipe everything for this track only out of the workspace\n// if you're using the GUI, lots of things will disappear!\nAbstractChuckArray.freeTypeAll(\\noodle);\n\n// reverb still exists because it didn't belong to a chucklib object\nEvent.pop;\n~noodle.cleanup;\n\n// only ~master MixerChannel is left\n~master.free;\n",
    "noodle-gui.scd": "\n// set up guis etc. for composition development\n\nvar\tmasterLayout, chuckKeyCtl, composeDocKeyResp,\n\toriginalDocInit;\t\t// must maintain independent of environment\n\nvar\tpath;\n\n~toolbarFlow.isNil.if({\n\nLibrary.at(\\mixer, \\smallskin).isNil.if({\n\tLibrary.put(\\mixer, \\smallskin, MixerSkin.new.maxAcross_(1));\n});\n\nAbstractChuckArray.loadWindowBounds;\n\nMIDIPort.init;\nMIDIPort.resetAll;\nMIDIPort.autoFreeSockets = false;\t// protect midi controllers from being destroyed accidentally\n\ns.boot;\n\n~statusW = GUI.window.new(\"Building GUI, please wait...\",\n\tRect(GUI.window.screenBounds.width - 250 div: 2,\n\tGUI.window.screenBounds.height - 40 div: 2,\n\t250, 40));\n~statusSl = GUI.rangeSlider.new(~statusW, Rect(10, 15, 230, 10))\n\t.lo_(0).hi_(0);\n~numUpdates = (~voicerRows * ~voicerColumns) + 6;\n~currentUpdate = 0;\n~advanceStatus = {\n\t~currentUpdate = ~currentUpdate + 1;\n\t~statusSl.hi_(~currentUpdate / ~numUpdates);\n};\n~statusW.front;\n\n~masterLayout = ResizeFlowWindow(\"control panel\");\nmasterLayout = ~masterLayout;\n\n~toolbarFlow = FlowView(~masterLayout.view, Rect(0, 0, 290, GUI.window.screenBounds.height-5));\n(~useScroll ? false).if({\n\t~voicerScroll = GUI.scrollView.new(~masterLayout.view, Rect(0, 0, 450 * ~voicerColumns,\n\t\tGUI.window.screenBounds.height-50)).hasHorizontalScroller_(false);\n}, {\n\t~voicerScroll = ~masterLayout.view;\n});\n~voicerFlow = FlowView(~voicerScroll, Rect(0, 0, 450 * ~voicerColumns, 20000));\n\nGUI.staticText.new(~toolbarFlow, Rect(0, 0, 280, 20)).string_(\"Toolbar\").align_(\\center);\n\n// voicerproxies -- creating this gui is time sensitive\n// thus the remainder of the gui building is wrapped in a routine that is run on AppClock\nRoutine({\n\tvar\tcount = 0;\n\t(~voicerRows * ~voicerColumns).do({ |i|\n\t\tVoicerProxy.new => VP.prNew(i);\n\t\t\t// first proxy has 4 controls, the rest have 3\n\t\t(3 + (count < ~voicersWith4Controls).binaryValue).do({\n\t\t\tVP(i).v.addControlProxy(nil, true)\n\t\t});\n\t\tcount = count + 1;\n\t\tVP(i).v.maxControlProxies = VP(i).v.controlProxies.size;\n\t\tVP(i).v.smallGui(~voicerFlow, nil, nil, nil, nil, false);\n\t\t0.2.wait;\n\t\t~advanceStatus.();\n\t\t(i+1 % ~voicerColumns == 0).if({ ~voicerFlow.startRow; });\n\t});\n\n~voicerFlow.recursiveResize;\n\n\n// MIDI bufs\n\nMIDIBufManager(nil, 0) => MBM.prNew(0);\nMBM(0).v.gui(~toolbarFlow, Rect(0, 0, 290, 300));\n\n// midi trigger\n~toolbarFlow.startRow;\nMT(1).gui(~toolbarFlow);\n\n0.2.wait;\n~advanceStatus.();\n\n// make draggable modwheel and pitchbend controls\n~midiControlFlow = FlowView.new(~toolbarFlow, Rect(0, 0, 80, 250));\nVoicerMIDIController.defaultDest = VoicerGCDummy;\n#[mw, pb].do({ |type|\n\tvar mc;\n\tmc = VoicerMIDIController(\\omni, type);\n\tGUI.dragSource.new(~midiControlFlow, Rect(0, 0, 30, 20))\n\t\t.align_(\\center)\n\t\t.object_(mc).string_(mc.ccnum.shortName)\n\t\t.beginDragAction_({ |drag| drag.object });\n//\t\t.action_({ |drag|\n//\t\t\ttry { drag.string_(mc.ccnum.shortName) }\n//\t\t});\n\tmc => CC.prNew(mc.ccnum.shortName.asSymbol);\n});\n\n~midiControlFlow.startRow;\n\nGUI.dragSink.new(~midiControlFlow, 80@20).string_(\"reset\").align_(\\center)\n\t.background_(Color.new255(190, 198, 225)).stringColor_(Color.new255(191, 0, 0))\n\t.action_({ |drag|\n\t\ttry { drag.object.reset };\n\t\tdrag.string = \"reset\";\n\t});\n\nGUI.dragSink.new(~midiControlFlow, 80@20).string_(\"free\").align_(\\center)\n\t.background_(Color.new255(190, 198, 225)).stringColor_(Color.new255(191, 0, 0))\n\t.action_({ |drag|\n\t\tvar\tvc, vp;\n\t\t(drag.object.class == VoicerProxy).if({\n\t\t\tvp = drag.object;\n\t\t\tvc = VC.collection.detect({ |vc| vc.v === vp.voicer });\n\t\t\ttry { vc.free }\n\t\t}, {\n\t\t\ttry { drag.object.free };\n\t\t});\n\t\tdrag.string = \"free\";\n\t});\n\nGUI.button.new(~midiControlFlow, 80@20)\n\t.states_([\n\t\t[\"use VProxy\", Color.new255(191, 0, 0), Color.new255(190, 198, 225)],\n\t\t[\"use Voicer\", Color.new255(191, 0, 0), Color.new255(190, 198, 225)],\n\t])\n\t.value_(1)\n\t.action_({ |view|\n\t\tBP.useVoicerProxy = (view.value == 0);\n\t});\nBP.useVoicerProxy = false;\n\n0.2.wait;\n~advanceStatus.();\n\n~toolbarFlow.startRow;\ns.gui(~toolbarFlow);\n\n~toolbarFlow.startRow;\n\n~chuckBrowser = ChuckableBrowser(~toolbarFlow);\n~chuckKeyCtl = ChuckBrowserKeyController(~chuckBrowser);\nchuckKeyCtl = ~chuckKeyCtl;\n\n\t// ctrl-` from gui switches focus to current document\n\t// any other key, if not caught by a view, switches focus back to the chuck key controller\n\t// and passes key thru\nif(thisProcess.platform.name == \\osx) {\n\t~masterLayout.view.keyDownAction_({ |view, char, mods, unicode, keycode|\n\t//view.dumpBackTrace;\n\t//[char, mods, unicode, keycode].debug(\"bubbled up to masterlayout\");\n\t\t(unicode == 30 and: { (mods bitAnd: 0x40000) > 0 }).if({\n\t\t\tDocument.current.front;\n\t\t}, {\n\t\t\tchuckKeyCtl.focus.doKey(view, char, mods, unicode, keycode);\n\t\t});\n\t});\n};\n\n0.2.wait;\n~advanceStatus.();\n\n// fix views with nil keyDownActions so that bubbling will be right\n// defaultKeyDownAction returns nil if it should bubble, so func should just pass the return thru\nf = { |view|\n\t\t// MIDIBufManager gui uses a toggletextfield - this change to key down action breaks it\n\t(view.class.name != 'ToggleTextField').if({\n\t\t(view.respondsTo(\\keyDownAction) and: { view.keyDownAction.isNil }).if({\n\t\t\tview.keyDownAction = { |view, char, modifiers, unicode, keycode|\n\t\t\t\tview.defaultKeyDownAction(char, modifiers, unicode, keycode)\n\t\t\t};\n\t\t});\n\t\t\t// nil-do is its own nil check\n\t\tview.tryPerform(\\children).do(f.value(_));\n\t});\n};\n\nf.value(~masterLayout.view);\nf = nil;\n\n~toolbarFlow.recursiveResize;\n\n0.2.wait;\n~advanceStatus.();\n\n//~masterLayout.recursiveResize.front;\n\n// mixer gui slots\n~board = MixingBoard(\"mixer control pool\", Library.at(\\mixer, \\smallskin));\n8.do({ |i| MixerChannelGUI(nil, ~board) => MCG.prNew(i);\n\t~board.add(MCG(i).v);\n});\n1.0.wait;\n~advanceStatus.();\n~board.refresh;\n1.0.wait;\n~advanceStatus.();\n\n~masterLayout.window.bounds = ~controlpanelBounds;\n\t// test scrollability\n~voicerScroll.respondsTo(\\visibleOrigin).if({\n\t~voicerScroll.bounds = ~voicerScroll.bounds.width_(305)\n});\n~board.w.bounds = ~mixerBounds;\nif(thisProcess.platform.name == \\osx) {\n\t~codedoc = Document.new(\"type code\");\n\t~codedoc.bounds_(~codedocBounds);\n\tDocument.listener.bounds = ~postwindowBounds;\n};\n\nLibrary.put(\\codeBounds, ~codedocBounds);\n\n~statusW.close;\n~statusW = ~statusSl = ~numUpdates = ~currentUpdate = ~advanceStatus = nil;\n~masterLayout.front.refresh;\n\n}).play(AppClock);\n\n}, {\n\t\"gui already loaded\".warn;\n});\n",
    "c23code_examples_dialects.scd": "\n// Chapter 23. Dialects, Constraints, and Systems within Systems\n\n// 1 Dialects\n\n// not a Figure\n// a quine in SC3\n(_ + '.(*' +  quote(_)  + '! 2)').(*\"(_ + '.(*' +  quote(_)  + '! 2)')\" ! 2)\n\n\n// not a Figure\n// ensure VagueList.sc in in the enxtensions folder \n// VagueList has a vague 'at' method \na\u00ca=\u00caVagueList[0,\u00ca1,\u00ca2,\u00ca3];  \na.at(2); \t// may return 1, 2, or 3 \na.at(2); \na.at(2); \n\n\n// not a Figure\n// Eniac Cycling Unit with adjustable clock speed\n(\n{\tvar clockspeed = MouseX.kr(1, 300, 1);\n\tvar clocksignal = LFSaw.ar(clockspeed).range(0, 80);\n \tvar timingPulses = CU_PulseLookUpTables.ar(clocksignal); // 10 channels.\n \ttimingPulses * 0.2\n}.scope;\n)\n\n// Figure 23.1 The ENIAC Cycling Unit (graphic image).\n\n\n// not a Figure\n// two ways of coupling parameters\n\n{ var freq = MouseX.kr(20, 2000, 1); Pulse.ar(freq, freq.explin(20, 2000, 0.95, 0.05)) }.play;\n\n\n// more intricate dependency\n{ var freq = MouseX.kr(20, 2000, 1);  Pulse.ar(freq,  freq.explin(20, 2000, 0, 5pi).sin * 0.45 + 0.5) }.play;\n\n\n// Figure 23.2: Two ways of constraining parameters\n(\n{\tvar f = { | a, b | [a.min(1 - b), b.min(1 - a)] };\n\tvar freq = f.value(MouseX.kr, MouseY.kr) * 400 + 500;\n\tSinOsc.ar(freq) * 0.1\n}.play;\n)\n\n\n(\na = { |freq=100, width=0.5|\n\tvar df, dw;\n\tdf = freq - LastValue.kr(freq);\n\tdw = width - LastValue.kr(width);\n\tfreq = freq + (dw * 100);\n\twidth = width + (df / 100);\n\tPulse.ar(freq, width.clip(0.01, 0.99).poll) * 0.1\n}.play;\n)\n\na.set(\\freq, exprand(200.0, 600.0));\na.set(\\width, 1.0.rand);\n\n\n//  Figure 23.3 \u00d0 Pokey registers (graphic image)\n\n\n\n// Figure 23.4:  Modulating Pokey inputs\n// modulating the frequency input to a Pokey UGen results in great variance\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate + mod, audc1: 2r01000000 + amp);\n}.play\n);\n\n// modulating the pure tone bit\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate, audc1: 2r00100000 + (mod * 2r00100000) + amp);\n}.play\n);\n\n\n\n\n// Figure 23.5: Setting up rd_clt and mapping Ctls to a Synth's controls. \n// You may need to install the rd_clt Quark. See the Quarks help file.\n(\n\tSynthDef(\"FreqMod\", { |car=440, carFine=1, mod=100, modFine=1, index=4, amp=0.3, pan=0| \n\t\tOut.ar(0, Pan2.ar(PMOsc.ar(car * carFine, mod * modFine, index), pan, amp)); \n\t}).add; \t\t\n\t\n\tc = Controller.new(s, 256);\n\tc.makeInterface(2, 3, 0, \"Freq Mod controller\");\n\t\n\tc[0].setup(\"carFreq\", [50, 4800, \\exp].asSpec, 440);\n\tc[1].setup(\"carFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\n\tc[2].setup(\"modFreq\", [10, 4800, \\exp].asSpec, 10);\n\tc[3].setup(\"modFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\n\tc[4].setup(\"mIndex\", [0, 24, \\lin].asSpec, 1);\n\tc[5].setup(\"amp\", [0, 1, \\lin].asSpec, 0.2);\n);\n\n\na = Synth(\"FreqMod\") // start the synth\n6.do({|i| a.map(i, c[i].index)}); // map the synth control to the controller.\n\na.free\n\n\n//  3 Scheduling constraints: HierSch\n\n\n// Figure 23.6 HierSch scheduling constraints and priority levels (graphic image)\n\n\n// Figure 23.7: Priority-based HierSch scheduling.\n// You may need to install the HierSch Quark. See the Quarks help file. \n\n(\nSynthDef(\\ping, {\n\targ out = 0, mfreq = 69, pan = 0, gain = 0.2, dur = 0.25;\n\tOut.ar(out, Pan2.ar(\n\tSinOsc.ar(mfreq.midicps, 0, \n\tEnvGen.kr(envelope: (Env.perc(0.01, dur)), doneAction: 2)),\n\tpan, gain));\n}).add;\n\n// function to play a synth\nm = {|f, d=0.3, g=0.2, p=0| Synth(\\ping, [\\mfreq, f + 45, \\pan, p, \\gain, g, \\dur, d])};\n\n// function to make a chord\nc = {|a, b, c| [a, b, c].do{|i| m.value(i, 1.2, 0.075, rrand(-1.0, 1.0))}};\n\nt = TempoClock.default.tempo_(116 / 60); // assign clock to t\nb = HierSch.new(t); // start new HierSch, pass in clock\n)\n\n(\n// HierSch schedules\nb.schedAbs(t.beats.ceil + 48, 1, { var offset = [0, 5, 7, 12]; c.value(*[12, 16, 19]+ offset.choose)}, Prand(#[1.5, 3], 30)); // enters last, priority highest\n\nb.schedAbs(t.beats.ceil + 14, 2, {|b, p, d, c| m.value([0, 0, 7, 5, 4].at(c % 5) + [12, 24].choose, 0.4, 0.15, rrand(-1.0, 1.0))}, Pseq(#[2, 2, 2, 1], 15)); // enters middle, priority middle\n\nb.schedAbs(t.beats.ceil, 3, { |b, p, d, c| m.value(VagueList[0, 12, 4, 7, 10, 10, 9, 9, 7].at(c % 9))}, Pseq(#[0.5, 0.5, 0.5, 0.5, 0.25, 0.75, 1, 0.5, 0.5], 17)); // enters first, priority lowest\n)\n\n\n// \t4 Object Systems: Redirections and Constraints\n\n\n// \t4.1 Redirecting Assignment: Maybe and LazyEnvir\n\n// not a Figure\n\nx = 1;\t// assigment\n\n~x = 1;\t// environment put\n\\x.envirPut(1);\ncurrentEnvironment.put(\\x, 1); \n\n\n\n\n// Figure 23.8: Maybe yes.\n\np = LazyEnvir.push;\n~a = ~b * ~c;\n~a.value; \t// => nil\n~b = Pseq([1, 2, 3]).asStream;\n~c = 10;\n~a.value; \t// => 10\n~a.value; \t// => 20\n~b = [1, 2, 3];\n~a.value; \t// => [10, 20, 30];\n~a.postcs;\t// => Maybe((Maybe([ 1, 2, 3 ]) * Maybe(10)))\np.pop\n\n\n//\t4.2 Declaring Constraints: List Comprehensions\n\n// not a Figure\n_ + 1 ! 7  // => [ 1, 2, 3, 4, 5, 6, 7 ]\n\nArray.fill(7, { |i| i + 1 })  // => [ 1, 2, 3, 4, 5, 6, 7 ]\n\n\n// not a Figure\n// list comprehensions example \n\t\nf\u00ca=\u00ca{:[x, y], x <- (2..10), y <- (x..10), gcd(x, y) == 1  }; \n\nf.next; // [2, 3] \nf.next; \n\nf.all;\n\nf\u00ca=\u00ca{:[x, y], x<-(2..10), y<-(x + 1..10), gcd(x, y) == 1; x.isPrime.not and: y.isPrime.not  }; \nf.next; // [2, 3] \nf.next;  \n\n\n// Figure 23.9: Coprimes as frequency and trigger rates\n(\nvar x;\nx = { |rates=#[1, 1]| Ringz.ar(Impulse.ar(rates) * 0.1, rates * 80, 1 / rates) }.play;\nfork {\n\tvar str = {:[x, y], \n\t\tx<-(40..2), \n\t\ty<-(x + 1..40),\n\t\tgcd(x, y) == 1,\n\t\tx.isPrime.not and: y.isPrime.not\n\t};\n\t0.5.wait;\n\tstr.do { |primes|\n\t\tx.setn(\\rates, primes.postln);\n\t\t(primes.product / primes.sum / 20).wait;\n\t}\n};\n)\n\n// 5 Text Systems\n\n\n// not a Figure\na = Pseq(\"aggaca\").collect(_.ascii)\na.asStream.all // => [ 97, 103, 103, 97, 99 ]\n\n\n// Figure 23.10: A very simple notation translater\n\n(\nvar dict, maxLength = 0;\ndict = (\n\tab: { (note: [4, 0, 7], legato: 0.1, dur: 1) },\n\tba: { (note: [4, 9, 8], legato: 0.3, dur: 0.3) },\n\taaa: { (note: 5, legato:1.5) },\n\tbbb: { (note: 0, legato:2.5, dur: 0.25) }\n);\n\ndict.keys.do { |key| maxLength = max(maxLength, key.asString.size) };\n\nf = { |str|\n\tvar i = 0, n = 0, substr, event;\n\twhile { i < str.size } {\n\t\tsubstr = str[i..i + n];\n\t\tevent = dict[substr.asSymbol].value;\n\t\tif(event.notNil) {\n\t\t\tsubstr.postln;\n\t\t\ti = i + n + 1;\n\t\t\tn = 0;\n\t\t\tevent.postln.play;\n\t\t\tevent.delta.wait;\n\t\t} {\n\t\t\tif(n + 1 < maxLength) { n = n + 1 } { n = n - 1; i = i + 1 }\n\t\t};\n\t};\n};\n)\n\n// play some sequences\nfork { f.value(\"abbbbaab\"); }\nfork { f.value(\"aaabbbabbaaaabbabaaaaba\"); };\n\n\n\n// not a Figure\n\t\nx = \"1 + 2\";\nx.interpret\u00ca/\u00ca3;\u00ca//\u00ca1\nx\u00ca=\u00cax.replace(\"+\", \"-\"); \nx.interpret\u00ca/\u00ca3;\u00ca//\u00ca-0.33333\n\n\nthis.preProcessor = { |str| str.replace(\"+\", \"-\") } \n1 + 2 // -1\nthis.preProcessor = nil \n1 + 2 // 3\n\n",
    "BrainfuckCompiler.scd": "// brainfuck, urban mueller 1993\n// for its universality, see also http://www.hevanet.com/cristofd/brainfuck/utm.b\n/*\n>\tMove the pointer to the right\n<\tMove the pointer to the left\n+\tIncrement the memory cell under the pointer\n-\tDecrement the memory cell under the pointer\n.\tOutput the character signified by the cell at the pointer\n,\tInput a character and store it in the cell at the pointer\n[\tJump past the matching ] if the cell under the pointer is 0\n]\tJump back to the matching [\n*/\n\n(\nvar findBrack = { |str, offset|\n\t\tvar count = 0, i = offset;\n\t\twhile {\n\t\t\tif(str[i] == $[ /*]*/) { count = count + 1 };\n\t\t\tif(str[i] == /*[*/$]) { count = count - 1 };\n\t\t\ti < str.size and: { count > 0 }\n\t\t} {\n\t\t\ti = i + 1;\n\t\t};\n\t\tif(i == str.size and: { count > 0 }) { nil } { i }\t\n};\n\ne = (\n\t'>': { ~ptr = ~ptr + 1 },\n\t'<': { ~ptr = ~ptr - 1 },\n\t'+': { ~mem[~ptr] = ~mem[~ptr] + 1;  },\n\t'-': { ~mem[~ptr] = ~mem[~ptr] - 1; },\n\t'.': { ~mem[~ptr].asAscii.post; },\n\t',': { |char| ~mem[~ptr] = char.ascii },\n\t'['/*]*/ : {   \n\t\t\t\n\t\t\tif(~mem[~ptr] <= 0) {\n\t\t\t\t~codePtr = findBrack.(~code, ~codePtr);\n\t\t\t\tif(~codePtr.isNil) { Error(\"syntax error!\").throw };\n\t\t\t\t\n\t\t\t};\n\t\t\t~stack = ~stack.add(~codePtr);\n\t\t},\n\t/*[*/']': {\n\t\t~codePtr = ~stack.pop;\n\t\tif(~codePtr.isNil) { Error(\"syntax error closing br!\").throw } { ~codePtr = ~codePtr - 1 };\n\t}\n);\n\nx = (\n\treg: e,\n\tmemsize: 1024,\n\tcodePtr: 0,\n\t\n\tinterpret: { |x, code, verbose = false, dt = 0.01|\n\t\tx.use {\n\t\t\tif(dt.notNil) {\n\t\t\t\tfork { x.pr_interpret(code, verbose, dt) }\n\t\t\t} {\n\t\t\t\tx.pr_interpret(code, verbose);\n\t\t\t}\n\t\t};\"\";\n\t},\n\tpr_interpret: { |x, code, verbose = false, dt|\n\t\t\tvar func, sym, count = 0, max = 1e5, overrun;\n\t\t\t\n\t\t\t~code = code;\n\t\t\t~codePtr = 0;\n\t\t\t~ptr = 0;\n\t\t\t~mem = 0.dup(~memsize);\n\t\t\t~stack = nil;\n\t\t\t\n\t\t\twhile {\n\t\t\t\tsym = ~code[~codePtr].asSymbol;\n\t\t\t\tfunc = ~reg[sym];\n\t\t\t\t\n\t\t\t\tif(verbose) { \n\t\t\t\t\tpostf(\"\\nptr: % char: % stack: %\\nmem: % \\n\", \n\t\t\t\t\t\t~codePtr, sym, ~stack, ~mem.join($ )) \n\t\t\t\t};\n\t\t\t\tcount = count + 1;\n\t\t\t\toverrun = dt.isNil and: { count >= max };\n\t\t\t\tif(overrun) { \"time overrun (t > %).\\n\".format(max).warn };\n\t\t\t\tfunc.notNil and: { ~codePtr < ~code.size } and: { overrun.not }\n\t\t\t} {\n\t\t\t\tfunc.value;\n\t\t\t\tif(~ptr >= ~memsize) { \"memory overrun (i > %).\\n\".format(~memsize).throw };\n\t\t\t\t~codePtr = ~codePtr + 1;\n\t\t\t\tif(dt.notNil) { dt.yield };\n\t\t\t};\n\t\t\t\n\t}\n\n);\n\n);\n\n\nx.interpret(\"++++----\", true, 0.4); \nx.interpret(\"----++++\", true, 0.4);\nx.interpret(join($+ ! 100) ++ \".+.+.+.\", false, 0.4);\n\nx.interpret(\"++>+++><---<--\", true);\nx.interpret(\"+>+>>+>+>>+\", true);\n\nx.interpret(\"[+]>+\", true); // jump first to +>\n\nx.interpret(\"+[-]\", true); // go in first first, then jump out\nx.interpret(\"+[-]\", true); // go in first first, then jump out\n\n\nx.interpret(\"+[+-]+++\", true);\n\nx.interpret(\"++[++-.]+\");\n\n// hello world\n(\nx.interpret(\">+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.>>>++++++++[<++++>-]\n<.>>>++++++++++[<+++++++++>-]<---.<<<<.+++.------.--------.>>+.\"); \"\";\n)\n\n\n\n\n// quines????\n// takes long..\n(\nx.interpret(\"->++>+++>+>+>++>>+>+>+++>>+>+>++>+++>+++>+>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>+>+>++>>>+++>>>>>+++>+>>>>>>>>>>>>>>>>>>>>>>+++>>>>>>>++>+++>+++>+>>+++>>>+++>+>+++>+>++>+++>>>+>+>+>+>++>+++>+>+>>+++>>>>>>>+>+>>>+>+>++>+++>+++>+>>+++>+++>+>+++>+>++>+++>++>>+>+>++>+++>+>+>>+++>>>+++>+>>>++>+++>+++>+>>+++>>>+++>+>+++>+>>+++>>+++>>+[[>>+[>]+>+[<]<-]>>[>]<+<+++[<]<<+]>>+[>]+++[++++++++++>++[-<++++++++++++++++>]<.<-<]\", false, 0.001); \n)\n\n(\nx.interpret(\">+++++>+++>+++>+++++>+++>+++>+++++>++++++>+>++>+++>++++>++++>+++>+++>+++++>+>+>++++>+++++++>+>+++++>+>+>+++++>++++++>+++>+++>++>+>+>++++>++++++>++++>++++>+++>+++++>+++>+++>++++>++>+>+>+>+>++>++>++>+>+>++>+>+>++++++>++++++>+>+>++++++>++++++>+>+>+>+++++>++++++>+>+++++>+++>+++>++++>++>+>+>++>+>+>++>++>+>+>++>++>+>+>+>+>++>+>+>+>++++>++>++>+>+++++>++++++>+++>+++>+++>+++>+++>+++>++>+>+>+>+>++>+>+>++++>+++>+++>+++>+++++>+>+++++>++++++>+>+>+>++>+++>+++>+++++++>+++>++++>+>++>+>+++++++>++++++>+>+++++>++++++>+++>+++>++>++>++>++>++>++>+>++>++>++>++>++>++>++>++>++>+>++++>++>++>++>++>++>++>++>+++++>++++++>++++>+++>+++++>++++++>++++>+++>+++>++++>+>+>+>+>+++++>+++>+++++>++++++>+++>+++>+++>++>+>+>+>++++>++++[[>>>+<<<-]<]>>>>[<<[-]<[-]+++++++[>+++++++++>++++++<<-]>-.>+>[<.<<+>>>-]>]<<<[>>+>>>>+<<<<<<-]>++[>>>+>>>>++>>++>>+>>+[<<]>-]>>>-->>-->>+>>+++>>>>+[<<]<[[-[>>+<<-]>>]>.[>>]<<[[<+>-]<<]<<]\");\n);\n",
    "CadavreExquisNo2.scd": "// cadavre exquis no. 2, from sc-users list, October 2005.\n// Archives at http://lists.create.ucsb.edu/mailman/listinfo/sc-users\n\n\n// On 22 Oct 2005, at 22:50, Julian Rohrhuber wrote:\n\n// cadavre exquis no. 2\n\n(\nz = { var x = 1.0.rand; { |i, j| (x * i) + (x * j) % 5 } };\n\ny = { |q=0.1|\n\tFormlet.ar(\n\t\tDust.ar(LFPulse.kr(20 * q, [0.2, 0.2]) * 1000 + 10), \n\t\tq * 400 + 800, \n\t\t0.08, \n\t\t0.1\n\t)\n};\n\nfork {\n\tvar d = y.play;\n\tvar q;\n\t1.wait;\n\t3.do {\n\t\t3.do {|i|\n\t\t\tq = z.value;\n\t\t\t3.do {|j|\n\t\t\t\td.set(\\q, q.(i, j));\n\t\t\t\t2.wait\n\t\t\t}\n\t\t}\n\t};\n\td.free;\n}\n)\n\n\n//////////////\n\n// On 22 Oct 2005, Tom Hall wrote:\n\n// \"curried\" cadavre exquis no. 2\n// y has got places to go?\n\n(\nz = { var x = 1.0.rand; { |i, j| (x * i) + (x * j) % 5 } };\n\ny = { |q=0.1|\n\tvar  distance, pitchRatio, amp;    // see hypot help\n\tdistance = hypot(9, LFSaw.kr(1/6, 0, 100));\n\tpitchRatio = (344 - Slope.kr(distance)) / 344;\n\tamp = 300 / distance.squared;\n\tFormlet.ar(Dust.ar(LFPulse.kr(20 * q, [0.2, 0.2]) * 1000 + 10),\n\t\t\t(q * pitchRatio * 1000) + 750, 0.08, 0.1, amp)\n};\n\nfork {\n\tvar d = y.play;\n\tvar q;\n\t1.wait;\n\t3.do {\n\t\t3.do {|i|\n\t\t\tq = z.value;\n\t\t\t3.do {|j|\n\t\t\t\td.set(\\q, q.(i, j));\n\t\t\t\t2.wait\n\t\t\t}\n\t\t}\n\t};\n\td.free;\n}\n)\n\n\n////////////\n\n// On 25 Oct 2005, kernal wrote:\n\n// cadavre exquis no. 2\n// reminds me of YOU ;-)\n\n(\nz = { var x = 1.0.rand; { |i, j| (x * i) + (x * j) % 9 } };\n\ny = { |q=0.1|\n\t\n\tLimiter.ar(\n\t\tFormlet.ar(\n\t\t\tCombC.ar(SinOsc.ar(232+(q*183) + {LFNoise2.ar(q*2332+0.45,9)}.dup,0,1),\n\t\t\t\t1,q,q*202), q * 808 + 50, 0.02, 0.1,0.5),\n\t\t0.9,0.01\n\t)\n};\n\nfork {\n\tvar d = y.play;\n\tvar q;\n\t1.wait;\n\t3.do {\n\t\t3.do {|i|\n\t\t\tq = z.value;\n\t\t\t3.do {|j|\n\t\t\t\td.set(\\q, q.(i, j));\n\t\t\t\t2.wait\n\t\t\t}\n\t\t}\n\t};\n\td.free;\n}\n)\n\n\n/////////////\n\n// On 28 Oct 2005, Tim Walters wrote:\n\n// cadavre exquis no. 2\n// another round\n\n(\nz = { var x = 1.0.rand; { |i, j| (x * i) + (x * j) % 9 } };\n\ny = { |q=0.1|\n\n    var a;\n    a = SinOsc.ar(232+(q*183)+{LFNoise2.ar(q*q+0.45,9)}.dup,0,1);\n    LPF.ar(\n        CombC.ar(a,1,Lag.kr(q, q.squared),q*808) * 0.25\n    , Lag.kr(q, q.squared) * 808 + 50, (q + 1).reciprocal.squared, 0.1, a)\n};\n\nfork {\n    var d = y.play;\n    var q;\n    (1.0.rand + 0.1).wait;\n    3.do {\n        3.do {|i|\n            q = z.value;\n            3.do {|j|\n                d.set(\\q, q.(i, j));\n                (2.0.rand + 0.2).wait\n            }\n        }\n    };\n    d.free;\n}\n)\n\n\n/////////////\n\n// On 28 Oct 2005, Julian Rohrhuber wrote:\n\n// cadavre exquis no. 2\n// some more curry\n\n(\nz = { var x = 1.0.rand;\n\t{ |i|\n\t\t{ |j| (x * i) + (x * j) % 5 }\n\t}\n};\n\ny = { |q=0.1|\n\n    var a, f;\n    var  distance, pitchRatio, amp;    // see hypot help\n\tdistance = hypot(9, LFSaw.kr(1/6, 0.5, 100));\n\tpitchRatio = (344 - Slope.kr(distance)) / 344;\n\tamp = 300 / distance.squared;\n\tf = q * pitchRatio * 1000 + 200;\n \ta = SinOsc.ar(f + { LFNoise2.ar(q * q + 0.45, 9) }.dup) * amp * 0.1;\n    RHPF.ar(\n       \tCombC.ar(a, 1, Lag.kr(q, q.squared), q * 808) * 0.25,\n   \t\tLag.kr(q, q.squared) * 808 + 50,\n   \t\t(q + 1).reciprocal.squared,\n   \t\t0.1,\n   \t\ta\n   \t)\n};\n\nfork {\n\tvar d = y.play;\n\tvar q, b;\n\t(1.0.rand + 0.1).wait;\n\t\t3.do {\n\t\tb = z.value;\n\t\t3.do {|i|\n\t\t\tq = b.(i);\n\t\t\t3.do {|j|\n\t\t\t\td.set(\\q, q.(j));\n\t\t\t\t2.wait\n\t\t\t}\n\t\t}\n\t};\n\td.free;\n}\n)\n\n\n////////////\n\n// On 29 Oct 2005, Jonathan Segal wrote:\n\n// cadavre exquis no. 2\n// chunks in the sauce\n\n(\nz = { var x = 1.0.rand;\n    { |i|\n        { |j| (x * i) + (x * j) % 5 }\n    }\n};\n\ny = { |q=0.1|\n\n    var a, f;\n    var  distance, pitchRatio, amp, pulser, ratio;    // see hypot help\n        pulser = LFNoise0.kr(q.reciprocal).range (0.125, 8);\n    distance = hypot(9, LFCub.kr(pulser, 0.5, 100));\n    pitchRatio = (distance.squared - Slope.kr(distance)) / distance.squared;\n    amp = 300 / distance.squared;\n    f = q * Slope.kr(pitchRatio, 0.002).squared  + 150;\n     a = (SinOsc.ar(f + { LFNoise0.ar(q.reciprocal*2, 27) }.dup) * amp).distort;\n     ratio=LFNoise2.kr(q).range(0,1);\n     CombC.ar(a*ratio, 1, Lag.kr(q/500, q).max(0.0001),q, a*ratio.reciprocal).softclip\n\n};\n\nfork {\n    var d = y.play;\n    var q, b;\n    (1.0.rand + 0.1).wait;\n        4.do {\n        b = z.value;\n        5.do {|i|\n            q = b.(i);\n            3.do {|j|\n                d.set(\\q, q.(j));\n                0.5.wait\n            }\n        }\n    };\n    d.free;\n}\n)\n\n\n////////////\n\n// On 29 Oct 2005, Tim Walters wrote:\n\n// cadavre exquis no. 2\n// the curry eats itself\n\n(\nz = { var x = 1.0.rand;\n    { |i|\n        { |j| (x * i) + (x * j) % 5 }\n    }\n};\n\ny = { |q=0.1|\n\n    var a, f, z, c;\n    var  distance, pitchRatio, amp, pulser, ratio;    // see hypot help\n        pulser = LFNoise0.kr(q.reciprocal).range (0.125, 8);\n    distance = hypot(9, LFCub.kr(pulser, 0.5, 100)).reciprocal * 0.001;\n    pitchRatio = (distance.squared - Slope.kr(distance)) / distance.squared;\n    amp = 300 / distance.squared;\n    f = q * Slope.kr(pitchRatio, 0.002).squared  + 150;\n     a = (SinOsc.ar(f + { LFNoise0.ar(q.reciprocal*2, 27) }.dup) * amp).distort;\n     z = Saw.ar(ZeroCrossing.ar(a) * 0.125).range(0.5, 1);\n\n     ratio=LFNoise2.kr(q).range(0,1);\n     c = CombC.ar(a*ratio * z, 1, Lag.kr(q/500, q).max(0.0001) * z, q * z,\n     a*ratio.reciprocal * 0.1).clip(-0.25, 0.25);\n    Normalizer.ar(Formlet.ar(c, q * 400 + 400, \n    \t(q + 1).reciprocal * z * 0.01, z * 0.01), 0.75, 0.1)\n\n};\n\nfork {\n    var d = y.play;\n    var q, b;\n    (1.0.rand + 0.1).wait;\n        4.do {\n        b = z.value;\n        5.do {|i|\n            q = b.(i);\n            3.do {|j|\n                d.set(\\q, q.(j));\n                ((q.(j) + 1).reciprocal + 0.5).wait\n            }\n        }\n    };\n    d.free;\n}\n)\n\n\n///////////\n\n// On 29 Oct 2005, Fredrik Olofsson wrote:\n\n// cadavre exquis no. 2\n// the country&western curry that ate itself?\n\n(\nz = { var x = 1.0.rand;\n    { |i|\n        { |j| (x * i) + (x * j) % 5 }\n    }\n};\n\ny = { |q=0.1|\n\tvar a, f, z, c, i, o;\n\tvar  distance, pitchRatio, amp, pulser, ratio;    // see hypot help\n\ti= LocalIn.ar(2);\n\tpulser = (Amplitude.kr(i)+q).range(0.15, 2);\n\tdistance = hypot(9, LFCub.kr(pulser, 0.5, 100)).reciprocal * 0.001;\n\tpitchRatio = (distance.squared - Slope.kr(distance)) / distance.squared;\n\tamp = 300 / distance.squared;\n\tf = q * Slope.kr(pitchRatio, 0.002).squared  + 150;\n\ta = (SinOsc.ar(f + { LFNoise0.ar(q.reciprocal*2, 27) }.dup) * amp).distort;\n\tz = Saw.ar(ZeroCrossing.ar(a) * 0.125).range(0.5, 1);\n\n\tratio=LFNoise2.kr(q).range(0,1);\n\tc = CombC.ar(a*ratio * z, 1, Lag.kr(q/500, q).max(0.0001) * z, q * z,\n\ta*ratio.reciprocal * 0.1).clip(-0.25, 0.25);\n\to= Normalizer.ar(Formlet.ar(c, q * 400 + 400, \n\t\t(q + 1).reciprocal * z * 0.01, z * 0.01), 0.75, 0.1);\n\tLocalOut.ar(DelayN.ar(o, 0.1, 0.1));\n\to\n};\n\nfork {\n\tvar d = y.play;\n\tvar q, b;\n\t(1.0.rand + 0.1).wait;\n\t\t4.do {\n\t\tb = z.value;\n\t\t5.do {|i|\n\t\t\tq = b.(i);\n\t\t\t3.do {|j|\n\t\t\t\td.set(\\q, q.(j));\n\t\t\t\t((q.(j) + 1).reciprocal + 0.5).wait\n\t\t\t}\n\t\t}\n\t};\n\td.free;\n}\n)\n\n// (couldn't get the banjo sound quite right)\n// _f\n\n\n////////////\n\n// On 29 Oct 2005, John Thompson wrote:\n\n// cadavre exquis no. 2\n// the country&western pigeon curry that ate itself?\n\n(\nRoutine({\n7.do({\n~zed = { var x = 1.0.rand;\n        { |i|\n                { |j| (x * i) + (x * j) % 5 }\n        }\n};\n\n~yed = { |q=0.1|\n\n     var a, f;\n     var  distance, pitchRatio, amp;   \n        distance = hypot(9, LFSaw.kr(1/6, 0.5, 1000 + 1000.rand));\n        pitchRatio = (344 - Slope.kr(distance)) / 344;\n        amp = 300 / distance.squared;\n        f = q * pitchRatio * 1000 + 200;\n        a = SinOsc.ar(f + { LFNoise2.ar(q * q + 0.45, 9) }.dup) * amp * 0.1;\n     Pan2.ar(LeakDC.ar(PitchShift.ar(RHPF.ar(\n                CombC.ar(a, 0.15, Lag.kr(q, q.squared) \n                \t* 0.5, 5 + (q * LFNoise0.kr(15, 100, 808))) * 0.25,\n                Lag.kr(q, q.squared) * LFNoise1.kr(15, 1000, 1808) + 50,\n                LFNoise1.kr(13, 1.1, (q + 1).reciprocal.squared),\n                0.1,\n                a\n        ), 0.4, 0.5, 2.0, SinOsc.kr(0.1, 0, 0.2,\n0.2))), -1.0 + LFNoise1.kr(5, 1, 0))\n};\n\nfork {\n        var d = ~yed.play;\n        var q, b;\n        (1.0.rand + 0.1).wait;\n                3.do {\n                b = ~zed.value;\n\n                3.do {|i|\n                        q = b.(i);\n                        3.do {|j|\n                                d.set(\\q, q.(j));\n                                2.wait\n                        }\n                }\n        };\n        d.free;\n};\n\n});\n\n// [code block contniues]\n(\nz = { var x = 1.0.rand;\n     { |i|\n         { |j| (x * i) + (x * j) % 5 }\n     }\n};\n\ny = { |q=0.1|\n        var a, f, z, c, i, o;\n        var  distance, pitchRatio, amp, pulser, ratio;\n\n        i= LocalIn.ar(2);\n        pulser = (Amplitude.kr(i)+q).range(0.15, 2);\n        distance = hypot(9, LFCub.kr(pulser, 0.5, 100)).reciprocal * 0.001;\n        pitchRatio = (distance.squared - Slope.kr(distance)) / distance.squared;\n        amp = 300 / distance.squared;\n        f = q * Slope.kr(pitchRatio, 0.002).squared  + 150;\n        a = (SinOsc.ar(f + { LFNoise0.ar(q.reciprocal*2, 27) }.dup) * amp).distort;\n        z = Saw.ar(ZeroCrossing.ar(a) * 0.125).range(0.5, 1);\n\n        ratio=LFNoise2.kr(q).range(0,1);\n        c = CombC.ar(a*ratio * z, 1, Lag.kr(q/500, q).max(0.0001) * z, q * z,\n        a*ratio.reciprocal * 0.1).clip(-0.25, 0.25);\n        o= Normalizer.ar(\n        \tFormlet.ar(c, q * 400 + 400, (q + 1).reciprocal * z * 0.01, z * 0.01), 0.75, 0.1\n        );\n        LocalOut.ar(DelayN.ar(o, 0.1, 0.1));\n        o\n};\n\nfork {\n        var d = y.play;\n        var q, b;\n        (1.0.rand + 0.1).wait;\n                4.do {\n                b = z.value;\n                5.do {|i|\n                        q = b.(i);\n                        3.do {|j|\n                                d.set(\\q, q.(j));\n                                ((q.(j) +1).reciprocal + 0.5).wait\n                        }\n                }\n        };\n        d.free;\n}\n);\n\n}).play\n)\n\n\n////////////////////////\n\n// On 31 Oct 2005, Julian Rohrhuber wrote:\n\n// cadavre exquis no. 2\n// the country&western pigeon curry that ate itself but the rubbersnake ?\n\n(\nvar zed, yed, led;\nvar f1, f2;\n\nzed = { var x = 1.0.rand;\n\t\t{ |i|\n\t\t\t\t{ |j| (x * i) + (x * j) % 5 }\n\t\t}\n};\n\nyed = { |q=0.1|\n\n\t var a, f;\n\t var  distance, pitchRatio, amp;\n\t\tdistance = hypot(9, LFSaw.kr(1/6, 0.5, 1000 + 1000.rand));\n\t\tpitchRatio = (344 - Slope.kr(distance)) / 344;\n\t\tamp = 300 / distance.squared;\n\t\tf = q * pitchRatio * 1000 + 200;\n\t\ta = SinOsc.ar(f + { LFNoise2.ar(q * q + 0.45, 9) }.dup) * amp * 0.1;\n\t Pan2.ar(\n\t\tLeakDC.ar(\n\t\t\tPitchShift.ar(RHPF.ar(\n\t\t\t\tCombC.ar(a, 0.15, Lag.kr(q, q.squared) * 0.5, \n\t\t\t\t\t5 + (q * LFNoise0.kr(15, 100, 808))) * 0.25,\n\t\t\t\tLag.kr(q, q.squared) * LFNoise1.kr(15, 1000, 1808) + 50,\n\t\t\t\tLFNoise1.kr(13, 1.1, (q + 1).reciprocal.squared),\n\t\t\t\t0.1,\n\t\t\t\ta\n\t\t),\n\t\t0.4, 0.5, 2.0, SinOsc.kr(0.1, 0, 0.2, 0.2))),\n\t  -1.0 + LFNoise1.kr(5, 1, 0))\n};\n\nled = { |q=0.1| Pan2.ar(BPF.ar(Impulse.ar(10 * (q+1), 3), \n\tq * 1000 + 3000, 0.05) * q.lag(1), q * 2 - 1) };\n\nf1 = { |synthFunc, wait=({2.0 + 0.2.rand}), repeat=3|\n\t\t\tvar d = synthFunc.play;\n\t\t\tvar q, b;\n\t\t\twait.value.wait;\n\t\t repeat.do {\n\t\t\t\tb = zed.value;\n\t\t\t\t3.do {|i|\n\t\t\t\t\t\tq = b.(i);\n\t\t\t\t\t\t3.do {|j|\n\td.set(\\q, q.(j));\n\twait.value.wait;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t};\n\t\td.free;\n};\n\n2.do {\n\t\tfork { f1.(yed);  f1.(led, { #[1, 2].choose }, 8); };\n\t\tfork {\n\t\t\t6.wait;\n\t\t\tf1.(led, { 0.1.rand + 0.1 }, 18);\n\t\t};\n\t};\n)\n\n// End of submissions",
    "Controller.help.scd": "// Controller.help.sc - (c) rohan drape, 2004-2007\n\n// Initialise as required, ie. boot\n// scsynth & interface engine.\n\ns.boot;\nSwingOSC.default.initTree;\n\n// Create a new <Controller> value, and create\n// a window to monitor and edit <Ctl> status.\n// A <Ctl> interface has three components, a\n// NameView, a DialView and a ValueView.\n\n(\nc = Controller.new(s, 256) ;\nc.makeInterface(rows: 4, columns: 3, offset: 0);\n)\n\n// There is a trivial midi initializer to set\n// up some standard midi mappings, if it does\n// not do what you want you will need to do\n// this yourself - if you are not using midi\n// skip this...\n\nc.midiInitialize;\n\n// Setup the first <Ctl> with a non-zero depth\n// value.  Editing the DialView modifies the\n// <Ctl> value.  Pressing the NameView\n// increments the <Ctl> state, using the shift\n// modifier decrements.  Note that modifying\n// the state modifies the value, and also the\n// reverse.  The display method prints the\n// <Ctl> status.\n\n(\nc[0].setup(\"Frequency\", ControlSpec.new(220, 440, ExponentialWarp), 330, 4);\nc[0].display;\nc[0].addRecv({\n\targ index, spec, value, state;\n\t[index, spec, value, state].postln;});\n)\n\n// Make the state modification follow a\n// constrained map.  The array is given in\n// 'value' space and mapped immediately to\n// 'internal' space, subsequent changes to the\n// <Ctl> spec will keep the same 'shape'\n// stateMap.  Note that the map is only\n// consulted when the state is modified,\n// changing the value modifies the state in\n// the same unit linear manner.\n\nc[0].stateMap = [330, 360];\n\n// The state modification map need not be\n// linear.\n\nc[0].stateMap = [220, 221, 400];\n\n// If the state modification map has the same\n// number of elements as the depth of the\n// <Ctl> the values are located exactly.\n\nc[0].depth = 4;\nc[0].stateMap = [220, 230, 240, 420];\nc[0].state = 1;\nc[0].value;            // => 230\nc[0].increment(-2);\nc[0].value;            // => 420\n\n// Assigning nil as the map reinstates the\n// default linear map.\n\nc[0].stateMap = nil;\n\n// The <Ctl> value can be updated from the\n// server.  The ValueView at a <Ctl> interface\n// is a button that can be pressed to update\n// that value in this manner.\n\n(\ns.sendMsg(\"/c_set\", 0, 345);\nc[0].update;\nc[0].value;\n)\n\n// Make an interface with a color scheme.  The\n// colorChooser argument should be a procedure\n// that returns a <Color> value based on an\n// <Integer> index.\n\n(\nc.makeInterface(colorChooser: {\n\targ index;\n\t[Color.yellow, Color.white].wrapAt(index);});\n)\n\n// Replace the default midi controller map.\n// This map makes the following sixteen\n// controller arrangement:\n\n//         .---.---.---.---.---.---.---.---.\n//         | 0 | 8 | 1 | 9 | 2 | 10| 3 | 11|\n//         .---.---.---.---.---.---.---.---.\n//         | 4 | 12| 5 | 13| 6 | 14| 7 | 15|\n//         .---.---.---.---.---.---.---.---.\n\n(\nMIDIIn.control = {\n\targ source, channel, number, value;\n\tvar index ;\n\tindex = [(0..7),(8..15)].lace(16).at(number);\n\tc[index].internal = value / 127.0;\n};\n)\n\n// Make two Sine oscillators.\n\n(\nc[0].setup(\"Frequency\", ControlSpec.new(220, 240, ExponentialWarp), 221);\nc[1].setup(\"Gain\", ControlSpec.new(0, 1/5, LinearWarp), 1/7);\nc[8].setup(\"Frequency\", ControlSpec.new(220, 240, ExponentialWarp), 229);\nc[9].setup(\"Gain\", ControlSpec.new(0, 1/5, LinearWarp), 1/9);\n{SinOsc.ar(In.kr([0, 8]), 0, In.kr([1, 9]))}.play\n)\n\n// A test instrument.\n\n(\nSynthDef.new(\"ping\", {\n\targ out = 0, freq = 440, pan = 0, gain = 1;\n\tOut.ar(out, Pan2.ar(\n\t\tSinOsc.ar(freq, 0,\n\t\t\tEnvGen.kr(envelope: (Env.perc), doneAction: 2)),\n\t\tpan, gain));}).send(s);\n)\n\n// Use <Ctl> values for scheduling nodes\n// (pings).\n\n(\nc[0].setup(\"DelayTime\", ControlSpec.new(0.05, 0.75, LinearWarp), 0.18);\nc[1].setup(\"FreqScalar\", ControlSpec.new(0.5, 2, LinearWarp), 1.75);\nc[2].setup(\"PanLocation\", ControlSpec.new(-1, 1, LinearWarp), 0);\nc[3].setup(\"BasicGain\", ControlSpec.new(0, 1, LinearWarp), 0.1);\nc[4].setup(\"Scale\", ControlSpec.new(0, 1, LinearWarp), 0.0, 3);\nRoutine.new({\n\tvar d;\n\td = [[0, 2, 4, 5, 7, 9, 11],\n\t\t[0, 2, 3, 5, 6, 8, 9, 11],\n\t\t[0, 2, 4, 6, 8, 10]];\n\tinf.do({\n\t\targ n;\n\t\tvar f;\n\t\tf = (d[c[4].state].choose + 48 + [-12,0,12].choose).midicps;\n\t\t[n,f].postln;\n\t\ts.sendMsg(\"/s_new\", \"ping\", -1, 0, 0,\n\t\t\t\"freq\", f * c[1].value,\n\t\t\t\"pan\", c[2].value,\n\t\t\t\"gain\", c[3].value + 0.25.rand);\n\t\tc[0].value.yield;\n\t\tc[0].value.postln;\n\t});\n}).play(SystemClock);\n)\n\n// Add a language level oscillator to the pan\n// <Ctl>.  This runs at the same rate as the\n// node instantiation routine, though it is\n// not synchronized.  Note that the interface\n// reflects changes at the <Ctl>.\n\nRoutine.new({inf.do({c[2].value = 2.0.rand - 1.0; c[0].value.yield;})}).play;\n\n// Setup midi NoteOn messages to increment and\n// decrement state as if Midi Controllers\n// (ie. 7bit signal).\n\n(\nc[0].depth = 127;\nMIDIIn.noteOn = {\n\targ src, chan, num, vel;\n\tvar step;\n\tif(num==60, {step = -1}, {step = 1});\n\tc[0].increment(step);\n};\n)\n\n// A single sawtooth oscillator with NoteOn\n// and NoteOff messages setting C values.\n\n(\nc[16].setup(\"Note\", ControlSpec.new(0, 127, LinearWarp));\nc[17].setup(\"Gain\", ControlSpec.new(0, 0.1, LinearWarp));\nMIDIIn.noteOn = {\n\targ src, chan, num, vel;\n\tc[16].internal = num/127.0;\n\tc[17].internal = vel/127.0;\n};\nMIDIIn.noteOff = {\n\targ src, chan, num, vel;\n\tc[17].internal = 0.0;\n};\n{LFSaw.ar(In.kr(16).midicps, 0, In.kr(17))}.play\n)\n\n// Find out where the audio input bus is.\n\ns.options.dump;\n\n// Two comb filters, one tuned using a delay\n// time, the other a note input.\n\n(\nc[0].setup(\"DelayTime\", ControlSpec.new(0.001, 0.18, LinearWarp));\nc[1].setup(\"DecayTime\", ControlSpec.new(0.01, 9.0, LinearWarp));\nc[2].setup(\"Gain\", ControlSpec.new(0, 1, LinearWarp));\nc[3].setup(\"Note\", ControlSpec.new(0, 127, LinearWarp));\nc[4].setup(\"DecayTime\", ControlSpec.new(0.01, 9.0, LinearWarp));\nc[5].setup(\"Gain\", ControlSpec.new(0, 1, LinearWarp));\n{[\n CombC.ar(In.ar(8), 0.2, In.kr(0), In.kr(1), In.kr(2)),\n  CombC.ar(In.ar(8), 0.2, 1.0 / (In.kr(3).floor.midicps), In.kr(4), In.kr(5))\n];}.play;\n)\n\n// Make an interface with non default numbers\n// of rows and columns and name each <ctl>\n// according to index.\n\n(\nn = 36;\nc = Controller.new(s, n);\nc.makeInterface(6, 6);\nn.do({\n\targ i;\n\tc[i].setup(\"Ctl:\" ++ i.asString);\n});\n)\n\n// Dump information about a <Ctl>\n\nc[0].dump;\n\n// <Controller> implements the copySeries\n// method, allowing expressions like.\n\nc[10..13].collect(_.value).sum\n\n// There is a snapshot mechanism that collects\n// the current values.\n\n~preset = c.snapshot(0,15);\n\n// Scramble the values just stored...\n\nc[0..15].do(_.internal = 1.0.rand);\n\n// Restore values from snapshot.\n\nc.restore(~preset);\n\n// Non-default interfaces.  Make a trivial\n// multi-slider to set <Ctl> values.\n\n(\nw = GUI.window.new(\"c.Sliders\", Rect(200 , 200, 200, 200)).front;\ns = GUI.multiSliderView.new(w, Rect(0, 0, 200, 200));\ns.action = {arg e; c[e.index].value = e.currentvalue;};\n)\n",
    "c25sec4-1_LPFrates.scd": "// Demonstrates the effect of using checkSameRateAsFirstInput\ns.boot;\nx = {LPF.ar(WhiteNoise.kr) }.play(s); // Error\nx = {LPF.ar(WhiteNoise.ar) }.play(s); // OK\nx.free;\nx = {LPF.kr(WhiteNoise.ar) }.play(s); // Error\nx = {LPF.kr(WhiteNoise.kr) }.play(s); // OK\nx.free;\n",
    "Ch3code.scd": "\n///////////////////////////////////////////////////////////////\n// Clock examples\n\nSystemClock.sched(2, {\"foo\".postln; }); \n\n// \"foo\" repeats every second\nSystemClock.sched(0, {\"foo\".postln; 1.0 }); \n\n// \"bar\" repeats at a random delay\nSystemClock.sched(0, {\"bar\".postln; 1.0.rand }); \n\n// clear all scheduled events \nSystemClock.clear; \n\n// causes an \"operation cannot be called from this Process\" error\nSystemClock.sched(1, { SCWindow.new.front });\n\n// defer reschedules GUI code on the AppClock, so this works\nSystemClock.sched(1, { { SCWindow.new.front }.defer });\n\n//TempoClock\n(\nt = TempoClock.new; // make a new TempoClock\nt.sched(0, {\"Hello!\".postln; 1});\n)\nt.tempo = 2; // twice as fast\nt.clear;\n\n// Routine\n(\nr = Routine({\n\"foo\".yield;\n\"bar\".yield;\n});\n)\nr.value; // foo\nr.value; // bar\nr.value; // we've reached the end, so it returns nil\n\n// Routine in a Clock\n(\nr = Routine({\n\t\"foo\".postln;\n\t1.yield; // reschedule after 1 second\n\t\"bar\".postln;\n\t1.yield;\n\t\"foobar\".postln;\n});\nSystemClock.sched(0, r);\n) \n\n///////////////////////////////////////////////////////////////\n// Figure 3.1 A simple routine illustrating a musical use of yield\n// Fermata\ns.boot;\n(\nr = Routine({\t\n\tx = Synth(\\default, [freq: 76.midicps]);\n\t1.wait;\n\t\n\tx.release(0.1);\n\ty = Synth(\\default, [freq: 73.midicps]);\n\t\"Waiting...\".postln;\n\tnil.yield;// fermata\n\t\n\ty.release(0.1);\n\tz = Synth(\\default, [freq: 69.midicps]);\n\t2.wait;\n\tz.release;\n});\n)\n// do this then wait for the fermata\nr.play;\n// feel the sweet tonic... \nr.play; \n\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////// \n// Figure 3.2 Using Task so you can pause the sequence\n(\nt = Task({\t\n\tloop({\t // loop the whole thing\n\t\t3.do({\t // do this 3 times\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 76.midicps]);\n\t\t\t0.5.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 73.midicps]);\n\t\t\t0.5.wait;\n\t\t});\n\t\t\"I'm waiting for you to press resume\".postln;\n\t\tnil.yield;// fermata\n\t\tx.release(0.1);\n\t\tx = Synth(\\default, [freq: 69.midicps]);\n\t\t1.wait;\n\t\tx.release;\n\t});\n});\n\nw = Window.new(\"Task Example\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\nButton.new(w, Rect(0, 0, 100, 20)).states_([[\"Play/Resume\", Color.black, Color.clear]])\n\t.action_({ t.resume(0);});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Pause\", Color.black, Color.clear]])\n\t.action_({ t.pause;});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Finish\", Color.black, Color.clear]])\n\t.action_({ \n\t\tt.stop; \n\t\tx.release(0.1);\n\t\tw.close;\n\t});\n)\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.3 Nesting tasks inside routines\n(\nr = Routine({\t\n\tc = TempoClock.new; // make a TempoClock\n\t// start a 'wobbly' loop\n\tt = Task({\t\n\t\tloop({\t\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 61.midicps, amp: 0.2]);\n\t\t\t0.2.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 67.midicps, amp: 0.2]);\n\t\t\trrand(0.075, 0.25).wait; // random wait from 0.1 to 0.25 seconds\n\t\t});\n\t}, c); // use the TempoClock to play this Task\n\tt.start;\n\tnil.yield;\n\t\n\t// now add some notes\n\ty = Synth(\\default, [freq: 73.midicps, amp: 0.3]);\n\tnil.yield;\n\ty.release(0.1);\n\ty = Synth(\\default, [freq: 79.midicps, amp: 0.3]);\n\tc.tempo = 2; // double time\n\tnil.yield;\n\tt.stop; y.release(1); x.release(0.1); // stop the Task and Synths\n});\n)\n\nr.next; // start loop\nr.next; // first note\nr.next; // second note; loop goes 'double time'\nr.next; // stop loop and fade\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.4 Using patterns within a task\n\n(// random notes from lydian b7 scale\np = Pxrand([64, 66, 68, 70, 71, 73, 74, 76], inf).asStream; \n// ordered sequence of durations\nq = Pseq([1, 2, 0.5], inf).asStream; \nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\nt.stop; x.release(2);\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.5 Thanks to polymorphism we can substitute objects that understand the same message\n(\np = 64; // a constant note\nq = Pseq([1, 2, 0.5], inf).asStream; // ordered sequence of durations\nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\n// now change p\np = Pseq([64, 66, 68], inf).asStream; // to a Pattern: do re mi\np = { rrand(64, 76) }; // to a Function: random notes from a chromatic octave\nt.stop; x.release(2);\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.6 Using 'messaging style': Score\n\n(\nSynthDef(\"ScoreSine\",{ arg freq = 440;\nOut.ar(0,\n\tSinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)\n)\n}).add;\nx = [\n// args for s_new are synthdef, nodeID, addAction, targetID, synth args ...\n[0.0, [ \\s_new, \\ScoreSine, 1000, 0, 0,  \\freq, 1413 ]],\n[0.5, [ \\s_new, \\ScoreSine, 1001, 0, 0,  \\freq, 712 ]],\n[1.0, [ \\s_new, \\ScoreSine, 1002, 0, 0,  \\freq, 417 ]],\n[2.0, [\\c_set, 0, 0]] // dummy command to mark end of NRT synthesis time\n];\nz = Score(x);\n)\nz.play;\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.7 Executing one line at a time\n\n(\n// here's a synthdef that allows us to play from a buffer, with a fadeout\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t\t* Linen.kr(gate, doneAction: 2); // release synth when fade done\n\t)\n}).add;\n// load all the paths in the sounds/ folder into buffers\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \n)\n// now here's the score, so to speak\n// execute these one line at a time\n~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[0]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[1]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[2]]);\n~nowPlaying.release;\n// free the buffer memory\n~someSoundsBuffered.do(_.free);\n \n \n \n \n \n \n \n///////////////////////////////////////////////////////////////\n// Figure 3.8 Play cues with a simple GUI\n\n(\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t* Linen.kr(gate, doneAction: 2) * 0.6; \n\t\t// with 'doneAction: 2' we release synth when fade is done\t\n) }).add;\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \nn = 0; // a counter\n// here's our GUI code\nw = Window.new(\"Simple CuePlayer\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\n//this will play each cue in turn\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Play Cue\", Color.black, Color.clear]]).action_({ \n\tif(n < ~someSounds.size, {\n\t\tif(n != 0, {~nowPlaying.release;}); \n\t\t~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[n]]); n=n+1;\n\t});\n}); \n//this sets the counter to the first cue\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Stop / Reset\", Color.black, Color.clear]]).action_({ n=0; ~nowPlaying.release; }); \n// free the buffers when the window is closed\nw.onClose = { ~someSounds.do(_.free); };\n)\n\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.9 Gathering up files for multichannel cues \n\n// gather all your folder paths\n//this will path match each folder in the collection, i.e. we will have a collection of collections of paths\n\n~groupOfindivCueFolders = \"sounds/*\".pathMatch.collect{ | item |  (item.asSymbol++\"*\").pathMatch };\n\nPost << ~groupOfindivCueFolders;  //see them all !\n\n//check how many cues you will have in the end\n~groupOfindivCueFolders.size; \n\n//automate the buffering process for all cues:\n~bufferedCues = ~groupOfindivCueFolders.collect{|item, i| item.collect{| path |  Buffer.read(s,  path)}}; //now all our cue files are sitting in their buffers ! \n\n~bufferedCues[0];  //here is cue 1\n\n// see it in the post window:\nPost << ~bufferedCues[0];\n\n// play them all in a Group, using our previous synthdef\n// we use bind here to ensure they start simultaneously\n(\ns.bind({\t\n\t~nowPlaying = Group.new(s); // a group to put all the channel synths in\n\t~bufferedCues[0].do({|cue| Synth(\"playbuf\", [buf: cue], ~nowPlaying)})\n});\n)\n// fade them out together by sending a release message to the group\n~nowPlaying.release;\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.10 Recording the results of making sounds with supercollider\n\ns.boot; // make sure the server is running\n(  \t// first evaluate this section\nb = Buffer.read(s, \"sounds/a11wlk01.wav\"); // a source\ns.prepareForRecord; // prepare the server to record (you must do this first)\n)\n(\t// simultaneously start the processing and recording\ns.bind({\n\t// here's our funky effect\n\tx = { var columbia, amp; \n\t\tcolumbia = PlayBuf.ar(1, b, loop: 1);\n\t\tamp = Amplitude.ar(columbia, 0.5, 0.5, 4000, 250); // 'sticky' amp follower\n\t\tOut.ar(0, Resonz.ar(columbia, amp, 0.02, 3)) // filter; freq follows amp\n\t\t}.play;\ns.record;\n});\n)\ns.pauseRecording; // pause\ns.record // start again\ns.stopRecording; // stop recording and close the resulting sound file\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n\n// Thinking in the Abstract examples\n(\n{\nResonz.ar(Dust2.ar(5), 300, 0.001, 100)  +\nResonz.ar(Dust2.ar(5), 600, 0.001, 100)  +\nResonz.ar(Dust2.ar(5), 900, 0.001, 100) * 3.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n(\nf = 300;\nn = 3;\n{\nMix.fill(n, {|i| Resonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 100)})\n* n.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n(\nf = 40;\nn = 50;\n{\nMix.fill(n, {|i| Resonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)})\n* n.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.12 A variable number of resonators with an automatically created GUI       \n(\nf = 300;\nn = 30; // number of resonators\nt = Array.fill(n, { |i|\n{\nResonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)\n* n.reciprocal; // scale to ensure no clipping\n}.play;\n});\n\n// now make a GUI\n// a scrolling window so we don't run out of space\nw = Window.new(\"Buttons\", Rect(50, 100, 290, 250), scroll:true);\nw.view.decorator = FlowLayout.new(w.view.bounds); // auto layout the widgets\nn.do({|i|\nButton.new(w, Rect(0, 0, 130, 30)).states_([\n[\"Freq\" + (f * (i + 1)) + \"On\", Color.black, Color.white],\n[\"Freq\" + (f * (i + 1)) + \"Off\", Color.white, Color.black]\n])\n.action_({ arg butt;\nt[i].run(butt.value == 0);\n});\n});\nw.front;\n)\n  \n\n\n\n///////////////////////////////////////////////////////////////\n// Empty Gestures\n\n( //you will be able to add multiple soundfiles, just shift click when selecting !\nvar file, soundPath;\n~buffers = List[];\nDialog.getPaths({ arg paths;\npaths.do({|soundPath|\n//post the path to verify that is the one you expect!\n    soundPath.postln; \n//adds the recently selected buffer to your list \n    ~buffers.add(Buffer.read(s, soundPath);); })\n});\n)\n\n~buffers.size;\n~buffers[0];\n~buffers[0].play;\n\n\n(\n// buffer player with done action and control of envelope and panning\nSynthDef(\\samplePlayer, { arg out=0, buf = 0,\nrate = 1, at =0.01, rel= 0.1, pos =0, pSpeed = 0, lev = 0.5;\nvar sample, panT,  amp, aux;\nsample = PlayBuf.ar(1, buf, rate*BufRateScale.kr(buf), 1, 0, 0);\npanT= FSinOsc.kr(pSpeed);\namp = EnvGen.ar(Env.perc(at, rel, lev), doneAction: 2);\nOut.ar(out, Pan2.ar(sample, panT, amp));\n}).memStore;\n)\n\nSynth(\\samplePlayer,[\\out, 0, \\bufnum, ~buffers[0], \\rel, 0.25]);\nSynth(\\samplePlayer,[\\out, 0, \\bufnum, ~buffers[~buffers.size.rand], \\rel, 0.25]); \n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Figure 3.13 Making a stuttering gesture using a geometric pattern\n\n(/* a routine for creating a ritardando stutter with panning, you must have\nrun the code in fig 3.9 so that this routine may find some sounds already loaded into buffers, you can change the index of ~bufferedCues to test the routine on different sounds */\n\n\n~stut = Routine( { var dur, pos;\n~stutPatt = Pseq([Pgeom(0.01, 1.1707, 18), Pn(0.1, 1),Pgeom(0.1, 0.94, 200) ]);\n~str= ~stutPatt.asStream;\n100.do{\n    dur =  ~str.next;\n    dur.postln; \t//so we can check values on the post window\n    ~sample = Synth(\"samplePlayer\",[\\out, 0, \\buf,  ~bufferedCues[0], \\at, 0.1, \\rel, 0.05,\\pSpeed, 0.5]);\n    dur.wait;\n}\n});\n)\n\n//now play it\n~stut.play;\n// reset before you play again!\n~stut.reset; \n \n\n\n///////////////////////////////////////////////////////////////\n// More Empty Gestures\n\n// randomly selected frequency, duration 0.1 seconds\nPbind(\\freq, Prand([300, 500, 231.2, 399.2], 30), \\dur, 0.1).play;\n\n~gest1 = Pbind(\\instrument, \\samplePlayer, \\dur, 2, \\rel, 1.9);\n~player = ~gest1.play; //make it play\n~player.stream = Pbind(\\instrument, \\samplePlayer, \\dur, 1/8, \\rate, Pxrand([1/2,1,2/3,4],inf), \\rel, 0.9).asStream; //substitute the stream\n~player.stop;\n\n\n~gest1 = Pbind(\\instrument, \\samplePlayer, \\dur, Pgeom(0.01, 1.1707, 20), \\rel, 1.9);\n~gest1.play;\n\nPbind(\\instrument, \\samplePlayer, \\dur, Pseq([Pgeom(0.01, 1.1707, 20), Pgeom(0.01, 0.93, 20)], 1), \\rel, 1.9, \\pSpeed, 0.5).play;\n\nPbind(\\instrument, \\samplePlayer, \\dur, Pseq([Pgeom(0.01, 1.1707, 20), Pgeom(0.01, 0.93, 20)], 1),\\rate, Pxrand([1/2,1,2/3,4],inf), \\rel, 1.9, \\pSpeed, 0.5).play;\n\n~rhythm1 = Pseq([1/4, 1/4, 1/8, 1/12, 1/24, nil]); //the nil is so it will stop !\n\n~gest1 = Pdef(\\a, Pbind(\\instrument, \\samplePlayer, \\dur, ~rhythm1, \\rel, 1.9, \\pSpeed, 0.5) );\n~gest1.play;\n\n~rhythm1 = Pseq([1/64,1/64,1/64, 1/32, 1/32, 1/32, 1/32, 1/24, 1/16, 1/12, nil]);\n~gest1 = Pdef(\\a, Pbind(\\instrument, \\samplePlayer, \\dur, ~rhythm1, \\rel, 1.9, \\pSpeed, 0.5) );\n\n~gest1 = Pdef( \\a , Pbind(\\instrument, \\samplePlayer, \\att, 0.5, \\rel, 3, \\lev, {rrand(0.1,0.2)}, \\dur, 0.05, \\rate, Pseq([ Pbrown(0.8, 1.01, 0.01, 20) ]) ) );\n\n\n",
    "SETO-basicFreq-example.scd": "/*\n * Part of the SuperCollider Book\n * Author of code: Till Bovermann\n * for more information, see http://tuio.lfsaw.de/seto.shtml\n */\n\n/* \n\tBasic example for controlling sound rendering with SETO \n\tWe use Objects of \"_ixya\" style.\n*/\n\nSynthDef(\\testTUIO, {|freq = 400, out = 0, amp = 0, vol = 0.25, famp=1|\n\tOut.ar([out, out+1], SinOsc.ar(freq, 0, (amp.lag(0.01)*vol*famp)))\n}).send(s);\n\nq = ();\n(\nq.synths = IdentityDictionary.new; // a storage for synths\n\nJITseto.action = {|me|\n\ts.bind{\n\t\t// make sure there is a synth\n\t\tq.synths[me].isNil.if{\n\t\t\tq.synths[me] = Synth(\\testTUIO, [\\vol, 0.2, \\amp, 0])\n\t\t};\n\t\ts.sync;\n\t\tme.visible.if({\n\t\t\tq.synths[me].set(\n\t\t\t\t\\freq, me.rotEuler[0].wrap(0, 2pi).linexp(0, 2pi, 400, 800),\n\t\t\t\t\\amp, 1\n\t\t\t)\n\t\t}, {\n\t\t\tq.synths[me].set(\n\t\t\t\t\\amp, 0\n\t\t\t)\n\t\t})\n\t}\n}\n)\n\n// instantiate SETOServer\nt = SETO_OSCServer('_ixya', setoClass: JITseto);\nt.gui;\nt.start;\nt.stop;",
    "TUIO_oscResponder.scd": "/*\n * Part of the SuperCollider Book\n * Author of code: Till Bovermann\n * for more information, see http://tuio.lfsaw.de/seto.shtml\n */\n\n/* \n\tBasic example for controlling sound rendering with TUIO \n\tGiven a fixed set of Objects, each having i,x,y,a and the object ids are 0..numObj-1.\n*/\n\nSynthDef(\\testTUIO, {|freq = 400, out = 0, amp = 0, vol = 0.25|\n\tOut.ar(out, SinOsc.ar(freq, 0, amp*vol)!2)\n}).send(s);\n\n(\nvar synths, numObj = 4, resp;\n\n// Create a Synth for each object. make sure it will not play.\nsynths = Array.fill(numObj, {\n\tSynth(\\testTUIO, [\\vol, numObj.reciprocal, \\amp, 0])\n});\n\n// set up OSC responder\nresp = OSCresponder(nil, \"/tuio/_ixya\", {|time, resp, msg|\n\tvar id, classID, x, y, a, pos, amps;\n\t\n\t// if object state is updated, change frequency of corresponding synth \n\t(msg[1] == \\set).if{\n\t\t# id, classID, x, y, a = msg[2..6];\n\t\tsynths[id].set(\n\t\t\t\\freq, a.wrap(0, 2pi).linexp(0, 2pi, 400, 800)\n\t\t)\n\t};\n\t\n\t// only play synths for alive (i.e. visible) objects\n\t(msg[1] == \\alive).if{\n\t\tamps = Array.fill(numObj, 0);\n\t\tmsg[2..].do{|i|\n\t\t\tamps[i] = 1;\n\t\t};\n\t\tsynths.do{|synth, i|\n\t\t\tsynth.set(\\amp, amps[i])\n\t\t}\n\t};\n}).add;\n)",
    "GUIexample.scd": "(\nw = Window.new( \"Key Example\", Rect( 0,0, 150,150 ));\nc = UserView( w, Rect( 0, 0, 150, 150 )).background_( Color.white );\nc.keyDownAction = { arg view,char,modifiers,unicode,keycode;\n\t[ char, modifiers, unicode, keycode ].postln;\n};\nw.front;\n)\n\n\n(\n    w = Window( \"Mouse Actions\", Rect( 200, 400, 350, 180 ), resizable: false );\n    a = StaticText( w, Rect( 10, 10, 160, 160 ))\n        .string_( \"Mouse Pad\" )\n        .stringColor_( Color.white )\n        .align_( \\center )\n        .background_( Color.blue );\n    b = Slider2D( w, Rect( 180, 10, 160, 160 ))\n        .canFocus_( false );\n    f = { arg view, x, y, modif; var bounds = view.bounds;\n\t\tb.setXY( x / bounds.width, 1.0 - (y / bounds.height) );\n    };\n    a.mouseMoveAction = f;\n    a.mouseDownAction = { arg ... args; b.knobColor = Color.red; f.value( *args )};\n    a.mouseUpAction = { arg ... args; b.knobColor = Color.clear; f.value( *args )};\n    w.front;\n)\n\na.mouseOverAction = f;\nw.acceptsMouseOver = true;  // otherwise mouseOverAction won't be called\n        \n// Mouse events are only fired if the component is enabled.\n\na.enabled = false;\na.enabled = true;\n",
    "MIDIIn_example.scd": "Ins and Outs - MIDI\n\nMidiIn\n\n// connects one input, to the first available output from a device or program\nMIDIIn.connect;\nMIDIIn.connect(0,3);\n// assigns a function to incoming noteOn messages\nMIDIIn.noteOn = { |port, chan, note, vel|\t[port, chan, note, vel].postln};\n\n// first unassign the noteOn method:\nMIDIIn.noteOn = nil;\n// create a NoteOnResponder and assign it to the variable n\nn = NoteOnResponder( { |src, chan, num, vel|\t[src, chan, num, vel].postln},nil,nil,(0..127), (0..127) );\n\n// create a NoteOnResponder and assign it to the variable m\nm = NoteOnResponder( { |src, chan, num, vel| \"responder m \".post;[src, chan, num, vel].postln},nil,nil,[64], (0..127) );\n\n// remove the NoteOnResponder n:\nn.remove;\n\n// Hit note 64 again, and you'll get only one post.\n\n// remove the NoteOnResponder m:\nm.remove;\n\n// Now you've removed all the responders.\n\nNoteOnResponder.removeAll;\n\n// now a Sound example:\n\ns.boot;\n// create a NoteOnResponder that makes a sound:\nm = NoteOnResponder( { |src, chan, num, vel| \n\tvar x = Synth.new(\\default,[\\freq, num.midicps,\\out,0,\\amp,0.2,\\gate,1,\\dur,1,\\pan,0]);\n\tTask({ 1.0.wait; x.free }).play;\n},nil,nil,(0..127), (0..127) );\n\n\nm.remove;\n",
    "MIDIOut_example.scd": "Ins and Outs - MIDI\n\n// initialize the MIDI client:\nMIDIClient.init;\n\n// create a MIDI out connection:\nm = MIDIOut(0, MIDIClient.destinations.at(0).uid);\n\n// On linux, you may just want to use:\nm = MIDIOut(0);\n// and connect SC's first port to your device's port with for example QJackCtl, or use:\nm.connect(1);\n// to connect to the second port\n\n// a task which will play a little melody:\n(\nt = Task( {\n\t[60, 64, 61, 60, 65, 61].do{ |it|\n\t\tm.noteOn(16, it, 60);\n\t\t1.0.wait;\n\t\tm.noteOff(16, it, 60);\n\t};\n\t[64, 65, 67].dup(4).flatten.do{ |it|\n\t\tm.noteOn(16, it, 120);\n\t\t0.25.wait;\n\t\tm.noteOff(16, it, 120);\n\t};\n\t[61, 65, 60, 61, 64, 60].do{ |it|\n\t\tm.noteOn(16, it, 60);\n\t\t1.0.wait;\n\t\tm.noteOff(16, it, 60);\n\t};\n\tm.noteOn(16, 60, 40); m.noteOn(16, 52, 40);\n\t2.0.wait;\n\tm.noteOff(16, 60, 40); m.noteOff(16, 52, 40);\n\tm.noteOn(16, 57, 40); m.noteOn(16, 52, 40);\n\t2.0.wait;\n\tm.noteOff(16, 57, 40); m.noteOff(16, 52, 40);\n\tm.noteOn(16, 53, 40);\n\t2.0.wait;\n\tm.noteOff(16, 53, 40);\n\tm.noteOn(16, 52, 40);\n\t4.0.wait;\n\tm.noteOff(16, 52, 40);\n});\n);\n\n// play the task:\nt.play;\n\n// stop it:\nt.stop;\n\n// free any hung notes if necessary:\nm.allNotesOff(16);\n\n\n\n// using a pattern to send a MIDI event:\na = Pbind(\\degree, Prand([1, 2, 3, [0, 5]], inf), \\bend, Pwhite(0, 76, inf));\n// chain a midi event into the pattern and play it (see Pchain)\n(a <> (type: \\midi, midiout: m)).play;\n\n// stop the pattern with Cmd-. , Alt-., C-c C-s, F12 or ESC\n\n// free any hung notes if necessary:\nm.allNotesOff(16);\n",
    "OSCresponderNode_example.scd": "// Figure 4.1\n//\n// Create two OSC responders for the same command\n~r1 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\tfork {\n\t\t\t(time - thisThread.seconds).wait;\n\t\t\t[\\responder1, time, message, address].postln;\n\t\t};\n\t}\n).add;\n~r2 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\tfork {\n\t\t\t(time - thisThread.seconds).wait;\n\t\t\t[\\responder2, time, message, address].postln;\n\t\t};\n\t}\n).add;\n\n\n// Create a network address representing sclang itself\n~host = NetAddr(\"localhost\", NetAddr.langPort);\n\n// Send an OSC message\n~host.sendMsg(\"/testMsg\", \"OSCresponderNode test\");\n\n// Send an OSC message\n~host.sendMsg( \"/testMsg\", 42, \"string\", pi);\n\n// Send an OSC bundle and execute its contents\n// 200 ms from 'now'\n~host.sendBundle(0.2,\n\t[\"/testMsg\", 42, \"string\", pi],\n\t[\"/testMsg\", 183]);\n\n\n// Remove responders\n~r1.remove;\n~r2.remove;\n\n",
    "ambientlight_source.scd": "// serialport setup\nSerialPort.devicePattern = \"/dev/tty.usbserial*\"; // osx usb serial\nSerialPort.devices;\t// look if the device is there\n(\n~serial = SerialPort(\n\tSerialPort.devices.first,\n\tbaudrate: 115200,\n\tcrtscts: true\n);\n)\n\n\n// minimal example\n~serial.putAll(\"A120\"); // red component\n~serial.putAll(\"B255\"); // green component\n~serial.putAll(\"C100\"); // blue component\n\n// function example with values between 0..1\na = {|char, val, serial|\n  serial.putAll(char ++ ((val*255).asInt + 1000).asString[1..3]);\n}\n\n// test it\na.(\"A\", 0.1, ~serial)\n\n// complete example\na = {|which, color, serial|\n  // create an empty message\n  var msg = \"\";\n\n  // is there a color defined in the arguments?\n  color = color ? Color.black;\n\n  // convert color into an array\n  color = color.asArray;\n\n  // convert number of used orb into its corresponding ASCII character (determining colors)\n  // convert light value [0..1] into a value between [\"000\" .. \"255\"]\n  // collect al values in the message\n  (65 + #[0, 1, 2] + (which * 3)).collect{|val, i|\n    val.asAscii ++ ((color[i]*255).asInt + 1000).asString[1..3]\n  }.do{|elem|\n    msg = msg ++ elem;\n  };\n\n  // send it to the serial port\n  serial.putAll(msg);\n}",
    "gamepad_example.scd": "// Ins and Outs - Gamepad example\n// This example was made with an Impact Gamepad, but can easily be adapted to work with gamepads of other vendors.\n\n\n// General structure to access a device\n// Look for the devices that are attached:\nGeneralHID.buildDeviceList;\n// Get the list of devices:\nd = GeneralHID.deviceList;\n// Check which devices have been found:\nGeneralHID.postDevices;\n\n// The impact has vendor number 1973, so look for it:\na = GeneralHID.findBy( 1973 );\n// If you have a different gamepad, just look in the list that is posted. The first entry in the arrays that are posted is the index into the list, so if your device shows up as [ 5, device description ], you can do:\na = d[5];\n\n\n// Pick the right device and open it and create an instance of it:\na = GeneralHID.open( a );\n// Get info on the device (double check whether you have the right one):\na.info;\n// if you did not know the vendorID and product yet, you can use\na.info.findArgs;\n// to find out which args we could use to automatically find the gamepad in future sessions:\n\n\n// Start eventloop:\nGeneralHID.startEventLoop\n// Get the capabilities of the device in a readable format:\na.caps;\n// See if data is coming in:\na.debug_( true );\n// Stop it:\na.debug_( false );\n\n// find the joysticks\n\n// on OSX:\na.slots[3][48].debug_(true); // right x\na.slots[3][48].debug_(false); // right x\n\na.slots[3][49].debug_(true); // right y\na.slots[3][49].debug_(false); // right y\n\na.slots[3][50].debug_(true); // left y\na.slots[3][50].debug_(false); // left y\n\na.slots[3][53].debug_(true); // left x\na.slots[3][53].debug_(false); // left x\n\n// on linux:\na.slots[3][0].debug_(true); // left x\na.slots[3][0].debug_(false); // left x\n\na.slots[3][1].debug_(true); // left y\na.slots[3][1].debug_(false); // left y\n\na.slots[3][2].debug_(true); // right x\na.slots[3][2].debug_(false); // right x\n\na.slots[3][5].debug_(true); // right y\na.slots[3][5].debug_(false); // right y\n\n/// We could also use a GUI:\na.makeGui;\n\n// Note the Impact Gamepad has a button in the middle (above the LED), which changes the function of the arrow button on the left from being an alternative to the left joystick axes, or its own two axes.\n\n// Now that we know which slot is which, we can name them:\n\n( // using the OSX mapping\na.add( \\lx, [3,48]);\na.add( \\ly, [3,49]);\na.add( \\rx, [3,50]);\na.add( \\ry, [3,53]);\n// buttons\n(1..8).do{ |it,i| a.add( (i+1).asSymbol, [1,it]) }\n)\n\n( // using the linux mapping\na.add( \\lx, [3,0]);\na.add( \\ly, [3,1]);\na.add( \\rx, [3,2]);\na.add( \\ry, [3,5]);\na.add( \\hatx, [3,16] );\na.add( \\haty, [3,17] );\n// buttons\n(288..299).do{ |it,i| a.add( (i+1).asSymbol, [1,it]) }\n)\n\n\n\n// view the spec:\na.spec.map\n\n// save the spec:\na.spec.save( \"GamepadExample\");\n\n// now we can find it:\nb = a.findSpec;\n\n// so in future session we can reload it with:\na.setSpec( b[0] );\n\n// Now that we have given the slots symbolic names, there is no difference anymore for using the HID device between OSX and Linux.\n\n// The impact gamepad has two joysticks and a whole lot of buttons.\n// In this example we will create a setup, where we can record movements of the joysticks, which are then used as wavetable for a synthesizer.\n\n// on OSX, use the internal server:\ns = Server.internal.boot;\n// otherwise, use the local server (and SwingOSC)\ns = Server.local.boot;\n\n// GUI's\ns.makeGui;\ns.scope( 2 );\n\n(\n// synth to write the waveform to a buffer:\nSynthDef( \\wavewriteb2, { |input=0,buffer=0,dur=5,speed=1,offset=0.5,mul=1,gate=0|\n\tEnvGen.kr( Env.sine, gate, timeScale: dur ) *\n\tBufWr.kr( In.kr( input, 1 ) * mul - offset, buffer, Phasor.kr( gate, speed, 0, BufFrames.kr(buffer)), 0 );\n}).send(s);\n// synth to play back the waveform:\nSynthDef( \\waveplayb, { |buffer=0, speed=0.5, out=0, amp=1, vol = 0.5|\n\tOut.ar( out,\n\t\tvol * amp * BufRd.ar( 1, buffer, LFSaw.ar(BufDur.ir(buffer).reciprocal * speed * 2).range(0, BufFrames.ir(buffer)) )\n\t\t);\n\t}).add;\n)\n\n(\n// create busses for each of the joystick axes:\n[\\rx,\\ry,\\ly,\\lx].do{ |key| a.at( key ).createBus( s ); };\n// create busses for eight of the buttons:\n(1..8).do{ |id| a.at( id.asSymbol ).createBus( s ); };\n)\n\n(\n// assign 4 Buffers for four wavetables:\n~buffers = 4.collect{ Buffer.alloc( s, 4096, 1 ); };\n)\n\n( // create a window to view the buffer contents:\nw = Window.new( \"Gamepad Buffer play\" );\n~bufwins = 4.collect{ |i| CompositeView.new( w, Rect( 0, 100*i, w.bounds.width, 100 ) ) };\nw.front;\n\nTdef( \\updateplot, {\n\tloop {\n\t\t~bufwins.do{ |it| it.children.do{ |jt| jt.remove; } };\n\t\t~buffers.do{ |it,i| it.plot( \"buffer \"++i, parent: ~bufwins[i] ) };\n\t\t1.0.wait;\n\t\t}\n\t});\n)\n\n\n( // start the synths and window update routine:\nTdef( \\updateplot ).play;\n~writers = [ \\lx, \\ly, \\lx, \\ly ].collect{ |it,i|\n\tSynth.new( \\wavewriteb2, [ \\input, a.at(it).bus, \\buffer, ~buffers[i], \\offset, 1, \\mul, 2 ], s ).busMap( \\speed, a.at( (i+1).asSymbol).bus ).busMap( \\gate, a.at( (i+1).asSymbol).bus );\n\t};\n~players = [\\rx, \\rx, \\ry, \\ry ].collect{ |it,i|\n\tSynth.new( \\waveplayb, [ \\buffer, ~buffers[i], \\out, (i/2).floor ], s).busMap( \\amp, a.at( (i+5).asSymbol).bus ).busMap( \\speed, a[it].bus );\n\t};\n)\n\n\n// Buttons 1 to 4 select to which buffer is recorded\n// Buttons 5 to 8 (on the front), select which buffer is played back\n// Left joystick determines recording\n// Right joystick determines playback speed\n\n// change volume:\n~players.do{ |it| it.set( \\vol, 0.5 ) };\n\n\n// clean up:\n\n(\n~writers.do{ |it| it.free };\n~players.do{ |it| it.free };\n\n~buffers.do{ |it| it.free };\n\nTdef( \\updateplot ).stop;\n\n// free all the busses for each of the joystick axes:\na.freeAllBuses;\n\n// Close the device after use:\na.close;\n// stop the eventloop;\nGeneralHID.stopEventLoop\n\n)",
    "wacom_example_linux.scd": "// =========================================\n// Wacom tablet example\n// =========================================\n\n// Note: this example only works on Linux. The OSX Wacom drivers unfortunately do not give you access to the HID layer of the Wacom device. Look at the osx example for how to do the same thing with the GUI utilities.)\n\n// find the Wacom tablet:\nGeneralHID.buildDeviceList;\nd = GeneralHID.deviceList;\nGeneralHID.postDevices;\n// suppose this is the tablet, so open it (mine is a Wacom PenPartner2, so I look for that name in the device list. The first entry in the array that is posted on each line is the index into the deviceList)\nw = GeneralHID.open( d[6] );\n// check whether it was the right one:\nw.info;\n// get which args we could use to automatically find the tablet in future sessions:\nw.info.findArgs;\n// usually the first two are sufficient to get the device (the others are version numbers, or are related to which USB port the device is connected to)\n// So in future sessions we can open the device with:\nw = GeneralHID.open( GeneralHID.findBy( 1386, 100 ) );\n\n// grab it, so we don't fuck up our mouse (linux only):\nw.grab;\n// create a GUI, so we can see whether it works:\nGeneralHIDDeviceGUI.new( w );\n// or:\nw.makeGui;\n\n// we can also use:\nw.debug = true;\nw.debug = false;\n\n// my PenPartner2 seems to have several things which are defined, but do not seem to do anything. Probably the manufacturer uses the same firmware for several devices, but doesn't hook up the same hardware functions to all of them.\n\n// create names for different functions (look at the gui to see which action causes which buttons or sliders to move)\n(\nw.add( \\x, [3,0]);\nw.add( \\y, [3,1]);\nw.add( \\pressure, [3,24]);\nw.add( \\topbutton, [1,331]);\nw.add( \\botbutton, [1,332]);\nw.add( \\inrange, [1,320]);\nw.add( \\touch, [1,330] );\n);\n\n// view the spec:\nw.spec.map\n\n// save the spec:\nw.spec.save( \"WacomExample\");\n\n// now we can find it:\nw.findSpec;\n\n// so in future session we can reload it with:\nw.setSpec( w.findSpec.first );\nw.spec.map\n\ns = Server.local.boot;\n\n// we use q as our holder for synths\nq = ();\n\n// create buses for the defined slots:\n(\nw.createAllBuses( s );\n)\n\n// create actions for two of the \"buttons\"\n(\nq.active = false;\n// when the pen hits the tablet, spawn a synth and map the buses:\nw[\\touch].action_( { |v| \n\tif ( v.value == 1 and: q.active.not, {\n\t\tq.active = true;\n\t\tq.synthi = Synth.new( \\wacotheremin ); \n\t\tq.synthi.map( \\freq, w[\\y].bus );\n\t\tq.synthi.map( \\mod, w[\\x].bus );\n\t\tq.synthi.map( \\amp, w[\\pressure].bus );\n\t\tq.synthi.map( \\room, w[\\x].bus );\n\t\tq.synthi.map( \\damp, w[\\y].bus );\n\t\tq.synthi.map( \\roomset, w[\\topbutton].bus );\n\t\tq.synthi.map( \\dampset, w[\\botbutton].bus );\n\n\t});\n});\n// when the pen leaves the sensitive range, free the synth:\nw[\\inrange].action_( { |v| \n\tif ( v.value == 0 and: q.active, {\n\t\tq.synthi.free;\n\t\tq.active = false;\n\t});\n});\n)\n\n/// and here's the synth:\n\n( // freely derived from the Theremin example:\nSynthDef(\\wacotheremin, { arg freq=0, amp=1, mod = 7, detune = 0, roomset=0, dampset=0, room=0.5, damp=0.2;\n\tvar f, a, z;\n\tf = [4000, 200, 'exponential'].asSpec.map( freq.lag(0.1) )*0.8 + detune;\n\ta = SinOsc.ar(f + (f * SinOsc.ar( [2,20].asSpec.map(mod.lag(0.1)),0,0.02)), mul: amp.lag(0.1));\n\tz = FreeVerb.ar( Mix.ar(a), 0.5, Gate.kr( room.lag(0.1), roomset ), Gate.kr( damp.lag(0.1), dampset ) );\n\tOut.ar(0, z) + Out.ar(1, z)\n}).add;\n)\n\n// the frequency and modulation are modulated with x and y, the pressure controls the amplitude\n// the room and damp of the reverb are only changed when the buttons are pushed.\n\n\n// cleanup\n\nw.freeAllBuses;\nw.close;\n",
    "wacom_example_osx.scd": "// =========================================\n// Wacom tablet example\n// =========================================\n\n(\n// Unfortunately, OS X does allow to use a graphics-tablet with HID.\n// So, here you find the HID example adapted to use a tablet-enabled GUI element (TabletSlider2D)\n\n// The frequency and modulation are modulated with x and y, the pressure controls the amplitude.\n// The room and damp of the reverb are only changed when pen is tilted to a positive amount towards  x resp. y-axises. You may want to adapt this behavior according to your specific tablet.\n\nw = Window.new;\nt = TabletSlider2D(w,Rect(40,40,300,300));\nt.background = Color.white;\nw.front;\n\n// we use q as our holder for synths\nq = ();\nq.active = false;\n\nt.mouseDownAction = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount,absoluteZ,rotation;\n\tif ( q.active.not, {\n\t\tq.active = true;\n\t\tq.synthi = Synth.new( \\wacotheremin ); \n\n\t});\n\tview.action.value(view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount,absoluteZ,rotation)\n};\n\nt.action = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount,absoluteZ,rotation;\n\tq.synthi.set( \\freq, y);\n\tq.synthi.set( \\mod, x );\n\tq.synthi.set( \\amp, pressure );\n\tq.synthi.set( \\room, x );\n\tq.synthi.set( \\damp, y );\n\tq.synthi.set( \\roomset, (tiltx > 0.1).binaryValue );\n\tq.synthi.set( \\dampset, (tilty > 0.1).binaryValue );\n};\n\nt.mouseUpAction = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount,absoluteZ,rotation;\n\tif (q.active, {\n\t\tq.synthi.free;\n\t\tq.active = false;\n\t});\n};\n)\n\n\n/// and here's the synth:\n\n( // freely derived from the Theremin example:\nSynthDef(\\wacotheremin, { arg freq=0, amp=1, mod = 7, detune = 0, roomset=0, dampset=0, room=0.5, damp=0.2;\n\tvar f, a, z;\n\tf = [4000, 200, 'exponential'].asSpec.map( freq.lag(0.1) )*0.8 + detune;\n\ta = SinOsc.ar(f + (f * SinOsc.ar( [2,20].asSpec.map(mod.lag(0.1)),0,0.02)), mul: amp.lag(0.1));\n\tz = FreeVerb.ar( Mix.ar(a), 0.5, Gate.kr( room.lag(0.1), roomset ), Gate.kr( damp.lag(0.1), dampset ) );\n\tOut.ar(0, z) + Out.ar(1, z)\n}).add;\n)\n",
    "Ch5code.scd": "  //Figure 5.1\n1\t\t\t\t\t// the Integer number 1 \n1.234 \t\t\t\t// the floating-point (Float) number 1.234\n$a \t\t\t\t\t// the character (Char) a\n\"hello\"\t\t\t\t// a String (an array of characters) \n\\alpha\t\t\t\t// a Symbol (a unique identifier) \n'alpha 1'\t\t\t\t// another notation for a Symbol\n100@150 \t\t\t\t// a Point defined by coordinates x, y \n[1, \\A, $b] \t\t\t\t// an Array containing 3 elements\n(a: 1, b: 0.2) \t\t\t// an Event \n{ 10.rand }\t\t\t\t// a Function\nString \t\t\t\t// the Class String \nMeta_String \t\t\t// the Class of Class String\n\n\n\f\n//Figure 5.3\n// Boot the default server first:\nServer.default.boot;\n// Then select all lines between the outermost parentheses and run: \n( \t\n{\n\tResonz.ar(GrayNoise.ar,\n\t\tXLine.kr(100, 1000, 10, doneAction: 2), \n\t\tXLine.kr(0.5, 0.01, [4, 7], doneAction: 0)\n\t)\n}.play\n)\n// further examples:\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 3, doneAction: 2)) }.play;\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 0.3, doneAction: 2))}.play;\n\n\n\f\n //Figure 5.4\n((1 + 2).asString).interpret \t\t// = 3\n\"1\" ++ \"2\". interpret\t\t\t// 12: 2 is translated to string by ++\n(\"1\" ++ \"2\").interpret\t\t\t// 12\n(1.asString ++ 2.asString).interpret \t// 12\n\"1+2\". interpret \t\t\t\t// 3\n(1.asString ++ \"+2\"). interpret\t\t// 3\n(1 + 2).interpret\t\t\t\t// error: interpret not understood by Integer 3\n\n\n\n\n\f\n //Figure 5.5\n(\na = 5;\n5 do: { a = a + 10; a.postln };\nPost << \"The value of variable 'a' is now \" << a << \"\\n\";\n)\n\f\n//Figure 5.8\n(\n// A window with a button that posts: \"hello there!\"\nvar window, button;\n// create a GUI window and store it in variable window\nwindow = Window.new(\"OLA!\", Rect(200, 200, 120, 120)); \n// create a button in the window and store it in variable button\nbutton = Button.new(window, Rect(10, 10, 100, 100));\nbutton.states = [[\"'ALLO\"]];\t// set one single label for the button\nbutton.action = { \"hello there!\".postln }; // set the action of the button\nwindow.front;\t\t  \t  // show the window\n)\n \f\n//Figure 5.9\n\n( \n// execute this first to boot the server and load the synth definition\nServer.default.waitForBoot({ \n\tSynthDef(\"ping\", { | freq = 440 |\n\t\tOut.ar(0, \n\t\t\tSinOsc.ar([freq, freq * (4/3)], 0,\n\t\t\t\tEnvGen.kr(Env.perc(0.05, 0.3, 0.1, -4), doneAction: 2)\n\t\t\t)\n\t\t)\n\t}).send(Server.default);\n});\n)\n\n(\n// execute this next to create the sounds\nvar countdown = 100;\nvar note = 50;\nvar increment_func, decrement_func;\nvar action;\nincrement_func = {\n\tnote = note + [2, 5, 7, 12].choose;\n\tif (note > 100) { action = decrement_func };\n};\ndecrement_func = {\n\tnote = note - [1, 2, 5, 7, 12].choose;\n\tif (note < 50) { action = increment_func };\n};\naction = increment_func;\n{\n\tcountdown do: { \n\t\tSynth(\"ping\", [\\freq, note.midicps]);\n\t\taction.value;\n\t\t0.1.wait;\n\t}\n}.fork;\n)\n\n\f\n //Figure 5.11\n// run each line separately: \ncurrentEnvironment;\t// empty if no environment variables have been set\n~alpha = pi;\t\t\t// set env. variable ~alpha to pi\ncurrentEnvironment;\t// see current Environment again: ~alpha is set\n~freq = 800;\t\t\t// set another environment variable\nServer.local.boot;\n{ LFNoise0.ar(~freq, 0.1) }.play; // use an environment variable\n// setting an environment variable to nil is equivalent to removing it: \n~alpha = nil;\ncurrentEnvironment;\t// alpha is no longer set\n\n\f\n //Figure 5.12\n(\n~q = \"TOP\";\t\t\t\t\t\t\t// store \"TOP\" in ~a, top environment\n(a: \"INNER\") use: { // run function in environment with ~a = \"INNER\"\n\tcurrentEnvironment.postln; // show the current environment\n\ttopEnvironment.postln;\t\t// show the top environment (different!)\n\t~a.postln\t\t\t\t// show ~a's value in current environment\n};\t\n~a;\t\t\t\t\t\t// show ~a's value in top environment\n)\n\n\f\n //Figure 5.13\n(\nvar alpha, beta, gamma;\ngamma = alpha;\t// storing variable alpha in gamma only stores nil \nalpha = 10; \t// store 10 in alpha ...\ngamma.postln;\t// but the value of gamma remains unchanged\nalpha = beta;\t// so one cannot use gamma as 'joker'\nbeta = 20;\t\t// to switch between variables alpha and beta.\ngamma.postln;\t// gamma is still nil.\n)\n\n\f\n //Figure 5.15\nServer.default.boot; \t\t// (boot Server before running example)\n(\n// Define a function and call it in different contexts\nvar synth;\t\t\t\t// Synth creating the sound that is changed\nvar freq = 220; \t\t\t// frequency of the sound\nvar change_freq;\t\t\t// function that changes the frequency of the sound\nvar window;\t\t\t// window holding buttons for changing the sound\nvar button1, button2, button3; // buttons changing the sound\n\n// Create a synth that plays the sound to be controlled:\nsynth = { | freq = 220 | LFTri.ar([freq, freq * 2.01], 0, 0.1) }.play;\n// Create frequency changing function and store it in variable change_freq\nchange_freq = {\t\t\t\t\t\t// start of function definition\n\t\tfreq = freq * [0.9, 0.9.reciprocal].choose; // change freq value\n\t\tsynth.set(\\freq, freq);\t\t\t// set synth's frequency to new value\n};\t\t\t\t\t\t\t\t// end of function definition\n\n// Create 3 buttons that call the example function in various ways\nwindow = Window(\"Buttons Archaic\", Rect(400, 400, 340, 120));\n//  ------------------------- Example 1 -------------------------\nbutton1 = Button(window, Rect(10, 10, 100, 100));\nbutton1.states = [[\"I\"]]; // set the label of button1\n// button1 calls the function each time that it is pressed \nbutton1.action = change_freq;\t// make button1 change freq once\n//  ------------------------- Example 2 -------------------------\nbutton2 = Button(window, Rect(120, 10, 100, 100));\nbutton2.states = [[\"III\"]];\n// Button2 creates a routine that calls the example function 3 times\nbutton2.action = { \t\t\t// make button2 change freq 3 times\n\t{ 3 do: { change_freq.value; 0.4.wait } }.fork; // play as routine\n};\n//  ------------------------- Example 3 -------------------------\nbutton3 = Button(window, Rect(230, 10, 100, 100));\nbutton3.states = [[\"VIII\"]];\nbutton3.action = { \t\t\t// like example 2, but 8 times\n\t{ 8 do: { change_freq.value; 0.1.wait } }.fork; // play as routine\n};\n// use large size font for all buttons:\n[button1, button2, button3] do: _.font_(Font(\"Times\", 32));\n// stop the sound when the window closes: \nwindow.onClose = { synth.free };\nwindow.front; // show the window\n)\n\n\n\n\f\n //Figure 5.18\n(\n// a function that calculates the square of the mean of two numbers\nvar sq_mean;\nsq_mean = { arg a, b; \t// arguments a, b defined in arg statement form\n\t(a + b / 2).squared;\n};\n// calculate the square of the mean of 3 and 1:\nsq_mean.value(3, 1);\n)\n\n\f\n //Figure 5.19\n(\n// a function that calculates the square of the mean of any numbers\nvar sq_mean_all;\nsq_mean_all = { | ... numbers | // using ellipsis and | | argument form\n\t(numbers.sum / numbers.size).squared;\n};\n// calculate the square of the mean of [1, 3, 5, -7]:\nsq_mean_all.(1, 3, 5, -7); // short form: omit message 'value'\n)\n\n\f\n //Figure 5.20\n(\nvar w_func;\nw_func = { arg message = \"warning!\", bounds = Rect(200, 500, 500, 100);\n\tvar window;\n\twindow = Window(\"message window\", bounds).front;\n\tTextView(window, window.view.bounds.insetBy(10, 10))\n\t\t.string = message;\t\n};\n // provide text, use default bounds\nw_func.(String.new.addAll(Array.new.addAll(\" Major news! \").pyramid(7)));\n)\n\n\f\n //Figure 5.21\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot!\"], [\"quit!\"]];\nbutton.action = { |me| Server.default perform: [\\quit, \\boot][me.value] };\nwindow.front;\n)\n\n\f\n //Figure 5.22\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot\"], [\"quit\"]];\nbutton.action = { | me | \n\t[{ \"QUITTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.quit;\n\t},{ \"BOOTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.boot;\n\t}][me.value].value;\n};\nwindow.front;\n)\n\n\n\f\n //Figure 5.23\nServer.default.boot // boot default server before running example\n(\nvar buffer;\nbuffer = Buffer.read(path: \"sounds/a11wlk01.wav\",\n\taction: { | buffer |\n\t\tformat(\"loaded % at: %\", buffer, Main.elapsedTime).postln;\n\t});\nformat(\"Reached this after 'Buffer.read' at: %\", Main.elapsedTime).postln;\nbuffer;\n)\n\n\f\n //Figure 5.24\nServer.default.boot;  // do this first\n(\t\t\t\t\t\t// then the rest of the program\nvar window, routine;\nwindow = Window(\"close me to stop\").front;\nwindow.onClose = { routine.stop };\nroutine = { \n\tloop {\n\t\t(degree: -10 + 30.xrand, dur: 0.05, amp: 0.1.rand).play;\n\t\t0.05.rand.wait;\n\t}\n}.fork;\n)\n\n\f\n //Figure 5.25\n_.isPrime ! 10\n_.squared ! 10\n_@_.(30, 40) // equivalent to: { | a, b | Point(a, b) }.value(30, 40)\nArray.rand(12, 0, 1000).clump(4) collect: Rect(*_)\n(1..8).collect([\\a, \\b, _]);\n(a: _, b: _, c: _, d: _, e: _).(*Array.rand(5, 0, 100));\n\n\f\n //Figure 5.26\n(\nvar iterative_factorial;\niterative_factorial = { | n |\n\tvar factorial = 1;\t// initialize factorial as factorial of 1\n\t// calculate factorial n times, updating its value each time\n\tn do: { | i | factorial = factorial * (i + 1) };\n\tfactorial;\t// return the final value of factorial;\n};\niterative_factorial.(10).postln;\t// 10 factorial: 3628800\n)\n\n\n\f\n//Figure 5.27\n// Define the factorial function and store it in variable f:\nf = { | x | if ( x > 1) { x * thisFunction.value(x - 1) } { x } };\n f.value(10);\t\t\t// 10 factorial: 3628800\n\n\f\n //Figure 5.28\n(\n/* a function that recursively prints all folders and files\n   found in a path and its subfolders */\n{ | path |\n\t// store function here for use inside the if's {}:\n\tvar thisFunc = thisFunction;\n\tformat(\"====== now exploring: %\", path).postln;\n\t// for all items in the path:\n\tpath.pathMatch do: { | p | \n\t\t// if the item is a folder, run this function on its contents\n\t\t// otherwise print the file found\n\t\tif (p.last == $/) { thisFunc.(p ++ \"*\") }{ p.postln }\n\t}\n}.(\"*\") // run function on home path of SuperCollider\n)\n\n\f\n//Figure 5.29\n(\n// a function that creates a function that counts to any number\nvar counter_maker;\nvar window, button1, button2; // gui for testing the function\n\n// the function that makes the counting function\ncounter_maker = { | max_count |\n\t// current_count is used by the function created below\n\t// to store the number of times that it has run\n\tvar current_count = 0;  \n\t{\t// start of definition of the counting function\n\t\tif (current_count == max_count) {\n\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\tmax_count;\t\t// return max count for eventual use\n\t\t}{\n\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\tcurrent_count\t// return current count for eventual use\n\t\t}\n\t}\t// end of definition of the counting function \n};\n\n//  ----- Test application for the counter_maker function ----- \n// window displaying 2 buttons counting to different numbers\nwindow = Window(\"Counters\", Rect(400, 400, 200, 80));\n// make a button for triggering the counting: \nbutton1 = Button(window, Rect(10, 10, 180, 20));\nbutton1.states = [[\"counting to 10\"]];\t// labels for button1\n// make a function that counts to 10 and store it as action in button1\nbutton1.action = counter_maker.(10);\nbutton2 = Button(window, Rect(10, 40, 180, 20));\nbutton2.states = [[\"counting to 5\"]];\t// labels for button2\n// make a function that counts to 5 and store it as action in button2\nbutton2.action = counter_maker.(5);\nwindow.front;\t\t\t// show the window\n)\n\n\f\n//Figure 5.31\n(\nvar counter_maker;\t\t// creator of counters\nvar make_counters_gui;\t// function making counters + a gui\n/* a function that creates an event that counts to any number, \n   and resets: */ \ncounter_maker = { | max_count |\n\tvar current_count = 0; \n\t(\t// the counter object is an event with 3 functions: \n\t\tcount1: // function 1: increment count (stored as count1)\n\t\t{\t// start of definition of the counting function\n\t\t\tif (current_count == max_count) {\n\t\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\t}{\n\t\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\t}\n\t\t},\t// end of definition of the counting function\n\t\treset_count: { // function 2: reset count (stored as reset_count)\n\t\t\tformat(\"resetting % counter\", max_count).postln;\n\t\t\tcurrent_count = 0\n\t\t},\n\t\tmax_count: { max_count } // function 3: return value of max_count\n\t)\n};\n// Function that makes several counters and a GUI to control them\nmake_counters_gui = { | ... counts |\n\tvar window, counter;\n\twindow = Window(\"Counters\", \n\t\t\tRect(400, 400, 200, 50 * counts.size + 10));\n\t// enable automatic placement of new items in window: \n\twindow.view.decorator = FlowLayout(window.view.bounds, 5@5, 5@5);\n\tcounts collect: counter_maker.(_) do: { | counter |  \n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Counting to: \" ++ counter.max_count.asString]])\n\t\t\t.action = { counter.count1 };\n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Reset\"]])\n\t\t\t.action = { counter.reset_count };\n\t};\n\twindow.front;\n};\nmake_counters_gui.(5, 10, 27); // example use of the GUI test function\n)\n\n\n\n\f\n//Figure 5.32\nServer.default.boot;\t// boot the server first;\n(\nvar degrees, window, button;\nwindow = Window(\"melodies?\", Rect(400, 400, 200, 200));\nbutton = Button(window, window.view.bounds.insetBy(10, 10));\nbutton.states = [[\"click me to add a note\"]];\nbutton.action = { \n\tdegrees = degrees add: 0.rrand(15);\n\tPbind(\\degree, Pseq(degrees), \\dur, Prand([0.1, 0.2, 0.4], inf)).play;\n};\nwindow.front;\n)\n\n\f\n //Figure 5.34\n1.class \t\t// the class of Integer 1: Integer\n1.class.class \t// the Class of the Class of Integer 1: Meta_Integer\n// the Class of the Class of the Class of Integer 1: \n1.class.class.class  \t\t\t\t\t// Class\n// the Class of the Class of the Class of the Class of Integer 1\n1.class.class.class.class\t\t\t\t// Meta_Class\n// the Class of the Class of the Class of the Class of the Class of 1\n1.class.class.class.class.class \t\t// Class \nClass.class\t\t\t\t// the Class of Class is Meta_Class\nMeta_Class.class\t\t// the Class of Meta_Class is Class\n\n\n\f\n //Figure 5.36\nCounter { \n\t// variables: maximum count, current count\n\tvar <>max_count, <>current_count = 1;\n\t// class method for creating a new instance\n\t*new { | max_count = 10 |\n\t\t^super.new.max_count_(max_count)\n\t}\n\t// if maximum count not reached, increment count by 1\n\tcount1 {\n\t\tif (current_count >= max_count) {\n\t\t\tthis.changed(\\max_reached)\n\t\t}{\n\t\t\tcurrent_count = current_count + 1;\n\t\t\tthis.changed(\\count, current_count);\n\t\t}\n\t}\n\t// reset count\n\treset {\n\t\tcurrent_count = 1;\n\t\tthis.changed(\\reset);\n\t}\n}\n\n\f\n //Figure 5.37\nServer.default.boot;\n(\nSynthDef(\"ping\", { | freq = 440 | \n\tOut.ar(0, \n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).send(Server.default);\n\nSynthDef(\"wham\", {\n\tOut.ar(0, BrownNoise.ar(\n\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).send(Server.default); \n)\n\n\f\n //Figure 5.38\n(\n~sound_adapter =  { | counter, what, count |\n\tswitch (what, \n\t\t\\reset, { Synth(\"wham\"); },\n\t\t\\max_reached, { counter.reset },\n\t\t\\count, { Synth(\"ping\", \n\t\t\t[\\freq, count.postln * 10 + counter.max_count * 20]\n\t\t\t)\n\t\t}\n\t)\n};\n)\n //Figure 5.39\n(\n~make_display = { | counter |\n\tvar window, label, adapter, stagger;\n\twindow = Window(\n\t\t\"counting to \" ++ counter.max_count.asString, \n\t\tRect(stagger = UniqueID.next % 20 * 20 + 400, stagger, 200, 50)\n\t);\n\tlabel = StaticText(window, window.view.bounds.insetBy(10, 10));\n\tadapter = { | counter, what, count |\n\t\t\t{ label.string = counter.current_count.asString }.defer\n\t};\n\tcounter addDependant: adapter;\n\t/* remove the adapter when window closes to prevent error in \n\t   updating non-existent views: */\n\twindow.onClose = { counter removeDependant: adapter };\n\twindow.front\n};\n)\n\n\n\n\n\n\n\n\n\n\n",
    "Ch6code.scd": "Figure 6.1.  Example of a SynthDef\nSynthDef(\t\t\t\t\t\n\t\"sine\", \t\t\t\t// name of SynthDef\t\n\t{\t\t\t\t// function begins with a brace\n\t arg gate = 1, out = 0, \t\t// arguments serve as Control declarations\n freq = 400, amp = 0.4,\n pan = 0, ar = 1, dr = 1;\n\n\tvar audio;\t\t\t\n\taudio = SinOsc.ar(freq, 0, amp);\t\t// start with a SinOsc\n\taudio = audio * Linen.kr(gate, ar, 1, dr, 2);\t// apply an envelope\n\taudio = Pan2.ar(audio, pan);\t\t\t// stereo pan, \n\tOffsetOut.ar(out,audio);\t\t\t// to bus out and out+1 \n\t}\n).add;\t\t\t\t// make and store a SynthDesc and SynthDef\n\n\fFigure 6.2. Example of a key/value Array and a note Event=\na = [ \n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n];\n\ne = (\n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n);\ne.play;\t\t\t\t\t// play the note\n\f\nFigure  6.3. The OSC commands created by the note event\ne.asOSC.do{ | osc | osc.postcs };\n\n// the result that would be posted:\t\t\n//  [ 0.0, ['s_new', 'sine', 1000, 0, 1, 'out', 0, 'freq', 400.0, 'amp', 0.1, 'pan', 0, 'ar', 2, 'dr', 4] ]\n//  [ 2.0, [ 'n_set', 1000, 'gate', 0 ] ] \n\n\n\n\fFigure 6.4. Two ways of writing the same Event Pattern\n\t1. Pbind( *[ \n\t\tdur:\t0.2,\nfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t] );\n\n\t2. Pbind( \n\t\t\\dur, 0.2,\n\t\t\\freq, \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t);\n\n\fFigure 6.5. A more elaborate Event Pattern\np = Pbind(*[ \n\t\tinstrument:\t\\default,\n\t\tdetune:\t\t[0,1,3],\n\t\tfreq: \t\tPseq( (1..11) * 100,  4 * 5 * 7),\n\t\tdb:\t\tPseq([-20, -40, -30, -40], inf),\n\t\tpan:\t\tPseq([-1,0,1,0], inf),\n\t\tdur:\t\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8], inf),\n\t\tlegato:\t\tPseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n// render 40 seconds of the pattern in the file named \"sf.aif\"\t\n\tp.render(\"sounds/sf.aif\", 40)\t\n// now play the pattern in real-time\n\tp.play;\t\t\t\t\t\t\t\t\t\n\fFigure 6.6.  Using Event types\n(\n\t(type: \t\\group, \t\nid: 2\n).play;\t\t\t\t\t// create a group with nodeID 2\n\n\t(\ttype:\t\t\\note, \t\t// play note\t\t\n\t \tsustain:\t100, \t\t// lasting 100 seconds\t\t\t\t\n\t \tgroup: \t\t2\t\t// in group 2\n\n\t ).play;\t\n\t \t\t\t\t\t\t\t\t\t\t\n)\n(\n\t(type: \t\\off, \tid: 2).play;\t\t// release all notes in the group\n\t(type:\t \\kill,\tid: 2,  lag: 3).play;\t// and free the group  3 seconds later\t\n)\n\f\nFigure 6.7. Chord events\n// 2nd inversion - e loudest\n( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -20, -10] ).play\t\t\t\n// 2nd inversion - c loudest\n ( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -10, -20] ).play\t\n// note \"fattened\" by three detuned copies\n ( degree: 0,\t\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// each detune is assigned to a different pitch, fat free.\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// detune rotates through each note in the chord\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,0,0,3,3,3,5,5,5] ).play \t\n\n\fFigure 6.8.  Interdependent key values in a Pattern\n\tPbind(*[\n\t\tstretch:\t\tPseg([0,0.1,0.2,1],8).linexp(0,1, 1,0.125),\n\t\tmidinote: \t\t100.cpsmidi,\n\t\tharmonic:\t\tPwhite(1, 16),\n\t\tlegato:\t\t\tPkey(\\stretch) * Pkey(\\harmonic)/2 ,\n\t\tdb:\t\t\t-10 - Pkey(\\harmonic),\n\t\tdetune:\t\t\tPwhite(0.0,3.0),\n\t\tdur:\t\t\t0.2,\n\t]).play\n\n\fFigure 6.9. Chaining Event Patterns\n\ta = Pbind(*[\n\t\tscale: \tPn( Pstep([[0,2,4,5,7,9,11], [0,1,3,5,6,8,11] ], 5 ) ),\n\t\tdb:\tPn(Pseg([-20, -30, -25, -30], 0.4))\n\t]);\n\tb = Pbind(*[ \ndegree: Pbrown(0, 6, 1), \nmtranspose: Prand([\\rest, Pseq([0], 5.rand)],inf), \ndur: 0.2, \noctave: 6\n]);\n\tc = Pbind(*[ \ndegree: [0,2,4],  \nmtranspose: Pbrown(0, 6, 1), \ndur: 0.4, \ndb: -35\n]);\n\td = Pchain(Ppar([b, c]),a);\nd.play;\n\n\fFigure 6.10. Using Proutine to define and play patterns on the fly\n\tProutine({| ev |\n\t\tvar pat, refPat;\n\n\t\trefPat = Pbind(*[dur: 0.2, note: Pseq([0,0, 0, 7,0, 7])]);\n\n\t\tloop {\n\t\t\tev = refPat.embedInStream(ev);\n\n\t\t\tpat = Pbind(*[\n\t\t\t\tdur: [0.2, 0.4].choose,\n\t\t\t\tnote: Pseq(Array.fill(5, { 10.rand }), 3.rand )\n\t\t\t]);\t\nev = pat.embedInStream(ev);\n\t\t}\n\t\n}).play\n\n\n\n\fFigure 6.11.  Using Proutine to define value and event patterns\n~patA = Pbind(*[\n\tdur:\t0.2,\n\tdegree: Proutine({ | ev |\n\t\tvar noteArray  = (0..5);\n\t\tloop {\n\t\t\tev = Pseq(noteArray ).embedInStream(ev);\n\t\t\tnoteArray[6.rand] = 7.rand;\n\t\t}\t\t\n\t})\n]);\n\n\n~patB = Proutine({ | ev |\n\tvar pat, pats= [\n\t \tPbind(*[ degree: Pseq([  0, 7]), dur: 0.2   ]),\n\t \tPbind(*[ degree: Pseq([11, 7]), dur: 0.2 ]),\n\t\tPbind(*[ degree: Pseq([16, 7]), dur: 0.2 ]).\n\t\t(type: \\rest, delta: 1)\n\t];\n\t\t\t\n\tloop {\n\t\tpat = pats.choose;\n\t\tev = pat.embedInStream(ev);\n\t}\n});\n\nPchain(\n\tPbind(*[\n\t\tdb: \tPn(Pstep([-15, -25,-25, -20, -30, -25], 0.2) )\n\t\t\t+ Pseg([-30, -5,-10, -40], 12)\n\t]), \n\tPtpar([\n\t\t0, ~patA, \n\t\t0,  ~patA, \n\t\t12,  ~patB\n\t]) \n).play;\n\n\fFigure 6.12.  Rendering and playing a pattern\n\t~pattern = Pbind(*[ \n\t\tinstrument:\t\"default\",\n\t\tfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100], 5),\n\t\tdb:\tPseq([-10, -30, -20, -30], inf),\n\t\tdur:\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8],inf),\n\t\tlegato: Pseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n\n\t~score = ~pattern.asScore(24 * 11/7);\n\t~score.render(\"recordings/test.aif\");\n\tSoundFile(\"recordings/test.aif\").play;\n\fFigure 6.13. Soundfile granulation with a Pattern \nSynthDef(\"playbuf\", { | out=0, bufnum = 0, rate = 1, \nstartPos = 0, amp = 0.1, sustain = 1, \npan = 0, gate = 1|\n\tvar audio, env;\n\trate = rate * BufRateScale.kr(bufnum);\n\tstartPos = startPos * BufFrames.kr(bufnum);\n\tenv = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: 2);\n\taudio = PlayBuf.ar(1, bufnum, rate, 1, startPos, 0);\n\taudio = env * audio;\n\taudio = Pan2.ar(audio, pan, amp);\n\tOffsetOut.ar(out, audio);\n}).add;\n\t\t\n\tPseq([\n\t\t(\ttype:\t\t\\load,\n\t\t\tfilename:\t\"sounds/a11wlk01.wav\",\n\t\t\tbufnum:\t1,\n\t\t\tdelta:\t\t0\n\t\t),\n\t\t\n\t\tPbind(*[\n\t\t\tinstrument:\t\"playbuf\",\n\t\t\ttype:\t\t\\on,\n\t\t\tid:\t\t-1,\n\t\t\tdur:\t\t Pseg([0,1],21).linexp(0,1,0.01,2),\n\t\t\tlegato:\t\t4,\n\t\t\tstartPos:\tPn(Pseg([0,1], 10)),\n\t\t\tbufnum:\t1,\t\t\n\t\t]),\n\t\t(\ttype:\t\t\\free, \n\t\t\tbufnum: \t1\n\t\t)\n\t]).play(quant: 0) \n// the result: [ ( 'midinote': 60 ), ( 'midinote': 64 ), ( 'midinote': 67 ) ]\n\fFigure 6.14.  Yield versus EmbedInStream\n\tr = Routine{ \n\t\tPseq([1,2,3]).yield; \n\t\tPseq([1,2,3]).embedInStream;\n\t\t123445.embedInStream; \n\t\t123445.embedInStream; \n\t};\n\n\t[next(r), next(r), next(r), next(r), next(r), next(r)];\n\t// the result: [ a Pseq, 1, 2, 3, 123445, 123445, nil]\n\n\fFigure 6.15. The definition of the stream created by Pseq.\n\tRoutine({\n\t\trepeats.value.do({\n\t\t\tlist.size.do({ arg i;\n\t\t\t\titem = list.wrapAt(i + offsetValue);\n\t\t\t\tinval = item.embedInStream(inval);\n\t\t\t});\n\t\t});\n\t});\n\n \fFigure 6.16.  The definition of Event\u00d5s play method.\n\tplay {\n\t\tif (parent.isNil) { parent = defaultParentEvent };\n\t\tthis.use { ~play.value };\n\t}\n\n\fFigure 6.17. Definition of the key \\play in the default event\n{\n\tvar tempo, server;\n\t\n\t~finish.value;\t\t\t\t\t\t// user callback \n\tserver = ~server ?? { Server.default };\t \n\ttempo = ~tempo;\t\t\t\t\t// assigning to a variable\n\t\t\t\t\t\t\t\t\t// saves repeated look ups\n\tif (tempo.notNil) {\t\t\t\t\t// if not nil, change tempo of\n\t\tthisThread.clock.tempo = tempo;\t// the clock playing the pattern\n\t};\n\t~eventTypes[~type].value(server);\t\t// select play function from ~type\n}\n\n\fFigure 6.18.  Implementation of the event type \\bus.\n\t{ |server|\n\t\tvar lag, array;\n\t\tlag = ~lag + server.latency;\n\t\tarray = ~array.asArray;\n\t\tserver.sendBundle(lag, \n\t\t\t[\\c_setn, ~out.asUGenInput, array.size] ++ array);\n\t}\t\n\n\n",
    "README.scd": "\n/*\nThe methods asScore, render, and asOSC do not work in SuperCollider 3.4.\nEvaluating the following code corrects the problem.  \nThis patch is incorporated into SuperCollider 3.4.2\n\n*/\n(\nEvent.default.parent[\\eventTypes][\\note] =\u00ca\u00ca#{|server|\n\tvar freqs, lag, strum, sustain;\n\tvar bndl, addAction, sendGate, ids;\n\tvar msgFunc, instrumentName, offset, strumOffset;\n\t\n\t// var schedBundleArray;\n\n\tfreqs = ~detunedFreq.value;\n\tif (freqs.isKindOf(Symbol).not) {\t\n\t\t\n\t\t// msgFunc gets the synth's control values from the Event\n\t\tmsgFunc = ~getMsgFunc.valueEnvir;\n\t\tinstrumentName = ~synthDefName.valueEnvir;\n\t\t\t\n\t\t// determine how to send those commands\n\t\t// sendGate == false turns off releases\n\t\t\n\t\tsendGate = ~sendGate ? ~hasGate;\n\t\t\t\t\t\n\t\t// update values in the Event that may be determined by functions\n\t\t\n\t\t~freq = freqs;\n\t\t~amp = ~amp.value;\n\t\t~sustain = sustain = ~sustain.value;\n\t\tlag = ~lag;\n\t\toffset = ~timingOffset;\n\t\tstrum = ~strum;\n\t\t~server = server;\n\t\t~isPlaying = true;\n\t\taddAction = Node.actionNumberFor(~addAction);\n\t\n\t\t// compute the control values and generate OSC commands\n\t\tbndl = msgFunc.valueEnvir;\n\t\tbndl = [\\s_new, instrumentName, ids, addAction, ~group] ++ bndl;\n\t\t\n\t\t\n\t\tif(strum == 0 and: { (sendGate and: { sustain.isArray })\u00ca\n\t\t\tor: { offset.isArray } or: { lag.isArray } }) {\u00ca\n\t\t\t\tbndl = flopTogether(\n\t\t\t\t\t\t\tbndl,\n\t\t\t\t\t\t\t[sustain, lag, offset]\n\t\t\t\t);\n\t\t\t\t#sustain, lag, offset = bndl[1].flop;\n\t\t\t\tbndl = bndl[0];\n\t\t} {\u00ca\n\t\t\t\tbndl = bndl.flop\u00ca\n\t\t};\n\t\t\n\t\t// produce a node id for each synth\n\t\t\n\t\t~id = ids = Array.fill(bndl.size, { server.nextNodeID });\n\t\tbndl = bndl.collect { | msg, i |\u00ca\n\t\t\t\tmsg[2] = ids[i];\u00ca\n\t\t\t\tmsg.asOSCArgArray\n\t\t};\n\t\n\t\t// schedule when the bundles are sent\n\t\tif (strum == 0) {\n\t\t\t~schedBundleArray.(lag, offset, server, bndl, ~latency);\n\t\t\tif (sendGate) {\n\t\t\t\t~schedBundleArray.(\n\t\t\t\t\tlag,\n\t\t\t\t\tsustain + offset,\n\t\t\t\t\tserver,\n\t\t\t\t\t[\\n_set, ids, \\gate, 0].flop,\u00ca\n\t\t\t\t\t~latency\n\t\t\t\t);\n\t\t\t}\n\t\t} {\n\t\t\t\n\t\t\tif (strum < 0) { bndl = bndl.reverse };\n\t\t\tstrumOffset = offset + Array.series(bndl.size, 0, strum.abs);\n\t\t\t~schedBundleArray.(\n\t\t\t\tlag, strumOffset, server, bndl, ~latency\n\t\t\t);\n\t\t\tif (sendGate) {\n\t\t\t\tif (~strumEndsTogether) {\n\t\t\t\t\t\tstrumOffset = sustain + offset\n\t\t\t\t} {\n\t\t\t\t\t\tstrumOffset = sustain + strumOffset\n\t\t\t\t};\n\t\t\t\t~schedBundleArray.(\n\t\t\t\t\tlag, strumOffset, server,\n\t\t\t\t\t[\\n_set, ids, \\gate, 0].flop,\u00ca\n\t\t\t\t\t~latency\n\t\t\t\t);\n\t\t\t}\n\t\t}\t\n\t}\n};\n)",
    "Ch7code.scd": "\n// in the following examples, all code that needs to be evaluated as one block is set in parentheses\n// any such part can be evaluated in any order, e.g. starting from the middle or the end,\n// and it may usually be rewritten at runtime.\n\n\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////// 1 Changing state   ////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n// Figure 7.1: A modulo algorithm that operates over states of variables\n(\nTask {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(note: x.postln, dur: 0.125).play;\n\t\t0.125.wait;\n\t}\n}.play\n);\t\t// creates a loop of values\n\n// change x and y\nx = 5;\t// new initial value\ny = 4;\t// new multiplication factor\n\n\n\n// Figure 7.2: Synthesis graph\n\n(\n{\n\tx = SinOsc.kr(4); \n\ty = SinOsc.kr(13);\n\tSinOsc.ar(x * y % 0.4 * 500 + 600) * 0.2\n}.play;\n)\n\n// change x and y?\nx = SinOsc.kr(4); // no effect.\ny = SinOsc.kr(4); // no effect either.\n\n\n// Figure 7.3: Dynamic synthesis graph\n\np = ProxySpace.push;\n~x = { SinOsc.kr(4) }; \n~y = { SinOsc.kr(13) };\n~z = { SinOsc.ar(~x * ~y % 0.4 * 500 + 600) * 0.2 };\n~z.play;\n\n\t\n// now ~x and ~y can be replaced\n~x = { SinOsc.kr(0.4) }; \n~y = { SinOsc.kr(1.3) }; \n\np.clear(2).pop; // release environment (2 sec fadeout)\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n///////////////////  3 ProxySpace, Ndef, and NodeProxy  /////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n// Figure 7.4: Refactoring a synthesis graph at runtime\n\np = ProxySpace.push;\t// if needed\n\n~a = { Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2) };\n(\n~b = {\n\tvar c, d;\n\tc = Dust.ar(20 ! 2);\n\td = Decay2.ar(c, 0.01, 0.02, SinOsc.ar(11300));\n\td + BPF.ar(c * 5, ~a.ar * 3000 + 1000, 0.1)\n}\n);\n\n~b.play;\n\n// the refactored code from above\n\n(\n~a = { \n\tvar a;\n\ta =  Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2);\n\tBPF.ar(~c.ar * 5, a * 3000 + 1000, 0.1) \n}\n);\n~c = { Dust.ar(20 ! 2) };\n~d = { Decay2.ar(~c.ar, 0.01, 0.02, SinOsc.ar(11300)) };\n~b = ~a + ~d;\n\n~b.play;\n\n\n\n// Figure 7.6: A dynamic graph of a chaotic linear congruence. \n// self reference (~x) constructs a loop at control rate \n\n~out.play;\n~x = 0.2; ~a = 1.1; ~c = 0.13;\n~x = (~a * ~x) + ~c % 1.0;  // leaving out the .kr message assumes a control rate ugen.\n\n~out = { Pan2.ar(SinOsc.ar(~x * 4000 + 200) * 0.1, ~x) };\n\n\n\n// Figure 7.7: Creating a proxy object explicitly and changing its source\nn = NodeProxy.new;\nx = { SinOsc.ar(n.kr * 200 + 300) * 0.1 }.play;\nn.source = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\nn.clear; x.free;\n\n// Figure 7.8: Unified creation and access syntax with Ndef\n\nNdef(\\out, { SinOsc.ar(Ndef.kr(\\x) * 200 + 300) * 0.1 }).play;\nNdef(\\x, { LFPulse.kr([1.3, 2.1, 3.2]).sum });\nNdef.clear;\n\n// Figure 7.9: Unified creation and access syntax within an environment\np = ProxySpace.push; // if needed\n~out = { SinOsc.ar(~x.kr * 200 + 300) * 0.1 }\n~out.play;\n~x = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\np.clear.pop;\n\n\n\n// Figure 7.10: Initialisation of node proxies in the proxy space\n\np.clear; // neutralize space, free all buses and synths\np.push; // if needed\n~a.ar(3); // 3 channels, audio rate\n~b.kr(8); // 8 channels, control rate\n~c.play; // playing an uninitialized proxy assumes (per default) 2 channels, audio rate\n~d = { LFNoise0.kr([1, 1, 1, 1]) }; // 4 channels, control rate\n\n\n\n\n// Figure 7.11: Parameter mapping and setting\n\n~out.play; ~out.fadeTime = 3;\n(\n// name with a_ represents audio rate argument\n~out = { |freq=440, mod=0.4, detune=0.1, a_in = #[1,1]|\n\tfreq = freq * ([0, detune] + 1);\n\tLFTri.ar(LFTri.ar(mod * freq).range(freq * mod, freq)) * a_in * 0.2\n}\n);\n\n~mod2 = { LFNoise1.kr(1).range(0, 1) };\n~mod1 =  { LFPulse.kr(~mod2.kr * 30 + 1, 0, 0.3) };\n~freq1 = { ~mod1.kr * 13100 + 100 };\n~freq2 = { LFTri.kr(30) * 200 + 300 };\n~audio1 = { BrownNoise.ar(LFClipNoise.kr(10.dup), 1) };\n~audio2 = { SinOsc.ar(LFNoise2.kr(1.dup).exprange(4, 1000)) };\n\n~out.map(\\freq, ~freq2, \\mod, ~mod1);\n~out.set(\\detune, 0.01);\n~out.map(\\freq, ~freq1, \\mod, ~mod1);\n~out.xmap(\\freq, ~freq1, \\mod, ~mod2); // xmap crossfades over fade time to new value.\n~out.xmap(\\freq, ~freq2, \\mod, ~mod1, \\a_in, ~audio2);\n~out.map(\\a_in, ~audio1);\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////  4 Structured waiting and rewriting: TaskProxy, Tdef  ////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n\n// Figure 7.12: Rewriting a synth def and a task def while running\n// this synthdef is used in the subsequent figures\n(\nSynthDef(\\wave, { |out, freq=440, amp=0.1, sustain=0.1, mod=0.2|\n\tOffsetOut.ar(out,\n\t\tEnvGen.ar(Env.perc(ExpRand(0.001, 0.05), sustain, amp), doneAction: 2)\n\t\t*\n\t\tSinOsc.ar(freq, SinOsc.ar(sustain.reciprocal * 8, [0, Rand(0, pi)], mod))\n\t)\n}).add\n);\n(\nTdef(\\x, {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(instrument: \\wave, note: x.postln, sustain: 0.5, octave: 6).play;\n\t\t0.125.wait;\n\t}\n}).play\n);\n\n\n// Figure 7.13: Embed and fork of different tasks\n\n(\n\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 1500).play; 0.03.wait } });\nTdef(\\b, { [1, 5, 1, 2, 8, 4, 12].do { |x| (instrument: \\wave, note: x + 8).play; 0.1.wait } });\nTdef(\\c, { \"c is just a waiting message\".postln; 2.wait; });\n\n\nTdef(\\x, {\n\tloop {\n\t\tTdef(\\a).embed; // play in sequence\n\t\t1.wait;\n\t\tTdef(\\b).embed;\n\t\t2.wait;\n\t\tTdef(\\a).fork; // play in parallel\n\t\tTdef(\\b).fork;\n\t\tTdef(\\c).embed;\n\t}\n}).play\n);\n\n// rewrite with infinite loop\nTdef(\\a, { inf.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } }); \n// rewrite with finite loop\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } });\n\n\n// Figure 7.14: Passing an environment into a task proxy when embedding\n(\nTdef(\\a, { |in|\n\tin.at(\\n).do { |i| \n\t\tin = (instrument: \\wave, detune: 5.rand2).putAll(in);\n\t\tin.postln.play; \n\t\tin.delta.wait;\n\t} \n})\n);\n\n(\nTdef(\\x, { |inevent|\n\tloop {\n\t\tTdef(\\a).embed((note: [15, 17], dur: 0.01, n: 13));\n\t\t1.wait;\n\t\tTdef(\\a).embed((note: 9, dur: 0.4, n: 4));\n\t\t1.wait;\n\t}\n}).play;\n)\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////   5 Empty Patterns    /////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n// Figure 7.15: A pattern proxy as an entry point into a stream\n\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3], inf));\n(\nTask {\n\tvar stream = Pdefn(\\x).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next; \n\t\t(instrument: \\wave, note: val).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\nPdefn(\\x, Pseq([0, 2, 0, 8, 6, 5, 2, 3, 4, 5], inf)); // rewrite the definition at runtime.\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 4, inf));\n\n\n\n// Figure 7.16: Deriving variations fom nonexisting streams by mathematical operations\n\nPdefn(\\y, Pdefn(\\x) + 2); // derive a transposition\nPdefn(\\z, Pdefn(\\x) + Pseq([0, 5, 0, 7, 2], inf)); // derive a variation\nPdefn(\\a, Ptuple([Pdefn(\\y), Pdefn(\\z)])); // combine them in a stream of arrays\n(\nTask {\n\tvar stream = Pdefn(\\a).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next.postln; \n\t\t(instrument: \\wave, note: val, sustain: rrand(0.5, 0.9)).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\n// rewriting the definitions causes all derivations to vary\nPdefn(\\x, Pseq([0, 11], inf));\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 5, inf));\nPdefn(\\z, Pdefn(\\x) + Pseq([1, 5, 1, 11, 1], inf)); // change a variation\n\nPdefn(\\a, 5); // a number as a source\nPdefn.clear; // clearing all - the empty pattern returns a series of 1. \n\n\n\n// Figure 7.17: Pdef - play, pause and resume.\n\nPdef(\\a).play; // play silence in sequence\nPdef(\\a, Pbind(\\instrument, \\wave)); // insert a sequence of notes\nPdef(\\a, Pbind(\\instrument, \\wave, \\dur, Pseq([1, 3, 2, 3], inf) / 6)); // add some rhythm\nPdef(\\a).pause;\nPdef(\\a).resume;\nPdef(\\a).stop;\n\n\n\n// Figure 7.18: A larger combination of Pdefs\n(\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\mod, Pseq([1, 0, 1, 0], inf), \n\t\t\\dur, Pn(1/2, 8),\n\t\t\\note, 7\n\t)\n)\n);\n\n(\nPdef(\\y,\n\tPbindf(\n\t\tPdef(\\x),\n\t\t\\amp, 0.2,\n\t\t\\note, Pshuf([0, 2, 3, 5], 2) + Prand([0, 5, [0, 4]], inf),\n\t\t\\dur, Pseq([1, 3, 2, 3], inf) / 6\n\t)\n)\n);\n\n(\nPdef(\\z, Pbindf(Pdef(\\y), \\dur, 1/4))\n);\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPseq([\n\t\t\tPpar([Pdef(\\x), Pdef(\\y)]),\n\t\t\tPdef(\\x),\n\t\t\tPdef(\\y),\n\t\t\tPdef(\\z),\n\t\t\tPpar([Pdef(\\x), Pbindf(Pdef(\\y), \\ctranspose, 2)])\n\t\t], inf)\n\t)\n);\n))\n\nPdef(\\a).play; // play it\n\n// go into a looping vamp\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], inf) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\n// release a break\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], 1) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\nPdef(\\a).stop; // stop the player\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////  6 Symbol streams and recursive patterns  /////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n// Figure 7.19: Simplifying the code in Figure 12.18 using Psym\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\b, Pbindf(Pdef(\\y), \\ctranspose, 2));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf).trace) // trace it to post which\n\t)\n).play;\n)\n\n// Figure 7.20: Using a Pdefn for the sequence of symbols itself\n(\nPdefn(\\sequence, Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pdefn(\\sequence).trace)\n\t)\n).play;\n)\n\n// rewrite the sequence\nPdefn(\\sequence, Pseq([\\x], inf));\nPdefn(\\sequence, Pseq([\\x, \\y, \\x, [\\x, \\y]], inf));\n\nPdef(\\a).stop; // stop playing\n\n\n// Figure 7.21: Event type 'phrase'\n\n(instrument: \\x, type: \\phrase).play; // a single phrase from Pdef(\\x)\n\n// a pattern of overlapping phrases\n(\nPbind(\n\t\\type, \\phrase, \n\t\\instrument, \\x, \n\t\\legato, 2.5, \n\t\\note, Pseq([0, 5, 7], inf)\n).play\n);\n\n\n// Figure 7.22: Recursive phrasing\n(\nPdef(\\x, { |note=0, n=6, step=3, modulo=15, sustain=1|  \n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\note, note.value + (Pseries(1, step, n) % modulo) + 7, \n\t\t\\dur, sustain.value / n\n\t) \n})\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Pseq([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf)\n\t)\n).play\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Prand([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\recursionLevel, 1,\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf) * 2\n\t)\n).play\n);\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////////  8 Combinatorics  /////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n// Figure 7.25: Combinations between patterns and ugen graphs\n\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\np = ProxySpace.push;\n~z.play;\n\n// A pattern in an audio rate node proxy ...\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), // only non-standard keys, i.e. xfreq \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n~y = { Ringz.ar(~x.ar, 5000 * [1, 1.2], 0.01) }; // resonant filter on the impulses from ~x\n~mod = { LFNoise1.kr(0.1).exprange(200, 5000) }; // a modulator\n~z = { ~y.ar * (SinOsc.ar(~mod.kr) + 1) }; // ring modulation with frequency ~mod\n\n// ... and a control rate node proxy in a pattern.\n// To pass on modulation like this, the standard event parameters like freq cannot be used.\n// Here, we use xfreq instead.\n\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, ~mod, 5, ~mod, 19], inf), // read from the ~mod proxy bus. \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n\n// Figure 7.26 The same functionality, using Ndef instead of ProxySpace.\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\nNdef(\\z).play;\n\n// a pattern in an audio rate node proxy ...\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\nNdef(\\y, { Ringz.ar(Ndef(\\x).ar, 5000 * [1, 1.2], 0.01) });\nNdef(\\mod, { LFNoise1.kr(0.1).exprange(200, 5000) });\nNdef(\\z, { Ndef(\\y).ar * (SinOsc.ar(Ndef(\\mod).kr) + 1) }); // ring modulation with Ndef(\\mod)\n\n// ... and a control rate node proxy in a pattern\n\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Ndef(\\mod), 5, Ndef(\\mod), 19], inf), // read from the Ndef(\\mod) proxy bus\n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\n\n\n// Figure 7.27: Using a Tdef to create overlapping synths within a node proxy\n\n\nNdef(\\x).play; // here an Ndef is used, the same can be done within a ProxySpace\nNdef(\\x, { |freq=5, detune=0| Impulse.ar(freq * [detune, 1 - detune]) * 0.2 });\n(\nTdef(\\c, {\n\tloop {\n\t\t Ndef(\\x).fadeTime = rrand(0.1, 3.5);\n\t\t Ndef(\\x).send([\\freq, exprand(2, 400), \\detune, [0.0, 1.0].choose.rand]);\n\t\t2.wait;\n\t}\n}).play\n);\n\n\n\n\n\n",
    "eternal_return_elementary.scd": "\n\n// eternal return. \n// nonlinear history for live and experimental just in time programming.\n// Julian Rohrhuber 2007\n\n/*\n\n\nThis program will give access to any ProxySpace (or subclass of LazyEnvir / EnvironmentRedirect) that is present as current environment. If none is present, it will create a ProxySpace and push it.\n\nIt creates a document window with some temporal navigations. \nThis document is a throw away GUI, it can be closed anytime.\n\n- the black stripe is the current time. here the edits become visible.\n- the first number box is the current time\n- the last number box represents the length of history, after which we return to beginning\n\nButtons:\n_\tnavigate in time without entering it (toggles)\n->\tstart time / stop time (toggles)\n<<\trewind to beginning of time\n:<\tstep back to previous edit\n>:\tstep forward to next edit\t\n<\tbackward 0.25 sec in time\n>\tforward 0.25 sec in time\np\tpost the complete history\nrm\tremove the current entry\nld\tload an appropriate history\n\n\n*/\n\n\n(\n\tvar w, txt, value = 0, mapVal, valMap, b2, loadFunc, scaledValue = 0, tmax = 4 * 60 + 33, delta = 0.25;\n\tvar ff, fne, fla, fba, fne2, fla2, m,  v, vv, mmax, task, changed, running = false;\n\tvar drawLine, playRout, windowFollow,toggleHistory, dispatch, onTime = false;\n\tvar browseBut, browseMode = false;\n\tvar nietzsche, temporaryPseudoEnvironment, proxyspace;\n\tvar width = 700;\n\ttemporaryPseudoEnvironment = EnvironmentRedirect.new;\n\t\n\tb2 = Rect(10, 10, 350, 20);\n\tw = Window.new(\"---\", Rect(128, 64, width, 30));\n\tw.view.decorator = FlowLayout( w.view.bounds ).gap_(2 @ 2);\n\t\n\t\n\trunning = { task.isPlaying };\n\ttoggleHistory = {\n\t\tif(running.value) { task.play(AppClock) } { task.stop };\n\t};\n\t\n\t\n\t\n\t// get the next appropriate point in time,\n\t// either the next delta step, or, if closer, the next timepoint\n\ttask = Task {\n\t\tvar nextDelta, nextIndex;\n\t\tloop {\n\t\t\tnextIndex = dispatch.timepoints.indexOfGreaterThan(scaledValue);\n\t\t\tif(nextIndex.isNil) {\n\t\t\t\tif(dispatch.timepoints.last.notNil \n\t\t\t\t\tand: {dispatch.timepoints.last >= (scaledValue + delta)}) {\n\t\t\t\t\tnextDelta = tmax - scaledValue;\n\t\t\t\t} {\n\t\t\t\t\tnextDelta = delta\n\t\t\t\t}\n\t\t\t} {\n\t\t\t\tnextDelta = min(delta, dispatch.timepoints.at(nextIndex) - scaledValue);\n\t\t\t};\n\t\t\tscaledValue = (scaledValue + nextDelta % tmax);\n\t\t\tvalMap.(scaledValue);\n\t\t\tnextDelta.wait;\n\t\t}\n\t\n\t};\n\tif(currentEnvironment.isKindOf(EnvironmentRedirect).not) {\n\t\tproxyspace = p = ProxySpace.push(s.boot);\n\t} {\n\t\tproxyspace = currentEnvironment;\n\t};\n\tdispatch = proxyspace.dispatch;\n\tif(dispatch.isNil) {\n\t\tproxyspace.dispatch = dispatch = HistoryDispatch.new;\n\t};\n\tdispatch.manual = true;\n\tdispatch.alwaysReplace = false;\n\t\n\tchanged = { |time|\n\t\tvar str, envir, changed, pairs;\n\t\tenvir = dispatch.envir;\n\t\tif(browseMode) {\n\t\t\tpairs = dispatch.getPairsForTime(time);\n\t\t\tif(pairs.isNil) { d.string = \"\" } {\n\t\t\t\td.string = pairs.collect { |pair|\n\t\t\t\t\t\tformat(\"\\n~% = %;\\n\\n\", pair[0], pair[1].asCompileString)\n\t\t\t\t\t}.join;\n\t\t\t};\n\t\t} {\n\t\t\tchanged = dispatch.setTime(time);\n\t\t\tif(changed) {\n\t\t\t\tstr = dispatch.envir.asCompileString;\n\t\t\t\td. string_( String.streamContents { arg str; \n\t\t\t\t\tenvir.storeOn(str, includeSettings: false); \n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n\t\n\tdrawLine = { |x, inset=0|\n\t\t\tPen.beginPath;\n\t\t\tPen.moveTo(x @ (5 + inset));\n\t\t\tPen.lineTo(x @ (vv.bounds.height + 5 - inset));\n\t\t\tPen.stroke;\n\t};\n\t\n\tw.drawHook_{\n\t\tPen.use {\t\n\t\t\tPen.smoothing = false;\n\t\t\tPen.width = 1;\n\t\t\t\n\t\t\tColor.white.set;\n\t\t\tdrawLine.(value, 0);\n\t\t\t\n\t\t\tColor.new255(230, 123, 155).set;\n\t\t\tdispatch.timepoints.do {|x=(0)|\n\t\t\t\tx = x.clip(0, tmax);\n\t\t\t\tdrawLine.(x / tmax * vv.bounds.width + vv.bounds.left, 3);\n\t\t\t};\n\n\t\t};\n\t};\n\t\n\tmapVal = {|x|\n\t\t\tif(x.inclusivelyBetween(vv.bounds.left, vv.bounds.left + vv.bounds.width)) {\n\t\t\t\tvalue = x;\n\t\t\t\tscaledValue = x - vv.bounds.left / vv.bounds.width * tmax;\n\t\t\t\tm.value = scaledValue;\n\t\t\t\t//onTime = dispatch.timepoints.includes(scaledValue);\n\t\t\t\tw.refresh;\n\t\t\t}\n\t};\n\t\n\tvalMap = {|x|\n\t\t\tif(x.notNil) {\n\t\t\t\tx = x.clip(0, tmax);\n\t\t\t\tm.value = scaledValue = x;\n\t\t\t\tvalue = x / tmax * vv.bounds.width + vv.bounds.left;\n\t\t\t\tchanged.value(scaledValue);\n\t\t\t//\tonTime = timepoints.includes(scaledValue);\n\t\t\t\tw.refresh;\n\t\t\t}\n\t};\n\t\n\tloadFunc = { |path|\n\t\tvar file, str, delim;\n\t\tprotect {\n\t\t\tfile = File(path.standardizePath, \"r\");\n\t\t\tstr = file.readAllString;\n\t\t} {\n\t\t\tfile.close;\n\t\t};\n\t\tstr = str.stripRTF;\n\t\tdelim = str.findAll(\"// -\").add(str.size - 1);\n\n\t\tstr = str.clumps(delim.differentiate).drop(1).drop(-1);\n\t\t\n\t\tproxyspace.awake = false;\n\t\t\tstr.do { |substr|\n\t\t\t\tvar time = History.getTimeFromString(substr);\n\t\t\t\tchanged.(time);\n\t\t\t\tsubstr.interpret;\n\t\t\t};\n\t\tproxyspace.awake = true;\n\t\ttmax = max(tmax, History.getTimeFromString(str.last));\n\t\tmmax.value = tmax;\n\t\tvalMap.(0.0);\n\t\td.front;\n\t};\n\t\n\tvv = CompositeView.new(w, b2).background_(Color.black);\n\tv = UserView.new(vv, Rect(0, 0, w.bounds.width, w.bounds.height))\n\t\t\n\t\t.mouseMoveAction_({|v,x| mapVal.value(x) })\n\t\t.mouseUpAction_({|v,x| mapVal.value(x); changed.value(scaledValue); })\n\t\t.mouseDownAction_({|v,x| mapVal.value(x); });\n\t\n\t\n\tm = NumberBox.new(w, Rect(0, 0, 40, 20));\n\tm.value = 0;\n\tm.action = { valMap.value(m.value) };\n\t\n\tvv.keyDownAction = { |v, char|\n\t\tchar.postln;\n\t\tif(char == $ , toggleHistory);\n\t};\n\n\tbrowseBut = Button.new(w, Rect(0, 0, 20, 20))\n\t\t.states_([[\"_\", Color.black], [\"-\", Color.black]])\n\t\t.action_({|b| \n\t\t\tbrowseMode = b.value == 1;\n\t\t\tif(b.value == 0) {\n\t\t\t\tvalMap.(scaledValue);\n\t\t\t};\n\t\t\td.background = [Color.white, Color.grey(0.8)][b.value];\n\t\t});\n\t\n\n\tff = Button.new(w, Rect(0, 0, 20, 20)).states_([[\"->\", Color.black], [\"||\", Color.red]]);\n\t\n\tfba = Button.new(w, Rect(0, 0, 20, 20)).states_([[\"<<\", Color.black]]);\n\t\n\tfla = Button.new(w, Rect(0, 0, 20, 20)).states_([[\":<\", Color.black]]);\n\tfne = Button.new(w, Rect(0, 0, 20, 20)).states_([[\">:\", Color.black]]);\n\t\n\tfla2 = Button.new(w, Rect(0, 0, 20, 20)).states_([[\"<\", Color.black]]);\n\tfne2 = Button.new(w, Rect(0, 0, 20, 20)).states_([[\">\", Color.black]]);\n\t\n\tff.action = { if(ff.value == 1) { task.play(AppClock);  } { task.stop } };\n\tfba.action = { valMap.(0.0) };\n\tfne.action = { \n\t\ti = dispatch.timepoints.indexOfGreaterThan(scaledValue) ? 0; \n\t\tvalMap.(dispatch.timepoints.at(i))\n\t };\n\tfla.action = { \n\t\ti = dispatch.timepoints.indexOfGreaterThan(scaledValue - 0.01);\n\t\ti = i ? dispatch.timepoints.lastIndex;\n\t\tif(i.notNil and: { i > 0 }) {\n\t\t\tvalMap.(dispatch.timepoints.wrapAt(i-1))\n\t\t}\n\t};\n\t\n\tfne2.action = { \n\t\tvalMap.(scaledValue + delta % tmax)\n\t };\n\tfla2.action = {\n\t\tvalMap.(scaledValue - delta  % tmax)\n\t};\n\t\n\tmmax = NumberBox.new(w, Rect(0, 0, 40, 20));\n\tmmax.value = tmax;\n\tmmax.action = { tmax = mmax.value; valMap.(scaledValue); };\n\t\n\t\n\t\n\tButton.new(w, Rect(0, 0, 20, 20)).states_([[\"p\", Color.black]])\n\t\t.action_({dispatch.document});\n\t\n\t\n\tButton.new(w, Rect(0, 0, 20, 20)).states_([[\"rm\", Color.black]])\n\t\t.action_({ \n\t\t\t\tdispatch.removeAllAtTime(scaledValue);\n\t\t\t\tchanged.(scaledValue);\n\t\t\t\tw.refresh;\n\t\t});\n\t\t\n\tButton.new(w, Rect(0, 0, 20, 20)).states_([[\"ld\", Color.black]])\n\t\t.action_({ \n\t\t\t\tDialog.getPaths({ |paths| paths.do(loadFunc.(_)) });\n\t\t});\n\t\t\n\tw.front;\n\td = Document.new(\"history doc\").bounds_(Rect(20, 280, width, 481));\n\td.onClose = { w.close; windowFollow.stop; CmdPeriod.remove(playRout); };\n\tw.onClose = { windowFollow.stop; CmdPeriod.remove(playRout); };\n\td.toFrontAction = d.toFrontAction.addFunc {\n\t\tif(w.isClosed.not) { ff.valueAction = 0 };\n\t};\n\tnietzsche = #[\"Alles Laufenkoennen muss gelaufen sein\", \"Der Torweg muss auch gelaufen sein\", \"Der Augenblick zieht alles nach sich, auch sich selbst\", \"Alles Laufenkoennen muss noch laufen\", \"Out of damp and gloomy days, out of solitude, out of loveless words directed at us, conclusions grow in us like fungus: one morning they are there, we do not know how, and they gaze upon us.\", \"Woe to the thinker who is not the gardener but only the soil of the plants that grow up in him!\"];\n\twindowFollow = Routine { \n\t\tvar x;\n\t\tloop {\n\t\t0.06.wait;\n\t\tif(d.bounds != x) {\n\t\t \tw.bounds = \n\t\t \tRect(d.bounds.left, d.bounds.top + d.bounds.height, d.bounds.width, w.bounds.height);\n\t\t \tif(0.3.coin) { nietzsche.choose.postln };\n\t\t \t \n\t\t \t w.front;\n\t\t \t 0.01.wait;\n\t\t \t d.front;\n\t\t\t\n\t\t };\n\t\t x = d.bounds;\n\t\t\n\t\t  0.3.wait;\n\t\t}\n\t\n\t};\n\tplayRout = { windowFollow.play(AppClock) };\n\tCmdPeriod.add(playRout);\n\t\n\tplayRout.value;\n\tvalMap.value(0);\n\t\n\n)\n",
    "Ch8codefigures1.scd": "\n/////////////////////// Object Modeling code figures /////////////////// \n\n\n\n\t//\tfigure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently\n\n\n\n\n\n\n\n\t// figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)\n\n\n\n\n\n\t// figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test\n\n\n\n\n\n\n\t//\tfigure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done\n\n\n\n\t// figure 8.5 - add a pseudo-method.\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin; \nz.makeWin(\"Try showing that.\"); \n\n\n\n\n\n\t// figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?\n\n\n\n\n\n\t// figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given\n\n\n\n\n\n\t// figure 8.8 is an image - \"c6_ObjMod_fig8.8_shoutWin.png\"\n\n\n\n\n\n\t// figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!\n\n\n\n\n\n\t//\tfigure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");\n\n\n\n\n\n\n\t//\tfigure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;\n\n\n\n\n\t// figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;\n\n\n\n\n\t// figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");\n\n\n\n\n\n\n\t//\tfigure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window\n\n\n\n\n\n\n\t//\tfigure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;\n\n\n\n\n\n \n\t// figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));\n\n\n\n\n\n\n\n\t//\tfigure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.\n\n\n\n\n\n\n\t//\tfigure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}\n\n\n\n\n\n\n\t// figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}\n\n\n\n\n\n\n\t// figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}\n\n\n\n\n\n\n\n// figure 8.21 \u00d1 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});\n\n\n\n\n\n///////// continued in ObjMod2_codefigures.rtf ///// \n\n\n",
    "Ch8codefigures2.scd": "\n\n\t// figure 8.23 - two granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\percSin);\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t// figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n\n\t// figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n\n\n\n\n\n\t// figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 8.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t// figure 8.28 is an image: the CloudGenMini GUI, file \"c8_ObjMod_8.29_cloudGenGui.png\"  //\n\n\n\n\n\t// figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)))).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);\n\n\n",
    "ObjMod1_shout_qcd.scd": "\n/////////////////////// Object Modeling code figures /////////////////// \n\n\n\n\t// error and doesNotUnderstand\n{ SinOsc.ar }.pay; \n\n\nq = ( ); \t\nq[\\melA] = [0, 2, 3];\nq[\\melA] + 10;\n\n\t// Equivalently, put and at operations can be written like getter and setter messages: \nq.melA_([0, 2, 3]); \t\n\t// Or also:\nq.melA = [0, 2, 3];\nq.melA + 7; \n\n\t// One can organize repositories of objects hierarchically as well:\nq.mels = ();\nq.mels.melA = [0, 2, 3];\n\n\t// functions are special:\nq.playMel = { |ev| Pbind(\\note, Pseq(ev.melA), \\dur, 0.2).play };\nq.playMel;\n\n\n\n\t//\tfigure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently\n\n\n\n\n\n\n\n\t// figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)\n\n\n\n\n\t// figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test\n\n\n\n\n\n////////////////////// Shout Window ///////////////////////\n\n\t//\tfigure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done\n\n\n\n\t// figure 8.5 - add a pseudo-method.\n\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin; \nz.makeWin(\"Try showing that.\"); \n\n\n\n\n\n\t// figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?\n\n\n\n\n\n\t// figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given\n\n\n\n\n\n\t// figure 8.8 is an image // \n\n\n\n\n\n\t// figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!\n\n\n\n\n\n\t//\tfigure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");\n\n\n\n\n\t// class files can be put into one of these locations:\nPlatform.userExtensionDir; \nPlatform.systemExtensionDir;\n\n\n\t//\tfigure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;\n\n\n\n\n\t// figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;\n\n\n\n\n\t// figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");\n\n\n\n\n\n\n\t//\tfigure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window\n\n\n\n\n\t//\tfigure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;\n\n\n\n \n\t// figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));\n\n\n\n\n\n\t//\tfigure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.\n\n\n\n\n\t//\tfigure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}\n\n\n\n///////////////////////////////// QCD /////////////////////////\n\n\n\t// no figure - converting QCD data files (text) to soundfiles.\n(\nq = q ? ();\nq.data = \"~/data/share/QCD/data/*.nojunk\".pathMatch.collect{|path|\n\ta = FileReader.read((path), true, true, _.asFloat * 0.03125 ).flat.as(Signal);\n\tb = SoundFile.new;\n\tb.openWrite(path.replace(\"txt.nojunk\", \"aiff\"));\n\tb.writeData(a).postln;\n\tb.close; \n\ta;\t\n}\n)\n\n\n\n\n\t// figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}\n\n\n\n\t// figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}\n\n\n\n\n// figure 8.21 here \u00d1 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});\n\n\n\n\n\n///////// continued in ObjMod2_CloudGenMini.scd ///// \n\n\n",
    "ObjMod2_CloudGenMini.scd": "// CloudGenMini is based on CloudGenerator, a granular synthesis program \n// by Curtis Roads and John Alexander. \n// This partial miniature version was implemented by Alberto de Campo, 2007. \n\n\n\n\n\t// figure 8.23 - some granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp * AmpComp.ir(freq) * 0.5, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp * AmpComp.ir(freq) * 0.5, 4), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t// a noise band grain with percussive envelope\nSynthDef(\\percNoise, { |out, amp=0.2, freq=440, sustain=0.01, pan, rq=0.1| \n\tvar snd = BPF.ar(GrayNoise.ar, freq, rq, 3);\n\tvar env = EnvGen.ar(Env.perc, timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, \n\t\tPan2.ar(snd * env, pan, amp)\n\t);\n}, \\ir ! 6).memStore\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\gabWide);\nSynth(\\percSin);\nSynth(\\percSinRev);\n\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\percNoise, [\\amp, 0.2, \\sustain, 0.1]);\n\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t// figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n/*\n\t// figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n*/\n\n\n\n\n\t// figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 8.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t// figure 8.28 is an image, the CloudGenMini GUI //\n\n\n\n\n\t// figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)))).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);\n\n\n",
    "Ch01_fig_001.scd": "\u00ef\u00bb\u00bf1.1 Additive synthesis example\n\nplay({\n\tvar sines = 5, speed = 6;\n\tMix.fill(sines, \n\t\t{arg x; \n\t\t\tPan2.ar(\n\t\t\t\tSinOsc.ar(x+1*100, \n\t\t\t\t\tmul: max(0, \n\t\t\t\t\t\tLFNoise1.kr(speed) +\n\t\t\t\t\t\tLine.kr(1, -1, 30)\n\t\t\t\t\t)\n\t\t\t\t), rand2(1.0))})/sines})\n\n",
    "Ch01_fig_002.scd": "\u00ef\u00bb\u00bf1.2 Nested Commands for Fortuitous Robot\n\nserve(\n\ttoss(\n\t\twash(lettuce, water, 10),\n\t\tdice(tomato, small),\n\t\tsprinkle(choose([blue, feta, gouda]))\n\t),\n\tbake(catch(lagoon, hook, bamboo), 400, 20),\n\tmix(\n\t\tslice(peel(banana), 20),\n\t\tcook(mix(milk, sugar, starch), 200, 10)\n\t)\n)\t\t\n\n\n\n",
    "Ch01_fig_003.scd": "\u00ef\u00bb\u00bf1.3 Forbidden Planet \n\n(\nplay(\n\t{\n\t\tCombN.ar(\n\t\t\tSinOsc.ar(\n\t\t\t\tmidicps(\n\t\t\t\t\tLFNoise1.ar(3, 24, \n\t\t\t\t\t\tLFSaw.ar([5, 5.123], 0, 3, 80)\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\t0, 0.4), \n\t\t\t1, 0.3, 2)\n\t}\n)\n)\n\n\n\n",
    "Ch01_fig_004.scd": "\u00ef\u00bb\u00bf1.4 VCO, VCF, VCA\n\n(\n{\n\tBlip.ar(\n\t\tTRand.kr( // frequency or VCO\n\t\t\t100, 1000, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tTRand.kr( // number of harmonics or VCF\n\t\t\t1, 10, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tLinen.kr( // mul, or amplitude, VCA\n\t\t\tImpulse.kr(Line.kr(1, 20, 60)), // trigger\n\t\t\t0, // attack\n\t\t\t0.5, // sustain level\n\t\t\t1/Line.kr(1, 20, 60)) // trigger\n\t\t)\n}.play\n)\n\n\n\n",
    "Ch01_fig_005.scd": "\u00ef\u00bb\u00bf1.5 Variables\n\n(\n// run this first\np = { // make p equal to this function\nr = Line.kr(1, 20, 60); // rate\n// r = LFTri.kr(1/10) * 3 + 7;\nt = Impulse.kr(r); // trigger\n// t = Dust.kr(r);\ne = Linen.kr(t, 0, 0.5, 1/r); // envelope uses r and t\nf = TRand.kr(1, 10, t); // triggered random also uses t\n// f = e + 1 * 4;\nBlip.ar(f*100, f, e) // f, and e used in Blip\n}.play\n)\n\np.free;  // run this to stop it\n\n\n",
    "Ch01_fig_006.scd": "\u00ef\u00bb\u00bf1.6 Phase Modulation With Modulator as Ratio\n\n(\n{ // carrier and modulator not linked\n\tr = Impulse.kr(10);\n\tc = TRand.kr(100, 5000, r);\n\tm = TRand.kr(100, 5000, r);\n\tPMOsc.ar(c, m, 12)*0.3\n}.play\n)\n \n(\n{\n\tvar rate = 4, carrier, modRatio; // declare variables\n\tcarrier = LFNoise0.kr(rate) * 500 + 700;\n\tmodRatio = MouseX.kr(1, 2.0);\n\t// modulator expressed as ratio, therefore timbre\n\tPMOsc.ar(carrier, carrier*modRatio, 12)*0.3\n}.play\n)\n \n\n\n",
    "Ch01_fig_007.scd": "\u00ef\u00bb\u00bf1.7 Synth Definition\n\n(\n//run this first\nSynthDef(\"PMCrotale\", {\narg midi = 60, tone = 3, art = 1, amp = 0.8, pan = 0; \nvar env, out, mod, freq;\n\nfreq = midi.midicps;\nenv = Env.perc(0, art);\nmod = 5 + (1/IRand(2, 6));\n\nout = PMOsc.ar(freq, mod*freq, \n\tpmindex: EnvGen.kr(env, timeScale: art, levelScale: tone), \n\tmul: EnvGen.kr(env, timeScale: art, levelScale: 0.3));\n\nout = Pan2.ar(out, pan);\n\nout = out * EnvGen.kr(env, timeScale: 1.3*art, \n\tlevelScale: Rand(0.1, 0.5), doneAction:2);  \nOut.ar(0, out); //Out.ar(bus, out);\n\n}).add;\n)\n\n//Then run this a bunch of times:\n\nSynth(\"PMCrotale\", [\"midi\", rrand(48, 72).round(1), \"tone\", rrand(1, 6)])\n",
    "Ch01_fig_008.scd": "\u00ef\u00bb\u00bf1.8 Playback Buffers\n\n[~houston.bufnum, ~houston.numChannels, ~houston.path, ~houston.numFrames];\n\n[~chooston.bufnum, ~chooston.numChannels, ~chooston.path, ~chooston.numFrames];\n\n(  // phasing\n{\n\tvar rate, trigger, frames;\n\tframes = ~houston.numFrames; // or use ~chooston.numFrames\n\n\trate = [1, 1.01];\n\ttrigger = Impulse.kr(rate);\n\tPlayBuf.ar(1, ~houston, 1, trigger, frames * Line.kr(0, 1, 60)) * \n\tEnvGen.kr(Env.linen(0.01, 0.96, 0.01), trigger) * rate;\n}.play;\n)\n\n\n",
    "Ch01_fig_009.scd": "\u00ef\u00bb\u00bf1.9 Connecting controls with a bus\n\n (\n// if these haven't been used they will hold 0\n~kbus1 = Bus.control; // a control bus\n~kbus2 = Bus.control; // a control bus\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tPlayBuf.ar(1, ~chooston, (speed * direction), loop: 1);\n}.play;\n)\n(\n// now start the controls\n{Out.kr(~kbus1, LFNoise0.kr(12))}.play;\n\n{Out.kr(~kbus2, LFClipNoise.kr(1/4))}.play;\n)\n// Now start the second buffer with the same control input buses, \n// but send it to the right channel using Out.ar(1 etc.\n\n(\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tOut.ar(1, PlayBuf.ar(1, ~houston, (speed * direction), loop: 1));\n}.play;\n)\n\n",
    "Ch01_fig_010.scd": "\u00ef\u00bb\u00bf1.10 Buffer Modulation\n\n(\n{\n\tOut.ar(0,\n\t\tPan2.ar( PlayBuf.ar(1, ~houston, loop: 1) * \n\t\t\tSinOsc.ar(LFNoise0.kr(12, mul: 500, add: 600)),\n\t\t0.5)\n\t)\n}.play\n)\n\n(\n{\nvar source, delay; \n\tsource = PlayBuf.ar(1, ~chooston, loop: 1);\n\tdelay =  AllpassC.ar(source, 2, [0.65, 1.15], 10);\n\tOut.ar(0,\n\tPan2.ar(source) + delay\n\t)\n}.play\n)\n\n\n\n",
    "Ch01_fig_011.scd": "\u00ef\u00bb\u00bf1.11 FX Routing using Buses\n\n// Create and name buses \n~delay = Bus.audio(s, 2);\n~mod = Bus.audio(s, 2);\n~gate = Bus.audio(s, 2);\n~k5 = Bus.control;\n\n~controlSyn= {Out.kr(~k5, LFNoise0.kr(4))}.play; // start the control\n\n// Start the last item in the chain, the delay\n~delaySyn = {Out.ar(0, AllpassC.ar(In.ar(~delay, 2), 2, [0.65, 1.15], 10))}.play(~controlSyn, addAction: \\addAfter) \n\n// Start the next to last item, the modulation\n~modSyn = {Out.ar(~delay, In.ar(~mod, 2) * SinOsc.ar(In.kr(~k5)*500 + 1100))}.play(~delaySyn, addAction: \\addBefore);\n\n// Start the third to last item, the gate\n~gateSyn = {Out.ar([0, ~mod], In.ar(~gate, 2) * max(0, In.kr(~k5)))}.play(~modSyn, addAction: \\addBefore);\n\n// make a group for the PlayBuf synths at the head of the chain\n~pbGroup = Group.before(~controlSyn);\n\n// Start one buffer. Since we add to the group, we know where it will go\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~houston, loop: 1), 0.5))}.play(~pbGroup);\n\n// Start the other\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~chooston, loop: 1), -0.5))}.play(~pbGroup);\n\n\n\n",
    "Ch01_fig_012.scd": "\u00ef\u00bb\u00bf1.12 Random MIDI Walk\n\nTask({\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"count, midi, pitch, octave\".postln;\n\tdo(50, {arg count;\n\t\tp = rrand(36, 72);\n\t\t[count, p, a.wrapAt(p), (p/12).round(1) - 1].postln;\n\t1.wait;\n\t})\n}).play\n\n",
    "Ch01_fig_013.scd": "\u00ef\u00bb\u00bf1.13 Random Crotale Walk\n\n// This uses the PMCrotale synth definition\n(\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"event, midi, pitch, octave\".postln;\nr = Task({\n\tinf.do({ arg count;\n\t\tvar midi, oct, density;\n\t\tdensity = 1.0; // 100% of the time. Uncomment below for 70%, etc.\n\t\t// density = 0.7; \n\t\t// density = 0.3;\n\t\tmidi = [0, 2, 4, 7, 9].choose;\n\t\t// midi = [0, 2, 4, 5, 7, 9, 11].choose;\n\t\t// midi = [0, 2, 3, 5, 6, 8, 9, 11] .choose; \n\t\t// midi = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] .choose;\n\t\toct = [48, 60, 72].choose;\n\t\tif(density.coin, \n\t\t\t{ // true action\n\t\t\t\t\"\".postln;\n\t\t\t\t[midi + oct, a.wrapAt(midi), \n\t\t\t\t(oct/12).round(1)].post;\n\t\t\t\tSynth(\"PMCrotale\", \n\t\t\t\t\t[\"midi\", midi + oct, \"tone\", rrand(1, 7), \n\t\t\t\t\t\"art\", rrand(0.3, 2.0), \"amp\", rrand(0.3, 0.6), \"pan\", 1.0.rand2]);\n\t\t\t}, {[\"rest\"].post}); // false action\n\t\t0.2.wait; \n\t}); \n}).start\n)\n\nr.stop; // run this to stop\n\n",
    "Ch01_fig_014.scd": "\u00ef\u00bb\u00bf1.14 Nested do to Generate a 12-Tone Matrix\n\n(\nvar row, inversion, pitchClass;\nrow = Array.series(11, 1).scramble.insert(0, 0); \n// or enter your own row, e.g. Webern's Op 27\n// row = [0, 11, 8, 2, 1, 7, 9, 10, 4, 3, 5, 6]; \nrow.postln;\ninversion = 12 - row;\n// I add spaces to the strings for a tidy row\npitchClass = [\"C  \", \"C# \", \"D  \", \"Eb \", \n\t\"E  \", \"F  \", \"F# \", \"G  \", \"Ab \", \"A  \", \"Bb \", \"B  \"];\ninversion.do({arg eachInv;\n\tvar trans;\n\ttrans = (row + eachInv); \n\t// prints just pitch class\n\ttrans.do({arg scaleDegree; pitchClass.wrapAt(scaleDegree).post});\n\t//\"\".postln; // uncomment these line if you want to do both\n\t// prints just numbers\n\t//trans.do({arg scaleDegree; (scaleDegree%12).post; \" \".post});\n\t\"\".postln;\n\t});\n\"\".postln\n)\n\n",
    "Ch01_fig_015.scd": "\u00ef\u00bb\u00bf1.15 Additive Synthesis Examples\n\n// Mix down a few of them tuned to harmonics:\n\n(\n{\nvar fund = 220;\nMix.ar(\n\t[\n\tSinOsc.ar(220, mul: max(0, LFNoise1.kr(12))),\n\tSinOsc.ar(440, mul: max(0, LFNoise1.kr(12)))*1/2,\n\tSinOsc.ar(660, mul: max(0, LFNoise1.kr(12)))*1/3,\n\tSinOsc.ar(880, mul: max(0, LFNoise1.kr(12)))*1/4,\n\tSinOsc.ar(1110, mul: max(0, LFNoise1.kr(12)))*1/5,\n\tSinOsc.ar(1320, mul: max(0, LFNoise1.kr(12)))*1/6\n\t]\n)*0.3\n}.play\n)\n\n",
    "Ch01_fig_016.scd": "\u00ef\u00bb\u00bf1.16 Additive Synthesis Example\n\n// Try this first\nArray.fill(20, {arg cnt; cnt + 1*110}); // harmonics built on 110\n\n// And a patch\n(\n{Mix.ar(\n\tArray.fill(12, \n\t\t{arg count; \n\t\tvar harm;\n\t\tharm = count + 1 * 110; // remember precedence; count + 1, then * 110\n\t\t\tSinOsc.ar(harm, \n\t\t\t\tmul: max([0, 0], SinOsc.kr(count+1/4))\n\t\t\t\t)*1/(count+1)\n\t\t})\n)*0.7}.play\n)\n\n",
    "Ch01_fig_018.scd": "\u00ef\u00bb\u00bf1.18 Physically Modeled Bells\n// Try this first, to illustrate the array of arrays.\nArray.fill(3, {Array.fill(10, {rand(1000)})})\t\n// Then this patch.\n(\n{\nvar scale, specs, freqs, amps, rings, \n\tnumRes = 5, bells = 20, pan; \nscale = [60, 62, 64, 67, 69].midicps;\n\tMix.fill(bells, {\n\t\tfreqs = Array.fill(numRes, {rrand(1, 15)*(scale.choose)});\n\t\tamps = Array.fill(numRes, {rrand(0.3, 0.9)});\n\t\trings = Array.fill(numRes, {rrand(1.0, 4.0)});\n\t\tspecs = [freqs, amps, rings].round(0.01);\n\t\t// specs.postln;\n\t\tpan = (LFNoise1.kr(rrand(3, 6))*2).softclip;\n\t\tPan2.ar( \n\t\t\tKlank.ar(`specs, \n\t\t\t\tDust.ar(1/6, 0.03)), \n\t\t\t\tpan)\n\t})\n}.play;\n) \n\n",
    "Ch01_fig_019.scd": "\u00ef\u00bb\u00bf1.19 Generative Sequences using Arrays\n\n( // first define the synth\n\nSynthDef.new(\"SimpleBlip\", { \narg midi = 60, tone = 10, art = 0.125, amp = 0.2, pan = -1;\nvar out, temper;\t\nout =\tPan2.ar(\n\t\t\tBlip.ar( // play the sequence\n\t\t\t\tmidi.midicps,\n\t\t\t\ttone\n\t\t\t\t) * EnvGen.kr(Env.perc(0.01, art)),\n\t\tpan // pan left, center, or right\n\t);\nDetectSilence.ar(out, doneAction:2);\namp = amp - ((midi - 60) * 0.02);\nOut.ar(0, out*amp)\n\t}).add;\n)\n \n(\n// Then run this Task\n~inst = [0, 0, 0]; // Three containers for tasks\n~pSeq = [0, 0, 0]; // Three containers for sequences\n~scaleAdd = [4, 5, 11, nil, 10, 3, 6, nil]; // \n~notes = \n[\" C\", \" C#\", \" D\", \" Eb\", \" E\", \" F\", \n\t\" F#\", \" G\", \" Ab\", \" A\", \" Bb\", \" B\"]; \n~rout = Task({\n\tinf.do({\n\t\targ cnt1; \n\t\tvar steps, durSeq, harmSeq;\n\t\tsteps = rrand(6, 12);\n\t\tif(cnt1%6 == 0, // every sixth iteration, add a degree\n\t\t\t{~scale = ~scale.add(~scaleAdd.wrapAt((cnt1/6).round(1) - 1));}); \n\t\t\"\\nIteration: \".post; cnt1.post; \n\t\t[\" (center) \", \" (right) \", \" (left) \"].wrapAt(cnt1).postln;\n\t\tif(cnt1%24 == 0, // reset all three\n\t\t\t{~scale = [0, 2, 7, 9]; \n\t\t\t3.do({arg cnt2; \n\t\t\t\t~pSeq.wrapPut(cnt2, \n\t\t\t\t\tArray.fill(steps, \n\t\t\t\t\t\t{~scale.choose + [48, 60].choose}))})});\n\t\t\"scale: \".post; ~scale.postln;\n\t\t~pSeq.wrapPut(cnt1, // fill array with scale steps\n\t\t\tArray.fill(steps, {~scale.choose + [48, 60].choose}));\n\t\t\"MIDI seq: \".post; (~pSeq.wrapAt(cnt1)%12).postln;\n\t\t\"Sequence (notes): \".post; \n\t\t~pSeq.wrapAt(cnt1).do( // print the sequence using note names\n\t\t\t{arg thisItem; ~notes.at(thisItem%12).post}); \n\t\t\"\".postln;\n\t\t// create harmonic and duration arrays\n\t\tharmSeq = Array.fill(steps, {rrand(1.0, 5.0)});\n\t\tdurSeq = Array.fill(steps - 1, {rrand(0.01, 0.9)});\n\t\t// stop the previous task at this array position\n\t\t~inst.wrapAt(cnt1).stop;\n\t\t~inst.wrapPut(cnt1, \n\t\t\tTask({\n\t\t\t\tinf.do({arg cnt3; // each sequence\n\t\t\t\t\tSynth(\"SimpleBlip\", \n\t\t\t\t\t\t[\\midi, ~pSeq.wrapAt(cnt1).wrapAt(cnt3), \n\t\t\t\t\t\t\\tone, harmSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\art, durSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\amp, rrand(0.1, 0.3), \n\t\t\t\t\t\t\\pan, cnt1.wrap(-1, 2)]);\n\t\t\t\t\t0.125.wait; // tempo of each note\n\t\t\t\t})}).start;\n\t\t);\n\t\t12.wait;})\n}).start; // time between each new sequence\n)\n\n~rout.stop; // stop new sequences\n~inst.at(0).stop; // at any time, stop center sequence\n~inst.at(1).stop; // stop right sequence\n~inst.at(2).stop; // stop center sequence\n\n",
    "Ch01_fig_020.scd": "\u00ef\u00bb\u00bf1.20 Offset and Scale\n\n(\n\t{\n\tvar trigger, wave, label, scale, offset;\n\ttrigger = Impulse.kr(10);\n\twave = SinOsc.kr(1/10) ; // change to 400\n\tscale = 1; offset = 0;\n//\twave = wave * scale + offset; \n\tlabel = \"scale = \" ++ scale.asString ++ \", offset = \" ++ offset.asString;\n\twave.round(0.01).poll(label: label);\n\t}.scope(1)\n)\n \n\n",
    "Ch01_fig_021.scd": "\u00ef\u00bb\u00bf1.21 SinOsc Offset and Scaled for Control\n\n(\n\t{\n\tvar trigger, control, scale, offset;\n\tscale = 300; // try other values, but not greater than offset\n\toffset = 600; // try other values\n\ttrigger = Impulse.kr(10);\n\tcontrol = SinOsc.ar(1/4).scope(\"control\"); // LFO\n\tcontrol = control  * scale + offset;\n\tSinOsc.ar(freq: abs(control).poll).scope(\"audio\")\n\t}.play\n) \n\n// Speaking of vibrato, I can't resist this faux Theremin: \n\n{SinOsc.ar(SinOsc.ar(8, 0, 10, MouseX.kr(440, 1760, 1)))}.play\n\n\n",
    "Ch01_fig_022.scd": "\u00ef\u00bb\u00bf1.22 Test Your Skills\n\n(\n{\n\tvar carrier, rate, trigger, modRatio, index, control, env;\n\trate = 3;\n\ttrigger = Impulse.kr(rate);\n\tcontrol = LFNoise0.kr(rate);\n\tcarrier = 62;\n\tmodRatio = 4.125;\n\tindex = 10;\n\tcarrier = carrier.midicps;\n\tcarrier.poll(trigger, \"carrier\"); \n\tindex.poll(trigger, \"index\"); \n\tmodRatio.poll(trigger, \"modRatio\");\n\tPMOsc.ar(carrier, carrier*modRatio, index)\n}.play\n)\n\n\n",
    "Ch01_fig_023.scd": "\u00ef\u00bb\u00bf1.23 PMOsc With Offset and Scale\n\n(\na = SynthDef(\"PMOsc_ex\", \n{\n\targ left = 10, right = 10, indexLow = 4, indexHigh = 12;\n\tvar pitch, timbre, trigger, env, index, out;\n\ttrigger = Impulse.kr([left, right]); // trigger\n\tpitch = TRand.kr(36, 72, trigger).round(1); // C2 to C6\n\ttimbre = LFNoise0.kr(1/20, mul: 0.2, add: 2); // mod control\n\tenv = Linen.kr(trigger, releaseTime: 1/[left, right]); // envelope\n\tindex = env * indexHigh + indexLow; // env scaled and offset for index\n\tpitch = pitch.midicps; // midi converted to freq\n\tout = PMOsc.ar(pitch, pitch*timbre, index, mul: env);\n\tOut.ar(0, out);\n}).play\n)\n\na.set(\"left\", 4)\n\na.set(\"right\", 5)\n\na.set(\"indexLow\", 1)\n\na.set(\"indexHigh\", 4)\n\n",
    "Ch01_fig_024.scd": "\u00ef\u00bb\u00bf1.24 PMOsc With Sample and Hold (Latch) \n\n(\n// run this first\na = SynthDef(\"Latch_demo\",\n{\narg rate = 9; \nvar freq, latchrate, index, ratio, env, out;\nlatchrate = rate*LFNoise0.kr(1/10, mul: 0.03, add: 1.6);\nindex = Latch.kr(\n\tLFSaw.kr(latchrate, mul: 5, add: 6),\n\tImpulse.kr(rate)\n\t);\nfreq = Latch.kr(\n\tLFSaw.kr(latchrate, \n\tmul: max(0, LFNoise1.kr(1/5, mul: 24, add: 10)), \n\tadd: LFNoise0.kr(1/7, mul: 12, add: 60)),\n\tImpulse.kr(rate)\n\t).round(1).midicps;\n\nratio = LFNoise1.kr(1/10, mul: 2.0, add: 5.0);\n\nenv = EnvGen.kr(\n\tEnv.perc(0, LFNoise0.kr(rate, mul: 1, add: 1.5)/rate), \n\tImpulse.kr(rate), \n\tLFNoise1.kr([5, 5], 2, 1).max(0).min(0.8));\nout = PMOsc.ar(\n\t[freq, freq * 1.5],\n\tfreq*ratio,\n\tindex,\n\tmul: env\n);\nOut.ar(0, out);\n}\n).play\n)\n\na.set(\"rate\", 10)\n\na.set(\"rate\", 15)\n\na.set(\"rate\", 6)\n\na.free;\n\n\n",
    "Ch01_fig_025.scd": "\u00ef\u00bb\u00bf1.25 It's Just a Bell\n\n(\n{ // it's just a bell\nvar burst, burstEnv, bell, delay, dry, \nburstFreq = 500, freqs, amps, rings;\nburstEnv = EnvGen.kr(Env.perc(0, 0.05),\n\t\t\t\tDust.kr(1/5), 0.1);\n// burstEnv.poll(100, \"env\");\nburst = SinOsc.ar(freq: burstFreq,\n\tmul: burstEnv);\n// burst.poll(100, \"burst\");\nfreqs = Array.fill(10, {exprand(100, 1000)});\namps = Array.fill(10, {rrand(0.01, 0.1)});\nrings = Array.fill(10, {rrand(1.0, 6.0)});\n// [freqs, amps, rings].round(0.01).postln;\n// \"safe\" values\n// freqs = [100, 200, 300, 400];\n// amps = [1, 1, 1, 1];\n// rings = [1, 1, 1, 1];\n\nbell = Pan2.ar(\n\tKlank.ar(`[freqs, amps, rings], burst), \n\trrand(-1.0, 1.0)\n);\n\ndelay = AllpassN.ar(bell, 2.5, \n\t[LFNoise1.kr(7, 1.5, 1.6), LFNoise1.kr(7, 1.5, 1.6)], \n\t1, mul: 0.8);\nbell \n+ delay\n// + SinOsc.ar(mul: LFPulse.kr(1) * 0.05);\n}.play\n)\n\n",
    "Ch02_fig_001.scd": "\u00ef\u00bb\u00bf\n/* Figure 2.1 */\nServer.default = s = Server.internal;\n\ns.boot;\n\nz = s.scope(4);\n\n// a) mono output\n(\nSynthDef(\\UGen_ex1a, {\n\tOut.ar(0, SinOsc.ar(440, 0, 0.1))\n}).add\n)\t\n\na= Synth(\\UGen_ex1a);\n\na.free;\n\n// b) freq input is an Array of 4 items - outputs to busses 0-3\n(\nSynthDef(\\UGen_ex1b, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, 0.1))\n}).add\n)\t\n\na= Synth(\\UGen_ex1b);\n\na.free;\n\n// c) Array is added to the 'mul' arg to show mapping\n(\nSynthDef(\\UGen_ex1c, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3, 0.4]))\n}).add;\n)\t\n\na= Synth(\\UGen_ex1c);\n\na.free;\n\n// d) The output of the SinOsc above is actually an Array of four SinOscs. Sum them       // together for an additive synthesis example.\n(\nSynthDef(\\UGen_ex1d, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3]).sum);\n}).add\n)\t\n\na= Synth(\\UGen_ex1d);\n\na.free;\n\nz.window.close;\n\n\n",
    "Ch02_fig_002.scd": "\u00ef\u00bb\u00bf/* Figure 2.2 */\n\nServer.default = s = Server.internal.boot;\n\nz = s.scope;\n(\nSynthDef(\\UGen_ex2, {arg freq = 440;\n\tvar src, compressor, limiter, out;\n\t// 10 SinOsc's, mixed together. Output amplitude is controlled with an Dust UGen\n \t// wrapped in a Decay2 UGen to create a spike with an Exponential Decay\n\tsrc = SinOsc.ar(\n\t\t// a harmonic series based on freq\n\t\tArray.series(10, freq, freq),\n\t\t0, // phase\n\t\tArray.fill(10, {Decay2.ar( \n\t\t\t// Dust will create an impulse about every 2 seconds, with values between 0\n\t\t\t// and 5\n\t\t\tDust.ar(0.1, 5),\n\t\t\t// Decay2, attach time of 0.01 seconds and a decay time of 5 seconds to\n\t\t\t// allow for a build up of signal\n\t\t\t0.01, 5)});\n\t\t).sum;\n\t// compress signal about 0.5\n\tcompressor = Compander.ar(src, src, 0.5, 1, 0.1);\n\tlimiter = Limiter.ar(compressor, 0.5);\n\t// out is the compressed only signal on the left, the compressed and limited on the \n\t// right\n\tout = [DelayN.ar(compressor, 0.02, 0.02), limiter];\n\t// use Peak and poll to track the highest output values. Updates every second\n\tPeak.ar(out ++  src, Impulse.kr(1)).poll(1, [\"compressed\", \"limited\", \"src\"]);\n\tOut.ar(0, out);\n}).add;\n)\t\na = Synth(\\UGen_ex2, [\\freq, 440]);\n\na.free; z.window.close;\n\n\n",
    "Ch02_fig_003.scd": "\u00ef\u00bb\u00bf/* Figure 2.3 */\n(\nSynthDef(\\UGen_ex3, {arg gate = 1, amp = 1, rate = 10;\n\tvar trigger, dur, carfreq, modfreq, index, pan, env;\n\ttrigger = Impulse.ar(rate);\n\tdur = rate.reciprocal;\n\tcarfreq = LFNoise2.kr.range(100, 110);\n\tmodfreq = LFTri.kr(0.1).exprange(200, 840);\n\tindex = LFCub.kr(0.2).range(4, 10);\n\tpan = WhiteNoise.ar.range(-0.1, 0.1);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1),\n\t\tgate,\n\t\tlevelScale: amp,\n\t\tdoneAction: 2);\n\tOut.ar(0,\n\t\tGrainFM.ar(2, trigger, dur, carfreq, modfreq, index,\n\t\t\tpan, -1) * env)\n}).add;\n)\na = Synth(\\UGen_ex3, [\\rate, 80, \\amp, 0.2]);\n\nb = Synth(\\UGen_ex3, [\\rate, 42, \\amp, 0.2]);\n\nc = Synth(\\UGen_ex3, [\\rate, 121, \\amp, 0.2]);\n\n[a, b, c].do({arg thisSynth; thisSynth.set(\\gate, 0)});\n\n\n",
    "Ch02_fig_004.scd": "\u00ef\u00bb\u00bf/* Figure 2.4 */\n\n(\nSynthDef(\\UGen_ex4a, {arg id, limit = 1;\n\tvar src, pitch, hasPitch, keynum, outOfTune;\n\t// read input\n\tsrc = SoundIn.ar(0);\n\t// analyze the frequency of the input\n\t#pitch, hasPitch = Pitch.kr(src);\n\t// convert to a midi keynum, but don't round! This value will be used later.\n\tpitch = pitch.cpsmidi;\n\t// if you are within an eighth tone of an equal tempered pitch, send a trigger\n\toutOfTune = (pitch - pitch.round).abs < 0.25;\n\t// if outOfTune is true, send a trigger. Limit to 1 trigger every 'limit' seconds  \n\tSendTrig.kr(Trig.kr(outOfTune, limit), id, pitch.round);\n}).add;\n\t\nSynthDef(\\UGen_ex4b, {arg id1, id2, limit = 1, thresh = 0.5;\n\tvar src, amp, amptrig, timer;\n\tsrc = SoundIn.ar(0);\n\t// analyze the amplitude input, cause a trigger if the output is over the thresh\n\tamp = Amplitude.kr(src);\n\tamptrig = Trig.kr(amp > thresh, limit);\n\t// use amptrig to see how long it is between triggers.\n\ttimer = Timer.kr(amptrig);\n\t// send the values back with two different ids\n\tSendTrig.kr(amptrig, id1, amp);\n\tSendTrig.kr(amptrig, id2, timer);\n}).add;\n\n// plays a SinOsc of the pitch you were closest to\nSynthDef(\\UGen_ex4c, {arg freq;\n\tOut.ar(1, SinOsc.ar(freq, 0, XLine.kr(0.1, 0.00001, 0.5, doneAction: 2)))\n}).add;\n\n// modulated noise to respond to amp spikes\nSynthDef(\\UGen_ex4d, {arg freq;\n\tOut.ar(1, LFNoise1.ar(200) * SinOsc.ar(freq, 0, \n\t\tXLine.kr(0.1, 0.00001, 0.5, doneAction: 2)));\n}).add;\n\n// allocate three unique ids for the trigger ids\na = UniqueID.next;\nb = UniqueID.next;\nc = UniqueID.next;\t\n\n// an envelope to poll for amp values later\ne = Env([440, 880], [1], \\exp);\n\n// add the responder\no = OSCresponderNode(s.addr, '/tr', {arg time, responder, msg;\n\t// the msg is an array with 4 values... post them\n\tmsg.postln;\n\t// the id sent back from the SendTrig is msg[2]... use it to decide what to do\n\tcase \n\t\t// pitch trigger\n\t\t{msg[2] == a}\n\t\t// msg[3] is the rounded keynum\n\t\t{Synth(\\UGen_ex4c, [\\freq, msg[3].midicps])}\n\t\t// amp trigger\n\t\t{msg[2] == b}\n\t\t// play a noise burst, higher the amp value, higher the freq (polls the \n\t\t// Env 'e')\n\t\t{Synth(\\UGen_ex4d, [\\freq, e[msg[3]]])}\n\t\t// use the Timer value to play a delayed noise burst at 2000 Hz\n\t\t{msg[2] == c}\n\t\t{SystemClock.sched(msg[3], {\n\t\t\tSynth(\\UGen_ex4d, [\\freq, 2000]);\n\t\t\t})}\n}).add;\n\n// schedule the start our listening synths...\n// then sing or tap away on the input.\nSystemClock.sched(1.0, {\n\tSynth(\\UGen_ex4a, [\\id, a, \\limit, 1]);\n\tSynth(\\UGen_ex4b, [\\id1, b, \\id2, c, \\limit, 0.2, \\thresh, 0.25]);\n});\n\t\n// add a command period function to stop the synths and remove the responder\nCmdPeriod.doOnce({\n\to.remove; \"Removed the responder\".postln;\n})\n)\n\n",
    "Ch02_fig_005.scd": "\u00ef\u00bb\u00bf/* Figure 2.5 */\n(\nSynthDef(\\UGen_ex5, {arg gate = 1, seed = 0, id = 1, amp = 1;\n\tvar src, pitchbase, freq, rq, filt, trigger, env;\n\tRandID.ir(id);\n\tRandSeed.ir(1, seed);\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = WhiteNoise.ar;\n\ttrigger = Impulse.kr(Rand.new(2, 5));\n\tpitchbase = IRand.new(4, 9) * 12;\n\tfreq = TIRand.kr(pitchbase, pitchbase + 12, trigger).midicps;\n\trq = LFDNoise3.kr(Rand.new(0.3, 0.8)).range(0.01, 0.005);\n\tfilt = Resonz.ar(src, Lag2.kr(freq), rq);\n\tOut.ar(0, Pan2.ar(filt, LFNoise1.kr(0.1)) * env * amp)\n}).add;\n)\t\na = Synth(\\UGen_ex5, [\\seed, 123]);\n\na.release;\n\n// Using the same seed, we get the same gesture\nb = Synth(\\UGen_ex5, [\\seed, 123]);\n\nb.release;\n\n// passing in different seeds\n(\nr = Routine.run({\n\tthisThread.randSeed_(123);\n\t10.do({\n\t\ta = Synth(\\UGen_ex5, [\\seed, 10000.rand.postln, \\amp, 3.dbamp]);\n\t\t1.wait;\n\t\ta.release;\n\t})\n});\n)\t\t\n\n",
    "Ch02_fig_006.scd": "\u00ef\u00bb\u00bf/* Figure 2.6 */\n(\nSynthDef(\\UGen_ex6, {arg gate = 1, roomsize = 200, revtime = 450;\n\tvar src, env, gverb;\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = Resonz.ar(\n\t\t\tArray.fill(4, {Dust.ar(6)}),\n\t\t\t1760 * [1, 2.2, 3.95, 8.76] + \n\t\t\t\tArray.fill(4, {LFNoise2.kr(1, 20)}), \n\t\t\t0.01).sum * 30.dbamp;\n\tgverb = GVerb.ar(\n\t\tsrc,\n\t\troomsize, \n\t\trevtime, \n\t\t// feedback loop damping\n\t\t0.99,\n\t\t// input bw of signal\n\t\tLFNoise2.kr(0.1).range(0.9, 0.7),\n\t\t// spread \n\t\tLFNoise1.kr(0.2).range(0.2, 0.6),\n\t\t// almost no direct source \n\t\t-60.dbamp,\n\t\t// some early reflection\n\t\t-18.dbamp, \n\t\t// lots of the tail\n\t\t3.dbamp,\n\t\troomsize);\n\tOut.ar(0, gverb * env)\n}).add;\n)\t\na = Synth(\\UGen_ex6);\n\na.release;\n\n",
    "Ch02_fig_007.scd": "\u00ef\u00bb\u00bf/* Figure 2.7 */\n(\nSynthDef(\\UGen_ex7a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.ar(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex7b, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\nSynthDef(\\UGen_ex7c, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\n\n// 56% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 39%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7b, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 35%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7c, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n",
    "Ch02_fig_008.scd": "\u00ef\u00bb\u00bf/* Figure 2.8 */\n(\nSynthDef(\\UGen_ex8a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar w, x, y, out, env, decode;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tdecode = DecodeB2.ar(2, w, x, y);\n\tOut.ar(0, decode * env)\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8b, {arg outbus, freq = 440, rate = 0.2;\n\tvar w, x, y;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tOut.ar(outbus, [w, x, y])\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8c, {arg inbus, gate = 1, amp = 0.1;\n\tvar w, x, y, env, decode;\n\t#w, x, y = In.ar(inbus, 3);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 14);\n\tdecode = DecodeB2.ar(2, w, x, y) * env;\n\tReplaceOut.ar(0, decode);\n}).add;\n)\n\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex8a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n(\na = Group.new;\nz = Bus.audio(s, 3);\n\n// the 'catch-all' synth for decoding and enveloping\nSynth(\\UGen_ex8c, [\\inbus, z, \\amp, 0.001], a, \\addToTail); // add it to the tail of the Group containing the encoding synths\n\n250.do({\n\tSynth(\\UGen_ex8b, [\\freq, 440.0.rrand(1760.0), \\outbus, z, \\rate, 0.2], a)\n});\n)\n\na.release;\t\n\n",
    "Ch02_fig_009.scd": "\u00ef\u00bb\u00bf\n/* Figure 2.9 */\n(\n// pass in amp in db\nSynthDef(\\UGen_ex9a, {arg gate = 1, freq = 440, amp = 0;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0, amp.dbamp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\n// pass in linear amplitude\nSynthDef(\\UGen_ex9b, {arg gate = 1, freq = 440, amp = 1;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\nSynthDef(\\UGen_ex9c, {arg gate = 1, freq = 440, amp = -3, pos = 0;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\t\n\n// 45% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9a, [\\freq, 440.0.rrand(1760.0), \\amp, -60], a)\n});\n)\na.release;\n\n// 36%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9b, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp], a)\n});\n)\na.release;\n\n// 36% (no difference from b)\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9c, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp, \\pos, 1.0.rand2], a)\n});\n)\na.release;\n\n\n",
    "Ch02_fig_010.scd": "\u00ef\u00bb\u00bf\n/* Figure 2.10 */\n(\nSynthDef(\\UGen_ex10a, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10b, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10c, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\na = Synth(\\UGen_ex10a); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10b); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10c); // cubic interpolation\na.release;\n\n(\nSynthDef(\\UGen_ex10d, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10e, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\t\nSynthDef(\\UGen_ex10f, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\n// tune to a specific pitch\na = Synth(\\UGen_ex10d, [\\deltime, 100.midicps.reciprocal]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 100.midicps.reciprocal]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 100.midicps.reciprocal]); // cubic interpolation\na.release;\n\n// a much longer delay\na = Synth(\\UGen_ex10d, [\\deltime, 0.1]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 0.1]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 0.1]); // cubic interpolation\na.release;\n\n",
    "Ch03_fig_001.scd": "\u00ef\u00bb\u00bfFigure 3.1 A simple routine illustrating a musical use of yield\n// Fermata\ns.boot;\n(\nr = Routine({\t\n\tx = Synth(\\default, [freq: 76.midicps]);\n\t1.wait;\n\t\n\tx.release(0.1);\n\ty = Synth(\\default, [freq: 73.midicps]);\n\t\"Waiting...\".postln;\n\tnil.yield;// fermata\n\t\n\ty.release(0.1);\n\tz = Synth(\\default, [freq: 69.midicps]);\n\t2.wait;\n\tz.release;\n});\n)\n// do this then wait for the fermata\nr.play;\n// feel the sweet tonic... \nr.play; \n\n\n",
    "Ch03_fig_002.scd": "\u00ef\u00bb\u00bfFigure 3.2 Using Task so you can pause the sequence\n(\nt = Task({\t\n\tloop({\t // loop the whole thing\n\t\t3.do({\t // do this 3 times\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 76.midicps]);\n\t\t\t0.5.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 73.midicps]);\n\t\t\t0.5.wait;\n\t\t});\n\t\t\"I'm waiting for you to press resume\".postln;\n\t\tnil.yield;// fermata\n\t\tx.release(0.1);\n\t\tx = Synth(\\default, [freq: 69.midicps]);\n\t\t1.wait;\n\t\tx.release;\n\t});\n});\n\nw = Window.new(\"Task Example\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\nButton.new(w, Rect(0, 0, 100, 20)).states_([[\"Play/Resume\", Color.black, Color.clear]])\n\t.action_({ t.resume(0);});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Pause\", Color.black, Color.clear]])\n\t.action_({ t.pause;});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Finish\", Color.black, Color.clear]])\n\t.action_({ \n\t\tt.stop; \n\t\tx.release(0.1);\n\t\tw.close;\n\t});\n)\n\n\n\n\n\n",
    "Ch03_fig_003.scd": "\u00ef\u00bb\u00bf\n// Figure 3.3 Nesting tasks inside routines\n(\nr = Routine({\t\n\tc = TempoClock.new; // make a TempoClock\n\t// start a 'wobbly' loop\n\tt = Task({\t\n\t\tloop({\t\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 61.midicps, amp: 0.2]);\n\t\t\t0.2.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 67.midicps, amp: 0.2]);\n\t\t\trrand(0.075, 0.25).wait; // random wait from 0.1 to 0.25 seconds\n\t\t});\n\t}, c); // use the TempoClock to play this Task\n\tt.start;\n\tnil.yield;\n\t\n\t// now add some notes\n\ty = Synth(\\default, [freq: 73.midicps, amp: 0.3]);\n\tnil.yield;\n\ty.release(0.1);\n\ty = Synth(\\default, [freq: 79.midicps, amp: 0.3]);\n\tc.tempo = 2; // double time\n\tnil.yield;\n\tt.stop; y.release(1); x.release(0.1); // stop the Task and Synths\n});\n)\n\nr.next; // start loop\nr.next; // first note\nr.next; // second note; loop goes 'double time'\nr.next; // stop loop and fade\n\n\n\n\n\n\n\n",
    "Ch03_fig_004.scd": "\u00ef\u00bb\u00bf// Figure 3.4 Using patterns within a task\n\n(// random notes from lydian b7 scale\np = Pxrand([64, 66, 68, 70, 71, 73, 74, 76], inf).asStream; \n// ordered sequence of durations\nq = Pseq([1, 2, 0.5], inf).asStream; \nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\nt.stop; x.release(2);\n\n",
    "Ch03_fig_005.scd": "\u00ef\u00bb\u00bf\n// Figure 3.5 Thanks to polymorphism we can substitute objects that understand the same message\n(\np = 64; // a constant note\nq = Pseq([1, 2, 0.5], inf).asStream; // ordered sequence of durations\nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\n// now change p\np = Pseq([64, 66, 68], inf).asStream; // to a Pattern: do re mi\np = { rrand(64, 76) }; // to a Function: random notes from a chromatic octave\nt.stop; x.release(2);\n\n\n\n",
    "Ch03_fig_006.scd": "\u00ef\u00bb\u00bf\n// Figure 3.6 Using 'messaging style': Score\n\n(\nSynthDef(\"ScoreSine\",{ arg freq = 440;\nOut.ar(0,\n\tSinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)\n)\n}).add;\nx = [\n// args for s_new are synthdef, nodeID, addAction, targetID, synth args ...\n[0.0, [ \\s_new, \\ScoreSine, 1000, 0, 0,  \\freq, 1413 ]],\n[0.5, [ \\s_new, \\ScoreSine, 1001, 0, 0,  \\freq, 712 ]],\n[1.0, [ \\s_new, \\ScoreSine, 1002, 0, 0,  \\freq, 417 ]],\n[2.0, [\\c_set, 0, 0]] // dummy command to mark end of NRT synthesis time\n];\nz = Score(x);\n)\nz.play;\n\n\n",
    "Ch03_fig_007.scd": "\u00ef\u00bb\u00bf// Figure 3.7 Executing one line at a time\n\n(\n// here's a synthdef that allows us to play from a buffer, with a fadeout\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t\t* Linen.kr(gate, doneAction: 2); // release synth when fade done\n\t)\n}).add;\n// load all the paths in the sounds/ folder into buffers\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \n)\n// now here's the score, so to speak\n// execute these one line at a time\n~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[0]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[1]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[2]]);\n~nowPlaying.release;\n// free the buffer memory\n~someSoundsBuffered.do(_.free);\n \n \n\n",
    "Ch03_fig_008.scd": "\u00ef\u00bb\u00bf\n // Figure 3.8 Play cues with a simple GUI\n\n(\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t* Linen.kr(gate, doneAction: 2) * 0.6; \n\t\t// with 'doneAction: 2' we release synth when fade is done\t\n) }).add;\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \nn = 0; // a counter\n// here's our GUI code\nw = Window.new(\"Simple CuePlayer\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\n//this will play each cue in turn\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Play Cue\", Color.black, Color.clear]]).action_({ \n\tif(n < ~someSounds.size, {\n\t\tif(n != 0, {~nowPlaying.release;}); \n\t\t~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[n]]); n=n+1;\n\t});\n}); \n//this sets the counter to the first cue\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Stop / Reset\", Color.black, Color.clear]]).action_({ n=0; ~nowPlaying.release; }); \n// free the buffers when the window is closed\nw.onClose = { ~someSounds.do(_.free); };\n)\n\n\n\n\n\n",
    "Ch03_fig_009.scd": "\u00ef\u00bb\u00bf\n// Figure 3.9 Gathering up files for multichannel cues \n\n// gather all your folder paths\n//this will path match each folder in the collection, i.e. we will have a collection of collections of paths\n\n~groupOfindivCueFolders = \"sounds/*\".pathMatch.collect{ | item |  (item.asSymbol++\"*\").pathMatch };\n\nPost << ~groupOfindivCueFolders;  //see them all !\n\n//check how many cues you will have in the end\n~groupOfindivCueFolders.size; \n\n//automate the buffering process for all cues:\n~bufferedCues = ~groupOfindivCueFolders.collect{|item, i| item.collect{| path |  Buffer.read(s,  path)}}; //now all our cue files are sitting in their buffers ! \n\n~bufferedCues[0];  //here is cue 1\n\n// see it in the post window:\nPost << ~bufferedCues[0];\n\n// play them all in a Group, using our previous synthdef\n// we use bind here to ensure they start simultaneously\n(\ns.bind({\t\n\t~nowPlaying = Group.new(s); // a group to put all the channel synths in\n\t~bufferedCues[0].do({|cue| Synth(\"playbuf\", [buf: cue], ~nowPlaying)})\n});\n)\n// fade them out together by sending a release message to the group\n~nowPlaying.release;\n\n\n\n\n",
    "Ch03_fig_010.scd": "\u00ef\u00bb\u00bf// Figure 3.10 Recording the results of making sounds with supercollider\n\ns.boot; // make sure the server is running\n(  \t// first evaluate this section\nb = Buffer.read(s, \"sounds/a11wlk01.wav\"); // a source\ns.prepareForRecord; // prepare the server to record (you must do this first)\n)\n(\t// simultaneously start the processing and recording\ns.bind({\n\t// here's our funky effect\n\tx = { var columbia, amp; \n\t\tcolumbia = PlayBuf.ar(1, b, loop: 1);\n\t\tamp = Amplitude.ar(columbia, 0.5, 0.5, 4000, 250); // 'sticky' amp follower\n\t\tOut.ar(0, Resonz.ar(columbia, amp, 0.02, 3)) // filter; freq follows amp\n\t\t}.play;\ns.record;\n});\n)\ns.pauseRecording; // pause\ns.record // start again\ns.stopRecording; // stop recording and close the resulting sound file\n\n\n",
    "Ch03_fig_012.scd": "\u00ef\u00bb\u00bf\n// Figure 3.12 A variable number of resonators with an automatically created GUI       \n(\nf = 300;\nn = 30; // number of resonators\nt = Array.fill(n, { |i|\n{\nResonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)\n* n.reciprocal; // scale to ensure no clipping\n}.play;\n});\n\n// now make a GUI\n// a scrolling window so we don't run out of space\nw = Window.new(\"Buttons\", Rect(50, 100, 290, 250), scroll:true);\nw.view.decorator = FlowLayout.new(w.view.bounds); // auto layout the widgets\nn.do({|i|\nButton.new(w, Rect(0, 0, 130, 30)).states_([\n[\"Freq\" + (f * (i + 1)) + \"On\", Color.black, Color.white],\n[\"Freq\" + (f * (i + 1)) + \"Off\", Color.white, Color.black]\n])\n.action_({ arg butt;\nt[i].run(butt.value == 0);\n});\n});\nw.front;\n)\n\n",
    "Ch03_fig_013.scd": "\u00ef\u00bb\u00bf\n// Figure 3.13 Making a stuttering gesture using a geometric pattern\n\n(/* a routine for creating a ritardando stutter with panning, you must have\nrun the code in fig 3.9 so that this routine may find some sounds already loaded into buffers, you can change the index of ~bufferedCues to test the routine on different sounds */\n\n\n~stut = Routine( { var dur, pos;\n~stutPatt = Pseq([Pgeom(0.01, 1.1707, 18), Pn(0.1, 1),Pgeom(0.1, 0.94, 200) ]);\n~str= ~stutPatt.asStream;\n100.do{\n    dur =  ~str.next;\n    dur.postln; \t//so we can check values on the post window\n    ~sample = Synth(\"samplePlayer\",[\\out, 0, \\buf,  ~bufferedCues[0], \\at, 0.1, \\rel, 0.05,\\pSpeed, 0.5]);\n    dur.wait;\n}\n});\n)\n\n//now play it\n~stut.play;\n// reset before you play again!\n~stut.reset; \n \n\n",
    "Ch04_fig_001.scd": "\u00ef\u00bb\u00bfFigure 4.1\nCreate a network address representing sclang itself\n~host = NetAddr(\"localhost\", NetAddr.langPort);\n// Create two OSC responders for the same command\n~r1 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\t[\\responder1, time, message, address].postln;\n\t}\n).add;\n~r2 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\t[\\responder2, time, message, address].postln;\n\t}\n).add;\n\n// Send an OSC message\n~host.sendMsg(\"/testMsg\", \"OSCresponderNode test\");\n\n// Remove responders\n~r1.remove;\n~r2.remove;\n\n\n",
    "Ch05_fig_001.scd": "\u00ef\u00bb\u00bf  Figure 5.1\n1\t\t\t\t\t// the Integer number 1 \n1.234 \t\t\t\t// the floating-point (Float) number 1.234\n$a \t\t\t\t\t// the character (Char) a\n\"hello\"\t\t\t\t// a String (an array of characters) \n\\alpha\t\t\t\t// a Symbol (a unique identifier) \n'alpha 1'\t\t\t\t// another notation for a Symbol\n100@150 \t\t\t\t// a Point defined by coordinates x, y \n[1, \\A, $b] \t\t\t\t// an Array containing 3 elements\n(a: 1, b: 0.2) \t\t\t// an Event \n{ 10.rand }\t\t\t\t// a Function\nString \t\t\t\t// the Class String \nMeta_String \t\t\t// the Class of Class String\n\n\n\n",
    "Ch05_fig_003.scd": "\u00ef\u00bb\u00bfFigure 5.3\n// Boot the default server first:\nServer.default.boot;\n// Then select all lines between the outermost parentheses and run: \n( \t\n{\n\tResonz.ar(GrayNoise.ar,\n\t\tXLine.kr(100, 1000, 10, doneAction: 2), \n\t\tXLine.kr(0.5, 0.01, [4, 7], doneAction: 0)\n\t)\n}.play\n)\n// further examples:\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 3, doneAction: 2)) }.play;\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 0.3, doneAction: 2))}.play;\n\n\n",
    "Ch05_fig_004.scd": "\u00ef\u00bb\u00bfFigure 5.4\n((1 + 2).asString).interpret \t\t// = 3\n\"1\" ++ \"2\". interpret\t\t\t// 12: 2 is translated to string by ++\n(\"1\" ++ \"2\").interpret\t\t\t// 12\n(1.asString ++ 2.asString).interpret \t// 12\n\"1+2\". interpret \t\t\t\t// 3\n(1.asString ++ \"+2\"). interpret\t\t// 3\n(1 + 2).interpret\t\t\t\t// error: interpret not understood by Integer 3\n\n\n",
    "Ch05_fig_005.scd": "\u00ef\u00bb\u00bfFigure 5.5\n(\na = 5;\n5 do: { a = a + 10; a.postln };\nPost << \"The value of variable 'a' is now \" << a << \"\\n\";\n)\n",
    "Ch05_fig_008.scd": "\u00ef\u00bb\u00bfFigure 5.8\n(\n// A window with a button that posts: \"hello there!\"\nvar window, button;\n// create a GUI window and store it in variable window\nwindow = Window.new(\"OLA!\", Rect(200, 200, 120, 120)); \n// create a button in the window and store it in variable button\nbutton = Button.new(window, Rect(10, 10, 100, 100));\nbutton.states = [[\"'ALLO\"]];\t// set one single label for the button\nbutton.action = { \"hello there!\".postln }; // set the action of the button\nwindow.front;\t\t  \t  // show the window\n)\n \n",
    "Ch05_fig_009.scd": "\u00ef\u00bb\u00bfFigure 5.9\n\n( \n// execute this first to boot the server and load the synth definition\nServer.default.waitForBoot({ \n\tSynthDef(\"ping\", { | freq = 440 |\n\t\tOut.ar(0, \n\t\t\tSinOsc.ar([freq, freq * (4/3)], 0,\n\t\t\t\tEnvGen.kr(Env.perc(0.05, 0.3, 0.1, -4), doneAction: 2)\n\t\t\t)\n\t\t)\n\t}).add\n});\n)\n\n(\n// execute this next to create the sounds\nvar countdown = 100;\nvar note = 50;\nvar increment_func, decrement_func;\nvar action;\nincrement_func = {\n\tnote = note + [2, 5, 7, 12].choose;\n\tif (note > 100) { action = decrement_func };\n};\ndecrement_func = {\n\tnote = note - [1, 2, 5, 7, 12].choose;\n\tif (note < 50) { action = increment_func };\n};\naction = increment_func;\n{\n\tcountdown do: { \n\t\tSynth(\"ping\", [\\freq, note.midicps]);\n\t\taction.value;\n\t\t0.1.wait;\n\t}\n}.fork;\n)\n\n",
    "Ch05_fig_011.scd": "\u00ef\u00bb\u00bfFigure 5.11\n// run each line separately: \ncurrentEnvironment;\t// empty if no environment variables have been set\n~alpha = pi;\t\t\t// set env. variable ~alpha to pi\ncurrentEnvironment;\t// see current Environment again: ~alpha is set\n~freq = 800;\t\t\t// set another environment variable\nServer.local.boot;\n{ LFNoise0.ar(~freq, 0.1) }.play; // use an environment variable\n// setting an environment variable to nil is equivalent to removing it: \n~alpha = nil;\ncurrentEnvironment;\t// alpha is no longer set\n\n",
    "Ch05_fig_012.scd": "\u00ef\u00bb\u00bfFigure 5.12\n(\n~q = \"TOP\";\t\t\t\t\t\t\t// store \"TOP\" in ~a, top environment\n(a: \"INNER\") use: { // run function in environment with ~a = \"INNER\"\n\tcurrentEnvironment.postln; // show the current environment\n\ttopEnvironment.postln;\t\t// show the top environment (different!)\n\t~a.postln\t\t\t\t// show ~a's value in current environment\n};\t\n~a;\t\t\t\t\t\t// show ~a's value in top environment\n)\n\n\n",
    "Ch05_fig_013.scd": "\u00ef\u00bb\u00bfFigure 5.13\n(\nvar alpha, beta, gamma;\ngamma = alpha;\t// storing variable alpha in gamma only stores nil \nalpha = 10; \t// store 10 in alpha ...\ngamma.postln;\t// but the value of gamma remains unchanged\nalpha = beta;\t// so one cannot use gamma as 'joker'\nbeta = 20;\t\t// to switch between variables alpha and beta.\ngamma.postln;\t// gamma is still nil.\n)\n\n\n",
    "Ch05_fig_015.scd": "\u00ef\u00bb\u00bfFigure 5.15\nServer.default.boot; \t\t// (boot Server before running example)\n(\n// Define a function and call it in different contexts\nvar synth;\t\t\t\t// Synth creating the sound that is changed\nvar freq = 220; \t\t\t// frequency of the sound\nvar change_freq;\t\t\t// function that changes the frequency of the sound\nvar window;\t\t\t// window holding buttons for changing the sound\nvar button1, button2, button3; // buttons changing the sound\n\n// Create a synth that plays the sound to be controlled:\nsynth = { | freq = 220 | LFTri.ar([freq, freq * 2.01], 0, 0.1) }.play;\n// Create frequency changing function and store it in variable change_freq\nchange_freq = {\t\t\t\t\t\t// start of function definition\n\t\tfreq = freq * [0.9, 0.9.reciprocal].choose; // change freq value\n\t\tsynth.set(\\freq, freq);\t\t\t// set synth's frequency to new value\n};\t\t\t\t\t\t\t\t// end of function definition\n\n// Create 3 buttons that call the example function in various ways\nwindow = Window(\"Buttons Archaic\", Rect(400, 400, 340, 120));\n//  ------------------------- Example 1 -------------------------\nbutton1 = Button(window, Rect(10, 10, 100, 100));\nbutton1.states = [[\"I\"]]; // set the label of button1\n// button1 calls the function each time that it is pressed \nbutton1.action = change_freq;\t// make button1 change freq once\n//  ------------------------- Example 2 -------------------------\nbutton2 = Button(window, Rect(120, 10, 100, 100));\nbutton2.states = [[\"III\"]];\n// Button2 creates a routine that calls the example function 3 times\nbutton2.action = { \t\t\t// make button2 change freq 3 times\n\t{ 3 do: { change_freq.value; 0.4.wait } }.fork; // play as routine\n};\n//  ------------------------- Example 3 -------------------------\nbutton3 = Button(window, Rect(230, 10, 100, 100));\nbutton3.states = [[\"VIII\"]];\nbutton3.action = { \t\t\t// like example 2, but 8 times\n\t{ 8 do: { change_freq.value; 0.1.wait } }.fork; // play as routine\n};\n// use large size font for all buttons:\n[button1, button2, button3] do: _.font_(Font(\"Times\", 32));\n// stop the sound when the window closes: \nwindow.onClose = { synth.free };\nwindow.front; // show the window\n)\n\n\n\n\n",
    "Ch05_fig_018.scd": "\u00ef\u00bb\u00bfFigure 5.18\n(\n// a function that calculates the square of the mean of two numbers\nvar sq_mean;\nsq_mean = { arg a, b; \t// arguments a, b defined in arg statement form\n\t(a + b / 2).squared;\n};\n// calculate the square of the mean of 3 and 1:\nsq_mean.value(3, 1);\n)\n\n\n",
    "Ch05_fig_019.scd": "\u00ef\u00bb\u00bfFigure 5.19\n(\n// a function that calculates the square of the mean of any numbers\nvar sq_mean_all;\nsq_mean_all = { | ... numbers | // using ellipsis and | | argument form\n\t(numbers.sum / numbers.size).squared;\n};\n// calculate the square of the mean of [1, 3, 5, -7]:\nsq_mean_all.(1, 3, 5, -7); // short form: omit message 'value'\n)\n\n",
    "Ch05_fig_020.scd": "\u00ef\u00bb\u00bfFigure 5.20\n(\nvar w_func;\nw_func = { arg message = \"warning!\", bounds = Rect(200, 500, 500, 100);\n\tvar window;\n\twindow = Window(\"message window\", bounds).front;\n\tTextView(window, window.view.bounds.insetBy(10, 10))\n\t\t.string = message;\t\n};\n // provide text, use default bounds\nw_func.(String.new.addAll(Array.new.addAll(\" Major news! \").pyramid(7)));\n)\n\n",
    "Ch05_fig_021.scd": "\u00ef\u00bb\u00bfFigure 5.21\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot!\"], [\"quit!\"]];\nbutton.action = { |me| Server.default perform: [\\quit, \\boot][me.value] };\nwindow.front;\n)\n\n",
    "Ch05_fig_022.scd": "\u00ef\u00bb\u00bfFigure 5.22\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot\"], [\"quit\"]];\nbutton.action = { | me | \n\t[{ \"QUITTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.quit;\n\t},{ \"BOOTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.boot;\n\t}][me.value].value;\n};\nwindow.front;\n)\n\n\n\n",
    "Ch05_fig_023.scd": "\u00ef\u00bb\u00bfFigure 5.23\nServer.default.boot // boot default server before running example\n(\nvar buffer;\nbuffer = Buffer.read(path: \"sounds/a11wlk01.wav\",\n\taction: { | buffer |\n\t\tformat(\"loaded % at: %\", buffer, Main.elapsedTime).postln;\n\t});\nformat(\"Reached this after 'Buffer.read' at: %\", Main.elapsedTime).postln;\nbuffer;\n)\n\n",
    "Ch05_fig_024.scd": "\u00ef\u00bb\u00bfFigure 5.24\nServer.default.boot;  // do this first\n(\t\t\t\t\t\t// then the rest of the program\nvar window, routine;\nwindow = Window(\"close me to stop\").front;\nwindow.onClose = { routine.stop };\nroutine = { \n\tloop {\n\t\t(degree: -10 + 30.xrand, dur: 0.05, amp: 0.1.rand).play;\n\t\t0.05.rand.wait;\n\t}\n}.fork;\n)\n\n\n",
    "Ch05_fig_025.scd": "\u00ef\u00bb\u00bfFigure 5.25\n_.isPrime ! 10\n_.squared ! 10\n_@_.(30, 40) // equivalent to: { | a, b | Point(a, b) }.value(30, 40)\nArray.rand(12, 0, 1000).clump(4) collect: Rect(*_)\n(1..8).collect([\\a, \\b, _]);\n(a: _, b: _, c: _, d: _, e: _).(*Array.rand(5, 0, 100));\n\n",
    "Ch05_fig_026.scd": "\u00ef\u00bb\u00bfFigure 5.26\n(\nvar iterative_factorial;\niterative_factorial = { | n |\n\tvar factorial = 1;\t// initialize factorial as factorial of 1\n\t// calculate factorial n times, updating its value each time\n\tn do: { | i | factorial = factorial * (i + 1) };\n\tfactorial;\t// return the final value of factorial;\n};\niterative_factorial.(10).postln;\t// 10 factorial: 3628800\n)\n\n",
    "Ch05_fig_027.scd": "\u00ef\u00bb\u00bfFigure 5.27\n// Define the factorial function and store it in variable f:\nf = { | x | if ( x > 1) { x * thisFunction.value(x - 1) } { x } };\n f.value(10);\t\t\t// 10 factorial: 3628800\n\n",
    "Ch05_fig_028.scd": "\u00ef\u00bb\u00bfFigure 5.28\n(\t\n/* a function that recursively prints all folders and files\n   found in a path and its subfolders */\n{ | path |\n\t// store function here for use inside the if's {}:\n\tvar thisFunc = thisFunction;\n\tformat(\"====== now exploring: %\", path).postln;\n\t// for all items in the path:\n\tpath.pathMatch do: { | p | \n\t\t// if the item is a folder, run this function on its contents\n\t\t// otherwise print the file found\n\t\tif (p.last == $/) { thisFunc.(p ++ \"*\") }{ p.postln }\n\t}\n}.(\"*\") // run function on home path of SuperCollider\n)\n\n\n",
    "Ch05_fig_029.scd": "\u00ef\u00bb\u00bfFigure 5.29\n(\n// a function that creates a function that counts to any number\nvar counter_maker;\nvar window, button1, button2; // gui for testing the function\n\n// the function that makes the counting function\ncounter_maker = { | max_count |\n\t// current_count is used by the function created below\n\t// to store the number of times that it has run\n\tvar current_count = 0;  \n\t{\t// start of definition of the counting function\n\t\tif (current_count == max_count) {\n\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\tmax_count;\t\t// return max count for eventual use\n\t\t}{\n\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\tcurrent_count\t// return current count for eventual use\n\t\t}\n\t}\t// end of definition of the counting function \n};\n\n//  ----- Test application for the counter_maker function ----- \n// window displaying 2 buttons counting to different numbers\nwindow = Window(\"Counters\", Rect(400, 400, 200, 80));\n// make a button for triggering the counting: \nbutton1 = Button(window, Rect(10, 10, 180, 20));\nbutton1.states = [[\"counting to 10\"]];\t// labels for button1\n// make a function that counts to 10 and store it as action in button1\nbutton1.action = counter_maker.(10);\nbutton2 = Button(window, Rect(10, 40, 180, 20));\nbutton2.states = [[\"counting to 5\"]];\t// labels for button2\n// make a function that counts to 5 and store it as action in button2\nbutton2.action = counter_maker.(5);\nwindow.front;\t\t\t// show the window\n)\n\n",
    "Ch05_fig_031.scd": "\u00ef\u00bb\u00bfFigure 5.31\n(\nvar counter_maker;\t\t// creator of counters\nvar make_counters_gui;\t// function making counters + a gui\n/* a function that creates an event that counts to any number, \n   and resets: */ \ncounter_maker = { | max_count |\n\tvar current_count = 0; \n\t(\t// the counter object is an event with 3 functions: \n\t\tcount1: // function 1: increment count (stored as count1)\n\t\t{\t// start of definition of the counting function\n\t\t\tif (current_count == max_count) {\n\t\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\t}{\n\t\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\t}\n\t\t},\t// end of definition of the counting function\n\t\treset_count: { // function 2: reset count (stored as reset_count)\n\t\t\tformat(\"resetting % counter\", max_count).postln;\n\t\t\tcurrent_count = 0\n\t\t},\n\t\tmax_count: { max_count } // function 3: return value of max_count\n\t)\n};\n// Function that makes several counters and a GUI to control them\nmake_counters_gui = { | ... counts |\n\tvar window, counter;\n\twindow = Window(\"Counters\", \n\t\t\tRect(400, 400, 200, 50 * counts.size + 10));\n\t// enable automatic placement of new items in window: \n\twindow.view.decorator = FlowLayout(window.view.bounds, 5@5, 5@5);\n\tcounts collect: counter_maker.(_) do: { | counter |  \n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Counting to: \" ++ counter.max_count.asString]])\n\t\t\t.action = { counter.count1 };\n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Reset\"]])\n\t\t\t.action = { counter.reset_count };\n\t};\n\twindow.front;\n};\nmake_counters_gui.(5, 10, 27); // example use of the GUI test function\n)\n\n\n\n\n",
    "Ch05_fig_032.scd": "\u00ef\u00bb\u00bfFigure 5.32\nServer.default.boot;\t// boot the server first;\n(\nvar degrees, window, button;\nwindow = Window(\"melodies?\", Rect(400, 400, 200, 200));\nbutton = Button(window, window.view.bounds.insetBy(10, 10));\nbutton.states = [[\"click me to add a note\"]];\nbutton.action = { \n\tdegrees = degrees add: 0.rrand(15);\n\tPbind(\\degree, Pseq(degrees), \\dur, Prand([0.1, 0.2, 0.4], inf)).play;\n};\nwindow.front;\n)\n\n\n",
    "Ch05_fig_034.scd": "\u00ef\u00bb\u00bfFigure 5.34\n1.class \t\t// the class of Integer 1: Integer\n1.class.class \t// the Class of the Class of Integer 1: Meta_Integer\n// the Class of the Class of the Class of Integer 1: \n1.class.class.class  \t\t\t\t\t// Class\n// the Class of the Class of the Class of the Class of Integer 1\n1.class.class.class.class\t\t\t\t// Meta_Class\n// the Class of the Class of the Class of the Class of the Class of 1\n1.class.class.class.class.class \t\t// Class \nClass.class\t\t\t\t// the Class of Class is Meta_Class\nMeta_Class.class\t\t// the Class of Meta_Class is Class\n\n\n",
    "Ch05_fig_036.scd": "\u00ef\u00bb\u00bfFigure 5.36\nCounter { \n\t// variables: maximum count, current count\n\tvar <>max_count, <>current_count = 1;\n\t// class method for creating a new instance\n\t*new { | max_count = 10 |\n\t\t^super.new.max_count_(max_count)\n\t}\n\t// if maximum count not reached, increment count by 1\n\tcount1 {\n\t\tif (current_count >= max_count) {\n\t\t\tthis.changed(\\max_reached)\n\t\t}{\n\t\t\tcurrent_count = current_count + 1;\n\t\t\tthis.changed(\\count, current_count);\n\t\t}\n\t}\n\t// reset count\n\treset {\n\t\tcurrent_count = 1;\n\t\tthis.changed(\\reset);\n\t}\n}\n\n\n",
    "Ch05_fig_037.scd": "\u00ef\u00bb\u00bfFigure 5.37\nServer.default.boot;\n(\nSynthDef(\"ping\", { | freq = 440 | \n\tOut.ar(0, \n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).add;\n\nSynthDef(\"wham\", {\n\tOut.ar(0, BrownNoise.ar(\n\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).add; \n)\n\n\n",
    "Ch05_fig_038.scd": "\u00ef\u00bb\u00bfFigure 5.38\n(\n~sound_adapter =  { | counter, what, count |\n\tswitch (what, \n\t\t\\reset, { Synth(\"wham\"); },\n\t\t\\max_reached, { counter.reset },\n\t\t\\count, { Synth(\"ping\", \n\t\t\t[\\freq, count.postln * 10 + counter.max_count * 20]\n\t\t\t)\n\t\t}\n\t)\n};\n)\n \n\n",
    "Ch05_fig_039.scd": "\u00ef\u00bb\u00bfFigure 5.39\n(\n~make_display = { | counter |\n\tvar window, label, adapter, stagger;\n\twindow = Window(\n\t\t\"counting to \" ++ counter.max_count.asString, \n\t\tRect(stagger = UniqueID.next % 20 * 20 + 400, stagger, 200, 50)\n\t);\n\tlabel = StaticText(window, window.view.bounds.insetBy(10, 10));\n\tadapter = { | counter, what, count |\n\t\t\t{ label.string = counter.current_count.asString }.defer\n\t};\n\tcounter addDependant: adapter;\n\t/* remove the adapter when window closes to prevent error in \n\t   updating non-existent views: */\n\twindow.onClose = { counter removeDependant: adapter };\n\twindow.front\n};\n)\n",
    "Ch06_fig_001.scd": "\u00ef\u00bb\u00bfFigure 6.1.  Example of a SynthDef\nSynthDef(\t\t\t\t\t\n\t\"sine\", \t\t\t\t// name of SynthDef\t\n\t{\t\t\t\t// function begins with a brace\n\t arg gate = 1, out = 0, \t\t// arguments serve as Control declarations\n freq = 400, amp = 0.4,\n pan = 0, ar = 1, dr = 1;\n\n\tvar audio;\t\t\t\n\taudio = SinOsc.ar(freq, 0, amp);\t\t// start with a SinOsc\n\taudio = audio * Linen.kr(gate, ar, 1, dr, 2);\t// apply an envelope\n\taudio = Pan2.ar(audio, pan);\t\t\t// stereo pan, \n\tOffsetOut.ar(out,audio);\t\t\t// to bus out and out+1 \n\t}\n).add;\t\t\t\t// make and store a SynthDesc and SynthDef\n\n\n",
    "Ch06_fig_002.scd": "\u00ef\u00bb\u00bfFigure 6.2. Example of a key/value Array and a note Event=\na = [ \n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n];\n\ne = (\n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n);\ne.play;\t\t\t\t\t// play the note\n\n",
    "Ch06_fig_003.scd": "\u00ef\u00bb\u00bf\nFigure  6.3. The OSC commands created by the note event\ne.asOSC.do{ | osc | osc.postcs };\n\n// the result that would be posted:\t\t\n//  [ 0.0, ['s_new', 'sine', 1000, 0, 1, 'out', 0, 'freq', 400.0, 'amp', 0.1, 'pan', 0, 'ar', 2, 'dr', 4] ]\n//  [ 2.0, [ 'n_set', 1000, 'gate', 0 ] ] \n\n",
    "Ch06_fig_004.scd": "\u00ef\u00bb\u00bfFigure 6.4. Two ways of writing the same Event Pattern\n\t1. Pbind( *[ \n\t\tdur:\t0.2,\nfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t] );\n\n\t2. Pbind( \n\t\t\\dur, 0.2,\n\t\t\\freq, \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t);\n\n",
    "Ch06_fig_005.scd": "\u00ef\u00bb\u00bfFigure 6.5. A more elaborate Event Pattern\np = Pbind(*[ \n\t\tinstrument:\t\\default,\n\t\tdetune:\t\t[0,1,3],\n\t\tfreq: \t\tPseq( (1..11) * 100,  4 * 5 * 7),\n\t\tdb:\t\tPseq([-20, -40, -30, -40], inf),\n\t\tpan:\t\tPseq([-1,0,1,0], inf),\n\t\tdur:\t\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8], inf),\n\t\tlegato:\t\tPseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n// render 40 seconds of the pattern in the file named \"sf.aif\"\t\n\tp.render(\"sounds/sf.aif\", 40)\t\n// now play the pattern in real-time\n\tp.play;\t\t\t\t\t\t\t\t\t\n\n",
    "Ch06_fig_006.scd": "\u00ef\u00bb\u00bfFigure 6.6.  Using Event types\n(\n\t(type: \t\\group, \t\nid: 2\n).play;\t\t\t\t\t// create a group with nodeID 2\n\n\t(\ttype:\t\t\\note, \t\t// play note\t\t\n\t \tsustain:\t100, \t\t// lasting 100 seconds\t\t\t\t\n\t \tgroup: \t\t2\t\t// in group 2\n\n\t ).play;\t\n\t \t\t\t\t\t\t\t\t\t\t\n)\n(\n\t(type: \t\\off, \tid: 2).play;\t\t// release all notes in the group\n\t(type:\t \\kill,\tid: 2,  lag: 3).play;\t// and free the group  3 seconds later\t\n)\n\n\n",
    "Ch06_fig_007.scd": "\u00ef\u00bb\u00bfFigure 6.7. Chord events\n// 2nd inversion - e loudest\n( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -20, -10] ).play\t\t\t\n// 2nd inversion - c loudest\n ( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -10, -20] ).play\t\n// note \"fattened\" by three detuned copies\n ( degree: 0,\t\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// each detune is assigned to a different pitch, fat free.\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// detune rotates through each note in the chord\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,0,0,3,3,3,5,5,5] ).play \t\n\n\n",
    "Ch06_fig_008.scd": "\u00ef\u00bb\u00bfFigure 6.8.  Interdependent key values in a Pattern\n\tPbind(*[\n\t\tstretch:\t\tPseg([0,0.1,0.2,1],8).linexp(0,1, 1,0.125),\n\t\tmidinote: \t\t100.cpsmidi,\n\t\tharmonic:\t\tPwhite(1, 16),\n\t\tlegato:\t\t\tPkey(\\stretch) * Pkey(\\harmonic)/2 ,\n\t\tdb:\t\t\t-10 - Pkey(\\harmonic),\n\t\tdetune:\t\t\tPwhite(0.0,3.0),\n\t\tdur:\t\t\t0.2,\n\t]).play\n\n\n",
    "Ch06_fig_009.scd": "\u00ef\u00bb\u00bfFigure 6.9. Chaining Event Patterns\n\ta = Pbind(*[\n\t\tscale: \tPn( Pstep([[0,2,4,5,7,9,11], [0,1,3,5,6,8,11] ], 5 ) ),\n\t\tdb:\tPn(Pseg([-20, -30, -25, -30], 0.4))\n\t]);\n\tb = Pbind(*[ \ndegree: Pbrown(0, 6, 1), \nmtranspose: Prand([\\rest, Pseq([0], 5.rand)],inf), \ndur: 0.2, \noctave: 6\n]);\n\tc = Pbind(*[ \ndegree: [0,2,4],  \nmtranspose: Pbrown(0, 6, 1), \ndur: 0.4, \ndb: -35\n]);\n\td = Pchain(Ppar([b, c]),a);\nd.play;\n\n",
    "Ch06_fig_010.scd": "\u00ef\u00bb\u00bfFigure 6.10. Using Prout to define and play patterns on the fly\n\tProut({| ev |\n\t\tvar pat, refPat;\n\n\t\trefPat = Pbind(*[dur: 0.2, note: Pseq([0,0, 0, 7,0, 7])]);\n\n\t\tloop {\n\t\t\tev = refPat.embedInStream(ev);\n\n\t\t\tpat = Pbind(*[\n\t\t\t\tdur: [0.2, 0.4].choose,\n\t\t\t\tnote: Pseq(Array.fill(5, { 10.rand }), 3.rand )\n\t\t\t]);\t\nev = pat.embedInStream(ev);\n\t\t}\n\t\n}).play\n\n\n",
    "Ch06_fig_011.scd": "\u00ef\u00bb\u00bfFigure 6.11.  Using Prout to define value and event patterns\n~patA = Pbind(*[\n\tdur:\t0.2,\n\tdegree: Prout({ | ev |\n\t\tvar noteArray  = (0..5);\n\t\tloop {\n\t\t\tev = Pseq(noteArray ).embedInStream(ev);\n\t\t\tnoteArray[6.rand] = 7.rand;\n\t\t}\t\t\n\t})\n]);\n\n\n~patB = Prout({ | ev |\n\tvar pat, pats= [\n\t \tPbind(*[ degree: Pseq([  0, 7]), dur: 0.2   ]),\n\t \tPbind(*[ degree: Pseq([11, 7]), dur: 0.2 ]),\n\t\tPbind(*[ degree: Pseq([16, 7]), dur: 0.2 ]).\n\t\t(type: \\rest, delta: 1)\n\t];\n\t\t\t\n\tloop {\n\t\tpat = pats.choose;\n\t\tev = pat.embedInStream(ev);\n\t}\n});\n\nPchain(\n\tPbind(*[\n\t\tdb: \tPn(Pstep([-15, -25,-25, -20, -30, -25], 0.2) )\n\t\t\t+ Pseg([-30, -5,-10, -40], 12)\n\t]), \n\tPtpar([\n\t\t0, ~patA, \n\t\t0,  ~patA, \n\t\t12,  ~patB\n\t]) \n).play;\n\n",
    "Ch06_fig_012.scd": "\u00ef\u00bb\u00bfFigure 6.12.  Rendering and playing a pattern\n\t~pattern = Pbind(*[ \n\t\tinstrument:\t\"default\",\n\t\tfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100], 5),\n\t\tdb:\tPseq([-10, -30, -20, -30], inf),\n\t\tdur:\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8],inf),\n\t\tlegato: Pseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n\n\t~score = ~pattern.asScore(24 * 11/7);\n\t~score.render(\"recordings/test.aif\");\n\tSoundFile(\"recordings/test.aif\").play;\n\n",
    "Ch06_fig_013.scd": "\u00ef\u00bb\u00bfFigure 6.13. Soundfile granulation with a Pattern \nSynthDef(\"playbuf\", { | out=0, bufnum = 0, rate = 1, \nstartPos = 0, amp = 0.1, sustain = 1, \npan = 0, gate = 1|\n\tvar audio, env;\n\trate = rate * BufRateScale.kr(bufnum);\n\tstartPos = startPos * BufFrames.kr(bufnum);\n\tenv = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: 2);\n\taudio = PlayBuf.ar(1, bufnum, rate, 1, startPos, 0);\n\taudio = env * audio;\n\taudio = Pan2.ar(audio, pan, amp);\n\tOffsetOut.ar(out, audio);\n}).add;\n\t\t\n\tPseq([\n\t\t(\ttype:\t\t\\load,\n\t\t\tfilename:\t\"sounds/a11wlk01.wav\",\n\t\t\tbufnum:\t1,\n\t\t\tdelta:\t\t0\n\t\t),\n\t\t\n\t\tPbind(*[\n\t\t\tinstrument:\t\"playbuf\",\n\t\t\ttype:\t\t\\on,\n\t\t\tid:\t\t-1,\n\t\t\tdur:\t\t Pseg([0,1],21).linexp(0,1,0.01,2),\n\t\t\tlegato:\t\t4,\n\t\t\tstartPos:\tPn(Pseg([0,1], 10)),\n\t\t\tbufnum:\t1,\t\t\n\t\t]),\n\t\t(\ttype:\t\t\\free, \n\t\t\tbufnum: \t1\n\t\t)\n\t]).play(quant: 0) \n// the result: [ ( 'midinote': 60 ), ( 'midinote': 64 ), ( 'midinote': 67 ) ]\n\n",
    "Ch06_fig_014.scd": "\u00ef\u00bb\u00bfFigure 6.14.  Yield versus EmbedInStream\n\tr = Routine{ \n\t\tPseq([1,2,3]).yield; \n\t\tPseq([1,2,3]).embedInStream;\n\t\t123445.embedInStream; \n\t\t123445.embedInStream; \n\t};\n\n\t[next(r), next(r), next(r), next(r), next(r), next(r)];\n\t// the result: [ a Pseq, 1, 2, 3, 123445, 123445, nil]\n\n\n",
    "Ch06_fig_015.scd": "\u00ef\u00bb\u00bfFigure 6.15. The definition of the stream created by Pseq.\n\tRoutine({\n\t\trepeats.value.do({\n\t\t\tlist.size.do({ arg i;\n\t\t\t\titem = list.wrapAt(i + offsetValue);\n\t\t\t\tinval = item.embedInStream(inval);\n\t\t\t});\n\t\t});\n\t});\n\n\n",
    "Ch06_fig_016.scd": "\u00ef\u00bb\u00bfFigure 6.16.  The definition of Event\u00e2\u0080\u0099s play method.\n\tplay {\n\t\tif (parent.isNil) { parent = defaultParentEvent };\n\t\tthis.use { ~play.value };\n\t}\n\n\n",
    "Ch06_fig_017.scd": "\u00ef\u00bb\u00bfFigure 6.17. Definition of the key \\play in the default event\n{\n\tvar tempo, server;\n\t\n\t~finish.value;\t\t\t\t\t\t// user callback \n\tserver = ~server ?? { Server.default };\t \n\ttempo = ~tempo;\t\t\t\t\t// assigning to a variable\n\t\t\t\t\t\t\t\t\t// saves repeated look ups\n\tif (tempo.notNil) {\t\t\t\t\t// if not nil, change tempo of\n\t\tthisThread.clock.tempo = tempo;\t// the clock playing the pattern\n\t};\n\t~eventTypes[~type].value(server);\t\t// select play function from ~type\n}\n\n\n",
    "Ch06_fig_018.scd": "\u00ef\u00bb\u00bfFigure 6.18.  Implementation of the event type \\bus.\n\t{ |server|\n\t\tvar lag, array;\n\t\tlag = ~lag + server.latency;\n\t\tarray = ~array.asArray;\n\t\tserver.sendBundle(lag, \n\t\t\t[\\c_setn, ~out.asUGenInput, array.size] ++ array);\n\t}\n",
    "Ch07_fig_001.scd": "\u00ef\u00bb\u00bf\nFigure 7.1\n(\nTask {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(note: x.postln, dur: 0.125).play;\n\t\t0.125.wait;\n\t}\n}.play\n);\t\t// creates a loop of values\n\n// change x and y\nx = 5;\t// new initial value\ny = 4;\t// new multiplication factor\n\n\n\n",
    "Ch07_fig_002.scd": "\u00ef\u00bb\u00bfFigure 7.2\n(\n{\n\tx = SinOsc.kr(4); \n\ty = SinOsc.kr(13);\n\tSinOsc.ar(x * y % 0.4 * 500 + 600) * 0.2\n}.play;\n)\n\n// change x and y?\nx = SinOsc.kr(4); // no effect.\ny = SinOsc.kr(4); // no effect either.\n\n\n\n",
    "Ch07_fig_003.scd": "\u00ef\u00bb\u00bf\n\n Figure 7.3\n\np = ProxySpace.push;\n~x = { SinOsc.kr(4) }; \n~y = { SinOsc.kr(13) };\n~z = { SinOsc.ar(~x * ~y % 0.4 * 500 + 600) * 0.2 };\n~z.play;\n\n\t\n// now ~x and ~y can be replaced\n~x = { SinOsc.kr(0.4) }; \n~y = { SinOsc.kr(1.3) }; \n\np.clear(2).pop; // release environment (2 sec fadeout)\n\n\n",
    "Ch07_fig_004.scd": "\u00ef\u00bb\u00bf\n\nFigure 7.4\n\np = ProxySpace.push;\t// if needed\n\n~a = { Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2) };\n(\n~b = {\n\tvar c, d;\n\tc = Dust.ar(20 ! 2);\n\td = Decay2.ar(c, 0.01, 0.02, SinOsc.ar(11300));\n\td + BPF.ar(c * 5, ~a.ar * 3000 + 1000, 0.1)\n}\n);\n\n~b.play;\n\n// the refactored code from above\n\n(\n~a = { \n\tvar a;\n\ta =  Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2);\n\tBPF.ar(~c.ar * 5, a * 3000 + 1000, 0.1) \n}\n);\n~c = { Dust.ar(20 ! 2) };\n~d = { Decay2.ar(~c.ar, 0.01, 0.02, SinOsc.ar(11300)) };\n~b = ~a + ~d;\n\n~b.play;\n\n\n\n\n",
    "Ch07_fig_006.scd": "\u00ef\u00bb\u00bfFigure 7.6\n\n// self reference (~x) constructs a loop at control rate \n\n~out.play;\n~x = 0.2; ~a = 1.1; ~c = 0.13;\n~x = (~a * ~x) + ~c % 1.0;  // leaving out the .kr message assumes a control rate ugen.\n\n~out = { Pan2.ar(SinOsc.ar(~x * 4000 + 200) * 0.1, ~x) };\n\n\n",
    "Ch07_fig_007.scd": "\u00ef\u00bb\u00bfFigure 7.7\n\nn = NodeProxy.new;\nx = { SinOsc.ar(n.kr * 200 + 300) * 0.1 }.play;\nn.source = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\nn.clear; x.free;\n\n\n",
    "Ch07_fig_008.scd": "\u00ef\u00bb\u00bfFigure 7.8\n\nNdef(\\out, { SinOsc.ar(Ndef.kr(\\x) * 200 + 300) * 0.1 }).play;\nNdef(\\x, { LFPulse.kr([1.3, 2.1, 3.2]).sum });\nNdef.clear;\n\n",
    "Ch07_fig_009.scd": "\u00ef\u00bb\u00bfFigure 7.9\n\np = ProxySpace.push; // if needed\n~out = { SinOsc.ar(~x.kr * 200 + 300) * 0.1 }\n~out.play;\n~x = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\np.clear.pop;\n\n\n",
    "Ch07_fig_010.scd": "\u00ef\u00bb\u00bfFigure 7.10\n\np.clear; // neutralize space, free all buses and synths\np.push; // if needed\n~a.ar(3); // 3 channels, audio rate\n~b.kr(8); // 8 channels, control rate\n~c.play; // playing an uninitialized proxy assumes (per default) 2 channels, audio rate\n~d = { LFNoise0.kr([1, 1, 1, 1]) }; // 4 channels, control rate\n\n\n",
    "Ch07_fig_011.scd": "\u00ef\u00bb\u00bf\nFigure 7.11\n\n~out.play; ~out.fadeTime = 3;\n(\n// name with a_ represents audio rate argument\n~out = { |freq=440, mod=0.4, detune=0.1, a_in = #[1,1]|\n\tfreq = freq * ([0, detune] + 1);\n\tLFTri.ar(LFTri.ar(mod * freq).range(freq * mod, freq)) * a_in * 0.2\n}\n);\n\n(\n~mod2 = { LFNoise1.kr(1).range(0, 1) };\n~mod1 =  { LFPulse.kr(~mod2.kr * 30 + 1, 0, 0.3) };\n~freq1 = { ~mod1.kr * 13100 + 100 };\n~freq2 = { LFTri.kr(30) * 200 + 300 };\n~audio1 = { BrownNoise.ar(LFClipNoise.kr(10.dup), 1) };\n~audio2 = { SinOsc.ar(LFNoise2.kr(1.dup).exprange(4, 1000)) };\n);\n\n~out.map(\\freq, ~freq2, \\mod, ~mod1);\n~out.set(\\detune, 0.01);\n~out.map(\\freq, ~freq1, \\mod, ~mod1);\n~out.xmap(\\freq, ~freq1, \\mod, ~mod2); // xmap crossfades over fade time to new value.\n~out.xmap(\\freq, ~freq2, \\mod, ~mod1, \\a_in, ~audio2);\n~out.map(\\a_in, ~audio1);\n\n\n",
    "Ch07_fig_012.scd": "\u00ef\u00bb\u00bf\nFigure 7.12\n\n// this synthdef is used in the subsequent figures\n(\nSynthDef(\\wave, { |out, freq=440, amp=0.1, sustain=0.1, mod=0.2|\n\tOffsetOut.ar(out,\n\t\tEnvGen.ar(Env.perc(ExpRand(0.001, 0.05), sustain, amp), doneAction: 2)\n\t\t*\n\t\tSinOsc.ar(freq, SinOsc.ar(sustain.reciprocal * 8, [0, Rand(0, pi)], mod))\n\t)\n}).add\n);\n(\nTdef(\\x, {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(instrument: \\wave, note: x.postln, sustain: 0.5, octave: 6).play;\n\t\t0.125.wait;\n\t}\n}).play\n);\n\n\n",
    "Ch07_fig_013.scd": "\u00ef\u00bb\u00bfFigure 7.13\n\n(\n\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 1500).play; 0.03.wait } });\nTdef(\\b, { [1, 5, 1, 2, 8, 4, 12].do { |x| (instrument: \\wave, note: x + 8).play; 0.1.wait } });\nTdef(\\c, { \"c is just a waiting message\".postln; 2.wait; });\n\n\nTdef(\\x, {\n\tloop {\n\t\tTdef(\\a).embed; // play in sequence\n\t\t1.wait;\n\t\tTdef(\\b).embed;\n\t\t2.wait;\n\t\tTdef(\\a).fork; // play in parallel\n\t\tTdef(\\b).fork;\n\t\tTdef(\\c).embed;\n\t}\n}).play\n);\n\n// rewrite with infinite loop\nTdef(\\a, { inf.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } }); \n// rewrite with finite loop\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } });\n\n\n",
    "Ch07_fig_014.scd": "\u00ef\u00bb\u00bf\nFigure 7.14\n(\nTdef(\\a, { |in|\n\tin.at(\\n).do { |i| \n\t\tin = (instrument: \\wave, detune: 5.rand2).putAll(in);\n\t\tin.postln.play; \n\t\tin.delta.wait;\n\t} \n})\n);\n\n(\nTdef(\\x, { |inevent|\n\tloop {\n\t\tTdef(\\a).embed((note: [15, 17], dur: 0.01, n: 13));\n\t\t1.wait;\n\t\tTdef(\\a).embed((note: 9, dur: 0.4, n: 4));\n\t\t1.wait;\n\t}\n}).play;\n)\n\n\n\n",
    "Ch07_fig_015.scd": "\u00ef\u00bb\u00bf\n\nFigure 7.15\n\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3], inf));\n(\nTask {\n\tvar stream = Pdefn(\\x).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next; \n\t\t(instrument: \\wave, note: val).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\nPdefn(\\x, Pseq([0, 2, 0, 8, 6, 5, 2, 3, 4, 5], inf)); // rewrite the definition at runtime.\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 4, inf));\n\n\n",
    "Ch07_fig_016.scd": "\u00ef\u00bb\u00bfFigure 7.16\n\nPdefn(\\y, Pdefn(\\x) + 2); // derive a transposition\nPdefn(\\z, Pdefn(\\x) + Pseq([0, 5, 0, 7, 2], inf)); // derive a variation\nPdefn(\\a, Ptuple([Pdefn(\\y), Pdefn(\\z)])); // combine them in a stream of arrays\n(\nTask {\n\tvar stream = Pdefn(\\a).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next.postln; \n\t\t(instrument: \\wave, note: val, sustain: rrand(0.5, 0.9)).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\n// rewriting the definitions causes all derivations to vary\nPdefn(\\x, Pseq([0, 11], inf));\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 5, inf));\nPdefn(\\z, Pdefn(\\x) + Pseq([1, 5, 1, 11, 1], inf)); // change a variation\n\nPdefn(\\a, 5); // a number as a source\nPdefn.clear; // clearing all - the empty pattern returns a series of 1. \n\n\n",
    "Ch07_fig_017.scd": "\u00ef\u00bb\u00bfFigure 7.17\n\nPdef(\\a).play; // play silence in sequence\nPdef(\\a, Pbind(\\instrument, \\wave)); // insert a sequence of notes\nPdef(\\a, Pbind(\\instrument, \\wave, \\dur, Pseq([1, 3, 2, 3], inf) / 6)); // add some rhythm\nPdef(\\a).pause;\nPdef(\\a).resume;\nPdef(\\a).stop;\n\n\n",
    "Ch07_fig_018.scd": "\u00ef\u00bb\u00bf\nFigure 7.18\n\n(\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\mod, Pseq([1, 0, 1, 0], inf), \n\t\t\\dur, Pn(1/2, 8),\n\t\t\\note, 7\n\t)\n)\n);\n\n(\nPdef(\\y,\n\tPbindf(\n\t\tPdef(\\x),\n\t\t\\amp, 0.2,\n\t\t\\note, Pshuf([0, 2, 3, 5], 2) + Prand([0, 5, [0, 4]], inf),\n\t\t\\dur, Pseq([1, 3, 2, 3], inf) / 6\n\t)\n)\n);\n\n(\nPdef(\\z, Pbindf(Pdef(\\y), \\dur, 1/4))\n);\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPseq([\n\t\t\tPpar([Pdef(\\x), Pdef(\\y)]),\n\t\t\tPdef(\\x),\n\t\t\tPdef(\\y),\n\t\t\tPdef(\\z),\n\t\t\tPpar([Pdef(\\x), Pbindf(Pdef(\\y), \\ctranspose, 2)])\n\t\t], inf)\n\t)\n);\n))\n\nPdef(\\a).play; // play it\n\n// go into a looping vamp\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], inf) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\n// release a break\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], 1) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\nPdef(\\a).stop; // stop the player\n\n\n\n",
    "Ch07_fig_019.scd": "\u00ef\u00bb\u00bfFigure 7.19\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\b, Pbindf(Pdef(\\y), \\ctranspose, 2));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf).trace) // trace it to post which\n\t)\n).play;\n)\n\n",
    "Ch07_fig_020.scd": "\u00ef\u00bb\u00bf\nFigure 7.20\n\n(\nPdefn(\\sequence, Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pdefn(\\sequence).trace)\n\t)\n).play;\n)\n\n// rewrite the sequence\nPdefn(\\sequence, Pseq([\\x], inf));\nPdefn(\\sequence, Pseq([\\x, \\y, \\x, [\\x, \\y]], inf));\n\nPdef(\\a).stop; // stop playing\n\n\n\n\n",
    "Ch07_fig_021.scd": "\u00ef\u00bb\u00bfFigure 7.21\n\n(instrument: \\x, type: \\phrase).play; // a single phrase from Pdef(\\x)\n\n// a pattern of overlapping phrases\n(\nPbind(\n\t\\type, \\phrase, \n\t\\instrument, \\x, \n\t\\legato, 2.5, \n\t\\note, Pseq([0, 5, 7], inf)\n).play\n);\n\n",
    "Ch07_fig_022.scd": "\u00ef\u00bb\u00bf\nFigure 7.22\n(\nPdef(\\x, { |note=0, n=6, step=3, modulo=15, sustain=1|  \n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\note, note.value + (Pseries(1, step, n) % modulo) + 7, \n\t\t\\dur, sustain.value / n\n\t) \n})\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Pseq([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf)\n\t)\n).play\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Prand([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\recursionLevel, 1,\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf) * 2\n\t)\n).play\n);\n\n\n\n",
    "Ch07_fig_025.scd": "\u00ef\u00bb\u00bf\nFigure 7.25\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\np = ProxySpace.push;\n~z.play;\n\n// A pattern in an audio rate node proxy ...\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), // only non-standard keys, i.e. xfreq \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n~y = { Ringz.ar(~x.ar, 5000 * [1, 1.2], 0.01) }; // resonant filter on the impulses from ~x\n~mod = { LFNoise1.kr(0.1).exprange(200, 5000) }; // a modulator\n~z = { ~y.ar * (SinOsc.ar(~mod.kr) + 1) }; // ring modulation with frequency ~mod\n\n// ... and a control rate node proxy in a pattern.\n// To pass on modulation like this, the standard event parameters like freq cannot be used.\n// Here, we use xfreq instead.\n\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, ~mod, 5, ~mod, 19], inf), // read from the ~mod proxy bus. \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n\n\n\n\n\n",
    "Ch07_fig_026.scd": "\u00ef\u00bb\u00bf\nFigure 7.26\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\nNdef(\\z).play;\n\n// a pattern in an audio rate node proxy ...\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\nNdef(\\y, { Ringz.ar(Ndef(\\x).ar, 5000 * [1, 1.2], 0.01) });\nNdef(\\mod, { LFNoise1.kr(0.1).exprange(200, 5000) });\nNdef(\\z, { Ndef(\\y).ar * (SinOsc.ar(Ndef(\\mod).kr) + 1) }); // ring modulation with Ndef(\\mod)\n\n// ... and a control rate node proxy in a pattern\n\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Ndef(\\mod), 5, Ndef(\\mod), 19], inf), // read from the Ndef(\\mod) proxy bus\n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\n\n\n",
    "Ch07_fig_027.scd": "\u00ef\u00bb\u00bf\nFigure 7.27\n\nNdef(\\x).play; // here an Ndef is used, the same can be done within a ProxySpace\nNdef(\\x, { |freq=5, detune=0| Impulse.ar(freq * [detune, 1 - detune]) * 0.2 });\n(\nTdef(\\c, {\n\tloop {\n\t\t Ndef(\\x).fadeTime = rrand(0.1, 3.5);\n\t\t Ndef(\\x).send([\\freq, exprand(2, 400), \\detune, [0.0, 1.0].choose.rand]);\n\t\t2.wait;\n\t}\n}).play\n);\n\n\n",
    "Ch08_fig_001.scd": "\u00ef\u00bb\u00bf//\tfigure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently\n\n\n\n\n",
    "Ch08_fig_002.scd": "\u00ef\u00bb\u00bf// figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)\n\n\n",
    "Ch08_fig_003.scd": "\u00ef\u00bb\u00bf// figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test\n\n\n",
    "Ch08_fig_004.scd": "\u00ef\u00bb\u00bf//\tfigure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done\n\n\n\n",
    "Ch08_fig_005.scd": "\u00ef\u00bb\u00bf// figure 8.5 - add a pseudo-method.\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin(\"Try showing that.\"); \n\n",
    "Ch08_fig_006.scd": "\u00ef\u00bb\u00bf// figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?\n\n\n",
    "Ch08_fig_007.scd": "\u00ef\u00bb\u00bf// figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00c2\u00a0\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given\n\n\n\n",
    "Ch08_fig_009.scd": "\u00ef\u00bb\u00bf// figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!\n\n\n\n\n",
    "Ch08_fig_010.scd": "\u00ef\u00bb\u00bf\n\t//\tfigure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");\n\n\n",
    "Ch08_fig_011.scd": "\u00ef\u00bb\u00bf\t//\tfigure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;\n\n\n",
    "Ch08_fig_012.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;\n\n",
    "Ch08_fig_013.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");\n\n\n\n",
    "Ch08_fig_014.scd": "\u00ef\u00bb\u00bf\n\t//\tfigure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c2\u00a1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window\n\n\n\n\n\n\n",
    "Ch08_fig_015.scd": "\u00ef\u00bb\u00bf\t//\tfigure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00c2\u00a0\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;\n\n\n\n",
    "Ch08_fig_016.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(Font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));\n\n\n",
    "Ch08_fig_017.scd": "\u00ef\u00bb\u00bf//\tfigure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.\n\n\n\n\n\n\n\n",
    "Ch08_fig_018.scd": "\u00ef\u00bb\u00bf//\tfigure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c2\u00a1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}\n\n\n\n",
    "Ch08_fig_019.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}\n\n\n",
    "Ch08_fig_020.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}\n\n\n\n",
    "Ch08_fig_021.scd": "\u00ef\u00bb\u00bf\n\n// figure 8.21 \u00e2\u0080\u0094 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});\n\n\n",
    "Ch08_fig_023.scd": "\u00ef\u00bb\u00bf// figure 8.23 - two granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\percSin);\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n",
    "Ch08_fig_024.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n",
    "Ch08_fig_025.scd": "\u00ef\u00bb\u00bf// figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n",
    "Ch08_fig_026.scd": "\u00ef\u00bb\u00bf\n\t// figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n",
    "Ch08_fig_027.scd": "\u00ef\u00bb\u00bf\n\t// ex. 8.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n",
    "Ch08_fig_029.scd": "\u00ef\u00bb\u00bf// figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@320))), false).front;\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefGui(tdef, parent: w); \n\n\tw.view.decorator.nextLine;\n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);\n\n\n\n",
    "Ch09_fig_002.scd": "\u00ef\u00bb\u00bffigure 9.2\n\n(\nvar window, slider, mySynth;\nmySynth = Synth(\\default);\nwindow = SCWindow(\"myWindow\", Rect(100,100, 220, 40));\nslider = SCSlider(window, Rect(8,4, 200, 20))\n\t\t.value_(440.explin(20,20000,0,1))\n\t\t.action_({|view| \n\t\t\tmySynth.set(\\freq,\n\t\t\t\tview.value.linexp(0,1,20,20000).postln\n\t\t\t)\t\n\t\t})\n\t\t.onClose_({mySynth.release;});\nwindow.front;\nCmdPeriod.doOnce({window.close});\n)\n\n",
    "Ch09_fig_003.scd": "\u00ef\u00bb\u00bf\nfigure 9.3\n\n(\nvar window, slider, mySynth, spec;\nmySynth = Synth(\\default);\nspec = \\freq.asSpec;\nwindow = SCWindow(\"myWindow\", Rect(100,100, 220, 40));\nslider = SCSlider(window, Rect(8,4, 200, 20))\n\t\t.value_(spec.unmap(440))\n\t\t.action_({|view| \n\t\t\tmySynth.set(\\freq,\t\t\t\n\t\t\t\tspec.map(view.value).postln\n\t\t\t)\n\t\t})\n\t\t.onClose_({mySynth.release;});\nwindow.front;\nCmdPeriod.doOnce({window.close});\n)\n\n",
    "Ch09_fig_005.scd": "\u00ef\u00bb\u00bffigure 9.5\n\n// simple MVC example\n(\nvar window, slider, level, updater, model, numberbox, setValueFunction;\n\n//model\nmodel = (myValue: 1);\nsetValueFunction = {|value| \n\t\t\tmodel [\\myValue] = value; \n\t\t\tmodel.changed(\\value, value);\n};\n\n//view\nwindow = SCWindow(\"myWindow\", Rect(100, 100, 288, 80));\nnumberbox = SCNumberBox(window, Rect(20, 20, 44, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nslider = SCSlider(window, Rect(68, 20, 200, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \n\nlevel = SCLevelIndicator(window, Rect(272, 20, 5, 20))\n\t\t\t.warning_(0.8)\n\t\t\t.critical_(1.0);\n\nwindow.front;\nwindow.onClose_({model.removeDependant(updater);});\n\n//updater\nupdater = {|theChanger, what, val| \n\t\t\t\t\tif(what == \\value, {\n\t\t\t\t\t\tnumberbox.value_(val);\n\t\t\t\t\t\tslider.value_(val);\n\t\t\t\t\t\tlevel.value_(val);\n\t\t\t\t\t});\n\t\t\t\t};\nmodel.addDependant(updater);\n\nsetValueFunction.value(0.4);\n)\n\n\n",
    "Ch09_fig_006.scd": "\u00ef\u00bb\u00bffigure 9.6\n\n(\nvar window;\nwindow = SCWindow(\"AppClock\").front;\nTask({\n\t100.do{|i|\n\t\twindow.view.background_(Color.grey(i/100));\n\t\t0.04.wait;\n\t}\n}).play(AppClock);\n)\n\n",
    "Ch09_fig_007.scd": "\u00ef\u00bb\u00bffigure 9.7\n\n(\nvar window, slider, updater, model, level, numberbox, setValueFunction, oscresponder;\n\n//model\nmodel = (myValue: 1);\nsetValueFunction = {|value| \n\t\t\tmodel [\\myValue] = value; \n\t\t\tmodel.changed(\\value, value);\n};\n\n//view\nwindow = SCWindow(\"myWindow\", Rect(100,100, 288, 80));\nnumberbox = SCNumberBox(window, Rect(20, 20, 44,20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nslider = SCSlider(window, Rect(68,20, 200, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nlevel = SCLevelIndicator(window, Rect(272, 20, 5, 20))\n\t\t\t.warning_(0.8)\n\t\t\t.critical_(1.0);\n\t\nwindow.front;\nwindow.onClose_({model.removeDependant(updater); oscresponder.remove;});\n\n//updater\nupdater = {|theChanger, what, val| \n\t\t\t\t\t{\n\t\t\t\t\tif(what == \\value, {\n\t\t\t\t\t\tnumberbox.value_(val);\n\t\t\t\t\t\tslider.value_(val);\n\t\t\t\t\t\tlevel.value_(val);\n\t\t\t\t\t});\n\t\t\t\t\t}.defer;\n\t\t\t\t};\nmodel.addDependant(updater);\n\n// play a Synth on the server\nSynthDef(\"send_trig\",{\n\tSendTrig.kr(Dust.kr(2.0), 0, LFNoise1.kr(1, 0.5, 0.5));\n}).play(s);\n\n// register to receive the message from the Synth above and let it set the model\noscresponder = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;\n\tsetValueFunction.value(msg[3]);\n}).add;\n\n)\n\n",
    "Ch09_fig_008.scd": "\u00ef\u00bb\u00bf\nfigure 9.8\n\n(\nvar window, button, composite, slider, numberbox;\nwindow = SCWindow(\"myWindow\", Rect(100,100, 288, 80));\nbutton = SCButton(window, Rect(4,4, 100, 20))\n\t\t\t.states_([[\"hide\"], [\"show\"]])\n\t\t\t.action_({|v| \n\t\t\t\tif(v.value==0){\n\t\t\t\t\tcomposite.visible_(true)\t\n\t\t\t\t}{\n\t\t\t\t\tcomposite.visible_(false)\n\t\t\t\t}\n\t\t\t});\n\ncomposite = SCCompositeView(window, Rect(0, 40, 268, 28))\n\t\t\t.background_(Color.blue);\nnumberbox = SCNumberBox(composite, Rect(4, 4, 40,20));\nslider = SCSlider(composite, Rect(48,4, 200, 20));\n\t\nwindow.front;\n)\n\n",
    "Ch09_fig_010.scd": "\u00ef\u00bb\u00bf\nfigure 9.10\n\n(\nvar window, listView, updater, changeItemGui, model;\n\nmodel = [\\item1, \\item2, \\item3];\n\nwindow = SCWindow(\"double click example\", Rect(200,200,180, 320)).front;\nlistView = SCListView(window, Rect(4,4,172, 310))\n\t\t\t\t.items_(model)\n\t\t\t\t.mouseDownAction_({|view, x, y, modifiers, buttonNumber, clickCount|\n\t\t\t\t\tif(clickCount == 2){\n\t\t\t\t\t\tchangeItemGui.value(view)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.onClose_({model.removeDependant(updater)});\n\nchangeItemGui = {|view|\n\tvar win;\n\twin = SCWindow(\"chnage item\", Rect(200,250, 150, 30)).front;\n\tSCTextField(win, Rect(4,4, 142, 20))\n\t\t.string_(view.item.asString)\n\t\t.action_({|v|\n\t\t\tmodel[view.value] = v.string.asSymbol;\n\t\t\tmodel.changed(\\value);\n\t\t\twin.close;\n\t\t})\n\t\t.focus;\n};\n\nupdater = {|theChanger, what, moreArgs|\n\tlistView.items_(theChanger)\n};\nmodel.addDependant(updater);\n\n)\n\n",
    "Ch09_fig_011.scd": "\u00ef\u00bb\u00bf\nfigure 9.11\n\n(\n\tvar window, listViews, model, updater;\n\t\n\tmodel = (\tleft: [ \"SinOsc\", \"Saw\", \"LFSaw\", \"WhiteNoise\", \"PinkNoise\", \"BrownNoise\", \"Osc\" ], \n\t\t\t\tright: []);\n\t\n\twindow = SCWindow(\"list view drag & drop\", Rect(200,200, 255, 100)).front;\n\twindow.view.decorator_(FlowLayout(window.view.bounds));\n\t\n\tlistViews = [\\left, \\right].collect{|it|\n\t\tSCListView(window, Rect(10,10,120,70))\n\t\t\t.items_(model[it])\n\t\t\t.canReceiveDragHandler_{ SCView.currentDrag.isKindOf(Symbol) or: SCView.currentDrag.isKindOf(String)}\n\t\t\t.receiveDragHandler_{|v| \n\t\t\t\tvar index;\n\t\t\t\tindex = model[it].indexOfEqual(SCView.currentDrag);\n\t\t\t\tif(index.notNil){\n\t\t\t\t\tv.value_(index);\n\t\t\t\t}{\n\t\t\t\t\tmodel[it] = model[it].add(SCView.currentDrag);\n\t\t\t\t\tmodel.changed(it);\n\t\t\t\t\tv.value_(v.items.size-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t.beginDragAction_{|v| v.item}\n\t\t\t.action_({|view|\n\t\t\t\t[view.value, view.item].postln;\n\t\t\t})\n\t\t\t.onClose_({model.removeDependant(updater)});\n\t};\n\t\n\tupdater = {|theChanger, what, moreArgs| \n\t\t\tswitch(what, \n\t\t\t\t\\left, {listViews[0].items_(model[\\left])},\n\t\t\t\t\\right, {listViews[1].items_(model[\\right])}\n\t\t\t)\n\t\t\t};\n\tmodel.addDependant(updater);\n)\n",
    "Ch09_fig_013.scd": "\u00ef\u00bb\u00bf\nfigure 9.13\n\n\n(\nvar window, userView, value=false;\nwindow = SCWindow(\"toggle view\", Rect(200,200, 166, 66)).front;\nuserView = SCUserView(window, Rect(10,10, 40,40))\n\t\t\t\t.drawFunc_({|v|\n\t\t\t\t\tvar width, height, offset=2;\n\t\t\t\t\twidth =  v.bounds.width;\n\t\t\t\t\theight = v.bounds.height;\n\t\t\t\t\tSCPen.use{\n\t\t\t\t\t\t//draw outline and background\n\t\t\t\t\t\tSCPen.strokeRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\t\t\t\t\t\tSCPen.fillColor_(Color.white);\n\t\t\t\t\t\tSCPen.fillRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\n\t\t\t\t\t\tif(value){\n\t\t\t\t\t\t\t//draw the toggle cross\n\t\t\t\t\t\t\tSCPen.line(Point(offset, height-offset), Point(width-offset, offset));\n\t\t\t\t\t\t\tSCPen.line(Point(offset, offset), Point(width-offset, height-offset));\n\t\t\t\t\t\t\tSCPen.stroke;\n\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t//switch states on mouse-down\n\t\t\t\t.mouseDownAction_({|view|\n\t\t\t\t\tvalue = value.not;\n\t\t\t\t\tview.refresh;\n\t\t\t\t});\n~win = window;\n)\n\n\n\n",
    "Ch09_fig_014.scd": "\u00ef\u00bb\u00bffigure 9.14\n\nTToggle : SCUserView{\n\tvar <> value=false;\n\t\n\tinit{ arg argParent, argBounds;\n\t\tsuper.init(argParent, argBounds);\n\t\tbackground = Color.white\n\t}\n\t\n\t*viewClass{\n\t\t^SCUserView\n\t}\n\t\n\tdraw{\n\t\tvar width, height, offset=2;\n\t\twidth =  this.bounds.width;\n\t\theight = this.bounds.height;\n\t\tSCPen.use{\n\t\t\t//draw outline and background\n\t\t\tSCPen.strokeRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\t\t\tSCPen.fillColor_(Color.white);\t\t\t\t\n\t\t\tSCPen.fillRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\n\t\t\tif(value){\n\t\t\t\t//draw the toggle cross\n\t\t\t\tSCPen.line(Point(offset, height-offset), Point(width-offset, offset));\n\t\t\t\tSCPen.line(Point(offset, offset), Point(width-offset, height-offset));\n\t\t\t\tSCPen.stroke;\n\n\t\t\t};\n\t\t}\n\t}\n\t\n\t//override \n\tmouseDown{arg x, y, modifiers, buttonNumber, clickCount;\n\t\tvalue = value.not;\n\t\tthis.refresh;\n\t\tmouseDownAction.value(this, x, y, modifiers, buttonNumber, clickCount);\t\n\t}\n}\n",
    "Ch09_fig_016.scd": "\u00ef\u00bb\u00bf\nfigure 9.16\n\n(\nvar createGUIFor, synthDefName, eventForSynthDef;\nsynthDefName = \\default;\nSynthDescLib.global.read;\n\n//create a custom ControlSpec if necessary:\nControlSpec.specs.put(\\out, ControlSpec(0, 128, \\lin, 1, 0));\n\n//model \n\neventForSynthDef = {|synthDefName|\n\tvar event, node;\n\tevent = (\n\t\t\tinstrument: synthDefName,\n\t\t\tplay: {\n\t\t\t\tvar args = event.select{|it| it.isKindOf(Number)}.asKeyValuePairs;\n\t\t\t\tnode = Synth(~instrument, args);\n\t\t\t\t\tOSCpathResponder(Server.default.addr, [\"/n_end\", node.nodeID], \n\t\t\t\t\t\t{|time, resp, msg| \n\t\t\t\t\t\t\tnode = nil;\n\t\t\t\t\t\t\tevent.changed(\\play, 0); \n\t\t\t\t\t\t\tresp.remove;\n\t\t\t\t\t\t} \n\t\t\t\t\t).add;\t\t\n\t\t\t\tevent.changed(\\play, 1);\n\t\t\t\t\n\t\t\t},\n\t\t\tstopPlaying:{\n\t\t\t\tif( SynthDescLib.global[synthDefName].hasGate) {\n\t\t\t\t\tnode.release;\n\t\t\t\t}{\n\t\t\t\t\tnode.free;\t\t\t\t\t\n\t\t\t\t};\n\t\t\t\tnode = nil;\n\t\t\t\tevent.changed(\\play, 0);\n\t\t\t\t\n\t\t\t},\n\t\t\tsetArg: {|inevent, argName, value|\n\t\t\t\tinevent.use{\n\t\t\t\t\tif(node.notNil){\n\t\t\t\t\t\tnode.set(argName, value);\n\t\t\t\t\t};\n\t\t\t\t\tinevent.put(argName.asSymbol, value);\n\t\t\t\t\tinevent.changed(argName.asSymbol);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t);\n\tSynthDescLib.global[synthDefName.asSymbol].controls.do{|it|\n\t\tevent.put(it.name.asSymbol, it.defaultValue);\n\t};\n\tevent\n};\n\ncreateGUIFor = {|event, window|\n\tvar controlNames, playButton, height, updater, funcDict;\n\n\t//GUI\n\t\t\n\tcontrolNames = SynthDescLib.global[event[\\instrument]].controls;\n\t\n\theight = controlNames.size * 24 +40;\n\t\n\twindow = SCWindow(\"myWindow\", Rect(100,100, 328, height));\n\twindow.view.decorator_(FlowLayout(window.view.bounds));\n\t\n\tSCStaticText(window, 80@20).string_(event[\\instrument].asString);\n\t\n\tplayButton = SCButton(window, 120@20)\n\t\t\t.states_([[\"play\"],[\"stop\"]])\n\t\t\t.action_({|view| \n\t\t\t\tif(view.value==1){\n\t\t\t\t\tevent.play;\t\n\t\t\t\t}{\n\t\t\t\t\tevent.stopPlaying;\n\t\t\t\t}\n\t\t\t});\n\t\n\tfuncDict = IdentityDictionary.new;\n\t\n\t//register button in funcDict\n\tfuncDict.put(\\play, {|value| {playButton.value_(value)}.defer});\t\n\t\n\twindow.view.decorator.nextLine;\n\t\n\t//create sliders\n\t\n\tcontrolNames.do{|control, i| \n\t\tvar spec, name, action, initValue, slider;\n\t\tname = control.name;\n\t\tspec = name.asSymbol.asSpec ? [0,1].asSpec;\n\t\taction = {|view| event.setArg(name, view.value)};\n\t\tinitValue = control.defaultValue;\n\t\tslider = EZSlider(window, 300@20, name, spec, action, initValue);\n\t\twindow.view.decorator.nextLine;\n\t\t\n\t\t//register slider at controller\n\t\t\n\t\tfuncDict.put(control.asSymbol, {|value|\n\t\t\t{\n\t\t\t\tslider.value_(spec.unmap(value));\n\t\t\t}.defer\n\t\t})\n\t};\n\t\n\t// updater\n\tupdater = {|theChanger, what, value|\n\t\tfuncDict[what].value(value);\n\t};\n\tevent.addDependant(updater);\n\t\n\twindow.front;\n\twindow.onClose_{event.stopPlaying; event.removeDependant(updater)};\n\t\n\n};\n\n//evaluate the GUI function \n\ncreateGUIFor.value(eventForSynthDef.(synthDefName));\n)\n\n",
    "Ch09_fig_018.scd": "\u00ef\u00bb\u00bf\nfigure 9.18\n\n(\nvar window, button, createSingletonFunc, singletonWindow;\n\ncreateSingletonFunc = {|view|\n\tif(singletonWindow.isNil){\n\t\tsingletonWindow = SCWindow(\"singleton\").front\n\t\t\t.onClose_({singletonWindow = nil});\n\t}{\n\t\tsingletonWindow.front;\n\t}\n};\n\nwindow = SCWindow(\"open Singleton\", Rect(300,300, 200, 40)).front;\nbutton = SCButton(window, Rect(4,4,192, 30))\n\t\t\t.states_([[\"singleton\"]])\n\t\t\t.action_(createSingletonFunc);\n)\n\n",
    "Ch09_fig_020.scd": "\u00ef\u00bb\u00bf\nfigure 9.20\n\n(\nvar k;\nk= KeyCodeResponder.new;\n//  shift control p\nk.register(   35  ,   true, false, false, true, {\n\tCocoaDialog.getPaths({|paths|\n\t\tDocument.current.selectedString_(paths[0].asCompileString);\n\t});\n});\nDocument.globalKeyDownAction_(k)\n)\n\n",
    "Ch10_fig_001.scd": "\u00ef\u00bb\u00bfFigure 10.1\n\n// boot the sound synthesis server and prepare a SynthDef for buffer playback\n(\ns.waitForBoot({\n    SynthDef( \\bufPlay, { arg buf, amp = 1.0, speed = 1.0;\n        Out.ar( 0, Pan2.ar( \nPlayBuf.ar( 1, buf, speed * BufRateScale.kr( buf ), loop: 1 ) * amp )\n);\n    }).add;\n    ~buf = Buffer.read( s, \"sounds/a11wlk01.wav\" );\n});\n)\n\n// now replace the action function\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf ]);\n    }, {\n        ~node.free; ~node = nil;\n    })\n};\n)\n\n",
    "Ch10_fig_002.scd": "\u00ef\u00bb\u00bfFigure 10.2\n\n~amp   = 0.5;  // initial amplitude\n~speed = 1.0;  // initial speed (1.0 is normal, 0.5 is half-speed, etc.)\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf, \\amp, ~amp, \\speed, ~speed ]);\n    }, {\n        ~node.free; ~node = nil;\n    })};\n)\n~win.setInnerExtent( 370, 72 );  // more suitable dimensions for the window\n~win.resizable = false;\nJSCStaticText( ~win, Rect( 56, 4, 50, 25 )).align_( \\right ).string_( \"Amp:\" );\n(\n~ampSlider = JSCSlider( ~win, Rect( 110, 4, 200, 25 ))\n    .value_( ~amp ) // initial slider position\n    .action_({ arg view;\n        ~amp = view.value;\n        ~node.set( \\amp, ~amp );\n    });\n)\nJSCStaticText( ~win, Rect( 56, 32, 50, 25 )).align_( \\right ).string_( \"Speed:\" );\n~speedSpec = ControlSpec( 1/8, 8, \\exp );\n(\n~speedSlider = JSCSlider( ~win, Rect( 110, 32, 200, 25 ))\n    .value_( ~speedSpec.unmap( ~speed ))  // initial slider position\n    .action_({ arg view;\n        ~speed = ~speedSpec.map( view.value );\n        ~node.set( \\speed, ~speed );\n    });\n) \n\n",
    "Ch10_fig_004.scd": "\u00ef\u00bb\u00bfFigure 10.4\n\n~node.free; ~node = nil;\n\n(\n~model        = Event.new;\n~model.amp    = ~amp;\n~model.speed  = ~speed;\n~model.node   = ~node;\n~model.buf    = ~buf;\n~model.adjust = { arg mod, key, value, source;\n    mod.put( key, value );\n    mod.changed( key, value, source )};\n\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\amp, value )}, \\amp );\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\speed, value )}, \\speed );\n\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~model.node = Synth( \\bufPlay, [\n            \\buf, ~model.buf, \\amp, ~model.amp, \\speed, ~model.speed ]);\n    }, {\n        ~model.node.free; ~model.node = nil;\n    })};\n~ampSlider.action   = { arg view;\n    ~model.adjust( \\amp, view.value, view )};\n~speedSlider.action = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( view.value ), view )};\n)\n\n",
    "Ch10_fig_005.scd": "\u00ef\u00bb\u00bfFigure 10.5\n\n(\n~ampText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 4, 50, 25 ));\n~ampTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~ampText.string = \"% dB\".format( value.ampdb.round( 0.1 ))}, \\amp );\n~speedText = JSCStaticText( ~win, Rect( ~speedSlider.bounds.right + 2, 32, 50, 25 ));\n~speedTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~speedText.string = \"%\\\\%\".format( (value * 100).round( 0.1 ))}, \\speed );\n)\n// note: the sliders must be initially dragged to cause view updates!\n\n",
    "Ch10_fig_007.scd": "\u00ef\u00bb\u00bfFigure 10.7\n\n(\n~ampSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~ampSlider, {\n        ~ampSlider.value = value;\n    })}, \\amp );\n~speedSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~speedSlider, {\n        ~speedSlider.value = ~speedSpec.unmap( value );\n    })}, \\speed );\n)\n\n",
    "Ch10_fig_010.scd": "\u00ef\u00bb\u00bfFigure 10.10\n\n// ~win = JSCWindow.new;\n[ \"/local\", 1000, \"[\", \"/new\", \"de.sciss.swingosc.Frame\", \"panel\", \"[\", \"/new\", \"java.awt.Rectangle\", 128, 64, 400, 400, \"]\", 0, \"]\" ]\n[ \"/local\", \"ac1000\", \"[\", \"/new\", \"de.sciss.swingosc.WindowResponder\", \n1000, \"]\", 1001, \"[\", \"/method\", 1000, \"getContentPane\", \"]\" ]]\n[ \"/local\", \"key1001\", \"[\", \"/new\", \"de.sciss.swingosc.KeyResponder\", 1001,\n\"]\" ]\n[ \"/local\", \"cmp1001\", \"[\", \"/new\", \"de.sciss.swingosc.ComponentResponder\",\n1001, \"]\" ]]\n\t\t\n// ~win.front;\n[ \"/set\", 1000, \"visible\", 1 ]\n[ \"/method\", 1000, \"toFront\" ]]\n\n// ~playButton = JSCButton( ~win, Rect( 4, 4, 40, 56 ));\n[ \"/local\", 1002, \"[\", \"/new\", \"de.sciss.gui.MultiStateButton\", \"]\", \n\"ac1002\", \"[\", \"/new\", \"de.sciss.swingosc.ActionResponder\", 1002, \"[\",\n\"/array\", \"selectedIndex\", \"lastModifiers\", \"]\", \"]\" ]\n[ \"/set\", 1002, \"bounds\", \"[\", \"/new\", \"java.awt.Rectangle\", 1, 1, 46, 62,\n\"]\", \"font\", \"[\", \"/ref\", \"font\", \"]\" ]\n[ \"/local\", \"dnd1002\", \"[\", \"/new\", \n\"de.sciss.swingosc.DummyTransferHandler\", 1002, 2, \"]\" ]\n[ \"/local\", \"key1002\", \"[\", \"/new\", \"de.sciss.swingosc.KeyResponder\", 1002,\n\"]\" ]\n[ \"/local\", \"cmp1002\", \"[\", \"/new\", \"de.sciss.swingosc.ComponentResponder\",\n1002, \"]\" ]]\n[ \"/method\", 1001, \"add\", \"[\", \"/ref\", 1002, \"]\" ]\n[ \"/method\", 1001, \"revalidate\" ],\n[ \"/method\", 1001, \"repaint\" ]]\n\n// ~playButton.states = [[ \"Play\", Color.white, Color.green( 0.4 )],\n//                       [ \"Stop\", Color.white, Color.red ]];\n[ \"/method\", 1002, \"removeAllItems\" ]\n[ \"/method\", 1002, \"addItem\", \"Play\", \"[\", \"/new\", \"java.awt.Color\", 1.0, \n1.0, 1.0, 1.0, \"]\", \"[\", \"/new\", \"java.awt.Color\", 0.0, 0.4, 0.0, 1.0,\n\"]\" ]\n[ \"/method\", 1002, \"addItem\", \"Stop\", \"[\", \"/new\", \"java.awt.Color\", 1.0, \n1.0, 1.0, 1.0, \"]\", \"[\", \"/new\", \"java.awt.Color\", 1.0, 0.0, 0.0, 1.0,\n\"]\" ]]\n\n",
    "Ch10_fig_011.scd": "\u00ef\u00bb\u00bfFigure 10.11\n\n[ \"/component\", 1001, \"resized\", 0, 0, 400, 400 ]\n[ \"/window\", 1000, \"opened\" ]\n[ \"/window\", 1000, \"activated\" ]\n[ \"/window\", 1000, \"gainedFocus\" ]\n[ \"/window\", 1000, \"resized\", 128, 414, 400, 421 ]\n[ \"/component\", 1001, \"resized\", 0, 0, 400, 399 ]\n[ \"/window\", 1000, \"moved\", 128, 414, 400, 421 ]\n[ \"/window\", 1000, \"lostFocus\" ]\n[ \"/window\", 1000, \"deactivated\" ]\n\n",
    "Ch10_fig_013.scd": "\u00ef\u00bb\u00bfFigure 10.13\n\n(\n~mySlider            = Event.new;\n~mySlider.view       = JSCUserView( ~win, Rect( 110, 32, 200, 145 )).focusVisible_( false );\n~mySlider.pos        = ~speedSpec.unmap( ~model.speed );\n// these will be used in the final draw func:\n~mySlider.pressed    = false;\n~mySlider.project    = false;\n// this will update the slider position and refresh the view:\n~mySlider.adjustPos  = { arg slid, pos;\n    slid.pos         = pos;\n    slid.view.action.value( slid );\n    slid.view.refresh };\n// these will set the slider track curve and refresh the view:\n~mySlider.adjustCurve= { arg slid, curve;\n    slid.curve       = curve;\n    slid.lines       = curve.slide( 2, 1 ).clump( 2 );\n    slid.lineLens    = slid.lines.collect({ arg pair; pair[ 0 ].dist( pair[ 1 ])}).normalizeSum; \n    slid.projections = nil;\n    slid.view.refresh };\n// a primary draw function just to indicate the view's bounds:\n~mySlider.view.drawFunc = { arg view; var b = view.bounds;\n    JPen.line( 0 @ 0, b.width @ b.height );\n    JPen.line( 0 @ b.height, b.width @ 0 );\n    JPen.stroke };\n// make the window a little bigger:\n~win.setInnerExtent( 370, 180 );\n)\n\n",
    "Ch10_fig_014.scd": "\u00ef\u00bb\u00bfFigure 10.14\n\n(\n~mySlider.adjustCurve([ 0 @ 0, 0.25 @ 1, 0.5 @ 0, 1.0 @ 0.5 ]);\n~mySlider.view.drawFunc = { arg view;\n    var b, scale, lnP1, lnP2, linePos, proj, inner, sum = 0;\n    b     = view.bounds;\n    // scaling factor for coordinates normalized to 0...1\n    scale = b.width @ b.height;\n    // set the initial curve coordinate\n    JPen.moveTo( ~mySlider.curve[ 0 ] * scale );\n    (1..(~mySlider.curve.size-1)).do({ arg i;\n        // create the curve by adding successive line segments\n        JPen.lineTo( ~mySlider.curve[ i ] * scale );\n    });\n    // stroke the curve with a 2-pixel wide black pen\n    JPen.width = 2;\n    JPen.color = Color.black;\n    JPen.stroke;\n    // draw the knob: iterate over the line segments until\n    // the one is found inside which the knob (read from ~mySlider.pos)\n    // is located.\n    block { arg break;\n        ~mySlider.lineLens.do({ arg len, i;\n            // if we have found the line segment...\n            if( sum + len >= ~mySlider.pos, {\n                // calucate the point inside this segment\n                // (proj) and draw a filled circle around it\n                #lnP1, lnP2    = ~mySlider.lines[ i ];\n                linePos        = (~mySlider.pos - sum) / len;\n                proj           = lnP1 + ((lnP2 - lnP1) * linePos);\n                JPen.fillOval( Rect.aboutPoint( proj * scale, 8, 8 ));\n                // if this view is focused, use blue color, otherwise grey\n                JPen.fillColor = Color.hsv( 0.7, view.hasFocus.if( 0.7, 0.0 ), 1.0 );\n                // if the mouse is pressed, the outline should be thicker\n                inner          = if( ~mySlider.pressed, 5, 7 );\n                JPen.fillOval( Rect.aboutPoint( proj * scale, inner, inner ));\n                break.value;\n            });\n            sum = sum + len;\n        });\n    };\n    \n    // a debugging utility to visualize the point projections\n    // of the mouse dragging\n    if( ~mySlider.project, {\n        ~mySlider.projections.do({ arg pt;\n            pt = pt * scale;\n            JPen.line( pt + (-5 @ -5), pt + (5 @  5) );\n            JPen.line( pt + (-5 @  5), pt + (5 @ -5) );\n        });\n        JPen.width = 1; JPen.stroke;\n    });\n};\n)\n\n",
    "Ch10_fig_015.scd": "\u00ef\u00bb\u00bfFigure 10.15\n\n(\nvar mouseFunc = { arg view, x, y, modifiers, buttonNumber, clickCount;\n    var b, nx, ny, dx, dy, lnP1, lnP2, linePos, lineLenSq,\n        proj, dist, sum = 0, minDist = inf, newValue;\n    \n    b  = view.bounds;\n    nx = x / b.width;\n    ny = y / b.height;\n    ~mySlider.projections = Array( ~mySlider.lines.size );\n    // look up the line segment which is closest to the mouse\n    ~mySlider.lines.do({ arg pair, i;\n        #lnP1, lnP2 = pair;\n        dx          = lnP2.x - lnP1.x;\n        dy          = lnP2.y - lnP1.y;\n        lineLenSq   = (dx*dx) + (dy*dy);\n        dist        = (((nx - lnP1.x) * dx) + ((ny - lnP1.y) * dy)) / lineLenSq;\n        proj        = (lnP1.x + (dist * dx)) @ (lnP1.y + (dist * dy));\n        if( lnP1.x != lnP2.x, {\n            linePos = (proj.x - lnP1.x) / dx;\n        }, {\n            linePos = (proj.y - lnP1.y) / dy;\n        });\n        if( linePos < 0, {\n            proj = lnP1;\n        }, { if( linePos > 1, {\n            proj = lnP2;\n        })});\n        ~mySlider.projections.add( proj );\n        dist = proj.dist( nx @ ny );\n        if( dist < minDist, {\n            newValue = sum + (linePos.clip( 0, 1 ) * ~mySlider.lineLens[i]);\n            minDist  = dist;\n        });\n        sum = sum + ~mySlider.lineLens[ i ];\n    });\n    ~mySlider.pressed = true;\n    ~mySlider.adjustPos( newValue );\n};\n~mySlider.view.mouseDownAction = mouseFunc;\n~mySlider.view.mouseMoveAction = mouseFunc;\n~mySlider.view.mouseUpAction   = { arg view; ~mySlider.pressed = false; view.refresh };\n~mySlider.view.action          = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( ~mySlider.pos ), ~mySlider )};\n)\n\n",
    "Ch10_fig_017.scd": "\u00ef\u00bb\u00bfFigure 10.17\n\n(\n~action = { arg fileName; \"Selected file is '%'\\n\".postf( fileName )};\n~sResp  = JavaObject( \"de.sciss.swingosc.ActionResponder\", nil, ~fileChooser.id );\n~cResp  = OSCpathResponder( g.addr, [ '/action', ~fileChooser.id ], {\n    fork { var file, fileName;\n        file     = ~fileChooser.getSelectedFile__;\n        fileName = file.getAbsolutePath_;\n        file.destroy;\n        ~action.value( fileName.asString );\n    };\n}).add;\n)\n\n",
    "Ch10_fig_018.scd": "\u00ef\u00bb\u00bfFigure 10.18\n\n(\n~cp.remove( ~fileChooser );\n~frame.dispose;\n~cp.destroy; ~frame.destroy;\n~win.setInnerExtent( 760, 340 );   // again a bit bigger\n~plug = JSCPlugView( ~win, Rect( 370, 2, 386, 336 ), ~fileChooser );\n~action = { arg fileName; var sf, oldBuf;\n    // try to open as a sound file. returns nil if it could not be opened\n    if( (sf = SoundFile.openRead( fileName )).notNil, {\n        sf.close;  // the header info was read, we can close the file\n        if( sf.numChannels == 1, {  // allow mono files only\n            oldBuf = ~model.buf;\n            if( ~model.node.notNil, {  // free old buffer when synth is freed\n                UpdateListener.newFor( ~model.node, { arg upd;\n                    upd.remove; oldBuf.free }, \\n_end );\n                ~model.node.register;\n            }, {\n                oldBuf.free;\n            });\n            ~model.buf = Buffer.read( s, fileName );  // replace buffer\n        }, {\n            \"Sound file must be mono\".error;\n        });\n    });\n};\n)\n\n",
    "Ch10_fig_019.scd": "\u00ef\u00bb\u00bfFigure 10.19\n\nimport java.io.File;\nimport javax.swing.filechooser.FileFilter;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\n\npublic class SoundFileChooser extends javax.swing.JFileChooser\nimplements java.beans.PropertyChangeListener\n{\n    private final java.util.List listeners = new java.util.ArrayList();\n    \n    public SoundFileChooser() {\n        super();        \n        final FileFilter filter = new FileFilter() {            \n            public boolean accept( File f ) {\n                if( f.isDirectory() ) return true;\n                try {\n                    return( de.sciss.io.AudioFile.retrieveType( f ) !=\n                            de.sciss.io.AudioFileDescr.TYPE_UNKNOWN );\n                }\n                catch( java.io.IOException e ) { return false; }\n            }\n        \n            public String getDescription() { return \"Audio Files\"; }\n        };\n        addChoosableFileFilter( filter );\n        setFileFilter( filter );\n        setControlButtonsAreShown( false );\n        addPropertyChangeListener( SELECTED_FILE_CHANGED_PROPERTY, this );\n        addPropertyChangeListener( DIRECTORY_CHANGED_PROPERTY, this );\n    }\n    \n    public String getSelectedPath() {\n        final File f = getSelectedFile();\n        return f == null ? \"\" : f.getAbsolutePath();\n    }\n    \n    public void setSelectedPath( String path ) {\n        setSelectedFile( new File( path ));\n    }\n    \n    public String getCurrentDirectoryPath() {\n        return getCurrentDirectory().getAbsolutePath();\n    }\n    \n    public void setCurrentDirectoryPath( String path ) {\n        setCurrentDirectory( new File( path ));\n    }\n    \n    public void addChangeListener( ChangeListener l ) { listeners.add( l ); }\n    public void removeChangeListener( ChangeListener l ) { listeners.remove( l ); }\n\n    public void propertyChange( java.beans.PropertyChangeEvent pce ) {\n        final ChangeEvent ce = new ChangeEvent( this );\n        for( int i = 0; i < listeners.size(); i++ ) {\n            ((ChangeListener) listeners.get( i )).stateChanged( ce );\n        }\n    }\n}\n\n",
    "Ch10_fig_020.scd": "\u00ef\u00bb\u00bfFigure 10.20\n\nJSCSoundFileChooser : JSCView {\n    var <path;       // String : current file selection (or nil)\n    var <directory;  // String : currently visible directory\n    var chResp;      // OSCpathResponder for ChangeResponder\n\n    path_ { arg value;\n        path = value;\n        server.sendMsg( '/set', this.id, \\selectedPath, value );\n    }\n\n    directory_ { arg value;\n        directory = value;\n        server.sendMsg( '/set', this.id, \\currentDirectoryPath, value );\n    }\n\n    prSCViewNew {\n        chResp = OSCpathResponder( server.addr, [ '/change', this.id ], {\n            arg time, resp, msg; var oldPath = path;\n            path        = if( msg[ 4 ] !== '', { msg[ 4 ].asString });\n            directory   = msg[ 6 ].asString;\n            if( oldPath != path, {{ this.doAction }.defer });\n        }).add;\n        ^super.prSCViewNew([[ '/local', this.id, '[', '/new', \"SoundFileChooser\", ']', \"ch\" ++ this.id, '[', '/new', \"de.sciss.swingosc.ChangeResponder\", this.id, '[', '/array', \\selectedPath, \\currentDirectoryPath, ']', ']' ]]);\n    }\n\n    prClose {\n        chResp.remove;\n        ^super.prClose([[ '/method', \"ch\" ++ this.id, \\remove ],\n                        [ '/free', \"ch\" ++ this.id ]]);\n    }\n}\n\n",
    "Ch10_fig_021.scd": "\u00ef\u00bb\u00bfFigure 10.21\n\n(\n~plug.remove;\t// this implicitly calls ~fileChooser.destroy!\n~soundChooser        = JSCSoundFileChooser( ~win, Rect( 370, 2, 386, 306 ));\n~soundChooser.path   = \"sounds/a11wlk01.wav\".absolutePath;\n~loadButton          = JSCButton( ~win, Rect( 370, 312, 60, 24 )).states_([[ \"Load\" ]]).enabled_( false );\n~infoText            = JSCStaticText( ~win, Rect( 438, 312, 318, 24 ));\n~soundChooser.action = { arg view; var enabled = false, info = \"\", sf;\n    if( view.path.notNil and: { (sf = SoundFile.openRead( view.path )).notNil }, {\n        sf.close;\n        enabled         = sf.numChannels == 1;\n        info            = \"% audio, %-chan. % % kHz, %\".format( sf.headerFormat, sf.numChannels, sf.sampleFormat, sf.sampleRate/1000, (sf.numFrames/sf.sampleRate).asTimeString );\n    });\n    ~loadButton.enabled = enabled;\n    ~infoText.string    = info;\n};\n~loadButton.action   = { ~action.value( ~soundChooser.path )};\n)\n\n",
    "Ch10_fig_022.scd": "\u00ef\u00bb\u00bfFigure 10.22\n\n(\n~ampSlider.resize     = 2;\n~mySlider.view.resize = 5;\n~ampText.resize       = 3;\n~speedText.resize     = 3;\n~soundChooser.resize  = 6;\n~loadButton.resize    = 9;\n~infoText.resize      = 9;\n~win.resizable        = true;\n) \n\n",
    "Ch11_fig_003.scd": "\u00ef\u00bb\u00bfFigure 11.3\n// Tasks \n(\nSynthDef(\"task\", { arg out=0, freq=2000;\n\tvar env = EnvGen.kr(Env.perc, 1.0, 0.2, doneAction:2);\n\tvar source = DynKlank.ar(`[ [0.5, 0.8, 1, 1.2, 2, 4]*freq, nil, nil ], PinkNoise.ar(0.007));\n\tOut.ar(out, source * env ! 2);\n}).add;\n\nt = Task({\n\tvar freq;\n\tloop {\n\t\tfreq = ((1..10)*220).choose;\n\t\tSynth(\"task\", [\\freq, freq]);\n\t\t0.3.wait;\n\t}\n})\n)\n\nt.start;\nt.stop;\n\n\n",
    "Ch11_fig_004.scd": "\u00ef\u00bb\u00bfFigure 11.4\n// Patterns\n(\nSynthDef(\"pattern\", { arg out=0, freq=220, pan=0, gate=1;\n\tvar ctl = RLPF.ar(Saw.ar(5, 1.0, 2), 25, 0.03);\n \tvar source = SinOsc.ar(ctl * freq) * 0.1;\n\tvar env = EnvGen.kr(Env.adsr, gate, doneAction: 2);\n\tOut.ar(out, Pan2.ar(source * env, pan));\n}).add;\n\ne = Pbind(\n\t\\midinote, Pxrand(#[60, 61, 63, 65, 72], 20), \n\t\\dur, 0.4,\n\t\\pan, Pwhite(-1.0, 1.0, 20),\n\t\\instrument, \\pattern\n);\n)\n\ne.play;\n\n\n",
    "Ch11_fig_005.scd": "\u00ef\u00bb\u00bfFigure 11.5\n// ProxySpace\np = p ?? ProxySpace.push(s);\n\n~ctl = { SinOsc.kr(1) * 110 + 440 };\n~out = { arg freq=220, amp=0.5; Ringz.ar(Dust.ar(2, 0.4), freq, 0.8) ! 2 };\n\n~out.play;\n\n~out.map(\\freq, ~ctl);\n\n~ctl = { SinOsc.kr(LFSaw.kr(5, add: 2.0) * 10) * 220 + 440 };\n\nProxyMixer(p);\n\n~out.stop;\n~out.clear;\n\n",
    "Ch11_fig_007.scd": "\u00ef\u00bb\u00bfFigure 11.7\n// MIDI Example\n(\nSynthDef(\\midi, { arg out=0, midinote=60, dur=0.1;\n\tvar source = Blip.ar(midinote.midicps, 4, 0.2);\n\tvar env = EnvGen.kr(Env.perc(0.1, dur), 1.0, doneAction: 2);\n\tOut.ar(out, (source * env) ! 2);\n\n}).add;\n\nc = NoteOnResponder( { |src, chan, num, vel|\n\t[num, vel].postln;\n\tSynth.new(\\midi, [\\midinote, num, \\dur, vel/512]);\n});\n)\nc.remove;\n\n",
    "Ch11_fig_008.scd": "\u00ef\u00bb\u00bfFigure 11.8\n// NetAddr and OSCresponder example\nn = NetAddr(\"localhost\", 57120); \nr = OSCresponder(n, '/good/news', { arg time, resp, msg; [time, msg].postln }).add;\n\nn.sendMsg(\"/good/news\", \"you\", \"not you\");\n\nr.remove;\nn.disconnect;\n\n",
    "Ch11_fig_009.scd": "\u00ef\u00bb\u00bfFigure 11.9\n// GUI Example\n(\n\tSynthDef(\\gui, { arg out=0, freq=8, decay=0.11;\n\t\tvar in = Formlet.ar(Impulse.ar(freq, 0, 0.4), 800, 0.01, decay);\n\t\tOut.ar(out, in ! 2);\n\t}).add;\n)\n(\n\ta = Synth.newPaused(\\gui);\n\tw = Window.new( \"A GUI window\", Rect( 128, 64, 340, 250 ));\n\tw.view.decorator = FlowLayout( w.view.bounds );\n\n\tb = Button.new( w, Rect( 50, 20, 75, 24 ));\n\tb.states = [[ \"Start\"],[ \"Stop\"]];\n\tb.action_({ arg butt;\n\t\tif (butt.value == 1, { a.run }, { a.run(false) });\t\n\t});\n\n\tc = Slider2D.new( w, Rect(50, 120, 330, 200));\n\tc.x_(0.5).y_(0.5).action_({|sl|\n\t\t\ta.setn(\\freq, [sl.x * 10 + 3, sl.y / 5 + 0.01]);\n\t});\n\tw.front;\n)\n\n",
    "Ch12_fig_001.scd": "\u00ef\u00bb\u00bf//Figure 12.1\n//#!/usr/local/bin/sclang\nif (thisProcess.argv.isEmpty) {\n\t\"Missing arguments!\".postln;\n\texit(1);\n};\nthisProcess.argv.do { | argu, i |\n\t\"% : %\\n\".postf(i, argu);\n};\nexit(0);\n\n",
    "Ch12_fig_003.scd": "\u00ef\u00bb\u00bfFigure 12.3\n// select the following lines and type C-c C-d\n// stop synthesis with C-c C-s\n{\n\tvar trem = LFTri.kr(3).range(-12.dbamp, 0.dbamp);\n\tSinOsc.ar(\n\t\t{ rrand(60, 80).midicps } ! 6,\n\t\tmul: -10.dbamp * trem\n\t).clump(2).sum\n}.play\n\n",
    "Ch12_fig_004.scd": "\u00ef\u00bb\u00bfFigure 12.4\n// evaluate the following lines by double-clicking on the\n// first paranthesis when `transient-mark-mode' is enabled\n// and pressing C-c C-c\n(\nx = {\nSaw.ar(\nXLine.kr(20, [400,403,407], 20),\nmul: 0.7\n).clump(2).sum\n}.play; \"scel\";\n)\n// evaluate this line by pressing C-c C-c\nx.free; \"rocks\";\n\n\n",
    "Ch13_fig_001.scd": "\u00ef\u00bb\u00bf// figure 13.1 - Loading the data\n(\nq = q ? ();\nq.execdata = ();\nq.execdata.years = (1977 .. 2008); \n\t// data is: [total for each region, 1977 ... 2007];\nq.execdata.regions = (\n\tTotal: [1099,1,0,2,0,1,2,5,21,18,18,25,11,16,23,14,31,38,31,\n\t\t\t56,45,74,68,98,85,66,71,65,59,60,53,42,37],\n\tNortheast: [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,1,0,0,0],\n\tMidwest: [129,0,0,0,0,1,0,0,0,1,0,0,0,1,5,1,1,4,3,11,9,10,5,12,5,10,9,7,7,14,6,5,2],\n\tSouth: [933,0,0,1,0,0,2,5,21,16,18,24,10,13,17,13,26,30,26,41,29,60,\n\t\t55,74,76,50,61,57,50,43,44,36,35],\n\tWest: [67,1,0,1,0,0,0,0,0,1,0,1,1,2,1,0,4,4,2,2,7,4,8,11,4,4,1,0,2,2,3,1,0],\n\tTexas: [423,0,0,0,0,0,1,0,3,6,10,6,3,4,4,5,12,17,14,19,3,37,20,35,40,17,33,24,23,19,24,26,18]\n);\nq.getReg = { |q, regName| q.execdata.regions[regName].drop(1) };\n)\n\n",
    "Ch13_fig_002.scd": "\u00ef\u00bb\u00bf// figure 13.2 - Mapping the data to pitch in discrete events\n(\nPbindef(\\exec, \n\t\\note, Pseq(q.getReg(\\Midwest)), \n\t\\octave, 3, \n\t\\dur, 5 / q.execdata.years.size\n).play;\n)\n\t// the different regions\nPbindef(\\exec, \\note, Pseq(q.getReg(\\Northeast)));\nPbindef(\\exec, \\note, Pseq(q.getReg(\\West)));\nPbindef(\\exec, \\note, Pseq(q.getReg(\\South)));\n\n",
    "Ch13_fig_003.scd": "\u00ef\u00bb\u00bf\t\t\t// figure 13.3 - Continuous data sonification\n \nb = Buffer.sendCollection(s, q.getReg(\\Northeast), 1); \n(\nNdef(\\exec, { |dur = 5, scale=50, offset=200| \n\tvar vals = PlayBuf.ar(1, b, dur / SampleRate.ir );\n\tPan2.ar(\n\t\tSinOsc.ar(vals  * scale + offset), 0, \n\t\tEnvGen.kr(Env.linen(0.01, dur, 0.01, 0.2), doneAction: 2)\n\t);\n}).play;\n)\n\t// load other regions into buffer\nb.sendCollection(q.getReg(\\Midwest));   Ndef(\\exec).send;\nb.sendCollection(q.getReg(\\West));   Ndef(\\exec).send;\nb.sendCollection(q.getReg(\\South));   Ndef(\\exec).send;\n\n",
    "Ch13_fig_004.scd": "\u00ef\u00bb\u00bf// figure 13.4 - Sound design with noise pulses \n(\nSynthDef( \"noisepulses\", { arg out = 0, sustain=1.0, numPulses = 0, pan = 0.0, amp = 0.2; \n\tOut.ar(out, \n\t\tPanAz.ar(4, \n\t\t\tPinkNoise.ar \n\t\t\t* Decay2.ar(Impulse.ar(numPulses / sustain, 0, numPulses.sign), 0.001, 0.2),\n\t\t\tpan, \n\t\t\tEnvGen.kr( Env.linen(0.0, 0.995, 0.0), levelScale: amp, timeScale: sustain, doneAction: 2)\n\t\t)\n\t);\n}).add;\nSynthDef(\\tick, { |out, amp=0.2, pan| \n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(0) * Line.kr(amp, amp, 0.001, doneAction: 2), pan)) \n}).add;\n)\n(instrument: \\noisepulses, numPulses: 10, legato: 1, dur: 2).play;\n(instrument: \\tick).play;\n\n",
    "Ch13_fig_005.scd": "\u00ef\u00bb\u00bf\t\t// figure 13.5 - Four regions in sequence\n(\nTdef(\\execs, { \n\tvar yearDur = 2;\t// one year is 2 seconds\n\tvar region, numExecs, numyears = q.execdata.years.size; \n\t[\\Northeast, \\Midwest, \\West, \\South].do { |regName, i| \n\n\t\tregion = q.execdata.regions[regName].postln; \n\t\tq.execdata.years.do { |year, i| \n\t\t\tnumExecs = region[i + 1]; \n\t\t\t[regName, year, numExecs].postln;\n\t\t\t(instrument: \\tick).play;\n\t\t\tif (numExecs > 0) {\n\t\t\t\t(instrument: \\noisepulses, legato: 1, \nnumPulses: numExecs, dur: yearDur).play;\n\t\t\t};\n\t\t\tyearDur.wait;\n\t\t};\n\t\tyearDur.wait;\n\t};\n}).play;\n)\n\n",
    "Ch13_fig_006.scd": "\u00ef\u00bb\u00bf// figure 13.6 - Four regions in parallel\n(\n// four channels playing, ordered by total number. \n// On stereo systems, only the first 2 channels play.\nTdef(\\execs, { \n\tvar yearDur = 2;\t// one year is 2 seconds\n\tq.execdata.years.do { |year, i| \n\tvar region, numExecs, numyears = q.execdata.years.size; \n\t\t// ordered by total number, on stereo, only first 2 play.\n\t[\\South, \\Midwest,  \\West, \\Northeast ].do { |regName, j| \n\n\t\tregion = q.execdata.regions[regName].postln; \n\t\t\tnumExecs = region[i + 1]; \n\t\t\t[regName, year, numExecs].postln;\n\t\t\t(instrument: \\tick).play;\n\t\t\tif (numExecs > 0) {\n\t\t\t\t(instrument: \\noisepulses, legato: 1, \ndur: yearDur, \n\t\t\t\t\tnumPulses: numExecs, \n\t\t\t\t\tpan: j * 0.5 - 0.25 \t// to 4 channels\n\t\t\t\t).play;\n\t\t\t};\n\t\t};\n\t\tyearDur.wait;\n\t};\n}).play;\n)\n\n\n",
    "Ch13_fig_007.scd": "\u00ef\u00bb\u00bf\t// figure 13.7 - Sonification of tag systems\n(\n// compare two axioms on left and right channels\n// ? = 4 (size of alphabet)\n// v (deletion number) varies [1..6] with horizontal cursor position\n{\n\tvar tag, rules, val;\n\trules = [[0, 1, 1], [1, 3, 2, 0], [1, 2], [3, 1, 1]]; // same rule for both\n\tv = MouseX.kr(1, 6);\n\tval = dup {\n\t\tvar axiom = Array.fill(14, { #[0, 1, 2, 3].choose }); axiom.join.postln;\n\t\tDuty.ar(1 / SampleRate.ir, 0,  Dtag(7e5, v, axiom, rules), doneAction:2);\n\t} * 0.1\n}.play;\n)\n\n",
    "Ch13_fig_012.scd": "\u00ef\u00bb\u00bf// figure 13.12 - Rotational Grain Train\n(\n~rotater = {|amp = 1|\n\tvar rotVel = ~rotVel.kr;\t// rotVel and height from tracking data proxies\n\tBPF.ar(\n\t\tImpulse.ar((rotVel > 0.5) * rotVel * 5).lag(0.0001),\n\t\t(~height.kr * 120 + 36 + [[0, 7], [0, 12], [0, 16]]).midicps, \n\t\t0.2\n\t).collect({ |pair| (pair * [1, 0.125]).sum }) \t* 6 * amp\n};\n)\n\n",
    "Ch13_fig_013.scd": "\u00ef\u00bb\u00bf// figure 13.13 - Rotation Trigger\n(\n~planeTicker = {|saw2sin = 1, filterFreq = 2000, fSpread = 0.4, amp = 0.1|\n\t\n\tvar freq = 3000 * fSpread * (~height.kr * 4 - 1).range(0.5, 2);\n\n\tvar src = SelectX.ar(\n\t\tsaw2sin, \n\t\t[LFSaw.ar(freq) , SinOsc.ar(freq)]\n\t) \n\t* Decay2.ar(\n\t\tTrig1.ar(~zeroCrossing.ar, 0.001) * 0.1, \n\t\t0.001,\n\t\t0.3\n\t);\n\n\tLPF.ar(src, filterFreq, mul: amp * 0.1)\n};\n)\n\n\n",
    "Ch13_fig_014.scd": "\u00ef\u00bb\u00bf// figure 13.14 - Distances to the Head\n(\n~backCross = {|amp = 1|\n\tvar \tnumObj = 3;\n\tvar \tin = ~isLeft.kr(numObj);\n\tvar \theight = ~height.kr(numObj), \n\t\tfront = ~isFront.kr(numObj); \n\tvar aEnv, fEnv, aEnvNoise;\n\n\tvar trig = Trig1.ar((in - Delay1.kr(in)).abs - 1, 0.00001) > 0.5;\n\t// only trigger if behind the body and near ground\n\ttrig = trig * (front < 0) * (height < 0.26);\n\taEnv = EnvGen.kr(Env.perc(0.05, 2), gate: trig);\n\taEnvNoise = EnvGen.kr(Env.perc(0.01, 0.1), gate: trig);\n\tfEnv = EnvGen.kr(\n\t\tEnv.perc(0.01, 0.1), gate: trig, \n\t\tlevelScale: 900, levelBias: 50\n\t);\n\t\n\taEnv * ((0.2 * WhiteNoise.ar * aEnvNoise) + \n\tSinOsc.ar(fEnv * (height * 8).squared * 0.4, 0, 1.5).softclip) * amp\n};\n)\n",
    "Ch13_fig_015.scd": "\u00ef\u00bb\u00bf// figure 13.15 -  Left-right Trigger\n(\n~distances = {|amp = 0.2795| \n\tLFSaw.ar(min((~dist.kr * 2.5 * 90 + 20).midicps, 44100)) * amp\n};\n)\n\n\n",
    "Ch13_fig_016.scd": "\u00ef\u00bb\u00bf// figure 13.16 - Rain on Bells\n(\n\n~clackUp = { |amp = 0.1|\n\tFormlet.ar(\n\t\t~trigsUp.ar.lag(0.0004), \n\t\t(~height.kr).exprange(25, 2500), \n\t\t0.002,\n\t\t0.05\n\t)\n\t* (~height.kr * 4 ** 2) \n\t* amp\n};\n)\n\n",
    "Ch13_fig_018.scd": "\u00ef\u00bb\u00bf/// figure 13.18: Navegar \u00e2\u0080\u0093 sound design for a single country\n(\n~single = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, attack=0.00, decay = 1.0, \n\tdens = 2, amp=0.2, x=1, y = 0, step=0.33333| \n\t\n\tvar numChans = 4; \n\t\n\tvar freqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\tvar exciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07)  \t// five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \t\t\t\t// slightly filtered\n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude comp for dust density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// some fused background noise\n\t\t\t* (decay ** -0.5);\t\t\t\t// amplitude comp. for decay\n\t\t\t\t\n\tvar resonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\tvar pos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (pi.reciprocal) + 1; // look west.\n\n\tPanAz.ar(numChans, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n~single.play;\n)\n\n",
    "Ch14_fig_001.scd": "\u00ef\u00bb\u00bfFigure 14.1\n\n(\n/// basic setup\ns = Server.local.boot;\n\ns.doWhenBooted({\n\tSynthDef( \\nicepoc, { |out=0,freq=440,amp=0.1,dur=0.3|\n\t\tOut.ar( out, SinOsc.ar( freq, mul: amp )*EnvGen.kr( Env.perc(0.05,1), timeScale: dur, doneAction:2 ) )\n\t}).add;\n});\n)\n\n// mono, 1 channel:\n(\np = Pbind(\n     \\degree, Pseq([0, 3, 5, 6, 7],5),\n     \\dur, 0.2,\n     \\instrument, \\nicepoc\n).play;\n)\n\np.stop;\n\n// multiple mono:\n// the melody gets played on both channels, the second note in the pattern differs,\n// so when listening to it, the space \"spreads\" out\n(\np = Pbind(\n     \\degree, Pseq([0 ,[3,4], 5, 6, 7],5),\n     \\out, [0,1],\n     \\dur, 0.2,\n     \\instrument, \\nicepoc\n).play;\n)\n\np.stop;\n\n",
    "Ch14_fig_003.scd": "\u00ef\u00bb\u00bfFigure 14.3\n\n\n// 2 channel panners:\n Pan2.ar( in, pos, level );\n LinPan2.ar( in, pos, level );\n Balance2.ar( left, right, pos, level );\n Rotate2.ar( x, y, pos );\n\n// 4-channel panner:\n Pan4.ar( in, xpos, ypos, level );\n\n// N-channel panner:\n PanAz.ar( numChans, in, pos, level, width, orientation );\n\n// spread M channels over a stereo field:\n Splay.ar( inArray, spread, level, center, levelComp );\n\n// spread M channels over N channels:\n SplayAz.ar( numChans, inArray, spread, level, width, center, orientation, levelComp );\n\n\n\n",
    "Ch14_fig_005.scd": "\u00ef\u00bb\u00bfFigure 14.5\n\n// single tap delay lines\nDelayN.ar(in, maxdelaytime, delaytime, mul, add)\nDelayL.ar(in, maxdelaytime, delaytime, mul, add)\nDelayC.ar(in, maxdelaytime, delaytime, mul, add)\n\n// allpass filters:\nAllpassN.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nAllpassL.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nAllpassC.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\n\n// comb filters (delaylines with feedback):\nCombN.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nCombL.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nCombC.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\n\n// buffer versions:\n\nBufDelayN.ar(buf, in, delaytime, mul, add)\nBufDelayL.ar(buf, in, delaytime, mul, add)\nBufDelayC.ar(buf, in, delaytime, mul, add)\n\nBufAllpassN.ar(buf, in, delaytime, decaytime, mul, add)\nBufAllpassL.ar(buf, in, delaytime, decaytime, mul, add)\nBufAllpassC.ar(buf, in, delaytime, decaytime, mul, add)\n\nBufCombN.ar(buf, in, delaytime, decaytime, mul, add)\nBufCombL.ar(buf, in, delaytime, decaytime, mul, add)\nBufCombC.ar(buf, in, delaytime, decaytime, mul, add)\n\n\n// special delay lines utilising PlayBuf:\nTap.ar(bufnum, numChannels, delaytime)\nPingPong.ar(bufnum, inputArray, delayTime, feedback, rotate)\n\n\n",
    "Ch14_fig_006.scd": "\u00ef\u00bb\u00bfFigure 14.6\n\n // Create a buffer.\nb=Buffer.alloc(s, s.sampleRate, 1); //enough space for one second of mono audio \n\n// Write to the Buffer with BufWr, read using several taps and mix them together:\n(\nSynthDef(\\helpTap, {|bufnum|\n var source, capture;\n source= Impulse.ar(1);\n capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));\n\t Out.ar(0, Mix.new([1,0.95,0.94,0.93,0.8,0.4,0.4]*Tap.ar(bufnum, 1, [0.04,0.1,0.22,0.88,0.9,0.91,0.93])));\n}).add;\n)\n\nx=Synth(\\helpTap,[\\bufnum, b.bufnum]);\nx.free;\n\n( // alternate source; use headphones to avoid feedback\nSynthDef(\\helpTap2, {|bufnum|\n var source, capture;\n source= SoundIn.ar(0);\n capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));\n\t Out.ar(0, Mix.new([1,0.95,0.94,0.93,0.8,0.4,0.4]*Tap.ar(bufnum, 1, [0.04,0.1,0.22,0.88,0.9,0.91,0.93])));\n}).add;\n)\n\nx=Synth(\\helpTap2,[\\bufnum, b.bufnum]);\nx.free;\n\n// free buffer:\nb.free;\n\n\n",
    "Ch14_fig_007.scd": "\u00ef\u00bb\u00bfFigure 14.7\n\n\n// convolving two signals with each other:\nConvolution.ar( in, kernel, framesize, mul, add )\n\n// convolving one signal with a buffer:\nConvolution2.ar( in, kernel, trigger, framesize, mul, add )\n// as above with linear interpolation:\nConvolution2L.ar( in, kernel, trigger, framesize, crossfade, mul, add )\n// as above, with two buffers:\nStereoConvolution2L.ar( in, kernelL, kernelR, trigger, framesize, crossfade, mul, add )\n\n// time based convolution (highly inefficient for audio rate)\nConvolution3.ar( in, kernel, trigger, framesize, mul, add )\nConvolution3.kr( in, kernel, trigger, framesize, mul, add )\n\n// partitioned convolution\nPartConv.ar(in, fftsize, irbufnum, mul, add)\n\n",
    "Ch14_fig_008.scd": "\u00ef\u00bb\u00bf   Figure 14.8\n\n\n// one channel input:\nFreeVerb.ar(in, mix, room, damp, mul, add)\n// 2 channel input and output:\nFreeVerb2.ar(in, in2, mix, room, damp, mul, add)\n\n// stereo reverb\n#left, right = GVerb.ar(in, roomsize, revtime, damping, inputbw,\n spread, drylevel, earlyreflevel, taillevel, maxroomsize, mul, add)\n\n\n\n",
    "Ch14_fig_010.scd": "\u00ef\u00bb\u00bfFigure 14.10\n\n\n// 5.1 array (subwoofer must be treated separately)\nVBAPSpeakerArray.new(2, [ -30, 30, 0, -110, 110 ]);\n\n// 16 channel partial dome\nVBAPSpeakerArray.new(3, [[-22.5, 14.97], [22.5, 14.97], [-67.5, 14.97], [67.5, 14.97], [-112.5, 14.97], [112.5, 14.97], [-157.5, 14.97], [157.5, 14.97], [-45, 0], [45, 0], [-90, 0], [90, 0], [-135, 0], [135, 0], [0, 0], [180, 0]]); \n\n\n",
    "Ch14_fig_011.scd": "\u00ef\u00bb\u00bfFigure 14.11\n\n\na = VBAPSpeakerArray.new(3, [[-22.5, 14.97], [22.5, 14.97], [-67.5, 14.97], [67.5, 14.97], [-112.5, 14.97], [112.5, 14.97], [-157.5, 14.97], [157.5, 14.97], [-45, 0], [45, 0], [-90, 0], [90, 0], [-135, 0], [135, 0], [0, 0], [180, 0]]); // zig zag partial dome\n\nb = a.loadToBuffer; // send speaker config to the server\n\n(\n// pan around the circle up and down\nx = { |azi = 0, ele = 0, spr = 10|\nvar source;\nsource = PinkNoise.ar(0.2);\nVBAP.ar(16, source, b, LFSaw.kr(0.5, 0).range(-180, 180) * -1, SinOsc.kr(3, 0).range(0, 14.97), spr);\n}.play;\n)\n\n\n",
    "Ch14_fig_012.scd": "\u00ef\u00bb\u00bfFigure 14.12\n\n\n// 3D encoding:\nPanB.ar(in, azimuth, elevation, gain)\n// 2D encoding:\nPanB2.kr(in, azimuth, gain)\n// 2D encoding of a stereo signal:\nBiPanB2.kr(inA, inB, azimuth, gain)\n\n// decoding (2D):\nDecodeB2.kr(numChans, w, x, y, orientation)\n\n// rotating (in the horizontal plane):\nRotate2.kr(x, y, pos)\n\n\n/** From AmbisonicUGens in sc3-plugins: **/\n\n// encoding (3D):\nBFEncode1.ar(in, azimuth, elevation, rho, gain, wComp)\nBFEncode2.ar(in, point_x, point_y, elevation, gain, wComp)\n\n// encoding of a stereo signal (3D)\nBFEncodeSter.ar(l, r, azimuth, width, elevation, rho, gain, wComp)\n\n// decoding (3D):\nBFDecode1.ar(w, x, y, z, azimuth, elevation, wComp, mul, add)\n\n// manipulating (3D):\nBFManipulate.ar(w, x, y, z, rotate, tilt, tumble)\n// rotate is rotation around the z-axis, tilt around the x-axis, and tumble around the y-axis\n\n\n",
    "Ch14_fig_016.scd": "\u00ef\u00bb\u00bfFigure 14.16\n\n\n// no interpolation\n*arBufN { arg sound = 0, bufnum, location, speakerSpec, speedOfSound = 334, ampType = 'ws'; \n var numChannels, distArray;\n\n// WFSPoint is a 3D representation of a point in cartesian space\n\n speakerSpec = speakerSpec ? [WFSPoint.new(-2.7, 1.8, 0), WFSPoint.new(2.7,1.8, 0)]; //default 2 speakers\n\n if( speakerSpec.class == WFSConfiguration )\n  { speakerSpec = speakerSpec.allSpeakers; };\n\n numChannels = speakerSpec.size; // speakerSpec = Array of WFSPoint objects\n\n location = location ? WFSPoint.new(0,0,0); // the location of the sound source\n\n distArray = Array.fill(numChannels, { |i| speakerSpec.at(i).dist(location)}); // distance of the sound source to each speaker (r_0)\n\n cosPhiArray = Array.fill(numChannels, { |i| speakerSpec.at(i).cosphi(location)}); // cosine phi_0 of the sound source to each speaker (cos phi_0)\n ^BufDelayN.ar(bufnum, sound, \n  distArray / speedOfSound, // delay\n  WFSPan.wfsAmp(distArray,cosPhiArray);\n }\n\n*wfsAmp{ arg inDist, inCosPhi, refDist=4.0, minDist = 0.1;\n // refDist is the reference line distance\n // minDist is the minimal distance to the speaker array (to avoid explosion at /0)\n\n // avoid explosion:\n inDist = inDist.max( minDist );\n\n ^(ampFactor * ((refDist/(refDist + inDist)).sqrt)*(inCosPhi/(inDist.sqrt)))\n}\n\n\n\n",
    "Ch14_fig_017.scd": "\u00ef\u00bb\u00bfFigure 14.17\n\n\ns.boot;\n(\nb = Buffer.alloc(s,2048,1);\nc = Buffer.read(s,\"sounds/a11wlk01.wav\");\nd = Buffer.alloc(s,2048,1);\n)\n\n(\n//make stereo from mono\n// MouseX controls decorrelation\nx = SynthDef(\"PV_DecorrelateStereo\", { arg out=0, bufnum=0, bufnum2, soundBufnum=2;\n var in, chain, chain2;\n in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);\n chain = FFT(bufnum, in);\n chain2 = PV_Copy(chain, bufnum2);\n chain = PV_Decorrelate([chain, chain2], 1,  MouseX.kr);\n Out.ar(out, 0.5 * IFFT(chain));\n}).play(s,[\\out, 0, \\bufnum, b, \\bufnum2, d, \\soundBufnum, c]);\n)\n\nx.free; [b, c, d].do(_.free);\n\n\n\n",
    "Ch14_fig_018.scd": "\u00ef\u00bb\u00bfFigure 14.18\n\n(\nb = Buffer.read(s, \"sounds/a11wlk01.wav\");\nSynthDef(\"grain\",{ arg i_out=0, i_sampbufnum, dur = 0.05, \n pointer, offset = 0.005, amp = 1.0, loop = 1;\n var thisStart, thisDur, grain;\n thisStart = pointer + IRand(0, offset); // adds random time offset\n grain = EnvGen.ar(Env.sine, 1.0, amp, 0.0, dur, 2) \n  * PlayBuf.ar(1,i_sampbufnum, BufRateScale.ir(i_sampbufnum),\n   1, thisStart,loop);\n OffsetOut.ar(i_out,grain); // use OffsetOut for precise sub-block timing\n}).add;\n)\n\n(\nx = {\nvar numGrains = 32; // approximate number of simultaneous grains\nvar numChannels = 2; // adjust for your setup\nvar dur = 0.05, durRand = 0.05, thisDur;\nvar start, now;\nvar numGrainsRecip;\nnumGrainsRecip = numGrains.reciprocal; // save some divides by converting to reciprocal\n\nstart = Main.elapsedTime;\nloop({ \n now = Main.elapsedTime - start;\n thisDur = dur + durRand.rand;\n s.bind({Synth(\"grain\", [i_out: numChannels.rand, i_sampbufnum: b, dur: thisDur, \n  pointer: now * b.sampleRate, amp: numGrainsRecip]);\n }); // send as a bundle for precise sub-block timing\n (thisDur * numGrainsRecip).wait;\n})\n}.fork;\n)\n\nx.stop; b.free;\n\n\n",
    "Ch14_fig_019.scd": "\u00ef\u00bb\u00bfFigure 14.19\n\n\nServer.default = s = Server.internal;\ns.boot;\n(\nn = 512; // number of bins\nb = Buffer.alloc(s, n, 1);\nc = Buffer.alloc(s, n, 1);\n\n// create arrays of magnitude scalars and load them to buffers\nd = Array.fill(n, {1.0.linrand});\ne = 1.0 - d;\nd = Buffer.loadCollection(s, d);\ne = Buffer.loadCollection(s, e);\n\nf = Buffer.read(s,\"sounds/a11wlk01.wav\");\n)\n\n(\nx = SynthDef(\"spectral diffusion\", { arg out=0, analBuf, analBufCopy, scalBuf1, scalBuf2, soundBuf;\n var chain1, chain2;\n chain1 = FFT(analBuf, PlayBuf.ar(1, soundBuf, BufRateScale.kr(soundBuf), loop: 1));\n chain2 = PV_Copy(chain1, analBufCopy); // copy the initial analysis\n chain1 = PV_MagMul(chain1, scalBuf1);\n chain2 = PV_MagMul(chain2, scalBuf2); \n Out.ar(out,  0.5 * IFFT([chain1, chain2]));\n}).play(s,[out: 0, analBuf: b, analBufCopy: c, scalBuf1: d, scalBuf2: e, soundBuf: f]);\ns.scope; // compare the two channels\n)\n\n// execute this multiple times to change the distribution\n(\ng = Array.fill(n, {1.0.linrand});\nh = 1 - g;\nd.loadCollection(g);\ne.loadCollection(h);\n)\n\nx.free; [b, c, d, e, f].do(_.free);\n\n\n",
    "Ch15_fig_001.scd": "\u00ef\u00bb\u00bfFigure 15.1\n(\nx={\n\tvar in, amp, freq, hasFreq, out;\n\tin = SoundIn.ar(0);\n\tamp = Amplitude.ar(in);\n\t# freq, hasFreq = Pitch.kr(in);\n\tLFTri.ar(freq*[1,2]) * amp;\n}.play\n)\n\nx.free;\n\n",
    "Ch15_fig_002.scd": "\u00ef\u00bb\u00bfFigure 15.2\nb = Buffer.alloc(s,1024,1);   //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\t\n(  //analyse loudness and poll result\nx={\n\tvar in, fft, loudness;\n\t\n\tin = SoundIn.ar(0); \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tloudness = Loudness.kr(fft); \n\t\n\tloudness.poll(20); //poll for testing 20 times per second\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n",
    "Ch15_fig_003.scd": "\u00ef\u00bb\u00bfFigure 15.3\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//d=Buffer.read(s,\"sounds/a11wlk01.wav\");\n\n\n(\nx= {\n\tvar in, fft, array;\n\t\n\t//in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tin = SoundIn.ar(0); \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tarray = MFCC.kr(fft); \n\t\n\tarray.size.postln; \n\t\n\tOut.kr(0,array); \n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\n\nc= Bus.new('control', 0, 13); \n\n//poll coefficients\nc.getn(13,{arg val; {val.plot;}.defer}); \n\n\n//Continuous graphical display of MFCC values; free routine before closing window\n\n(\nvar ms; \n\nw = Window(\"Thirteen MFCC coefficients\", Rect(200,400,300,300));\n\nms = MultiSliderView(w, Rect(10,10,260,280));\n\nms.value_(Array.fill(13,0.0));\nms.valueThumbSize_(20.0);\nms.indexThumbSize_(20.0);\nms.gap_(0);\n\nw.front;\n\nr = {\n\t\n\tinf.do{\n\t\t\n\t\tc.getn(13,{arg val; {ms.value_(val*0.9)}.defer}); \n\t\t\n\t\t0.04.wait; //25 frames per second\n\t};\n\n}.fork;\n\n)\n\n\n//tidy up\n(\nr.stop;\nb.free;\nc.free;\nx.free;\nw.close;\n)\n\n\n\n",
    "Ch15_fig_004.scd": "\u00ef\u00bb\u00bfFigure 15.4\n// Prepare the buffer\nb = Buffer.alloc(s, 512);\n\n(\nx = {\n\tvar sig, chain, onsets, pips, trigger;\n\t\n\tsig = SoundIn.ar(0); \n\t\n\tchain = FFT(b, sig);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger= SendTrig.kr(onsets);\n\t\n\tpips = SinOsc.ar(880, 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));\n\t\n\tOut.ar(0, ((sig * 0.1) + pips).dup);\n}.play;\n)\n\n(\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\t[time,responder,msg].postln;\n}).add;\n)\n\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer\n\n\n\n\n",
    "Ch15_fig_005.scd": "\u00ef\u00bb\u00bfFigure 15.5\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin); events will be spawned at quarter, eighth and sixteenth note rates\n(\nSynthDef(\\beattrack,{\t\n\tvar trackb,trackh,trackq,tempo;\n\tvar source;\n\tvar bsound,hsound,qsound;\n\t\n\tsource = SoundIn.ar(0);\n\t\n\t#trackb,trackh,trackq,tempo = BeatTrack.kr(FFT(b.bufnum, source));\n\t\n\tbsound = Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);\n\t\n\thsound = Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);\n\t\n\tqsound = Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);\n\t\n\tOut.ar(0, bsound+hsound+qsound);\n}).add;\n)\n\nx = Synth(\\beattrack); // Go!\n\nx.free;\nb.free; // Free the buffer\n\n",
    "Ch15_fig_006.scd": "\u00ef\u00bb\u00bfFigure 15.6\n//straight forward test file with few transients; training set in e minor from MIREX2006 \n//You will need to substitute your own soundfile to load here\nd=Buffer.read(s,\"/Users/nickcollins/Desktop/ML/training_wav/78.wav\")\n\n\nb = Buffer.alloc(s,4096,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,8192,1); //for sampling rates 88200 and 96000\n\n(\nx= {\n\tvar in, fft; \n\tvar key;\n\t\n\tin = PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tkey = KeyTrack.kr(fft, 2.0, 0.5);\n\t\n\tkey.poll; //write out detected key\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n\n\n",
    "Ch15_fig_007.scd": "\u00ef\u00bb\u00bfFigure 15.7\n//Example uses internal server to demonstrate shared busses\n\n(\ns=Server.internal; \nServer.default=s; \n\ns.doWhenBooted({\n\nb = Buffer.alloc(s, 512);\n\n//this SynthDef will make no sound, just analyses input\nSynthDef(\\pitchandonsets,\n{\n\tvar in, amp, freqdata, chain, onsets, trigger;\n\t\n\tin = SoundIn.ar(0);\n\tamp = RunningSum.rms(in, 64); //get rms amplitude value per control block\n\tfreqdata = Pitch.kr(in); \n\t\n\t//allow synchronous polling, Internal Server only\n\tSharedOut.kr(0,freqdata);\t\n\tSharedOut.kr(2,amp);\n\t\n\tchain = FFT(b, in);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger = SendTrig.kr(onsets);\n\n}).send(s); \n});\n\n)\n\n\n\n(\nvar freqlist=List(), amplist=List(); \nvar notelist= List(), numnotes=10; //will hold the last 10 notes \nvar lasttime, started=false; \nvar maxlength=0.5, maxkperiods, waittime;\n\nmaxkperiods = ((maxlength*(s.sampleRate))/(s.options.blockSize)).asInteger;\nwaittime = (s.options.blockSize)/(s.sampleRate);\n\n\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\tvar newnote;\n\t\t\n\tif(started,{\t\n\t\t\n\t//finalise previous note as [starttime, ioi= inter onset interval, dur, medianpitch, maxamp]\t\n\tnewnote = \t[lasttime, time-lasttime, (time-lasttime).min(maxlength), if(freqlist.notEmpty, {freqlist.median.cpsmidi},{nil}),amplist.maxItem.ampdb];\n\t\n\tnewnote.postln;\n\t\t\n\tnotelist.addFirst(newnote);\n\t\n\t//remove oldest note if over size\n\tif(notelist.size>numnotes,{notelist.pop}); \n\t\n\t},{started = true;}); \n\t\n\t//reset lists for collection\n\tfreqlist = List();\n\tamplist = List(); \n\tlasttime = time;\n\t\t\n}).add;\n\nx= Synth(\\pitchandonsets); \n\n//poll values\n{\t\n\t\n\tinf.do{  \n\t\tvar freq, hasfreq, rmsamp;\n\t\t \n\t\tfreq = s.getSharedControl(0);\n\t\thasfreq = s.getSharedControl(1);\n\t\trmsamp = s.getSharedControl(2);\n\t\t\n\t\t//don't allow notes of longer than 500 control periods or so\n\t\tif((hasfreq>0.5) and: (amplist.size<maxkperiods), {freqlist.add(freq)});\n\t\t\n\t\tif(amplist.size<maxkperiods, {amplist.add(rmsamp)});\n\t\t \n\t\t//poll every control period, intensive\n\t\t(waittime).wait;\n\t}; \n\t\n}.fork;\n\n)\n\n\n\n(\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer\n)\n\n\n\n\n",
    "Ch15_fig_008.scd": "\u00ef\u00bb\u00bfFigure 15.8\n//do this first: \nMIDIIn.connect; \t// init for one port midi interface\n\n\n//now:\nm = OnlineMIDI();\n\nm.analyse(3,1.0); //3 seconds window, step size of 1.0 seconds\n\nm.data //poll current data\n\nm.status = true; //prints analysis data as it goes\nm.status= false;\n\n//use analysis data to formulate responses\n\n(\nSynthDef(\\beep2,{arg freq=440,amp=0.1, pan=0.0, dur=0.1; \nvar source; \n\nsource= SinOsc.ar(freq*[1,1.007],0,amp*0.5);\n\nOut.ar(0,Pan2.ar(Mix(source)*Line.kr(1,0,dur, doneAction:2),pan))}).add;\n)\n\n//to echo each note you play on a MIDI keyboard with a sound; your SynthDef must have freq and amp arguments, and deal with duration and freeing the Synth itself.  \n(\nm.playinput= true; \nm.inputsynthdef= \\beep2; \n)\n\n//set a function that gets called after each window is analysed, to schedule events over the next second \n(\nm.response = {|analysis|  \n\tvar number;\n\tnumber= analysis.density; \n\t//number= max(0,(10-(analysis.density))); //inverting number of notes playing\n\t\n\tif(analysis.iois.notEmpty, {\n\t\t{\n\t\t\n\t\tnumber.do{\n\t\t\n\t\tSynth(\\beep2, [\\freq, analysis.pitches.choose.midicps, \\amp, 0.2*(rrand(analysis.volumemin, analysis.volumemax))]);\n\t\t\n\t\tanalysis.iois.choose.wait; //could last longer than the next second, but still fun! \n\t\t\n\t\t}; \n\t\t\n\t\t}.fork;\n\t}); \n\t\n};\n)\n\n\nm.response= nil; //stop\n\n\n\n",
    "Ch16_fig_001.scd": "\u00ef\u00bb\u00bfFigure 16.1: Short grain durations, pitch to colored click \n\n(\t// a gabor grain, gaussian-shaped envelope\nSynthDef(\\gabor, { |out, freq = 440, sustain = 1, pan, amp = 0.1, width = 0.25 |\n\tvar env = LFGauss.ar(sustain, width, loop: 0, doneAction: 2);\n\tvar son = FSinOsc.ar(freq, 0.5pi, env);\n\tOffsetOut.ar(out, Pan2.ar(son, pan, amp));\n\n}, \\ir ! 6).add;\n\n\t// or an approximation with a sine-shaped envelope\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)\n\n(\nPbindef(\\grain,\n\t\\instrument, \\gabor, \\freq, 1000, \n\t\\dur, 0.5, \\sustain, 20/1000, \\amp, 0.2\n).play;\n)\nPbindef(\\grain, \\sustain, 10/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 5/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 3/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 2/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 1/Pkey(\\freq));\n\n\t// successively shorter, end\nPbindef(\\grain, \\sustain, Pseq((10..1)) / Pkey(\\freq)).play;\n\n\t// random drift of grain duration\nPbindef(\\grain, \\sustain, Pbrown(1, 10, 3) / Pkey(\\freq), \\dur, 0.1).play\n\n",
    "Ch16_fig_002.scd": "\u00ef\u00bb\u00bfFigure 16.2: Perception of short silences.\n\n(\np = ProxySpace.push;\n\n~source = { SinOsc.ar * 0.1 };\n~silence = { |silDur=0.01| \n\tEnvGen.ar(\n\t\tEnv([0, 1, 1, 0, 0, 1, 1, 0], [0.01, 2, 0.001, silDur, 0.001, 2, 0.01]), \n\t\tdoneAction: 2) ! 2\n};\n~listen = ~source * ~silence;\n~listen.play;\n)\n\n~silence.spawn([\\silDur, 0.001]); // sounds like an added pulse \n~silence.spawn([\\silDur, 0.003]);\n~silence.spawn([\\silDur, 0.01]);\n~silence.spawn([\\silDur, 0.03]);\t  // a pause in the sound\n\n\t// try the same examples with noise:\n~source = { WhiteNoise.ar * 0.1 };\t\n\np.pop\n\n",
    "Ch16_fig_003.scd": "\u00ef\u00bb\u00bfFigure 16.3: Order confusion with sounds in fast succession. \n\tAs grains move closer and closer together, their order becomes ambiguous. \n\n(\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp), timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)\n(\nPbindef(\\lo, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 250, \\amp, 0.2, \\dur, 0.5, \\lag, 0\n).play;\nPbindef(\\hi, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 875, \\amp, 0.1, \\dur, 0.5, \\lag, 0\n).play;\n)\n\t// try different lag times between them\nPbindef(\\hi, \\lag, 0.1);\nPbindef(\\hi, \\lag, 0.03);\nPbindef(\\hi, \\lag, 0.01);\nPbindef(\\hi, \\lag, 0.003);\n\n\t// hi too early or too late by a fixed time - which one is first?\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.01).postln).play;\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.02).postln);\n\n\t// is it easier to hear when the sounds are panned apart?\nPbindef(\\hi, \\pan, 0.5); Pbindef(\\lo, \\pan, -0.5);\nPbindef(\\hi, \\pan, 0);   Pbindef(\\lo, \\pan, 0);\n\n\n",
    "Ch16_fig_004.scd": "\u00ef\u00bb\u00bfFigure 16.4: multiple grains fuse into one composite.\n\t// when the order changes, the sound is subtly different.\n(\nPbindef(\\grain4, \n\t\\instrument, \\percSin, \\sustain, 0.03, \\amp, 0.2,\n\t\\freq, Pshuf([1000, 600, 350, 250]), // random every each time\n\t\\dur, 0.005\n).play;\n\t\t\t\t// repeat grain cluster \nTdef(\\grain, { loop { Pbindef(\\grain4).play; 1.wait } }).play;\n)\n\t// fixed order\nPbindef(\\grain4, \\freq, Pseq([1000, 600, 350, 250].scramble));\n\n\t// different order every time\nPbindef(\\grain4, \\freq, Pshuf([1000, 600, 350, 250]));\n\n\n",
    "Ch16_fig_006.scd": "\u00ef\u00bb\u00bfFigure 16.6 \u00e2\u0080\u0093 Making different envelope shapes\n\nEnv.sine.plot2;\t\t// approx. gaussian \nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\sin).test.plot2; // quasi-gaussian\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\lin).test.plot2; // 3 stage line segments.\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\welch).test.plot2; // welch curve interpolation\nEnv([1, 0.001], [0.1], \\exp).test.plot2;\t// expoDec (exponential decay);\nEnv([0.001, 1], [0.1], \\exp).test.plot2;\t// revExpoDec (reverse exponential decay);\nEnv.perc(0.01, 0.09).test.plot2;\n\n(\t// a sinc function envelope \nq = q ? ();\nq.makeSinc = { |q, num=1, size=400| \n\tdup({ |x| x = x.linlin(0, size-1, -pi, pi) * num; sin(x) / x }, size);\n}; \na = q.makeSinc(6);\na.plot(bounds: Rect(0,0,409,200), minval: -1, maxval: 1);\n)\n\n",
    "Ch16_fig_009.scd": "\u00ef\u00bb\u00bf// figure 16.9 - SynthDefs with different envelopes\n\n(\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env.sine(sustain, amp2), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp2, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// an exponential decay envelope\nSynthDef(\\expodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = AmpComp.ir(freq.max(50)) * 0.5 * amp;\n\tvar env = XLine.ar(amp2, amp2 * 0.001, sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a reversed exponential decay envelope\nSynthDef(\\rexpodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = XLine.ar(amp2 * 0.001, amp2, sustain, doneAction: 2) \n\t\t* (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)\n",
    "Ch16_fig_010.scd": "\u00ef\u00bb\u00bfFigure 16.10: Changing grain duration, frequency, envelope.\n\n\t// figure 16.10 - changing grain duration, frequency, envelope\n(\nPbindef(\\grain0,\n\t\\instrument, \\gabor1, \\freq, 500, \n\t\\sustain, 0.01, \\dur, 0.2\t\n).play;\n)\n\t// change grain durations\nPbindef(\\grain0, \\sustain, 0.1);\nPbindef(\\grain0, \\sustain, 0.03);\nPbindef(\\grain0, \\sustain, 0.01);\nPbindef(\\grain0, \\sustain, 0.003);\nPbindef(\\grain0, \\sustain, 0.001);\nPbindef(\\grain0, \\sustain, Pn(Pgeom(0.1, 0.9, 60)));\nPbindef(\\grain0, \\sustain, Pfunc({ exprand(0.0003, 0.03) }));\nPbindef(\\grain0, \\sustain, 0.03);\n\n\t// change grain waveform (sine) frequency\nPbindef(\\grain0, \\freq, 300);\nPbindef(\\grain0, \\freq, 1000);\nPbindef(\\grain0, \\freq, 3000);\nPbindef(\\grain0, \\freq, Pn(Pgeom(300, 1.125, 32)));\nPbindef(\\grain0, \\freq, Pfunc({ exprand(300, 3000) }));\nPbindef(\\grain0, \\freq, 1000);\n\n\t// change synthdef for different envelopes\nPbindef(\\grain0, \\instrument, \\gabor1);\nPbindef(\\grain0, \\instrument, \\gabWide);\nPbindef(\\grain0, \\instrument, \\percSin);\nPbindef(\\grain0, \\instrument, \\percSinRev);\nPbindef(\\grain0, \\instrument, \\expodec);\nPbindef(\\grain0, \\instrument, \\rexpodec);\nPbindef(\\grain0, \\instrument, Prand([\\gabWide, \\percSin, \\percSinRev], inf));\n\n",
    "Ch16_fig_011.scd": "\u00ef\u00bb\u00bfFigure 16.11: Different control strategies applied to density.\n\n(\t// synchronous - regular time intervals\nPbindef(\\grain0).clear;\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, 0.1, \\sustain, 0.06\n);\n)\n\t// different fixed values\nPbindef(\\grain0, \\dur, 0.06) \t// rhythm\nPbindef(\\grain0, \\dur, 0.035)\t\nPbindef(\\grain0, \\dur, 0.02)\t// fundamental frequency 50 Hz\n\n\t// time-changing values: accelerando/ritardando\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02], [4], \\exp), inf));\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02, 0.06, 0.01].scramble, [3, 2, 1], \\exp), inf));\n\n\t// repeating values: rhythms or tones\nPbindef(\\grain0, \\dur, Pstutter(Pwhite(2, 15), Pfunc({ exprand(0.01, 0.3) })));\n\n\t// introducing irregularity - quasi-synchronous\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.8, 1.2))\nPbindef(\\grain0, \\dur, 0.03 * Pbrown(0.6, 1.4, 0.1)) // slower drift\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.2, 1.8))\n\n\t// average density constant, vary degree of irregularity  \nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.1.linrand * 3) + 0.9 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.3.linrand * 3) + 0.3 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (1.0.linrand * 3) + 0.0 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ 2.45.linrand.squared })); // very irregular\n\n\n(\t// coupling - duration depends on freq parameter\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq  })\n);\n)\n\n\t// different freq movement, different timing\nPbindef(\\grain0, \\freq, Pbrown(48.0, 96.0, 12.0).midicps);\n\n(\t// duration depends on freq, with some variation - tendency mask\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq * rrand(0.5, 1.5)  })\n);\n)\n\n\n",
    "Ch16_fig_012.scd": "\u00ef\u00bb\u00bfFigure 16.12: Control strategies applied to different parameters\n\n(\nPbindef(\\grain0).clear;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, 200,\n\t\\sustain, 0.05, \\dur, 0.07\n).play;\n)\n\t// time-varying freq with envelope pattern\nPbindef(\\grain0, \\freq, Pn(Penv([200, 1200], [10], \\exp), inf));\n\t// random freq\nPbindef(\\grain0, \\freq, 400 * Pwhite(-24.0, 24).midiratio);\n\t// timechanging with random variation\nPbindef(\\grain0, \\freq, Pn(Penv([400, 2400], [10], \\exp), inf) * Pwhite(-24.0, 24).midiratio);\n\n\t// panning\nPbindef(\\grain0, \\pan, Pwhite(-0.8, 0.8));  // random\nPbindef(\\grain0, \\pan, Pn(Penv([-1, 1], [2]), inf)); // tendency\nPbindef(\\grain0, \\pan, Pfunc({ |ev| ev.freq.explin(50, 5000, -1, 1) })); // coupled to freq\n\n\t// time scattering variants\nPbindef(\\grain0, \\dur, 0.1 * Pwhite(0.5, 1.5));\t// random range\nPbindef(\\grain0, \\dur, 0.05 * Prand([0, 1, 1, 2, 4], inf)); // rhythmic random\n\n\t// amplitude - randomized\nPbindef(\\grain0, \\amp, Pwhite(0.01, 0.2));\t// linear\nPbindef(\\grain0, \\amp, Pwhite(-50, -14).dbamp); // exponential - more depth\nPbindef(\\grain0, \\dur, 0.025 * Prand([0, 1, 1, 2, 4], inf)); // could be denser now\n\n\t// random amplitude envelopes with Pseg\n(\nPbindef(\\grain0, \n\t\\amp, Pseg(\n\t\tPxrand([-50, -20, -30, -40] + 10, inf), // level pattern\n\t\tPxrand([0.5, 1, 2, 3], inf), \t\t// time pattern\n\t\tPrand([\\step, \\lin], inf)\t\t\t// curve pattern\n\t).dbamp\n); \n)\n\t// grain sustain time coupled to freq\nPbindef(\\grain0, \\sustain, Pkey(\\freq).reciprocal * 20).play;\n\n",
    "Ch16_fig_013.scd": "\u00ef\u00bb\u00bf\tFigure 16.13: GrainFM with individual control proxies\n\n\t// figure 16.13   - GrainFM with individual control proxies\np = ProxySpace.push;\n\n(\n~trig = { |dens=10| Impulse.kr(dens) };\n~freq = { MouseX.kr(100, 2000, 1) * LFNoise1.kr(1).range(0.25, 1.75) };\n~moddepth = { LFNoise1.kr(20).range(1, 10) };\n~modfreq = 200;\n~graindur = 0.1;\n\n~grain = { arg envbuf = -1;\n\tGrainFM.ar(2, ~trig.kr, ~graindur.kr, \n\t\t~freq.kr, ~modfreq.kr, ~moddepth.kr, \n\t\tpan: WhiteNoise.kr, envbufnum: envbuf) * 0.2\n};\n~grain.play;\n)\n\t// change control ugens: \n~modfreq = { ~freq.kr * LFNoise2.kr(1).range(0.5, 2.0) }; // modfreq roughly follows freq\n~trig = { |dens=10| Dust.kr(dens)};\t// random triggering, same density\n~freq = { LFNoise0.kr(0.3).range(200, 800) };\n~moddepth = 3; \t// fixed depth\n~graindur = { LFNoise0.kr.range(0.01, 0.1) };\n\n",
    "Ch16_fig_014.scd": "\u00ef\u00bb\u00bfFigure 16.14: GrainBuf with control proxies\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~grain.set(\\wavebuf, b.bufnum);\n~trig = { |dens=10| Impulse.kr(dens) };\n~graindur = 0.1;\n~filepos = {LFNoise2.kr(0.2).range(0, 1) };\n~rate = { LFNoise1.kr.range(0.5, 1.5) };\n\n~grain = { arg envbuf = -1, wavebuf = 0;\n\tGrainBuf.ar(2, ~trig.kr, ~graindur.kr, wavebuf, \n\t~rate.kr, ~filepos.kr, 2, WhiteNoise.kr, envbuf) * 0.2\n};\n~grain.play;\n)\n\n\t// experiment with control proxies\n~trig = { |dens=20| Impulse.kr(dens) };\n~rate = { LFNoise1.kr.range(0.99, 1.01) };\n~filepos = { MouseX.kr + LFNoise0.kr(100, 0.03) };\n~graindur = 0.05;\n~trig = { |dens=50| Dust.kr(dens) };\n\nc = Buffer.sendCollection(s, Env.perc(0.01, 0.99).discretize, 1);\n~grain.set(\\envbuf, c.bufnum); \n~grain.set(\\envbuf, -1);\n\n~trig = { |dens=50| Impulse.kr(dens) }; ~graindur = 0.05;\n\n\n",
    "Ch16_fig_015.scd": "\u00ef\u00bb\u00bfFigure 16.15: Glisson synthesis\n\n(\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\nSynthDef(\"glisson\", \n\t{ arg out = 0, envbuf, freq=800, freq2=1200, sustain=0.001, amp=0.2, pan = 0.0;\n\t\tvar env = Osc1.ar(envbuf, sustain, 2);\n\t\tvar freqenv = XLine.ar(freq, freq2, sustain);\n\t\tOffsetOut.ar(out, \n\t\t\tPan2.ar(SinOsc.ar(freqenv) * env, pan, amp)\n\t\t)\n}, \\ir!7).add;\n)\n\n(\nTdef(\\gliss0, { |e|\n\t100.do({ arg i;\n\t\ts.sendBundle(s.latency, [\"/s_new\", \"glisson\", -1, 0, 0, \n\t\t\t\\freq, i % 10 * 100 + 1000,\n\t\t\t\\freq2, i % 13 * -100 + 3000,\n\t\t\t \\sustain, 0.05, \n\t\t\t \\amp, 0.1,\n\t\t\t \\envbuf, b.bufnum\n\t\t]);\n\t\t(3 / (i + 10)).wait;\n\t});\n}).play;\n)\n\n\n\n",
    "Ch16_fig_016.scd": "\u00ef\u00bb\u00bfFigure 16.16: Pulsar basics \u00e2\u0080\u0093 a set of waveform and control tables\n\n\t// figure 16.16 - Pulsar basics - make a set of waveform and control tables\n(\nq = ();\nq.curr = (); \t// make a dict for the set of tables\nq.curr.tab = ();\n\t\t\t\t// random tables for pulsaret  and envelope waveforms:\nq.curr.tab.env = Env.perc.discretize; \nq.curr.tab.pulsaret = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// random tables for the control parameters:\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.curr.tab.amp = 0.2.dup(1024);\nq.curr.tab.pan = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// make buffers from all of them:\nq.bufs = q.curr.tab.collect({ |val, key| Buffer.sendCollection(s, val, 1) });\n)\n\t\t// plot one of them\nq.bufs.pulsaret.plot2(\"a pulsaret\");\n\n\n",
    "Ch16_fig_017.scd": "\u00ef\u00bb\u00bfFigure 16.17: Pulsars as nodeproxies using GrainBuf\n\n(\np = ProxySpace.push; \n\n\t\t// fund, form, amp, pan\n~controls = [ 16, 100, 0.5, 0]; \n~pulsar1.set(\\wavebuf, q.bufs.pulsaret.bufnum);\n~pulsar1.set(\\envbuf, q.bufs.env.bufnum);\n\n~pulsar1 = { |wavebuf, envbuf = -1| \n\tvar ctls = ~controls.kr;\n\tvar trig = Impulse.ar(ctls[0]);\n\tvar grdur = ctls[1].reciprocal;\n\tvar rate = ctls[1] * BufDur.kr(wavebuf);\n\t\t\n\tGrainBuf.ar(2, trig, grdur, wavebuf, rate, 0, 4, ctls[3], envbuf);\n};\n~pulsar1.play;\n)\n\n\t// crossfade between control settings\n~controls.fadeTime = 3; \n~controls = [ 16, 500, 0.5, 0]; \t// change formfreq\n~controls = [ 50, 500, 0.5, 0]; \t// change fundfreq\n~controls = [ 16, 100, 0.5, 0]; \t// change both\n~controls = [ rrand(12, 100), rrand(100, 1000)]; \n\n(\t// control parameters from looping tables\n~controls = { |looptime = 10| \n\tvar rate = BufDur.kr(q.bufs.pulsaret.bufnum) / looptime; \n\tA2K.kr(PlayBuf.ar(1, [\\fund, \\form, \\amp, \\pan].collect(q.bufs[_]), \n\t\trate: rate, loop: 1));\n};\n)\n\n",
    "Ch16_fig_018.scd": "\u00ef\u00bb\u00bfFigure 16.18: Making new tables and sending them to buffers\n\nq.bufs.pulsaret.sendCollection(Array.linrand(1024, -1.0, 1.0)); // noise burst\nq.bufs.pulsaret.read(\"sounds/a11wlk01.wav\", 44100 * 1.5);       // sample\nq.bufs.pulsaret.sendCollection(Pbrown(-1.0, 1.0, 0.2).asStream.nextN(1024));\n\n\t// make a new random fundfreq table, and send it\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.bufs.fund.sendCollection(q.curr.tab.fund);\n\n\t// and a new random formfreq table\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.bufs.form.sendCollection(q.curr.tab.form);\n\n\n",
    "Ch16_fig_019.scd": "\u00ef\u00bb\u00bfFigure 16.19: A nodeproxy for time-pitch changing\n\np = ProxySpace.push(s.boot);\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~timepitch = {arg sndbuf, pitchRatio=1, pitchRd=0.01, grainRate=10, overlap=2, \n\tposSpeed=1, posRd=0.01;\n\t\n\tvar graindur = overlap / grainRate;\n\tvar pitchrate = pitchRatio + LFNoise0.kr(grainRate, pitchRd);\n\tvar position = LFSaw.kr(posSpeed / BufDur.kr(sndbuf)).range(0, 1) \n\t\t+ LFNoise0.kr(grainRate, posRd);\n\t\t\n\tGrainBuf.ar(2, Impulse.kr(grainRate), graindur, sndbuf, pitchrate,\n\t\t\tposition, 4, 0, -1)\n};\n~timepitch.set(\\sndbuf, b.bufnum);\n~timepitch.play;\n);\n\nSpec.add(\\pitchRatio, [0.25, 4, \\exp]);\nSpec.add(\\pitchRd, [0, 0.5, \\amp]);\nSpec.add(\\grainRate, [1, 100, \\exp]);\nSpec.add(\\overlap, [0.25, 16, \\exp]);\nSpec.add(\\posSpeed, [-2, 2]);\nSpec.add(\\posRd, [0, 0.5, \\amp]);\nNodeProxyEditor(~timepitch, 10);\n\n\t// reconstruct original\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 1, \\posRd, 0);\n\n\t// four times as long: tweak pitchRd and posJitter to reduce artifacts\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0);\n\n\t// random read position, random pitch\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0.5, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0.5);\n\n",
    "Ch16_fig_020.scd": "\u00ef\u00bb\u00bfFigure 16.20: A constant-Q Synthdef.\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\nSynthDef(\\constQ, { |out, bufnum=0, amp=0.5, pan, centerPos=0.5, sustain=0.1, \n\trate=1, freq=400, rq=0.3| \n\n\tvar ringtime = (2.4 / (freq * rq) * 0.66).min(0.5); // estimated\n\tvar ampcomp = (rq ** -1) * (400 / freq ** 0.5);\t\n\tvar envSig = EnvGen.ar(Env([0, amp, 0], [0.5, 0.5] * sustain, \\welch));\n\tvar cutoffEnv = EnvGen.kr(Env([1, 1, 0], [sustain+ringtime,0.01]), doneAction: 2);\n\tvar grain = PlayBuf.ar(1, bufnum, rate, 0, \n\t\tcenterPos - (sustain * rate * 0.5) * BufSampleRate.ir(bufnum), \n\t\t1) * envSig;\t\n\tvar filtered = BPF.ar( grain, freq, rq, ampcomp ); \n\n\tOffsetOut.ar(out, Pan2.ar(filtered, pan, cutoffEnv))\n}, \\ir.dup(8)).add;\n)\n\nSynth(\\constQ, [\\bufnum, b, \\freq, exprand(100, 10000), \\rq, exprand(0.01, 0.1), \\sustain, 0.01]);\n\n",
    "Ch16_fig_021.scd": "\u00ef\u00bb\u00bfFigure 16.21: A stream of constant-Q grains\n(\nPbindef(\\gr1Q, \n\t\\instrument, \\constQ, \\bufnum, b.bufnum,\n\t\\sustain, 0.01, \\amp, 0.2,\n\t\\centerPos, Pn(Penv([1, 2.0], [10], \\lin)), \n\t\\dur, Pn(Penv([0.01, 0.09, 0.03].scramble, [0.38, 0.62] * 10, \\exp)),\n\t\\rate, Pwhite(0.95, 1.05), \n\t\\freq, Pbrown(64.0, 120, 8.0).midicps,\n\t\\pan, Pwhite(-1, 1, inf),\n\t\\rq, 0.03\n).play;\n)\n\t// changing parameters while playing\nPbindef(\\gr1Q, \\rq, 0.1);\nPbindef(\\gr1Q, \\rq, 0.01);\nPbindef(\\gr1Q, \\sustain, 0.03, \\amp, 0.08);\nPbindef(\\gr1Q, \\freq, Pbrown(80, 120, 18.0).midicps);\n\nPbindef(\\gr1Q, \\rq, 0.03);\n\nPbindef(\\gr1Q, \\rate, Pn(Penv([1, 2.0], [6], \\lin)));\n\n\t// variable duration\nPbindef(\\gr1Q, \\dur, Pwhite(0.01, 0.02));\n\n\t// a rhythm that ends\nPbindef(\\gr1Q, \\dur, Pgeom(0.01, 1.1, 40));\n\n\n\n",
    "Ch16_fig_022.scd": "\u00ef\u00bb\u00bfFigure 16.22: A Wavesets object\n\nw = Wavesets.from(\"sounds/a11wlk01.wav\");\n\nw.xings;\t\t\t// all integer indices of the zero crossings found\nw.numXings;\t\t// the total number of zero crossings\nw.lengths;\t\t// lengths of all wavesets\nw.amps;\t\t\t// peak amplitude of every waveset\nw.maxima;\t\t\t// index of positive maximum value in every waveset\nw.minima;\t\t\t// index of negative minimum value in every waveset\n\nw.fracXings;\t\t// fractional zerocrossing points\nw.fracLengths;\t// and lengths: allows more precise looping.\n\t\t\t\t\nw.lengths.plot;\t// show distribution of lengths\nw.amps.plot;\n\n\t// get data for a single waveset: frameIndex, length (in frames), dur\nw.frameFor(140, 1);\t\nw.ampFor(140, 1);\t\t// peak amplitude of that waveset or group\n\t\n\t// extract waveset by hand\nw.signal.copyRange(w.xings[150], w.xings[151]).plot(\"waveset 150\");\nw.plot(140, 1);\t// convenience plotting\nw.plot(1510, 1);\t\n\n\t// plot a group of 5 adjacent wavesets\nw.plot(1510, 5)\t\n\n\n",
    "Ch16_fig_025.scd": "\u00ef\u00bb\u00bfFigure 16.25: Playing Wavesets from buffers.\n\n(\n\t// A wavesets loads the file into a buffer by default.\n\t\tb = w.buffer;\t\t\n\t// Wavesets.prepareSynthDefs loads this synthdef: \n\t\tSynthDef(\\wvst0, { arg out = 0, buf = 0, start = 0, length = 441, playRate = 1, sustain = 1, amp=0.2, pan; \n\t\t\tvar phasor = Phasor.ar(0, BufRateScale.ir(buf) * playRate, 0, length) + start;\n\t\t\tvar env = EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2);\n\t\t\tvar snd = BufRd.ar(1, buf, phasor) * env;\n\t\t\t\n\t\t\tOffsetOut.ar(out, Pan2.ar(snd, pan));\n\t\t}, \\ir.dup(8)).add;\n)\n\n// play from frame 0 to 440, looped for 0.1 secs, so ca 10 repeats. \n(instrument: \\wvst0, bufnum: b.bufnum, start: 0, length: 440, amp: 1, sustain: 0.1).play;\n\n\t// get data from waveset\n(\nvar start, length, sustain, repeats = 20; \n#start, length, sustain = w.frameFor(150, 5);\n\n(\tinstrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\tstart: start, length: length, sustain: sustain * repeats\n).play;\n)\n\n\t// or even simpler: \nw.eventFor(startWs: 150, numWs: 5, repeats: 20, playRate: 1).put(\\amp, 0.5).play;\n\n",
    "Ch16_fig_026.scd": "\u00ef\u00bb\u00bfFigure 16.26: A pattern to play wavesets\n\n\t// by default, this pattern reconstructs a soundfile segment as is.\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 3000), 1), \n\t\\numWs, 1, \n\t\\playRate, 1, \n\t\\bufnum, b.bufnum, \n\t\\repeats, 1, \n\t\\amp, 0.4,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur; \n\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\t\t[start, length, wsDur * ev[\\repeats] / ev[\\playRate].abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\n",
    "Ch16_fig_027.scd": "\u00ef\u00bb\u00bfFigure 16.27: Some of Trevor Wishart's transforms\n\n\t// waveset transposition: every second waveset, half speed\nPbindef(\\ws1, \\playRate, 0.5, \\startWs, Pn(Pseries(0, 2, 500), 1)).play;\n\n\t// reverse every single waveset \nPbindef(\\ws1, \\playRate, -1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\t// reverse every 2 wavesets\nPbindef(\\ws1, \\numWs, 2, \\playRate, -1, \\startWs, Pn(Pseries(0, 2, 1000), 1)).play;\n\t// reverse every 20 wavesets\nPbindef(\\ws1, \\numWs, 20, \\playRate, -1, \\startWs, Pn(Pseries(0, 20, 1000), 1)).play;\n\t// restore\nPbindef(\\ws1, \\numWs, 1, \\playRate, 1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\n\t// time stretching\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 4).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1, \\repeats, 1).play;\t// restore\n\n\t// waveset omission: drop every second\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1,1, \\, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pfunc({ if (0.25.coin, 1, \\) }) ).play; // drop randomly\nPbindef(\\ws1, \\numWs, 1, \\freq, 1, \\startWs, Pn(Pseries(0, 1, 1000)) ).play; // restore\n\n\t// waveset shuffling (randomize waveset order +- 5, 25, 125)\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 5.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 25.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 125.rand2 })).play;\t\n\n",
    "Ch16_fig_028.scd": "\u00ef\u00bb\u00bfFigure 16.28: Waveset substitution\n\t\n\t// the waveform to substitute\nc = Buffer.alloc(s, 512); c.sendCollection(Signal.sineFill(512, [1]));\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 1000), 5), \n\t\\numWs, 1, \\playRate, 1, \n\t\\buf, c.bufnum, // sine wave\n\t\\repeats, 1, \n\t\\amp, 1,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur, origRate; \n\t\torigRate = ev[\\playRate];\n\t\t\n\t\t\t// get orig waveset specs\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\n\t\t\t// adjust playrate for different length of substituted wave\n\t\tev[\\playRate] = origRate * (512 / length); \n\n\t\t\t// get amplitude from waveset, to scale full volume sine wave\n\t\tev[\\amp] = ev[\\amp] * w.ampFor(ev[\\startWs], ev[\\numWs]);\n\t\t\n\t\t[0, 512, wsDur * ev[\\repeats] / origRate.abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\t// clearer sinewave-ish segments\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1).stop;\n\n\t// different waveforms\nc.sendCollection(Signal.sineFill(512, 1/(1..4).squared.scramble));\nc.sendCollection(Signal.rand(512, -1.0, 1.0));\nc.sendCollection(Signal.sineFill(512, [1]));\n\nc.plot;\n\n",
    "Ch16_fig_029.scd": "\u00ef\u00bb\u00bfFigure 16.29: Wavesets played with a Tdef \n\t\n\t// very simple first pass, fixed repeat time\n(\nTdef(\\ws1).set(\\startWs, 400);\nTdef(\\ws1).set(\\numWs, 5);\nTdef(\\ws1).set(\\repeats, 5);\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain; \n\n\tloop { \n\t\t#startFrame, length, wsSustain = w.frameFor(ev.startWs.next, ev.numWs);\n\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * ev.repeats;\n\t\t).play;\n\t\t\n\t\t0.1.wait;\t\n\t}\n}).play;\n)\n\nTdef(\\ws1).set(\\startWs, 420);\nTdef(\\ws1).set(\\repeats, 3);\nTdef(\\ws1).set(\\numWs, 2);\n\n\t\t// drop in a pattern for starting waveset \t\t\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n",
    "Ch16_fig_030.scd": "\u00ef\u00bb\u00bfFigure 16.30: Waittime derived from waveset duration and an added gap \n(\nTdef(\\ws1).set(\\gap, 3);\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps; \n\n\tloop { \n\t\treps = ev.repeats.next;\n\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, ev.numWs.next);\t\t\t\n\t\t\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * reps,\n\t\t\tpan: 1.0.rand2\n\t\t).play;\n\t\t\n\t\t\t// derive waittime from waveset sustain time\n\t\t\t// add gap based on waveset sustain time \n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\t// experiment with dropping in patterns:\n\t// very irregular gaps\nTdef(\\ws1).set(\\gap, { exprand(0.1, 20) });\n\t// sometimes continuous, sometimes gaps\nTdef(\\ws1).set(\\gap, Pbrown(-10.0, 20, 2.0).max(0).asStream);\n\n\t// random repeats\nTdef(\\ws1).set(\\repeats, { exprand(1, 20).round });\n\t// randomize number of wavesets per group\nTdef(\\ws1).set(\\numWs, { exprand(3, 20).round });\nTdef(\\ws1).set(\\numWs, 3, \\repeats, { rrand(2, 5) });\n\nTdef(\\ws1).stop;\n\n",
    "Ch16_fig_031.scd": "\u00ef\u00bb\u00bfFigure 16.31: Wavesets with pitch contour and dropout rate\n(\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\nTdef(\\ws1).set(\\gap, 0);\nTdef(\\ws1).set(\\pitchContour, 0);\nTdef(\\ws1).set(\\keepCoin, 1.0);\nTdef( 'ws1' ).set( 'repeats' , 5 );\nTdef( 'ws1' ).set( 'numWs' , 3 );\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps, numWs, len2Avg; \n\tvar squeezer, playRate;\n\tloop { \n\t\treps = ev.repeats.next;\n\t\tnumWs = ev.numWs.next;\n\t\t\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, numWs);\t\t\t\n\t\t\n\t\tlen2Avg = length / numWs / w.avgLength;\t\t\n\t\tsqueezer = len2Avg ** ev.pitchContour.next;\n\t\twsSustain = wsSustain / squeezer; \n\t\tplayRate = 1 * squeezer;\n\n\t\tif (ev.keepCoin.next.coin) { \n\t\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\t\tstart: startFrame, length:  length, \n\t\t\t\tsustain: wsSustain * reps,\n\t\t\t\tplayRate: playRate, \n\t\t\t\tpan: 1.0.rand2\n\t\t\t).play;\n\t\t};\n\t\t\n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\n\t// try different pitch Contours:\nTdef(\\ws1).set(\\pitchContour, 0); \t// original pitch\n\nTdef(\\ws1).set(\\pitchContour, 0.5); // flattened contour\n\n\t\t// waveset overtone singing - all equal length\nTdef(\\ws1).set(\\pitchContour, 1.0); \n\n\t\t// inversion of contour\nTdef(\\ws1).set(\\pitchContour, 1.5);\nTdef(\\ws1).set(\\pitchContour, 2);\nTdef(\\ws1).set(\\repeats, 3); \n\n\t// waveset omission\nTdef(\\ws1).set(\\keepCoin, 0.75);\nTdef(\\ws1).set(\\keepCoin, 1);\n\n\t// fade out by omission over 13 secs, pause 2 secs \nTdef(\\ws1).set(\\keepCoin, Pn(Penv([1, 0, 0], [13, 2])).asStream).play;\n\n\t// add a pitch contour envelope\nTdef(\\ws1).set(\\pitchContour, Pn(Penv([0, 2, 0], [21, 13])).asStream);\n\n",
    "Ch17_fig_001.scd": "\u00ef\u00bb\u00bf(\n// read a whole sound into memory\ns = Server.local;\nb = Buffer.read(s,\"sounds/a11wlk01.wav\"); // remember to free the buffer later.\n)\n(\nSynthDef(\"help_PlayBuf\", { arg out=0,bufnum=0, rate=1;\nOut.ar(out,\nPan2.ar(\nPlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)*rate, loop: 1),\n0)\n)\n}).add;\n)\np=Synth(\\help_PlayBuf, [\\rate, 0.midiratio,\\out, 0, \\bufnum, b.bufnum]); // original pitch\np.set(\\rate, 12.midiratio);\t// one octave up\np.set(\\rate, 7.midiratio);\t// seven semitones up (fifth interval)\n\np.free;\np=nil;\nb.free;\nb=nil;\n\n",
    "Ch17_fig_002.scd": "\u00ef\u00bb\u00bfFigure  17.2 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5, 7]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_003.scd": "\u00ef\u00bb\u00bf  Figure  17.3 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5.25, 7.5]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_004.scd": "\u00ef\u00bb\u00bfFigure  17.4 \n\n(\nPbind(\n\\note, Pseq([0,2,4,5,7,9,11,12], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_005.scd": "\u00ef\u00bb\u00bf  Figure  17.5 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_006.scd": "\u00ef\u00bb\u00bfFigure  17.6 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5,\n\\scale, (0..11)\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_007.scd": "\u00ef\u00bb\u00bfFigure  17.7 \n\n(\nPbind(\n\\degree, Pseq([0, 2, 2.1, 2.05], inf),\n\\dur, 0.3,\n\\scale, (0..11),\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_008.scd": "\u00ef\u00bb\u00bfFigure  17.8 \n\n(\nPbind(\n\\note, Pwhite(-6,9),\n\\dur, 0.3,\n\\sustain, 1.1,\n\\stepsPerOctave, 7\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_009.scd": "\u00ef\u00bb\u00bf    Figure  17.9 \n(\ne=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 4, 8, 11, 14, 17]\n).play;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_010.scd": "\u00ef\u00bb\u00bfFigure  17.10 \n\n(\n// previous example should still be running\ne.stream=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 3, 5, 8, 10, 13]\n).asStream;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_011.scd": "\u00ef\u00bb\u00bf  Figure  17.11 \n\n(\nvar stepsperoctave=3;\nArray.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\n)\n\n//Using a function to calculate the value at a chosen degree\n(\nf = {|degree, steps|\n2.pow(degree/steps)\n};\n)\n// \tdegree 0\nf.(0, 3);\n// \tdegree 1\nf.(1, 3);\n// \tdegree 2\nf.(2, 3);\n\n//The function is modified to multiply the value by a root frequency in Hertz\n(\nf = {|degree, steps, root=440|\n2.pow(degree/steps)*root\n};\n)\n//\t12 notes per octave, degrees 0,1 and 12\nf.(0,12)\nf.(1, 12)\nf.(12, 12)\n\n//\t14 notes per octave, degrees 0,1, 12 and 14\nf.(0,14)\nf.(1, 14)\nf.(12, 14)\nf.(14,14)\n//////////////////////////////////////////////////////\n\n\n",
    "Ch17_fig_012.scd": "\u00ef\u00bb\u00bfFigure 17.12 \n\n(\nSynthDef(\"tone2\", { arg freq = 440, amp=0.5, gate=1, envdur=1.5;\nvar sound, env;\nenv = EnvGen.kr(Env.perc(0.01, envdur), doneAction:2);\nsound = Pan2.ar(SinOsc.ar(freq, 0, amp)*env, 0);\nOut.ar(0, sound);\n}).add;\n)\n(\na=[ 1, 1.030303030303, 1.0606060606061, 1.1212121212121, 1.3636363636364, 1.6060606060606, 2 ]*220;\n\n// Play the all the notes of the tuning\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).play\n)\n// Choose the notes randomly\n(\ne.stream=Pbind(\n\\freq, Pn(Prand( a, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).asStream\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_013.scd": "\u00ef\u00bb\u00bfFigure 17.13 \n\n(\n~rationames=[1/1, 8/7, 7/6, 6/5, 5/4, 4/3, 7/5, 10/7, 3/2, 8/5, 5/3, 12/7, 7/4];\n~scale=[0,3,5,8,10,12];\ne = Pbind(\n\\freq, Pseq([\nPfunc({\n(~rationames.wrapAt(~scale).[~scale.size.rand])*440\n})\n],inf),\n\\dur, 0.25,\n\\amp, 0.5,\n\\instrument, \\tone2\n).play; // returns an EventStream\n)\n// set a new scale\n~scale=[0,2,5,7,9,11];\n~scale=[0,1,3,5,6,8,9];\n~scale=[0,3,5,8,10,12];\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_014.scd": "\u00ef\u00bb\u00bfFigure 17.14 \n\n(\nvar n, buts, synths, ratios, rationames;\nw = Window(\"tonality diamond\", Rect(200,500,420,150));\nw.view.decorator = FlowLayout(w.view.bounds);\n\nrationames=[\n\"7/4\", \"3/2\",\"5/4\",\"1/1\",\n\"7/5\",\"6/5\",\"1/1\",\"8/5\",\n\"7/6\",\"1/1\",\"5/3\",\"4/3\",\n\"1/1\",\"12/7\",\"10/7\",\"8/7\"\n];\n\nn=rationames.size;\n\nn.do({ |i|\nButton(w, Rect(20,20+(i*30),100,30))\n.states_([[rationames[i], Color.black, \nif((rationames[i])==\"1/1\", {Color.red},{Color.yellow})\n]\n])\n.action_({ arg butt;\nSynth(\\tone2, [\\freq, ((rationames[i]).interpret)*440]);\n\n})\n});\nw.front;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_016.scd": "\u00ef\u00bb\u00bfFigure 17.16 \n\n(\na=Pbind(\n\\degree, Pwhite(0, 12),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pwhite(0, 14),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_017.scd": "\u00ef\u00bb\u00bfFigure 17.17 \n\n(\na=Pbind(\n\\degree, Pfunc({\n[\n[0, 6, 12].choose, 12.rand\n].choose;\n}),\n\\dur, 0.5,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pfunc({\n[\n[0, 7, 14].choose, 14.rand\n].choose;\n}),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.3,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_018.scd": "\u00ef\u00bb\u00bfFigure 17.18 \n\n(\n~tolerance={|a, b, t, max|\nvar c, d;\nc=[];\nd=[];\na.do({ |aitem, aindex|\nb.do({ |bitem, bindex|\nvar x;\nx = (aitem-bitem).abs;\nif( (x > t) && (x < max),\n{\nc=c.add(aindex);\nd=d.add(bindex);\n//[aitem, bitem].post; \" out of tune \".post; [aindex, bindex].postln;\n//\" \".postln;\n})\n})\n});\n[(0..a.size).difference(c), (0..b.size).difference(d)];\n};\n)\n\n(\n// use the function function with two tunings\nvar mintreshold, maxtreshold, int;\n\n// two different equal tunings expressed linearly\na=Array.fill(12, { |i| (1/12)*(i) });\nb=Array.fill(21, { |i| (1/21)*(i) });\n\nint=1/21;\t\t\t\t// smallest interval\nmintreshold=int*0.15;\nmaxtreshold=int*0.85;\n/*\nintervals inferior to mintreshold are in tune\nintervals between mintreshold and maxtreshold are out of tune\nintervals superior to maxtreshold are in tune\n*/\n\n// print a list of notes from the two tunings which form a dissonant interval\n~tolerance.value(a, b, mintreshold, maxtreshold);\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_019.scd": "\u00ef\u00bb\u00bfFigure 17.19 \n\n(\na=Pbind(\n\\degree, Pfunc({\n// notes which clash with the other tuning have been removed\n[0,4,8,12].choose\n}),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).play;\nb=Pbind(\n// notes which clash with the other tuning have been removed\n\\degree, Pfunc({\n[0,7,14,21].choose\n}),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.35,\n\\sustain, 0.85,\n\\stepsPerOctave, 21,\n\\instrument, \\tone2\n).play;\n)\n\n(\na.stream=Pbind(\n// introducing more notes from that tuning after having changed the threshold\n\\degree, Pfunc({\n[ 0, 1, 4, 7, 8, 9, 9, 12 ].choose\n}),\n\\dur, 0.75,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).asStream;\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_020.scd": "\u00ef\u00bb\u00bfFigure 17.20 \n\n(\nf = {|steps| Array.fill(steps, { |i| 2.pow(i/steps) }) };\n//\tCalculation of the twelve equal-note temperament\nx =  f.(12);\n//\tmapping the tuning to a new range beyond an octave\ny = x.linlin(1, 2, 1, 2.25);\n//\tmultiplying by a root frequency\na=y*440;\n\nPbind(\n\\freq, Pfunc({ a.choose }),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_021.scd": "\u00ef\u00bb\u00bfFigure 17.21 \n\n(\nPbind(\n\\degree, Pwhite(0, 18),\n\\dur, 0.3,\n\\sustain, 1.0,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2,\n\\stepsPerOctave,  18.809\n).play;\n)\n//////////////////////////////////////////////////////\n\n\n",
    "Ch17_fig_022.scd": "\u00ef\u00bb\u00bfFigure 17.22 \n\n(\na=[ 1, 1.09375, 1.1875, 1.28125, 1.375, 1.46875, 1.5625, 1.65625];\nb=a*440;\ne=Pbind(\n\\freq, Pseq( b, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).play\n)\n// play in a different order\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( b, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).asStream\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_023.scd": "\u00ef\u00bb\u00bf   Figure 17.23 \n\n(\n// F. Mogini pattern-based Tuning - 2000.\nx=880;\n\nPbind(\n\\freq, Pn(\nPlazy({\nif(x<=150, {x=x*2});\nif(x>=2000, {x=x/2});\nx=[\n\nx*[1.1428,  1.36, 1.26].choose,\nx/[1.1428,  1.36, 1.26].choose\n\n].choose\n})\n),\n\\dur, 0.14,\n\\sustain, 0.8,\n\\cutoff, Pfunc({ 1.0.rand})\n).play;\n)\n//////////////////////////////////////////////////////\n\n\n",
    "Ch17_fig_024.scd": "\u00ef\u00bb\u00bfFigure 17.24 \n\na=(1..16)*100\n(\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2\n).play\n)\n\n// a beautiful tuning system can be created from the harmonic series.\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( a, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).asStream\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_025.scd": "\u00ef\u00bb\u00bfFigure 17.25\n\na=(1..11);\n(\na.size.do({ |i|\nvar x=a[i];\nwhile({x>2},{x=x/2});\na.put(i, x)\n});\n)\n\nb=a.asSet.asArray.sort;\n(\ne=Pbind(\n\\freq, Pn(Pshuf( b*440, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_026.scd": "\u00ef\u00bb\u00bfFigure 17.26 \n\na=(1..8);\nb=(9..16);\n(\na.size.do({ |i|\nvar x=a[i];\nvar y=b[i];\n// harmonics below 8 remain in the first octave\nwhile({x>2},{x=x/2});\n// harmonics above 9 remain in the second octave\nwhile({y>4},{y=y/2});\na.put(i, x);\nb.put(i, y);\n});\n)\na;\nb;\nc=(a++b).asSet.asArray.sort;\nc;\n\n(\ne=Pbind(\n\\freq, Pn(Pshuf( c*200, 1)),\n\\dur, 0.2,\n\\sustain, 1.1\n).play\n)\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_027.scd": "\u00ef\u00bb\u00bf  Figure 17.27 \n\n(\n// \ta function to expand the tuning from one octave to four octaves\n~harmsfunc={arg stepsperoctave=7;\nvar harms;\n// calculate each note from the tuning\nharms=Array.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\nharms.size.do({ |i|\nif( 0.6.coin, {\n// multiply some of the notes to create higher harmonics\nharms.put(i, (harms[i])*[1,2,4,8].choose )\n})\n});\nharms.sort;\n};\n)\n\n//  create an array of virtual harmonics, seven equal-note temperament\n~harms=~harmsfunc.value(7);\n\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).add;\n)\n\n(\ne=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are rpeated so we can notice the effect of harmonics\n\\degree, Pseq([0,1,2,3,4,5,6,7],inf),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).play;\n)\n\nSend the SynthDef function again to obtain new amplitudes for each harmonic\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).add;\n)\n\n// re-evalute the function to create new harmonics (update the SynthDef afterwards)\n~harms=~harmsfunc.value(7);\n//Send the SynthDef function again, as we have done earlier to obtain new amplitudes for each harmonic\n\n// finally playing a random melody to make it less repetitive\n(\ne.stream=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are repeated so we can notice the effect of harmonics\n\\degree,  Pwhite(0, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).asStream;\n)\n// we could develop further and re-write the SynthDef with a partial argument \n// and also change the partials directly from Pbind\n\n//////////////////////////////////////////////////////\n\n",
    "Ch17_fig_028.scd": "\u00ef\u00bb\u00bfFigure 17.28 \n\n(\nvar w, keys, steps, octaves;\n\nw = Window.new.name=\"Custom keyboard: 7 steps per octave\";\nsteps = 7;\noctaves= 2;\n// seven steps per octave;\na=Array.fill(7, { |i| (1/7)*(i) })+1;\nb= a++(a*2);\n\nc=Synth(\\default, [\\amp, 0]);\n\nkeys=Array.fill(steps*octaves,{ |i|\n\nButton(w, Rect(20+(i*22),20,20,50))\n.states_([\nif(i.mod(steps)==0,{\n[i.asString, Color.black, Color.red]},{\n[i.asString, Color.black, Color.yellow]});\n\n])\n.action_({ arg butt;\nc.set(\\freq,b[i]*220, \\amp, 0.25)\n});\n});\n\nw.front;\n)\n//////////////////////////////////////////////////////\n\n\n",
    "Ch18_fig_001.scd": "\u00ef\u00bb\u00bfFigure 18.1\n/*\nThis example is adapted and extracted from the Non-Realtime Synthesis helpfile itself, accessible from the Main SuperCollider help page.\n*/\n(\nvar f, c, d;\n// open a file for writing raw OSC data to\nf = File(\"~/test.osc\".standardizePath,\"w\");\n// start a sine oscillator at 0.2 seconds.\nc = [ 0.2, [\\s_new, \\default, 1001, 0, 0]];\n// convert the bundle to raw OSC\nd = c.asRawOSC;\nf.write(d.size); // each bundle is preceded by a 32 bit size.\nf.write(d); // write the bundle data.\nf.close;\n)\n\n\n",
    "Ch18_fig_002.scd": "\u00ef\u00bb\u00bfFigure 18.2\ns = Server.local;\ns.boot;\n\n// a sample SynthDef\nSynthDef(\\NRT_beep, {arg freq, dur, amp = 0.1;\n\tvar half;\n\thalf = dur * 0.5;\n\tOut.ar(0, SinOsc.ar(freq, 0, \n\t\tEnvGen.kr(Env.new([0, amp, 0], [half, half], [4, -4]))));\n\t}).load(s);\n\n(\nvar score;\n\n// A Score, created from a note-list of time-stamped events.\nscore = Score.new([\n    [0.0,\n        [\\g_new, 1000],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.0,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [2.0,\n        [\\n_free, 1001, 1000]\n    ],\n\t[2.00001, [0]]\n]);\n\nscore.play(s); // play the Score in real-time...\n\n// ... or render in Non-Real-Time\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n)\n",
    "Ch18_fig_003.scd": "\u00ef\u00bb\u00bfFigure 18.3\n(\n//In this example, we use the higher-level server abstraction classes, Group and Synth to handle the\n// node IDs. At least as important though is the use of variables. Now that the relationships are\n// specified rather than the specific values, we can change the gesture dramatically by changing\n// just one or two variables. To transpose everything, we only need to change the value of \n// ~baseNote. To adjust the duration, we only need to change the ~dur variable, and this is now \n// independent of the deltaOn (i.e. independent of the amount of time between the start of one\n// note and the start of the next note).\nvar score;\nvar deltaOn = 0.2;  //amount of time between the start of one note and the start of the next note\nvar dur = 0.4;      //try changing dur to 0.3, 1.4, 3.4, or whatever you like\nvar baseNote = 75;  //transpose the entire fragment up or down\nvar firstPitch  = (baseNote + 0).midicps;  //alter the relationship between any of the pitches\nvar secondPitch = (baseNote - 4).midicps;  // without effecting the others\nvar thirdPitch  = (baseNote + 7).midicps;\n\nscore = Score.new([\n\t[t =  0.0,\n\t\t(g = Group.basicNew(s)).newMsg,\n\t\t//we use environment variables here (identified by the preceding ~) \n\t\t// since we might add or remove events; hence we don't know ahead of \n\t\t// time how many events we have, and therefore how many variables we'll need\n\t\t(~s01 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s01.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s02 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s02.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s03 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t],\n\t[t + dur,\n\t\t~s03.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s04 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s04.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s05 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s05.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s06 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s06.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s07 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s07.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s08 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s08.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s09 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s09.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s10 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s10.freeMsg,\n\t\tg.freeMsg\n\t],\n]\n);\n\nscore.sort;\nscore.play(s);\n)\n\n\n",
    "Ch18_fig_004.scd": "\u00ef\u00bb\u00bf\nFigure 18.4\n(\nvar score, graingest;\n\n// seed the randomness\nthisThread.randSeed_(123);\n\n// a sample SynthDef\nSynthDef(\\NRT_grain, {arg freq, dur, amp, pan;\n\tOffsetOut.ar(0, Pan2.ar(\n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.ar(Env.sine(dur, amp), doneAction: 2)),\n\t\tpan)\n\t\t);\n\t}).load(s);\n\nscore = Score.new;\n\n// envelope times are scaled to 1.\ngraingest = {arg score, starttime, duration, windur, overlaps, freqenv, ampenv, panenv;\n\tvar ratio, curfreq, curamp, curpan, notestart, now = 0.0, note;\n\twhile({\n\t\tratio = now / duration;\n\t\tcurfreq = freqenv[ratio];\n\t\tcuramp = ampenv[ratio];\n\t\tcurpan = panenv[ratio];\n\t\tnotestart = now + starttime;\n\t\tnote = Synth.basicNew(\\NRT_grain);\n\t\tscore.add([notestart, \n\t\t\tnote.newMsg(1, [\\freq, curfreq,\\amp, curamp, \\dur, windur, \\pan, curpan], \\addToHead)]\n\t\t\t);\n\t\t// check the current event's endtime against the global endtime\n\t\tnow = now + (windur / overlaps);\n\t\tnow < duration;\n\t\t});\n\t};\n\n// call the above function to populate the Score\n\ngraingest.value(score, 1.0, 10.0, 100.reciprocal, 1, Env([440, 550], [1]), \n\tEnv([0, 0.2, 0], [0.3, 0.7], [4, -4]), Env([0, 0], [1]));\ngraingest.value(score, 3.0, 3.0, 130.reciprocal, 2, Env([700, 400], [1]),\n\tEnv([0, 0.2, 0], [0.1, 0.9], [4, -1]), Env([-0.7, 0.7], [1]));\n\n// create a number of short gestures\n10.do({arg i;\n\tgraingest.value(score, 5.0.rrand(10.0), 3.0.rrand(5.0), (100 * i).reciprocal, [1, 2, 4].choose,\n\t\tEnv([1000, 800], [1]), Env([0, 0.2, 0], [0.5, 0.5]), Env([0.5.rand2, 0.5.rand2], [1]));\n\t});\n\n// save the endtime to the Score to tell NRT when to stop rendering. The above gestures won't\n// be more the 16 seconds\n\nscore.add([16, [0]]);\n\n// sort the score to ensure events are in the correct order\n\nscore.sort;\n\n// render the Score to the users home folder\n\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n\t\n// also save the Score to a file\nscore.saveToFile(\"~/test.sc\".standardizePath);\n)\t\n\n\n",
    "Ch18_fig_005.scd": "\u00ef\u00bb\u00bf\nFigure 18.5\n(\nvar score, sndbuf, starttime, synth, options;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// create a Buffer object for adding to the Score\nsndbuf = Buffer.new;\n\n// for NRT rendering, the buffer messages must be added to the Score\nscore.add([0, sndbuf.allocReadMsg(\"sounds/a11wlk01-44_1.aiff\")]);\n\nstarttime = 0.0;\n\n// a small function to create a series of small notes based on the Buffer\nwhile({\n\tsynth = Synth.basicNew(\\NRT_playback);\n\tscore.add([starttime, \n\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\tstarttime = starttime + 0.05;\n\tstarttime < 10.0;\n\t});\n\n// the dummy command. The soundfile will be 11 seconds long\nscore.add([11, 0]);\n\nscore.sort;\n\n// the ServerOptions for rendering the soundfile\noptions = ServerOptions.new.numOutputBusChannels_(1);\n\n// write the soundfile out to disk\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, options: options);\n)\n\n\n",
    "Ch18_fig_006.scd": "\u00ef\u00bb\u00bfFigure 18.6\n(\nvar score, sndbuf, starttime, synth, options, cond;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// set up a Condition to check for when asynchronous events are finished.\n\ncond = Condition.new;\n\n// wrap the code that will run in real-time in a Routine, to allow for the Server to sync\nRoutine.run({\n\t// load the buffer\n\tsndbuf = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\t\n\t// pause while the buffer is loaded\n\ts.sync(cond);\n\t\n\t// fill the Score with notes\n\t\n\tstarttime = 0.0;\n\t\n\twhile({\n\t\tsynth = Synth.basicNew(\\NRT_playback);\n\t\tscore.add([starttime, \n\t\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\t\tstarttime = starttime + 0.05;\n\t\tstarttime < 10.0;\n\t\t});\n\t\n\t// the last command is NOT needed, since no soundfile is being rendered\n//\tscore.add([11, 0]);\n\t\n\tscore.sort;\n\t\n\t// again, options won't be needed for real time performance\n//\toptions = ServerOptions.new.numOutputBusChannels_(1);\n\t\n\tscore.play;\n\t// schedule the freeing of the buffer after the Score is done playing\n\tSystemClock.sched(11, {sndbuf.free; \"Buffer resources freed\".postln;});\n\t})\n)\n\n\n\n",
    "Ch18_fig_007.scd": "\u00ef\u00bb\u00bfFigure 18.7\n\n\n// environment variables are used for real-time examples of Ctk objects\n\nn = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg gate = 1, freq, amp;\n\t\tvar src, env;\n\t\tsrc = SinOsc.ar(freq, 0, amp);\n\t\tenv = EnvGen.kr(Env([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction:2);\n\t\tOffsetOut.ar(0, src * env);\n\t\t})\n\t);\n\t\n// create a new note based on 'n', start to play it in 0.1 seconds\na = n.new(0.1).freq_(440).amp_(0.1).gate_(1).play;\n// the release method will set 'gate' to 0.0, and free this node\na.release;\n\n// create another note\na = n.new(0.1).freq_(440).amp_(0.1).play;\n// alter the freq argument in real time\na.freq_(550);\n// alter the freq with a CtkControl that describes an Env\n// CtkControl.env(Env)\na.freq_(CtkControl.env(Env([550, 440, 550], [1, 2], \\exp)));\n// apply a random control to the amp parameter, with an envelope applied to the range. All \n// parameters to the CtkControl can themselves be CtkControls\n// CtkControl.lfo(KRUGen, freq, low, high, phase)\na.amp_(CtkControl.lfo(LFNoise2, 0.5, CtkControl.env(Env([0.1, 0.9], [5])), 0.1));\na.amp_(0.1);\n\n// release the note\na.release;\n\n\n",
    "Ch18_fig_008.scd": "\u00ef\u00bb\u00bfFigure 18.8\n// melodic expander\n(\nvar note, keys, durs, now, score, chunk, expander, rangemap;\n\n// \nthisThread.randSeed_(123);\n\n// a simple note player\n\nnote = CtkSynthDef(\\NRT_dut, {arg key, amp, dur;\n\t\tOut.ar(0, SinOsc.ar(key.midicps, 0, XLine.kr(amp, 0.00001, dur)))\n\t\t});\n\n// first, make a melody - these will be used as midikeynums (easier to alter later)\n\nkeys = [ 72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72 ];\n\n// a list of durations\n\ndurs = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5];\n\n// create a var to store 'now' in\n\nnow = 0.0;\n\n// create a CtkScore with the above melody\n\nscore = CtkScore.new;\n\nkeys.do({arg thiskey, inc;\n\tvar thisdur;\n\tthisdur = durs[inc];\n\tscore.add(note.new(now, thisdur).key_(thiskey).amp_(0.2).dur_(thisdur));\n\tnow = now + thisdur;\n\t});\n\n// first, create a function that will return a chunk of the melody the duration of the chunk\n// sets the starttimes of the notes to a base of 0.0\n\nchunk = {arg offset = 0;\n\tvar size, start, end, duration = 0, chunk, copies;\n\t// the size of the current melody - 1 (for array access)\n\tsize = score.notes.size;\n\t// the beginning of the chunk can come from the beginning of the melody to the second to \n\t// last note\n\tstart = 0.rrand(size-1);\n\tend = start.rrand(size);\n\tchunk = score.notes[start..end].collect({arg anote; \n\t\tvar newnote;\n\t\tnewnote = anote.copy(duration + offset);\n\t\tduration = duration + anote.duration;\n\t\tnewnote;\n\t\t});\n\t[chunk, duration];\n\t};\n\n// now, create a function that will add those chunks to the score, and will keep doing this\n// until the score is at least the desired length. Then check the score size, and truncate to \n// desired size.\n\nexpander = {arg len;\n\tvar curchunk, chunkdur, insert, inserttime, insertdur, cursize, newnotes;\tcursize = score.notes.size;\n\twhile({\n\t\tcursize < len\n\t\t}, {\t\t\n\t\tinsert = 0.rrand(cursize - 1);\n\t\tinserttime = score.notes[insert].starttime;\n\t\tinsertdur = score.notes[insert].duration;\n\t\t#curchunk, chunkdur = chunk.value(inserttime + insertdur);\n\t\tscore.notes[(insert+1)..(cursize-1)].do({arg me; \n\t\t\tme.setStarttime(me.starttime + chunkdur)});\n\t\tscore = score.add(curchunk);\n\t\t(score.notes.size > len).if({\n\t\t\tscore.notes.do({arg me, i;\n\t\t\t\t(i > (len - 1)).if({score.notes.remove(me)});\n\t\t\t\t})\n\t\t\t});\n\t\tcursize = score.notes.size;\n\t\t});\n\t};\n\n// rangemap will place the melodic material within a certain range. The user passes \n// in an envelope that will describe the center pitch in an octave range\n\nrangemap = {arg center;\n\tscore.notes.do({arg me;\n\t\tme.key_(me.key.mapIntoRange(12, center[me.starttime]));\n\t\t})\n\t};\n\t\t\n// expand it to 100 notes\nexpander.value(100);\n\n// describe a new range of pitches\nrangemap.value(Env([60, 96], [20]));\n\n// finally, play the CtkScore\n\nscore.play;\n)\n\n",
    "Ch18_fig_009.scd": "\u00ef\u00bb\u00bfFigure 18.9\n\n(\nvar score, grain, now, thisdur;\nvar ampmap, double;\n\ngrain = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg freq, amp, dur, pan = 0;\n\t\tvar src, env;\n\t\tenv = EnvGen.ar(\n\t\t\tEnv([0, 1, 0], [0.5, 0.5], \\sin),\n\t\t\ttimeScale: dur, doneAction: 2, levelScale: amp);\n\t\tsrc = SinOsc.ar(freq, 0, env);\n\t\tOffsetOut.ar(0, Pan2.ar(src, pan));\n\t\t})\n\t);\n\t\nscore = CtkScore.new;\n\nnow = 0;\n\n// create a 3 second granular gesture\n\nwhile({\n\tthisdur = 0.05.rrand(0.1);\n\tscore.add(\n\t\tgrain.new(now, thisdur).freq_(440.rrand(880)).amp_(0.05).dur_(thisdur).pan_(0));\n\tnow = now + 0.01;\n\tnow < 3;\n\t});\n\n// a function to later map the amplitude to a given shape\n// envtimes should be scaled to 1\nampmap = {arg aScore, env;\n\t// scaled the envs times by the CtkScore's duration\n\tenv.times = env.times * aScore.endtime;\n\taScore.notes.do({arg thisNote;\n\t\tvar curtime;\n\t\tcurtime = thisNote.starttime;\n\t\tthisNote.amp_(env[curtime]);\n\t\t});\n\t};\n\n// returns a new copy of the CtkScore with notes\n// double an octave higher\ndouble = {arg aScore, shift = 2;\n\tvar thisScore;\n\tthisScore = aScore.copy;\n\tthisScore.notes.do({arg thisNote;\n\t\tthisNote.freq_(thisNote.freq * shift)\n\t\t});\n\tthisScore;\n\t};\n\t\t\n// a Routine to play the examples\nRoutine.run({\n\tvar scoreDouble;\n\t// play the CtkScore;\n\tscore.play;\n\tscore.endtime.wait;\n\t// remap the amplitudes\n\tampmap.value(score, Env([0, 0.2, 0], [0.1, 0.9], [4, -2]));\n\t1.wait; // pause for a moment\n\t// play it again!\n\tscore.play;\n\tscore.endtime.wait;\n\t// add the CtkScore that octaveDouble returns\n\tscoreDouble = double.value(score, 19.midiratio);\n\tampmap.value(scoreDouble, Env([0, 0.25, 0], [0.6, 0.4], [4, -2]));\n\tscore.add(scoreDouble);\n\t1.wait;\n\tscore.play;\n\tscore.endtime.wait;\n\t// don't like the second version? remove double\n\tscore.ctkscores.remove(scoreDouble);\n\tampmap.value(score, Env([0.15, 0.05], [1]));\n\t1.wait;\n\tscore.play;\n\t}).randSeed_(123)\n)\n\n\n",
    "Ch18_fig_010.scd": "\u00ef\u00bb\u00bfFigure 18.10\ns = Server.local;\ns.boot;\n\n~sinosc = CtkSynthDef.new(\\NRT_sinosc, \n\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t}\n);\n\n(\nvar score;\nvar baseNote = 75;\nvar slopeTime = 0.25;\nvar curve = \\sine;\nvar firstPitch = (baseNote + 0).midicps;\nvar firstStart = 0.0;\nvar firstDur = 5.0;\nvar firstAttackTime = slopeTime * 0.5;\nvar firstDecayTime  = slopeTime - firstAttackTime;\nvar firstVibDepth = 0.21;\nvar firstVibRate = 2.3;\nvar firstPeakAmp = 0.25;\nvar firstDecayAmp = 0.01;\nvar secondPitch = (baseNote - 4).midicps;\nvar secondStart = 2.2;\nvar secondDur = 4.0;\nvar secondAttackTime = slopeTime * 0.5;\nvar secondDecayTime  = slopeTime - secondAttackTime;\nvar secondVibDepth = 0.15;\nvar secondVibRate = 1.7;\nvar secondPeakAmp = 0.25;\nvar secondDecayAmp = 0.01;\nvar thirdPitch = (baseNote + 7).midicps;\nvar thirdStart = 3.1;\nvar thirdDur = 3.75;\nvar thirdAttackTime = slopeTime * 0.5;\nvar thirdDecayTime  = slopeTime - thirdAttackTime;\nvar thirdVibDepth = 0.21;\nvar thirdVibRate = 4;\nvar thirdPeakAmp = 0.2;\nvar thirdDecayAmp = 0.25;\n\nscore = CtkScore.new(\n\t~firstGroup = CtkGroup.new(firstStart, firstDur, server: s),\n\t~sinosc.new(firstStart, firstDur, \\tail, ~firstGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, firstVibRate, \n\t\t\t(firstPitch - ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (1/3)))), \n\t\t\t(firstPitch + ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (2/3)))), \n\t\t\tduration: firstDur, addAction: \\head, target: ~firstGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, firstPeakAmp, firstDecayAmp, 0], [firstAttackTime, \n\t\t\t\tfirstDur - (firstAttackTime + firstDecayTime), firstDecayTime], curve), \n\t\t\taddAction: \\head, target: ~firstGroup, server: s)),\n\t~secondGroup = CtkGroup.new(secondStart, secondDur, server: s),\n\t~sinosc.new(secondStart, secondDur, \\tail, ~secondGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, secondVibRate, \n\t\t\t(secondPitch - ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (1/3)))), \n\t\t\t(secondPitch + ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (2/3)))), \n\t\t\tduration: secondDur, addAction: \\head, target: ~secondGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, secondPeakAmp, secondDecayAmp, 0], [secondAttackTime, \n\t\t\t\tsecondDur - (secondAttackTime + secondDecayTime), secondDecayTime], curve), \n\t\t\taddAction: \\head, target: ~secondGroup, server: s)),\n\t~thirdGroup = CtkGroup.new(thirdStart, thirdDur, server: s),\n\t~sinosc.new(thirdStart, thirdDur, \\tail, ~thirdGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, thirdVibRate, \n\t\t\t(thirdPitch - ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (1/3)))), \n\t\t\t(thirdPitch + ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (2/3)))), \n\t\t\tduration: thirdDur, addAction: \\head, target: ~thirdGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, thirdPeakAmp, thirdDecayAmp, 0], [thirdAttackTime, \n\t\t\t\tthirdDur - (thirdAttackTime + thirdDecayTime), thirdDecayTime], curve), \n\t\t\taddAction: \\head, target: ~thirdGroup, server: s))\n);\n\nscore.play;\n)\n\n",
    "Ch18_fig_011.scd": "\u00ef\u00bb\u00bfFigure 18.11\nVSO_Vib {\n\n\tvar <pitch, <depth, <rate, <control;\n\n\t*new {arg start = 0.0, dur = nil, freq = 1, vibDepth = 0.21, vibRate = 1, \n\t\taddAction = 0, target = 1, server;\n\t\t^super.new.initVSO_Vib(start, dur, freq, vibDepth, vibRate, addAction, \n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_Vib {arg start, dur, freq, vibDepth, vibRate, add = 0, tgt = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tpitch = freq;\n\t\tdepth = vibDepth;\n\t\trate = vibRate;\n\t\tcontrol = CtkControl.lfo(SinOsc, rate, this.getLowerValue,\n\t\t\tthis.getUpperValue, 0, start, dur, add, tgt, server: server);\n\t\n\t}\n\t\n\tgetLowerValue {\n\t\t^(pitch - ((pitch / (pitch.log2)) * (depth * (1/3))));\n\t}\n\n\tgetUpperValue {\n\t\t^(pitch + ((pitch / (pitch.log2)) * (depth * (2/3))));\n\t}\n}\n\n\n",
    "Ch18_fig_012.scd": "\u00ef\u00bb\u00bfFigure 18.12\nVSO_ADR {\n\n\tvar <control, <attackDur, <releaseDur, <totalDur;\n\n\t*new {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, attackDur = 0.125, \n\t\treleaseDur = 0.125, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO_ADR(start, dur, peak, decay, attackDur, releaseDur, addAction,\n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_ADR {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, aDur = 0.125, \n\t\trDur = 0.125, addAction = 0, target = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tattackDur = aDur;\n\t\treleaseDur = rDur;\n\t\ttotalDur = dur;\n\t\tcontrol = CtkControl.env(Env.new([0, peak, decay, 0], \n\t\t\t[attackDur, this.decayDur, releaseDur], \\sine), \n\t\t\tstart, addAction, target, server: server, doneAction: 0);\n\t}\n\t\n\tdecayDur {\n\t\t^(totalDur - (attackDur + releaseDur));\n\t}\n\n}\n\n\n",
    "Ch18_fig_013.scd": "\u00ef\u00bb\u00bfFigure 18.13\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n\n\n\n\n\n",
    "Ch18_fig_014.scd": "\u00ef\u00bb\u00bfFigure 18.14\nVSO {\n\n\tclassvar <sinoscdef;\n\tvar <score, group, oscil, freqCntl, <ampCntl;\n\t\n\t*new {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, ampDecayLevel = 0.01, \n\t\tvibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO(start, dur, freq, ampPeakLevel, ampDecayLevel, \n\t\t\tvibDepth, vibRate, addAction, target, server);\n\t}\n\n\t*initClass {\n\t\tsinoscdef.isNil.if({\n\t\t\tsinoscdef = CtkSynthDef.new(\\NRT_sinosc, \n\t\t\t\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\t\t\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t\t\t\t})\n\t\t\t});\n\t}\n\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n\n}\n\n\n",
    "Ch18_fig_015.scd": "\u00ef\u00bb\u00bfFigure 18.15\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nscore = CtkScore.new(\n\t(a = VSO.new(0.0, 5.0, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(2.2, 4.0, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(3.1, 3.75, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n)\n\n\n\n\n",
    "Ch18_fig_016.scd": "\u00ef\u00bb\u00bf\nFigure 18.16\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nd = [2.4, 1.7];\na = NRT_TimeFrame.new(0.0, 11);\nb = NRT_TimeFrame.new(a.starttime + d.at(0), a.endtime - (a.starttime + d.at(0)));\nc = NRT_TimeFrame.new(b.starttime + d.at(1), b.endtime - (b.starttime + d.at(1)));\n\nscore = CtkScore.new(\n\t(a = VSO.new(a.starttime, a.duration, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(b.starttime, b.duration, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(c.starttime, c.duration, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n//N.B. You may notice three \"Node not found\" warnings.\n// This is expected behavior for this version of Ctk\n)\n\n\n",
    "Ch18_fig_017.scd": "\u00ef\u00bb\u00bfFigure 18.17\nNRT_TimeFrame {\n\n\tvar >starttime, >duration;\n\t\n\t*new {arg starttime, duration;\n\t\t^super.newCopyArgs(starttime, duration);\n\t}\n\n\tstarttime {\n\t\t^ starttime.value;\n\t}\n\n\tduration {\n\t\t^ duration.value;\n\t}\n\n\tendtime {\n\t\t^(this.starttime != nil).if({\n\t\t\t\t(this.duration != nil).if({\n\t\t\t\t\t//call the getter methods rather than accessing\n\t\t\t\t\t// the variables directly\n\t\t\t\t\tthis.starttime + this.duration;\n\t\t\t\t}, {nil})\n\t\t}, {nil});\n\n\t}\n\n}\n\n",
    "Ch20_fig_001.scd": "\u00ef\u00bb\u00bfFigure 20.1\n// create the mixer: one channel in, two channels out\nm = MixerChannel(\\fig1, s, 1, 2);\n\n// bring up a mixing board -- you can play with the level and panning controls\n// closing the window, or freeing all of its channels, removes the MixingBoard\nb = MixingBoard(\\Fig1, nil, m);\n\n// a SynthDef should include an outbus argument\n// so that the MixerChannel can tell it where to write its output\n(\nSynthDef(\\fig1, { |outbus, lowfreq = 220, hifreq = 1200, decay = 0.05|\n\tvar\ttrig = Impulse.kr(8);\n\t\t// Do not hard-code the outbus here!\n\t\t// Out.ar(0, ...) is not OK. Out.ar(outbus, ...) is good.\n\tOut.ar(outbus, SinOsc.ar(TExpRand.kr(lowfreq, hifreq, trig)) * Decay2.kr(trig, 0.01, decay));\n}).add;\n)\n\na = m.play(\\fig1, [lowfreq: 100, hifreq: 2000, decay: 0.1]);\n\n// automate panning - this is done with a control-rate synth\nm.automate(\\pan, { SinOsc.kr(LFNoise1.kr(0.5).exprange(0.4, 5.0)) });\n\n// the GUI can show the automation\nm.watch(\\pan);\n\n// add reverb using post-fader send\n// auto-play the reverb synth in the completion function\n(\nr = MixerChannel(\\rvb, s, 2, 2, level:1, completionFunc: { |chan|\n\t\"creating reverb synth\".postln;\n\tchan.playfx({ |outbus|\n\t\tvar\tsig = In.ar(outbus, 2);  // read from channel's bus\n\t\tFreeVerb2.ar(sig[0], sig[1], 1, 0.6, 0.5)\n\t});\n});\n\nb.add(r);  // add to MixingBoard\n)\n\n// feed the signal into the reverb\nm.newPostSend(r, 0.6);\n\n// prints out current state of all mixers in the board\n// the board is accessible also through the MixingBoard.boards array\nb.postSettings;\n\n// fade to black\nm.levelTo(0, 15);\n\n// and release\n// note that on m.free, the synth 'a' is removed also\n// freeing the last MixerChannel in the MixingBoard closes the window\nm.free;\nr.free;\n\n\n",
    "Ch20_fig_003.scd": "\u00ef\u00bb\u00bfFigure 20.3\n// Voicer(voices, things, args, bus, target, addAction)\n// target may be a Group, Server, or MixerChannel\nv = Voicer(10, \\default);\n\nv.trigger(440, 1);  // v.trigger(freq, gate, args, latency)\nv.release(440);\n\n// v.gate(freq, dur, gate, args, lat) -- lat = latency\nv.gate(440, 2.0, 1, [pan: -0.5]);\n\nr = fork {\n\tloop {\n\t\t\t// play over a C major scale\n\t\t[60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|\n\t\t\tv.gate(midi.midicps, 0.1, 1, [amp: rrand(0.05, 0.15)],\n\t\t\t\tlat: 0.1);\n\t\t\t0.125.wait;\n\t\t});\n\t}\n};\n\nr.stop;\n\nv.free;\n\n",
    "Ch20_fig_004.scd": "\u00ef\u00bb\u00bfFigure 20.4\n// let's put a pan global control on the voicer\n\nv = Voicer(10, \\default);\n\n// v.mapGlobal(name, bus, value, spec)\n// \\bipolar is a ControlSpec for the range -1..+1\nv.mapGlobal(\\pan, nil, 0, \\bipolar);\n\nv.gui;\n\n// Pbind works with voicer, using 'voicerNote' event type\np = Pbind(\n\t\\type, \\voicerNote,\n\t\\voicer, v,\n\t\\degree, Pn(Pseries(0, 1, 8), inf),\n\t\\amp, Pwhite(0.05, 0.15, inf),\n\t\\dur, 0.125,\n\t\\legato, 0.8\n).play;\n\np.stop;\n\nv.free;\n\n\n",
    "Ch20_fig_005.scd": "\u00ef\u00bb\u00bfFigure 20.5\nv = Voicer(10, \\default);\n\n// 0 = device 0, channel 0\n// for a different device, use [device index, channel]\nk = VoicerMIDISocket(0, v);\n\n// modwheel to control pan\nk.addControl(1, \\pan, 0, \\bipolar);\nv.gui;\n\n// a homegrown variety of just intonation\n// release all notes before executing this!\nk.midiToFreq = TuningRatios(12, tunings: [1, 135/128, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 14/9, 27/16, 16/9, 15/8]);\n\n// per-note argument generation using a Pbind\n// here used to map velocity data onto the amp input\nk.noteOnArgsPat = Pbind(\\amp, Pkey(\\velocity).linlin(0, 127, 0.01, 0.2));\n\n// if you have a footswitch (controller number 64), this handles it properly\nl = VoicerSusPedal(0, 64, v);\n\n// by default, freeing the voicer automatically frees the socket and all attached MIDI controllers\nv.free;\n\n\n",
    "Ch20_fig_006.scd": "\u00ef\u00bb\u00bfFigure 20.6\n// \"Hello World\" greeter classes\n\n(\n~greeter = Proto({\n\t~sayhi = { |name|\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n});\n\n// make a subclass with .clone\n~frenchGreeter = ~greeter.clone({\n\t~greeting = \"Bonjour\";\n});\n\n~timeAwareFrenchGreeter = ~frenchGreeter.clone({\n\t~greeting = {\n\t\tvar\thour = Date.getDate.hour;\n\t\tif(hour < 18) { ~dayGreeting } { ~eveningGreeting };\n\t};\n\t~dayGreeting = \"Bonjour\";\n\t~eveningGreeting = \"Bon soir\";\n});\n)\n\n// Use the objects:\n~greeter.sayhi;\n~greeter.sayhi(\"Bob\");\n~frenchGreeter.sayhi(\"Isabelle\");\n~timeAwareFrenchGreeter.sayhi(\"Eric\");\n\n\n",
    "Ch20_fig_007.scd": "\u00ef\u00bb\u00bfFigure 20.7\n(\n\t// define PR prototype - Proto(...) => PR(\\name)\nProto({\n\t~sayhi = { |name|\n\t\t\t// ~greeting.value is an internal pseudomethod call\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n}) => PR(\\greeter);\n)\n\n// make working instance as BP\nPR(\\greeter) => BP(\\greeter);\nBP(\\greeter).sayhi(\"Jacqueline\");\nBP(\\greeter).name = \"Zsa Zsa\";\nBP(\\greeter).sayhi;\n\t// changing name in BP does not affect PR\nPR(\\greeter).name;\n\n// override default at chuck time\n// now this greeter belongs just to Bob\nPR(\\greeter).chuck(BP(\\greetBob), parms: (name: \"Bob\"));\nBP(\\greetBob).name;\t// ~name variable is overridden\nBP(\\greetBob).sayhi;\n\n// remove both instances from the repository\nBP([\\greeter, \\greetBob]).free;\n\n\n",
    "Ch20_fig_009.scd": "\u00ef\u00bb\u00bfFigure 20.9\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t\t// BEHAVIORAL components\n\t\t// eventKey refers to ProtoEvent(\\singleSynthPlayer)\n\t~event = (eventKey: \\singleSynthPlayer);\n\t\t// here, manufacture the pattern to play\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\bufnum, ~buf.bufnum,\n\t\t\t\\delta, BPStream(\\delta),\t// reference to ~delta stream\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * ~buf.sampleRate,\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\t\t// default Pbind streams\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ ~buf.duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\n\t\t// ARCHITECTURAL components\n\t~path = \"sounds/a11wlk01.wav\";\t// default soundfile\n\t~startFrame = 0;\n\t~numFrames = -1;\n\t\t// constructor: auto-load soundfile and create mixer\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t\"loading %\\n\".postf(~path);\n\t\t~buf = Buffer.read(s, ~path, ~startFrame, ~numFrames,\n\t\t\taction: { \"done loading buffer\".postln });\n\t};\n\t\t// destructor, called on .free\n\t~freeCleanup = {\n\t\t[~chan, ~buf].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\n// That was the definition. In performance you only need this to play it.\n\nPR(\\bufSlicer) => BP(\\columbia);\nBP(\\columbia).play;\n\n// change process\u00e2\u0080\u0099s stream references while it is playing\n\nBP(\\columbia).tfactor = 0.25;\n\nBP(\\columbia).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\n\nBP(\\columbia).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\n\nBP(\\columbia).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\n\n\n// also valid to chuck patterns into a BP\n// \".pan\" is an adverb indicating which variable to replace\nsin(Ptime(inf)) =>.pan BP(\\columbia);\n\nBP(\\columbia).stop;\nBP(\\columbia).free;\t// MixerChannel and Buffer go away also\n\n\n",
    "Ch20_fig_010.scd": "\u00ef\u00bb\u00bfFigure 20.10\n// In the definition file:\n(\n(make: { |name|\n\tPR(\\bufSlicer) => BP(name);\n}, type: \\bp) => Fact(\\basic);\n\n(make: { |name|\n\tPR(\\bufSlicer).chuck(BP(name), parms: (\n\t\tpath: \"sounds/a11wlk01-44_1.aiff\",\n\t\ttfactor: sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55,\n\t\tdelta: Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf)),\n\t\tstartSec: Pclutch(Pwhite(0.0, Pfunc({ ~buf.duration }) - Pkey(\\time)), Pdiff(Pkey(\\delta)).abs > 0),\n\t\tpan: sin(Ptime(inf)),\n\t\tquant: 1\t// quantize to next beat\n\t))\n}, type: \\bp) => Fact(\\fancy);\n)\n\n// In the performance script:\nFact(\\basic) => BP(\\basic);\n\nBP(\\basic).play;\n\nFact(\\fancy) => BP(\\fancy);\n\nBP(\\fancy).play;\n\nBP([\\basic, \\fancy]).stop;\n\nBP([\\basic, \\fancy]).free;\n\n\n",
    "Ch21_fig_002.scd": "\u00ef\u00bb\u00bf\n// Figure 2. A Synth Definition with the first 16 harmonics\n(\nSynthDef(\\simpleSynth, {|freq, amp|\n\tvar signal, harmonics;\n\tharmonics = 16;\n\tsignal = Mix.fill(harmonics, {|i| \n\t\t\t\tSinOsc.ar(freq*(i+1), 1.0.rand, amp * harmonics.reciprocal/(i+1)) \n\t\t\t});\n\tOut.ar(0, signal ! 2);\n}, [0.15, 0.15]).add// lag times so the slider \"sounds\" better\n)\n\n// A line of code testing the synth definition that we created\nSynth(\\simpleSynth, [\\freq, 440, \\amp, 1])\n\n",
    "Ch21_fig_003.scd": "\u00ef\u00bb\u00bf\n// Figure 3. A GUI to control the frequency and amplitude of our synth\n(\nvar synth, win;\n// we initialize the synth\nsynth = Synth(\\simpleSynth, [\\freq, 100, \\amp, 0]);\n// specify the GUI window\nwin = Window(\"simpleSynth\", Rect(100,100, 230, 90), false);\n// and place the frequency and amplitude sliders in the window\nStaticText(win, Rect(10,10, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"freq\");\nSlider(win, Rect(40,10, 160, 24))\n\t.action_({|sl| synth.set(\\freq, [100, 2000, \\exp].asSpec.map(sl.value)) });\nStaticText(win, Rect(10,46, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"amp\");\nSlider(win, Rect(40,46, 160, 24))\n\t.action_({|sl| synth.set(\\amp, [0, 1.0, \\amp].asSpec.map(sl.value)) });\nwin.onClose_({ synth.free }).front; // we add a \"onClose\" message to the window and \"front\" it.\n)\n\n",
    "Ch21_fig_005.scd": "\u00ef\u00bb\u00bf\n// Figure 5. A GUI with vertical sliders controlling the frequency and amplitude\n(\nvar synth, win;\nsynth = Synth(\\simpleSynth, [\\freq, 100, \\amp, 0]);\nwin = Window(\"\", Rect(100, 100, 94, 200), false);\nStaticText(win, Rect(20, 170, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"freq\");\nSlider(win, Rect(10, 10, 30, 160))\n\t.action_({|sl| synth.set(\\freq, [100, 2000, \\exp].asSpec.map(sl.value)) });\nStaticText(win, Rect(60, 170, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"amp\");\nSlider(win, Rect(50, 10, 30, 160))\n\t.action_({|sl| synth.set(\\amp, [0, 1.0, \\amp].asSpec.map(sl.value)) });\nwin.onClose_({ synth.free }).front; // we add a \"onClose\" message to the window and \"front\" it.\n)\n\n",
    "Ch21_fig_007.scd": "\u00ef\u00bb\u00bf\n\n// Figure 7. Irritia. A stochastic patch playing with the envelope view. The mouse can be used to interact with the patch\n(\nvar nNodes, envView, startStop, myWait, timeSlider, mouseTracker;\nvar xLoc, yLoc, mousedown = false;\nvar randLoc = 0.12.rand;\n\nSynthDef(\\irritia, { arg out=0, gate=1, freq=440, pan=0.0; \n\tOut.ar(out, Pan2.ar(LFSaw.ar(freq,0.4,0.05) * EnvGen.kr(Env.sine, gate, doneAction:2), pan))\n}).add;\n\nnNodes = 10;\nmyWait = 0.033;\n\nw = Window(\"irritia\", Rect(200 , 450, 400, 400)).front;\n\nenvView = EnvelopeView(w, Rect(20, 20, 355, 300))\n\t\t\t.thumbHeight_(6.0)\n\t\t\t.thumbWidth_(6.0)\n\t\t\t.fillColor_(Color.grey)\n\t\t\t.background_(Color.white)\n\t\t\t.drawLines_(true)\n\t\t\t.selectionColor_(Color.red)\n\t\t\t.drawRects_(true)\n\t\t\t.resize_(5) // can be resized and stretched\n\t\t\t.value_([{1.0.rand}!nNodes, {1.0.rand}!nNodes]);\n\t\t\t\n// connect all the nodes in the envelope view to each other\nnNodes.do({arg i; envView.connect(i, {|j|j}!nNodes); });\n\n// create a little interaction where mouseactions affect the activity\nUserView(w, Rect(20, 20, 355, 300))\n\t.mouseDownAction_({|view, x, y| mousedown = true; xLoc = x/355; yLoc = (-1+(y/300)).abs; })\n\t.mouseMoveAction_({|view, x, y| xLoc = x/355; yLoc = (-1+(y/300)).abs; })\n\t.mouseUpAction_({mousedown = false});\n\nr = Routine({\n\tinf.do({ |i|\n\t\tenvView.select(envView.size.rand);\n\t\tif(mousedown.not, {\n\t\t\t0.05.coin.if({\n\t\t\t\t0.5.coin.if({\n\t\t\t\t\tmyWait = rrand(0.028, 0.042);\n\t\t\t\t\txLoc = 1.0.rand; \n\t\t\t\t\tyLoc = 1.0.rand;\n\t\t\t\t}); \n\t\t\t\trandLoc = 0.12.rand2; \n\t\t\t});\n\t\t\txLoc = envView.x+rand2(randLoc); \n\t\t\tyLoc = envView.y+rand2(randLoc);\n\t\t}, {\n\t\t\txLoc = (xLoc + envView.x+rand2(0.1.rand))/2;\n\t\t\tyLoc = (yLoc + envView.y+rand2(0.1.rand))/2;\n\t\t});\n\t\tenvView.x_(xLoc);\n\t\tenvView.y_(yLoc);\n\t\tSynth(\\irritia, [\\freq, (yLoc*200)+50, \\pan, (xLoc*2)-1]);\n\t\tmyWait.wait;\n\t});\n}).play(AppClock);\n\nw.onClose_({ r.stop });\n\n)\n\n",
    "Ch21_fig_012.scd": "\u00ef\u00bb\u00bf\n// Figure 12. A sketch of snow triggering a bell sound on landing\n(\nSynthDef(\\snowBell, { | freq=440, amp=0.4, pan=0 |\n\tvar x, env;\n\tenv = EnvGen.kr(Env.perc(0.001, Rand(550,650)/freq, amp), doneAction:2);\n\tx = Mix.fill(6, {SinOsc.ar(freq*Rand(-10,10), 0, Rand(0.1,0.2))});\n\tx = Pan2.ar(x, pan, env);\n\tOut.ar(0, x);\n}).add;\n)\n\n(\nvar win, msl, trigAction, snowloc, speeds, speed, layers=4, snowcount = 62;\n\n// fill an array with arrays (number of layers) of locations\nsnowloc = {{rrand(0.38,1.5)} ! snowcount} ! layers;\n// fill an array with arrays (number of layers) of step size (speed)\nspeeds = {{rrand(0.01,0.018)} ! snowcount} ! layers;\n\nspeed = 0.1;\n\nwin = Window(\"snow\", Rect(11, 311, 520, 240), border: false).front;\nwin.view.background = Color(0.14,0.17,0.24);\n\nmsl = Array.fill(layers, {|i|\n\t\tMultiSliderView(win, Rect(-1, -1, 522, 242))\n\t\t\t.strokeColor_( Color.new255(rrand(22,35),rrand(22,35),rrand(22,35)) )\n\t\t\t.fillColor_( Color.new255(rrand(222,255),rrand(222,255),rrand(222,255)) )\n\t\t\t.valueThumbSize_(rrand(2.8,3.8))\n\t\t\t.indexThumbSize_(rrand(2.8,3.8))\n\t\t\t.gap_(5)\n\t});\n\n// when the snow falls this happens. (pitch is mapped to index and amplitude to speed)\ntrigAction = {arg drop, amp; Synth(\\snowBell, [\\freq, 400+(drop*20), \\amp, amp, \\pan, rrand(-0.8, 0.8)])};\n\nt = Task({\n\tloop({\n\t\tsnowloc = snowloc.collect({|array, i| \n\t\t\tarray = array.collect({|val, j| \n\t\t\t\tval = val-speeds[i][j]; \n\t\t\t\tif(val< 0.0, {val = 1.0; trigAction.(j, speeds[i][j]*10 )});\n\t\t\t\tval\n\t\t\t});\n\t\t\tarray\n\t\t});\n\t\t/* \n\t\tTask uses the TempoClock by default so we need to \"defer\" the GUI updating \n\t\t(Function:defer uses AppClock) This means that the Task is essentially using \n\t\tthe SystemClock and therefore the timing is better on the sound front. \n\t\tThe AppClock (used for GUI updates) has worse timing.\n\t\t*/\n\t\t{ layers.do({|i| msl[i].value_(snowloc[i]) }) }.defer;\n\t\tspeed.wait;\n\t});\n}).start;\n\n// on stopping the program (Command/Ctrl + dot) the task will stop and the window close\nCmdPeriod.add({ t.stop; win.close; });\n)\n\n",
    "Ch23_fig_002.scd": "\u00ef\u00bb\u00bfFigure 23.2\n (\n{\tvar f = { | a, b | [a.min(1 - b), b.min(1 - a)] };\n\tvar freq = f.value(MouseX.kr, MouseY.kr) * 400 + 500;\n\tSinOsc.ar(freq) * 0.1\n}.play;\n)\n\n\n(\na = { |freq=100, width=0.5|\n\tvar df, dw;\n\tdf = freq - LastValue.kr(freq);\n\tdw = width - LastValue.kr(width);\n\tfreq = freq + (dw * 100);\n\twidth = width + (df / 100);\n\tPulse.ar(freq, width.clip(0.01, 0.99).poll) * 0.1\n}.play;\n)\n\na.set(\\freq, exprand(200.0, 600.0));\na.set(\\width, 1.0.rand);\n\n",
    "Ch23_fig_004.scd": "\u00ef\u00bb\u00bfFigure 23.4\n\n// modulating the frequency input to a Pokey UGen results in great variance\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate + mod, audc1: 2r01000000 + amp);\n}.play\n);\n\n// modulating the pure tone bit\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate, audc1: 2r00100000 + (mod * 2r00100000) + amp);\n}.play\n);\n\n\n",
    "Ch23_fig_005.scd": "\u00ef\u00bb\u00bfFigure 23.5 \n(\nSynthDef(\\FreqMod, { |car=440, carFine=1, mod=100, modFine=1, index=4, amp=0.3, pan=0| \n\tOut.ar(0, Pan2.ar(PMOsc.ar(car * carFine, mod * modFine, index), pan, amp)); \n}).add; \t\t\n\nc = Controller.new(s, 256);\nc.makeInterface(2, 3, 0, \"Freq Mod controller\");\n\nc[0].setup(\"carFreq\", [50, 4800, \\exp].asSpec, 440);\nc[1].setup(\"carFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\nc[2].setup(\"modFreq\", [10, 4800, \\exp].asSpec, 10);\nc[3].setup(\"modFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\nc[4].setup(\"mIndex\", [0, 24, \\lin].asSpec, 1);\nc[5].setup(\"amp\", [0, 1, \\lin].asSpec, 0.2);\n);\n\na = Synth(\\FreqMod) // start the synth\n6.do({|i| a.map(i, c[i].index)}); // map the synth control to the controller.\na.free // when finished\n\n\n",
    "Ch23_fig_007.scd": "\u00ef\u00bb\u00bfFigure 23.7 \n(\nSynthDef(\\ping, {\n\targ out = 0, mfreq = 69, pan = 0, gain = 0.2, dur = 0.25;\n\tOut.ar(out, Pan2.ar(\n\tSinOsc.ar(mfreq.midicps, 0, \n\tEnvGen.kr(envelope: (Env.perc(0.01, dur)), doneAction: 2)),\n\tpan, gain));\n}).add;\n\n// function to play a synth\nm = {|f, d=0.3, g=0.2, p=0| Synth(\\ping, [\\mfreq, f + 45, \\pan, p, \\gain, g, \\dur, d])};\n\n// function to make a chord\nc = {|a, b, c| [a, b, c].do{|i| m.value(i, 1.2, 0.075, rrand(-1.0, 1.0))}};\n\nt = TempoClock.default.tempo_(116 / 60); // assign clock to t\nb = HierSch.new(t); // start new HierSch, pass in clock\n)\n\n(\n// HierSch schedules\nb.schedAbs(t.beats.ceil + 48, 1, { var offset = [0, 5, 7, 12]; c.value(*[12, 16, 19]+ offset.choose)}, Prand(#[1.5, 3], 30)); // enters last, priority highest\n\nb.schedAbs(t.beats.ceil + 14, 2, {|b, p, d, c| m.value([0, 0, 7, 5, 4].at(c % 5) + [12, 24].choose, 0.4, 0.15, rrand(-1.0, 1.0))}, Pseq(#[2, 2, 2, 1], 15)); // enters middle, priority middle\n\nb.schedAbs(t.beats.ceil, 3, { |b, p, d, c| m.value(VagueList[0, 12, 4, 7, 10, 10, 9, 9, 7].at(c % 9))}, Pseq(#[0.5, 0.5, 0.5, 0.5, 0.25, 0.75, 1, 0.5, 0.5], 17)); // enters first, priority lowest\n)\n\n\n",
    "Ch23_fig_008.scd": "\u00ef\u00bb\u00bf// Figure 23.8\n\np = LazyEnvir.push;\n~a = ~b * ~c;\n~a.value; \t// => nil\n~b = Pseq([1, 2, 3]).asStream;\n~c = 10;\n~a.value; \t// => 10\n~a.value; \t// => 20\n~b = [1, 2, 3];\n~a.value; \t// => [10, 20, 30];\n~a.postcs;\t// => Maybe((Maybe([ 1, 2, 3 ]) * Maybe(10)))\np.pop\n\n\n",
    "Ch23_fig_009.scd": "\u00ef\u00bb\u00bfFigure 23.9\n\n(\nvar x;\nx = { |rates=#[1, 1]| Ringz.ar(Impulse.ar(rates) * 0.1, rates * 80, 1 / rates) }.play;\nfork {\n\tvar str = {:[x, y], \n\t\tx<-(40..2), \n\t\ty<-(x + 1..40),\n\t\tgcd(x, y) == 1,\n\t\tx.isPrime.not and: y.isPrime.not\n\t};\n\t0.5.wait;\n\tstr.do { |primes|\n\t\tx.setn(\\rates, primes.postln);\n\t\t(primes.product / primes.sum / 20).wait;\n\t}\n};\n)\n\n",
    "Ch23_fig_010.scd": "\u00ef\u00bb\u00bf\n// Figure 23.10\n\n(\nvar dict, maxLength = 0;\ndict = (\n\tab: { (note: [4, 0, 7], legato: 0.1, dur: 1) },\n\tba: { (note: [4, 9, 8], legato: 0.3, dur: 0.3) },\n\taaa: { (note: 5, legato:1.5) },\n\tbbb: { (note: 0, legato:2.5, dur: 0.25) }\n);\n\ndict.keys.do { |key| maxLength = max(maxLength, key.asString.size) };\n\nf = { |str|\n\tvar i = 0, n = 0, substr, event;\n\twhile { i < str.size } {\n\t\tsubstr = str[i..i + n];\n\t\tevent = dict[substr.asSymbol].value;\n\t\tif(event.notNil) {\n\t\t\tsubstr.postln;\n\t\t\ti = i + n + 1;\n\t\t\tn = 0;\n\t\t\tevent.postln.play;\n\t\t\tevent.delta.wait;\n\t\t} {\n\t\t\tif(n + 1 < maxLength) { n = n + 1 } { n = n - 1; i = i + 1 }\n\t\t};\n\t};\n};\n)\n\n// play some sequences\nfork { f.value(\"abbbbaab\"); }\nfork { f.value(\"aaabbbabbaaaabbabaaaaba\"); };\n\n",
    "Ch24_fig_002.scd": "\u00ef\u00bb\u00bfFigure 24.2\nunion PyrSlot\n{\n\tdouble f;\t\t\t\t\t// double\n\tstruct {\n\t\tint tag;\n\t\tunion {\n\t\t\tint\t\tc;\t\t// character\n\t\t\tint\t\ti;\t\t// integer\n\t\t\tvoid\t\t*ptr;\t// raw pointer\n\t\t\tPyrObject\t*o;\t\t// object pointer\n\t\t\tPyrSymbol\t*s;\t\t// symbol pointer\n\t\t\t...\t\t\t\t// other object pointers\n\t\t} u;\n\t} s;\n};\n\n",
    "Ch24_fig_004.scd": "\u00ef\u00bb\u00bfFigure 24.4\t\nPyrObjectHdr\n{\n\t// garbage collector links\n\tPyrObjectHdr\t*prev;\n\tPyrObjectHdr\t*next;\n\t// class pointer\n\tPyrClass\t*classptr;\n\t// object size\n\tint\t\tsize;\t\t\t\n\n\t// indexable object format\n\tunsigned char obj_format;\n\t// object size class (power of two)\n\tunsigned char obj_sizeclass;\n\t// object flags\n\tunsigned char obj_flags;\n\t// garbage collector color\n\tunsigned char gc_color;\n\t...\n};\n\n",
    "Ch24_fig_006.scd": "\u00ef\u00bb\u00bfFigure 24.6\nPyrSymbol\n{\n\t// symbol name\n\tchar\t*name;\n\t// hash value\n\tlong\thash;\n\t// special selector index\n\tshort\tspecialIndex;\n\t// symbol flags\n\tuint8\tflags;\n\t// length of symbol name\n\tuint8\tlength;\n\tunion {\n\t\t// index in method table or primitive table\n\t\tlong index;\n\t\t// pointer to class with this name\n\t\tstruct PyrClass *classobj; name.\n\t\t....\n\t} u;\n\t// class dependancy (used during compilation)\n\tClassDependancy *classdep;\t\n};\n\n",
    "Ch24_fig_007.scd": "\u00ef\u00bb\u00bfFigure 24.7\n\nVMGlobals\n{\n\t// global context\n\n\tAllocPool\t*allocPool;\n\t// main thread context\n\tPyrProcess\t*process;\n\t// global symbol table\n\tSymbolTable\t*symbolTable;\n\t// garbage collector for this process\n\tPyrGC\t\t*gc;\n\t// class variable array\n\tPyrObject\t*classvars;\n\n\t// next byte code is a tail call\n\tint\t\ttailCall;\n\n\t// true when in 'main' thread\n\tbool\t\tcanCallOS;\n\n\t// thread context\n\t\n\tPyrThread\t*thread;\n\tPyrMethod\t*method;\n\tPyrBlock\t*block;\n\tPyrFrame\t*frame;\n\tPyrMethod\t*primitiveMethod;\n\n\t// current instruction pointer\n\tunsigned char\t*ip;\n\t// current stack pointer\n\tPyrSlot\t\t*sp;\n\n\t// argument pointer for primitive\n\tPyrSlot\t\t*args;\n\t// current receiver\n\tPyrSlot\t\treceiver;\n\t// interpretation result\n\tPyrSlot\t\tresult;\n\t// number of args to pop for primitive\n\tint\t\tnumpop;\n\t// current index into primitive table\n\tlong\t\tprimitiveIndex;\n\t// random number generator state\n\tRGen\t\t*rgen;\n\t// handler for unwinding C stack\n\tjmp_buf\t\tescapeInterpreter;\n\n\t// scratch context\n\tlong\t\texecMethod;\n};\n",
    "Ch24_fig_008.scd": "\u00ef\u00bb\u00bfFigure 24.8\n\nClassDependancy\n{\n\t// next link in list\n\tClassDependancy\t*next;\n\t// superclass dependency\n\tClassDependancy\t*superClassDep;\n\t// subclass list (linked via 'next')\n\tClassDependancy\t*subclasses;\n\t// class name symbol\n\tPyrSymbol\t\t*className;\n\t// superclass name symbol\n\tPyrSymbol\t\t*superClassName;\n\t// file name symbol\n\tPyrSymbol\t\t*fileSym;\n\t// start character position of definition\n\tint\t\t\tstartPos;\n\t// end character position of definition\n\tint\t\t\tendPos;\n\t// line number of definition\n\tint\t\t\tlineOffset;\n};\n\n",
    "Ch24_fig_009.scd": "\u00ef\u00bb\u00bfFigure 24.9\n\nPyrBlock : PyrObjectHdr\n{\n\t// pointer to PyrMethodRaw\n\tPyrSlot rawData1;\t\t\t\n\t// byte codes, nil if inlined\n\tPyrSlot code;\n\t// method selectors, class names, closures table\n\tPyrSlot selectors;\n\t// literal constants table\n\tPyrSlot constants;\n\t// temporary variable default values\n\tPyrSlot prototypeFrame;\n\t// defining block context\n\t// (nil for methods and toplevel)\n\tPyrSlot contextDef;\n\t// arguments to block\n\tPyrSlot argNames;\n\t// variables in block\n\tPyrSlot varNames;\n\t// source code (for closed functions)\n\tPyrSlot sourceCode;\n};\n",
    "Ch24_fig_010.scd": "\u00ef\u00bb\u00bfFigure 24.10\nPyrMethodRaw\n{\n\t// special method index\n\tunsigned specialIndex;\n\t// method type\n\tunsigned methType;\n\t// prototype frame size\n\tunsigned frameSize;\n\n\t// number of arguments\n\tunsigned numargs;\n\t// 1 if has variable number of arguments\n\tunsigned varargs;\n\t// number of keyword and variable defaults\n\tunsigned numvars;\n\t// number of temporary (local) variables\n\tunsigned numtemps;\n\t// true when frame needs to be heap-allocated\n\tunsigned needsHeapContext;\n\t// numargs + varargs\n\tunsigned posargs;\n};\n\n",
    "Ch24_fig_011.scd": "\u00ef\u00bb\u00bfFigure 24.11\n\nPyrMethod : PyrBlock\n{\n\tPyrSlot ownerclass;\n\tPyrSlot name;\n\tPyrSlot primitiveName;\n\tPyrSlot filenameSym;\n\tPyrSlot charPos;\n};\n\n",
    "Ch24_fig_013.scd": "\u00ef\u00bb\u00bfFigure 24.13\n\nPyrFrame : PyrObjectHdr\n{\n\t// defining method\n\tPyrSlot method;\n\t// calling context\n\tPyrSlot caller;\n\t// closure context\n\tPyrSlot context;\n\t// method context\n\tPyrSlot homeContext;\n\t// instruction pointer\n\tPyrSlot ip;\n\t// temporary variable storage\n\tPyrSlot vars[1];\n};\n\n",
    "Ch24_fig_016.scd": "\u00ef\u00bb\u00bfFigure 24.16\n#include <math.h>\n#include \"GC.h\"\n#include \"PyrKernel.h\"\n#include \"PyrPrimitive.h\"\n\n// Primitive implementation of atan2,\n// calling the function from libm.\nstatic int prAtan2(struct VMGlobals *g, int numArgsPushed)\n{\n\t// Pointer to arguments\n\tPyrSlot *args = g->sp - numArgsPushed + 1;\n\t// Pointer to receiver (self)\n\tPyrSlot* self = args + 0;\n\t// Pointer to argument\n\tPyrSlot* arg  = args + 1;\n\n\tdouble x, y;\n\tint err;\n\t\n\t// Get receiver value\nerr = slotDoubleVal(self, &x);\n// Signal error for invalid input type\n\tif (err != errNone) return err;\n\t\n\t// Get argument value\n\terr = slotDoubleVal(arg, &y);\n// Signal error for invalid input type\n\tif (err != errNone) return err;\n\t\n\t// Compute result\ndouble result = atan2(x, y);\n\n\t// Set top of stack to return value\n\tSetFloat(self, result);\n\t\n\t// Signal success\n\treturn errNone;\n}\n\n// Call this function during initialization,\n// e.g. from initPrimitives() in PyrPrimitive.cpp\nvoid initMyPrimitives()\n{\n\t// Initialize primitive indices\n\tint base = nextPrimitiveIndex(), index = 0;\n\n\t// Define primitive with two arguments (self, operand)\n\tdefinePrimitive(base, index++, \"_MyFloatAtan2\", prAtan2, 2, 0);\n\t// ... define more primitives here ...\n}\n\n\n",
    "Ch25_fig_001.scd": "\u00ef\u00bb\u00bfFigure 25.1\n#include \"SC_PlugIn.h\"\n\t\t\t\nstatic InterfaceTable *ft;\n\n// the struct will hold data which we want to \"pass\" from one function to another\n// e.g. from the constructor to the calc func, \n// or from one call of the calc func to the next\nstruct Flanger : public Unit  {\n\tfloat rate, delaysize, fwdhop, readpos;\n\tint writepos;\n};\n\n// function declarations, exposed to C\nextern \"C\" {  \n\tvoid load(InterfaceTable *inTable);\n\tvoid Flanger_Ctor(Flanger *unit);\n\tvoid Flanger_next(Flanger *unit, int inNumSamples);\n}\n\n\nvoid Flanger_Ctor( Flanger *unit ) {\n\t\n\t// Here we must initialise state variables in the Flanger struct.\n\tunit->delaysize = SAMPLERATE * 0.02f; // Fixed 20ms max delay\n\t// Typically with reference to control-rate/scalar-rate inputs.\n\tfloat rate  = IN0(1);\n\t// Rather than using rate directly, we're going to calculate the size of \n\t// jumps we must make each time to scan through the delayline at \"rate\"\n\tfloat delta = (unit->delaysize * rate) / SAMPLERATE;\n\tunit->fwdhop = delta + 1.0f;\n\tunit->rate  = rate;\n\t\n\t// IMPORTANT: This tells scsynth the name of the calculation function\n\t// for this UGen.\n\tSETCALC(Flanger_next);\n\t\n\t// Should also calc 1 sample's worth of output \u00e2\u0080\u0093 \n\t//ensures each ugen's \"pipes\" are \"primed\"\n\tFlanger_next(unit, 1);\n}\n\nvoid Flanger_next( Flanger *unit, int inNumSamples ) {\n\t\n\tfloat *in = IN(0);\n\tfloat *out = OUT(0);\n\t\n\tfloat depth = IN0(2);\n\t\n\tfloat rate    = unit->rate;\n\tfloat fwdhop  = unit->fwdhop;\n\tfloat readpos = unit->readpos;\n\tint writepos  = unit->writepos;\n\tint delaysize = unit->delaysize;\n\n\tfloat val, delayed;\n\t\n\tfor ( int i=0; i<inNumSamples; ++i) {\n\t\tval = in[i];\n\t\t\n\t\t// Do something to the signal before outputting\n\t\t// (not yet done)\n\t\t\n\t\tout[i] = val;\n\t}\n\t\n\tunit->writepos = writepos;\n\tunit->readpos = readpos;\n}\t\n\n\nvoid load(InterfaceTable *inTable) {\n\t\n\tft = inTable;\n\t\n\tDefineSimpleUnit(Flanger);\n}\n\n\n",
    "Ch25_fig_002.scd": "\u00ef\u00bb\u00bfFigure 25.2\n#include \"SC_PlugIn.h\"\n\nstatic InterfaceTable *ft;\n\n// the struct will hold data which we want to \"pass\" from one function to another\n// e.g. from the constructor to the calc func, \n// or from one call of the calc func to the next\nstruct Flanger : public Unit  {\n\tfloat rate, delaysize, fwdhop, readpos;\n\tint writepos;\n\t\n\t// a pointer to the memory we'll use for our internal delay\n\tfloat *delayline;\n};\n\n// function declarations, exposed to C\nextern \"C\" {  \n\tvoid load(InterfaceTable *inTable);\n\tvoid Flanger_Ctor(Flanger *unit);\n\tvoid Flanger_next(Flanger *unit, int inNumSamples);\n\tvoid Flanger_Dtor(Flanger *unit);\n}\n\n\nvoid Flanger_Ctor( Flanger *unit ) {\n\t\n\t// Here we must initialise state variables in the Flanger struct.\n\tunit->delaysize = SAMPLERATE * 0.02f; // Fixed 20ms max delay\n\t// Typically with reference to control-rate/scalar-rate inputs.\n\tfloat rate  = IN0(1);\n\t// Rather than using rate directly, we're going to calculate the size of \n\t// jumps we must make each time to scan through the delayline at \"rate\"\n\tfloat delta = (unit->delaysize * rate) / SAMPLERATE;\n\tunit->fwdhop = delta + 1.0f;\n\tunit->rate = rate;\n\tunit->writepos = 0;\n\tunit->readpos = 0;\n\t\n\t// Allocate the delay line\n\tunit->delayline = (float*)RTAlloc(unit->mWorld, unit->delaysize * sizeof(float));\n\t// Initialise it to zeroes\n\tmemset(unit->delayline, 0, unit->delaysize * sizeof(float));\n\t\n\t// IMPORTANT: This tells scsynth the name of the calculation function \n\t//for this UGen.\n\tSETCALC(Flanger_next);\n\t\n\t// Should also calc 1 sample's worth of output \u00e2\u0080\u0093 \n\t//ensures each ugen's \"pipes\" are \"primed\"\n\tFlanger_next(unit, 1);\n}\n\nvoid Flanger_next( Flanger *unit, int inNumSamples ) {\n\t\n\tfloat *in = IN(0);\n\tfloat *out = OUT(0);\n\t\n\tfloat depth = IN0(2);\n\t\n\tfloat rate    = unit->rate;\n\tfloat fwdhop  = unit->fwdhop;\n\tfloat readpos = unit->readpos;\n\tfloat *delayline = unit->delayline;\n\tint writepos  = unit->writepos;\n\tint delaysize = unit->delaysize;\n\n\tfloat val, delayed, currate;\n\t\n\tcurrate = IN0(1);\n\t\n\tif(rate != currate){\n\t\t// rate input needs updating\n\t\trate = currate;\n\t\tfwdhop = ((delaysize * rate * 2) / SAMPLERATE) + 1.0f;\n\t}\n\t\n\tfor ( int i=0; i<inNumSamples; ++i) {\n\t\tval = in[i];\n\t\t\n\t\t// Write to the delay line\n\t\tdelayline[writepos++] = val;\n\t\tif(writepos==delaysize)\n\t\t\twritepos = 0;\n\t\t\n\t\t// Read from the delay line\n\t\tdelayed = delayline[(int)readpos];\n\t\treadpos += fwdhop;\n\t\t// Update position, NB we may be moving forwards or backwards \n\t\t//(depending on input)\n\t\twhile((int)readpos >= delaysize)\n\t\t\treadpos -= delaysize;\n\t\twhile((int)readpos < 0)\n\t\t\treadpos += delaysize;\n\t\t\n\t\t// Mix dry and wet together, and output them\n\t\tout[i] = val + (delayed * depth);\n\t}\n\t\n\tunit->rate = rate;\n\tunit->fwdhop = fwdhop;\n\tunit->writepos = writepos;\n\tunit->readpos = readpos;\n}\t\n\nvoid Flanger_Dtor( Flanger *unit ) {\n\tRTFree(unit->mWorld, unit->delayline);\n}\t\n\nvoid load(InterfaceTable *inTable) {\n\t\n\tft = inTable;\n\t\n\tDefineDtorUnit(Flanger);\n}\n"
}