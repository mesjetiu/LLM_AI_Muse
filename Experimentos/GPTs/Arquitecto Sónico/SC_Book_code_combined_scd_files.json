{
    "Figure 1": {
        "code": "Figure 1: Immediate machine listening example using Pitch and Amplitude UGens. The original detected pitch appears in your left ear and an octave up in the right.\n(\nx={\n\tvar in, amp, freq, hasFreq, out;\n\tin = SoundIn.ar(0);;\n\tamp = Amplitude.ar(in);\n\t# freq, hasFreq = Pitch.kr(in);\n\tLFTri.ar(freq*[1,2]) * amp;\n}.play\n)\n\nx.free;\n\n\n\n//",
        "description": "Captura la entrada de audio, calcula su amplitud y tono, y reproduce el tono detectado en el o\u00eddo izquierdo y una octava m\u00e1s alta en el derecho."
    },
    "Figure 2": {
        "code": "Figure 2: Loudness \n\nb = Buffer.alloc(s,1024,1);   //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n(  //analyse loudness and poll result\nx={\n\tvar in, fft, loudness;\n\t\n\tin = SoundIn.ar(0);; \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tloudness = Loudness.kr(fft); \n\t\n\tloudness.poll(20); //poll for testing 20 times per second\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n\n\n\n//",
        "description": "Analiza la intensidad sonora de la entrada de audio en tiempo real, mostrando los resultados frecuentemente."
    },
    "Figure 3": {
        "code": "Figure 3: MFCC \n\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//d=Buffer.read(s,\"sounds/a11wlk01.wav\");\n\n\n(\nx= {\n\tvar in, fft, array;\n\t\n\t//in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tin = SoundIn.ar(0);; \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tarray = MFCC.kr(fft); \n\t\n\tarray.size.postln; \n\t\n\tOut.kr(0,array); \n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\n\nc= Bus.new('control', 0, 13); \n\n//poll coefficients\nc.getn(13,{arg val; {val.plot;}.defer}); \n\n\n//Continuous graphical display of MFCC values; free routine before closing window\n\n(\nvar ms; \n\nw = GUI.window.new(\"Thirteen MFCC coefficients\", Rect(200,400,300,300));\n\nms = GUI.multiSliderView.new(w, Rect(10,10,260,280));\n\nms.value_(Array.fill(13,0.0));\nms.valueThumbSize_(20.0);\nms.indexThumbSize_(20.0);\nms.gap_(0);\n\nw.front;\n\nr = {\n\t\n\tinf.do{\n\t\t\n\t\tc.getn(13,{arg val; {ms.value_(val*0.9)}.defer}); \n\t\t\n\t\t0.04.wait; //25 frames per second\n\t};\n\n}.fork;\n\n)\n\n\n//tidy up\n(\nr.stop;\nb.free;\nc.free;\nx.free;\nw.close;\n)\n\n\n\n\n//",
        "description": "Implementa el an\u00e1lisis de MFCC en una se\u00f1al de audio, \u00fatil para caracter\u00edsticas de reconocimiento de voz y sonido."
    },
    "Figure 4": "Figure 4: Onsets\n\n// Prepare the buffer\nb = Buffer.alloc(s, 512);\n\n(\nx = {\n\tvar sig, chain, onsets, pips, trigger;\n\t\n\tsig = SoundIn.ar(0);; \n\t\n\tchain = FFT(b, sig);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger= SendTrig.kr(onsets);\n\t\n\tpips = SinOsc.ar(880, 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));\n\t\n\tOut.ar(0, ((sig * 0.1) + pips).dup);\n}.play;\n)\n\n(\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\t[time,responder,msg].postln;\n}).add;\n)\n\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer\n\n\n\n\n//",
    "Figure 5": "Figure 5: BeatTrack\n\n\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin); events will be spawned at quarter, eighth and sixteenth note rates\n(\nx= SynthDef(\\help_beattrack2,{\t\n\tvar trackb,trackh,trackq,tempo;\n\tvar source;\n\tvar bsound,hsound,qsound;\n\t\n\tsource = SoundIn.ar(0);;\n\t\n\t#trackb,trackh,trackq,tempo = BeatTrack.kr(FFT(b.bufnum, source));\n\t\n\tbsound = Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);\n\t\n\thsound = Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);\n\t\n\tqsound = Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);\n\t\n\tOut.ar(0, bsound+hsound+qsound);\n}).play;\n)\n\n\nx.free;\nb.free; // Free the buffer\n\n\n\n\n//",
    "Figure 6": "Figure 6: KeyTrack\n\n//straight forward test file with few transients; training set in e minor from MIREX2006 \n//You will need to substitute your own soundfile to load here\nd=Buffer.read(s,\"/Users/nickcollins/Desktop/ML/training_wav/78.wav\")\n\n\nb = Buffer.alloc(s,4096,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,8192,1); //for sampling rates 88200 and 96000\n\n(\nx= {\n\tvar in, fft; \n\tvar key;\n\t\n\tin = PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tkey = KeyTrack.kr(fft, 2.0, 0.5);\n\t\n\tkey.poll; //write out detected key\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;\n\n\n\n//",
    "Figure 7": "Figure 7: Simple melodic transcription\n//see melodytranscription.rtf\n\n\n//",
    "Figure 8": "Figure 8: OnlineMIDI\n\n//do this first: \nMIDIIn.connect; \t// init for one port midi interface\n\n\n//now:\nm = OnlineMIDI();\n\nm.analyse(3,1.0); //3 seconds window, step size of 1.0 seconds\n\nm.data //poll current data\n\nm.status = true; //prints analysis data as it goes\nm.status= false;\n\n//use analysis data to formulate responses\n\n(\nSynthDef(\\beep2,{arg freq=440,amp=0.1, pan=0.0, dur=0.1; \nvar source; \n\nsource= SinOsc.ar(freq*[1,1.007],0,amp*0.5);\n\nOut.ar(0,Pan2.ar(Mix(source)*Line.kr(1,0,dur, doneAction:2),pan))}).add;\n)\n\n//to echo each note you play on a MIDI keyboard with a sound; your SynthDef must have freq and amp arguments, and deal with duration and freeing the Synth itself.  \n(\nm.playinput= true; \nm.inputsynthdef= \\beep2; \n)\n\n//set a function that gets called after each window is analysed, to schedule events over the next second \n(\nm.response = {|analysis|  \n\tvar number;\n\tnumber= analysis.density; \n\t//number= max(0,(10-(analysis.density))); //inverting number of notes playing\n\t\n\tif(analysis.iois.notEmpty, {\n\t\t{\n\t\t\n\t\tnumber.do{\n\t\t\n\t\tSynth(\\beep2, [\\freq, analysis.pitches.choose.midicps, \\amp, 0.2*(rrand(analysis.volumemin, analysis.volumemax))]);\n\t\t\n\t\tanalysis.iois.choose.wait; //could last longer than the next second, but still fun! \n\t\t\n\t\t}; \n\t\t\n\t\t}.fork;\n\t}); \n\t\n};\n)\n\n\nm.response= nil; //stop",
    "Figure 9": "figure 6.23 - some granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp * AmpComp.ir(freq) * 0.5, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp * AmpComp.ir(freq) * 0.5, 4), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).store;\n\n\t\t// a noise band grain with percussive envelope\nSynthDef(\\percNoise, { |out, amp=0.2, freq=440, sustain=0.01, pan, rq=0.1| \n\tvar snd = BPF.ar(GrayNoise.ar, freq, rq, 3);\n\tvar env = EnvGen.ar(Env.perc, timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, \n\t\tPan2.ar(snd * env, pan, amp)\n\t);\n}, \\ir ! 6).store\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\gabWide);\nSynth(\\percSin);\nSynth(\\percSinRev);\n\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\percNoise, [\\amp, 0.2, \\sustain, 0.1]);\n\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t//",
    "Figure 10": "figure 6.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n/*\n\t//",
    "Figure 11": "figure  6.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n*/\n\n\n\n\n\t//",
    "Figure 12": "figure 6.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 6.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t//",
    "Figure 13": "figure 6.28 is an image, the CloudGenMini GUI //\n\n\n\n\n\t//",
    "Figure 14": "figure 6.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 0@0;\t// where to put the gui window\n\t\n\tw = GUI.window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)).postln)).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tGUI.button.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tGUI.staticText.new(w, 60@20).string_(\"xfadeTime\"); \n\tfdBox = GUI.numberBox.new(w, 40@20).action_{ |nbx| tdef.envir.xfadeTime = nbx.value }; \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = GUI.compositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tGUI.button.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tGUI.button.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tGUI.rangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 250@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tGUI.staticText.new(w, 50@20).string_(\"synthdef:\"); \n\tGUI.popUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tGUI.button.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tGUI.button.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);",
    "Figure 15": "figures //\n\n\n\t\t// perception at the micro time scale //\n\t\t\n\t//  pulses, transition from rhythm to pitch \n{ Impulse.ar (XLine.kr(12, 48, 6, doneAction: 2)) * 0.1 ! 2 }.play; // up\n\n{ Impulse.ar (XLine.kr(48, 12, 6, doneAction: 2)) * 0.1 ! 2 }.play; // down\n\n{ Impulse.ar (MouseX.kr(12, 48, 1)) * 0.1 ! 2 }.play; // mouse-controlled\n\n\n\n\n\n\t//",
    "Figure 16": "figure 16.1 short grain durations - pitch to colored click \n(\t// a gabor grain, gaussian-shaped envelope\nSynthDef(\\gabor, { |out, freq = 440, sustain = 1, pan, amp = 0.1, width = 0.25 |\n\tvar env = LFGauss.ar(sustain, width, loop: 0, doneAction: 2);\n\tvar son = FSinOsc.ar(freq, 0.5pi, env);\n\tOffsetOut.ar(out, Pan2.ar(son, pan, amp));\n\n}, \\ir ! 6).memStore;\n\n\t// or an approximation with a sine-shaped envelope\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n\n(\nPbindef(\\grain,\n\t\\instrument, \\gabor, \\freq, 1000, \n\t\\dur, 0.5, \\sustain, 20/1000, \\amp, 0.2\n).play;\n)\nPbindef(\\grain, \\sustain, 10/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 5/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 3/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 2/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 1/Pkey(\\freq));\n\n\t// successively shorter, end\nPbindef(\\grain, \\sustain, Pseq((10..1)) / Pkey(\\freq)).play;\n\n\t// random drift of grain duration\nPbindef(\\grain, \\sustain, Pbrown(1, 10, 3) / Pkey(\\freq), \\dur, 0.1).play\n\n\n\n\n\t// short grains seem softer \n(\nPbindef(\\grain, \n\t\\instrument, \\gabor, \\freq, 1000, \\dur, 1,\n\t[\\sustain, \\amp], Pseq([[0.001, 0.1], [0.1, 0.1]], inf) \n).play;\n)\n\t\t// short grain 2x louder \nPbindef(\\grain, [\\sustain, \\amp], Pseq([[0.001, 0.2], [0.1, 0.1]], inf));\n\n\t\t// short grain 4x louder\nPbindef(\\grain, [\\sustain, \\amp], Pseq([[0.001, 0.4], [0.1, 0.1]], inf));\n\n\n\n\t// a grain with quasi-rectangular envelope, short grain 6x louder.\n(\nSynthDef(\\pip, { |out, freq=440, sustain=0.02, amp=0.2, pan=0| \n\tOffsetOut.ar(out, \n\t\tPan2.ar(SinOsc.ar(freq) \n\t\t* EnvGen.ar(Env.linen(0.0005, sustain - 0.001, 0.0005, amp), doneAction: 2), pan)\n\t); \n}).memStore;\n\n\t// is this equal loudness?\nPbindef(\\grain).clear;\nPbindef(\\grain, \n\t\\instrument, \\pip,\n\t\\freq, 1000, \\dur, 1,\n\t\\sustain, Pseq([0.001, 0.1], inf), \n\t\\amp, Pseq([0.6, 0.1], inf) \t\n).play;\n)\n\n\n\n\n\t//",
    "Figure 17": "figure 16.2 - Perception of short silences.\n(\np = ProxySpace.push;\n\n~source = { SinOsc.ar * 0.1 };\n~silence = { |silDur=0.01| \n\tEnvGen.ar(\n\t\tEnv([0, 1, 1, 0, 0, 1, 1, 0], [0.01, 2, 0.001, silDur, 0.001, 2, 0.01]), \n\t\tdoneAction: 2) ! 2\n};\n~listen = ~source * ~silence;\n~listen.play;\n)\n\n~silence.spawn([\\silDur, 0.001]); // sounds like an added pulse \n~silence.spawn([\\silDur, 0.003]);\n~silence.spawn([\\silDur, 0.01]);\n~silence.spawn([\\silDur, 0.03]);\t  // a pause in the sound\n\n\t// try the same examples with noise:\n~source = { WhiteNoise.ar * 0.1 };\t\n\np.clear.pop; \n\n\n\n\n\t//",
    "Figure 18": "figure 16.3 - order confusion with sounds in fast succession. \n\t// as grains move closer and closer together, their order becomes ambiguous. \n(\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp), timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n(\nPbindef(\\lo, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 250, \\amp, 0.2, \\dur, 0.5, \\lag, 0\n).play;\nPbindef(\\hi, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 875, \\amp, 0.1, \\dur, 0.5, \\lag, 0\n).play;\n)\n\t// try different lag times between them\nPbindef(\\hi, \\lag, 0.1);\nPbindef(\\hi, \\lag, 0.03);\nPbindef(\\hi, \\lag, 0.01);\nPbindef(\\hi, \\lag, 0.003);\n\n\t// hi too early or too late by a fixed time - which one is first?\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.01).postln).play;\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.02).postln);\n\n\t// is it easier to hear when the sounds are panned apart?\nPbindef(\\hi, \\pan, 0.5); Pbindef(\\lo, \\pan, -0.5);\nPbindef(\\hi, \\pan, 0);   Pbindef(\\lo, \\pan, 0);\n\n\n\n\n\n\t//",
    "Figure 19": "figure 16.4: multiple grains fuse into one composite.\n\t// when their order changes, the sound is subtly different.\n(\nPbindef(\\grain4, \n\t\\instrument, \\percSin, \\sustain, 0.03, \\amp, 0.2,\n\t\\freq, Pshuf([1000, 600, 350, 250]), // random every each time\n\t\\dur, 0.005\n).play;\n\t\t\t\t// repeat grain cluster \nTdef(\\grain, { loop { Pbindef(\\grain4).play; 1.wait } }).play;\n)\n\t// fixed order\nPbindef(\\grain4, \\freq, Pseq([1000, 600, 350, 250].scramble));\n\n\t// different order every time\nPbindef(\\grain4, \\freq, Pshuf([1000, 600, 350, 250]));",
    "Figure 20": "figures - anatomy //\n\n\n\t// waveform, envelope, grain plotted\n\ne = Env.sine.asSignal(400).as(Array); \nw = Array.fill(400, { |i| (i * 2pi / 40).sin });\ng = e * w;\t\n\n[e, w, g].flop.flat.plot(\"envelope, wave, grain\", Rect(0,0,408,600), numChannels: 3);\n\n\n\t// a gaussian envelope created with the LFGauss UGen\n{ LFGauss.ar(0.01, 0.26) }.plot;\n\n\t// and a curve created from the gaussian distribution formula\n(-1, -0.995 .. 1).collect { |x| exp(squared(x) / (-2.0 * squared(0.26))) }.plot;\n\n\n\t// a gabor grain and tests\n\n(\nSynthDef(\\gabor0, {|out, freq=440, sustain=0.02, amp=0.2, pan|\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tvar sound = SinOsc.ar(freq) * env;\n\tOffsetOut.ar(out, Pan2.ar(sound, pan))\n}, \\ir.dup(5)).memStore;\n)\n\t\t// test with synth\nSynth(\\gabor0);\t\t// defaults from SynthDef\nSynth(\\gabor0, [\\freq, 1000, \\sustain, 0.005, \\amp, 0.1, \\pan, 0.5]);\n\n\t\t// test with event.play\n(instrument: \\gabor0).play;\t\t// default values from Event.defaultEvent\n(instrument: \\gabor0, sustain: 0.02).play;\n(instrument: \\gabor0, sustain: 0.002, freq: 1500, amp: 0.3, pan: 0.5).play;\n(instrument: \\gabor0, sustain: 0.001, freq: 2500, amp: 0.05, pan: -0.5).play;\n\nSynth.grain(\\gabor0, [\\freq, 2000, \\sustain, 0.003]) // higher efficiency, as no NodeID is kept\n\ns.sendMsg(\"s_new\",  \\gabor0, -1, 0, 0, \\freq, 2000, \\sustain, 0.003); // even more efficient, as no Synth object is created.\n\n\n\n\t//",
    "Figure 21": "figure 16.6 - making different envelope shapes\n\nEnv.sine.plot;\t\t// approx. gaussian \nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\sin).test.plot; // quasi-gaussian\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\lin).test.plot; // 3 stage line segments.\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\welch).test.plot; // welch curve interpolation\nEnv([1, 0.001], [0.1], \\exp).test.plot;\t// expoDec (exponential decay);\nEnv([0.001, 1], [0.1], \\exp).test.plot;\t// revExpoDec (reverse exponential decay);\nEnv.perc(0.01, 0.09).test.plot;\n\n(\t// a sinc function envelope \nq = q ? ();\nq.makeSinc = { |q, num=1, size=400| \n\tdup({ |x| x = x.linlin(0, size-1, -pi, pi) * num; sin(x) / x }, size);\n}; \na = q.makeSinc(6);\na.plot(bounds: Rect(0,0,409,200), minval: -1, maxval: 1);\n)\n\n\n\n\n\n\n(\t// more envelopes plotted \n[ \tEnv.sine, \n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\sin), \n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\lin),\n\tEnv([0, 1, 1, 0], [0.33, 0.34, 0.33], \\welch),\n\tEnv([1, 0.001], [1], \\exp),\n\tEnv([0.001, 1], [1], \\exp), \n\tEnv.perc(0.05, 0.95)\n]\t.collect(_.discretize(400))\n\t.add(q.makeSinc(6)).clump(4).collect { |gr4, i| \n\t\tgr4.flop.flat.plot(\n\t\t\t[\"gauss, quasi-gauss, line, welch\", \n\t\t\t\"expodec, rexpodec, perc, sinc\" ][i], \n\t\t\tRect(420 * i + 100, 300, 408, 400), numChannels: 4)\n\t};\n)\n\n\n\n\t//",
    "Figure 22": "figure 16.9 - SynthDefs with different envelopes\n\n(\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env.sine(sustain, amp2), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp2, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// an exponential decay envelope\nSynthDef(\\expodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = AmpComp.ir(freq.max(50)) * 0.5 * amp;\n\tvar env = XLine.ar(amp2, amp2 * 0.001, sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed exponential decay envelope\nSynthDef(\\rexpodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = XLine.ar(amp2 * 0.001, amp2, sustain, doneAction: 2) \n\t\t* (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n)\n\n\n\n\n\n\t//",
    "Figure 23": "figure 16.10 - changing grain duration, frequency, envelope\n(\nPbindef(\\grain0,\n\t\\instrument, \\gabor1, \\freq, 500, \n\t\\sustain, 0.01, \\dur, 0.2\t\n).play;\n)\n\t// change grain durations\nPbindef(\\grain0, \\sustain, 0.1);\nPbindef(\\grain0, \\sustain, 0.03);\nPbindef(\\grain0, \\sustain, 0.01);\nPbindef(\\grain0, \\sustain, 0.003);\nPbindef(\\grain0, \\sustain, 0.001);\nPbindef(\\grain0, \\sustain, Pn(Pgeom(0.1, 0.9, 60)));\nPbindef(\\grain0, \\sustain, Pfunc({ exprand(0.0003, 0.03) }));\nPbindef(\\grain0, \\sustain, 0.03);\n\n\t// change grain waveform (sine) frequency\nPbindef(\\grain0, \\freq, 300);\nPbindef(\\grain0, \\freq, 1000);\nPbindef(\\grain0, \\freq, 3000);\nPbindef(\\grain0, \\freq, Pn(Pgeom(300, 1.125, 32)));\nPbindef(\\grain0, \\freq, Pfunc({ exprand(300, 3000) }));\nPbindef(\\grain0, \\freq, 1000);\n\n\t// change synthdef for different envelopes\nPbindef(\\grain0, \\instrument, \\gabor1);\nPbindef(\\grain0, \\instrument, \\gabWide);\nPbindef(\\grain0, \\instrument, \\percSin);\nPbindef(\\grain0, \\instrument, \\percSinRev);\nPbindef(\\grain0, \\instrument, \\expodec);\nPbindef(\\grain0, \\instrument, \\rexpodec);\nPbindef(\\grain0, \\instrument, Prand([\\gabWide, \\percSin, \\percSinRev], inf));\n\n\n\n\n\n\t// bonus track - adjusting phase for attack color\n\t\n(\t// an expodec envelope sine grain with adjustable phase\nSynthDef(\\expodecPH, { |out, amp=0.1, freq=440, click=0, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq, click * 0.5pi);\n\tvar env = XLine.ar(amp, amp * 0.001, sustain, doneAction: 2) * (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 6).memStore;\n)\n(\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodecPH, \n\t\\sustain, 0.1, \n\t\\freq, [100, 300],\n\t\\click, Pseq((0..20)/20, inf) // add more and more click \n).play;\n)\n\n\n\n\n\n\n\t//",
    "Figure 24": "figure 16.11 - different control strategies applied to density\n\t\n(\t// synchronous - regular time intervals\nPbindef(\\grain0).clear;\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, 0.1, \\sustain, 0.06\n);\n)\n\t// different fixed values\nPbindef(\\grain0, \\dur, 0.06) \t// rhythm\nPbindef(\\grain0, \\dur, 0.035)\t\nPbindef(\\grain0, \\dur, 0.02)\t// fundamental frequency 50 Hz\n\n\t// time-changing values: accelerando/ritardando\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02], [4], \\exp), inf));\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02, 0.06, 0.01].scramble, [3, 2, 1], \\exp), inf));\n\n\t// repeating values: rhythms or tones\nPbindef(\\grain0, \\dur, Pstutter(Pwhite(2, 15), Pfunc({ exprand(0.01, 0.3) })));\n\n\t// introducing irregularity - quasi-synchronous\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.8, 1.2))\nPbindef(\\grain0, \\dur, 0.03 * Pbrown(0.6, 1.4, 0.1)) // slower drift\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.2, 1.8))\n\n\t// average density constant, vary degree of irregularity  \nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.1.linrand * 3) + 0.9 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.3.linrand * 3) + 0.3 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (1.0.linrand * 3) + 0.0 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ 2.45.linrand.squared })); // very irregular\n\n\n(\t// coupling - duration depends on freq parameter\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq  })\n);\n)\n\n\t// different freq movement, different timing\nPbindef(\\grain0, \\freq, Pbrown(48.0, 96.0, 12.0).midicps);\n\n(\t// duration depends on freq, with some variation - tendency mask\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq * rrand(0.5, 1.5)  })\n);\n)\n\n\n\t//",
    "Figure 25": "figure 16.12 - control strategies applied to different parameters\n(\nPbindef(\\grain0).clear;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, 200,\n\t\\sustain, 0.05, \\dur, 0.07\n).play;\n)\n\t// time-varying freq with envelope pattern\nPbindef(\\grain0, \\freq, Pn(Penv([200, 1200], [10], \\exp), inf));\n\t// random freq\nPbindef(\\grain0, \\freq, 400 * Pwhite(-24.0, 24).midiratio);\n\t// timechanging with random variation\nPbindef(\\grain0, \\freq, Pn(Penv([400, 2400], [10], \\exp), inf) * Pwhite(-24.0, 24).midiratio);\n\n\t// panning\nPbindef(\\grain0, \\pan, Pwhite(-0.8, 0.8));  // random\nPbindef(\\grain0, \\pan, Pn(Penv([-1, 1], [2]), inf)); // tendency\nPbindef(\\grain0, \\pan, Pfunc({ |ev| ev.freq.explin(50, 5000, -1, 1) })); // coupled to freq\n\n\t// time scattering variants\nPbindef(\\grain0, \\dur, 0.1 * Pwhite(0.5, 1.5));\t// random range\nPbindef(\\grain0, \\dur, 0.05 * Prand([0, 1, 1, 2, 4], inf)); // rhythmic random\n\n\t// amplitude - randomized\nPbindef(\\grain0, \\amp, Pwhite(0.01, 0.2));\t// linear\nPbindef(\\grain0, \\amp, Pwhite(-50, -14).dbamp); // exponential - more depth\nPbindef(\\grain0, \\dur, 0.025 * Prand([0, 1, 1, 2, 4], inf)); // could be denser now\n\n\t// random amplitude envelopes with Pseg\n(\nPbindef(\\grain0, \n\t\\amp, Pseg(\n\t\tPxrand([-50, -20, -30, -40] + 10, inf), // level pattern\n\t\tPxrand([0.5, 1, 2, 3], inf), \t\t// time pattern\n\t\tPrand([\\step, \\lin], inf)\t\t\t// curve pattern\n\t).dbamp\n); \n)\n\t// grain sustain time coupled to freq\nPbindef(\\grain0, \\sustain, Pkey(\\freq).reciprocal * 20).play;",
    "Figure 26": "figure 16.13   - GrainFM with individual control proxies\n(\n~trig = { |dens=10| Impulse.kr(dens) };\n~freq = { MouseX.kr(100, 2000, 1) * LFNoise1.kr(1).range(0.25, 1.75) };\n~moddepth = { LFNoise1.kr(20).range(1, 10) };\n~modfreq = 200;\n~graindur = 0.1;\n\n~grain = { arg envbuf = -1;\n\tGrainFM.ar(2, ~trig.kr, ~graindur.kr, \n\t\t~freq.kr, ~modfreq.kr, ~moddepth.kr, \n\t\tpan: WhiteNoise.kr, envbuf: envbuf) * 0.2\n};\n~grain.play;\n)\n\t// change control ugens: \n~modfreq = { ~freq.kr * LFNoise2.kr(1).range(0.5, 2.0) }; // modfreq roughly follows freq\n~trig = { |dens=10| Dust.kr(dens)};\t// random triggering, same density\n~freq = { LFNoise0.kr(0.3).range(200, 800) };\n~moddepth = 3; \t// fixed depth\n~graindur = { LFNoise0.kr.range(0.01, 0.1) };\n\n\n\n\t// bonus: blend dust and impulse triggers\n~trig = { |dens=20, bal=0.2| Dust.kr(dens * (1-bal)) + Impulse.kr(dens * bal) };\n~trig.set(\\bal, 0.1);\n~trig.set(\\bal, 0.5);\n~trig.set(\\bal, 0.9);\n\nProxyMixer(p);\n\n\n\n\np = ProxySpace.push;\n\n\n\t//",
    "Figure 27": "figure 16.14 - GrainBuf and control proxies\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~grain.set(\\wavebuf, b.bufnum);\n~trig = { |dens=10| Impulse.kr(dens) };\n~graindur = 0.1;\n~filepos = {LFNoise2.kr(0.2).range(0, 1) };\n~rate = { LFNoise1.kr.range(0.5, 1.5) };\n\n~grain = { arg envbuf = -1, wavebuf = 0;\n\tGrainBuf.ar(2, ~trig.kr, ~graindur.kr, wavebuf, \n\t~rate.kr, ~filepos.kr, 2, WhiteNoise.kr, envbuf) * 0.2\n};\n~grain.play;\n)\n\n\t// experiment with control proxies\n~trig = { |dens=20| Impulse.kr(dens) };\n~rate = { LFNoise1.kr.range(0.99, 1.01) };\n~filepos = { MouseX.kr + LFNoise0.kr(100, 0.03) };\n~graindur = 0.05;\n~trig = { |dens=50| Dust.kr(dens) };\n\nc = Buffer.sendCollection(s, Env.perc(0.01, 0.99).discretize, 1);\n~grain.set(\\envbuf, c.bufnum); \n~grain.set(\\envbuf, -1);\n\n~trig = { |dens=50| Impulse.kr(dens) }; ~graindur = 0.05;",
    "Figure 28": "figure 16.15 - Glisson synthesis\n(\nSynthDef(\"glisson\", \n\t{ arg out = 0, envbuf, freq=800, freq2=1200, sustain=0.001, amp=0.2, pan = 0.0;\n\t\tvar env = Osc1.ar(envbuf, sustain, 2);\n\t\tvar freqenv = XLine.ar(freq, freq2, sustain);\n\t\tOffsetOut.ar(out, \n\t\t\tPan2.ar(SinOsc.ar(freqenv) * env, pan, amp)\n\t\t)\n}, \\ir!7).memStore;\n)\n\n(\nTdef(\\gliss0, { |e|\n\t100.do({ arg i;\n\t\ts.sendBundle(s.latency, [\"/s_new\", \"glisson\", -1, 0, 0, \n\t\t\t\\freq, i % 10 * 100 + 1000,\n\t\t\t\\freq2, i % 13 * -100 + 3000,\n\t\t\t \\sustain, 0.05, \n\t\t\t \\amp, 0.1,\n\t\t\t \\envbuf, q.envbuf.bufnum\n\t\t]);\n\t\t(3 / (i + 10)).wait;\n\t});\n}).play;\n)\n\n\n\n/*\n\tMagnetization patterns can be:\n\tbidirectional, shallow, \n\tbidirectional, deep, \n\tunidir, up,\n\tunidir, down,\n\tconverging to center, \n\tdiverging from center. \n*/\n\n(\nSynthDef(\\glisson0, { |out, freq1=440, freq2=660, sustain=0.05, amp=0.2, pan, envwide=0.5| \n\tvar slopetime = (1 - envwide) * 0.5;\n\tvar sound = SinOsc.ar(XLine.ar(freq1, freq2, sustain));\n\tvar env = EnvGen.ar(\n\t\tEnv([0, amp, amp, 0], [slopetime, envwide, slopetime], \\sin), \n\t\ttimeScale: sustain,\n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(sound * env, pan));\n}).memStore; \n)\n\n(\nTdef(\\biGliss).set(\\fmin, 100, \\fmax, 5000, \\fratio, 1.0); // non-gliss, wide freq range\n\nTdef(\\biGliss, { |envir|\n\t\n\tvar f1, f2, temp; \n\tinf.do { \n\t\tf1 = exprand(envir.fmin, envir.fmax);\n\t\tf2 = f1 * (envir.fratio ** 1.0.rand2);\n\t//\t[f1, f2].postln;\n\t\t(\tinstrument: \\glisson0, \n\t\t\tfreq1: f1, \n\t\t\tfreq2: f2,\n\t\t\tpan: 1.0.rand2,\n\t\t\tsustain: 0.05\n\t\t).play;\n\t\t0.03.wait;\n\t};\n}).play;\n)\nTdef(\\biGliss).play;\nTdef(\\biGliss).set(\\fratio, 1.4);\t// shallow\nTdef(\\biGliss).set(\\fratio, 3.0);\t// wide\n\n\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 1.0);  // fixed\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 1.4);  // diverging, shallow\nTdef(\\biGliss).set(\\fmin, 600, \\fmax, 600, \\fratio, 2);\t   // diverging\n\n(\nTdef(\\biGliss).set(\\fmin, 1800, \\fmax, 600, \\fratio, 2.0);\t// converging\nTdef(\\biGliss, { |envir|\n\t\t\n\tvar f1, f2, temp; \n\t500.do { \n\t\tf1 = exprand(envir.fmin, envir.fmax);\n\t\tf2 = f1 * (envir.fratio ** 1.0.rand2);\n\t\t\n\t\t(\tinstrument: \\glisson0, \n\t\t\tfreq1: f2, \t// swap f1 and f2 here for converging\n\t\t\tfreq2: f1,\n\t\t\tpan: 1.0.rand2,\n\t\t\tsustain: 0.1\n\t\t).play;\n\t\t0.1.linrand.wait;\n\t};\n}).play;\n)\n\nTdef(\\biGliss).set(\\fmin, 1800, \\fmax, 2600, \\fratio, 2.0);   // converging",
    "Figure 29": "figure 16.16 - Pulsar basics - make a set of waveform and control tables\n(\nq = ();\nq.curr = (); \t// make a dict for the set of tables\nq.curr.tab = ();\n\t\t\t\t// random tables for pulsaret  and envelope waveforms:\nq.curr.tab.env = Env.perc.discretize; \nq.curr.tab.pulsaret = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// random tables for the control parameters:\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.curr.tab.amp = 0.2.dup(1024);\nq.curr.tab.pan = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// make buffers from all of them:\nq.bufs = q.curr.tab.collect({ |val, key| Buffer.sendCollection(s, val, 1) });\n)\n\t\t// plot one of them\nq.bufs.pulsaret.plot(\"a pulsaret\");\n\n\n\n\n\t//",
    "Figure 30": "figure 16.17 - Pulsars as nodeproxies using GrainBuf\n(\np = ProxySpace.push; \n\n\t\t// fund, form, amp, pan\n~controls = [ 16, 100, 0.5, 0]; \n~pulsar1.set(\\wavebuf, q.bufs.pulsaret.bufnum);\n~pulsar1.set(\\envbuf, q.bufs.env.bufnum);\n\n~pulsar1 = { |wavebuf, envbuf = -1| \n\tvar ctls = ~controls.kr;\n\tvar trig = Impulse.ar(ctls[0]);\n\tvar grdur = ctls[1].reciprocal;\n\tvar rate = ctls[1] * BufDur.kr(wavebuf);\n\t\t\n\tGrainBuf.ar(2, trig, grdur, wavebuf, rate, 0, 4, ctls[3], envbuf);\n};\n~pulsar1.play;\n)\n\n\t// crossfade between control settings\n~controls.fadeTime = 3; \n~controls = [ 16, 500, 0.5, 0]; \t// change formfreq\n~controls = [ 50, 500, 0.5, 0]; \t// change fundfreq\n~controls = [ 16, 100, 0.5, 0]; \t// change both\n~controls = [ rrand(12, 100), rrand(100, 1000)]; \n\n(\t// control parameters from looping tables\n~controls = { |looptime = 10| \n\tvar rate = BufDur.kr(q.bufs.pulsaret.bufnum) / looptime; \n\tA2K.kr(PlayBuf.ar(1, [\\fund, \\form, \\amp, \\pan].collect(q.bufs[_]), \n\t\trate: rate, loop: 1));\n};\n)\n\n\n\t//",
    "Figure 31": "figure 16.18 - make new tables and send them to buffers\n\n\t// make new pulsaret tables and send them to the buffer:\nq.bufs.pulsaret.sendCollection(Array.linrand(1024, -1.0, 1.0)); // noise burst\nq.bufs.pulsaret.read(\"sounds/a11wlk01.wav\", 44100 * 1.5);       // sample\nq.bufs.pulsaret.sendCollection(Pbrown(-1.0, 1.0, 0.2).asStream.nextN(1024));\n\n\t// make a new random fundfreq table, and send it\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.bufs.fund.sendCollection(q.curr.tab.fund);\n\n\t// and a new random formfreq table\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.bufs.form.sendCollection(q.curr.tab.form);\n\n\n\n\n\n\n\n\t// Pulsar synthesis with client-side control\n\t\n\t\t// a pulsaret and an envelope\na = Signal.sineFill(1024, 1/(1..10).scramble).putLast(0);\nb = Env.perc.discretize(1024).putLast(0);\n\t\t// as buffers\nx = Buffer.sendCollection(s, a, 1);\ny = Buffer.sendCollection(s, b, 1);\n\n\t\t// a pulsar synthdef\n(\nSynthDef(\\pulsar1, {|out, wavebuf, envbuf, form=200, amp=0.2, pan| \n\tvar grDur =  1/form;\n\tvar pulsaret = Osc1.ar(wavebuf, grDur);\n\tvar env = Osc1.ar(envbuf, grDur, doneAction: 2);\n\t\n\tOffsetOut.ar(out, Pan2.ar(pulsaret * env, pan, amp));\n}, \\ir ! 6).memStore;\n)\nSynth(\\pulsar1, [\\wavebuf, x, \\envbuf, y]);\n\n\t// a simple pattern\n(\nPbindef(\\pulsar1, \n\t\t\\instrument, \\pulsar1, \n\t\t\\wavebuf, x, \\envbuf, y, \n\t\t\\form, Pn(Penv([20, 1200], [4], \\exp)).loop, \n\t\t\\amp, 0.2, \\pan, 0,\n\t\t\\fund, 12, \n\t\t\\dur, Pfunc({ |ev| ev.fund.reciprocal })\n).play;\n)\n\n\n\n\t// Control from patterns and tables\n\nPbindef(\\pulsar1, \\form, Pn(Penv([20, 1200], [4], \\exp)).loop);\nPbindef(\\pulsar1, \\fund, Pn(Penv([5, 50], [5])).loop);\nPbindef(\\pulsar1, \\amp, Pn(Penv([0, 0.2, 0.1], [7])).loop);\nPbindef(\\pulsar1, \\pan, Pbrown(-1.0, 1.0, 0.2));\nPbindef(\\pulsar1, \\amp, 0.2);\n\n\t// use Pseg for a control table reader\nf = Env({ 100.0.rand }.dup(10), {1.0.rand}.dup(9).normalizeSum, \\sine).asSignal;\nf.plot;\n\nPbindef(\\pulsar1, \\fund, Pseg(f, 0.01, \\lin, inf)).play;",
    "Figure 32": "figure 16.19 time-pitch changing\np = ProxySpace.push(s.boot);\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~timepitch = {arg sndbuf, pitchRatio=1, pitchRd=0.01, grainRate=10, overlap=2, \n\tposSpeed=1, posRd=0.01;\n\t\n\tvar graindur = overlap / grainRate;\n\tvar pitchrate = pitchRatio + LFNoise0.kr(grainRate, pitchRd);\n\tvar position = LFSaw.kr(posSpeed / BufDur.kr(sndbuf)).range(0, 1) \n\t\t+ LFNoise0.kr(grainRate, posRd);\n\t\t\n\tGrainBuf.ar(2, Impulse.kr(grainRate), graindur, sndbuf, pitchrate,\n\t\t\tposition, 4, 0, -1)\n};\n~timepitch.set(\\sndbuf, b.bufnum);\n~timepitch.play;\n);\n\nSpec.add(\\pitchRatio, [0.25, 4, \\exp]);\nSpec.add(\\pitchRd, [0, 0.5, \\amp]);\nSpec.add(\\grainRate, [1, 100, \\exp]);\nSpec.add(\\overlap, [0.25, 16, \\exp]);\nSpec.add(\\posSpeed, [-2, 2]);\nSpec.add(\\posRd, [0, 0.5, \\amp]);\nNodeProxyEditor(~timepitch, 10);\n\n\t// reconstruct original\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 1, \\posRd, 0);\n\n\t// four times as long: tweak pitchRd and posJitter to reduce artifacts\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0);\n\n\t// random read position, random pitch\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0.5, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0.5);\n\n\n\n\n\n\n\t\t\t// examples constantQ granulation \n\n\n\t//",
    "Figure 33": "figure 16.20 - A constant-Q Synthdef.\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\nSynthDef(\\constQ, { |out, bufnum=0, amp=0.1, pan, centerPos=0.5, sustain=0.1, \n\trate=1, freq=400, rq=0.3| \n\n\tvar ringtime = (2.4 / (freq * rq) * 0.66).min(0.5); // estimated\n\tvar ampcomp = (rq ** -1) * (400 / freq ** 0.5);\t\n\tvar envSig = EnvGen.ar(Env([0, amp, 0], [0.5, 0.5] * sustain, \\welch));\n\tvar cutoffEnv = EnvGen.kr(Env([1, 1, 0], [sustain+ringtime,0.01]), doneAction: 2);\n\tvar grain = PlayBuf.ar(1, bufnum, rate, 0, \n\t\tcenterPos - (sustain * rate * 0.5) * BufSampleRate.ir(bufnum), \n\t\t1) * envSig;\t\n\tvar filtered = BPF.ar( grain, freq, rq, ampcomp ); \n\n\tOffsetOut.ar(out, Pan2.ar(filtered, pan, cutoffEnv))\n}, \\ir.dup(8)).memStore;\n)\n\nSynth(\\constQ, [\\bufnum, b, \\freq, exprand(100, 10000), \\rq, exprand(0.01, 0.1), \\sustain, 0.01]);\n\n\n\n\n\t// parameter tests for constant Q granulation\n\t\nSynth(\\constQ, [\\bufnum, b]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5]);\t// centerPos = where in soundfile (seconds)\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 1]);\t\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 1.5]);\t\n\t\n\t// sustain is sustain of exciter grain: \nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.01]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.03]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.1]);\nSynth(\\constQ, [\\bufnum, b, \\centerPos, 0.5, \\sustain, 0.3]);\n\n\t// filter parameters, rq of bandpass determines ringtime\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 1]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.3]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.1]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.03]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.01]);\nSynth(\\constQ, [\\bufnum, b, \\freq, 1200, \\rq, 0.003]);\n\n\t// lower freq rings longer\nSynth(\\constQ, [\\bufnum, b, \\freq, 600, \\rq, 0.003]);\n\n\n\n\t//",
    "Figure 34": "figure 16.21 - a stream of constant Q grains\n(\nPbindef(\\gr1Q, \n\t\\instrument, \\constQ, \\bufnum, b.bufnum,\n\t\\sustain, 0.01, \\amp, 0.2,\n\t\\centerPos, Pn(Penv([1, 2.0], [10], \\lin)), \n\t\\dur, Pn(Penv([0.01, 0.09, 0.03].scramble, [0.38, 0.62] * 10, \\exp)),\n\t\\rate, Pwhite(0.95, 1.05), \n\t\\freq, Pbrown(64.0, 120, 8.0).midicps,\n\t\\pan, Pwhite(-1, 1, inf),\n\t\\rq, 0.03\n).play;\n)\n\t// changing parameters while playing\nPbindef(\\gr1Q, \\rq, 0.1);\nPbindef(\\gr1Q, \\rq, 0.01);\nPbindef(\\gr1Q, \\sustain, 0.03, \\amp, 0.08);\nPbindef(\\gr1Q, \\freq, Pbrown(80, 120, 18.0).midicps);\n\nPbindef(\\gr1Q, \\rq, 0.03);\n\nPbindef(\\gr1Q, \\rate, Pn(Penv([1, 2.0], [6], \\lin)));\n\n\t// variable duration\nPbindef(\\gr1Q, \\dur, Pwhite(0.01, 0.02));\n\n\t// a rhythm that ends\nPbindef(\\gr1Q, \\dur, Pgeom(0.01, 1.1, 40));",
    "Figure 35": "figure 16.22 - a Wavesets object\nw = Wavesets.from(\"sounds/a11wlk01.wav\");\n\nw.xings;\t\t\t// all integer indices of the zero crossings found\nw.numXings;\t\t// the total number of zero crossings\nw.lengths;\t\t// lengths of all wavesets\nw.amps;\t\t\t// peak amplitude of every waveset\nw.maxima;\t\t\t// index of positive maximum value in every waveset\nw.minima;\t\t\t// index of negative minimum value in every waveset\n\nw.fracXings;\t\t// fractional zerocrossing points\nw.fracLengths;\t// and lengths: allows more precise looping.\n\t\t\t\t\nw.lengths.plot;\t// show distribution of lengths\nw.amps.plot;\n\n\t// get data for a single waveset: frameIndex, length (in frames), dur\nw.frameFor(140, 1);\t\nw.ampFor(140, 1);\t\t// peak amplitude of that waveset or group\n\t\n\t// extract waveset by hand\nw.signal.copyRange(w.xings[150], w.xings[151]).plot(\"waveset 150\");\nw.plot(140, 1);\t// convenience plotting\nw.plot(1510, 1);\t\n\n\t// plot a group of 5 adjacent wavesets\nw.plot(1510, 5)\t\n\n\n\n\t//",
    "Figure 36": "figure 16.23 and 24 are screenshots\n\n\n\n\t//",
    "Figure 37": "figure 16.25 - wavesets and buffers\n\n\t// A Synthdef to play a waveset (or group) n times.\n(\n\t// A wavesets loads the file into a buffer by default.\n\t\tb = w.buffer;\t\t\n\t// Wavesets.prepareSynthDefs loads this synthdef: \n\t\tSynthDef(\\wvst0, { arg out = 0, buf = 0, start = 0, length = 441, playRate = 1, sustain = 1, amp=0.2, pan; \n\t\t\tvar phasor = Phasor.ar(0, BufRateScale.ir(buf) * playRate, 0, length) + start;\n\t\t\tvar env = EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2);\n\t\t\tvar snd = BufRd.ar(1, buf, phasor) * env;\n\t\t\t\n\t\t\tOffsetOut.ar(out, Pan2.ar(snd, pan));\n\t\t}, \\ir.dup(8)).memStore;\n)\n\n// play from frame 0 to 440, looped for 0.1 secs, so ca 10 repeats. \n(instrument: \\wvst0, bufnum: b.bufnum, start: 0, length: 440, amp: 1, sustain: 0.1).play;\n\n\t// get data from waveset\n(\nvar start, length, sustain, repeats = 20; \n#start, length, sustain = w.frameFor(150, 5);\n\n(\tinstrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\tstart: start, length: length, sustain: sustain * repeats\n).play;\n)\n\n\t// or even simpler: \nw.eventFor(startWs: 150, numWs: 5, repeats: 20, playRate: 1).put(\\amp, 0.5).play;\n\n\n\n\n\t//",
    "Figure 38": "figure 16.26 - a pattern to play wavesets\n\n\t// by default, this pattern reconstructs a soundfile segment.\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 3000), 1), \n\t\\numWs, 1, \n\t\\playRate, 1, \n\t\\bufnum, b.bufnum, \n\t\\repeats, 1, \n\t\\amp, 0.4,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur; \n\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\t\t[start, length, wsDur * ev[\\repeats] / ev[\\playRate].abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\n\n\n\t//",
    "Figure 39": "figure 16.27 - some of wishart's transforms\n\n\t// waveset transposition: every second waveset, half speed\nPbindef(\\ws1, \\playRate, 0.5, \\startWs, Pn(Pseries(0, 2, 500), 1)).play;\n\n\t// reverse every single waveset \nPbindef(\\ws1, \\playRate, -1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\t// reverse every 2 wavesets\nPbindef(\\ws1, \\numWs, 2, \\playRate, -1, \\startWs, Pn(Pseries(0, 2, 1000), 1)).play;\n\t// reverse every 20 wavesets\nPbindef(\\ws1, \\numWs, 20, \\playRate, -1, \\startWs, Pn(Pseries(0, 20, 1000), 1)).play;\n\t// restore\nPbindef(\\ws1, \\numWs, 1, \\playRate, 1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\n\t// time stretching\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 4).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1, \\repeats, 1).play;\t// restore\n\n\t// waveset omission: drop every second\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1,1, \\, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pfunc({ if (0.25.coin, 1, \\) }) ).play; // drop randomly\nPbindef(\\ws1, \\numWs, 1, \\freq, 1, \\startWs, Pn(Pseries(0, 1, 1000)) ).play; // restore\n\n\t// waveset shuffling (randomize waveset order +- 5, 25, 125)\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 5.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 25.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 125.rand2 })).play;\t\n\n\n\n\n\n\t//",
    "Figure 40": "figure 16.28 - waveset substitution\n\t\n\t// the waveform to substitute\nc = Buffer.alloc(s, 512); c.sendCollection(Signal.sineFill(512, [1]));\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 1000), 5), \n\t\\numWs, 1, \\playRate, 1, \n\t\\buf, c.bufnum, // sine wave\n\t\\repeats, 1, \n\t\\amp, 1,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur, origRate; \n\t\torigRate = ev[\\playRate];\n\t\t\n\t\t\t// get orig waveset specs\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\n\t\t\t// adjust playrate for different length of substituted wave\n\t\tev[\\playRate] = origRate * (512 / length); \n\n\t\t\t// get amplitude from waveset, to scale full volume sine wave\n\t\tev[\\amp] = ev[\\amp] * w.ampFor(ev[\\startWs], ev[\\numWs]);\n\t\t\n\t\t[0, 512, wsDur * ev[\\repeats] / origRate.abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\t// clearer sinewave-ish segments\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1).stop;\n\n\t// different waveforms\nc.sendCollection(Signal.sineFill(512, 1/(1..4).squared.scramble));\nc.sendCollection(Signal.rand(512, -1.0, 1.0));\nc.sendCollection(Signal.sineFill(512, [1]));\n\nc.plot;\n\n\n\n\n\t//\twaveset interpolation - web examples only\n(\nSynthDef(\"wsInterp\", { arg out = 0, \n\tbuf1 = 0, start1 = 0, len1 = 1000, \n\tbuf2 = 0, start2 = 0, len2 = 500, \n\tplayRate = 1, sustain = 1, \n\tamp=0.2, pan; \n\t\n\tvar lenRatio = (len1 / len2);\n\tvar playRateLine = Line.ar(playRate, playRate * lenRatio, sustain); \n\t\n\tvar phasor1 = Phasor.ar(0, BufRateScale.ir(buf1) * playRateLine, 0, len1);\n\tvar phasor2 = phasor1 / lenRatio; \n\tvar xfade = Line.ar(0, 1, sustain);\n\t\n\tvar snd = (BufRd.ar(1, [buf1, buf2], \n\t\t[phasor1 + start1, phasor2 + start2], \n\t\tinterpolation: 4)\n\t\t* [1 - xfade, xfade]).sum;\n\t\n\tOffsetOut.ar(out, \n\t\tPan2.ar(\n\t\t\tsnd * EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2),\n\t\t \tpan\n\t \t)\n\t );\n}, \\ir.dup(12)).memStore;\n)\n\n(\nq = q ? ();\nq.playInterp = { |q, start1, len1, start2, len2, numWs=200| \n\tvar set1 = w.frameFor(start1, len1).postln;\n\tvar set2 = w.frameFor(start2, len2).postln; \n\tvar sustain = (set2[2] + set1[2] * 0.5 * numWs).postln;\n\n\t(instrument: \\wsInterp, buf1: b.bufnum, buf2: b.bufnum, amp: 0.5,\n\t\n\t\tstart1: set1[0], len1: set1[1], playRate: 1,\n\t\tstart2: set2[0], len1: set2[1], sustain: sustain\n\t).play;\t\n};\n)\n\t// some interpolations\nq.playInterp(200, 1, 500, 1, 400);\nq.playInterp(400, 8, 600, 3, 100);\nq.playInterp(200, 1, 500, 5, 600);\n\n\n\n\n\n\t//",
    "Figure 41": "figure 16.29 - wavesets played with Tdef \n\t\n\t// very simple first pass, fixed repeat time\n(\nTdef(\\ws1).set(\\startWs, 400);\nTdef(\\ws1).set(\\numWs, 5);\nTdef(\\ws1).set(\\repeats, 5);\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain; \n\n\tloop { \n\t\t#startFrame, length, wsSustain = w.frameFor(ev.startWs.next, ev.numWs);\n\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * ev.repeats;\n\t\t).play;\n\t\t\n\t\t0.1.wait;\t\n\t}\n}).play;\n)\n\nTdef(\\ws1).set(\\startWs, 420);\nTdef(\\ws1).set(\\repeats, 3);\nTdef(\\ws1).set(\\numWs, 2);\n\n\t\t// drop in a pattern for starting waveset \t\t\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\n\n\n\n\n\t//",
    "Figure 42": "figure 16.30 - waittime from waveset duration, gap\n(\nTdef(\\ws1).set(\\gap, 3);\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps; \n\n\tloop { \n\t\treps = ev.repeats.next;\n\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, ev.numWs.next);\t\t\t\n\t\t\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * reps,\n\t\t\tpan: 1.0.rand2\n\t\t).play;\n\t\t\n\t\t\t// derive waittime from waveset sustain time\n\t\t\t// add gap based on waveset sustain time \n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\t// experiment with dropping in patterns:\n\t// very irregular gaps\nTdef(\\ws1).set(\\gap, { exprand(0.1, 20) });\n\t// sometimes continuous, sometimes gaps\nTdef(\\ws1).set(\\gap, Pbrown(-10.0, 20, 2.0).max(0).asStream);\n\n\t// random repeats\nTdef(\\ws1).set(\\repeats, { exprand(1, 20).round });\n\t// randomize number of wavesets per group\nTdef(\\ws1).set(\\numWs, { exprand(3, 20).round });\nTdef(\\ws1).set(\\numWs, 3, \\repeats, { rrand(2, 5) });\n\nTdef(\\ws1).stop;\n\n\n\n\t//",
    "Figure 43": "figure 16.31 - add pitch contour and dropout rate\n(\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\nTdef(\\ws1).set(\\gap, 0);\nTdef(\\ws1).set(\\pitchContour, 0);\nTdef(\\ws1).set(\\keepCoin, 1.0);\nTdef( 'ws1' ).set( 'repeats' , 5 );\nTdef( 'ws1' ).set( 'numWs' , 3 );\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps, numWs, len2Avg; \n\tvar squeezer, playRate;\n\tloop { \n\t\treps = ev.repeats.next;\n\t\tnumWs = ev.numWs.next;\n\t\t\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, numWs);\t\t\t\n\t\t\n\t\tlen2Avg = length / numWs / w.avgLength;\t\t\n\t\tsqueezer = len2Avg ** ev.pitchContour.next;\n\t\twsSustain = wsSustain / squeezer; \n\t\tplayRate = 1 * squeezer;\n\n\t\tif (ev.keepCoin.next.coin) { \n\t\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\t\tstart: startFrame, length:  length, \n\t\t\t\tsustain: wsSustain * reps,\n\t\t\t\tplayRate: playRate, \n\t\t\t\tpan: 1.0.rand2\n\t\t\t).play;\n\t\t};\n\t\t\n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\n\t// try different pitch Contours:\nTdef(\\ws1).set(\\pitchContour, 0); \t// original pitch\n\nTdef(\\ws1).set(\\pitchContour, 0.5); // flattened contour\n\n\t\t// waveset overtone singing - all equal length\nTdef(\\ws1).set(\\pitchContour, 1.0); \n\n\t\t// inversion of contour\nTdef(\\ws1).set(\\pitchContour, 1.5);\nTdef(\\ws1).set(\\pitchContour, 2);\nTdef(\\ws1).set(\\repeats, 3); \n\n\t// waveset omission\nTdef(\\ws1).set(\\keepCoin, 0.75);\nTdef(\\ws1).set(\\keepCoin, 1);\n\n\t// fade out by omission over 13 secs, pause 2 secs \nTdef(\\ws1).set(\\keepCoin, Pn(Penv([1, 0, 0], [13, 2])).asStream).play;\n\n\t// add a pitch contour envelope\nTdef(\\ws1).set(\\pitchContour, Pn(Penv([0, 2, 0], [21, 13])).asStream);",
    "Figure 44": "Figure 1.1 Example of additive synthesis\n\nplay({\n\tvar sines = 100, speed = 6;\n\tMix.fill(sines, \n\t\t{arg x; \n\t\t\tPan2.ar(\n\t\t\t\tSinOsc.ar(x+1*100, \n\t\t\t\t\tmul: max(0, \n\t\t\t\t\t\tLFNoise1.kr(speed) +\n\t\t\t\t\t\tLine.kr(1, -1, 30)\n\t\t\t\t\t)\n\t\t\t\t), rand2(1.0))})/sines})\n\n/////////////\n\nrand(100)\n\nexprand(1.0, 100.0) \n\nthisThread.randSeed = 666; {rand(10.0)} ! 10;\n\ndup(\"echo\", 20)\n\nround([3.141, 5.9265, 358.98], 0.01)\n\nsort([23, 54, 678, 1, 21, 91, 34, 78])\n\nround(dup({exprand(1, 10)}, 100), 0.1)\n\nsort(round(dup({exprand(1, 10)}, 100), 0.1))\n\n/////////////\n\n                            exprand(1.0, 1000.0)\n                   dup({exprand(1.0, 1000.0)}, 100)\n           sort(dup({exprand(1.0, 1000.0)}, 100))\nround(sort(dup({exprand(1.0, 1000.0)}, 100)), 0.01)\n\n/////////////",
    "Figure 45": "Figure 1.3 Fortuitous futuristic nested music.\n\n(\nplay(\n\t{\n\t\tCombN.ar(\n\t\t\tSinOsc.ar(\n\t\t\t\tmidicps(\n\t\t\t\t\tLFNoise1.ar(3, 24, \n\t\t\t\t\t\tLFSaw.ar([5, 5.123], 0, 3, 80)\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\t0, 0.4), \n\t\t\t1, 0.3, 2)\n\t}\n)\n)\n\n/////////////\n\n[45, 13, 10, 498, 78].sort // collection of items, do this; sort yourself\n\n\"echo\".dup(20) // echo, do this; repeat yourself 20 times\n\n50.midicps // the number 50, do this; convert yourself into Hz\n\n444.cpsmidi // 444, do this; convert yourself into a midi number\n\n100.rand // 100, do this; pick a number between 0 and yourself\n\n{100.rand}.dup(50) // random picking function, do this; repeat 50 times\n\n[1.001, 45.827, 187.18].round(0.1) // collection of items; round to 0.1\n\n// Mac users only, sorry\n\"I've just picked up a fault in the AE35 unit\".speak // Hal; plot to kill me\n\n/////////////\n\n1000.0 // a number\n\n1000.0.rand // choose a number between 0 and 1000\n\n1000.0.rand.round(0.01) // choose a number and round it\n\n1000.0.rand.round(0.01).post // choose, round, then post\n\n{1000.0.rand.round(0.01).postln}.dup(100).plot // choose, round, dup, plot\n\n{1000.0.rand.round(0.01).postln}.dup(100).postln.sort.plot // choose etc., sort, plot\n\n//Mac only\n1000.0.rand.round(0.01).postln.asString.speak // convert to string and speak\n\n5 + 10 * 4\n\n[0, 11, 10, 1, 9, 8, 2, 3, 7, 4, 6, 5].reverse // retrograde of a 12-tone row\n\n12 - [0, 11, 10, 1, 9, 8, 2, 3, 7, 4, 6, 5].reverse // retrograde inversion\n\n[0, 2, 4, 5, 6, 7, 9, 11].scramble // diatonic scale\n\n[60, 62, 64, 67, 69].mirror // pentatonic\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].rotate\n\n[60, 62, 64, 65, 67, 69, 71].midicps.round(0.1) // convert midi to frequency in Hz\n\n[1, 0.75, 0.5, 0.25, 0.125].choose // maybe durations?\n\n0.125 * [1, 2, 3, 4, 5, 6, 7, 8].choose // multiples of a smallest quantize value\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].permute(6) \n\n/////////////\n\nexprand(1, 1000.0)\n\n{exprand(1, 1000.0)}\n\ndup(rand(1000.0), 5)  // picks a number, duplicates it\n\ndup({rand(1000.0)}, 5)  //duplicates the function of picking a number\n\n// essentially, this (which has a similar result) \n[rand(1000.0), rand(1000.0), rand(1000.0), rand(1000.0), rand(1000.0)]\n\n/////////////\n\n{LFNoise0.ar}.play  //play a series of random numbers\n\n{LFNoise0.ar(10000)}.plot // plot those numbers\n\n{LFNoise0.ar(10000)}.scope // play and show on a scope\n\n{100.rand}.dup(10) // pick 10 random numbers\n\n{100.rand} ! 10 // same as above\n\n{100.rand}.dup(10).postln.plot // pick 10 numbers, post, then plot them\n\n{100.rand}.dup(100).sort.plot // pick 100 numbers, sort them, then plot\n\n/////////////\n\n{Blip.ar(25, LFNoise0.kr(5, 12, 14), 0.3)}.play // single channel\n\n{Blip.ar(25, LFNoise0.kr([5, 10], 12, 14), 0.3)}.play // stereo\n\n{Blip.ar(25, LFNoise0.kr([5, 10, 2, 25], 12, 14), 0.3)}.play // quad\n\n{Blip.ar(25, LFNoise0.kr([5, 4, 7, 9, 5, 1, 9, 2], 12, 14), 0.3)}.play // 8\n\n/////////////\n\n{PMOsc.ar(440, 550, 7)}.play // pretty boring, like an FM radio\n\n{PMOsc.ar(440, MouseY.kr(1, 550), MouseX.kr(1, 15))}.play\n\n{PMOsc.ar(100, 500, 10, 0, 0.5)}.play // all arguments listed in order\n\n{PMOsc.ar(carfreq: 100, modfreq: 500, pmindex: 10, mul: 0.5)}.play // keywords\n\n{PMOsc.ar(carfreq: 100, mul: 0.5, pmindex: 10, modfreq: 500)}.play // mixed\n\n{SinOsc.ar(mul: MouseX.kr(0, 1.0))}.scope\n\n/////////////",
    "Figure 46": "Figure 1.4 VCO, VCF, VCA\n\n(\n{\n\tBlip.ar(\n\t\tTRand.kr( // frequency or VCO\n\t\t\t100, 1000, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tTRand.kr( // number of harmonics or VCF\n\t\t\t1, 10, // range\n\t\t\tImpulse.kr(Line.kr(1, 20, 60))), // trigger\n\t\tLinen.kr( // mul, or amplitude, VCA\n\t\t\tImpulse.kr(Line.kr(1, 20, 60)), // trigger\n\t\t\t0, // attack\n\t\t\t0.5, // sustain level\n\t\t\t1/Line.kr(1, 20, 60)) // trigger\n\t\t)\n}.play\n)\n\n/////////////\n\n(\na = 440;\nb = 3;\nc = \"math operations\";\n[c, a, b, a*b, a + b, a.pow(b), a.mod(b)]\n)\n\n// same as\n[\"math operations\", 440, 3, 440*3, 440 + 3, 440.pow(3), 440.mod(3)]\n\n/////////////\n\n(\n{\nr = MouseX.kr(1/3, 10);\nSinOsc.ar(mul: Linen.kr(Impulse.kr(r), 0, 1, 1/r))\n}.play\n)\n\n///////////// Example 1.5 Synthesis example with variables and statements\n\n(\n// run this first\np = { // make p equal to this function\nr = Line.kr(1, 20, 60); // rate\n// r = LFTri.kr(1/10) * 3 + 7;\nt = Impulse.kr(r); // trigger\n// t = Dust.kr(r);\ne = Linen.kr(t, 0, 0.5, 1/r); // envelope uses r and t\nf = TRand.kr(1, 10, t); // triggered random also uses t\n// f = e + 1 * 4;\nBlip.ar(f*100, f, e) // f, and e used in Blip\n}.play\n)\n\np.free;  // run this to stop it\n\n/////////////",
    "Figure 47": "Figure 1.6 Phase modulation with modulator as ratio\n\n(\n{ // carrier and modulator not linked\n\tr = Impulse.kr(10);\n\tc = TRand.kr(100, 5000, r);\n\tm = TRand.kr(100, 5000, r);\n\tPMOsc.ar(c, m, 12)*0.3\n}.play\n)\n\n(\n{\n\tvar rate = 4, carrier, modRatio; // declare variables\n\tcarrier = LFNoise0.kr(rate) * 500 + 700;\n\tmodRatio = MouseX.kr(1, 2.0);\n\t// modulator expressed as ratio, therefore timbre\n\tPMOsc.ar(carrier, carrier*modRatio, 12)*0.3\n}.play\n)\n\n/////////////\n\n{SinOsc.ar}.play // generates a temp__reallyLongNumber name\n\n// names the synth and output bus 0 (left) explicitly\nSynthDef(\"sine\", {Out.ar(0, SinOsc.ar)}).play\n\nSynthDef(\"sine\", {Out.ar(1, SinOsc.ar)}).play // right channel\n\n// or\n\n(\nSynthDef(\"one_tone_only\", {\n\tvar out, freq = 440;\n\tout = SinOsc.ar(freq);\n\tOut.ar(0, out)\n}).play\n)\n\n// then to play it\n\nSynth(\"one_tone_only\");\n\n/////////////\n\n(\nSynthDef(\"different_tones\", {\n\targ freq = 440; // declare an argument and give it a default value\n\tvar out; \n\tout = SinOsc.ar(freq)*0.3;\n\tOut.ar(0, out)\n}).play\n)\n\n/////////////\n\n// Run all four, then stop all \n\nSynth(\"different_tones\", [\"freq\", 550]);\n\nSynth(\"different_tones\", [\\freq, 660]); // same as \"freq\"\n\nSynth(\"different_tones\", [\"freq\", 880]);\n\n// If no argument is specified, defaults are used (440)\nSynth(\"different_tones\")\n\n/////////////\n\na = Synth(\"different_tones\", [\"freq\", 64.midicps]);\n\nb = Synth(\"different_tones\", [\"freq\", 67.midicps]);\n\nc = Synth(\"different_tones\", [\"freq\", 72.midicps]);\n\na.set(\"freq\", 65.midicps);\n\nc.set(\"freq\", 71.midicps);\n\na.set(\"freq\", 64.midicps); c.set(\"freq\", 72.midicps);\n\na.free; \n\nb.free; \n\nc.free;\n\n/////////////",
    "Figure 48": "Figure 1.7 Synth definition\n\n(\n//run this first\nSynthDef(\"PMCrotale\", {\narg midi = 60, tone = 3, art = 1, amp = 0.8, pan = 0; \nvar env, out, mod, freq;\n\nfreq = midi.midicps;\nenv = Env.perc(0, art);\nmod = 5 + (1/IRand(2, 6));\n\nout = PMOsc.ar(freq, mod*freq, \n\tpmindex: EnvGen.kr(env, timeScale: art, levelScale: tone), \n\tmul: EnvGen.kr(env, timeScale: art, levelScale: 0.3));\n\nout = Pan2.ar(out, pan);\n\nout = out * EnvGen.kr(env, timeScale: 1.3*art, \n\tlevelScale: Rand(0.1, 0.5), doneAction:2);  \nOut.ar(0, out); //Out.ar(bus, out);\n\n}).add;\n)\n\n//Then run this a bunch of times:\n\nSynth(\"PMCrotale\", [\"midi\", rrand(48, 72).round(1), \"tone\", rrand(1, 6)])\n\n\n~houston = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\n~chooston = Buffer.read(s, \"sounds/a11wlk01.wav\");\n\n{PlayBuf.ar(1, ~houston)}.play; // number of channels and buffer.\n\n{PlayBuf.ar(1, ~chooston)}.play; // number of channels and buffer.\n\n/////////////",
    "Figure 49": "Figure 1.8 Playback buffers\n\n[~houston.bufnum, ~houston.numChannels, ~houston.path, ~houston.numFrames];\n\n[~chooston.bufnum, ~chooston.numChannels, ~chooston.path, ~chooston.numFrames];\n\n(  // phasing\n{\n\tvar rate, trigger, frames;\n\tframes = ~houston.numFrames; // or use ~chooston.numFrames\n\n\trate = [1, 1.01];\n\ttrigger = Impulse.kr(rate);\n\tPlayBuf.ar(1, ~houston, 1, trigger, frames * Line.kr(0, 1, 60)) * \n\tEnvGen.kr(Env.linen(0.01, 0.96, 0.01), trigger) * rate;\n}.play;\n)\n\n/////////////\n\n(  // speed and direction change\n{\n\tvar speed, direction;\n\tspeed = LFNoise0.kr(12) * 0.2 + 1;\n\tdirection = LFClipNoise.kr(1/3);\n\tPlayBuf.ar(1, ~houston, (speed * direction), loop: 1);\n}.play;\n)\n\n/////////////",
    "Figure 50": "Figure 1.9 Connecting controls with a bus\n\n(\n// if these haven't been used they will hold 0\n~kbus1 = Bus.control; // a control bus\n~kbus2 = Bus.control; // a control bus\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tPlayBuf.ar(1, ~chooston, (speed * direction), loop: 1);\n}.play;\n)\n\n(\n// Start the controls\n{Out.kr(~kbus1, LFNoise0.kr(12))}.play;\n\n{Out.kr(~kbus2, LFClipNoise.kr(1/4))}.play;\n)\n\n// Start the second buffer with the same control input buses, \n// but send it to the right channel using Out.ar(1 etc.\n\n(\n{\n\tvar speed, direction;\n\tspeed = In.kr(~kbus1, 1) * 0.2 + 1;\n\tdirection = In.kr(~kbus2);\n\tOut.ar(1, PlayBuf.ar(1, ~houston, (speed * direction), loop: 1));\n}.play;\n)\n\n/////////////\n\n~kbus3 = Bus.control; // a control bus\n\n~kbus4 = Bus.control; // a control bus\n  // run these one at a time, (turn down the speakers!)\n\n{Out.kr(~kbus3, SinOsc.kr(3).scope(\"out3\") * 100)}.play; \n\n{Out.kr(~kbus4, LFPulse.kr(1/3).scope(\"out4\") * 200)}.play;\n\n{Out.ar(0, SinOsc.ar(In.kr(~kbus3) + In.kr(~kbus4) + 440).scope(\"left\"))}.play;\n\n{Out.ar(1, SinOsc.ar(In.kr(~kbus3) + In.kr(~kbus4) + 880).scope(\"right\"))}.play;\n\n~kbus3 = Bus.control; // a control bus \n\n~kbus4 = Bus.control; // a control bus \n\n{Out.kr(~kbus3, SinOsc.kr(3).range(340, 540))}.play;\n\n{Out.kr(~kbus4, LFPulse.kr(6).range(240, 640))}.play;\n\nSynthDef(\"Switch\", {arg freq = 440; Out.ar(0, SinOsc.ar(freq, 0, 0.3)) }).add;\n\nx = Synth(\"Switch\"); // default\n\nx.map(\\freq, ~kbus3)\n\nx.map(\\freq, ~kbus4)\n\n/////////////",
    "Figure 51": "Figure 1.10 Buffer modulation\n\n(\n{\n\tOut.ar(0,\n\t\tPan2.ar( PlayBuf.ar(1, ~houston, loop: 1) * \n\t\t\tSinOsc.ar(LFNoise0.kr(12, mul: 500, add: 600)),\n\t\t0.5)\n\t)\n}.play\n)\n\n(\n{\nvar source, delay; \n\tsource = PlayBuf.ar(1, ~chooston, loop: 1);\n\tdelay =  AllpassC.ar(source, 2, [0.65, 1.15], 10);\n\tOut.ar(0,\n\tPan2.ar(source) + delay\n\t)\n}.play\n)\n\n/////////////",
    "Figure 52": "Figure 1.11 FX routing using buses.\n\n// Create and name buses \n~delay = Bus.audio(s, 2);\n~mod = Bus.audio(s, 2);\n~gate = Bus.audio(s, 2);\n~k5 = Bus.control;\n\n{Out.kr(~k5, LFNoise0.kr(4))}.play; // start the control\n\n// Start the last item in the chain, the delay\n{Out.ar(0, AllpassC.ar(In.ar(~delay, 2), 2, [0.65, 1.15], 10))}.play \n\n// Start the next to last item, the modulation\n{Out.ar(~delay, In.ar(~mod, 2) * SinOsc.ar(In.kr(~k5)*500 + 1100))}.play\n\n// Start the third to last item, the gate\n{Out.ar([0, ~mod], In.ar(~gate, 2) * max(0, In.kr(~k5)))}.play\n\n// Start one buffer\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~houston, loop: 1), 0.5))}.play;\n\n// Start the other\n{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~chooston, loop: 1), -0.5))}.play\n\n/////////////\n\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B \"];\n\na.at(8);\n\n\"Item at index 5 is: \".post; a.at(5).postln; // why didn't it print E?\n\n\"Item at index 0 is: \".post; a.at(0).postln; // because we start with 0\n\ndo(50, { [0, 2, 4, 5, 7, 9, 11].at(7.rand).postln})\n\ndo(50, { [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"].at(7.rand).postln})\n\n///////////// \n\nTask({\n\t50.do({\n\t\t[\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"].at(7.rand).postln;\n\t\t1.wait;\n\t});\n}).play\n\n/////////////",
    "Figure 53": "Figure 1.12 Random MIDI walk.\n\nTask({\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"count, midi, pitch, octave\".postln;\n\tdo(50, {arg count;\n\t\tp = rrand(36, 72);\n\t\t[count, p, a.wrapAt(p), (p/12).round(1) - 1].postln;\n\t1.wait;\n\t})\n}).play\n\n///////////// 1.13 Random Crotale Walk\n\n// This uses the PMCrotale synth definition\n(\na = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n\"event, midi, pitch, octave\".postln;\nr = Task({\n\tinf.do({ arg count;\n\t\tvar midi, oct, density;\n\t\tdensity = 1.0; // 100% of the time. Uncomment below for 70%, etc.\n\t\t// density = 0.7; \n\t\t// density = 0.3;\n\t\tmidi = [0, 2, 4, 7, 9].choose;\n\t\t// midi = [0, 2, 4, 5, 7, 9, 11].choose;\n\t\t// midi = [0, 2, 3, 5, 6, 8, 9, 11] .choose; \n\t\t// midi = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] .choose;\n\t\toct = [48, 60, 72].choose;\n\t\tif(density.coin, \n\t\t\t{ // true action\n\t\t\t\t\"\".postln;\n\t\t\t\t[midi + oct, a.wrapAt(midi), \n\t\t\t\t(oct/12).round(1)].post;\n\t\t\t\tSynth(\"PMCrotale\", \n\t\t\t\t\t[\"midi\", midi + oct, \"tone\", rrand(1, 7), \n\t\t\t\t\t\"art\", rrand(0.3, 2.0), \"amp\", rrand(0.3, 0.6), \"pan\", 1.0.rand2]);\n\t\t\t}, {[\"rest\"].post}); // false action\n\t\t0.2.wait; \n\t}); \n}).start\n)\n\nr.stop; // run this to stop\n\n/////////////\n\nif(10 == 10, {\"10 is indeed equal to 10\"}, {\"false\"})\n\nif((1 < 20).and(1.isInteger), {\"1 is less than 20\"}, {\"false\"})\n\n10.do({arg count; [count, if(count.odd, {\"odd\"}, {\"even\"})].postln})\n\n(\n84.do({arg count; if([0, 4, 7].includes(count%12), \n\t{count.post; \" is part of a C triad.\".postln}, \n\t{count.post; \" is not part of a C traid\".postln})})\n)\n\n50.do({if(1.0.rand.round(0.01).post > 0.5,  {\" > 0.5\".postln}, {\" < 0.5\".postln})})\n\n50.do({if(1.0.rand > 0.5,  {\"play a note\".postln}, {\"rest\".postln})})\n\n50.do({if(0.5.coin, {\"play a note\".postln}, {\"rest\".postln})}) // same as above\n\nif((10.odd).or(10 < 20), {\"true\".postln}, {\"false\".postln})\n\n/////////////\n\nArray.fill(100, {wchoose([1, 2, 3, 4], [0.5, 0.3, 0.125, 0.075])}).sort\n\n/////////////\n\n[0, 2, 4, 5, 7, 9, 11].do({arg each, count; [\"count\", count, \"each\", each].postln})  \n// same\n[0, 2, 4, 5, 7, 9, 11].do({arg whatever, blech; [blech, whatever].postln})\n\n(\nvar pc;\npc = [\"C\", \"C#\", \"D\",  \"Eb\", \"E\", \"F\", \"F#\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\n[0, 2, 4, 5, 7, 9, 11].do({arg each; pc.wrapAt(each).postln;})\n)\n\n/////////////",
    "Figure 54": "Figure 1.14 Nested do to generate a 12-tone matrix.\n\n(\nvar row, inversion, pitchClass;\nrow = Array.series(11, 1).scramble.insert(0, 0); \n// or enter your own row, e.g. Webern's Op 27\n// row = [0, 11, 8, 2, 1, 7, 9, 10, 4, 3, 5, 6]; \nrow.postln;\ninversion = 12 - row;\n// I add spaces to the strings for a tidy row\npitchClass = [\"C  \", \"C# \", \"D  \", \"Eb \", \n\t\"E  \", \"F  \", \"F# \", \"G  \", \"Ab \", \"A  \", \"Bb \", \"B  \"];\ninversion.do({arg eachInv;\n\tvar trans;\n\ttrans = (row + eachInv); \n\t// prints just pitch class\n\ttrans.do({arg scaleDegree; pitchClass.wrapAt(scaleDegree).post});\n\t//\"\".postln; // uncomment these line if you want to do both\n\t// prints just numbers\n\t//trans.do({arg scaleDegree; (scaleDegree%12).post; \" \".post});\n\t\"\".postln;\n\t});\n\"\".postln\n)\n\n/////////////\n\n{LFNoise1.ar(5000)}.plot // random wave \n\n{max(0, LFNoise1.ar(5000))}.plot // return only positive values\n\n(\n{\nvar ampCont;\nampCont = max(0, LFNoise1.kr(12)); // slow it down for LFO control\nSinOsc.ar(440, mul: ampCont)\n}.scope\n)\n\n/////////////",
    "Figure 55": "Figure 1.15 Example of additive synthesis\n\n// Mix down a few of them tuned to harmonics:\n\n(\n{\nvar fund = 220;\nMix.ar(\n\t[\n\tSinOsc.ar(220, mul: max(0, LFNoise1.kr(12))),\n\tSinOsc.ar(440, mul: max(0, LFNoise1.kr(12)))*1/2,\n\tSinOsc.ar(660, mul: max(0, LFNoise1.kr(12)))*1/3,\n\tSinOsc.ar(880, mul: max(0, LFNoise1.kr(12)))*1/4,\n\tSinOsc.ar(1110, mul: max(0, LFNoise1.kr(12)))*1/5,\n\tSinOsc.ar(1320, mul: max(0, LFNoise1.kr(12)))*1/6\n\t]\n)*0.3\n}.play\n)\n\n/////////////",
    "Figure 56": "Figure 1.16 Example of additive synthesis\n\n// Try this first\nArray.fill(20, {arg cnt; cnt + 1*110}); // harmonics built on 440\n\n// And a patch\n(\n{Mix.ar(\n\tArray.fill(12, \n\t\t{arg count; \n\t\tvar harm;\n\t\tharm = count + 1 * 110; // remember precedence; count + 1, then * 110\n\t\t\tSinOsc.ar(harm, \n\t\t\t\tmul: max([0, 0], SinOsc.kr(count+1/4))\n\t\t\t\t)*1/(count+1)\n\t\t})\n)*0.7}.play\n)\n\n/////////////",
    "Figure 57": "Figure 1.18 Physically modeled bells. \n\n// Try this first, to illustrate the array of arrays.\n\nArray.fill(3, {Array.fill(10, {rand(1000)})})\t\n// Then this patch.\n(\n{\nvar scale, specs, freqs, amps, rings, \n\tnumRes = 5, bells = 20, pan; \nscale = [60, 62, 64, 67, 69].midicps;\n\tMix.fill(bells, {\n\t\tfreqs = Array.fill(numRes, {rrand(1, 15)*(scale.choose)});\n\t\tamps = Array.fill(numRes, {rrand(0.3, 0.9)});\n\t\trings = Array.fill(numRes, {rrand(1.0, 4.0)});\n\t\tspecs = [freqs, amps, rings].round(0.01);\n\t\t// specs.postln;\n\t\tpan = (LFNoise1.kr(rrand(3, 6))*2).softclip;\n\t\tPan2.ar( \n\t\t\tKlank.ar(`specs, \n\t\t\t\tDust.ar(1/6, 0.03)), \n\t\t\t\tpan)\n\t})\n}.play;\n) \n\n/////////////",
    "Figure 58": "Figure 1.19 Generative sequences using arrays\n\n( // first define the synth\n\nSynthDef.new(\"SimpleBlip\", { \narg midi = 60, tone = 10, art = 0.125, amp = 0.2, pan = -1;\nvar out, temper;\t\nout =\tPan2.ar(\n\t\t\tBlip.ar( // play the sequence\n\t\t\t\tmidi.midicps,\n\t\t\t\ttone\n\t\t\t\t) * EnvGen.kr(Env.perc(0.01, art)),\n\t\tpan // pan left, center, or right\n\t);\nDetectSilence.ar(out, doneAction:2);\namp = amp - ((midi - 60) * 0.02);\nOut.ar(0, out*amp)\n\t}).add;\n)\n\n/////////////\n \n(\n// Then run this Task\n~inst = [0, 0, 0]; // Three containers for tasks\n~pSeq = [0, 0, 0]; // Three containers for sequences\n~scaleAdd = [4, 5, 11, nil, 10, 3, 6, nil]; // \n~notes = \n[\" C\", \" C#\", \" D\", \" Eb\", \" E\", \" F\", \n\t\" F#\", \" G\", \" Ab\", \" A\", \" Bb\", \" B\"]; \n~rout = Task({\n\tinf.do({\n\t\targ cnt1; \n\t\tvar steps, durSeq, harmSeq;\n\t\tsteps = rrand(6, 12);\n\t\tif(cnt1%6 == 0, // every sixth iteration, add a degree\n\t\t\t{~scale = ~scale.add(~scaleAdd.wrapAt((cnt1/6).round(1) - 1));}); \n\t\t\"\\nIteration: \".post; cnt1.post; \n\t\t[\" (center) \", \" (right) \", \" (left) \"].wrapAt(cnt1).postln;\n\t\tif(cnt1%24 == 0, // reset all three\n\t\t\t{~scale = [0, 2, 7, 9]; \n\t\t\t3.do({arg cnt2; \n\t\t\t\t~pSeq.wrapPut(cnt2, \n\t\t\t\t\tArray.fill(steps, \n\t\t\t\t\t\t{~scale.choose + [48, 60].choose}))})});\n\t\t\"scale: \".post; ~scale.postln;\n\t\t~pSeq.wrapPut(cnt1, // fill array with scale steps\n\t\t\tArray.fill(steps, {~scale.choose + [48, 60].choose}));\n\t\t\"MIDI seq: \".post; (~pSeq.wrapAt(cnt1)%12).postln;\n\t\t\"Sequence (notes): \".post; \n\t\t~pSeq.wrapAt(cnt1).do( // print the sequence using note names\n\t\t\t{arg thisItem; ~notes.at(thisItem%12).post}); \n\t\t\"\".postln;\n\t\t// create harmonic and duration arrays\n\t\tharmSeq = Array.fill(steps, {rrand(1.0, 5.0)});\n\t\tdurSeq = Array.fill(steps - 1, {rrand(0.01, 0.9)});\n\t\t// stop the previous task at this array position\n\t\t~inst.wrapAt(cnt1).stop;\n\t\t~inst.wrapPut(cnt1, \n\t\t\tTask({\n\t\t\t\tinf.do({arg cnt3; // each sequence\n\t\t\t\t\tSynth(\"SimpleBlip\", \n\t\t\t\t\t\t[\\midi, ~pSeq.wrapAt(cnt1).wrapAt(cnt3), \n\t\t\t\t\t\t\\tone, harmSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\art, durSeq.wrapAt(cnt3), \n\t\t\t\t\t\t\\amp, rrand(0.1, 0.3), \n\t\t\t\t\t\t\\pan, cnt1.wrap(-1, 2)]);\n\t\t\t\t\t0.125.wait; // tempo of each note\n\t\t\t\t})}).start;\n\t\t);\n\t\t12.wait;})\n}).start; // time between each new sequence\n)\n\n~rout.stop; // stop new sequences\n\n~inst.at(0).free; // at any time, stop center sequence\n\n~inst.at(1).free; // stop right sequence\n\n~inst.at(2).free; // stop center sequence\n\n/////////////\n\nServer.internal.prepareForRecord; // or Server.local\n\nServer.internal.record;\n\nServer.internal.stopRecording;\n\n// Run these variations before to change file formats.\nServer.internal.recSampleFormat = \"int16\"; // change format\n\nServer.internal.recChannels = 1; // change from the default stereo\n// saves file in the SC folder, will be overwritten if repeated\n\nServer.internal.prepareForRecord(\"myAudio.aif\"); \n\n/////////////",
    "Figure 59": "Figure 1.20 Offset and scale\n\n(\n\t{\n\tvar trigger, wave, label, scale, offset;\n\ttrigger = Impulse.kr(10);\n\twave = SinOsc.kr(1/10) ; // change to 400\n\tscale = 1; offset = 0;\n//\twave = wave * scale + offset; \n\tlabel = \"scale = \" ++ scale.asString ++ \", offset = \" ++ offset.asString;\n\twave.round(0.01).poll(label: label);\n\t}.scope(1)\n)\n\n/////////////",
    "Figure 60": "Figure 1.21 SinOsc offset and scaled for control\n\n(\n\t{\n\tvar trigger, control, scale, offset;\n\tscale = 300; // try other values, but not greater than offset\n\toffset = 600; // try other values\n\ttrigger = Impulse.kr(10);\n\tcontrol = SinOsc.ar(1/4).scope(\"control\"); // LFO\n\tcontrol = control  * scale + offset;\n\tSinOsc.ar(freq: abs(control).poll).scope(\"audio\")\n\t}.play\n) \n\n// Speaking of vibrato, I can't resist this faux Theremin. Play it with the Mouse: \n\n{SinOsc.ar(SinOsc.ar(8, 0, 10, MouseX.kr(400, 1000, 1)))}.play\n\n/////////////",
    "Figure 61": "Figure 1.22 Test you skills on a patch\n\n(\n{\n\tvar carrier, rate, trigger, modRatio, index, control, env;\n\trate = 3;\n\ttrigger = Impulse.kr(rate);\n\tcontrol = LFNoise0.kr(rate);\n\tcarrier = 62;\n\tmodRatio = 4.125;\n\tindex = 10;\n\tcarrier = carrier.midicps;\n\tcarrier.poll(trigger, \"carrier\"); \n\tindex.poll(trigger, \"index\"); \n\tmodRatio.poll(trigger, \"modRatio\");\n\tPMOsc.ar(carrier, carrier*modRatio, index)\n}.play\n)\n\n/////////////",
    "Figure 62": "Figure 1.23 PMOsc with offset and scale. \n\n(\na = SynthDef(\"PMOsc_ex\", \n{\n\targ left = 10, right = 10, indexLow = 4, indexHigh = 12;\n\tvar pitch, timbre, trigger, env, index, out;\n\ttrigger = Impulse.kr([left, right]); // trigger\n\tpitch = TRand.kr(36, 72, trigger).round(1); // C2 to C6\n\ttimbre = LFNoise0.kr(1/20, mul: 0.2, add: 2); // mod control\n\tenv = Linen.kr(trigger, releaseTime: 1/[left, right]); // envelope\n\tindex = env * indexHigh + indexLow; // env scaled and offset for index\n\tpitch = pitch.midicps; // midi converted to freq\n\tout = PMOsc.ar(pitch, pitch*timbre, index, mul: env);\n\tOut.ar(0, out);\n}).play\n)\n\na.set(\"left\", 4)\n\na.set(\"right\", 5)\n\na.set(\"indexLow\", 1)\n\na.set(\"indexHigh\", 4)\n\n/////////////",
    "Figure 63": "Figure 1.24 PMOsc with sample and hold (latch).\n\n(\n// run this first\na = SynthDef(\"Latch_demo\",\n{\narg rate = 9; \nvar freq, latchrate, index, ratio, env, out;\nlatchrate = rate*LFNoise0.kr(1/10, mul: 0.03, add: 1.6);\nindex = Latch.kr(\n\tLFSaw.kr(latchrate, mul: 5, add: 6),\n\tImpulse.kr(rate)\n\t);\nfreq = Latch.kr(\n\tLFSaw.kr(latchrate, \n\tmul: max(0, LFNoise1.kr(1/5, mul: 24, add: 10)), \n\tadd: LFNoise0.kr(1/7, mul: 12, add: 60)),\n\tImpulse.kr(rate)\n\t).round(1).midicps;\n\nratio = LFNoise1.kr(1/10, mul: 2.0, add: 5.0);\n\nenv = EnvGen.kr(\n\tEnv.perc(0, LFNoise0.kr(rate, mul: 1, add: 1.5)/rate), \n\tImpulse.kr(rate), \n\tLFNoise1.kr([5, 5], 2, 1).max(0).min(0.8));\nout = PMOsc.ar(\n\t[freq, freq * 1.5],\n\tfreq*ratio,\n\tindex,\n\tmul: env\n);\nOut.ar(0, out);\n}\n).play\n)\n\na.set(\"rate\", 10)\n\na.set(\"rate\", 15)\n\na.set(\"rate\", 6)\n\na.free;\n\n/////////////",
    "Figure 64": "Figure 1.25 It's just a bell.\n\n(\n{ // it's just a bell\nvar burst, burstEnv, bell, delay, dry, \nburstFreq = 500, freqs, amps, rings;\nburstEnv = EnvGen.kr(Env.parc(0, 0.05),\n\t\t\t\tDust.kr(1/5), 0.1);\n// burstEnv.poll(100, \"env\");\nburst = SinOsc.ar(freq: burstFreq,\n\tmul: burstEnv);\n// burst.poll(100, \"burst\");\nfreqs = Array.fill(10, {exprand(100, 1000)});\namps = Array.fill(10, {rrand(0.01, 0.1)});\nrings = Array.fill(10, {rrand(1.0, 6.0)});\n// [freqs, amps, rings].round(0.01).postln;\n// \"safe\" values\n// freqs = [100, 200, 300, 400];\n// amps = [1, 1, 1, 1];\n// rings = [1, 1, 1, 1];\n\nbell = Pan2.ar(\n\tKlank.ar(`[freqs, amps, rings], burst), \n\trrand(-1.0, 1.0)\n);\n\ndelay = AllpassN.ar(bell, 2.5, \n\t[LFNoise1.kr(7, 1.5, 1.6), LFNoise1.kr(7, 1.5, 1.6)], \n\t1, mul: 0.8);\nbell \n+ delay\n// + SinOsc.ar(mul: LFPulse.kr(1) * 0.05);\n}.play\n)",
    "Figure 65": "Figure 10.1\n// boot the sound synthesis server and prepare a SynthDef for buffer playback\n(\ns.waitForBoot({\n    SynthDef( \\bufPlay, { arg buf, amp = 1.0, speed = 1.0;\n        Out.ar( 0, Pan2.ar( PlayBuf.ar( 1, buf, speed * BufRateScale.kr( buf ), loop: 1 ) * amp ));\n    }).send( s );\n    ~buf = Buffer.read( s, \"sounds/a11wlk01.wav\" );\n});\n)\n\n// now replace the action function\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf ]);\n    }, {\n        ~node.free; ~node = nil;\n    })\n};\n)\n\n////////",
    "Figure 66": "Figure 10.2\n~amp   = 0.5;  // initial amplitude\n~speed = 1.0;  // initial speed (1.0 is normal, 0.5 is half-speed, etc.)\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf, \\amp, ~amp, \\speed, ~speed ]);\n    }, {\n        ~node.free; ~node = nil;\n    })};\n)\n~win.setInnerExtent( 360, 72 );  // more suitable dimensions for the window\n~win.resizable = false;\nJSCStaticText( ~win, Rect( 56, 4, 50, 25 )).align_( \\right ).string_( \"Amp:\" );\n(\n~ampSlider = JSCSlider( ~win, Rect( 110, 4, 200, 25 ))\n    .value_( ~amp ) // initial slider position\n    .action_({ arg view;\n        ~amp = view.value;\n        ~node.set( \\amp, ~amp );\n    });\n)\nJSCStaticText( ~win, Rect( 56, 32, 50, 25 )).align_( \\right ).string_( \"Speed:\" );\n~speedSpec = ControlSpec( 1/8, 8, \\exp );\n(\n~speedSlider = JSCSlider( ~win, Rect( 110, 32, 200, 25 ))\n    .value_( ~speedSpec.unmap( ~speed ))  // initial slider position\n    .action_({ arg view;\n        ~speed = ~speedSpec.map( view.value );\n        ~node.set( \\speed, ~speed );\n    });\n)\n\n//////// alternative verbose version\n// this is an alternative variant that should not be executed:\n~label = JSCStaticText( ~win, Rect( 56, 4, 50, 25 ));\n~label.align = \\right;\n~label.string = \"Amp:\";\n\n//////// remove the variant if you accidentally executed its code\n~label.remove;\n\n// --------\n// -------- SECTION 4 - USING THE MODEL-VIEW-CONTROLLER PATTERN --------\n// --------\n\n////////",
    "Figure 67": "Figure 10.4\n~node.free; ~node = nil;\n\n(\n~model        = Event.new;\n~model.amp    = ~amp;\n~model.speed  = ~speed;\n~model.node   = ~node;\n~model.buf    = ~buf;\n~model.adjust = { arg mod, key, value, source;\n    mod.put( key, value );\n    mod.changed( key, value, source )};\n\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\amp, value )}, \\amp );\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\speed, value )}, \\speed );\n\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~model.node = Synth( \\bufPlay, [\n            \\buf, ~model.buf, \\amp, ~model.amp, \\speed, ~model.speed ]);\n    }, {\n        ~model.node.free; ~model.node = nil;\n    })};\n~ampSlider.action   = { arg view;\n    ~model.adjust( \\amp, view.value, view )};\n~speedSlider.action = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( view.value ), view )};\n)\n\n////////",
    "Figure 68": "Figure 10.5\n(\n~ampText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 4, 50, 25 ));\n~ampTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~ampText.string = \"% dB\".format( value.ampdb.round( 0.1 ))}, \\amp );\n~speedText = JSCStaticText( ~win, Rect( ~speedSlider.bounds.right + 2, 32, 50, 25 ));\n~speedTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~speedText.string = \"%\\\\%\".format( (value * 100).round( 0.1 ))}, \\speed );\n)\n// note: the sliders must be initially dragged to cause view updates!\n\n//////// algorithmic controller\n(\n~ctrlFunc = { 60.do({\n\t~model.adjust( \\speed, exprand( 1/8, 8 ), thisFunction );\n\t0.1.wait })};\n)\n~ctrlFunc.fork;\t// run as a Routine\n\n////////",
    "Figure 69": "Figure 10.7\n(\n~ampSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~ampSlider, {\n        ~ampSlider.value = value;\n    })}, \\amp );\n~speedSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~speedSlider, {\n        ~speedSlider.value = ~speedSpec.unmap( value );\n    })}, \\speed );\n)\n\n//////// remove observers when views close\n~ampSlider.onClose   = { ~ampSliderUpd.remove };\n~speedSlider.onClose = { ~speedSliderUpd.remove };\n~ampText.onClose     = { ~ampTextUpd.remove };\n~speedText.onClose   = { ~speedTextUpd.remove };\n\n//////// MVC is complete\n~ctrlFunc.fork;\n\n// --------\n// -------- SECTION 5 - UNDER THE HOOD - THE INNER WORKINGS OF SWINGSOSC --------\n// --------\n\n// --------\n// -------- SECTION 6 - RESPONDERS AND ASYNCHRONICITY --------\n// --------\n\n//////// seeing which messages are sent by the responders back to the client\ng.dumpOSC( 0, 1 );\n// if the \"/info\" messages are bothering, stop alive-thread\ng.stopAliveThread;\n// turning it off again\ng.dumpOSC( 0, 0 );\n\n//////// wait requires code to be run inside a Routine\n2.wait; \"hello\".postln;           // not allowed! (\"yield was called outside of a Routine.\")\nfork { 2.wait; \"hello\".postln };  // ok!\n\n// --------\n// -------- SECTION 7 - EXTENDING THE GUI REPERTOIRE USING JSCUSERVIEW --------\n// --------\n\n//////// removing the standard speed JSCSlider\n~speedSlider.remove;\n\n////////",
    "Figure 70": "Figure 10.13\n(\n~mySlider            = Event.new;\n~mySlider.view       = JSCUserView( ~win, Rect( 110, 32, 200, 145 )).focusVisible_( false );\n~mySlider.pos        = ~speedSpec.unmap( ~model.speed );\n// these will be used in the final draw func:\n~mySlider.pressed    = false;\n~mySlider.project    = false;\n// this will update the slider position and refresh the view:\n~mySlider.adjustPos  = { arg slid, pos;\n    slid.pos         = pos;\n    slid.view.action.value( slid );\n    slid.view.refresh };\n// these will set the slider track curve and refresh the view:\n~mySlider.adjustCurve= { arg slid, curve;\n    slid.curve       = curve;\n    slid.lines       = curve.slide( 2, 1 ).clump( 2 );\n    slid.lineLens    = slid.lines.collect({ arg pair; pair[ 0 ].dist( pair[ 1 ])}).normalizeSum; \n    slid.projections = nil;\n    slid.view.refresh };\n// a primary draw function just to indicate the view's bounds:\n~mySlider.view.drawFunc = { arg view; var b = view.bounds;\n    JPen.line( 0 @ 0, b.width @ b.height );\n    JPen.line( 0 @ b.height, b.width @\u00ca0 );\n    JPen.stroke };\n// make the window a little bigger:\n~win.setInnerExtent( 370, 180 );\n)\n\n////////",
    "Figure 71": "Figure 10.14\n(\n~mySlider.adjustCurve([ 0 @ 0, 0.25 @ 1, 0.5 @ 0, 1.0 @ 0.5 ]);\n~mySlider.view.drawFunc = { arg view;\n    var b, scale, lnP1, lnP2, linePos, proj, inner, sum = 0;\n    b     = view.bounds;\n    // scaling factor for coordinates normalized to 0...1\n    scale = b.width @ b.height;\n    // set the initial curve coordinate\n    JPen.moveTo( ~mySlider.curve[ 0 ] * scale );\n    (1..(~mySlider.curve.size-1)).do({ arg i;\n        // create the curve by adding successive line segments\n        JPen.lineTo( ~mySlider.curve[ i ] * scale );\n    });\n    // stroke the curve with a 2-pixel wide black pen\n    JPen.width = 2;\n    JPen.color = Color.black;\n    JPen.stroke;\n    // draw the knob: iterate over the line segments until\n    // the one is found inside which the knob (read from ~mySlider.pos)\n    // is located.\n    block { arg break;\n        ~mySlider.lineLens.do({ arg len, i;\n            // if we have found the line segment...\n            if( sum + len >= ~mySlider.pos, {\n                // calucate the point inside this segment\n                // (proj) and draw a filled circle around it\n                #lnP1, lnP2    = ~mySlider.lines[ i ];\n                linePos        = (~mySlider.pos - sum) / len;\n                proj           = lnP1 + ((lnP2 - lnP1) * linePos);\n                JPen.fillOval( Rect.aboutPoint( proj * scale, 8, 8 ));\n                // if this view is focused, use blue color, otherwise grey\n                JPen.fillColor = Color.hsv( 0.7, view.hasFocus.if( 0.7, 0.0 ), 1.0 );\n                // if the mouse is pressed, the outline should be thicker\n                inner          = if( ~mySlider.pressed, 5, 7 );\n                JPen.fillOval( Rect.aboutPoint( proj * scale, inner, inner ));\n                break.value;\n            });\n            sum = sum + len;\n        });\n    };\n    \n    // a debugging utility to visualize the point projections\n    // of the mouse dragging\n    if( ~mySlider.project, {\n        ~mySlider.projections.do({ arg pt;\n            pt = pt * scale;\n            JPen.line( pt + (-5 @ -5), pt + (5 @  5) );\n            JPen.line( pt + (-5 @  5), pt + (5 @ -5) );\n        });\n        JPen.width = 1; JPen.stroke;\n    });\n};\n)\n\n////////",
    "Figure 72": "Figure 10.15\n(\nvar mouseFunc = { arg view, x, y, modifiers, buttonNumber, clickCount;\n    var b, nx, ny, dx, dy, lnP1, lnP2, linePos, lineLenSq,\n        proj, dist, sum = 0, minDist = inf, newValue;\n    \n    b  = view.bounds;\n    nx = x / b.width;\n    ny = y / b.height;\n    ~mySlider.projections = Array( ~mySlider.lines.size );\n    // look up the line segment which is closest to the mouse\n    ~mySlider.lines.do({ arg pair, i;\n        #lnP1, lnP2 = pair;\n        dx          = lnP2.x - lnP1.x;\n        dy          = lnP2.y - lnP1.y;\n        lineLenSq   = (dx*dx) + (dy*dy);\n        dist        = (((nx - lnP1.x) * dx) + ((ny - lnP1.y) * dy)) / lineLenSq;\n        proj        = (lnP1.x + (dist * dx)) @ (lnP1.y + (dist * dy));\n        if( lnP1.x != lnP2.x, {\n            linePos = (proj.x - lnP1.x) / dx;\n        }, {\n            linePos = (proj.y - lnP1.y) / dy;\n        });\n        if( linePos < 0, {\n            proj = lnP1;\n        }, { if( linePos > 1, {\n            proj = lnP2;\n        })});\n        ~mySlider.projections.add( proj );\n        dist = proj.dist( nx @ ny );\n        if( dist < minDist, {\n            newValue = sum + (linePos.clip( 0, 1 ) * ~mySlider.lineLens[i]);\n            minDist  = dist;\n        });\n        sum = sum + ~mySlider.lineLens[ i ];\n    });\n    ~mySlider.pressed = true;\n    ~mySlider.adjustPos( newValue );\n};\n~mySlider.view.mouseDownAction = mouseFunc;\n~mySlider.view.mouseMoveAction = mouseFunc;\n~mySlider.view.mouseUpAction   = { arg view; ~mySlider.pressed = false; view.refresh };\n~mySlider.view.action          = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( ~mySlider.pos ), ~mySlider )};\n)\n\n//////// making the point projections visible\n~mySlider.project = true; ~mySlider.view.refresh;\n\n//////// using a more elaborate curve\n(\n~mySlider.adjustCurve( Array.fill( 20, { arg i;\n    Polar( (i + 1) / 40, i / 19 * 4pi ).asPoint + (0.5 @ 0.5) }));\n)\n\n//////// adding keyboard control\n(\n~mySlider.view.keyDownAction = { arg view, char, modifiers, unicode, keycode;\n    switch( keycode, 37, {   // decrease slider-value with cursor-left\n        ~mySlider.adjustPos( (~mySlider.pos - 0.05).max( 0.0 ))},\n    39, {   // increase slider-value with cursor-right\n        ~mySlider.adjustPos( (~mySlider.pos + 0.05).min( 1.0 ))})};\n)\n\n// --------\n// -------- SECTION 8 - GENERIC JAVA SCRIPTING --------\n// --------\n\n//////// making incoming and outgoing OSC-messages visible\ng.dumpOSC( 1, 1 );\n\n//////// instantiating a JFrame and operating on it\n~frame = JavaObject( \"javax.swing.JFrame\", nil, \"Test\" );\n~frame.setSize( 400, 400 );\n~frame.setVisible( true );\n\n//////// adding a file chooser to the frame\n~cp          = ~frame.getContentPane__;\n~fileChooser = JavaObject( \"javax.swing.JFileChooser\" );\n~cp.add( ~fileChooser );\n~cp.revalidate;\n\n//////// receiving a primitive value from the server\nfork { ~title = ~frame.getTitle_; ~title.postln };\n\n//////// reading the currently selected file's path\n// note that this works only if a file is selected,\n// otherwise an error is printed. we leave out the\n// error handling here for brevity!\n(\nfork { ~file = ~fileChooser.getSelectedFile__;\n       ~fileName = ~file.getAbsolutePath_; ~file.destroy; ~fileName.postln };\n)\n\n////////",
    "Figure 73": "Figure 10.17\n(\n~action = { arg fileName; \"Selected file is '%'\\n\".postf( fileName )};\n~sResp  = JavaObject( \"de.sciss.swingosc.ActionResponder\", nil, ~fileChooser.id );\n~cResp  = OSCpathResponder( g.addr, [ '/action', ~fileChooser.id ], {\n    fork { var file, fileName;\n        file     = ~fileChooser.getSelectedFile__;\n        fileName = file.getAbsolutePath_;\n        file.destroy;\n        ~action.value( fileName.asString );\n    };\n}).add;\n)\n\n//////// turn off OSC-dumping\ng.dumpOSC( 0, 0 );\n\n// --------\n// -------- SECTION 9 - EMBEDDING ARBITRARY SWING VIEWS IN A JSCWINDOW --------\n// --------\n\n////////",
    "Figure 74": "Figure 10.18\n(\n~cp.remove( ~fileChooser );\n~frame.dispose;\n~cp.destroy; ~frame.destroy;\n~win.setInnerExtent( 760, 340 );   // again a bit bigger\n~plug = JSCPlugView( ~win, Rect( 370, 2, 386, 336 ), ~fileChooser );\n~action = { arg fileName; var sf, oldBuf;\n    // try to open as a sound file. returns nil if it could not be opened\n    if( (sf = SoundFile.openRead( fileName )).notNil, {\n        sf.close;  // the header info was read, we can close the file\n        if( sf.numChannels == 1, {  // allow mono files only\n            oldBuf = ~model.buf;\n            if( ~model.node.notNil, {  // free old buffer when synth is freed\n                UpdateListener.newFor( ~model.node, { arg upd;\n                    upd.remove; oldBuf.free }, \\n_end );\n                ~model.node.register;\n            }, {\n                oldBuf.free;\n            });\n            ~model.buf = Buffer.read( s, fileName );  // replace buffer\n        }, {\n            \"Sound file must be mono\".error;\n        });\n    });\n};\n)\n\n// --------\n// -------- SECTION 10 - USING CUSTOM JAVA CLASSES --------\n// --------\n\n// SoundFileChooser.java and JSCSoundFileChooser.sc are contained in separate files!\n\n//////// add the SoundFileChooser.jar to the classpath\ng.addClasses( \"file://<javaSourceCodePath>/SoundFileChooser.jar\" );   // replace <javaSourceCodePath> here!\n\n////////",
    "Figure 75": "Figure 10.21\n(\n~plug.remove;\t// this implicitly calls ~fileChooser.destroy!\n~soundChooser        = JSCSoundFileChooser( ~win, Rect( 370, 2, 386, 306 ));\n~soundChooser.path   = \"sounds/a11wlk01.wav\".absolutePath;\n~loadButton          = JSCButton( ~win, Rect( 370, 312, 60, 24 )).states_([[ \"Load\" ]]).enabled_( false );\n~infoText            = JSCStaticText( ~win, Rect( 438, 312, 318, 24 ));\n~soundChooser.action = { arg view; var enabled = false, info = \"\", sf;\n    if( view.path.notNil and: { (sf = SoundFile.openRead( view.path )).notNil }, {\n        sf.close;\n        enabled         = sf.numChannels == 1;\n        info            = \"% audio, %-chan. % % kHz, %\".format( sf.headerFormat, sf.numChannels, sf.sampleFormat, sf.sampleRate/1000, (sf.numFrames/sf.sampleRate).asTimeString );\n    });\n    ~loadButton.enabled = enabled;\n    ~infoText.string    = info;\n};\n~loadButton.action   = { ~action.value( ~soundChooser.path )};\n)\n\n////////",
    "Figure 76": "Figure 10.22\n(\n~ampSlider.resize     = 2;\n~mySlider.view.resize = 5;\n~ampText.resize       = 3;\n~speedText.resize     = 3;\n~soundChooser.resize  = 6;\n~loadButton.resize    = 9;\n~infoText.resize      = 9;\n~win.resizable        = true;\n)",
    "Figure 77": "Figure 12.3\n//\n// select the following lines and type C-c C-x\n// stop synthesis with C-c C-s\n\n{\n\tvar trem = LFTri.kr(3).range(-12.dbamp, 0.dbamp);\n\tSinOsc.ar(\n\t\t{ rrand(60, 80).midicps } ! 6,\n\t\tmul: -10.dbamp * trem\n\t).clump(2).sum\n}.play\n\n\n//",
    "Figure 78": "Figure 12.4\n//\n// evaluate the following lines by double-clicking on the\n// first paranthesis when `transient-mark-mode' is enabled\n// and pressing C-c C-c\n\n(\nx = {\n\tSaw.ar(\n\t\tXLine.kr(20, [400,403,407], 20),\n\t\tmul: 0.7\n\t).clump(2).sum\n}.play; \"scel\";\n)\n\n// evaluate this line by pressing C-c C-c\nx.free; \"rocks\";",
    "Figure 79": "Figure 12.1\n\nif (thisProcess.argv.isEmpty) {\n\t\"Missing arguments!\".postln;\n\texit(1);\n};\n\nthisProcess.argv.do { | x, i |\n\t\"% : %\\n\".postf(i, x);\n};\n\nexit(0);",
    "Figure 80": "figure sonif 19 - Sound design for a single country\n(\n~single = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, attack=0.00, decay = 1.0, \n\tdens = 2, amp=0.2, x=1, y = 0, step=0.33333| \n\t\n\tvar numChans = 4; \n\t\n\tvar freqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\tvar exciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07) // five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \t\t\t\t\t// slightly filtered\n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude comp for dust density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// some fused background noise\n\t\t\t* (decay ** -0.5);\t\t\t\t\t// amplitude comp. for decay\n\t\t\t\t\n\tvar resonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\tvar pos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (pi.reciprocal) + 1; // look west.\n\t\n\tPanAz.ar(numChans, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n\n~single.play;\n)",
    "Figure 81": "Figure  17.1 \n\n(\n// read a whole sound into memory\ns = Server.local;\nb = Buffer.read(s,\"sounds/a11wlk01.wav\"); // remember to free the buffer later.\n)\n(\nSynthDef(\"help_PlayBuf\", { arg out=0,bufnum=0, rate=1;\nOut.ar(out,\nPan2.ar(\nPlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)*rate, loop: 1),\n0)\n)\n}).send(s,[\\out, 0, \\bufnum, b.bufnum]);\n)\np=Synth(\\help_PlayBuf, [\\rate, 0.midiratio]); // original pitch\np.set(\\rate, 12.midiratio);\t// one octave up\np.set(\\rate, 7.midiratio);\t// seven semitones up (fifth interval)\n\nb.free;\nb=nil;\np.free;\np=nil;\n//////////////////////////////////////////////////////",
    "Figure 82": "Figure  17.2 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5, 7]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 83": "Figure  17.3 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5.25, 7.5]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 84": "Figure  17.4 \n\n(\nPbind(\n\\note, Pseq([0,2,4,5,7,9,11,12], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 85": "Figure  17.5 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 86": "Figure  17.6 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5,\n\\scale, (0..11)\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 87": "Figure  17.7 \n\n(\nPbind(\n\\degree, Pseq([0, 2, 2.1, 2.05], inf),\n\\dur, 0.3,\n\\scale, (0..11),\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 88": "Figure  17.8 \n\n(\nPbind(\n\\note, Pwhite(-6,9),\n\\dur, 0.3,\n\\sustain, 1.1,\n\\stepsPerOctave, 7\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 89": "Figure  17.9 \n(\ne=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 4, 8, 11, 14, 17]\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 90": "Figure  17.10 \n\n(\n// previous example should still be running\ne.stream=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 3, 5, 8, 10, 13]\n).asStream;\n)\n//////////////////////////////////////////////////////",
    "Figure 91": "Figure  17.11 \n\n(\nvar stepsperoctave=3;\nArray.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\n)\n\nUsing a function to calculate the value at a chosen degree\n(\nf = {|degree, steps|\n2.pow(degree/steps)\n};\n)\n// \tdegree 0\nf.(0, 3);\n// \tdegree 1\nf.(1, 3);\n// \tdegree 2\nf.(2, 3);\n\nThe function is modified to multiply the value by a root frequency in Hertz\n(\nf = {|degree, steps, root=440|\n2.pow(degree/steps)*root\n};\n)\n//\t12 notes per octave, degrees 0,1 and 12\nf.(0,12)\nf.(1, 12)\nf.(12, 12)\n\n//\t14 notes per octave, degrees 0,1, 12 and 14\nf.(0,14)\nf.(1, 14)\nf.(12, 14)\nf.(14,14)\n//////////////////////////////////////////////////////",
    "Figure 92": "Figure 17.12 \n\n(\nSynthDef(\"tone2\", { arg freq = 440, amp=0.5, gate=1, envdur=1.5;\nvar sound, env;\nenv = EnvGen.kr(Env.perc(0.01, envdur), doneAction:2);\nsound = Pan2.ar(SinOsc.ar(freq, 0, amp)*env, 0);\nOut.ar(0, sound);\n}).load(s);\n)\n(\na=[ 1, 1.030303030303, 1.0606060606061, 1.1212121212121, 1.3636363636364, 1.6060606060606, 2 ]*220;\n\n// Play the all the notes of the tuning\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).play\n)\n// Choose the notes randomly\n(\ne.stream=Pbind(\n\\freq, Pn(Prand( a, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 93": "Figure 17.13 \n\n(\n~rationames=[1/1, 8/7, 7/6, 6/5, 5/4, 4/3, 7/5, 10/7, 3/2, 8/5, 5/3, 12/7, 7/4];\n~scale=[0,3,5,8,10,12];\ne = Pbind(\n\\freq, Pseq([\nPfunc({\n(~rationames.wrapAt(~scale).[~scale.size.rand])*440\n})\n],inf),\n\\dur, 0.25,\n\\amp, 0.5,\n\\instrument, \\tone2\n).play; // returns an EventStream\n)\n// set a new scale\n~scale=[0,2,5,7,9,11];\n~scale=[0,1,3,5,6,8,9];\n~scale=[0,3,5,8,10,12];\n//////////////////////////////////////////////////////",
    "Figure 94": "Figure 17.14 \n\n(\nvar n, buts, synths, ratios, rationames;\nw = SCWindow(\"tonality diamond\", Rect(200,500,420,150));\nw.view.decorator = FlowLayout(w.view.bounds);\n\nrationames=[\n\"7/4\", \"3/2\",\"5/4\",\"1/1\",\n\"7/5\",\"6/5\",\"1/1\",\"8/5\",\n\"7/6\",\"1/1\",\"5/3\",\"4/3\",\n\"1/1\",\"12/7\",\"10/7\",\"8/7\"\n];\n\nn=rationames.size;\n\nn.do({ |i|\nSCButton(w, Rect(20,20+(i*30),100,30))\n.states_([[rationames[i], Color.black, \nif((rationames[i])==\"1/1\", {Color.red},{Color.yellow})\n]\n])\n.action_({ arg butt;\nSynth(\\tone2, [\\freq, ((rationames[i]).interpret)*440]);\n\n})\n});\nw.front;\n)\n//////////////////////////////////////////////////////",
    "Figure 95": "Figure 17.16 \n\n(\na=Pbind(\n\\degree, Pwhite(0, 12),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pwhite(0, 14),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 96": "Figure 17.17 \n\n(\na=Pbind(\n\\degree, Pfunc({\n[\n[0, 6, 12].choose, 12.rand\n].choose;\n}),\n\\dur, 0.5,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pfunc({\n[\n[0, 7, 14].choose, 14.rand\n].choose;\n}),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.3,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 97": "Figure 17.18 \n\n(\n~tolerance={|a, b, t, max|\nvar c, d;\nc=[];\nd=[];\na.do({ |aitem, aindex|\nb.do({ |bitem, bindex|\nvar x;\nx = (aitem-bitem).abs;\nif( (x > t) && (x < max),\n{\nc=c.add(aindex);\nd=d.add(bindex);\n//[aitem, bitem].post; \" out of tune \".post; [aindex, bindex].postln;\n//\" \".postln;\n})\n})\n});\n[(0..a.size).difference(c), (0..b.size).difference(d)];\n};\n)\n\n(\n// use the function function with two tunings\nvar mintreshold, maxtreshold, int;\n\n// two different equal tunings expressed linearly\na=Array.fill(12, { |i| (1/12)*(i) });\nb=Array.fill(21, { |i| (1/21)*(i) });\n\nint=1/21;\t\t\t\t// smallest interval\nmintreshold=int*0.15;\nmaxtreshold=int*0.85;\n/*\nintervals inferior to mintreshold are in tune\nintervals between mintreshold and maxtreshold are out of tune\nintervals superior to maxtreshold are in tune\n*/\n\n// print a list of notes from the two tunings which form a dissonant interval\n~tolerance.value(a, b, mintreshold, maxtreshold);\n)\n//////////////////////////////////////////////////////",
    "Figure 98": "Figure 17.19 \n\n(\na=Pbind(\n\\degree, Pfunc({\n// notes which clash with the other tuning have been removed\n[0,4,8,12].choose\n}),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).play;\nb=Pbind(\n// notes which clash with the other tuning have been removed\n\\degree, Pfunc({\n[0,7,14,21].choose\n}),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.35,\n\\sustain, 0.85,\n\\stepsPerOctave, 21,\n\\instrument, \\tone2\n).play;\n)\n\n(\na.stream=Pbind(\n// introducing more notes from that tuning after having changed the threshold\n\\degree, Pfunc({\n[ 0, 1, 4, 7, 8, 9, 9, 12 ].choose\n}),\n\\dur, 0.75,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).asStream;\n)\n//////////////////////////////////////////////////////",
    "Figure 99": "Figure 17.20 \n\n(\nf = {|steps| Array.fill(steps, { |i| 2.pow(i/steps) }) };\n//\tCalculation of the twelve equal-note temperament\nx =  f.(12);\n//\tmapping the tuning to a new range beyond an octave\ny = x.linlin(1, 2, 1, 2.25);\n//\tmultiplying by a root frequency\na=y*440;\n\nPbind(\n\\freq, Pfunc({ a.choose }),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 100": "Figure 17.21 \n\n(\nPbind(\n\\degree, Pwhite(0, 18),\n\\dur, 0.3,\n\\sustain, 1.0,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2,\n\\stepsPerOctave,  18.809\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 101": "Figure 17.22 \n\n(\na=[ 1, 1.09375, 1.1875, 1.28125, 1.375, 1.46875, 1.5625, 1.65625];\nb=a*440;\ne=Pbind(\n\\freq, Pseq( b, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).play\n)\n// play in a different order\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( b, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 102": "Figure 17.23 \n\n(\n// F. Mogini pattern-based Tuning - 2000.\nx=880;\n\nPbind(\n\\freq, Pn(\nPlazy({\nif(x<=150, {x=x*2});\nif(x>=2000, {x=x/2});\nx=[\n\nx*[1.1428,  1.36, 1.26].choose,\nx/[1.1428,  1.36, 1.26].choose\n\n].choose\n})\n),\n\\dur, 0.14,\n\\sustain, 0.8,\n\\cutoff, Pfunc({ 1.0.rand})\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 103": "Figure 17.24 \n\na=(1..16)*100\n(\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2\n).play\n)\n\n// a beautiful tuning system can be created from the harmonic series.\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( a, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 104": "Figure 17.25\n\na=(1..11);\n(\na.size.do({ |i|\nvar x=a[i];\nwhile({x>2},{x=x/2});\na.put(i, x)\n});\n)\n\nb=a.asSet.asArray.sort;\n(\ne=Pbind(\n\\freq, Pn(Pshuf( b*440, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 105": "Figure 17.26 \n\na=(1..8);\nb=(9..16);\n(\na.size.do({ |i|\nvar x=a[i];\nvar y=b[i];\n// harmonics below 8 remain in the first octave\nwhile({x>2},{x=x/2});\n// harmonics above 9 remain in the second octave\nwhile({y>4},{y=y/2});\na.put(i, x);\nb.put(i, y);\n});\n)\na;\nb;\nc=(a++b).asSet.asArray.sort;\nc;\n\n(\ne=Pbind(\n\\freq, Pn(Pshuf( c*200, 1)),\n\\dur, 0.2,\n\\sustain, 1.1\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 106": "Figure 17.27 \n\n(\n// \ta function to expand the tuning from one octave to four octaves\n~harmsfunc={arg stepsperoctave=7;\nvar harms;\n// calculate each note from the tuning\nharms=Array.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\nharms.size.do({ |i|\nif( 0.6.coin, {\n// multiply some of the notes to create higher harmonics\nharms.put(i, (harms[i])*[1,2,4,8].choose )\n})\n});\nharms.sort;\n};\n)\n\n//  create an array of virtual harmonics, seven equal-note temperament\n~harms=~harmsfunc.value(7);\n\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).store;\n)\n\n(\ne=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are rpeated so we can notice the effect of harmonics\n\\degree, Pseq([0,1,2,3,4,5,6,7],inf),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).play;\n)\n\nSend the SynthDef function again to obtain new amplitudes for each harmonic\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).store;\n)\n\n// re-evalute the function to create new harmonics (update the SynthDef afterwards)\n~harms=~harmsfunc.value(7);\nSend the SynthDef function again, as we have done earlier to obtain new amplitudes for each harmonic\n\n// finally playing a random melody to make it less repetitive\n(\ne.stream=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are repeated so we can notice the effect of harmonics\n\\degree,  Pwhite(0, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).asStream;\n)\n// we could develop further and re-write the SynthDef with a partial argument \n// and also change the partials directly from Pbind\n\n//////////////////////////////////////////////////////",
    "Figure 107": "Figure 17.28 \n\n(\nvar w, keys, steps, octaves;\n\nw = SCWindow.new.name=\"Custom keyboard: 7 steps per octave\";\nsteps = 7;\noctaves= 2;\n// seven steps per octave;\na=Array.fill(7, { |i| (1/7)*(i) })+1;\nb= a++(a*2);\n\nc=Synth(\\default, [\\amp, 0]);\n\nkeys=Array.fill(steps*octaves,{ |i|\n\nSCButton(w, Rect(20+(i*22),20,20,50))\n.states_([\nif(i.mod(steps)==0,{\n[i.asString, Color.black, Color.red]},{\n[i.asString, Color.black, Color.yellow]});\n\n])\n.action_({ arg butt;\nc.set(\\freq,b[i]*220, \\amp, 0.25)\n});\n});\n\nw.front;\n)\n//////////////////////////////////////////////////////",
    "Figure 108": "Figure 18.1 */\n/*\nThis example is adapted and extracted from the Non-Realtime Synthesis helpfile itself, accessible from the Main SuperCollider help page.\n*/\n(\nvar f, c, d;\n// open a file for writing raw OSC data to\nf = File(\"~/test.osc\".standardizePath,\"w\");\n// start a sine oscillator at 0.2 seconds.\nc = [ 0.2, [\\s_new, \\default, 1001, 0, 0]];\n// convert the bundle to raw OSC\nd = c.asRawOSC;\nf.write(d.size); // each bundle is preceded by a 32 bit size.\nf.write(d); // write the bundle data.\nf.close;\n)\n/* End",
    "Figure 109": "Figure 18.1 */\n/*",
    "Figure 110": "Figure 18.2 */\ns = Server.local;\ns.boot;\n\n// a sample SynthDef\nSynthDef(\\NRT_beep, {arg freq, dur, amp = 0.1;\n\tvar half;\n\thalf = dur * 0.5;\n\tOut.ar(0, SinOsc.ar(freq, 0, \n\t\tEnvGen.kr(Env.new([0, amp, 0], [half, half], [4, -4]))));\n\t}).load(s);\n\n(\nvar score;\n\n// A Score, created from a note-list of time-stamped events.\nscore = Score.new([\n    [0.0,\n        [\\g_new, 1000],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.0,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [2.0,\n        [\\n_free, 1001, 1000]\n    ],\n\t[2.00001, [0]]\n]);\n\nscore.play(s); // play the Score in real-time...\n\n// ... or render in in Non-Real-Time\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n)\n/* End",
    "Figure 111": "Figure 18.2 */\n/*",
    "Figure 112": "Figure 18.3 */\n(\n//In this example, we use the higher-level server abstraction classes, Group and Synth to handle the\n// node IDs. At least as important though is the use of variables. Now that the relationships are\n// specified rather than the specific values, we can change the gesture dramatically by changing\n// just one or two variables. To transpose everything, we only need to change the value of \n// ~baseNote. To adjust the duration, we only need to change the ~dur variable, and this is now \n// independent of the deltaOn (i.e. independent of the amount of time between the start of one\n// note and the start of the next note).\nvar score;\nvar deltaOn = 0.2;  //amount of time between the start of one note and the start of the next note\nvar dur = 0.4;      //try changing dur to 0.3, 1.4, 3.4, or whatever you like\nvar baseNote = 75;  //transpose the entire fragment up or down\nvar firstPitch  = (baseNote + 0).midicps;  //alter the relationship between any of the pitches\nvar secondPitch = (baseNote - 4).midicps;  // without effecting the others\nvar thirdPitch  = (baseNote + 7).midicps;\n\nscore = Score.new([\n\t[t =  0.0,\n\t\t(g = Group.basicNew(s)).newMsg,\n\t\t//we use environment variables here (identified by the preceding ~) \n\t\t// since we might add or remove events; hence we don't know ahead of \n\t\t// time how many events we have, and therefore how many variables we'll need\n\t\t(~s01 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s01.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s02 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s02.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s03 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t],\n\t[t + dur,\n\t\t~s03.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s04 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s04.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s05 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s05.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s06 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s06.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s07 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s07.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s08 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s08.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s09 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s09.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s10 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s10.freeMsg,\n\t\tg.freeMsg\n\t],\n]\n);\n\nscore.sort;\nscore.play(s);\n)\n/* End",
    "Figure 113": "Figure 18.3 */\n/*",
    "Figure 114": "Figure 18.4 */\n(\nvar score, graingest;\n\n// seed the randomness\nthisThread.randSeed_(123);\n\n// a sample SynthDef\nSynthDef(\\NRT_grain, {arg freq, dur, amp, pan;\n\tOffsetOut.ar(0, Pan2.ar(\n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.ar(Env.sine(dur, amp), doneAction: 2)),\n\t\tpan)\n\t\t);\n\t}).load(s);\n\nscore = Score.new;\n\n// envelope times are scaled to 1.\ngraingest = {arg score, starttime, duration, windur, overlaps, freqenv, ampenv, panenv;\n\tvar ratio, curfreq, curamp, curpan, notestart, now = 0.0, note;\n\twhile({\n\t\tratio = now / duration;\n\t\tcurfreq = freqenv[ratio];\n\t\tcuramp = ampenv[ratio];\n\t\tcurpan = panenv[ratio];\n\t\tnotestart = now + starttime;\n\t\tnote = Synth.basicNew(\\NRT_grain);\n\t\tscore.add([notestart, \n\t\t\tnote.newMsg(1, [\\freq, curfreq,\\amp, curamp, \\dur, windur, \\pan, curpan], \\addToHead)]\n\t\t\t);\n\t\t// check the current event's endtime against the gloabl endtime\n\t\tnow = now + (windur / overlaps);\n\t\tnow < duration;\n\t\t});\n\t};\n\n// call the above function to populate the Score\n\ngraingest.value(score, 1.0, 10.0, 100.reciprocal, 1, Env([440, 550], [1]), \n\tEnv([0, 0.2, 0], [0.3, 0.7], [4, -4]), Env([0, 0], [1]));\ngraingest.value(score, 3.0, 3.0, 130.reciprocal, 2, Env([700, 400], [1]),\n\tEnv([0, 0.2, 0], [0.1, 0.9], [4, -1]), Env([-0.7, 0.7], [1]));\n\n// create a number of short gestures\n10.do({arg i;\n\tgraingest.value(score, 5.0.rrand(10.0), 3.0.rrand(5.0), (100 * i).reciprocal, [1, 2, 4].choose,\n\t\tEnv([1000, 800], [1]), Env([0, 0.2, 0], [0.5, 0.5]), Env([0.5.rand2, 0.5.rand2], [1]));\n\t});\n\n// save the endtime to the Score to tell NRT when to stop rendering. The above gestures won't\n// be more the 16 seconds\n\nscore.add([16, [0]]);\n\n// sort the score to ensure events are in the correct order\n\nscore.sort;\n\n// render the Score to the users home folder\n\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n\t\n// also save the Score to a file\nscore.saveToFile(\"~/test.sc\".standardizePath);\n)\t\n/* End",
    "Figure 115": "Figure 18.4 */\t\n/*",
    "Figure 116": "Figure 18.5 */\n(\nvar score, sndbuf, starttime, synth, options;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// create a Buffer object for adding to the Score\nsndbuf = Buffer.new;\n\n// for NRT rendering, the buffer messages must be added to the Score\nscore.add([0, sndbuf.allocReadMsg(\"sounds/a11wlk01-44_1.aiff\")]);\n\nstarttime = 0.0;\n\n// a small function to create a series of small notes based on the Buffer\nwhile({\n\tsynth = Synth.basicNew(\\NRT_playback);\n\tscore.add([starttime, \n\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\tstarttime = starttime + 0.05;\n\tstarttime < 10.0;\n\t});\n\n// the dummy command. The soundfile will be 11 seconds long\nscore.add([11, 0]);\n\nscore.sort;\n\n// the ServerOptions for rendering the soundfile\noptions = ServerOptions.new.numOutputBusChannels_(1);\n\n// write the soundfile out to disk\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, options: options);\n)\n/* End",
    "Figure 117": "Figure 18.5 */\n/*",
    "Figure 118": "Figure 18.6 */\n(\nvar score, sndbuf, starttime, synth, options, cond;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// set up a Condition to check for when asynchronous events are finished.\n\ncond = Condition.new;\n\n// wrap the code that will run in real-time in a Routine, to allow for the Server to sync\nRoutine.run({\n\t// load the buffer\n\tsndbuf = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\t\n\t// pause while the buffer is loaded\n\ts.sync(cond);\n\t\n\t// fill the Score with notes\n\t\n\tstarttime = 0.0;\n\t\n\twhile({\n\t\tsynth = Synth.basicNew(\\NRT_playback);\n\t\tscore.add([starttime, \n\t\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\t\tstarttime = starttime + 0.05;\n\t\tstarttime < 10.0;\n\t\t});\n\t\n\t// the last command is NOT needed, since no soundfile is being rendered\n//\tscore.add([11, 0]);\n\t\n\tscore.sort;\n\t\n\t// again, options won't be needed for real time performance\n//\toptions = ServerOptions.new.numOutputBusChannels_(1);\n\t\n\tscore.play;\n\t// schedule the freeing of the buffer after the Score is done playing\n\tSystemClock.sched(11, {sndbuf.free; \"Buffer resources freed\".postln;});\n\t})\n)\n/* End",
    "Figure 119": "Figure 18.6 */\n/*",
    "Figure 120": "Figure 18.7 */\n\n\n// environment variables are used for real-time examples of Ctk objects\n\nn = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg gate = 1, freq, amp;\n\t\tvar src, env;\n\t\tsrc = SinOsc.ar(freq, 0, amp);\n\t\tenv = EnvGen.kr(Env([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction:2);\n\t\tOffsetOut.ar(0, src * env);\n\t\t})\n\t);\n\t\n// create a new note based on 'n', start to play it in 0.1 seconds\na = n.new(0.1).freq_(440).amp_(0.1).gate_(1).play;\n// the release method will set 'gate' to 0.0, and free this node\na.release;\n\n// create another note\na = n.new(0.1).freq_(440).amp_(0.1).play;\n// alter the freq argument in real time\na.freq_(550);\n// alter the freq with a CtkControl that describes an Env\n// CtkControl.env(Env)\na.freq_(CtkControl.env(Env([550, 440, 550], [1, 2], \\exp)));\n// apply a random control to the amp parameter, with an envelope applied to the range. All \n// parameters to the CtkControl can themselves be CtkControls\n// CtkControl.lfo(KRUGen, freq, low, high, phase)\na.amp_(CtkControl.lfo(LFNoise2, 0.5, CtkControl.env(Env([0.1, 0.9], [5])), 0.1));\na.amp_(0.1);\n\n// release the note\na.release;\n\n/* End",
    "Figure 121": "Figure 18.7 */\n/*",
    "Figure 122": "Figure 18.8 */\n// melodic expander\n(\nvar note, keys, durs, now, score, chunk, expander, rangemap;\n\n// \nthisThread.randSeed_(123);\n\n// a simple note player\n\nnote = CtkSynthDef(\\NRT_dut, {arg key, amp, dur;\n\t\tOut.ar(0, SinOsc.ar(key.midicps, 0, XLine.kr(amp, 0.00001, dur)))\n\t\t});\n\n// first, make a melody - these will be used as midikeynums (easier to alter later)\n\nkeys = [ 72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72 ];\n\n// a list of durations\n\ndurs = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5];\n\n// create a var to store 'now' in\n\nnow = 0.0;\n\n// create a CtkScore with the above melody\n\nscore = CtkScore.new;\n\nkeys.do({arg thiskey, inc;\n\tvar thisdur;\n\tthisdur = durs[inc];\n\tscore.add(note.new(now, thisdur).key_(thiskey).amp_(0.2).dur_(thisdur));\n\tnow = now + thisdur;\n\t});\n\n// first, create a function that will return a chunk of the melody the duration of the chunk\n// sets the starttimes of the notes to a base of 0.0\n\nchunk = {arg offset = 0;\n\tvar size, start, end, duration = 0, chunk, copies;\n\t// the size of the current melody - 1 (for array access)\n\tsize = score.notes.size;\n\t// the beginning of the chunk can come from the beginning of the melody to the second to \n\t// last note\n\tstart = 0.rrand(size-1);\n\tend = start.rrand(size);\n\tchunk = score.notes[start..end].collect({arg anote; \n\t\tvar newnote;\n\t\tnewnote = anote.copy(duration + offset);\n\t\tduration = duration + anote.duration;\n\t\tnewnote;\n\t\t});\n\t[chunk, duration];\n\t};\n\n// now, create a function that will add those chunks to the score, and will keep doing this\n// until the score is at least the desired length. Then check the score size, and truncate to \n// desired size.\n\nexpander = {arg len;\n\tvar curchunk, chunkdur, insert, inserttime, insertdur, cursize, newnotes;\tcursize = score.notes.size;\n\twhile({\n\t\tcursize < len\n\t\t}, {\t\t\n\t\tinsert = 0.rrand(cursize - 1);\n\t\tinserttime = score.notes[insert].starttime;\n\t\tinsertdur = score.notes[insert].duration;\n\t\t#curchunk, chunkdur = chunk.value(inserttime + insertdur);\n\t\tscore.notes[(insert+1)..(cursize-1)].do({arg me; \n\t\t\tme.setStarttime(me.starttime + chunkdur)});\n\t\tscore = score.add(curchunk);\n\t\t(score.notes.size > len).if({\n\t\t\tscore.notes.do({arg me, i;\n\t\t\t\t(i > (len - 1)).if({score.notes.remove(me)});\n\t\t\t\t})\n\t\t\t});\n\t\tcursize = score.notes.size;\n\t\t});\n\t};\n\n// rangemap will place the melodic material within a certain range. The user passes \n// in an envelope that will describe the center pitch in an octave range\n\nrangemap = {arg center;\n\tscore.notes.do({arg me;\n\t\tme.key_(me.key.mapIntoRange(12, center[me.starttime]));\n\t\t})\n\t};\n\t\t\n// expand it to 100 notes\nexpander.value(100);\n\n// describe a new range of pitches\nrangemap.value(Env([60, 96], [20]));\n\n// finally, play the CtkScore\n\nscore.play;\n)\n/* End",
    "Figure 123": "Figure 18.8 */\n/*",
    "Figure 124": "Figure 18.9 */\n\n(\nvar score, grain, now, thisdur;\nvar ampmap, double;\n\ngrain = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg freq, amp, dur, pan = 0;\n\t\tvar src, env;\n\t\tenv = EnvGen.ar(\n\t\t\tEnv([0, 1, 0], [0.5, 0.5], \\sin),\n\t\t\ttimeScale: dur, levelScale: amp);\n\t\tsrc = SinOsc.ar(freq, 0, env);\n\t\tOffsetOut.ar(0, Pan2.ar(src, pan));\n\t\t})\n\t);\n\t\nscore = CtkScore.new;\n\nnow = 0;\n\n// create a 3 second granular gesture\n\nwhile({\n\tthisdur = 0.05.rrand(0.1);\n\tscore.add(\n\t\tgrain.new(now, thisdur).freq_(440.rrand(880)).amp_(0.05).dur_(thisdur).pan_(0));\n\tnow = now + 0.01;\n\tnow < 3;\n\t});\n\n// a function to later map the amplitude to a given shape\n// envtimes should be scaled to 1\nampmap = {arg aScore, env;\n\t// caled the envs times by the CtkScore's duration\n\tenv.times = env.times * aScore.endtime;\n\taScore.notes.do({arg thisNote;\n\t\tvar curtime;\n\t\tcurtime = thisNote.starttime;\n\t\tthisNote.amp_(env[curtime]);\n\t\t});\n\t};\n\n// returns a new copy of the CtkScore with notes\n// double an octave higher\ndouble = {arg aScore, shift = 2;\n\tvar thisScore;\n\tthisScore = aScore.copy;\n\tthisScore.notes.do({arg thisNote;\n\t\tthisNote.freq_(thisNote.freq * shift)\n\t\t});\n\tthisScore;\n\t};\n\t\t\n// a Routine to play the examples\nRoutine.run({\n\tvar scoreDouble;\n\t// play the CtkScore;\n\tscore.play;\n\tscore.endtime.wait;\n\t// remap the amplitudes\n\tampmap.value(score, Env([0, 0.2, 0], [0.1, 0.9], [4, -2]));\n\t1.wait; // pause for a moment\n\t// play it again!\n\tscore.play;\n\tscore.endtime.wait;\n\t// add the CtkScore that octaveDouble returns\n\tscoreDouble = double.value(score, 19.midiratio);\n\tampmap.value(scoreDouble, Env([0, 0.25, 0], [0.6, 0.4], [4, -2]));\n\tscore.add(scoreDouble);\n\t1.wait;\n\tscore.play;\n\tscore.endtime.wait;\n\t// don't like the second version? remove double\n\tscore.ctkscores.remove(scoreDouble);\n\tampmap.value(score, Env([0.15, 0.05], [1]));\n\t1.wait;\n\tscore.play;\n\t}).randSeed_(123)\n)\n\n\n/* End",
    "Figure 125": "Figure 18.9 */\n/*",
    "Figure 126": "Figure 18.10 */\ns = Server.local;\ns.boot;\n\n~sinosc = CtkSynthDef.new(\\NRT_sinosc, \n\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t}\n);\n\n(\nvar score;\nvar baseNote = 75;\nvar slopeTime = 0.25;\nvar curve = \\sine;\nvar firstPitch = (baseNote + 0).midicps;\nvar firstStart = 0.0;\nvar firstDur = 5.0;\nvar firstAttackTime = slopeTime * 0.5;\nvar firstDecayTime  = slopeTime - firstAttackTime;\nvar firstVibDepth = 0.21;\nvar firstVibRate = 2.3;\nvar firstPeakAmp = 0.25;\nvar firstDecayAmp = 0.01;\nvar secondPitch = (baseNote - 4).midicps;\nvar secondStart = 2.2;\nvar secondDur = 4.0;\nvar secondAttackTime = slopeTime * 0.5;\nvar secondDecayTime  = slopeTime - secondAttackTime;\nvar secondVibDepth = 0.15;\nvar secondVibRate = 1.7;\nvar secondPeakAmp = 0.25;\nvar secondDecayAmp = 0.01;\nvar thirdPitch = (baseNote + 7).midicps;\nvar thirdStart = 3.1;\nvar thirdDur = 3.75;\nvar thirdAttackTime = slopeTime * 0.5;\nvar thirdDecayTime  = slopeTime - thirdAttackTime;\nvar thirdVibDepth = 0.21;\nvar thirdVibRate = 4;\nvar thirdPeakAmp = 0.2;\nvar thirdDecayAmp = 0.25;\n\nscore = CtkScore.new(\n\t~firstGroup = CtkGroup.new(firstStart, firstDur, server: s),\n\t~sinosc.new(firstStart, firstDur, \\tail, ~firstGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, firstVibRate, \n\t\t\t(firstPitch - ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (1/3)))), \n\t\t\t(firstPitch + ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (2/3)))), \n\t\t\tduration: firstDur, addAction: \\head, target: ~firstGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, firstPeakAmp, firstDecayAmp, 0], [firstAttackTime, \n\t\t\t\tfirstDur - (firstAttackTime + firstDecayTime), firstDecayTime], curve), \n\t\t\taddAction: \\head, target: ~firstGroup, server: s)),\n\t~secondGroup = CtkGroup.new(secondStart, secondDur, server: s),\n\t~sinosc.new(secondStart, secondDur, \\tail, ~secondGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, secondVibRate, \n\t\t\t(secondPitch - ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (1/3)))), \n\t\t\t(secondPitch + ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (2/3)))), \n\t\t\tduration: secondDur, addAction: \\head, target: ~secondGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, secondPeakAmp, secondDecayAmp, 0], [secondAttackTime, \n\t\t\t\tsecondDur - (secondAttackTime + secondDecayTime), secondDecayTime], curve), \n\t\t\taddAction: \\head, target: ~secondGroup, server: s)),\n\t~thirdGroup = CtkGroup.new(thirdStart, thirdDur, server: s),\n\t~sinosc.new(thirdStart, thirdDur, \\tail, ~thirdGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, thirdVibRate, \n\t\t\t(thirdPitch - ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (1/3)))), \n\t\t\t(thirdPitch + ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (2/3)))), \n\t\t\tduration: thirdDur, addAction: \\head, target: ~thirdGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, thirdPeakAmp, thirdDecayAmp, 0], [thirdAttackTime, \n\t\t\t\tthirdDur - (thirdAttackTime + thirdDecayTime), thirdDecayTime], curve), \n\t\t\taddAction: \\head, target: ~thirdGroup, server: s))\n);\n\nscore.play;\n)\n/* End",
    "Figure 127": "Figure 18.10 */\n/*",
    "Figure 128": "Figure 18.11 */\nVSO_Vib {\n\n\tvar <pitch, <depth, <rate, <control;\n\n\t*new {arg start = 0.0, dur = nil, freq = 1, vibDepth = 0.21, vibRate = 1, \n\t\taddAction = 0, target = 1, server;\n\t\t^super.new.initVSO_Vib(start, dur, freq, vibDepth, vibRate, addAction, \n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_Vib {arg start, dur, freq, vibDepth, vibRate, add = 0, tgt = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tpitch = freq;\n\t\tdepth = vibDepth;\n\t\trate = vibRate;\n\t\tcontrol = CtkControl.lfo(SinOsc, rate, this.getLowerValue,\n\t\t\tthis.getUpperValue, 0, start, dur, add, tgt, server: server);\n\t\n\t}\n\t\n\tgetLowerValue {\n\t\t^(pitch - ((pitch / (pitch.log2)) * (depth * (1/3))));\n\t}\n\n\tgetUpperValue {\n\t\t^(pitch + ((pitch / (pitch.log2)) * (depth * (2/3))));\n\t}\n}\n/* End",
    "Figure 129": "Figure 18.11 */\n/*",
    "Figure 130": "Figure 18.12 */\nVSO_ADR {\n\n\tvar <control, <attackDur, <releaseDur, <totalDur;\n\n\t*new {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, attackDur = 0.125, \n\t\treleaseDur = 0.125, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO_ADR(start, dur, peak, decay, attackDur, releaseDur, addAction,\n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_ADR {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, aDur = 0.125, \n\t\trDur = 0.125, addAction = 0, target = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tattackDur = aDur;\n\t\treleaseDur = rDur;\n\t\ttotalDur = dur;\n\t\tcontrol = CtkControl.env(Env.new([0, peak, decay, 0], \n\t\t\t[attackDur, this.decayDur, releaseDur], \\sine), \n\t\t\tstart, addAction, target, server: server, doneAction: 0);\n\t}\n\t\n\tdecayDur {\n\t\t^(totalDur - (attackDur + releaseDur));\n\t}\n\n}\n/* End",
    "Figure 131": "Figure 18.12 */\n/*",
    "Figure 132": "Figure 18.13 */\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n/* End",
    "Figure 133": "Figure 18.13 */\n/*",
    "Figure 134": "Figure 18.14 */\nVSO {\n\n\tclassvar <sinoscdef;\n\tvar <score, group, oscil, freqCntl, <ampCntl;\n\t\n\t*new {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, ampDecayLevel = 0.01, \n\t\tvibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO(start, dur, freq, ampPeakLevel, ampDecayLevel, \n\t\t\tvibDepth, vibRate, addAction, target, server);\n\t}\n\n\t*initClass {\n\t\tsinoscdef.isNil.if({\n\t\t\tsinoscdef = CtkSynthDef.new(\\NRT_sinosc, \n\t\t\t\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\t\t\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t\t\t\t})\n\t\t\t});\n\t}\n\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n\n}\n/* End",
    "Figure 135": "Figure 18.14 */\n/*",
    "Figure 136": "Figure 18.15 */\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nscore = CtkScore.new(\n\t(a = VSO.new(0.0, 5.0, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(2.2, 4.0, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(3.1, 3.75, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n)\n/* End",
    "Figure 137": "Figure 18.15 */\n/*",
    "Figure 138": "Figure 18.16 */\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nd = [2.4, 1.7];\na = NRT_TimeFrame.new(0.0, 11);\nb = NRT_TimeFrame.new(a.starttime + d.at(0), a.endtime - (a.starttime + d.at(0)));\nc = NRT_TimeFrame.new(b.starttime + d.at(1), b.endtime - (b.starttime + d.at(1)));\n\nscore = CtkScore.new(\n\t(a = VSO.new(a.starttime, a.duration, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(b.starttime, b.duration, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(c.starttime, c.duration, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n//N.B. You may notice three \"Node not found\" warnings.\n// This is expected behavior for this version of Ctk\n)\n/* End",
    "Figure 139": "Figure 18.16 */\n/*",
    "Figure 140": "Figure 18.17 */\nNRT_TimeFrame {\n\n\tvar >starttime, >duration;\n\t\n\t*new {arg starttime, duration;\n\t\t^super.newCopyArgs(starttime, duration);\n\t}\n\n\tstarttime {\n\t\t^starttime.value;\n\t}\n\n\tduration {\n\t\t^duration.value;\n\t}\n\n\tendtime {\n\t\t^(this.starttime != nil).if({\n\t\t\t(this.duration != nil).if({\n\t\t\t\t//call the getter methods rather than accessing\n\t\t\t\t// the variables directly\n\t\t\t\tthis.starttime + this.duration;\n\t\t\t}, {nil})\n\t\t}, {nil});\n\t}\n\n}\n/* End",
    "Figure 141": "Figure 18.17 */",
    "Figure 142": "Figure 2.1 */\n\ns = Server.internal.boot;\nz = s.scope(4);\n\n// a) mono output\n(\na = SynthDef(\\UGen_ex1a, {\n\tOut.ar(0, SinOsc.ar(440, 0, 0.1))\n}).play(s);\n)\t\na.free;\n\n// b) freq input is an Array of 4 items - outputs to busses 0-3\n(\na = SynthDef(\\UGen_ex1b, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, 0.1))\n}).play(s);\n)\t\na.free;\n\n// c) Array is added to the 'mul' arg to show mapping\n(\na = SynthDef(\\UGen_ex1c, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3, 0.4]))\n}).play(s);\n)\t\na.free;\n\n// d) The output of the SinOsc above is actually an Array of four SinOscs. Sum them together\n// for an additive synthesis example.\n(\na = SynthDef(\\UGen_ex1d, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3]).sum);\n}).play(s);\n)\t\na.free;\n\nz.window.close;\n\n/*",
    "Figure 143": "Figure 2.2 */\n\nServer.default = s = Server.internal.boot;\n\nz = s.scope;\n(\nSynthDef(\\UGen_ex2, {arg freq = 440;\n\tvar src, compressor, limiter, out;\n\t// 10 SinOsc's, mixed together. Output amplitude is controlled with an Dust UGen\n \t// wrapped in a Decay2 UGen to create a spike with an Exponential Decay\n\tsrc = SinOsc.ar(\n\t\t// a harmonic series based on freq\n\t\tArray.series(10, freq, freq),\n\t\t0, // phase\n\t\tArray.fill(10, {Decay2.ar( \n\t\t\t// Dust will create an impulse about every 2 seconds, with values between 0\n\t\t\t// and 5\n\t\t\tDust.ar(0.1, 5),\n\t\t\t// Decay2, attach time of 0.01 seconds and a decay time of 5 seconds to\n\t\t\t// allow for a build up of signal\n\t\t\t0.01, 5)});\n\t\t).sum;\n\t// compress signal about 0.5\n\tcompressor = Compander.ar(src, src, 0.5, 1, 0.1);\n\tlimiter = Limiter.ar(compressor, 0.5);\n\t// out is the compressed only signal on the left, the compressed and limited on the \n\t// right\n\tout = [DelayN.ar(compressor, 0.02, 0.02), limiter];\n\t// use Peak and poll to track the highest output values. Updates every second\n\tPeak.ar(out ++  src, Impulse.kr(1)).poll(1, [\"compressed\", \"limited\", \"src\"]);\n\tOut.ar(0, out);\n}).add;\n)\t\na = Synth(\\UGen_ex2, [\\freq, 440]);\n\na.free; z.window.close;\n\n/*",
    "Figure 144": "Figure 2.3 */\n(\nSynthDef(\\UGen_ex3, {arg gate = 1, amp = 1, rate = 10;\n\tvar trigger, dur, carfreq, modfreq, index, pan, env;\n\ttrigger = Impulse.ar(rate);\n\tdur = rate.reciprocal;\n\tcarfreq = LFNoise2.kr.range(100, 110);\n\tmodfreq = LFTri.kr(0.1).exprange(200, 840);\n\tindex = LFCub.kr(0.2).range(4, 10);\n\tpan = WhiteNoise.ar.range(-0.1, 0.1);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1),\n\t\tgate,\n\t\tlevelScale: amp,\n\t\tdoneAction: 2);\n\tOut.ar(0,\n\t\tGrainFM.ar(2, trigger, dur, carfreq, modfreq, index,\n\t\t\tpan, -1) * env)\n}).add;\n)\na = Synth(\\UGen_ex3, [\\rate, 80, \\amp, 0.2]);\n\nb = Synth(\\UGen_ex3, [\\rate, 42, \\amp, 0.2]);\n\nc = Synth(\\UGen_ex3, [\\rate, 121, \\amp, 0.2]);\n\n[a, b, c].do({arg thisSynth; thisSynth.set(\\gate, 0)});\n\n/*",
    "Figure 145": "Figure 2.4 */\n\n(\nSynthDef(\\UGen_ex4a, {arg id, limit = 1;\n\tvar src, pitch, hasPitch, keynum, outOfTune;\n\t// read input\n\tsrc = SoundIn.ar(0);\n\t// analyze the frequency of the input\n\t#pitch, hasPitch = Pitch.kr(src);\n\t// convert to a midi keynum, but don't round! This value will be used later.\n\tpitch = pitch.cpsmidi;\n\t// if you are within an eighth tone of an equal tempered pitch, send a trigger\n\toutOfTune = (pitch - pitch.round).abs < 0.25;\n\t// if outOfTune is true, send a trigger. Limit to 1 trigger every 'limit' seconds  \n\tSendTrig.kr(Trig.kr(outOfTune, limit), id, pitch.round);\n}).add;\n\t\nSynthDef(\\UGen_ex4b, {arg id1, id2, limit = 1, thresh = 0.5;\n\tvar src, amp, amptrig, timer;\n\tsrc = SoundIn.ar(0);\n\t// analyze the amplitude input, cause a trigger if the output is over the thresh\n\tamp = Amplitude.kr(src);\n\tamptrig = Trig.kr(amp > thresh, limit);\n\t// use amptrig to see how long it is between triggers.\n\ttimer = Timer.kr(amptrig);\n\t// send the values back with two different ids\n\tSendTrig.kr(amptrig, id1, amp);\n\tSendTrig.kr(amptrig, id2, timer);\n}).add;\n\n// plays a SinOsc of the pitch you were closest to\nSynthDef(\\UGen_ex4c, {arg freq;\n\tOut.ar(1, SinOsc.ar(freq, 0, XLine.kr(0.1, 0.00001, 0.5, doneAction: 2)))\n}).add;\n\n// modulated noise to respond to amp spikes\nSynthDef(\\UGen_ex4d, {arg freq;\n\tOut.ar(1, LFNoise1.ar(200) * SinOsc.ar(freq, 0, \n\t\tXLine.kr(0.1, 0.00001, 0.5, doneAction: 2)));\n}).add;\n\n// allocate three unique ids for the trigger ids\na = UniqueID.next;\nb = UniqueID.next;\nc = UniqueID.next;\t\n\n// an envelope to poll for amp values later\ne = Env([440, 880], [1], \\exp);\n\n// add the responder\no = OSCresponderNode(s.addr, '/tr', {arg time, responder, msg;\n\t// the msg is an array with 4 values... post them\n\tmsg.postln;\n\t// the id sent back from the SendTrig is msg[2]... use it to decide what to do\n\tcase \n\t\t// pitch trigger\n\t\t{msg[2] == a}\n\t\t// msg[3] is the rounded keynum\n\t\t{Synth(\\UGen_ex4c, [\\freq, msg[3].midicps])}\n\t\t// amp trigger\n\t\t{msg[2] == b}\n\t\t// play a noise burst, higher the amp value, higher the freq (polls the \n\t\t// Env 'e')\n\t\t{Synth(\\UGen_ex4d, [\\freq, e[msg[3]]])}\n\t\t// use the Timer value to play a delayed noise burst at 2000 Hz\n\t\t{msg[2] == c}\n\t\t{SystemClock.sched(msg[3], {\n\t\t\tSynth(\\UGen_ex4d, [\\freq, 2000]);\n\t\t\t})}\n}).add;\n\n// schedule the start our listening synths...\n// then sing or tap away on the input.\nSystemClock.sched(1.0, {\n\tSynth(\\UGen_ex4a, [\\id, a, \\limit, 1]);\n\tSynth(\\UGen_ex4b, [\\id1, b, \\id2, c, \\limit, 0.2, \\thresh, 0.25]);\n});\n\t\n// add a command period function to stop the synths and remove the responder\nCmdPeriod.doOnce({\n\to.remove; \"Removed the responder\".postln;\n})\n)\n\n/*",
    "Figure 146": "Figure 2.5 */\n(\nSynthDef(\\UGen_ex5, {arg gate = 1, seed = 0, id = 1, amp = 1;\n\tvar src, pitchbase, freq, rq, filt, trigger, env;\n\tRandID.ir(id);\n\tRandSeed.ir(1, seed);\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = WhiteNoise.ar;\n\ttrigger = Impulse.kr(Rand.new(2, 5));\n\tpitchbase = IRand.new(4, 9) * 12;\n\tfreq = TIRand.kr(pitchbase, pitchbase + 12, trigger).midicps;\n\trq = LFDNoise3.kr(Rand.new(0.3, 0.8)).range(0.01, 0.005);\n\tfilt = Resonz.ar(src, Lag2.kr(freq), rq);\n\tOut.ar(0, Pan2.ar(filt, LFNoise1.kr(0.1)) * env * amp)\n}).add;\n)\t\na = Synth(\\UGen_ex5, [\\seed, 123]);\n\na.release;\n\n// Using the same seed, we get the same gesture\nb = Synth(\\UGen_ex5, [\\seed, 123]);\n\nb.release;\n\n// passing in different seeds\n(\nr = Routine.run({\n\tthisThread.randSeed_(123);\n\t10.do({\n\t\ta = Synth(\\UGen_ex5, [\\seed, 10000.rand.postln, \\amp, 3.dbamp]);\n\t\t1.wait;\n\t\ta.release;\n\t})\n});\n)\t\t\n/*",
    "Figure 147": "Figure 2.6 */\n(\nSynthDef(\\UGen_ex6, {arg gate = 1, roomsize = 200, revtime = 450;\n\tvar src, env, gverb;\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = Resonz.ar(\n\t\t\tArray.fill(4, {Dust.ar(6)}),\n\t\t\t1760 * [1, 2.2, 3.95, 8.76] + \n\t\t\t\tArray.fill(4, {LFNoise2.kr(1, 20)}), \n\t\t\t0.01).sum * 30.dbamp;\n\tgverb = GVerb.ar(\n\t\tsrc,\n\t\troomsize, \n\t\trevtime, \n\t\t// feedback loop damping\n\t\t0.99,\n\t\t// input bw of signal\n\t\tLFNoise2.kr(0.1).range(0.9, 0.7),\n\t\t// spread \n\t\tLFNoise1.kr(0.2).range(0.2, 0.6),\n\t\t// almost no direct source \n\t\t-60.dbamp,\n\t\t// some early reflection\n\t\t-18.dbamp, \n\t\t// lots of the tail\n\t\t3.dbamp,\n\t\troomsize);\n\tOut.ar(0, gverb * env)\n}).add;\n)\t\na = Synth(\\UGen_ex6);\n\na.release;\n\n/*",
    "Figure 148": "Figure 2.7 */\n(\nSynthDef(\\UGen_ex7a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.ar(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex7b, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\nSynthDef(\\UGen_ex7c, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\n\n// 56% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 39%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7b, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 35%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7c, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n/*",
    "Figure 149": "Figure 2.8 */\n(\nSynthDef(\\UGen_ex8a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar w, x, y, out, env, decode;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tdecode = DecodeB2.ar(2, w, x, y);\n\tOut.ar(0, decode * env)\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8b, {arg outbus, freq = 440, rate = 0.2;\n\tvar w, x, y;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tOut.ar(outbus, [w, x, y])\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8c, {arg inbus, gate = 1, amp = 0.1;\n\tvar w, x, y, env, decode;\n\t#w, x, y = In.ar(inbus, 3);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 14);\n\tdecode = DecodeB2.ar(2, w, x, y) * env;\n\tReplaceOut.ar(0, decode);\n}).add;\n)\n\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex8a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n(\na = Group.new;\nz = Bus.audio(s, 3);\n\n// the 'catch-all' synth for decoding and enveloping\nSynth(\\UGen_ex8c, [\\inbus, z, \\amp, 0.001], a, \\addAfter); // add it after the Group containing the encoding synths\n\n250.do({\n\tSynth(\\UGen_ex8b, [\\freq, 440.0.rrand(1760.0), \\outbus, z, \\rate, 0.2], a)\n});\n)\n\na.release;\t\n/*",
    "Figure 150": "Figure 2.9 */\n(\n// pass in amp in db\nSynthDef(\\UGen_ex9a, {arg gate = 1, freq = 440, amp = 0;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0, amp.dbamp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\n// pass in linear amplitude\nSynthDef(\\UGen_ex9b, {arg gate = 1, freq = 440, amp = 1;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\nSynthDef(\\UGen_ex9c, {arg gate = 1, freq = 440, amp = -3, pos = 0;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\t\n\n// 45% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9a, [\\freq, 440.0.rrand(1760.0), \\amp, -60], a)\n});\n)\na.release;\n\n// 36%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9b, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp], a)\n});\n)\na.release;\n\n// 36% (no difference from b)\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9c, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp, \\pos, 1.0.rand2], a)\n});\n)\na.release;\n\n/*",
    "Figure 151": "Figure 2.10 */\n(\nSynthDef(\\UGen_ex10a, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10b, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10c, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\na = Synth(\\UGen_ex10a); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10b); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10c); // cubic interpolation\na.release;\n\n(\nSynthDef(\\UGen_ex10d, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10e, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\t\nSynthDef(\\UGen_ex10f, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\n// tune to a specific pitch\na = Synth(\\UGen_ex10d, [\\deltime, 100.midicps.reciprocal]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 100.midicps.reciprocal]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 100.midicps.reciprocal]); // cubic interpolation\na.release;\n\n// a much longer delay\na = Synth(\\UGen_ex10d, [\\deltime, 0.1]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 0.1]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 0.1]); // cubic interpolation\na.release;",
    "Figure 152": "Figure 20.9 into a more flexible prototype.\n//////// Here we add support for multiple buffers, from arrays of paths and coordinates.\n//////// A pattern, ~buffer, will choose which buffer to use for each event.\n\n// This is a copy of the",
    "Figure 153": "Figure 20.9 prototype with additions, highlighted by comments.\n\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ |ev| ev[\\bufnum].duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\t~rate = 1;\n\t~buffer = Pfunc({ ~bufs.choose });\n\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\rate, BPStream(\\rate),\t// reference to ~rate stream\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\bufnum, BPStream(\\buffer),\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\n\t~paths = [\"sounds/a11wlk01.wav\"];\t// now an array of strings\n\t\t// [startFrame, numFrames] for each path in ~paths\n\t\t// if this array is shorter, the path index will be wrapped\n\t\t// this default will load the complete soundfile for every path\n\t~bufCoords = [[0, -1]];\n\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t~loadBufs.();\t// move buffer loading to a separate method for modularity\n\t};\n\n\t~loadBufs = {\n\t\t~bufs.do({ |buf| buf.free });\n\t\t~bufs = ~paths.collect({ |path, i|\n\t\t\t~loadOneBuf.(path, *~bufCoords.wrapAt(i));\n\t\t});\n\t};\n\t\n\t~loadOneBuf = { |path, startFrame, numFrames|\n\t\tif(thisProcess.platform.name == \\linux and: { path[..5] == \"sounds\" }) {\n\t\t\tpath = Platform.systemAppSupportDir +/+ path;\n\t\t};\n\t\t\"loading %\\n\".postf(path);\n\t\tBuffer.read(s, path, startFrame, numFrames,\n\t\t\taction: { \"done loading %\\n\".postf(path) });\n\t};\n\t\n\t\t// why not? you should be able to add and remove buffers on the fly\n\t\t// removing a buffer if a synth is using it is maybe risky, though\n\t~addBuf = { |path, startFrame, numFrames|\n\t\t~bufs = ~bufs.add(~loadOneBuf.(path, startFrame, numFrames));\n\t};\n\t\n\t~removeBufAt = { |index|\n\t\t~bufs[index].free;\n\t\t~bufs.removeAt(index);\n\t};\n\n\t~freeCleanup = {\n\t\t[~chan, ~bufs].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\nPR(\\bufSlicer).chuck(BP(\\z), parms: (paths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"]));\n\nBP(\\z).play;\n\nBP(\\z).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\nBP(\\z).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\nBP(\\z).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).buffer = Pclutch(Pfunc({ ~bufs.choose }), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).pan = sin(Ptime(inf));\n\nBP(\\z).stop;\n\nBP(\\z).free;",
    "Figure 154": "Figure 20.9 into a more flexible prototype.\n//////// Upping the ante further... now we support multiple synthdefs.\n//////// The main pattern does not know in advance which streams to use,\n//////// until the specific def is chosen. So, I invent a data structure that holds\n//////// the SynthDef and patterns for each argument. At initialization, these\n//////// patterns are written into the environment and can be tweaked as in\n//////// previous examples.\n\n(\nPR(\\abstractProcess).clone({\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~def = Pfunc({ ~defs.keys.choose });\n\t~buffer = Pfunc({ ~bufs.choose });\n\t~maxStart = Pfunc({ |ev| ev[\\bufnum].duration }) - Pkey(\\time);\n\n\t~basePattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\def, BPStream(\\def),\n\t\t\t\\instrument, Pfunc({ |ev| ~defs[ev[\\def]].name }),\n\t\t\t\\delta, BPStream(\\delta),\n\t\t\t\\bufnum, BPStream(\\buffer)\n\t\t)\n\t};\n\t\n\t~userPattern = { nil };\n\t\n\t~asPattern = {\n\t\tvar\tuserpat = ~userPattern.();\n\t\tuserpat.notNil.if({\n\t\t\tPchain(userpat, ~basePattern.())\n\t\t}, {\n\t\t\t~basePattern.()\n\t\t}).collect({ |ev|\n\t\t\t~defs[ev[\\def]].argStreams.pairsDo({ |name, value|\n\t\t\t\tev.put(name, value.next(ev));\n\t\t\t});\n\t\t\tev\n\t\t});\n\t};\n\n\t~paths = [\"sounds/a11wlk01.wav\"];\n\t~bufCoords = [[0, -1]];\n\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t~loadBufs.();\n\t\t~initSynthDefs.();\n\t};\n\n\t~loadBufs = {\n\t\t~bufs.do({ |buf| buf.free });\n\t\t~bufs = ~paths.collect({ |path, i|\n\t\t\t~loadOneBuf.(path, *~bufCoords.wrapAt(i));\n\t\t});\n\t};\n\t~loadOneBuf = { |path, startFrame, numFrames|\n\t\tif(thisProcess.platform.name == \\linux and: { path[..5] == \"sounds\" }) {\n\t\t\tpath = Platform.systemAppSupportDir +/+ path;\n\t\t};\n\t\t\"loading %\\n\".postf(path);\n\t\tBuffer.read(s, path, startFrame, numFrames,\n\t\t\taction: { \"done loading %\\n\".postf(path) });\n\t};\n\t~addBuf = { |path, startFrame, numFrames|\n\t\t~bufs = ~bufs.add(~loadOneBuf.(path, startFrame, numFrames));\n\t};\n\t~removeBufAt = { |index|\n\t\t~bufs[index].free;\n\t\t~bufs.removeAt(index);\n\t};\n\n\t~initSynthDefs = {\n\t\tvar\tsdef;\n\t\t~defs = ~defs.value;\n\t\t~defs.keysValuesDo({ |id, defDict|\n\t\t\tsdef = defDict[\\def];\n\t\t\tdefDict[\\name] = sdef.tryPerform(\\name) ? sdef;\n\t\t\tsdef.tryPerform(\\send, ~chan.server);\n\t\t\tsdef.tryPerform(\\add);\n\t\t\t~initArgsForSynthDef.(id);\n\t\t});\n\t};\n\t\n\t~initArgsForSynthDef = { |id|\n\t\tvar\tstreamarray = Array.new(~defs[id][\\args].size), fullname;\n\t\t~defs[id][\\args].pairsDo({ |name, pattern|\n\t\t\t\t// assigning a Pattern to a BP environment variable automatically creates the stream\n\t\t\tfullname = (id ++ name).asSymbol;\n\t\t\tfullname.envirPut(pattern.asPattern);\n\t\t\tstreamarray.add(name).add(BPStream(fullname).asStream);\n\t\t});\n\t\t~defs[id][\\argStreams] = streamarray;\n\t};\n\t\n\t~defs = (\n\t\tbasic: (def: SynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\t\t\t\t\tattack = 0.001, decay = 0.02, outbus|\n\t\t\t\t\tvar sig;\n\t\t\t\t\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t\t\t\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\t\t\t\t\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n\t\t\t\t}),\n\t\t\targs: [\n\t\t\t\trate: 1,\n\t\t\t\ttfactor: 1,\n\t\t\t\ttime: Pkey(\\tfactor) * Pkey(\\delta),\n\t\t\t\tstartSec: Pwhite(0.0, BPStream(\\maxStart), inf),\n\t\t\t\tstart: Pkey(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\tpan: Pwhite(-1.0, 1.0, inf),\n\t\t\t\tamp: 1\n\t\t\t]),\n\t\tstretch: (def: SynthDef(\\bufStretch, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\t\t\t\t\tstretch = 1, attack = 0.001, decay = 0.02, outbus|\n\t\t\t\t\tvar sig;\n\t\t\t\t\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum) / stretch, 1, start, 0);\n\t\t\t\t\tsig = PitchShift.ar(sig, pitchRatio: stretch)\n\t\t\t\t\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\t\t\t\t\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n\t\t\t\t}),\n\t\t\targs: [\n\t\t\t\trate: 1,\n\t\t\t\ttfactor: 1,\n\t\t\t\tstretch: Pexprand(2.0, 4.0, inf),\n\t\t\t\tdelta: Pkey(\\delta) * Pkey(\\stretch),\n\t\t\t\ttime: Pkey(\\tfactor) * Pkey(\\delta),\n\t\t\t\tstartSec: Pwhite(0.0, Pfunc({ |ev| ev[\\bufnum].duration }) - (Pkey(\\time) / Pkey(\\stretch))),\n\t\t\t\tstart: Pkey(\\startSec) * Pfunc({ |ev| ev[\\bufnum].sampleRate }),\n\t\t\t\tpan: Pwhite(-1.0, 1.0, inf),\n\t\t\t\tamp: 1\n\t\t\t])\n\t);\n\n\t~freeCleanup = {\n\t\t[~chan, ~bufs].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\nPR(\\bufSlicer).chuck(BP(\\z), parms: (paths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"]));\n\nBP(\\z).play;\n\nBP(\\z).def = Pwrand(#[basic, stretch], [0.9, 0.1], inf);\n\n// tfactor, startSec and pan are defined separately for each synthdef\n// so, based on the Proto definition, I must prepend the synthdef's key\n// delta and buffer are global for all synthdefs, so no prepend\nBP(\\z).basictfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\nBP(\\z).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\nBP(\\z).basicstartSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).buffer = Pclutch(Pfunc({ ~bufs.choose }), Pdiff(Pkey(\\delta)).abs > 0);\nBP(\\z).basicpan = sin(Ptime(inf));\n\nBP(\\z).stop;\n\nBP(\\z).free;\n\n\n/*\nHere, the chucking parms dictionary is used to add a new synthdef, not as part of the prototype but just in the instance. To avoid polluting the original defs dictionary, the parameter should copy the original and put new item(s) into it -- PR(\\bufSlicer).defs.copy.put(\\grains, ...).\n*/\n\n(\nPR(\\bufSlicer).chuck(BP(\\z), parms: (\n\tpaths: [\"sounds/a11wlk01.wav\", \"sounds/a11wlk01-44_1.aiff\"],\n\tdefs: PR(\\bufSlicer).defs.copy.put(\n\t\t\\grains, (def: SynthDef(\\grainspray, { |center = 0.5, width = 0.1,\n\t\t\t\tdurStart = 0.01, durEnd = 0.01, density = 5,\n\t\t\t\tattack = 0.001, time = 1, decay = 0.02, amp = 1, bufnum, outbus|\n\t\t\tvar\ttrig = Dust.kr(density),\n\t\t\t\trate = TExpRand.kr(0.25, 4.0, trig),\n\t\t\t\tdur = XLine.kr(durStart, durEnd, time),\n\t\t\t\tpan = TRand.kr(-1.0, 1.0, trig),\n\t\t\t\tposRand = TRand.kr(width.neg, width, trig),\n\t\t\t\tsig = TGrains.ar(2, trig, bufnum, rate, center * BufDur.kr(bufnum) + posRand,\n\t\t\t\t\tdur, pan, amp);\n\t\t\tOut.ar(outbus, sig * EnvGen.kr(Env.linen(attack, time, decay), doneAction: 2))\n\t\t}),\n\t\targs: [\n\t\t\tcenter: Pwhite(0.05, 0.95, inf),\n\t\t\twidth: min(Pwhite(0.05, 0.2, inf), min(Pkey(\\center), 1.0 - Pkey(\\center))),\n\t\t\ttime: Pkey(\\delta),\n\t\t\tdensity: Pwhite(20.0, 50.0, inf)\n\t\t])\n\t)\n));\n)\n\nBP(\\z).play;\n\nBP(\\z).def = Pwrand(#[basic, stretch, grains], [0.8, 0.15, 0.05], inf);\n\n// Manipulating other streams is an exercise for the reader.\n\nBP(\\z).stop;\n\nBP(\\z).free;",
    "Figure 155": "Figure 20.9) to a higher degree of complexity and reusability.",
    "Figure 156": "Figure numbers missing from this file are graphics.\n\n--- H. James Harkins\n\n*****/\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 157": "Figure 20.1.\n//////// MixerChannel creation, SynthDef conventions, Synth playing\n\n// create the mixer: one channel in, two channels out\ns.boot;\n\nm = MixerChannel(\\fig1, s, 1, 2);\n\n// bring up a mixing board -- you can play with the level and panning controls\n// closing the window, or freeing all of its channels, removes the MixingBoard\nb = MixingBoard(\\Fig1, nil, m);\n\n// a SynthDef should include an outbus (or out) argument\n// so that the MixerChannel can tell it where to write its output\n(\nSynthDef(\\fig1, { |out, lowfreq = 220, hifreq = 1200, decay = 0.05|\n\tvar\ttrig = Impulse.kr(8);\n\t\t// Do not hard-code the outbus here!\n\t\t// Out.ar(0, ...) is not OK. Out.ar(outbus, ...) is good.\n\tOut.ar(out, SinOsc.ar(TExpRand.kr(lowfreq, hifreq, trig)) * Decay2.kr(trig, 0.01, decay));\n}).add;\n)\n\na = m.play(\\fig1, [lowfreq: 100, hifreq: 2000, decay: 0.1]);\n\n// automate panning - this is done with a control-rate synth\nm.automate(\\pan, { SinOsc.kr(LFNoise1.kr(0.5).exprange(0.4, 5.0)) });\n\n// the GUI can show the automation\nm.watch(\\pan);\n\n// add reverb using post-fader send\n// auto-play the reverb synth in the completion function\n(\nr = MixerChannel(\\rvb, s, 2, 2, level:1, completionFunc: { |chan|\n\t\"creating reverb synth\".postln;\n\tchan.playfx({ |outbus|\n\t\tvar\tsig = In.ar(outbus, 2);  // read from channel's bus\n\t\tFreeVerb2.ar(sig[0], sig[1], 1, 0.6, 0.5)\n\t});\n});\n\nb.add(r);  // add to MixingBoard\n)\n\n// feed the signal into the reverb\nm.newPostSend(r, 0.6);\n\n// prints out current state of all mixers in the board\n// the board is accessible also by MixingBoard.at(0)\nb.postSettings;\n\n// fade to black\nm.levelTo(0, 15);\n\n// and release\n// note that on m.free, the synth 'a' is removed also\n// freeing the last MixerChannel in the MixingBoard closes the window\nm.free;\nr.free;\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 158": "Figure 20.3.\n//////// Basic Voicer creation; triggering and gating notes.\n\n// Voicer(voices, things, args, bus, target, addAction)\n// target may be a Group, Server, or MixerChannel\nv = Voicer(10, \\default);\n\nv.trigger(440, 1);  // v.trigger(freq, gate, args, latency)\nv.release(440);\n\nv.gate(440, 2.0, 1, [pan: -0.5]);  // v.gate(freq, dur, gate, args, latency)\n\nr = fork {\n\tloop {\n\t\t\t// play over a C major scale\n\t\t[60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|\n\t\t\tv.gate(midi.midicps, 0.1, 1, [amp: rrand(0.05, 0.15)],\n\t\t\t\tlat: 0.1);\n\t\t\t0.125.wait;\n\t\t});\n\t}\n};\n\nr.stop;\n\nv.free;\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 159": "Figure 20.4.\n//////// Global controls and GUI.\n\n// let's put a pan global control on the voicer\n\nv = Voicer(10, \\default);\nv.mapGlobal(\\pan, nil, 0, \\bipolar);\t// v.mapGlobal(name, bus, value, spec, allowGUI)\n\nv.gui;\n\n// Pbind works with voicer, using 'voicerNote' event type\n(\np = Pbind(\n\t\\type, \\voicerNote,\n\t\\voicer, v,\n\t\\degree, Pn(Pseries(0, 1, 8), inf),\n\t\\amp, Pwhite(0.05, 0.15, inf),\n\t\\dur, 0.125,\n\t\\legato, 0.8\n).play;\n)\n\n// Try moving the slider in the Voicer window\n\np.stop;\n\n// Note, freeing the Voicer does not close the window\n// because you might want to reuse the GUI\n// But the Voicer area becomes \"inactive\"\nv.free;\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 160": "Figure 20.5.\n//////// VoicerMIDISocket.\n\nv = Voicer(10, \\default);\n\n// 0 = device 0, channel 0\n// for a different device, use [device index, channel]\n// after this, you can play on your keyboard\nk = VoicerMIDISocket(0, v);\n\n// modwheel to control pan\nk.addControl(1, \\pan, 0, \\bipolar);\nv.gui;\t// pan is identified by '1' in the gui - MIDI controller ID\n\n// a homegrown variety of just intonation\n// release all notes before executing this!\nk.midiToFreq = TuningRatios(12, tunings: [1, 135/128, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 14/9, 27/16, 16/9, 15/8]);\n\n// If some notes got stuck by changing the tuning, do this:\nv.panic;\n\n// per-note argument generation using a Pbind\n// here used to map velocity data onto the amp input\nk.noteOnArgsPat = Pbind(\\amp, Pkey(\\velocity).linlin(0, 127, 0.01, 0.2));\n\n// if you have a footswitch (controller number 64), this handles it properly\n// make sure to use the same device:\n// if you used [1, 0] for the channel ID before, use [1, 0] here\nl = VoicerSusPedal(0, 64, v);\n\n// by default, freeing the voicer automatically frees the socket and all attached MIDI controllers\nv.free;\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 161": "Figure 20.6.\n//////// Proto for prototypes.\n\n// standard \"Hello World\" greeter classes\n\n(\n~greeter = Proto({\n\t~sayhi = { |name|\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n});\n\n// make a subclass with .clone\n~frenchGreeter = ~greeter.clone({\n\t~greeting = \"Bonjour\";\n});\n\n~timeAwareFrenchGreeter = ~frenchGreeter.clone({\n\t~greeting = {\n\t\tvar\thour;\n\t\tif(thisProcess.platform.name != \\windows) {\n\t\t\thour = Date.getDate.hour;\n\t\t\tif(hour < 18) { ~dayGreeting } { ~eveningGreeting };\n\t\t} { ~dayGreeting };\n\t};\n\t~dayGreeting = \"Bonjour\";\n\t~eveningGreeting = \"Bon soir\";\n});\n)\n\n// Use the objects:\n~greeter.sayhi;\n~greeter.sayhi(\"Bob\");\n~frenchGreeter.sayhi(\"Isabelle\");\n\t// note: Date does not work in Windows\n\t// this code ignores time check in Windows\n~timeAwareFrenchGreeter.sayhi(\"Eric\");\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 162": "Figure 20.7.\n//////// Greeter as a PR prototype, and usage through BP instances.\n\n(\n\t// define PR prototype - Proto(...) => PR(\\name)\nProto({\n\t~sayhi = { |name|\n\t\t\t// ~greeting.value is an internal pseudomethod call\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n}) => PR(\\greeter);\n)\n\n// make working instance as BP\nPR(\\greeter) => BP(\\greeter);\nBP(\\greeter).sayhi(\"Jacqueline\");\nBP(\\greeter).name = \"Zsa Zsa\";\nBP(\\greeter).sayhi;\n\t// changing name in BP does not affect PR\nPR(\\greeter).name;\n\n// override default at chuck time\n// now this greeter belongs just to Bob\nPR(\\greeter).chuck(BP(\\greetBob), parms: (name: \"Bob\"));\nBP(\\greetBob).name;\t// ~name variable is overridden\nBP(\\greetBob).sayhi;\n\n// remove both instances from the repository\nBP([\\greeter, \\greetBob]).free;\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 163": "Figure 20.9.\n//////// Interactive session to build a soundfile slicer.\n\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t\t// BEHAVIORAL components\n\t\t// eventKey refers to ProtoEvent(\\singleSynthPlayer)\n\t~event = (eventKey: \\singleSynthPlayer);\n\t~quant = 0;\n\t\t// here, manufacture the pattern to play\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\bufnum, ~buf.bufnum,\n\t\t\t\\delta, BPStream(\\delta),\t// reference to ~delta stream\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * ~buf.sampleRate,\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\t\t// default Pbind streams\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ ~buf.duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\n\t\t// ARCHITECTURAL components\n\t\t// default soundfile\n\t~path = Platform.case(\n\t\t\\linux, { Platform.systemAppSupportDir +/+ \"sounds/a11wlk01.wav\" },\n\t\t{ \"sounds/a11wlk01.wav\" }\n\t);\n\n\t~startFrame = 0;\n\t~numFrames = -1;\n\t\t// constructor: auto-load soundfile and create mixer\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t\"loading %\\n\".postf(~path);\n\t\t~buf = Buffer.read(s, ~path, ~startFrame, ~numFrames,\n\t\t\taction: { \"done loading buffer\".postln });\n\t};\n\t\t// destructor, called on .free\n\t~freeCleanup = {\n\t\t[~chan, ~buf].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\n// That was the definition. In performance you only need this to play it.\n\nPR(\\bufSlicer) => BP(\\columbia);\nBP(\\columbia).play;\n\n// change process's stream references while it is playing\nBP(\\columbia).tfactor = 0.25;\n\nBP(\\columbia).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\n\nBP(\\columbia).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\n\nBP(\\columbia).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\n\n// also valid to chuck patterns into a BP\n// \".pan\" is an adverb indicating which variable to replace\nsin(Ptime(inf)) =>.pan BP(\\columbia);\n\nBP(\\columbia).stop;\nBP(\\columbia).free;\t// MixerChannel and Buffer go away also\n\n\n\n////////////////////////////////////////\n////////",
    "Figure 164": "Figure 20.10.\n//////// Factories for two variants of the buffer slicer process.\n\n// In the definition file:\n(\n(make: { |name|\n\tPR(\\bufSlicer) => BP(name);\n}, type: \\bp) => Fact(\\basic);\n\n(make: { |name|\n\tPR(\\bufSlicer).chuck(BP(name), parms: (\n\t\tpath: PR(\\bufSlicer)[\\path].dirname +/+ \"a11wlk01-44_1.aiff\",\n\t\ttfactor: sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55,\n\t\tdelta: Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf)),\n\t\tstartSec: Pclutch(Pwhite(0.0, Pfunc({ ~buf.duration }) - Pkey(\\time)), Pdiff(Pkey(\\delta)).abs > 0),\n\t\tpan: sin(Ptime(inf)),\n\t\tquant: 1\t// quantize to next beat\n\t))\n}, type: \\bp) => Fact(\\fancy);\n)\n\n// In the performance script:\nFact(\\basic) => BP(\\basic);\n\nBP(\\basic).play;\n\nFact(\\fancy) => BP(\\fancy);\n\nBP(\\fancy).play;\n\nBP([\\basic, \\fancy]).stop;\n\nBP([\\basic, \\fancy]).free;",
    "Figure 165": "figure out rollPan and 2-channel versions later\n\nSynthDescLib.all[\\ddwSynths].synthDescs.do({ |desc|\n\tSynthDescLib.global.add(desc);\t\t// copy into the global lib\n});\n\n\n// Initially my idea is that the user would be responsible for sending the defs\n// to the server when needed. But this broke too many of my tracks,\n// so I'm adding a dependant to servers to send the synthdefs on boot.\n// Feel free to comment this out if you don't like it.\n\nUpdater(Server, { |obj, what, newServer|\n\tif(what == \\serverAdded) {\n\t\tUpdater(newServer, { |obj, what|\n\t\t\tif(what == \\serverRunning and: { obj.serverRunning }) {\n\t\t\t\tSynthDescLib.all[\\ddwSynths].synthDescs.do({ |desc|\n\t\t\t\t\tdesc.def.send(obj);\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t};\n});\n\nServer.named.do({ |svr| Server.changed(\\serverAdded, svr) });",
    "Figure 166": "Figure\n// a quine in SC3\n(_ + '.(*' +  quote(_)  + '! 2)').(*\"(_ + '.(*' +  quote(_)  + '! 2)')\" ! 2)\n\n\n// not a",
    "Figure 167": "Figure\n// ensure VagueList.sc in in the enxtensions folder \n// VagueList has a vague 'at' method \na\u00ca=\u00caVagueList[0,\u00ca1,\u00ca2,\u00ca3];  \na.at(2); \t// may return 1, 2, or 3 \na.at(2); \na.at(2); \n\n\n// not a",
    "Figure 168": "Figure\n// Eniac Cycling Unit with adjustable clock speed\n(\n{\tvar clockspeed = MouseX.kr(1, 300, 1);\n\tvar clocksignal = LFSaw.ar(clockspeed).range(0, 80);\n \tvar timingPulses = CU_PulseLookUpTables.ar(clocksignal); // 10 channels.\n \ttimingPulses * 0.2\n}.scope;\n)\n\n//",
    "Figure 169": "Figure 23.1 The ENIAC Cycling Unit (graphic image).\n\n\n// not a",
    "Figure 170": "Figure\n// two ways of coupling parameters\n\n{ var freq = MouseX.kr(20, 2000, 1); Pulse.ar(freq, freq.explin(20, 2000, 0.95, 0.05)) }.play;\n\n\n// more intricate dependency\n{ var freq = MouseX.kr(20, 2000, 1);  Pulse.ar(freq,  freq.explin(20, 2000, 0, 5pi).sin * 0.45 + 0.5) }.play;\n\n\n//",
    "Figure 171": "Figure 23.2: Two ways of constraining parameters\n(\n{\tvar f = { | a, b | [a.min(1 - b), b.min(1 - a)] };\n\tvar freq = f.value(MouseX.kr, MouseY.kr) * 400 + 500;\n\tSinOsc.ar(freq) * 0.1\n}.play;\n)\n\n\n(\na = { |freq=100, width=0.5|\n\tvar df, dw;\n\tdf = freq - LastValue.kr(freq);\n\tdw = width - LastValue.kr(width);\n\tfreq = freq + (dw * 100);\n\twidth = width + (df / 100);\n\tPulse.ar(freq, width.clip(0.01, 0.99).poll) * 0.1\n}.play;\n)\n\na.set(\\freq, exprand(200.0, 600.0));\na.set(\\width, 1.0.rand);\n\n\n//",
    "Figure 172": "Figure 23.3 \u00d0 Pokey registers (graphic image)\n\n\n\n//",
    "Figure 173": "Figure 23.4:  Modulating Pokey inputs\n// modulating the frequency input to a Pokey UGen results in great variance\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate + mod, audc1: 2r01000000 + amp);\n}.play\n);\n\n// modulating the pure tone bit\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate, audc1: 2r00100000 + (mod * 2r00100000) + amp);\n}.play\n);\n\n\n\n\n//",
    "Figure 174": "Figure 23.5: Setting up rd_clt and mapping Ctls to a Synth's controls. \n// You may need to install the rd_clt Quark. See the Quarks help file.\n(\n\tSynthDef(\"FreqMod\", { |car=440, carFine=1, mod=100, modFine=1, index=4, amp=0.3, pan=0| \n\t\tOut.ar(0, Pan2.ar(PMOsc.ar(car * carFine, mod * modFine, index), pan, amp)); \n\t}).add; \t\t\n\t\n\tc = Controller.new(s, 256);\n\tc.makeInterface(2, 3, 0, \"Freq Mod controller\");\n\t\n\tc[0].setup(\"carFreq\", [50, 4800, \\exp].asSpec, 440);\n\tc[1].setup(\"carFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\n\tc[2].setup(\"modFreq\", [10, 4800, \\exp].asSpec, 10);\n\tc[3].setup(\"modFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\n\tc[4].setup(\"mIndex\", [0, 24, \\lin].asSpec, 1);\n\tc[5].setup(\"amp\", [0, 1, \\lin].asSpec, 0.2);\n);\n\n\na = Synth(\"FreqMod\") // start the synth\n6.do({|i| a.map(i, c[i].index)}); // map the synth control to the controller.\n\na.free\n\n\n//  3 Scheduling constraints: HierSch\n\n\n//",
    "Figure 175": "Figure 23.6 HierSch scheduling constraints and priority levels (graphic image)\n\n\n//",
    "Figure 176": "Figure 23.7: Priority-based HierSch scheduling.\n// You may need to install the HierSch Quark. See the Quarks help file. \n\n(\nSynthDef(\\ping, {\n\targ out = 0, mfreq = 69, pan = 0, gain = 0.2, dur = 0.25;\n\tOut.ar(out, Pan2.ar(\n\tSinOsc.ar(mfreq.midicps, 0, \n\tEnvGen.kr(envelope: (Env.perc(0.01, dur)), doneAction: 2)),\n\tpan, gain));\n}).add;\n\n// function to play a synth\nm = {|f, d=0.3, g=0.2, p=0| Synth(\\ping, [\\mfreq, f + 45, \\pan, p, \\gain, g, \\dur, d])};\n\n// function to make a chord\nc = {|a, b, c| [a, b, c].do{|i| m.value(i, 1.2, 0.075, rrand(-1.0, 1.0))}};\n\nt = TempoClock.default.tempo_(116 / 60); // assign clock to t\nb = HierSch.new(t); // start new HierSch, pass in clock\n)\n\n(\n// HierSch schedules\nb.schedAbs(t.beats.ceil + 48, 1, { var offset = [0, 5, 7, 12]; c.value(*[12, 16, 19]+ offset.choose)}, Prand(#[1.5, 3], 30)); // enters last, priority highest\n\nb.schedAbs(t.beats.ceil + 14, 2, {|b, p, d, c| m.value([0, 0, 7, 5, 4].at(c % 5) + [12, 24].choose, 0.4, 0.15, rrand(-1.0, 1.0))}, Pseq(#[2, 2, 2, 1], 15)); // enters middle, priority middle\n\nb.schedAbs(t.beats.ceil, 3, { |b, p, d, c| m.value(VagueList[0, 12, 4, 7, 10, 10, 9, 9, 7].at(c % 9))}, Pseq(#[0.5, 0.5, 0.5, 0.5, 0.25, 0.75, 1, 0.5, 0.5], 17)); // enters first, priority lowest\n)\n\n\n// \t4 Object Systems: Redirections and Constraints\n\n\n// \t4.1 Redirecting Assignment: Maybe and LazyEnvir\n\n// not a",
    "Figure 177": "Figure\n\nx = 1;\t// assigment\n\n~x = 1;\t// environment put\n\\x.envirPut(1);\ncurrentEnvironment.put(\\x, 1); \n\n\n\n\n//",
    "Figure 178": "Figure 23.8: Maybe yes.\n\np = LazyEnvir.push;\n~a = ~b * ~c;\n~a.value; \t// => nil\n~b = Pseq([1, 2, 3]).asStream;\n~c = 10;\n~a.value; \t// => 10\n~a.value; \t// => 20\n~b = [1, 2, 3];\n~a.value; \t// => [10, 20, 30];\n~a.postcs;\t// => Maybe((Maybe([ 1, 2, 3 ]) * Maybe(10)))\np.pop\n\n\n//\t4.2 Declaring Constraints: List Comprehensions\n\n// not a",
    "Figure 179": "Figure\n_ + 1 ! 7  // => [ 1, 2, 3, 4, 5, 6, 7 ]\n\nArray.fill(7, { |i| i + 1 })  // => [ 1, 2, 3, 4, 5, 6, 7 ]\n\n\n// not a",
    "Figure 180": "Figure\n// list comprehensions example \n\t\nf\u00ca=\u00ca{:[x, y], x <- (2..10), y <- (x..10), gcd(x, y) == 1  }; \n\nf.next; // [2, 3] \nf.next; \n\nf.all;\n\nf\u00ca=\u00ca{:[x, y], x<-(2..10), y<-(x + 1..10), gcd(x, y) == 1; x.isPrime.not and: y.isPrime.not  }; \nf.next; // [2, 3] \nf.next;  \n\n\n//",
    "Figure 181": "Figure 23.9: Coprimes as frequency and trigger rates\n(\nvar x;\nx = { |rates=#[1, 1]| Ringz.ar(Impulse.ar(rates) * 0.1, rates * 80, 1 / rates) }.play;\nfork {\n\tvar str = {:[x, y], \n\t\tx<-(40..2), \n\t\ty<-(x + 1..40),\n\t\tgcd(x, y) == 1,\n\t\tx.isPrime.not and: y.isPrime.not\n\t};\n\t0.5.wait;\n\tstr.do { |primes|\n\t\tx.setn(\\rates, primes.postln);\n\t\t(primes.product / primes.sum / 20).wait;\n\t}\n};\n)\n\n// 5 Text Systems\n\n\n// not a",
    "Figure 182": "Figure\na = Pseq(\"aggaca\").collect(_.ascii)\na.asStream.all // => [ 97, 103, 103, 97, 99 ]\n\n\n//",
    "Figure 183": "Figure 23.10: A very simple notation translater\n\n(\nvar dict, maxLength = 0;\ndict = (\n\tab: { (note: [4, 0, 7], legato: 0.1, dur: 1) },\n\tba: { (note: [4, 9, 8], legato: 0.3, dur: 0.3) },\n\taaa: { (note: 5, legato:1.5) },\n\tbbb: { (note: 0, legato:2.5, dur: 0.25) }\n);\n\ndict.keys.do { |key| maxLength = max(maxLength, key.asString.size) };\n\nf = { |str|\n\tvar i = 0, n = 0, substr, event;\n\twhile { i < str.size } {\n\t\tsubstr = str[i..i + n];\n\t\tevent = dict[substr.asSymbol].value;\n\t\tif(event.notNil) {\n\t\t\tsubstr.postln;\n\t\t\ti = i + n + 1;\n\t\t\tn = 0;\n\t\t\tevent.postln.play;\n\t\t\tevent.delta.wait;\n\t\t} {\n\t\t\tif(n + 1 < maxLength) { n = n + 1 } { n = n - 1; i = i + 1 }\n\t\t};\n\t};\n};\n)\n\n// play some sequences\nfork { f.value(\"abbbbaab\"); }\nfork { f.value(\"aaabbbabbaaaabbabaaaaba\"); };\n\n\n\n// not a",
    "Figure 184": "Figure\n\t\nx = \"1 + 2\";\nx.interpret\u00ca/\u00ca3;\u00ca//\u00ca1\nx\u00ca=\u00cax.replace(\"+\", \"-\"); \nx.interpret\u00ca/\u00ca3;\u00ca//\u00ca-0.33333\n\n\nthis.preProcessor = { |str| str.replace(\"+\", \"-\") } \n1 + 2 // -1\nthis.preProcessor = nil \n1 + 2 // 3",
    "Figure 185": "Figure 3.1 A simple routine illustrating a musical use of yield\n// Fermata\ns.boot;\n(\nr = Routine({\t\n\tx = Synth(\\default, [freq: 76.midicps]);\n\t1.wait;\n\t\n\tx.release(0.1);\n\ty = Synth(\\default, [freq: 73.midicps]);\n\t\"Waiting...\".postln;\n\tnil.yield;// fermata\n\t\n\ty.release(0.1);\n\tz = Synth(\\default, [freq: 69.midicps]);\n\t2.wait;\n\tz.release;\n});\n)\n// do this then wait for the fermata\nr.play;\n// feel the sweet tonic... \nr.play; \n\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////// \n//",
    "Figure 186": "Figure 3.2 Using Task so you can pause the sequence\n(\nt = Task({\t\n\tloop({\t // loop the whole thing\n\t\t3.do({\t // do this 3 times\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 76.midicps]);\n\t\t\t0.5.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 73.midicps]);\n\t\t\t0.5.wait;\n\t\t});\n\t\t\"I'm waiting for you to press resume\".postln;\n\t\tnil.yield;// fermata\n\t\tx.release(0.1);\n\t\tx = Synth(\\default, [freq: 69.midicps]);\n\t\t1.wait;\n\t\tx.release;\n\t});\n});\n\nw = Window.new(\"Task Example\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\nButton.new(w, Rect(0, 0, 100, 20)).states_([[\"Play/Resume\", Color.black, Color.clear]])\n\t.action_({ t.resume(0);});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Pause\", Color.black, Color.clear]])\n\t.action_({ t.pause;});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Finish\", Color.black, Color.clear]])\n\t.action_({ \n\t\tt.stop; \n\t\tx.release(0.1);\n\t\tw.close;\n\t});\n)\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 187": "Figure 3.3 Nesting tasks inside routines\n(\nr = Routine({\t\n\tc = TempoClock.new; // make a TempoClock\n\t// start a 'wobbly' loop\n\tt = Task({\t\n\t\tloop({\t\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 61.midicps, amp: 0.2]);\n\t\t\t0.2.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 67.midicps, amp: 0.2]);\n\t\t\trrand(0.075, 0.25).wait; // random wait from 0.1 to 0.25 seconds\n\t\t});\n\t}, c); // use the TempoClock to play this Task\n\tt.start;\n\tnil.yield;\n\t\n\t// now add some notes\n\ty = Synth(\\default, [freq: 73.midicps, amp: 0.3]);\n\tnil.yield;\n\ty.release(0.1);\n\ty = Synth(\\default, [freq: 79.midicps, amp: 0.3]);\n\tc.tempo = 2; // double time\n\tnil.yield;\n\tt.stop; y.release(1); x.release(0.1); // stop the Task and Synths\n});\n)\n\nr.next; // start loop\nr.next; // first note\nr.next; // second note; loop goes 'double time'\nr.next; // stop loop and fade\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 188": "Figure 3.4 Using patterns within a task\n\n(// random notes from lydian b7 scale\np = Pxrand([64, 66, 68, 70, 71, 73, 74, 76], inf).asStream; \n// ordered sequence of durations\nq = Pseq([1, 2, 0.5], inf).asStream; \nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\nt.stop; x.release(2);\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 189": "Figure 3.5 Thanks to polymorphism we can substitute objects that understand the same message\n(\np = 64; // a constant note\nq = Pseq([1, 2, 0.5], inf).asStream; // ordered sequence of durations\nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\n// now change p\np = Pseq([64, 66, 68], inf).asStream; // to a Pattern: do re mi\np = { rrand(64, 76) }; // to a Function: random notes from a chromatic octave\nt.stop; x.release(2);\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 190": "Figure 3.6 Using 'messaging style': Score\n\n(\nSynthDef(\"ScoreSine\",{ arg freq = 440;\nOut.ar(0,\n\tSinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)\n)\n}).add;\nx = [\n// args for s_new are synthdef, nodeID, addAction, targetID, synth args ...\n[0.0, [ \\s_new, \\ScoreSine, 1000, 0, 0,  \\freq, 1413 ]],\n[0.5, [ \\s_new, \\ScoreSine, 1001, 0, 0,  \\freq, 712 ]],\n[1.0, [ \\s_new, \\ScoreSine, 1002, 0, 0,  \\freq, 417 ]],\n[2.0, [\\c_set, 0, 0]] // dummy command to mark end of NRT synthesis time\n];\nz = Score(x);\n)\nz.play;\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 191": "Figure 3.7 Executing one line at a time\n\n(\n// here's a synthdef that allows us to play from a buffer, with a fadeout\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t\t* Linen.kr(gate, doneAction: 2); // release synth when fade done\n\t)\n}).add;\n// load all the paths in the sounds/ folder into buffers\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \n)\n// now here's the score, so to speak\n// execute these one line at a time\n~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[0]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[1]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[2]]);\n~nowPlaying.release;\n// free the buffer memory\n~someSoundsBuffered.do(_.free);\n \n \n \n \n \n \n \n///////////////////////////////////////////////////////////////\n//",
    "Figure 192": "Figure 3.8 Play cues with a simple GUI\n\n(\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t* Linen.kr(gate, doneAction: 2) * 0.6; \n\t\t// with 'doneAction: 2' we release synth when fade is done\t\n) }).add;\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \nn = 0; // a counter\n// here's our GUI code\nw = Window.new(\"Simple CuePlayer\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\n//this will play each cue in turn\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Play Cue\", Color.black, Color.clear]]).action_({ \n\tif(n < ~someSounds.size, {\n\t\tif(n != 0, {~nowPlaying.release;}); \n\t\t~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[n]]); n=n+1;\n\t});\n}); \n//this sets the counter to the first cue\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Stop / Reset\", Color.black, Color.clear]]).action_({ n=0; ~nowPlaying.release; }); \n// free the buffers when the window is closed\nw.onClose = { ~someSounds.do(_.free); };\n)\n\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 193": "Figure 3.9 Gathering up files for multichannel cues \n\n// gather all your folder paths\n//this will path match each folder in the collection, i.e. we will have a collection of collections of paths\n\n~groupOfindivCueFolders = \"sounds/*\".pathMatch.collect{ | item |  (item.asSymbol++\"*\").pathMatch };\n\nPost << ~groupOfindivCueFolders;  //see them all !\n\n//check how many cues you will have in the end\n~groupOfindivCueFolders.size; \n\n//automate the buffering process for all cues:\n~bufferedCues = ~groupOfindivCueFolders.collect{|item, i| item.collect{| path |  Buffer.read(s,  path)}}; //now all our cue files are sitting in their buffers ! \n\n~bufferedCues[0];  //here is cue 1\n\n// see it in the post window:\nPost << ~bufferedCues[0];\n\n// play them all in a Group, using our previous synthdef\n// we use bind here to ensure they start simultaneously\n(\ns.bind({\t\n\t~nowPlaying = Group.new(s); // a group to put all the channel synths in\n\t~bufferedCues[0].do({|cue| Synth(\"playbuf\", [buf: cue], ~nowPlaying)})\n});\n)\n// fade them out together by sending a release message to the group\n~nowPlaying.release;\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 194": "Figure 3.10 Recording the results of making sounds with supercollider\n\ns.boot; // make sure the server is running\n(  \t// first evaluate this section\nb = Buffer.read(s, \"sounds/a11wlk01.wav\"); // a source\ns.prepareForRecord; // prepare the server to record (you must do this first)\n)\n(\t// simultaneously start the processing and recording\ns.bind({\n\t// here's our funky effect\n\tx = { var columbia, amp; \n\t\tcolumbia = PlayBuf.ar(1, b, loop: 1);\n\t\tamp = Amplitude.ar(columbia, 0.5, 0.5, 4000, 250); // 'sticky' amp follower\n\t\tOut.ar(0, Resonz.ar(columbia, amp, 0.02, 3)) // filter; freq follows amp\n\t\t}.play;\ns.record;\n});\n)\ns.pauseRecording; // pause\ns.record // start again\ns.stopRecording; // stop recording and close the resulting sound file\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n\n// Thinking in the Abstract examples\n(\n{\nResonz.ar(Dust2.ar(5), 300, 0.001, 100)  +\nResonz.ar(Dust2.ar(5), 600, 0.001, 100)  +\nResonz.ar(Dust2.ar(5), 900, 0.001, 100) * 3.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n(\nf = 300;\nn = 3;\n{\nMix.fill(n, {|i| Resonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 100)})\n* n.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n(\nf = 40;\nn = 50;\n{\nMix.fill(n, {|i| Resonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)})\n* n.reciprocal; // scale to ensure no clipping\n}.play\n)\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 195": "Figure 3.12 A variable number of resonators with an automatically created GUI       \n(\nf = 300;\nn = 30; // number of resonators\nt = Array.fill(n, { |i|\n{\nResonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)\n* n.reciprocal; // scale to ensure no clipping\n}.play;\n});\n\n// now make a GUI\n// a scrolling window so we don't run out of space\nw = Window.new(\"Buttons\", Rect(50, 100, 290, 250), scroll:true);\nw.view.decorator = FlowLayout.new(w.view.bounds); // auto layout the widgets\nn.do({|i|\nButton.new(w, Rect(0, 0, 130, 30)).states_([\n[\"Freq\" + (f * (i + 1)) + \"On\", Color.black, Color.white],\n[\"Freq\" + (f * (i + 1)) + \"Off\", Color.white, Color.black]\n])\n.action_({ arg butt;\nt[i].run(butt.value == 0);\n});\n});\nw.front;\n)\n  \n\n\n\n///////////////////////////////////////////////////////////////\n// Empty Gestures\n\n( //you will be able to add multiple soundfiles, just shift click when selecting !\nvar file, soundPath;\n~buffers = List[];\nDialog.getPaths({ arg paths;\npaths.do({|soundPath|\n//post the path to verify that is the one you expect!\n    soundPath.postln; \n//adds the recently selected buffer to your list \n    ~buffers.add(Buffer.read(s, soundPath);); })\n});\n)\n\n~buffers.size;\n~buffers[0];\n~buffers[0].play;\n\n\n(\n// buffer player with done action and control of envelope and panning\nSynthDef(\\samplePlayer, { arg out=0, buf = 0,\nrate = 1, at =0.01, rel= 0.1, pos =0, pSpeed = 0, lev = 0.5;\nvar sample, panT,  amp, aux;\nsample = PlayBuf.ar(1, buf, rate*BufRateScale.kr(buf), 1, 0, 0);\npanT= FSinOsc.kr(pSpeed);\namp = EnvGen.ar(Env.perc(at, rel, lev), doneAction: 2);\nOut.ar(out, Pan2.ar(sample, panT, amp));\n}).memStore;\n)\n\nSynth(\\samplePlayer,[\\out, 0, \\bufnum, ~buffers[0], \\rel, 0.25]);\nSynth(\\samplePlayer,[\\out, 0, \\bufnum, ~buffers[~buffers.size.rand], \\rel, 0.25]); \n\n\n\n\n\n\n///////////////////////////////////////////////////////////////\n//",
    "Figure 196": "Figure 3.13 Making a stuttering gesture using a geometric pattern\n\n(/* a routine for creating a ritardando stutter with panning, you must have\nrun the code in fig 3.9 so that this routine may find some sounds already loaded into buffers, you can change the index of ~bufferedCues to test the routine on different sounds */\n\n\n~stut = Routine( { var dur, pos;\n~stutPatt = Pseq([Pgeom(0.01, 1.1707, 18), Pn(0.1, 1),Pgeom(0.1, 0.94, 200) ]);\n~str= ~stutPatt.asStream;\n100.do{\n    dur =  ~str.next;\n    dur.postln; \t//so we can check values on the post window\n    ~sample = Synth(\"samplePlayer\",[\\out, 0, \\buf,  ~bufferedCues[0], \\at, 0.1, \\rel, 0.05,\\pSpeed, 0.5]);\n    dur.wait;\n}\n});\n)\n\n//now play it\n~stut.play;\n// reset before you play again!\n~stut.reset; \n \n\n\n///////////////////////////////////////////////////////////////\n// More Empty Gestures\n\n// randomly selected frequency, duration 0.1 seconds\nPbind(\\freq, Prand([300, 500, 231.2, 399.2], 30), \\dur, 0.1).play;\n\n~gest1 = Pbind(\\instrument, \\samplePlayer, \\dur, 2, \\rel, 1.9);\n~player = ~gest1.play; //make it play\n~player.stream = Pbind(\\instrument, \\samplePlayer, \\dur, 1/8, \\rate, Pxrand([1/2,1,2/3,4],inf), \\rel, 0.9).asStream; //substitute the stream\n~player.stop;\n\n\n~gest1 = Pbind(\\instrument, \\samplePlayer, \\dur, Pgeom(0.01, 1.1707, 20), \\rel, 1.9);\n~gest1.play;\n\nPbind(\\instrument, \\samplePlayer, \\dur, Pseq([Pgeom(0.01, 1.1707, 20), Pgeom(0.01, 0.93, 20)], 1), \\rel, 1.9, \\pSpeed, 0.5).play;\n\nPbind(\\instrument, \\samplePlayer, \\dur, Pseq([Pgeom(0.01, 1.1707, 20), Pgeom(0.01, 0.93, 20)], 1),\\rate, Pxrand([1/2,1,2/3,4],inf), \\rel, 1.9, \\pSpeed, 0.5).play;\n\n~rhythm1 = Pseq([1/4, 1/4, 1/8, 1/12, 1/24, nil]); //the nil is so it will stop !\n\n~gest1 = Pdef(\\a, Pbind(\\instrument, \\samplePlayer, \\dur, ~rhythm1, \\rel, 1.9, \\pSpeed, 0.5) );\n~gest1.play;\n\n~rhythm1 = Pseq([1/64,1/64,1/64, 1/32, 1/32, 1/32, 1/32, 1/24, 1/16, 1/12, nil]);\n~gest1 = Pdef(\\a, Pbind(\\instrument, \\samplePlayer, \\dur, ~rhythm1, \\rel, 1.9, \\pSpeed, 0.5) );\n\n~gest1 = Pdef( \\a , Pbind(\\instrument, \\samplePlayer, \\att, 0.5, \\rel, 3, \\lev, {rrand(0.1,0.2)}, \\dur, 0.05, \\rate, Pseq([ Pbrown(0.8, 1.01, 0.01, 20) ]) ) );",
    "Figure 197": "Figure 4.1\n//\n// Create two OSC responders for the same command\n~r1 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\tfork {\n\t\t\t(time - thisThread.seconds).wait;\n\t\t\t[\\responder1, time, message, address].postln;\n\t\t};\n\t}\n).add;\n~r2 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\tfork {\n\t\t\t(time - thisThread.seconds).wait;\n\t\t\t[\\responder2, time, message, address].postln;\n\t\t};\n\t}\n).add;\n\n\n// Create a network address representing sclang itself\n~host = NetAddr(\"localhost\", NetAddr.langPort);\n\n// Send an OSC message\n~host.sendMsg(\"/testMsg\", \"OSCresponderNode test\");\n\n// Send an OSC message\n~host.sendMsg( \"/testMsg\", 42, \"string\", pi);\n\n// Send an OSC bundle and execute its contents\n// 200 ms from 'now'\n~host.sendBundle(0.2,\n\t[\"/testMsg\", 42, \"string\", pi],\n\t[\"/testMsg\", 183]);\n\n\n// Remove responders\n~r1.remove;\n~r2.remove;",
    "Figure 198": "Figure 5.1\n1\t\t\t\t\t// the Integer number 1 \n1.234 \t\t\t\t// the floating-point (Float) number 1.234\n$a \t\t\t\t\t// the character (Char) a\n\"hello\"\t\t\t\t// a String (an array of characters) \n\\alpha\t\t\t\t// a Symbol (a unique identifier) \n'alpha 1'\t\t\t\t// another notation for a Symbol\n100@150 \t\t\t\t// a Point defined by coordinates x, y \n[1, \\A, $b] \t\t\t\t// an Array containing 3 elements\n(a: 1, b: 0.2) \t\t\t// an Event \n{ 10.rand }\t\t\t\t// a Function\nString \t\t\t\t// the Class String \nMeta_String \t\t\t// the Class of Class String\n\n\n\f\n//",
    "Figure 199": "Figure 5.3\n// Boot the default server first:\nServer.default.boot;\n// Then select all lines between the outermost parentheses and run: \n( \t\n{\n\tResonz.ar(GrayNoise.ar,\n\t\tXLine.kr(100, 1000, 10, doneAction: 2), \n\t\tXLine.kr(0.5, 0.01, [4, 7], doneAction: 0)\n\t)\n}.play\n)\n// further examples:\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 3, doneAction: 2)) }.play;\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 0.3, doneAction: 2))}.play;\n\n\n\f\n //",
    "Figure 200": "Figure 5.4\n((1 + 2).asString).interpret \t\t// = 3\n\"1\" ++ \"2\". interpret\t\t\t// 12: 2 is translated to string by ++\n(\"1\" ++ \"2\").interpret\t\t\t// 12\n(1.asString ++ 2.asString).interpret \t// 12\n\"1+2\". interpret \t\t\t\t// 3\n(1.asString ++ \"+2\"). interpret\t\t// 3\n(1 + 2).interpret\t\t\t\t// error: interpret not understood by Integer 3\n\n\n\n\n\f\n //",
    "Figure 201": "Figure 5.5\n(\na = 5;\n5 do: { a = a + 10; a.postln };\nPost << \"The value of variable 'a' is now \" << a << \"\\n\";\n)\n\f\n//",
    "Figure 202": "Figure 5.8\n(\n// A window with a button that posts: \"hello there!\"\nvar window, button;\n// create a GUI window and store it in variable window\nwindow = Window.new(\"OLA!\", Rect(200, 200, 120, 120)); \n// create a button in the window and store it in variable button\nbutton = Button.new(window, Rect(10, 10, 100, 100));\nbutton.states = [[\"'ALLO\"]];\t// set one single label for the button\nbutton.action = { \"hello there!\".postln }; // set the action of the button\nwindow.front;\t\t  \t  // show the window\n)\n \f\n//",
    "Figure 203": "Figure 5.9\n\n( \n// execute this first to boot the server and load the synth definition\nServer.default.waitForBoot({ \n\tSynthDef(\"ping\", { | freq = 440 |\n\t\tOut.ar(0, \n\t\t\tSinOsc.ar([freq, freq * (4/3)], 0,\n\t\t\t\tEnvGen.kr(Env.perc(0.05, 0.3, 0.1, -4), doneAction: 2)\n\t\t\t)\n\t\t)\n\t}).send(Server.default);\n});\n)\n\n(\n// execute this next to create the sounds\nvar countdown = 100;\nvar note = 50;\nvar increment_func, decrement_func;\nvar action;\nincrement_func = {\n\tnote = note + [2, 5, 7, 12].choose;\n\tif (note > 100) { action = decrement_func };\n};\ndecrement_func = {\n\tnote = note - [1, 2, 5, 7, 12].choose;\n\tif (note < 50) { action = increment_func };\n};\naction = increment_func;\n{\n\tcountdown do: { \n\t\tSynth(\"ping\", [\\freq, note.midicps]);\n\t\taction.value;\n\t\t0.1.wait;\n\t}\n}.fork;\n)\n\n\f\n //",
    "Figure 204": "Figure 5.11\n// run each line separately: \ncurrentEnvironment;\t// empty if no environment variables have been set\n~alpha = pi;\t\t\t// set env. variable ~alpha to pi\ncurrentEnvironment;\t// see current Environment again: ~alpha is set\n~freq = 800;\t\t\t// set another environment variable\nServer.local.boot;\n{ LFNoise0.ar(~freq, 0.1) }.play; // use an environment variable\n// setting an environment variable to nil is equivalent to removing it: \n~alpha = nil;\ncurrentEnvironment;\t// alpha is no longer set\n\n\f\n //",
    "Figure 205": "Figure 5.12\n(\n~q = \"TOP\";\t\t\t\t\t\t\t// store \"TOP\" in ~a, top environment\n(a: \"INNER\") use: { // run function in environment with ~a = \"INNER\"\n\tcurrentEnvironment.postln; // show the current environment\n\ttopEnvironment.postln;\t\t// show the top environment (different!)\n\t~a.postln\t\t\t\t// show ~a's value in current environment\n};\t\n~a;\t\t\t\t\t\t// show ~a's value in top environment\n)\n\n\f\n //",
    "Figure 206": "Figure 5.13\n(\nvar alpha, beta, gamma;\ngamma = alpha;\t// storing variable alpha in gamma only stores nil \nalpha = 10; \t// store 10 in alpha ...\ngamma.postln;\t// but the value of gamma remains unchanged\nalpha = beta;\t// so one cannot use gamma as 'joker'\nbeta = 20;\t\t// to switch between variables alpha and beta.\ngamma.postln;\t// gamma is still nil.\n)\n\n\f\n //",
    "Figure 207": "Figure 5.15\nServer.default.boot; \t\t// (boot Server before running example)\n(\n// Define a function and call it in different contexts\nvar synth;\t\t\t\t// Synth creating the sound that is changed\nvar freq = 220; \t\t\t// frequency of the sound\nvar change_freq;\t\t\t// function that changes the frequency of the sound\nvar window;\t\t\t// window holding buttons for changing the sound\nvar button1, button2, button3; // buttons changing the sound\n\n// Create a synth that plays the sound to be controlled:\nsynth = { | freq = 220 | LFTri.ar([freq, freq * 2.01], 0, 0.1) }.play;\n// Create frequency changing function and store it in variable change_freq\nchange_freq = {\t\t\t\t\t\t// start of function definition\n\t\tfreq = freq * [0.9, 0.9.reciprocal].choose; // change freq value\n\t\tsynth.set(\\freq, freq);\t\t\t// set synth's frequency to new value\n};\t\t\t\t\t\t\t\t// end of function definition\n\n// Create 3 buttons that call the example function in various ways\nwindow = Window(\"Buttons Archaic\", Rect(400, 400, 340, 120));\n//  ------------------------- Example 1 -------------------------\nbutton1 = Button(window, Rect(10, 10, 100, 100));\nbutton1.states = [[\"I\"]]; // set the label of button1\n// button1 calls the function each time that it is pressed \nbutton1.action = change_freq;\t// make button1 change freq once\n//  ------------------------- Example 2 -------------------------\nbutton2 = Button(window, Rect(120, 10, 100, 100));\nbutton2.states = [[\"III\"]];\n// Button2 creates a routine that calls the example function 3 times\nbutton2.action = { \t\t\t// make button2 change freq 3 times\n\t{ 3 do: { change_freq.value; 0.4.wait } }.fork; // play as routine\n};\n//  ------------------------- Example 3 -------------------------\nbutton3 = Button(window, Rect(230, 10, 100, 100));\nbutton3.states = [[\"VIII\"]];\nbutton3.action = { \t\t\t// like example 2, but 8 times\n\t{ 8 do: { change_freq.value; 0.1.wait } }.fork; // play as routine\n};\n// use large size font for all buttons:\n[button1, button2, button3] do: _.font_(Font(\"Times\", 32));\n// stop the sound when the window closes: \nwindow.onClose = { synth.free };\nwindow.front; // show the window\n)\n\n\n\n\f\n //",
    "Figure 208": "Figure 5.18\n(\n// a function that calculates the square of the mean of two numbers\nvar sq_mean;\nsq_mean = { arg a, b; \t// arguments a, b defined in arg statement form\n\t(a + b / 2).squared;\n};\n// calculate the square of the mean of 3 and 1:\nsq_mean.value(3, 1);\n)\n\n\f\n //",
    "Figure 209": "Figure 5.19\n(\n// a function that calculates the square of the mean of any numbers\nvar sq_mean_all;\nsq_mean_all = { | ... numbers | // using ellipsis and | | argument form\n\t(numbers.sum / numbers.size).squared;\n};\n// calculate the square of the mean of [1, 3, 5, -7]:\nsq_mean_all.(1, 3, 5, -7); // short form: omit message 'value'\n)\n\n\f\n //",
    "Figure 210": "Figure 5.20\n(\nvar w_func;\nw_func = { arg message = \"warning!\", bounds = Rect(200, 500, 500, 100);\n\tvar window;\n\twindow = Window(\"message window\", bounds).front;\n\tTextView(window, window.view.bounds.insetBy(10, 10))\n\t\t.string = message;\t\n};\n // provide text, use default bounds\nw_func.(String.new.addAll(Array.new.addAll(\" Major news! \").pyramid(7)));\n)\n\n\f\n //",
    "Figure 211": "Figure 5.21\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot!\"], [\"quit!\"]];\nbutton.action = { |me| Server.default perform: [\\quit, \\boot][me.value] };\nwindow.front;\n)\n\n\f\n //",
    "Figure 212": "Figure 5.22\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot\"], [\"quit\"]];\nbutton.action = { | me | \n\t[{ \"QUITTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.quit;\n\t},{ \"BOOTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.boot;\n\t}][me.value].value;\n};\nwindow.front;\n)\n\n\n\f\n //",
    "Figure 213": "Figure 5.23\nServer.default.boot // boot default server before running example\n(\nvar buffer;\nbuffer = Buffer.read(path: \"sounds/a11wlk01.wav\",\n\taction: { | buffer |\n\t\tformat(\"loaded % at: %\", buffer, Main.elapsedTime).postln;\n\t});\nformat(\"Reached this after 'Buffer.read' at: %\", Main.elapsedTime).postln;\nbuffer;\n)\n\n\f\n //",
    "Figure 214": "Figure 5.24\nServer.default.boot;  // do this first\n(\t\t\t\t\t\t// then the rest of the program\nvar window, routine;\nwindow = Window(\"close me to stop\").front;\nwindow.onClose = { routine.stop };\nroutine = { \n\tloop {\n\t\t(degree: -10 + 30.xrand, dur: 0.05, amp: 0.1.rand).play;\n\t\t0.05.rand.wait;\n\t}\n}.fork;\n)\n\n\f\n //",
    "Figure 215": "Figure 5.25\n_.isPrime ! 10\n_.squared ! 10\n_@_.(30, 40) // equivalent to: { | a, b | Point(a, b) }.value(30, 40)\nArray.rand(12, 0, 1000).clump(4) collect: Rect(*_)\n(1..8).collect([\\a, \\b, _]);\n(a: _, b: _, c: _, d: _, e: _).(*Array.rand(5, 0, 100));\n\n\f\n //",
    "Figure 216": "Figure 5.26\n(\nvar iterative_factorial;\niterative_factorial = { | n |\n\tvar factorial = 1;\t// initialize factorial as factorial of 1\n\t// calculate factorial n times, updating its value each time\n\tn do: { | i | factorial = factorial * (i + 1) };\n\tfactorial;\t// return the final value of factorial;\n};\niterative_factorial.(10).postln;\t// 10 factorial: 3628800\n)\n\n\n\f\n//",
    "Figure 217": "Figure 5.27\n// Define the factorial function and store it in variable f:\nf = { | x | if ( x > 1) { x * thisFunction.value(x - 1) } { x } };\n f.value(10);\t\t\t// 10 factorial: 3628800\n\n\f\n //",
    "Figure 218": "Figure 5.28\n(\n/* a function that recursively prints all folders and files\n   found in a path and its subfolders */\n{ | path |\n\t// store function here for use inside the if's {}:\n\tvar thisFunc = thisFunction;\n\tformat(\"====== now exploring: %\", path).postln;\n\t// for all items in the path:\n\tpath.pathMatch do: { | p | \n\t\t// if the item is a folder, run this function on its contents\n\t\t// otherwise print the file found\n\t\tif (p.last == $/) { thisFunc.(p ++ \"*\") }{ p.postln }\n\t}\n}.(\"*\") // run function on home path of SuperCollider\n)\n\n\f\n//",
    "Figure 219": "Figure 5.29\n(\n// a function that creates a function that counts to any number\nvar counter_maker;\nvar window, button1, button2; // gui for testing the function\n\n// the function that makes the counting function\ncounter_maker = { | max_count |\n\t// current_count is used by the function created below\n\t// to store the number of times that it has run\n\tvar current_count = 0;  \n\t{\t// start of definition of the counting function\n\t\tif (current_count == max_count) {\n\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\tmax_count;\t\t// return max count for eventual use\n\t\t}{\n\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\tcurrent_count\t// return current count for eventual use\n\t\t}\n\t}\t// end of definition of the counting function \n};\n\n//  ----- Test application for the counter_maker function ----- \n// window displaying 2 buttons counting to different numbers\nwindow = Window(\"Counters\", Rect(400, 400, 200, 80));\n// make a button for triggering the counting: \nbutton1 = Button(window, Rect(10, 10, 180, 20));\nbutton1.states = [[\"counting to 10\"]];\t// labels for button1\n// make a function that counts to 10 and store it as action in button1\nbutton1.action = counter_maker.(10);\nbutton2 = Button(window, Rect(10, 40, 180, 20));\nbutton2.states = [[\"counting to 5\"]];\t// labels for button2\n// make a function that counts to 5 and store it as action in button2\nbutton2.action = counter_maker.(5);\nwindow.front;\t\t\t// show the window\n)\n\n\f\n//",
    "Figure 220": "Figure 5.31\n(\nvar counter_maker;\t\t// creator of counters\nvar make_counters_gui;\t// function making counters + a gui\n/* a function that creates an event that counts to any number, \n   and resets: */ \ncounter_maker = { | max_count |\n\tvar current_count = 0; \n\t(\t// the counter object is an event with 3 functions: \n\t\tcount1: // function 1: increment count (stored as count1)\n\t\t{\t// start of definition of the counting function\n\t\t\tif (current_count == max_count) {\n\t\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\t}{\n\t\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\t}\n\t\t},\t// end of definition of the counting function\n\t\treset_count: { // function 2: reset count (stored as reset_count)\n\t\t\tformat(\"resetting % counter\", max_count).postln;\n\t\t\tcurrent_count = 0\n\t\t},\n\t\tmax_count: { max_count } // function 3: return value of max_count\n\t)\n};\n// Function that makes several counters and a GUI to control them\nmake_counters_gui = { | ... counts |\n\tvar window, counter;\n\twindow = Window(\"Counters\", \n\t\t\tRect(400, 400, 200, 50 * counts.size + 10));\n\t// enable automatic placement of new items in window: \n\twindow.view.decorator = FlowLayout(window.view.bounds, 5@5, 5@5);\n\tcounts collect: counter_maker.(_) do: { | counter |  \n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Counting to: \" ++ counter.max_count.asString]])\n\t\t\t.action = { counter.count1 };\n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Reset\"]])\n\t\t\t.action = { counter.reset_count };\n\t};\n\twindow.front;\n};\nmake_counters_gui.(5, 10, 27); // example use of the GUI test function\n)\n\n\n\n\f\n//",
    "Figure 221": "Figure 5.32\nServer.default.boot;\t// boot the server first;\n(\nvar degrees, window, button;\nwindow = Window(\"melodies?\", Rect(400, 400, 200, 200));\nbutton = Button(window, window.view.bounds.insetBy(10, 10));\nbutton.states = [[\"click me to add a note\"]];\nbutton.action = { \n\tdegrees = degrees add: 0.rrand(15);\n\tPbind(\\degree, Pseq(degrees), \\dur, Prand([0.1, 0.2, 0.4], inf)).play;\n};\nwindow.front;\n)\n\n\f\n //",
    "Figure 222": "Figure 5.34\n1.class \t\t// the class of Integer 1: Integer\n1.class.class \t// the Class of the Class of Integer 1: Meta_Integer\n// the Class of the Class of the Class of Integer 1: \n1.class.class.class  \t\t\t\t\t// Class\n// the Class of the Class of the Class of the Class of Integer 1\n1.class.class.class.class\t\t\t\t// Meta_Class\n// the Class of the Class of the Class of the Class of the Class of 1\n1.class.class.class.class.class \t\t// Class \nClass.class\t\t\t\t// the Class of Class is Meta_Class\nMeta_Class.class\t\t// the Class of Meta_Class is Class\n\n\n\f\n //",
    "Figure 223": "Figure 5.36\nCounter { \n\t// variables: maximum count, current count\n\tvar <>max_count, <>current_count = 1;\n\t// class method for creating a new instance\n\t*new { | max_count = 10 |\n\t\t^super.new.max_count_(max_count)\n\t}\n\t// if maximum count not reached, increment count by 1\n\tcount1 {\n\t\tif (current_count >= max_count) {\n\t\t\tthis.changed(\\max_reached)\n\t\t}{\n\t\t\tcurrent_count = current_count + 1;\n\t\t\tthis.changed(\\count, current_count);\n\t\t}\n\t}\n\t// reset count\n\treset {\n\t\tcurrent_count = 1;\n\t\tthis.changed(\\reset);\n\t}\n}\n\n\f\n //",
    "Figure 224": "Figure 5.37\nServer.default.boot;\n(\nSynthDef(\"ping\", { | freq = 440 | \n\tOut.ar(0, \n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).send(Server.default);\n\nSynthDef(\"wham\", {\n\tOut.ar(0, BrownNoise.ar(\n\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).send(Server.default); \n)\n\n\f\n //",
    "Figure 225": "Figure 5.38\n(\n~sound_adapter =  { | counter, what, count |\n\tswitch (what, \n\t\t\\reset, { Synth(\"wham\"); },\n\t\t\\max_reached, { counter.reset },\n\t\t\\count, { Synth(\"ping\", \n\t\t\t[\\freq, count.postln * 10 + counter.max_count * 20]\n\t\t\t)\n\t\t}\n\t)\n};\n)\n //",
    "Figure 226": "Figure 5.39\n(\n~make_display = { | counter |\n\tvar window, label, adapter, stagger;\n\twindow = Window(\n\t\t\"counting to \" ++ counter.max_count.asString, \n\t\tRect(stagger = UniqueID.next % 20 * 20 + 400, stagger, 200, 50)\n\t);\n\tlabel = StaticText(window, window.view.bounds.insetBy(10, 10));\n\tadapter = { | counter, what, count |\n\t\t\t{ label.string = counter.current_count.asString }.defer\n\t};\n\tcounter addDependant: adapter;\n\t/* remove the adapter when window closes to prevent error in \n\t   updating non-existent views: */\n\twindow.onClose = { counter removeDependant: adapter };\n\twindow.front\n};\n)",
    "Figure 227": "Figure 6.1.  Example of a SynthDef\nSynthDef(\t\t\t\t\t\n\t\"sine\", \t\t\t\t// name of SynthDef\t\n\t{\t\t\t\t// function begins with a brace\n\t arg gate = 1, out = 0, \t\t// arguments serve as Control declarations\n freq = 400, amp = 0.4,\n pan = 0, ar = 1, dr = 1;\n\n\tvar audio;\t\t\t\n\taudio = SinOsc.ar(freq, 0, amp);\t\t// start with a SinOsc\n\taudio = audio * Linen.kr(gate, ar, 1, dr, 2);\t// apply an envelope\n\taudio = Pan2.ar(audio, pan);\t\t\t// stereo pan, \n\tOffsetOut.ar(out,audio);\t\t\t// to bus out and out+1 \n\t}\n).add;\t\t\t\t// make and store a SynthDesc and SynthDef",
    "Figure 228": "Figure 6.2. Example of a key/value Array and a note Event=\na = [ \n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n];\n\ne = (\n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n);\ne.play;\t\t\t\t\t// play the note",
    "Figure 229": "Figure  6.3. The OSC commands created by the note event\ne.asOSC.do{ | osc | osc.postcs };\n\n// the result that would be posted:\t\t\n//  [ 0.0, ['s_new', 'sine', 1000, 0, 1, 'out', 0, 'freq', 400.0, 'amp', 0.1, 'pan', 0, 'ar', 2, 'dr', 4] ]\n//  [ 2.0, [ 'n_set', 1000, 'gate', 0 ] ]",
    "Figure 230": "Figure 6.4. Two ways of writing the same Event Pattern\n\t1. Pbind( *[ \n\t\tdur:\t0.2,\nfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t] );\n\n\t2. Pbind( \n\t\t\\dur, 0.2,\n\t\t\\freq, \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t);",
    "Figure 231": "Figure 6.5. A more elaborate Event Pattern\np = Pbind(*[ \n\t\tinstrument:\t\\default,\n\t\tdetune:\t\t[0,1,3],\n\t\tfreq: \t\tPseq( (1..11) * 100,  4 * 5 * 7),\n\t\tdb:\t\tPseq([-20, -40, -30, -40], inf),\n\t\tpan:\t\tPseq([-1,0,1,0], inf),\n\t\tdur:\t\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8], inf),\n\t\tlegato:\t\tPseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n// render 40 seconds of the pattern in the file named \"sf.aif\"\t\n\tp.render(\"sounds/sf.aif\", 40)\t\n// now play the pattern in real-time\n\tp.play;",
    "Figure 232": "Figure 6.6.  Using Event types\n(\n\t(type: \t\\group, \t\nid: 2\n).play;\t\t\t\t\t// create a group with nodeID 2\n\n\t(\ttype:\t\t\\note, \t\t// play note\t\t\n\t \tsustain:\t100, \t\t// lasting 100 seconds\t\t\t\t\n\t \tgroup: \t\t2\t\t// in group 2\n\n\t ).play;\t\n\t \t\t\t\t\t\t\t\t\t\t\n)\n(\n\t(type: \t\\off, \tid: 2).play;\t\t// release all notes in the group\n\t(type:\t \\kill,\tid: 2,  lag: 3).play;\t// and free the group  3 seconds later\t\n)",
    "Figure 233": "Figure 6.7. Chord events\n// 2nd inversion - e loudest\n( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -20, -10] ).play\t\t\t\n// 2nd inversion - c loudest\n ( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -10, -20] ).play\t\n// note \"fattened\" by three detuned copies\n ( degree: 0,\t\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// each detune is assigned to a different pitch, fat free.\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// detune rotates through each note in the chord\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,0,0,3,3,3,5,5,5] ).play",
    "Figure 234": "Figure 6.8.  Interdependent key values in a Pattern\n\tPbind(*[\n\t\tstretch:\t\tPseg([0,0.1,0.2,1],8).linexp(0,1, 1,0.125),\n\t\tmidinote: \t\t100.cpsmidi,\n\t\tharmonic:\t\tPwhite(1, 16),\n\t\tlegato:\t\t\tPkey(\\stretch) * Pkey(\\harmonic)/2 ,\n\t\tdb:\t\t\t-10 - Pkey(\\harmonic),\n\t\tdetune:\t\t\tPwhite(0.0,3.0),\n\t\tdur:\t\t\t0.2,\n\t]).play",
    "Figure 235": "Figure 6.9. Chaining Event Patterns\n\ta = Pbind(*[\n\t\tscale: \tPn( Pstep([[0,2,4,5,7,9,11], [0,1,3,5,6,8,11] ], 5 ) ),\n\t\tdb:\tPn(Pseg([-20, -30, -25, -30], 0.4))\n\t]);\n\tb = Pbind(*[ \ndegree: Pbrown(0, 6, 1), \nmtranspose: Prand([\\rest, Pseq([0], 5.rand)],inf), \ndur: 0.2, \noctave: 6\n]);\n\tc = Pbind(*[ \ndegree: [0,2,4],  \nmtranspose: Pbrown(0, 6, 1), \ndur: 0.4, \ndb: -35\n]);\n\td = Pchain(Ppar([b, c]),a);\nd.play;",
    "Figure 236": "Figure 6.10. Using Proutine to define and play patterns on the fly\n\tProutine({| ev |\n\t\tvar pat, refPat;\n\n\t\trefPat = Pbind(*[dur: 0.2, note: Pseq([0,0, 0, 7,0, 7])]);\n\n\t\tloop {\n\t\t\tev = refPat.embedInStream(ev);\n\n\t\t\tpat = Pbind(*[\n\t\t\t\tdur: [0.2, 0.4].choose,\n\t\t\t\tnote: Pseq(Array.fill(5, { 10.rand }), 3.rand )\n\t\t\t]);\t\nev = pat.embedInStream(ev);\n\t\t}\n\t\n}).play",
    "Figure 237": "Figure 6.11.  Using Proutine to define value and event patterns\n~patA = Pbind(*[\n\tdur:\t0.2,\n\tdegree: Proutine({ | ev |\n\t\tvar noteArray  = (0..5);\n\t\tloop {\n\t\t\tev = Pseq(noteArray ).embedInStream(ev);\n\t\t\tnoteArray[6.rand] = 7.rand;\n\t\t}\t\t\n\t})\n]);\n\n\n~patB = Proutine({ | ev |\n\tvar pat, pats= [\n\t \tPbind(*[ degree: Pseq([  0, 7]), dur: 0.2   ]),\n\t \tPbind(*[ degree: Pseq([11, 7]), dur: 0.2 ]),\n\t\tPbind(*[ degree: Pseq([16, 7]), dur: 0.2 ]).\n\t\t(type: \\rest, delta: 1)\n\t];\n\t\t\t\n\tloop {\n\t\tpat = pats.choose;\n\t\tev = pat.embedInStream(ev);\n\t}\n});\n\nPchain(\n\tPbind(*[\n\t\tdb: \tPn(Pstep([-15, -25,-25, -20, -30, -25], 0.2) )\n\t\t\t+ Pseg([-30, -5,-10, -40], 12)\n\t]), \n\tPtpar([\n\t\t0, ~patA, \n\t\t0,  ~patA, \n\t\t12,  ~patB\n\t]) \n).play;",
    "Figure 238": "Figure 6.12.  Rendering and playing a pattern\n\t~pattern = Pbind(*[ \n\t\tinstrument:\t\"default\",\n\t\tfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100], 5),\n\t\tdb:\tPseq([-10, -30, -20, -30], inf),\n\t\tdur:\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8],inf),\n\t\tlegato: Pseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n\n\t~score = ~pattern.asScore(24 * 11/7);\n\t~score.render(\"recordings/test.aif\");\n\tSoundFile(\"recordings/test.aif\").play;",
    "Figure 239": "Figure 6.13. Soundfile granulation with a Pattern \nSynthDef(\"playbuf\", { | out=0, bufnum = 0, rate = 1, \nstartPos = 0, amp = 0.1, sustain = 1, \npan = 0, gate = 1|\n\tvar audio, env;\n\trate = rate * BufRateScale.kr(bufnum);\n\tstartPos = startPos * BufFrames.kr(bufnum);\n\tenv = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: 2);\n\taudio = PlayBuf.ar(1, bufnum, rate, 1, startPos, 0);\n\taudio = env * audio;\n\taudio = Pan2.ar(audio, pan, amp);\n\tOffsetOut.ar(out, audio);\n}).add;\n\t\t\n\tPseq([\n\t\t(\ttype:\t\t\\load,\n\t\t\tfilename:\t\"sounds/a11wlk01.wav\",\n\t\t\tbufnum:\t1,\n\t\t\tdelta:\t\t0\n\t\t),\n\t\t\n\t\tPbind(*[\n\t\t\tinstrument:\t\"playbuf\",\n\t\t\ttype:\t\t\\on,\n\t\t\tid:\t\t-1,\n\t\t\tdur:\t\t Pseg([0,1],21).linexp(0,1,0.01,2),\n\t\t\tlegato:\t\t4,\n\t\t\tstartPos:\tPn(Pseg([0,1], 10)),\n\t\t\tbufnum:\t1,\t\t\n\t\t]),\n\t\t(\ttype:\t\t\\free, \n\t\t\tbufnum: \t1\n\t\t)\n\t]).play(quant: 0) \n// the result: [ ( 'midinote': 60 ), ( 'midinote': 64 ), ( 'midinote': 67 ) ]",
    "Figure 240": "Figure 6.14.  Yield versus EmbedInStream\n\tr = Routine{ \n\t\tPseq([1,2,3]).yield; \n\t\tPseq([1,2,3]).embedInStream;\n\t\t123445.embedInStream; \n\t\t123445.embedInStream; \n\t};\n\n\t[next(r), next(r), next(r), next(r), next(r), next(r)];\n\t// the result: [ a Pseq, 1, 2, 3, 123445, 123445, nil]",
    "Figure 241": "Figure 6.15. The definition of the stream created by Pseq.\n\tRoutine({\n\t\trepeats.value.do({\n\t\t\tlist.size.do({ arg i;\n\t\t\t\titem = list.wrapAt(i + offsetValue);\n\t\t\t\tinval = item.embedInStream(inval);\n\t\t\t});\n\t\t});\n\t});",
    "Figure 242": "Figure 6.16.  The definition of Event\u00d5s play method.\n\tplay {\n\t\tif (parent.isNil) { parent = defaultParentEvent };\n\t\tthis.use { ~play.value };\n\t}",
    "Figure 243": "Figure 6.17. Definition of the key \\play in the default event\n{\n\tvar tempo, server;\n\t\n\t~finish.value;\t\t\t\t\t\t// user callback \n\tserver = ~server ?? { Server.default };\t \n\ttempo = ~tempo;\t\t\t\t\t// assigning to a variable\n\t\t\t\t\t\t\t\t\t// saves repeated look ups\n\tif (tempo.notNil) {\t\t\t\t\t// if not nil, change tempo of\n\t\tthisThread.clock.tempo = tempo;\t// the clock playing the pattern\n\t};\n\t~eventTypes[~type].value(server);\t\t// select play function from ~type\n}",
    "Figure 244": "Figure 6.18.  Implementation of the event type \\bus.\n\t{ |server|\n\t\tvar lag, array;\n\t\tlag = ~lag + server.latency;\n\t\tarray = ~array.asArray;\n\t\tserver.sendBundle(lag, \n\t\t\t[\\c_setn, ~out.asUGenInput, array.size] ++ array);\n\t}",
    "Figure 245": "Figure 7.1: A modulo algorithm that operates over states of variables\n(\nTask {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(note: x.postln, dur: 0.125).play;\n\t\t0.125.wait;\n\t}\n}.play\n);\t\t// creates a loop of values\n\n// change x and y\nx = 5;\t// new initial value\ny = 4;\t// new multiplication factor\n\n\n\n//",
    "Figure 246": "Figure 7.2: Synthesis graph\n\n(\n{\n\tx = SinOsc.kr(4); \n\ty = SinOsc.kr(13);\n\tSinOsc.ar(x * y % 0.4 * 500 + 600) * 0.2\n}.play;\n)\n\n// change x and y?\nx = SinOsc.kr(4); // no effect.\ny = SinOsc.kr(4); // no effect either.\n\n\n//",
    "Figure 247": "Figure 7.3: Dynamic synthesis graph\n\np = ProxySpace.push;\n~x = { SinOsc.kr(4) }; \n~y = { SinOsc.kr(13) };\n~z = { SinOsc.ar(~x * ~y % 0.4 * 500 + 600) * 0.2 };\n~z.play;\n\n\t\n// now ~x and ~y can be replaced\n~x = { SinOsc.kr(0.4) }; \n~y = { SinOsc.kr(1.3) }; \n\np.clear(2).pop; // release environment (2 sec fadeout)\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n///////////////////  3 ProxySpace, Ndef, and NodeProxy  /////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n//",
    "Figure 248": "Figure 7.4: Refactoring a synthesis graph at runtime\n\np = ProxySpace.push;\t// if needed\n\n~a = { Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2) };\n(\n~b = {\n\tvar c, d;\n\tc = Dust.ar(20 ! 2);\n\td = Decay2.ar(c, 0.01, 0.02, SinOsc.ar(11300));\n\td + BPF.ar(c * 5, ~a.ar * 3000 + 1000, 0.1)\n}\n);\n\n~b.play;\n\n// the refactored code from above\n\n(\n~a = { \n\tvar a;\n\ta =  Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2);\n\tBPF.ar(~c.ar * 5, a * 3000 + 1000, 0.1) \n}\n);\n~c = { Dust.ar(20 ! 2) };\n~d = { Decay2.ar(~c.ar, 0.01, 0.02, SinOsc.ar(11300)) };\n~b = ~a + ~d;\n\n~b.play;\n\n\n\n//",
    "Figure 249": "Figure 7.6: A dynamic graph of a chaotic linear congruence. \n// self reference (~x) constructs a loop at control rate \n\n~out.play;\n~x = 0.2; ~a = 1.1; ~c = 0.13;\n~x = (~a * ~x) + ~c % 1.0;  // leaving out the .kr message assumes a control rate ugen.\n\n~out = { Pan2.ar(SinOsc.ar(~x * 4000 + 200) * 0.1, ~x) };\n\n\n\n//",
    "Figure 250": "Figure 7.7: Creating a proxy object explicitly and changing its source\nn = NodeProxy.new;\nx = { SinOsc.ar(n.kr * 200 + 300) * 0.1 }.play;\nn.source = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\nn.clear; x.free;\n\n//",
    "Figure 251": "Figure 7.8: Unified creation and access syntax with Ndef\n\nNdef(\\out, { SinOsc.ar(Ndef.kr(\\x) * 200 + 300) * 0.1 }).play;\nNdef(\\x, { LFPulse.kr([1.3, 2.1, 3.2]).sum });\nNdef.clear;\n\n//",
    "Figure 252": "Figure 7.9: Unified creation and access syntax within an environment\np = ProxySpace.push; // if needed\n~out = { SinOsc.ar(~x.kr * 200 + 300) * 0.1 }\n~out.play;\n~x = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\np.clear.pop;\n\n\n\n//",
    "Figure 253": "Figure 7.10: Initialisation of node proxies in the proxy space\n\np.clear; // neutralize space, free all buses and synths\np.push; // if needed\n~a.ar(3); // 3 channels, audio rate\n~b.kr(8); // 8 channels, control rate\n~c.play; // playing an uninitialized proxy assumes (per default) 2 channels, audio rate\n~d = { LFNoise0.kr([1, 1, 1, 1]) }; // 4 channels, control rate\n\n\n\n\n//",
    "Figure 254": "Figure 7.11: Parameter mapping and setting\n\n~out.play; ~out.fadeTime = 3;\n(\n// name with a_ represents audio rate argument\n~out = { |freq=440, mod=0.4, detune=0.1, a_in = #[1,1]|\n\tfreq = freq * ([0, detune] + 1);\n\tLFTri.ar(LFTri.ar(mod * freq).range(freq * mod, freq)) * a_in * 0.2\n}\n);\n\n~mod2 = { LFNoise1.kr(1).range(0, 1) };\n~mod1 =  { LFPulse.kr(~mod2.kr * 30 + 1, 0, 0.3) };\n~freq1 = { ~mod1.kr * 13100 + 100 };\n~freq2 = { LFTri.kr(30) * 200 + 300 };\n~audio1 = { BrownNoise.ar(LFClipNoise.kr(10.dup), 1) };\n~audio2 = { SinOsc.ar(LFNoise2.kr(1.dup).exprange(4, 1000)) };\n\n~out.map(\\freq, ~freq2, \\mod, ~mod1);\n~out.set(\\detune, 0.01);\n~out.map(\\freq, ~freq1, \\mod, ~mod1);\n~out.xmap(\\freq, ~freq1, \\mod, ~mod2); // xmap crossfades over fade time to new value.\n~out.xmap(\\freq, ~freq2, \\mod, ~mod1, \\a_in, ~audio2);\n~out.map(\\a_in, ~audio1);\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////  4 Structured waiting and rewriting: TaskProxy, Tdef  ////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n\n//",
    "Figure 255": "Figure 7.12: Rewriting a synth def and a task def while running\n// this synthdef is used in the subsequent figures\n(\nSynthDef(\\wave, { |out, freq=440, amp=0.1, sustain=0.1, mod=0.2|\n\tOffsetOut.ar(out,\n\t\tEnvGen.ar(Env.perc(ExpRand(0.001, 0.05), sustain, amp), doneAction: 2)\n\t\t*\n\t\tSinOsc.ar(freq, SinOsc.ar(sustain.reciprocal * 8, [0, Rand(0, pi)], mod))\n\t)\n}).add\n);\n(\nTdef(\\x, {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(instrument: \\wave, note: x.postln, sustain: 0.5, octave: 6).play;\n\t\t0.125.wait;\n\t}\n}).play\n);\n\n\n//",
    "Figure 256": "Figure 7.13: Embed and fork of different tasks\n\n(\n\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 1500).play; 0.03.wait } });\nTdef(\\b, { [1, 5, 1, 2, 8, 4, 12].do { |x| (instrument: \\wave, note: x + 8).play; 0.1.wait } });\nTdef(\\c, { \"c is just a waiting message\".postln; 2.wait; });\n\n\nTdef(\\x, {\n\tloop {\n\t\tTdef(\\a).embed; // play in sequence\n\t\t1.wait;\n\t\tTdef(\\b).embed;\n\t\t2.wait;\n\t\tTdef(\\a).fork; // play in parallel\n\t\tTdef(\\b).fork;\n\t\tTdef(\\c).embed;\n\t}\n}).play\n);\n\n// rewrite with infinite loop\nTdef(\\a, { inf.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } }); \n// rewrite with finite loop\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } });\n\n\n//",
    "Figure 257": "Figure 7.14: Passing an environment into a task proxy when embedding\n(\nTdef(\\a, { |in|\n\tin.at(\\n).do { |i| \n\t\tin = (instrument: \\wave, detune: 5.rand2).putAll(in);\n\t\tin.postln.play; \n\t\tin.delta.wait;\n\t} \n})\n);\n\n(\nTdef(\\x, { |inevent|\n\tloop {\n\t\tTdef(\\a).embed((note: [15, 17], dur: 0.01, n: 13));\n\t\t1.wait;\n\t\tTdef(\\a).embed((note: 9, dur: 0.4, n: 4));\n\t\t1.wait;\n\t}\n}).play;\n)\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////   5 Empty Patterns    /////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n//",
    "Figure 258": "Figure 7.15: A pattern proxy as an entry point into a stream\n\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3], inf));\n(\nTask {\n\tvar stream = Pdefn(\\x).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next; \n\t\t(instrument: \\wave, note: val).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\nPdefn(\\x, Pseq([0, 2, 0, 8, 6, 5, 2, 3, 4, 5], inf)); // rewrite the definition at runtime.\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 4, inf));\n\n\n\n//",
    "Figure 259": "Figure 7.16: Deriving variations fom nonexisting streams by mathematical operations\n\nPdefn(\\y, Pdefn(\\x) + 2); // derive a transposition\nPdefn(\\z, Pdefn(\\x) + Pseq([0, 5, 0, 7, 2], inf)); // derive a variation\nPdefn(\\a, Ptuple([Pdefn(\\y), Pdefn(\\z)])); // combine them in a stream of arrays\n(\nTask {\n\tvar stream = Pdefn(\\a).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next.postln; \n\t\t(instrument: \\wave, note: val, sustain: rrand(0.5, 0.9)).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\n// rewriting the definitions causes all derivations to vary\nPdefn(\\x, Pseq([0, 11], inf));\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 5, inf));\nPdefn(\\z, Pdefn(\\x) + Pseq([1, 5, 1, 11, 1], inf)); // change a variation\n\nPdefn(\\a, 5); // a number as a source\nPdefn.clear; // clearing all - the empty pattern returns a series of 1. \n\n\n\n//",
    "Figure 260": "Figure 7.17: Pdef - play, pause and resume.\n\nPdef(\\a).play; // play silence in sequence\nPdef(\\a, Pbind(\\instrument, \\wave)); // insert a sequence of notes\nPdef(\\a, Pbind(\\instrument, \\wave, \\dur, Pseq([1, 3, 2, 3], inf) / 6)); // add some rhythm\nPdef(\\a).pause;\nPdef(\\a).resume;\nPdef(\\a).stop;\n\n\n\n//",
    "Figure 261": "Figure 7.18: A larger combination of Pdefs\n(\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\mod, Pseq([1, 0, 1, 0], inf), \n\t\t\\dur, Pn(1/2, 8),\n\t\t\\note, 7\n\t)\n)\n);\n\n(\nPdef(\\y,\n\tPbindf(\n\t\tPdef(\\x),\n\t\t\\amp, 0.2,\n\t\t\\note, Pshuf([0, 2, 3, 5], 2) + Prand([0, 5, [0, 4]], inf),\n\t\t\\dur, Pseq([1, 3, 2, 3], inf) / 6\n\t)\n)\n);\n\n(\nPdef(\\z, Pbindf(Pdef(\\y), \\dur, 1/4))\n);\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPseq([\n\t\t\tPpar([Pdef(\\x), Pdef(\\y)]),\n\t\t\tPdef(\\x),\n\t\t\tPdef(\\y),\n\t\t\tPdef(\\z),\n\t\t\tPpar([Pdef(\\x), Pbindf(Pdef(\\y), \\ctranspose, 2)])\n\t\t], inf)\n\t)\n);\n))\n\nPdef(\\a).play; // play it\n\n// go into a looping vamp\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], inf) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\n// release a break\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], 1) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\nPdef(\\a).stop; // stop the player\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////  6 Symbol streams and recursive patterns  /////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n//",
    "Figure 262": "Figure 7.19: Simplifying the code in",
    "Figure 263": "Figure 12.18 using Psym\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\b, Pbindf(Pdef(\\y), \\ctranspose, 2));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf).trace) // trace it to post which\n\t)\n).play;\n)\n\n//",
    "Figure 264": "Figure 7.20: Using a Pdefn for the sequence of symbols itself\n(\nPdefn(\\sequence, Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pdefn(\\sequence).trace)\n\t)\n).play;\n)\n\n// rewrite the sequence\nPdefn(\\sequence, Pseq([\\x], inf));\nPdefn(\\sequence, Pseq([\\x, \\y, \\x, [\\x, \\y]], inf));\n\nPdef(\\a).stop; // stop playing\n\n\n//",
    "Figure 265": "Figure 7.21: Event type 'phrase'\n\n(instrument: \\x, type: \\phrase).play; // a single phrase from Pdef(\\x)\n\n// a pattern of overlapping phrases\n(\nPbind(\n\t\\type, \\phrase, \n\t\\instrument, \\x, \n\t\\legato, 2.5, \n\t\\note, Pseq([0, 5, 7], inf)\n).play\n);\n\n\n//",
    "Figure 266": "Figure 7.22: Recursive phrasing\n(\nPdef(\\x, { |note=0, n=6, step=3, modulo=15, sustain=1|  \n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\note, note.value + (Pseries(1, step, n) % modulo) + 7, \n\t\t\\dur, sustain.value / n\n\t) \n})\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Pseq([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf)\n\t)\n).play\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Prand([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\recursionLevel, 1,\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf) * 2\n\t)\n).play\n);\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////////  8 Combinatorics  /////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n//",
    "Figure 267": "Figure 7.25: Combinations between patterns and ugen graphs\n\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\np = ProxySpace.push;\n~z.play;\n\n// A pattern in an audio rate node proxy ...\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), // only non-standard keys, i.e. xfreq \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n~y = { Ringz.ar(~x.ar, 5000 * [1, 1.2], 0.01) }; // resonant filter on the impulses from ~x\n~mod = { LFNoise1.kr(0.1).exprange(200, 5000) }; // a modulator\n~z = { ~y.ar * (SinOsc.ar(~mod.kr) + 1) }; // ring modulation with frequency ~mod\n\n// ... and a control rate node proxy in a pattern.\n// To pass on modulation like this, the standard event parameters like freq cannot be used.\n// Here, we use xfreq instead.\n\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, ~mod, 5, ~mod, 19], inf), // read from the ~mod proxy bus. \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n\n//",
    "Figure 268": "Figure 7.26 The same functionality, using Ndef instead of ProxySpace.\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\nNdef(\\z).play;\n\n// a pattern in an audio rate node proxy ...\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\nNdef(\\y, { Ringz.ar(Ndef(\\x).ar, 5000 * [1, 1.2], 0.01) });\nNdef(\\mod, { LFNoise1.kr(0.1).exprange(200, 5000) });\nNdef(\\z, { Ndef(\\y).ar * (SinOsc.ar(Ndef(\\mod).kr) + 1) }); // ring modulation with Ndef(\\mod)\n\n// ... and a control rate node proxy in a pattern\n\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Ndef(\\mod), 5, Ndef(\\mod), 19], inf), // read from the Ndef(\\mod) proxy bus\n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\n\n\n//",
    "Figure 269": "Figure 7.27: Using a Tdef to create overlapping synths within a node proxy\n\n\nNdef(\\x).play; // here an Ndef is used, the same can be done within a ProxySpace\nNdef(\\x, { |freq=5, detune=0| Impulse.ar(freq * [detune, 1 - detune]) * 0.2 });\n(\nTdef(\\c, {\n\tloop {\n\t\t Ndef(\\x).fadeTime = rrand(0.1, 3.5);\n\t\t Ndef(\\x).send([\\freq, exprand(2, 400), \\detune, [0.0, 1.0].choose.rand]);\n\t\t2.wait;\n\t}\n}).play\n);",
    "Figure 270": "figures /////////////////// \n\n\n\n\t//",
    "Figure 271": "figure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently\n\n\n\n\n\n\n\n\t//",
    "Figure 272": "figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)\n\n\n\n\n\n\t//",
    "Figure 273": "figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test\n\n\n\n\n\n\n\t//",
    "Figure 274": "figure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done\n\n\n\n\t//",
    "Figure 275": "figure 8.5 - add a pseudo-method.\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin; \nz.makeWin(\"Try showing that.\"); \n\n\n\n\n\n\t//",
    "Figure 276": "figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?\n\n\n\n\n\n\t//",
    "Figure 277": "figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given\n\n\n\n\n\n\t//",
    "Figure 278": "figure 8.8 is an image - \"c6_ObjMod_fig8.8_shoutWin.png\"\n\n\n\n\n\n\t//",
    "Figure 279": "figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!\n\n\n\n\n\n\t//",
    "Figure 280": "figure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");\n\n\n\n\n\n\n\t//",
    "Figure 281": "figure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;\n\n\n\n\n\t//",
    "Figure 282": "figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;\n\n\n\n\n\t//",
    "Figure 283": "figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");\n\n\n\n\n\n\n\t//",
    "Figure 284": "figure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window\n\n\n\n\n\n\n\t//",
    "Figure 285": "figure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;\n\n\n\n\n\n \n\t//",
    "Figure 286": "figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));\n\n\n\n\n\n\n\n\t//",
    "Figure 287": "figure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.\n\n\n\n\n\n\n\t//",
    "Figure 288": "figure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}\n\n\n\n\n\n\n\t//",
    "Figure 289": "figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}\n\n\n\n\n\n\n\t//",
    "Figure 290": "figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}\n\n\n\n\n\n\n\n//",
    "Figure 291": "figure 8.21 \u00d1 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});\n\n\n\n\n\n///////// continued in ObjMod2_codefigures.rtf /////",
    "Figure 292": "figure 8.23 - two granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\percSin);\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t//",
    "Figure 293": "figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n\n\t//",
    "Figure 294": "figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n\n\n\n\n\n\t//",
    "Figure 295": "figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 8.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t//",
    "Figure 296": "figure 8.28 is an image: the CloudGenMini GUI, file \"c8_ObjMod_8.29_cloudGenGui.png\"  //\n\n\n\n\n\t//",
    "Figure 297": "figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)))).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);",
    "Figure 298": "figures /////////////////// \n\n\n\n\t// error and doesNotUnderstand\n{ SinOsc.ar }.pay; \n\n\nq = ( ); \t\nq[\\melA] = [0, 2, 3];\nq[\\melA] + 10;\n\n\t// Equivalently, put and at operations can be written like getter and setter messages: \nq.melA_([0, 2, 3]); \t\n\t// Or also:\nq.melA = [0, 2, 3];\nq.melA + 7; \n\n\t// One can organize repositories of objects hierarchically as well:\nq.mels = ();\nq.mels.melA = [0, 2, 3];\n\n\t// functions are special:\nq.playMel = { |ev| Pbind(\\note, Pseq(ev.melA), \\dur, 0.2).play };\nq.playMel;\n\n\n\n\t//",
    "Figure 299": "figure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently\n\n\n\n\n\n\n\n\t//",
    "Figure 300": "figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)\n\n\n\n\n\t//",
    "Figure 301": "figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test\n\n\n\n\n\n////////////////////// Shout Window ///////////////////////\n\n\t//",
    "Figure 302": "figure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done\n\n\n\n\t//",
    "Figure 303": "figure 8.5 - add a pseudo-method.\n\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin; \nz.makeWin(\"Try showing that.\"); \n\n\n\n\n\n\t//",
    "Figure 304": "figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?\n\n\n\n\n\n\t//",
    "Figure 305": "figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given\n\n\n\n\n\n\t//",
    "Figure 306": "figure 8.8 is an image // \n\n\n\n\n\n\t//",
    "Figure 307": "figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!\n\n\n\n\n\n\t//",
    "Figure 308": "figure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");\n\n\n\n\n\t// class files can be put into one of these locations:\nPlatform.userExtensionDir; \nPlatform.systemExtensionDir;\n\n\n\t//",
    "Figure 309": "figure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;\n\n\n\n\n\t//",
    "Figure 310": "figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;\n\n\n\n\n\t//",
    "Figure 311": "figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");\n\n\n\n\n\n\n\t//",
    "Figure 312": "figure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window\n\n\n\n\n\t//",
    "Figure 313": "figure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00ca\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;\n\n\n\n \n\t//",
    "Figure 314": "figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));\n\n\n\n\n\n\t//",
    "Figure 315": "figure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.\n\n\n\n\n\t//",
    "Figure 316": "figure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}\n\n\n\n///////////////////////////////// QCD /////////////////////////\n\n\n\t// no",
    "Figure 317": "figure - converting QCD data files (text) to soundfiles.\n(\nq = q ? ();\nq.data = \"~/data/share/QCD/data/*.nojunk\".pathMatch.collect{|path|\n\ta = FileReader.read((path), true, true, _.asFloat * 0.03125 ).flat.as(Signal);\n\tb = SoundFile.new;\n\tb.openWrite(path.replace(\"txt.nojunk\", \"aiff\"));\n\tb.writeData(a).postln;\n\tb.close; \n\ta;\t\n}\n)\n\n\n\n\n\t//",
    "Figure 318": "figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}\n\n\n\n\t//",
    "Figure 319": "figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}\n\n\n\n\n//",
    "Figure 320": "figure 8.21 here \u00d1 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});\n\n\n\n\n\n///////// continued in ObjMod2_CloudGenMini.scd /////",
    "Figure 321": "figure 8.23 - some granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp * AmpComp.ir(freq) * 0.5, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp * AmpComp.ir(freq) * 0.5, 4), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).memStore;\n\n\t\t// a noise band grain with percussive envelope\nSynthDef(\\percNoise, { |out, amp=0.2, freq=440, sustain=0.01, pan, rq=0.1| \n\tvar snd = BPF.ar(GrayNoise.ar, freq, rq, 3);\n\tvar env = EnvGen.ar(Env.perc, timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, \n\t\tPan2.ar(snd * env, pan, amp)\n\t);\n}, \\ir ! 6).memStore\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\gabWide);\nSynth(\\percSin);\nSynth(\\percSinRev);\n\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\percNoise, [\\amp, 0.2, \\sustain, 0.1]);\n\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);\n\n\n\n\n\n\t//",
    "Figure 322": "figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);\n\n\n\n\n/*\n\t//",
    "Figure 323": "figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.synName = \\gabWide;\nd.synName = \\percSinRev;\nd.synName = \\percNoise;\nd.synName = \\percSinRev;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);\n\n\n*/\n\n\n\n\n\t//",
    "Figure 324": "figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);\n\n\n\n\n\t// ex. 8.27 - crossfading between different settings with a taskproxy\n\t\n(\n\t// and some parameters for controlling the fade\nd.stopAfterFade = false;\nd.xfadeTime = 5; \n\nd.morphtask = TaskProxy({\n\tvar startSet = d[\\current], endSet = d[\\target];\n\tvar stepsPerSec = 20;\n\tvar numSteps = d.xfadeTime * stepsPerSec;\n\tvar blendVal, morphSettings;\n\t\n\tif (d.target.notNil) { \n\t\t(numSteps).do { |i| \n\t\t//\t[\"numSteps\", i].postln;\n\t\t\tblendVal = (i + 1) / numSteps; \n\t\t\tmorphSettings = endSet.collect({ |val, key| \n\t\t\t\t(startSet[key] ? val).blend(val, blendVal) \n\t\t\t});\n\t\t\td.current_(morphSettings);\n\t\t\t(1/stepsPerSec).wait;\n\t\t};\n\t\td.current_(d.target.copy);\n\t\t\"morph done.\".postln;\n\t\tif (d.stopAfterFade) { Tdef(\\cloud0).stop; };\n\t};\n}).quant_(0);\t\t// no quantization so the task starts immediately\n\n/* test morphing\n(\nTdef(\\cloud0).play;\nd.target = d.set6.copy;\nd.morphtask.play;\n)\nTdef(\\cloud0).stop;\n\n\t// playing a a finite cloud with tendency mask: \n(\nTdef(\\cloud0).play;\t\t// begin playing\nd.stopAfterFade = true; \t// end cloud when crossfade ends\nd.xfadeTime = 10; \t\t\t// set fade time\nd.target = d.set8.copy;\t\t// and target\nd.morphtask.play;\t\t\t// and start crossfade.\n)\n*/\n\n\t// put fading into its own method, with optional stop.\nd.fadeTo = { |d, start, end, time, autoStop| \n\td.current = d[start] ? d.current;\n\td.target = d[end]; \n\td.xfadeTime = time ? d.xfadeTime;\n\tif (autoStop.notNil) { d.stopAfterFade = autoStop };\n\td.morphtask.stop.play;\n};\n\n/* \t// tests fadeTo:\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set2, 20);\nd.fadeTo(\\current, \\set6, 10);\nd.fadeTo(\\current, \\set5, 3, true);\n\nTdef(\\cloud0).play;\nd.fadeTo(\\current, \\set1, 3, false);\n*/ \n);\n\n\n\n\t//",
    "Figure 325": "figure 8.28 is an image, the CloudGenMini GUI //\n\n\n\n\n\t//",
    "Figure 326": "figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@300)))).front;\n\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefEditor(tdef, height: 20, w: w); \n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);",
    "Figure 327": "Figure 2.1 */\nServer.default = s = Server.internal;\n\ns.boot;\n\nz = s.scope(4);\n\n// a) mono output\n(\nSynthDef(\\UGen_ex1a, {\n\tOut.ar(0, SinOsc.ar(440, 0, 0.1))\n}).add\n)\t\n\na= Synth(\\UGen_ex1a);\n\na.free;\n\n// b) freq input is an Array of 4 items - outputs to busses 0-3\n(\nSynthDef(\\UGen_ex1b, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, 0.1))\n}).add\n)\t\n\na= Synth(\\UGen_ex1b);\n\na.free;\n\n// c) Array is added to the 'mul' arg to show mapping\n(\nSynthDef(\\UGen_ex1c, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3, 0.4]))\n}).add;\n)\t\n\na= Synth(\\UGen_ex1c);\n\na.free;\n\n// d) The output of the SinOsc above is actually an Array of four SinOscs. Sum them       // together for an additive synthesis example.\n(\nSynthDef(\\UGen_ex1d, {\n\tOut.ar(0, SinOsc.ar([440, 446, 448.5, 882], 0, [0.1, 0.2, 0.3]).sum);\n}).add\n)\t\n\na= Synth(\\UGen_ex1d);\n\na.free;\n\nz.window.close;",
    "Figure 328": "Figure 2.2 */\n\nServer.default = s = Server.internal.boot;\n\nz = s.scope;\n(\nSynthDef(\\UGen_ex2, {arg freq = 440;\n\tvar src, compressor, limiter, out;\n\t// 10 SinOsc's, mixed together. Output amplitude is controlled with an Dust UGen\n \t// wrapped in a Decay2 UGen to create a spike with an Exponential Decay\n\tsrc = SinOsc.ar(\n\t\t// a harmonic series based on freq\n\t\tArray.series(10, freq, freq),\n\t\t0, // phase\n\t\tArray.fill(10, {Decay2.ar( \n\t\t\t// Dust will create an impulse about every 2 seconds, with values between 0\n\t\t\t// and 5\n\t\t\tDust.ar(0.1, 5),\n\t\t\t// Decay2, attach time of 0.01 seconds and a decay time of 5 seconds to\n\t\t\t// allow for a build up of signal\n\t\t\t0.01, 5)});\n\t\t).sum;\n\t// compress signal about 0.5\n\tcompressor = Compander.ar(src, src, 0.5, 1, 0.1);\n\tlimiter = Limiter.ar(compressor, 0.5);\n\t// out is the compressed only signal on the left, the compressed and limited on the \n\t// right\n\tout = [DelayN.ar(compressor, 0.02, 0.02), limiter];\n\t// use Peak and poll to track the highest output values. Updates every second\n\tPeak.ar(out ++  src, Impulse.kr(1)).poll(1, [\"compressed\", \"limited\", \"src\"]);\n\tOut.ar(0, out);\n}).add;\n)\t\na = Synth(\\UGen_ex2, [\\freq, 440]);\n\na.free; z.window.close;",
    "Figure 329": "Figure 2.3 */\n(\nSynthDef(\\UGen_ex3, {arg gate = 1, amp = 1, rate = 10;\n\tvar trigger, dur, carfreq, modfreq, index, pan, env;\n\ttrigger = Impulse.ar(rate);\n\tdur = rate.reciprocal;\n\tcarfreq = LFNoise2.kr.range(100, 110);\n\tmodfreq = LFTri.kr(0.1).exprange(200, 840);\n\tindex = LFCub.kr(0.2).range(4, 10);\n\tpan = WhiteNoise.ar.range(-0.1, 0.1);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1),\n\t\tgate,\n\t\tlevelScale: amp,\n\t\tdoneAction: 2);\n\tOut.ar(0,\n\t\tGrainFM.ar(2, trigger, dur, carfreq, modfreq, index,\n\t\t\tpan, -1) * env)\n}).add;\n)\na = Synth(\\UGen_ex3, [\\rate, 80, \\amp, 0.2]);\n\nb = Synth(\\UGen_ex3, [\\rate, 42, \\amp, 0.2]);\n\nc = Synth(\\UGen_ex3, [\\rate, 121, \\amp, 0.2]);\n\n[a, b, c].do({arg thisSynth; thisSynth.set(\\gate, 0)});",
    "Figure 330": "Figure 2.4 */\n\n(\nSynthDef(\\UGen_ex4a, {arg id, limit = 1;\n\tvar src, pitch, hasPitch, keynum, outOfTune;\n\t// read input\n\tsrc = SoundIn.ar(0);\n\t// analyze the frequency of the input\n\t#pitch, hasPitch = Pitch.kr(src);\n\t// convert to a midi keynum, but don't round! This value will be used later.\n\tpitch = pitch.cpsmidi;\n\t// if you are within an eighth tone of an equal tempered pitch, send a trigger\n\toutOfTune = (pitch - pitch.round).abs < 0.25;\n\t// if outOfTune is true, send a trigger. Limit to 1 trigger every 'limit' seconds  \n\tSendTrig.kr(Trig.kr(outOfTune, limit), id, pitch.round);\n}).add;\n\t\nSynthDef(\\UGen_ex4b, {arg id1, id2, limit = 1, thresh = 0.5;\n\tvar src, amp, amptrig, timer;\n\tsrc = SoundIn.ar(0);\n\t// analyze the amplitude input, cause a trigger if the output is over the thresh\n\tamp = Amplitude.kr(src);\n\tamptrig = Trig.kr(amp > thresh, limit);\n\t// use amptrig to see how long it is between triggers.\n\ttimer = Timer.kr(amptrig);\n\t// send the values back with two different ids\n\tSendTrig.kr(amptrig, id1, amp);\n\tSendTrig.kr(amptrig, id2, timer);\n}).add;\n\n// plays a SinOsc of the pitch you were closest to\nSynthDef(\\UGen_ex4c, {arg freq;\n\tOut.ar(1, SinOsc.ar(freq, 0, XLine.kr(0.1, 0.00001, 0.5, doneAction: 2)))\n}).add;\n\n// modulated noise to respond to amp spikes\nSynthDef(\\UGen_ex4d, {arg freq;\n\tOut.ar(1, LFNoise1.ar(200) * SinOsc.ar(freq, 0, \n\t\tXLine.kr(0.1, 0.00001, 0.5, doneAction: 2)));\n}).add;\n\n// allocate three unique ids for the trigger ids\na = UniqueID.next;\nb = UniqueID.next;\nc = UniqueID.next;\t\n\n// an envelope to poll for amp values later\ne = Env([440, 880], [1], \\exp);\n\n// add the responder\no = OSCresponderNode(s.addr, '/tr', {arg time, responder, msg;\n\t// the msg is an array with 4 values... post them\n\tmsg.postln;\n\t// the id sent back from the SendTrig is msg[2]... use it to decide what to do\n\tcase \n\t\t// pitch trigger\n\t\t{msg[2] == a}\n\t\t// msg[3] is the rounded keynum\n\t\t{Synth(\\UGen_ex4c, [\\freq, msg[3].midicps])}\n\t\t// amp trigger\n\t\t{msg[2] == b}\n\t\t// play a noise burst, higher the amp value, higher the freq (polls the \n\t\t// Env 'e')\n\t\t{Synth(\\UGen_ex4d, [\\freq, e[msg[3]]])}\n\t\t// use the Timer value to play a delayed noise burst at 2000 Hz\n\t\t{msg[2] == c}\n\t\t{SystemClock.sched(msg[3], {\n\t\t\tSynth(\\UGen_ex4d, [\\freq, 2000]);\n\t\t\t})}\n}).add;\n\n// schedule the start our listening synths...\n// then sing or tap away on the input.\nSystemClock.sched(1.0, {\n\tSynth(\\UGen_ex4a, [\\id, a, \\limit, 1]);\n\tSynth(\\UGen_ex4b, [\\id1, b, \\id2, c, \\limit, 0.2, \\thresh, 0.25]);\n});\n\t\n// add a command period function to stop the synths and remove the responder\nCmdPeriod.doOnce({\n\to.remove; \"Removed the responder\".postln;\n})\n)",
    "Figure 331": "Figure 2.5 */\n(\nSynthDef(\\UGen_ex5, {arg gate = 1, seed = 0, id = 1, amp = 1;\n\tvar src, pitchbase, freq, rq, filt, trigger, env;\n\tRandID.ir(id);\n\tRandSeed.ir(1, seed);\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = WhiteNoise.ar;\n\ttrigger = Impulse.kr(Rand.new(2, 5));\n\tpitchbase = IRand.new(4, 9) * 12;\n\tfreq = TIRand.kr(pitchbase, pitchbase + 12, trigger).midicps;\n\trq = LFDNoise3.kr(Rand.new(0.3, 0.8)).range(0.01, 0.005);\n\tfilt = Resonz.ar(src, Lag2.kr(freq), rq);\n\tOut.ar(0, Pan2.ar(filt, LFNoise1.kr(0.1)) * env * amp)\n}).add;\n)\t\na = Synth(\\UGen_ex5, [\\seed, 123]);\n\na.release;\n\n// Using the same seed, we get the same gesture\nb = Synth(\\UGen_ex5, [\\seed, 123]);\n\nb.release;\n\n// passing in different seeds\n(\nr = Routine.run({\n\tthisThread.randSeed_(123);\n\t10.do({\n\t\ta = Synth(\\UGen_ex5, [\\seed, 10000.rand.postln, \\amp, 3.dbamp]);\n\t\t1.wait;\n\t\ta.release;\n\t})\n});\n)",
    "Figure 332": "Figure 2.6 */\n(\nSynthDef(\\UGen_ex6, {arg gate = 1, roomsize = 200, revtime = 450;\n\tvar src, env, gverb;\n\tenv = EnvGen.kr(Env([0, 1, 0], [1, 4], [4, -4], 1), gate, doneAction: 2);\n\tsrc = Resonz.ar(\n\t\t\tArray.fill(4, {Dust.ar(6)}),\n\t\t\t1760 * [1, 2.2, 3.95, 8.76] + \n\t\t\t\tArray.fill(4, {LFNoise2.kr(1, 20)}), \n\t\t\t0.01).sum * 30.dbamp;\n\tgverb = GVerb.ar(\n\t\tsrc,\n\t\troomsize, \n\t\trevtime, \n\t\t// feedback loop damping\n\t\t0.99,\n\t\t// input bw of signal\n\t\tLFNoise2.kr(0.1).range(0.9, 0.7),\n\t\t// spread \n\t\tLFNoise1.kr(0.2).range(0.2, 0.6),\n\t\t// almost no direct source \n\t\t-60.dbamp,\n\t\t// some early reflection\n\t\t-18.dbamp, \n\t\t// lots of the tail\n\t\t3.dbamp,\n\t\troomsize);\n\tOut.ar(0, gverb * env)\n}).add;\n)\t\na = Synth(\\UGen_ex6);\n\na.release;",
    "Figure 333": "Figure 2.7 */\n(\nSynthDef(\\UGen_ex7a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.ar(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex7b, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src, pos) * env);\n}).add;\n\t\nSynthDef(\\UGen_ex7c, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0);\n\tpos = LFNoise2.kr(rate);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\n\n// 56% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 39%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7b, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n// 35%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex7c, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;",
    "Figure 334": "Figure 2.8 */\n(\nSynthDef(\\UGen_ex8a, {arg gate = 1, freq = 440, amp = 0.1, rate = 0.2;\n\tvar w, x, y, out, env, decode;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 2);\n\tdecode = DecodeB2.ar(2, w, x, y);\n\tOut.ar(0, decode * env)\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8b, {arg outbus, freq = 440, rate = 0.2;\n\tvar w, x, y;\n\t#w, x, y = PanB2.ar(\n\t\tSinOsc.ar(freq, 0), LFNoise2.kr(rate));\n\tOut.ar(outbus, [w, x, y])\n}).add;\n\t\t\t\nSynthDef(\\UGen_ex8c, {arg inbus, gate = 1, amp = 0.1;\n\tvar w, x, y, env, decode;\n\t#w, x, y = In.ar(inbus, 3);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: 14);\n\tdecode = DecodeB2.ar(2, w, x, y) * env;\n\tReplaceOut.ar(0, decode);\n}).add;\n)\n\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex8a, [\\freq, 440.0.rrand(1760.0), \\amp, 0.001, \\rate, 0.2], a)\n});\n)\na.release;\n\n(\na = Group.new;\nz = Bus.audio(s, 3);\n\n// the 'catch-all' synth for decoding and enveloping\nSynth(\\UGen_ex8c, [\\inbus, z, \\amp, 0.001], a, \\addToTail); // add it to the tail of the Group containing the encoding synths\n\n250.do({\n\tSynth(\\UGen_ex8b, [\\freq, 440.0.rrand(1760.0), \\outbus, z, \\rate, 0.2], a)\n});\n)\n\na.release;",
    "Figure 335": "Figure 2.9 */\n(\n// pass in amp in db\nSynthDef(\\UGen_ex9a, {arg gate = 1, freq = 440, amp = 0;\n\tvar src, pos, env;\n\tsrc = SinOsc.ar(freq, 0, amp.dbamp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\n// pass in linear amplitude\nSynthDef(\\UGen_ex9b, {arg gate = 1, freq = 440, amp = 1;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, Rand(-1.0, 1.0)));\n}).add;\n\t\nSynthDef(\\UGen_ex9c, {arg gate = 1, freq = 440, amp = -3, pos = 0;\n\tvar src, env;\n\tsrc = SinOsc.ar(freq, 0, amp);\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tOut.ar(0, Pan2.ar(src * env, pos));\n}).add;\n)\t\n\n// 45% on my machine\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9a, [\\freq, 440.0.rrand(1760.0), \\amp, -60], a)\n});\n)\na.release;\n\n// 36%\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9b, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp], a)\n});\n)\na.release;\n\n// 36% (no difference from b)\n(\na = Group.new;\n250.do({\n\tSynth(\\UGen_ex9c, [\\freq, 440.0.rrand(1760.0), \\amp, -60.dbamp, \\pos, 1.0.rand2], a)\n});\n)\na.release;",
    "Figure 336": "Figure 2.10 */\n(\nSynthDef(\\UGen_ex10a, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10b, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10c, {arg gate = 1;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, Line.kr(0.0001, 0.001, 10));\t\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\na = Synth(\\UGen_ex10a); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10b); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10c); // cubic interpolation\na.release;\n\n(\nSynthDef(\\UGen_ex10d, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombN.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\nSynthDef(\\UGen_ex10e, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombL.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n\t\nSynthDef(\\UGen_ex10f, {arg gate = 1, deltime = 0.001;\n\tvar src, delay, env;\n\tenv = EnvGen.kr(\n\t\tEnv([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction: 2);\n\tsrc = Decay.ar(Impulse.ar(1), 1.0, PinkNoise.ar(0.1));\n\tdelay = CombC.ar(src, 0.1, deltime);\n\tOut.ar(0, (delay * env).dup);\n}).add;\n)\n\n// tune to a specific pitch\na = Synth(\\UGen_ex10d, [\\deltime, 100.midicps.reciprocal]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 100.midicps.reciprocal]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 100.midicps.reciprocal]); // cubic interpolation\na.release;\n\n// a much longer delay\na = Synth(\\UGen_ex10d, [\\deltime, 0.1]); // no interpolation\na.release;\n\na = Synth(\\UGen_ex10e, [\\deltime, 0.1]); // linear interpolation\na.release;\n\na = Synth(\\UGen_ex10f, [\\deltime, 0.1]); // cubic interpolation\na.release;",
    "Figure 337": "Figure 3.1 A simple routine illustrating a musical use of yield\n// Fermata\ns.boot;\n(\nr = Routine({\t\n\tx = Synth(\\default, [freq: 76.midicps]);\n\t1.wait;\n\t\n\tx.release(0.1);\n\ty = Synth(\\default, [freq: 73.midicps]);\n\t\"Waiting...\".postln;\n\tnil.yield;// fermata\n\t\n\ty.release(0.1);\n\tz = Synth(\\default, [freq: 69.midicps]);\n\t2.wait;\n\tz.release;\n});\n)\n// do this then wait for the fermata\nr.play;\n// feel the sweet tonic... \nr.play;",
    "Figure 338": "Figure 3.2 Using Task so you can pause the sequence\n(\nt = Task({\t\n\tloop({\t // loop the whole thing\n\t\t3.do({\t // do this 3 times\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 76.midicps]);\n\t\t\t0.5.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 73.midicps]);\n\t\t\t0.5.wait;\n\t\t});\n\t\t\"I'm waiting for you to press resume\".postln;\n\t\tnil.yield;// fermata\n\t\tx.release(0.1);\n\t\tx = Synth(\\default, [freq: 69.midicps]);\n\t\t1.wait;\n\t\tx.release;\n\t});\n});\n\nw = Window.new(\"Task Example\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\nButton.new(w, Rect(0, 0, 100, 20)).states_([[\"Play/Resume\", Color.black, Color.clear]])\n\t.action_({ t.resume(0);});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Pause\", Color.black, Color.clear]])\n\t.action_({ t.pause;});\nButton.new(w, Rect(0, 0, 40, 20)).states_([[\"Finish\", Color.black, Color.clear]])\n\t.action_({ \n\t\tt.stop; \n\t\tx.release(0.1);\n\t\tw.close;\n\t});\n)",
    "Figure 339": "Figure 3.3 Nesting tasks inside routines\n(\nr = Routine({\t\n\tc = TempoClock.new; // make a TempoClock\n\t// start a 'wobbly' loop\n\tt = Task({\t\n\t\tloop({\t\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 61.midicps, amp: 0.2]);\n\t\t\t0.2.wait;\n\t\t\tx.release(0.1);\n\t\t\tx = Synth(\\default, [freq: 67.midicps, amp: 0.2]);\n\t\t\trrand(0.075, 0.25).wait; // random wait from 0.1 to 0.25 seconds\n\t\t});\n\t}, c); // use the TempoClock to play this Task\n\tt.start;\n\tnil.yield;\n\t\n\t// now add some notes\n\ty = Synth(\\default, [freq: 73.midicps, amp: 0.3]);\n\tnil.yield;\n\ty.release(0.1);\n\ty = Synth(\\default, [freq: 79.midicps, amp: 0.3]);\n\tc.tempo = 2; // double time\n\tnil.yield;\n\tt.stop; y.release(1); x.release(0.1); // stop the Task and Synths\n});\n)\n\nr.next; // start loop\nr.next; // first note\nr.next; // second note; loop goes 'double time'\nr.next; // stop loop and fade",
    "Figure 340": "Figure 3.4 Using patterns within a task\n\n(// random notes from lydian b7 scale\np = Pxrand([64, 66, 68, 70, 71, 73, 74, 76], inf).asStream; \n// ordered sequence of durations\nq = Pseq([1, 2, 0.5], inf).asStream; \nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\nt.stop; x.release(2);",
    "Figure 341": "Figure 3.5 Thanks to polymorphism we can substitute objects that understand the same message\n(\np = 64; // a constant note\nq = Pseq([1, 2, 0.5], inf).asStream; // ordered sequence of durations\nt = Task({\t\n\tloop({\t\n\t\tx.release(2);\n\t\tx = Synth(\\default, [freq: p.value.midicps]);\n\t\tq.value.wait;\n\t});\n});\nt.start;\n)\n// now change p\np = Pseq([64, 66, 68], inf).asStream; // to a Pattern: do re mi\np = { rrand(64, 76) }; // to a Function: random notes from a chromatic octave\nt.stop; x.release(2);",
    "Figure 342": "Figure 3.6 Using 'messaging style': Score\n\n(\nSynthDef(\"ScoreSine\",{ arg freq = 440;\nOut.ar(0,\n\tSinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)\n)\n}).add;\nx = [\n// args for s_new are synthdef, nodeID, addAction, targetID, synth args ...\n[0.0, [ \\s_new, \\ScoreSine, 1000, 0, 0,  \\freq, 1413 ]],\n[0.5, [ \\s_new, \\ScoreSine, 1001, 0, 0,  \\freq, 712 ]],\n[1.0, [ \\s_new, \\ScoreSine, 1002, 0, 0,  \\freq, 417 ]],\n[2.0, [\\c_set, 0, 0]] // dummy command to mark end of NRT synthesis time\n];\nz = Score(x);\n)\nz.play;",
    "Figure 343": "Figure 3.7 Executing one line at a time\n\n(\n// here's a synthdef that allows us to play from a buffer, with a fadeout\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t\t* Linen.kr(gate, doneAction: 2); // release synth when fade done\n\t)\n}).add;\n// load all the paths in the sounds/ folder into buffers\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \n)\n// now here's the score, so to speak\n// execute these one line at a time\n~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[0]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[1]]);\n~nowPlaying.release; ~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[2]]);\n~nowPlaying.release;\n// free the buffer memory\n~someSoundsBuffered.do(_.free);",
    "Figure 344": "Figure 3.8 Play cues with a simple GUI\n\n(\nSynthDef(\"playbuf\", { arg out = 0, buf, gate = 1;\n\tOut.ar(out,\n\t\tPlayBuf.ar(1, buf, BufRateScale.kr(buf), loop: 1.0) \n\t\t* Linen.kr(gate, doneAction: 2) * 0.6; \n\t\t// with 'doneAction: 2' we release synth when fade is done\t\n) }).add;\n~someSounds = \"sounds/*\".pathMatch.collect{ |path |  Buffer.read(s, path)}; \nn = 0; // a counter\n// here's our GUI code\nw = Window.new(\"Simple CuePlayer\", Rect(400, 400, 200, 30)).front;\nw.view.decorator = FlowLayout(w.view.bounds);\n//this will play each cue in turn\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Play Cue\", Color.black, Color.clear]]).action_({ \n\tif(n < ~someSounds.size, {\n\t\tif(n != 0, {~nowPlaying.release;}); \n\t\t~nowPlaying = Synth(\"playbuf\", [buf: ~someSounds[n]]); n=n+1;\n\t});\n}); \n//this sets the counter to the first cue\nButton.new(w, Rect(0, 0, 80, 20)).states_([[\"Stop / Reset\", Color.black, Color.clear]]).action_({ n=0; ~nowPlaying.release; }); \n// free the buffers when the window is closed\nw.onClose = { ~someSounds.do(_.free); };\n)",
    "Figure 345": "Figure 3.9 Gathering up files for multichannel cues \n\n// gather all your folder paths\n//this will path match each folder in the collection, i.e. we will have a collection of collections of paths\n\n~groupOfindivCueFolders = \"sounds/*\".pathMatch.collect{ | item |  (item.asSymbol++\"*\").pathMatch };\n\nPost << ~groupOfindivCueFolders;  //see them all !\n\n//check how many cues you will have in the end\n~groupOfindivCueFolders.size; \n\n//automate the buffering process for all cues:\n~bufferedCues = ~groupOfindivCueFolders.collect{|item, i| item.collect{| path |  Buffer.read(s,  path)}}; //now all our cue files are sitting in their buffers ! \n\n~bufferedCues[0];  //here is cue 1\n\n// see it in the post window:\nPost << ~bufferedCues[0];\n\n// play them all in a Group, using our previous synthdef\n// we use bind here to ensure they start simultaneously\n(\ns.bind({\t\n\t~nowPlaying = Group.new(s); // a group to put all the channel synths in\n\t~bufferedCues[0].do({|cue| Synth(\"playbuf\", [buf: cue], ~nowPlaying)})\n});\n)\n// fade them out together by sending a release message to the group\n~nowPlaying.release;",
    "Figure 346": "Figure 3.10 Recording the results of making sounds with supercollider\n\ns.boot; // make sure the server is running\n(  \t// first evaluate this section\nb = Buffer.read(s, \"sounds/a11wlk01.wav\"); // a source\ns.prepareForRecord; // prepare the server to record (you must do this first)\n)\n(\t// simultaneously start the processing and recording\ns.bind({\n\t// here's our funky effect\n\tx = { var columbia, amp; \n\t\tcolumbia = PlayBuf.ar(1, b, loop: 1);\n\t\tamp = Amplitude.ar(columbia, 0.5, 0.5, 4000, 250); // 'sticky' amp follower\n\t\tOut.ar(0, Resonz.ar(columbia, amp, 0.02, 3)) // filter; freq follows amp\n\t\t}.play;\ns.record;\n});\n)\ns.pauseRecording; // pause\ns.record // start again\ns.stopRecording; // stop recording and close the resulting sound file",
    "Figure 347": "Figure 3.12 A variable number of resonators with an automatically created GUI       \n(\nf = 300;\nn = 30; // number of resonators\nt = Array.fill(n, { |i|\n{\nResonz.ar(Dust2.ar(5), f * (i + 1), 0.001, 300)\n* n.reciprocal; // scale to ensure no clipping\n}.play;\n});\n\n// now make a GUI\n// a scrolling window so we don't run out of space\nw = Window.new(\"Buttons\", Rect(50, 100, 290, 250), scroll:true);\nw.view.decorator = FlowLayout.new(w.view.bounds); // auto layout the widgets\nn.do({|i|\nButton.new(w, Rect(0, 0, 130, 30)).states_([\n[\"Freq\" + (f * (i + 1)) + \"On\", Color.black, Color.white],\n[\"Freq\" + (f * (i + 1)) + \"Off\", Color.white, Color.black]\n])\n.action_({ arg butt;\nt[i].run(butt.value == 0);\n});\n});\nw.front;\n)",
    "Figure 348": "Figure 3.13 Making a stuttering gesture using a geometric pattern\n\n(/* a routine for creating a ritardando stutter with panning, you must have\nrun the code in fig 3.9 so that this routine may find some sounds already loaded into buffers, you can change the index of ~bufferedCues to test the routine on different sounds */\n\n\n~stut = Routine( { var dur, pos;\n~stutPatt = Pseq([Pgeom(0.01, 1.1707, 18), Pn(0.1, 1),Pgeom(0.1, 0.94, 200) ]);\n~str= ~stutPatt.asStream;\n100.do{\n    dur =  ~str.next;\n    dur.postln; \t//so we can check values on the post window\n    ~sample = Synth(\"samplePlayer\",[\\out, 0, \\buf,  ~bufferedCues[0], \\at, 0.1, \\rel, 0.05,\\pSpeed, 0.5]);\n    dur.wait;\n}\n});\n)\n\n//now play it\n~stut.play;\n// reset before you play again!\n~stut.reset;",
    "Figure 349": "Figure 4.1\nCreate a network address representing sclang itself\n~host = NetAddr(\"localhost\", NetAddr.langPort);\n// Create two OSC responders for the same command\n~r1 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\t[\\responder1, time, message, address].postln;\n\t}\n).add;\n~r2 = OSCresponderNode(\n\t~host, \"/testMsg\",\n\t{ | time, responder, message, address |\n\t\t[\\responder2, time, message, address].postln;\n\t}\n).add;\n\n// Send an OSC message\n~host.sendMsg(\"/testMsg\", \"OSCresponderNode test\");\n\n// Remove responders\n~r1.remove;\n~r2.remove;",
    "Figure 350": "Figure 5.1\n1\t\t\t\t\t// the Integer number 1 \n1.234 \t\t\t\t// the floating-point (Float) number 1.234\n$a \t\t\t\t\t// the character (Char) a\n\"hello\"\t\t\t\t// a String (an array of characters) \n\\alpha\t\t\t\t// a Symbol (a unique identifier) \n'alpha 1'\t\t\t\t// another notation for a Symbol\n100@150 \t\t\t\t// a Point defined by coordinates x, y \n[1, \\A, $b] \t\t\t\t// an Array containing 3 elements\n(a: 1, b: 0.2) \t\t\t// an Event \n{ 10.rand }\t\t\t\t// a Function\nString \t\t\t\t// the Class String \nMeta_String \t\t\t// the Class of Class String",
    "Figure 351": "Figure 5.3\n// Boot the default server first:\nServer.default.boot;\n// Then select all lines between the outermost parentheses and run: \n( \t\n{\n\tResonz.ar(GrayNoise.ar,\n\t\tXLine.kr(100, 1000, 10, doneAction: 2), \n\t\tXLine.kr(0.5, 0.01, [4, 7], doneAction: 0)\n\t)\n}.play\n)\n// further examples:\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 3, doneAction: 2)) }.play;\n{ WhiteNoise.ar(EnvGen.kr(Env.perc, timeScale: 0.3, doneAction: 2))}.play;",
    "Figure 352": "Figure 5.4\n((1 + 2).asString).interpret \t\t// = 3\n\"1\" ++ \"2\". interpret\t\t\t// 12: 2 is translated to string by ++\n(\"1\" ++ \"2\").interpret\t\t\t// 12\n(1.asString ++ 2.asString).interpret \t// 12\n\"1+2\". interpret \t\t\t\t// 3\n(1.asString ++ \"+2\"). interpret\t\t// 3\n(1 + 2).interpret\t\t\t\t// error: interpret not understood by Integer 3",
    "Figure 353": "Figure 5.5\n(\na = 5;\n5 do: { a = a + 10; a.postln };\nPost << \"The value of variable 'a' is now \" << a << \"\\n\";\n)",
    "Figure 354": "Figure 5.8\n(\n// A window with a button that posts: \"hello there!\"\nvar window, button;\n// create a GUI window and store it in variable window\nwindow = Window.new(\"OLA!\", Rect(200, 200, 120, 120)); \n// create a button in the window and store it in variable button\nbutton = Button.new(window, Rect(10, 10, 100, 100));\nbutton.states = [[\"'ALLO\"]];\t// set one single label for the button\nbutton.action = { \"hello there!\".postln }; // set the action of the button\nwindow.front;\t\t  \t  // show the window\n)",
    "Figure 355": "Figure 5.9\n\n( \n// execute this first to boot the server and load the synth definition\nServer.default.waitForBoot({ \n\tSynthDef(\"ping\", { | freq = 440 |\n\t\tOut.ar(0, \n\t\t\tSinOsc.ar([freq, freq * (4/3)], 0,\n\t\t\t\tEnvGen.kr(Env.perc(0.05, 0.3, 0.1, -4), doneAction: 2)\n\t\t\t)\n\t\t)\n\t}).add\n});\n)\n\n(\n// execute this next to create the sounds\nvar countdown = 100;\nvar note = 50;\nvar increment_func, decrement_func;\nvar action;\nincrement_func = {\n\tnote = note + [2, 5, 7, 12].choose;\n\tif (note > 100) { action = decrement_func };\n};\ndecrement_func = {\n\tnote = note - [1, 2, 5, 7, 12].choose;\n\tif (note < 50) { action = increment_func };\n};\naction = increment_func;\n{\n\tcountdown do: { \n\t\tSynth(\"ping\", [\\freq, note.midicps]);\n\t\taction.value;\n\t\t0.1.wait;\n\t}\n}.fork;\n)",
    "Figure 356": "Figure 5.11\n// run each line separately: \ncurrentEnvironment;\t// empty if no environment variables have been set\n~alpha = pi;\t\t\t// set env. variable ~alpha to pi\ncurrentEnvironment;\t// see current Environment again: ~alpha is set\n~freq = 800;\t\t\t// set another environment variable\nServer.local.boot;\n{ LFNoise0.ar(~freq, 0.1) }.play; // use an environment variable\n// setting an environment variable to nil is equivalent to removing it: \n~alpha = nil;\ncurrentEnvironment;\t// alpha is no longer set",
    "Figure 357": "Figure 5.12\n(\n~q = \"TOP\";\t\t\t\t\t\t\t// store \"TOP\" in ~a, top environment\n(a: \"INNER\") use: { // run function in environment with ~a = \"INNER\"\n\tcurrentEnvironment.postln; // show the current environment\n\ttopEnvironment.postln;\t\t// show the top environment (different!)\n\t~a.postln\t\t\t\t// show ~a's value in current environment\n};\t\n~a;\t\t\t\t\t\t// show ~a's value in top environment\n)",
    "Figure 358": "Figure 5.13\n(\nvar alpha, beta, gamma;\ngamma = alpha;\t// storing variable alpha in gamma only stores nil \nalpha = 10; \t// store 10 in alpha ...\ngamma.postln;\t// but the value of gamma remains unchanged\nalpha = beta;\t// so one cannot use gamma as 'joker'\nbeta = 20;\t\t// to switch between variables alpha and beta.\ngamma.postln;\t// gamma is still nil.\n)",
    "Figure 359": "Figure 5.15\nServer.default.boot; \t\t// (boot Server before running example)\n(\n// Define a function and call it in different contexts\nvar synth;\t\t\t\t// Synth creating the sound that is changed\nvar freq = 220; \t\t\t// frequency of the sound\nvar change_freq;\t\t\t// function that changes the frequency of the sound\nvar window;\t\t\t// window holding buttons for changing the sound\nvar button1, button2, button3; // buttons changing the sound\n\n// Create a synth that plays the sound to be controlled:\nsynth = { | freq = 220 | LFTri.ar([freq, freq * 2.01], 0, 0.1) }.play;\n// Create frequency changing function and store it in variable change_freq\nchange_freq = {\t\t\t\t\t\t// start of function definition\n\t\tfreq = freq * [0.9, 0.9.reciprocal].choose; // change freq value\n\t\tsynth.set(\\freq, freq);\t\t\t// set synth's frequency to new value\n};\t\t\t\t\t\t\t\t// end of function definition\n\n// Create 3 buttons that call the example function in various ways\nwindow = Window(\"Buttons Archaic\", Rect(400, 400, 340, 120));\n//  ------------------------- Example 1 -------------------------\nbutton1 = Button(window, Rect(10, 10, 100, 100));\nbutton1.states = [[\"I\"]]; // set the label of button1\n// button1 calls the function each time that it is pressed \nbutton1.action = change_freq;\t// make button1 change freq once\n//  ------------------------- Example 2 -------------------------\nbutton2 = Button(window, Rect(120, 10, 100, 100));\nbutton2.states = [[\"III\"]];\n// Button2 creates a routine that calls the example function 3 times\nbutton2.action = { \t\t\t// make button2 change freq 3 times\n\t{ 3 do: { change_freq.value; 0.4.wait } }.fork; // play as routine\n};\n//  ------------------------- Example 3 -------------------------\nbutton3 = Button(window, Rect(230, 10, 100, 100));\nbutton3.states = [[\"VIII\"]];\nbutton3.action = { \t\t\t// like example 2, but 8 times\n\t{ 8 do: { change_freq.value; 0.1.wait } }.fork; // play as routine\n};\n// use large size font for all buttons:\n[button1, button2, button3] do: _.font_(Font(\"Times\", 32));\n// stop the sound when the window closes: \nwindow.onClose = { synth.free };\nwindow.front; // show the window\n)",
    "Figure 360": "Figure 5.18\n(\n// a function that calculates the square of the mean of two numbers\nvar sq_mean;\nsq_mean = { arg a, b; \t// arguments a, b defined in arg statement form\n\t(a + b / 2).squared;\n};\n// calculate the square of the mean of 3 and 1:\nsq_mean.value(3, 1);\n)",
    "Figure 361": "Figure 5.19\n(\n// a function that calculates the square of the mean of any numbers\nvar sq_mean_all;\nsq_mean_all = { | ... numbers | // using ellipsis and | | argument form\n\t(numbers.sum / numbers.size).squared;\n};\n// calculate the square of the mean of [1, 3, 5, -7]:\nsq_mean_all.(1, 3, 5, -7); // short form: omit message 'value'\n)",
    "Figure 362": "Figure 5.20\n(\nvar w_func;\nw_func = { arg message = \"warning!\", bounds = Rect(200, 500, 500, 100);\n\tvar window;\n\twindow = Window(\"message window\", bounds).front;\n\tTextView(window, window.view.bounds.insetBy(10, 10))\n\t\t.string = message;\t\n};\n // provide text, use default bounds\nw_func.(String.new.addAll(Array.new.addAll(\" Major news! \").pyramid(7)));\n)",
    "Figure 363": "Figure 5.21\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot!\"], [\"quit!\"]];\nbutton.action = { |me| Server.default perform: [\\quit, \\boot][me.value] };\nwindow.front;\n)",
    "Figure 364": "Figure 5.22\n(\nvar window, button; \nwindow = Window(\"Server Button\", Rect(400, 400, 200, 200));\nbutton = Button(window, Rect(5, 5, 190, 190));\nbutton.states = [[\"boot\"], [\"quit\"]];\nbutton.action = { | me | \n\t[{ \"QUITTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.quit;\n\t},{ \"BOOTING THE DEFAULT SERVER\".postln;\n\t\tServer.default.boot;\n\t}][me.value].value;\n};\nwindow.front;\n)",
    "Figure 365": "Figure 5.23\nServer.default.boot // boot default server before running example\n(\nvar buffer;\nbuffer = Buffer.read(path: \"sounds/a11wlk01.wav\",\n\taction: { | buffer |\n\t\tformat(\"loaded % at: %\", buffer, Main.elapsedTime).postln;\n\t});\nformat(\"Reached this after 'Buffer.read' at: %\", Main.elapsedTime).postln;\nbuffer;\n)",
    "Figure 366": "Figure 5.24\nServer.default.boot;  // do this first\n(\t\t\t\t\t\t// then the rest of the program\nvar window, routine;\nwindow = Window(\"close me to stop\").front;\nwindow.onClose = { routine.stop };\nroutine = { \n\tloop {\n\t\t(degree: -10 + 30.xrand, dur: 0.05, amp: 0.1.rand).play;\n\t\t0.05.rand.wait;\n\t}\n}.fork;\n)",
    "Figure 367": "Figure 5.25\n_.isPrime ! 10\n_.squared ! 10\n_@_.(30, 40) // equivalent to: { | a, b | Point(a, b) }.value(30, 40)\nArray.rand(12, 0, 1000).clump(4) collect: Rect(*_)\n(1..8).collect([\\a, \\b, _]);\n(a: _, b: _, c: _, d: _, e: _).(*Array.rand(5, 0, 100));",
    "Figure 368": "Figure 5.26\n(\nvar iterative_factorial;\niterative_factorial = { | n |\n\tvar factorial = 1;\t// initialize factorial as factorial of 1\n\t// calculate factorial n times, updating its value each time\n\tn do: { | i | factorial = factorial * (i + 1) };\n\tfactorial;\t// return the final value of factorial;\n};\niterative_factorial.(10).postln;\t// 10 factorial: 3628800\n)",
    "Figure 369": "Figure 5.27\n// Define the factorial function and store it in variable f:\nf = { | x | if ( x > 1) { x * thisFunction.value(x - 1) } { x } };\n f.value(10);\t\t\t// 10 factorial: 3628800",
    "Figure 370": "Figure 5.28\n(\t\n/* a function that recursively prints all folders and files\n   found in a path and its subfolders */\n{ | path |\n\t// store function here for use inside the if's {}:\n\tvar thisFunc = thisFunction;\n\tformat(\"====== now exploring: %\", path).postln;\n\t// for all items in the path:\n\tpath.pathMatch do: { | p | \n\t\t// if the item is a folder, run this function on its contents\n\t\t// otherwise print the file found\n\t\tif (p.last == $/) { thisFunc.(p ++ \"*\") }{ p.postln }\n\t}\n}.(\"*\") // run function on home path of SuperCollider\n)",
    "Figure 371": "Figure 5.29\n(\n// a function that creates a function that counts to any number\nvar counter_maker;\nvar window, button1, button2; // gui for testing the function\n\n// the function that makes the counting function\ncounter_maker = { | max_count |\n\t// current_count is used by the function created below\n\t// to store the number of times that it has run\n\tvar current_count = 0;  \n\t{\t// start of definition of the counting function\n\t\tif (current_count == max_count) {\n\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\tmax_count;\t\t// return max count for eventual use\n\t\t}{\n\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\tcurrent_count\t// return current count for eventual use\n\t\t}\n\t}\t// end of definition of the counting function \n};\n\n//  ----- Test application for the counter_maker function ----- \n// window displaying 2 buttons counting to different numbers\nwindow = Window(\"Counters\", Rect(400, 400, 200, 80));\n// make a button for triggering the counting: \nbutton1 = Button(window, Rect(10, 10, 180, 20));\nbutton1.states = [[\"counting to 10\"]];\t// labels for button1\n// make a function that counts to 10 and store it as action in button1\nbutton1.action = counter_maker.(10);\nbutton2 = Button(window, Rect(10, 40, 180, 20));\nbutton2.states = [[\"counting to 5\"]];\t// labels for button2\n// make a function that counts to 5 and store it as action in button2\nbutton2.action = counter_maker.(5);\nwindow.front;\t\t\t// show the window\n)",
    "Figure 372": "Figure 5.31\n(\nvar counter_maker;\t\t// creator of counters\nvar make_counters_gui;\t// function making counters + a gui\n/* a function that creates an event that counts to any number, \n   and resets: */ \ncounter_maker = { | max_count |\n\tvar current_count = 0; \n\t(\t// the counter object is an event with 3 functions: \n\t\tcount1: // function 1: increment count (stored as count1)\n\t\t{\t// start of definition of the counting function\n\t\t\tif (current_count == max_count) {\n\t\t\t\tformat(\"finished counting to %\", max_count).postln; \n\t\t\t}{\n\t\t\t\tcurrent_count = current_count + 1; // increment count\n\t\t\t\tformat(\"counting % of %\", current_count, max_count).postln; \n\t\t\t}\n\t\t},\t// end of definition of the counting function\n\t\treset_count: { // function 2: reset count (stored as reset_count)\n\t\t\tformat(\"resetting % counter\", max_count).postln;\n\t\t\tcurrent_count = 0\n\t\t},\n\t\tmax_count: { max_count } // function 3: return value of max_count\n\t)\n};\n// Function that makes several counters and a GUI to control them\nmake_counters_gui = { | ... counts |\n\tvar window, counter;\n\twindow = Window(\"Counters\", \n\t\t\tRect(400, 400, 200, 50 * counts.size + 10));\n\t// enable automatic placement of new items in window: \n\twindow.view.decorator = FlowLayout(window.view.bounds, 5@5, 5@5);\n\tcounts collect: counter_maker.(_) do: { | counter |  \n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Counting to: \" ++ counter.max_count.asString]])\n\t\t\t.action = { counter.count1 };\n\t\tButton(window, Rect(0, 0, 190, 20))\n\t\t\t.states_([[\"Reset\"]])\n\t\t\t.action = { counter.reset_count };\n\t};\n\twindow.front;\n};\nmake_counters_gui.(5, 10, 27); // example use of the GUI test function\n)",
    "Figure 373": "Figure 5.32\nServer.default.boot;\t// boot the server first;\n(\nvar degrees, window, button;\nwindow = Window(\"melodies?\", Rect(400, 400, 200, 200));\nbutton = Button(window, window.view.bounds.insetBy(10, 10));\nbutton.states = [[\"click me to add a note\"]];\nbutton.action = { \n\tdegrees = degrees add: 0.rrand(15);\n\tPbind(\\degree, Pseq(degrees), \\dur, Prand([0.1, 0.2, 0.4], inf)).play;\n};\nwindow.front;\n)",
    "Figure 374": "Figure 5.34\n1.class \t\t// the class of Integer 1: Integer\n1.class.class \t// the Class of the Class of Integer 1: Meta_Integer\n// the Class of the Class of the Class of Integer 1: \n1.class.class.class  \t\t\t\t\t// Class\n// the Class of the Class of the Class of the Class of Integer 1\n1.class.class.class.class\t\t\t\t// Meta_Class\n// the Class of the Class of the Class of the Class of the Class of 1\n1.class.class.class.class.class \t\t// Class \nClass.class\t\t\t\t// the Class of Class is Meta_Class\nMeta_Class.class\t\t// the Class of Meta_Class is Class",
    "Figure 375": "Figure 5.36\nCounter { \n\t// variables: maximum count, current count\n\tvar <>max_count, <>current_count = 1;\n\t// class method for creating a new instance\n\t*new { | max_count = 10 |\n\t\t^super.new.max_count_(max_count)\n\t}\n\t// if maximum count not reached, increment count by 1\n\tcount1 {\n\t\tif (current_count >= max_count) {\n\t\t\tthis.changed(\\max_reached)\n\t\t}{\n\t\t\tcurrent_count = current_count + 1;\n\t\t\tthis.changed(\\count, current_count);\n\t\t}\n\t}\n\t// reset count\n\treset {\n\t\tcurrent_count = 1;\n\t\tthis.changed(\\reset);\n\t}\n}",
    "Figure 376": "Figure 5.37\nServer.default.boot;\n(\nSynthDef(\"ping\", { | freq = 440 | \n\tOut.ar(0, \n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).add;\n\nSynthDef(\"wham\", {\n\tOut.ar(0, BrownNoise.ar(\n\t\tEnvGen.kr(Env.perc(level: 0.1), doneAction: 2)\n\t))\n}).add; \n)",
    "Figure 377": "Figure 5.38\n(\n~sound_adapter =  { | counter, what, count |\n\tswitch (what, \n\t\t\\reset, { Synth(\"wham\"); },\n\t\t\\max_reached, { counter.reset },\n\t\t\\count, { Synth(\"ping\", \n\t\t\t[\\freq, count.postln * 10 + counter.max_count * 20]\n\t\t\t)\n\t\t}\n\t)\n};\n)",
    "Figure 378": "Figure 5.39\n(\n~make_display = { | counter |\n\tvar window, label, adapter, stagger;\n\twindow = Window(\n\t\t\"counting to \" ++ counter.max_count.asString, \n\t\tRect(stagger = UniqueID.next % 20 * 20 + 400, stagger, 200, 50)\n\t);\n\tlabel = StaticText(window, window.view.bounds.insetBy(10, 10));\n\tadapter = { | counter, what, count |\n\t\t\t{ label.string = counter.current_count.asString }.defer\n\t};\n\tcounter addDependant: adapter;\n\t/* remove the adapter when window closes to prevent error in \n\t   updating non-existent views: */\n\twindow.onClose = { counter removeDependant: adapter };\n\twindow.front\n};\n)",
    "Figure 379": "Figure 6.1.  Example of a SynthDef\nSynthDef(\t\t\t\t\t\n\t\"sine\", \t\t\t\t// name of SynthDef\t\n\t{\t\t\t\t// function begins with a brace\n\t arg gate = 1, out = 0, \t\t// arguments serve as Control declarations\n freq = 400, amp = 0.4,\n pan = 0, ar = 1, dr = 1;\n\n\tvar audio;\t\t\t\n\taudio = SinOsc.ar(freq, 0, amp);\t\t// start with a SinOsc\n\taudio = audio * Linen.kr(gate, ar, 1, dr, 2);\t// apply an envelope\n\taudio = Pan2.ar(audio, pan);\t\t\t// stereo pan, \n\tOffsetOut.ar(out,audio);\t\t\t// to bus out and out+1 \n\t}\n).add;\t\t\t\t// make and store a SynthDesc and SynthDef",
    "Figure 380": "Figure 6.2. Example of a key/value Array and a note Event=\na = [ \n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n];\n\ne = (\n\ttype:\t\t\t\\note,\t\t\n\tinstrument: \t\t'sine', \n\tfreq:\t\t\t400, \n\tamp:\t\t\t0.1, \n\tpan:\t\t\t0, \n\tar: \t\t\t2, \n\tdr: \t\t\t4, \n\tsustain:\t\t2\n);\ne.play;\t\t\t\t\t// play the note",
    "Figure 381": "Figure  6.3. The OSC commands created by the note event\ne.asOSC.do{ | osc | osc.postcs };\n\n// the result that would be posted:\t\t\n//  [ 0.0, ['s_new', 'sine', 1000, 0, 1, 'out', 0, 'freq', 400.0, 'amp', 0.1, 'pan', 0, 'ar', 2, 'dr', 4] ]\n//  [ 2.0, [ 'n_set', 1000, 'gate', 0 ] ]",
    "Figure 382": "Figure 6.4. Two ways of writing the same Event Pattern\n\t1. Pbind( *[ \n\t\tdur:\t0.2,\nfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t] );\n\n\t2. Pbind( \n\t\t\\dur, 0.2,\n\t\t\\freq, \tPseq([100, 200, 300, 400, 500, 600, 700, 800]) \n\t);",
    "Figure 383": "Figure 6.5. A more elaborate Event Pattern\np = Pbind(*[ \n\t\tinstrument:\t\\default,\n\t\tdetune:\t\t[0,1,3],\n\t\tfreq: \t\tPseq( (1..11) * 100,  4 * 5 * 7),\n\t\tdb:\t\tPseq([-20, -40, -30, -40], inf),\n\t\tpan:\t\tPseq([-1,0,1,0], inf),\n\t\tdur:\t\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8], inf),\n\t\tlegato:\t\tPseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n// render 40 seconds of the pattern in the file named \"sf.aif\"\t\n\tp.render(\"sounds/sf.aif\", 40)\t\n// now play the pattern in real-time\n\tp.play;",
    "Figure 384": "Figure 6.6.  Using Event types\n(\n\t(type: \t\\group, \t\nid: 2\n).play;\t\t\t\t\t// create a group with nodeID 2\n\n\t(\ttype:\t\t\\note, \t\t// play note\t\t\n\t \tsustain:\t100, \t\t// lasting 100 seconds\t\t\t\t\n\t \tgroup: \t\t2\t\t// in group 2\n\n\t ).play;\t\n\t \t\t\t\t\t\t\t\t\t\t\n)\n(\n\t(type: \t\\off, \tid: 2).play;\t\t// release all notes in the group\n\t(type:\t \\kill,\tid: 2,  lag: 3).play;\t// and free the group  3 seconds later\t\n)",
    "Figure 385": "Figure 6.7. Chord events\n// 2nd inversion - e loudest\n( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -20, -10] ).play\t\t\t\n// 2nd inversion - c loudest\n ( degree:  [-3,0,2],\tsustain: 2, \tdb: [-20, -10, -20] ).play\t\n// note \"fattened\" by three detuned copies\n ( degree: 0,\t\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// each detune is assigned to a different pitch, fat free.\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,3, 5] ).play\t\t\t\n// detune rotates through each note in the chord\n ( degree:  [-3,2,4],\tsustain: 2, \tdetune: [0,0,0,3,3,3,5,5,5] ).play",
    "Figure 386": "Figure 6.8.  Interdependent key values in a Pattern\n\tPbind(*[\n\t\tstretch:\t\tPseg([0,0.1,0.2,1],8).linexp(0,1, 1,0.125),\n\t\tmidinote: \t\t100.cpsmidi,\n\t\tharmonic:\t\tPwhite(1, 16),\n\t\tlegato:\t\t\tPkey(\\stretch) * Pkey(\\harmonic)/2 ,\n\t\tdb:\t\t\t-10 - Pkey(\\harmonic),\n\t\tdetune:\t\t\tPwhite(0.0,3.0),\n\t\tdur:\t\t\t0.2,\n\t]).play",
    "Figure 387": "Figure 6.9. Chaining Event Patterns\n\ta = Pbind(*[\n\t\tscale: \tPn( Pstep([[0,2,4,5,7,9,11], [0,1,3,5,6,8,11] ], 5 ) ),\n\t\tdb:\tPn(Pseg([-20, -30, -25, -30], 0.4))\n\t]);\n\tb = Pbind(*[ \ndegree: Pbrown(0, 6, 1), \nmtranspose: Prand([\\rest, Pseq([0], 5.rand)],inf), \ndur: 0.2, \noctave: 6\n]);\n\tc = Pbind(*[ \ndegree: [0,2,4],  \nmtranspose: Pbrown(0, 6, 1), \ndur: 0.4, \ndb: -35\n]);\n\td = Pchain(Ppar([b, c]),a);\nd.play;",
    "Figure 388": "Figure 6.10. Using Prout to define and play patterns on the fly\n\tProut({| ev |\n\t\tvar pat, refPat;\n\n\t\trefPat = Pbind(*[dur: 0.2, note: Pseq([0,0, 0, 7,0, 7])]);\n\n\t\tloop {\n\t\t\tev = refPat.embedInStream(ev);\n\n\t\t\tpat = Pbind(*[\n\t\t\t\tdur: [0.2, 0.4].choose,\n\t\t\t\tnote: Pseq(Array.fill(5, { 10.rand }), 3.rand )\n\t\t\t]);\t\nev = pat.embedInStream(ev);\n\t\t}\n\t\n}).play",
    "Figure 389": "Figure 6.11.  Using Prout to define value and event patterns\n~patA = Pbind(*[\n\tdur:\t0.2,\n\tdegree: Prout({ | ev |\n\t\tvar noteArray  = (0..5);\n\t\tloop {\n\t\t\tev = Pseq(noteArray ).embedInStream(ev);\n\t\t\tnoteArray[6.rand] = 7.rand;\n\t\t}\t\t\n\t})\n]);\n\n\n~patB = Prout({ | ev |\n\tvar pat, pats= [\n\t \tPbind(*[ degree: Pseq([  0, 7]), dur: 0.2   ]),\n\t \tPbind(*[ degree: Pseq([11, 7]), dur: 0.2 ]),\n\t\tPbind(*[ degree: Pseq([16, 7]), dur: 0.2 ]).\n\t\t(type: \\rest, delta: 1)\n\t];\n\t\t\t\n\tloop {\n\t\tpat = pats.choose;\n\t\tev = pat.embedInStream(ev);\n\t}\n});\n\nPchain(\n\tPbind(*[\n\t\tdb: \tPn(Pstep([-15, -25,-25, -20, -30, -25], 0.2) )\n\t\t\t+ Pseg([-30, -5,-10, -40], 12)\n\t]), \n\tPtpar([\n\t\t0, ~patA, \n\t\t0,  ~patA, \n\t\t12,  ~patB\n\t]) \n).play;",
    "Figure 390": "Figure 6.12.  Rendering and playing a pattern\n\t~pattern = Pbind(*[ \n\t\tinstrument:\t\"default\",\n\t\tfreq: \tPseq([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100], 5),\n\t\tdb:\tPseq([-10, -30, -20, -30], inf),\n\t\tdur:\tPseq([0.2,0.2,0.2,0.2, 0.4,0.4,0.8],inf),\n\t\tlegato: Pseq([2,0.5,0.75,0.5,0.25], inf)\t\n\t] );\n\n\t~score = ~pattern.asScore(24 * 11/7);\n\t~score.render(\"recordings/test.aif\");\n\tSoundFile(\"recordings/test.aif\").play;",
    "Figure 391": "Figure 6.13. Soundfile granulation with a Pattern \nSynthDef(\"playbuf\", { | out=0, bufnum = 0, rate = 1, \nstartPos = 0, amp = 0.1, sustain = 1, \npan = 0, gate = 1|\n\tvar audio, env;\n\trate = rate * BufRateScale.kr(bufnum);\n\tstartPos = startPos * BufFrames.kr(bufnum);\n\tenv = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: 2);\n\taudio = PlayBuf.ar(1, bufnum, rate, 1, startPos, 0);\n\taudio = env * audio;\n\taudio = Pan2.ar(audio, pan, amp);\n\tOffsetOut.ar(out, audio);\n}).add;\n\t\t\n\tPseq([\n\t\t(\ttype:\t\t\\load,\n\t\t\tfilename:\t\"sounds/a11wlk01.wav\",\n\t\t\tbufnum:\t1,\n\t\t\tdelta:\t\t0\n\t\t),\n\t\t\n\t\tPbind(*[\n\t\t\tinstrument:\t\"playbuf\",\n\t\t\ttype:\t\t\\on,\n\t\t\tid:\t\t-1,\n\t\t\tdur:\t\t Pseg([0,1],21).linexp(0,1,0.01,2),\n\t\t\tlegato:\t\t4,\n\t\t\tstartPos:\tPn(Pseg([0,1], 10)),\n\t\t\tbufnum:\t1,\t\t\n\t\t]),\n\t\t(\ttype:\t\t\\free, \n\t\t\tbufnum: \t1\n\t\t)\n\t]).play(quant: 0) \n// the result: [ ( 'midinote': 60 ), ( 'midinote': 64 ), ( 'midinote': 67 ) ]",
    "Figure 392": "Figure 6.14.  Yield versus EmbedInStream\n\tr = Routine{ \n\t\tPseq([1,2,3]).yield; \n\t\tPseq([1,2,3]).embedInStream;\n\t\t123445.embedInStream; \n\t\t123445.embedInStream; \n\t};\n\n\t[next(r), next(r), next(r), next(r), next(r), next(r)];\n\t// the result: [ a Pseq, 1, 2, 3, 123445, 123445, nil]",
    "Figure 393": "Figure 6.15. The definition of the stream created by Pseq.\n\tRoutine({\n\t\trepeats.value.do({\n\t\t\tlist.size.do({ arg i;\n\t\t\t\titem = list.wrapAt(i + offsetValue);\n\t\t\t\tinval = item.embedInStream(inval);\n\t\t\t});\n\t\t});\n\t});",
    "Figure 394": "Figure 6.16.  The definition of Event\u00e2\u0080\u0099s play method.\n\tplay {\n\t\tif (parent.isNil) { parent = defaultParentEvent };\n\t\tthis.use { ~play.value };\n\t}",
    "Figure 395": "Figure 6.17. Definition of the key \\play in the default event\n{\n\tvar tempo, server;\n\t\n\t~finish.value;\t\t\t\t\t\t// user callback \n\tserver = ~server ?? { Server.default };\t \n\ttempo = ~tempo;\t\t\t\t\t// assigning to a variable\n\t\t\t\t\t\t\t\t\t// saves repeated look ups\n\tif (tempo.notNil) {\t\t\t\t\t// if not nil, change tempo of\n\t\tthisThread.clock.tempo = tempo;\t// the clock playing the pattern\n\t};\n\t~eventTypes[~type].value(server);\t\t// select play function from ~type\n}",
    "Figure 396": "Figure 6.18.  Implementation of the event type \\bus.\n\t{ |server|\n\t\tvar lag, array;\n\t\tlag = ~lag + server.latency;\n\t\tarray = ~array.asArray;\n\t\tserver.sendBundle(lag, \n\t\t\t[\\c_setn, ~out.asUGenInput, array.size] ++ array);\n\t}",
    "Figure 397": "Figure 7.1\n(\nTask {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(note: x.postln, dur: 0.125).play;\n\t\t0.125.wait;\n\t}\n}.play\n);\t\t// creates a loop of values\n\n// change x and y\nx = 5;\t// new initial value\ny = 4;\t// new multiplication factor",
    "Figure 398": "Figure 7.2\n(\n{\n\tx = SinOsc.kr(4); \n\ty = SinOsc.kr(13);\n\tSinOsc.ar(x * y % 0.4 * 500 + 600) * 0.2\n}.play;\n)\n\n// change x and y?\nx = SinOsc.kr(4); // no effect.\ny = SinOsc.kr(4); // no effect either.",
    "Figure 399": "Figure 7.3\n\np = ProxySpace.push;\n~x = { SinOsc.kr(4) }; \n~y = { SinOsc.kr(13) };\n~z = { SinOsc.ar(~x * ~y % 0.4 * 500 + 600) * 0.2 };\n~z.play;\n\n\t\n// now ~x and ~y can be replaced\n~x = { SinOsc.kr(0.4) }; \n~y = { SinOsc.kr(1.3) }; \n\np.clear(2).pop; // release environment (2 sec fadeout)",
    "Figure 400": "Figure 7.4\n\np = ProxySpace.push;\t// if needed\n\n~a = { Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2) };\n(\n~b = {\n\tvar c, d;\n\tc = Dust.ar(20 ! 2);\n\td = Decay2.ar(c, 0.01, 0.02, SinOsc.ar(11300));\n\td + BPF.ar(c * 5, ~a.ar * 3000 + 1000, 0.1)\n}\n);\n\n~b.play;\n\n// the refactored code from above\n\n(\n~a = { \n\tvar a;\n\ta =  Lag.ar(LFClipNoise.ar(2 ! 2, 0.5, 0.5), 0.2);\n\tBPF.ar(~c.ar * 5, a * 3000 + 1000, 0.1) \n}\n);\n~c = { Dust.ar(20 ! 2) };\n~d = { Decay2.ar(~c.ar, 0.01, 0.02, SinOsc.ar(11300)) };\n~b = ~a + ~d;\n\n~b.play;",
    "Figure 401": "Figure 7.6\n\n// self reference (~x) constructs a loop at control rate \n\n~out.play;\n~x = 0.2; ~a = 1.1; ~c = 0.13;\n~x = (~a * ~x) + ~c % 1.0;  // leaving out the .kr message assumes a control rate ugen.\n\n~out = { Pan2.ar(SinOsc.ar(~x * 4000 + 200) * 0.1, ~x) };",
    "Figure 402": "Figure 7.7\n\nn = NodeProxy.new;\nx = { SinOsc.ar(n.kr * 200 + 300) * 0.1 }.play;\nn.source = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\nn.clear; x.free;",
    "Figure 403": "Figure 7.8\n\nNdef(\\out, { SinOsc.ar(Ndef.kr(\\x) * 200 + 300) * 0.1 }).play;\nNdef(\\x, { LFPulse.kr([1.3, 2.1, 3.2]).sum });\nNdef.clear;",
    "Figure 404": "Figure 7.9\n\np = ProxySpace.push; // if needed\n~out = { SinOsc.ar(~x.kr * 200 + 300) * 0.1 }\n~out.play;\n~x = { LFPulse.kr([1.3, 2.1, 3.2]).sum };\np.clear.pop;",
    "Figure 405": "Figure 7.10\n\np.clear; // neutralize space, free all buses and synths\np.push; // if needed\n~a.ar(3); // 3 channels, audio rate\n~b.kr(8); // 8 channels, control rate\n~c.play; // playing an uninitialized proxy assumes (per default) 2 channels, audio rate\n~d = { LFNoise0.kr([1, 1, 1, 1]) }; // 4 channels, control rate",
    "Figure 406": "Figure 7.11\n\n~out.play; ~out.fadeTime = 3;\n(\n// name with a_ represents audio rate argument\n~out = { |freq=440, mod=0.4, detune=0.1, a_in = #[1,1]|\n\tfreq = freq * ([0, detune] + 1);\n\tLFTri.ar(LFTri.ar(mod * freq).range(freq * mod, freq)) * a_in * 0.2\n}\n);\n\n(\n~mod2 = { LFNoise1.kr(1).range(0, 1) };\n~mod1 =  { LFPulse.kr(~mod2.kr * 30 + 1, 0, 0.3) };\n~freq1 = { ~mod1.kr * 13100 + 100 };\n~freq2 = { LFTri.kr(30) * 200 + 300 };\n~audio1 = { BrownNoise.ar(LFClipNoise.kr(10.dup), 1) };\n~audio2 = { SinOsc.ar(LFNoise2.kr(1.dup).exprange(4, 1000)) };\n);\n\n~out.map(\\freq, ~freq2, \\mod, ~mod1);\n~out.set(\\detune, 0.01);\n~out.map(\\freq, ~freq1, \\mod, ~mod1);\n~out.xmap(\\freq, ~freq1, \\mod, ~mod2); // xmap crossfades over fade time to new value.\n~out.xmap(\\freq, ~freq2, \\mod, ~mod1, \\a_in, ~audio2);\n~out.map(\\a_in, ~audio1);",
    "Figure 407": "Figure 7.12\n\n// this synthdef is used in the subsequent figures\n(\nSynthDef(\\wave, { |out, freq=440, amp=0.1, sustain=0.1, mod=0.2|\n\tOffsetOut.ar(out,\n\t\tEnvGen.ar(Env.perc(ExpRand(0.001, 0.05), sustain, amp), doneAction: 2)\n\t\t*\n\t\tSinOsc.ar(freq, SinOsc.ar(sustain.reciprocal * 8, [0, Rand(0, pi)], mod))\n\t)\n}).add\n);\n(\nTdef(\\x, {\n\tx = 4; y = 13;\n\tloop {\n\t\tx = (x * y) % 11;\n\t\t(instrument: \\wave, note: x.postln, sustain: 0.5, octave: 6).play;\n\t\t0.125.wait;\n\t}\n}).play\n);",
    "Figure 408": "Figure 7.13\n\n(\n\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 1500).play; 0.03.wait } });\nTdef(\\b, { [1, 5, 1, 2, 8, 4, 12].do { |x| (instrument: \\wave, note: x + 8).play; 0.1.wait } });\nTdef(\\c, { \"c is just a waiting message\".postln; 2.wait; });\n\n\nTdef(\\x, {\n\tloop {\n\t\tTdef(\\a).embed; // play in sequence\n\t\t1.wait;\n\t\tTdef(\\b).embed;\n\t\t2.wait;\n\t\tTdef(\\a).fork; // play in parallel\n\t\tTdef(\\b).fork;\n\t\tTdef(\\c).embed;\n\t}\n}).play\n);\n\n// rewrite with infinite loop\nTdef(\\a, { inf.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } }); \n// rewrite with finite loop\nTdef(\\a, { 10.do { (instrument: \\wave, freq: 50.rand + 500).play; 0.1.wait } });",
    "Figure 409": "Figure 7.14\n(\nTdef(\\a, { |in|\n\tin.at(\\n).do { |i| \n\t\tin = (instrument: \\wave, detune: 5.rand2).putAll(in);\n\t\tin.postln.play; \n\t\tin.delta.wait;\n\t} \n})\n);\n\n(\nTdef(\\x, { |inevent|\n\tloop {\n\t\tTdef(\\a).embed((note: [15, 17], dur: 0.01, n: 13));\n\t\t1.wait;\n\t\tTdef(\\a).embed((note: 9, dur: 0.4, n: 4));\n\t\t1.wait;\n\t}\n}).play;\n)",
    "Figure 410": "Figure 7.15\n\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3], inf));\n(\nTask {\n\tvar stream = Pdefn(\\x).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next; \n\t\t(instrument: \\wave, note: val).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\nPdefn(\\x, Pseq([0, 2, 0, 8, 6, 5, 2, 3, 4, 5], inf)); // rewrite the definition at runtime.\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 4, inf));",
    "Figure 411": "Figure 7.16\n\nPdefn(\\y, Pdefn(\\x) + 2); // derive a transposition\nPdefn(\\z, Pdefn(\\x) + Pseq([0, 5, 0, 7, 2], inf)); // derive a variation\nPdefn(\\a, Ptuple([Pdefn(\\y), Pdefn(\\z)])); // combine them in a stream of arrays\n(\nTask {\n\tvar stream = Pdefn(\\a).asStream;\n\tvar val;\n\tloop { \n\t\tval = stream.next.postln; \n\t\t(instrument: \\wave, note: val, sustain: rrand(0.5, 0.9)).play; \n\t\t0.2.wait \n\t}\n}.play\n);\n\n// rewriting the definitions causes all derivations to vary\nPdefn(\\x, Pseq([0, 11], inf));\nPdefn(\\x, Pseq([0, 2, 0, 7, 6, 5, 4, 3].scramble + 5, inf));\nPdefn(\\z, Pdefn(\\x) + Pseq([1, 5, 1, 11, 1], inf)); // change a variation\n\nPdefn(\\a, 5); // a number as a source\nPdefn.clear; // clearing all - the empty pattern returns a series of 1.",
    "Figure 412": "Figure 7.17\n\nPdef(\\a).play; // play silence in sequence\nPdef(\\a, Pbind(\\instrument, \\wave)); // insert a sequence of notes\nPdef(\\a, Pbind(\\instrument, \\wave, \\dur, Pseq([1, 3, 2, 3], inf) / 6)); // add some rhythm\nPdef(\\a).pause;\nPdef(\\a).resume;\nPdef(\\a).stop;",
    "Figure 413": "Figure 7.18\n\n(\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\mod, Pseq([1, 0, 1, 0], inf), \n\t\t\\dur, Pn(1/2, 8),\n\t\t\\note, 7\n\t)\n)\n);\n\n(\nPdef(\\y,\n\tPbindf(\n\t\tPdef(\\x),\n\t\t\\amp, 0.2,\n\t\t\\note, Pshuf([0, 2, 3, 5], 2) + Prand([0, 5, [0, 4]], inf),\n\t\t\\dur, Pseq([1, 3, 2, 3], inf) / 6\n\t)\n)\n);\n\n(\nPdef(\\z, Pbindf(Pdef(\\y), \\dur, 1/4))\n);\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPseq([\n\t\t\tPpar([Pdef(\\x), Pdef(\\y)]),\n\t\t\tPdef(\\x),\n\t\t\tPdef(\\y),\n\t\t\tPdef(\\z),\n\t\t\tPpar([Pdef(\\x), Pbindf(Pdef(\\y), \\ctranspose, 2)])\n\t\t], inf)\n\t)\n);\n))\n\nPdef(\\a).play; // play it\n\n// go into a looping vamp\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], inf) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\n// release a break\n(\nPdef(\\x,\n\tPbind(\n\t\t\\instrument, \\wave, \n\t\t\\dur, Pseq([1, 3, 2, Prand([3, 2])], 1) / 6,\n\t\t\\octave, [6, 4]\n\t)\n)\n);\n\nPdef(\\a).stop; // stop the player",
    "Figure 414": "Figure 7.19\n\n// the combination of all placeholders into a new placeholder\n(\nPdef(\\b, Pbindf(Pdef(\\y), \\ctranspose, 2));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf).trace) // trace it to post which\n\t)\n).play;\n)",
    "Figure 415": "Figure 7.20\n\n(\nPdefn(\\sequence, Pseq([[\\x, \\y], \\x, \\y, \\z, [\\x, \\b]], inf));\nPdef(\\a,\n\tPmul(\\dur, Pwhite(-0.02, 0.02) + 1,\n\t\tPsym(Pdefn(\\sequence).trace)\n\t)\n).play;\n)\n\n// rewrite the sequence\nPdefn(\\sequence, Pseq([\\x], inf));\nPdefn(\\sequence, Pseq([\\x, \\y, \\x, [\\x, \\y]], inf));\n\nPdef(\\a).stop; // stop playing",
    "Figure 416": "Figure 7.21\n\n(instrument: \\x, type: \\phrase).play; // a single phrase from Pdef(\\x)\n\n// a pattern of overlapping phrases\n(\nPbind(\n\t\\type, \\phrase, \n\t\\instrument, \\x, \n\t\\legato, 2.5, \n\t\\note, Pseq([0, 5, 7], inf)\n).play\n);",
    "Figure 417": "Figure 7.22\n(\nPdef(\\x, { |note=0, n=6, step=3, modulo=15, sustain=1|  \n\tPbind(\n\t\t\\instrument, \\wave,\n\t\t\\note, note.value + (Pseries(1, step, n) % modulo) + 7, \n\t\t\\dur, sustain.value / n\n\t) \n})\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Pseq([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf)\n\t)\n).play\n);\n\n(\nPdef(\\a, \n\tPbind(\n\t\t\\type, \\phrase,\n\t\t\\instrument, \\x,\n\t\t\\note, Pseq([0, 5, 4, 8, 0], inf),\n\t\t\\n, 5,\n\t\t\\modulo, Prand([3, [4, 3, 5], [13, 15]], inf),\n\t\t\\recursionLevel, 1,\n\t\t\\dur, Pseq([1, 2, 0.5, 1.5], inf) * 2\n\t)\n).play\n);",
    "Figure 418": "Figure 7.25\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\np = ProxySpace.push;\n~z.play;\n\n// A pattern in an audio rate node proxy ...\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), // only non-standard keys, i.e. xfreq \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);\n~y = { Ringz.ar(~x.ar, 5000 * [1, 1.2], 0.01) }; // resonant filter on the impulses from ~x\n~mod = { LFNoise1.kr(0.1).exprange(200, 5000) }; // a modulator\n~z = { ~y.ar * (SinOsc.ar(~mod.kr) + 1) }; // ring modulation with frequency ~mod\n\n// ... and a control rate node proxy in a pattern.\n// To pass on modulation like this, the standard event parameters like freq cannot be used.\n// Here, we use xfreq instead.\n\n(\n~x = Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, ~mod, 5, ~mod, 19], inf), // read from the ~mod proxy bus. \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n)\n);",
    "Figure 419": "Figure 7.26\n\n(\nSynthDef(\\train, { |out, xfreq=15, sustain=1.0, amp=0.1, pan|\n\tLine.ar(1, 1, sustain, doneAction:2);\n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(xfreq), pan, amp));\n}).add\n);\n\nNdef(\\z).play;\n\n// a pattern in an audio rate node proxy ...\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Pwhite(30, 800, 1), 5, 14, 19], inf), \n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);\nNdef(\\y, { Ringz.ar(Ndef(\\x).ar, 5000 * [1, 1.2], 0.01) });\nNdef(\\mod, { LFNoise1.kr(0.1).exprange(200, 5000) });\nNdef(\\z, { Ndef(\\y).ar * (SinOsc.ar(Ndef(\\mod).kr) + 1) }); // ring modulation with Ndef(\\mod)\n\n// ... and a control rate node proxy in a pattern\n\n(\nNdef(\\x, Pbind(\n\t\\instrument, \\train, \n\t\\xfreq, Pseq([50, Ndef(\\mod), 5, Ndef(\\mod), 19], inf), // read from the Ndef(\\mod) proxy bus\n\t\\sustain, Pseq([Pwhite(0.01, 0.1, 1), 0.1, 1, 0.5, 0.5], inf),\n\t\\pan, Prand([-1, 1], inf) * 0.1\n))\n);",
    "Figure 420": "Figure 7.27\n\nNdef(\\x).play; // here an Ndef is used, the same can be done within a ProxySpace\nNdef(\\x, { |freq=5, detune=0| Impulse.ar(freq * [detune, 1 - detune]) * 0.2 });\n(\nTdef(\\c, {\n\tloop {\n\t\t Ndef(\\x).fadeTime = rrand(0.1, 3.5);\n\t\t Ndef(\\x).send([\\freq, exprand(2, 400), \\detune, [0.0, 1.0].choose.rand]);\n\t\t2.wait;\n\t}\n}).play\n);",
    "Figure 421": "figure 8.1 - a Puppet class, and tests for it.\n\t\nPuppet { \n\tvar <>myfreq; // an instance variable with a getter and a setter method\n\t\n\t\t// a method for creating a new object of this kind\n\t*new { |myfreq=50| ^super.new.myfreq_(myfreq) }\n\t\n\t\t// a simple method that uses 'myfreq' for something audible.\n\tblip { { Blip.ar(myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; }\n}\n\n\t// tests for the behavior implemented so far:\nm = Puppet.new(50);// make an instance of Puppet, pass in myfreq\n\nm.dump;\t\t\t// test that myfreq is set correctly\nm.myfreq;\t\t\t// test accessing myfreq\nm.blip;\t\t\t// should sound\nm.myfreq_(100);\t// test setting myfreq\nm.blip;\t\t // should sound differently",
    "Figure 422": "figure  8.2 - a puppet modeled as an event.\n\nm = (); \t\t\t// make an empty event\nm.myfreq_(50);\t// put something in it with a setter method: a pseudo-instance variable\nm.myfreq;\t\t\t// look it up with a getter method\n\t\t\t\t// put a function into it with a setter: \n\t\t\t\t// this becomes a pseudo-method\nm.blip_({ |ev| { Blip.ar(ev.myfreq, 11) * XLine.kr(1, 0.01, 0.6, doneAction: 2) }.play; });\nm.blip;\t\t// execute the function with a pseudo-method call (same name)",
    "Figure 423": "figure  8.3 - add more instance variables, change the blip method.\n(\nm.numHarms_(20); \t// a new instvar\nm.decay_(0.3); \t// and another\n\t\t\t\t// update the blip method to use them:\nm.blip_({ |ev| \n\t{ Blip.ar(ev.myfreq, ev.numHarms) \n\t* XLine.kr(1, 0.01, ev.decay, doneAction: 2) }.play; \n});\n)\nm.blip;\t// test",
    "Figure 424": "figure 8.4 - A minimal shout window sketch.\n\nz = z ? (); \t// make an empty event as a pseudo-object\nz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\nz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\nz.txtView.string_(\"Shout this!\");\nz.txtView.font_(Font(\"Monaco\", 32));\n\n\t// tune appearances\nz.win.alpha_(0.7);\t\t// make the window slightly transparent\nz.win.view.background_(Color.clear);\t// make the window's top view,\nz.txtView.background_(Color.clear);\t// and textview fully transparent\nz.win.alwaysOnTop_(true);\t// make sure it is always on top .\n\nz.win.close;\t// close when done",
    "Figure 425": "figure 8.5 - add a pseudo-method.\n(\nz.makeWin = { |z, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.string_(message);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", 32));\n\tz.txtView.background_(Color.clear);\n};\n)\nz.makeWin(\"Try showing that.\");",
    "Figure 426": "figure 8.6 - more pseudo-methods.\n\nz.setMessage = { |z, str| z.txtView.string_(str) };\n\nz.setMessage(\"Does this update?\");\t// test\n(\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n)\nz.shout(\"Do we get this?\"); // test\n\nz.win.close;\nz.shout(\"Do we get this too?\"); // also when window has closed?",
    "Figure 427": "figure 8.7 - text color animation\n\nz.txtView.stringColor_(Color.red);\t// try a single color\n(\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00c2\u00a0\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n)\nz.animate;\t\t\t// test with default values \nz.animate(0.1, 24); \t// and test with arguments given",
    "Figure 428": "figure 8.9 - using codeDump to shout \n\nthis.codeDump = { |str, result, func| [str, result, func].printAll };\n\na = 1 + 2;\t// code appears in post window\n\nz.shoutTag = \"//!!\";\nthis.codeDump = { |str| if (str.beginsWith(z.shoutTag)) { z.shout(str.drop(z.shoutTag.size)) } };\n\n//!! a comment with a 'shout tag' now gets shouted!",
    "Figure 429": "figure 8.10 - updated setMessage flashes text.\n(\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(GUI.font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n)\n//!! a long comment gets scaled down to a rather smaller font size, minimally fontsize 32! \n\n//!! short is big!\n(\nz.makeWin = { |q, message=\"Shout this!\"|\n\tz.win = Window(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = TextView(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n)\nz.makeWin(\"shout.\");",
    "Figure 430": "figure 8.11 - a Shout class\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\";\n\tvar <win, <txtView;\n\t\n\t*new { ^super.new }\n} \n// end of file - Shout.sc\n\n// tests: \nShout.tag;\nShout.tag_(\"//SHOUT\");\n\na = Shout.new; \na.win;\na.txtView;",
    "Figure 431": "figure 8.12 - more class variables and initClass method.\n\n// begin of file - Shout.sc\nShout {\n\tclassvar <>tag=\"//!!\", <>width=1250, <>defaultCodeDumpFunc; \n\tvar <win, <txtView;\n\t\n\t*initClass { \n\t\tdefaultCodeDumpFunc = { |str| if (str.beginsWith(tag)) { Shout(str.drop(tag.size)) } };\n\t}\n\t*new { ^super.new }\n} \n// end of Shout.sc\n\nShout.width;\nShout.defaultCodeDumpFunc;",
    "Figure 432": "figure 8.13 - converting makeWin.\n\nz.makeWin = { |message=\"Shout this!\"|\n\tz.win = GUI.window.new(\"Shout\", Rect(0, 900,1200, 100)).front;\n\tz.win.alpha_(0.7);\t\n\tz.win.view.background_(Color.clear);\t\n\tz.win.alwaysOnTop_(true);\n\n\tz.txtView = GUI.textView.new(z.win, Rect(0, 0,1200, 100));\n\tz.txtView.background_(Color.clear);\n\tz.setMessage(message);\n};\n\n\nShout {\t\n\t...\n\t*new { |message| ^super.new.makeWin(message); }\n\t\n\tmakeWin { |message=\"Shout this!\"| \n\t\n\t\twin = Window(\"Shout'er\", Rect(20, 800, width, 80)).front;\n\t\twin.alpha_(0.7);\n\t\twin.view.background_(Color.clear);\n\t\twin.alwaysOnTop_(true);\n\t\t\n\t\ttxtView = TextView(win, win.bounds.moveTo(0,0));\n\t\ttxtView.background_(Color.clear);\n\t\ttxtView.font_(Font.new(\"Monaco\", 32));\n\t\tthis.setMessage(message);\n\t}\n\n\tsetMessage { |message| \n\t\ttxtView.string_(message.asString)\n\t}\n}\n\n// tests:\nShout.new;\na = Shout.new(\"Blabla\");\na.setMessage(\"Otto\");",
    "Figure 433": "figure 8.14 - converting z.shout to Shout.new.\n\nz.shout = { |z, str|\n\tif (z.win.isNil or: { z.win.isClosed }) { z.makeWin };\n\tz.setMessage(str);\n};\n\nShout { \n\tclassvar <top;\n\t...\n\t*new { |message=\"\u00c2\u00a1Shout'er!\"| \n\n\t\tif (top.isNil or: { top.win.isClosed }) { \n\t\t\ttop = this.basicNew(message); \n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t\t// the method formerly known as *new\n\t*basicNew { |message=\"Shout this!\"| ^super.new.makeWin(message) } \n\n\t*close { try { top.win.close } }\n\t\n\t...\n}\n\n// tests: \nShout(\"Test 1, 2\");\nShout(\"Test 1, 2, 3, 4\");\t// same window\nShout.close;\n\nShout(\"Test 1, 2\");\t\t// new window",
    "Figure 434": "figure 8.15 - converting animate to a class method.\n\nz.animate = { |z, dt=0.2, n = 6| \n\tvar colors = [Color.red, Color.green, Color.black];\n\tTask { \n\t\tn.do { |i|\u00c2\u00a0\n\t\t\tdt.wait; \n\t\t\tz.txtView.stringColor_(colors.wrapAt(i))\n\t\t}\n\t}.play(AppClock)\n};\n\nShout { \n\t...\n\tanimate { |dt=0.2, n=6|\n\t\tvar colors = [Color.red, Color.green, Color.black]; \n\t\tTask { \n\t\t\tn.do { |i| \n\t\t\t\ttxtView.stringColor_(colors.wrapAt(i)); \n\t\t\t\tdt.wait \n\t\t\t};\n\t\t\ttxtView.stringColor_(Color.black); // make sure we end black\n\t\t}.play(AppClock);\n\t}\n\t...\t\n}\n\n// tests: \na = Shout(\"Test 1, 2\");\nShout.top.animate;",
    "Figure 435": "figure 8.16 - converting setMessage\n\nz.setMessage = { |z, str| \n\tvar messSize = str.size; \n\tvar fontsize = (1.64 * z.txtView.bounds.width) / max(messSize, 32);\n\tz.txtView.font_(Font.new(\"Monaco\", fontsize));\n\tz.txtView.string_(str);\n\tz.animate;\n};\n\nShout { \n\t...\n\tsetMessage { |message| \n\t\tvar messSize, fontSize;\n\t\tmessSize = message.size;\n\t\tfontSize = (1.64 * width) / max(messSize, 32);\n\t\t\n\t\tdefer { \n\t\t\ttxtView.font_(Font(\"Monaco\", fontSize))\n\t\t\t\t.string_(message.asString);\n\t\t};\n\t\tthis.animate;\n\t}\n\t...\t\n}\n\nShout(\"Test 1, 2\");\nShout(\"Test\" + (1..16));",
    "Figure 436": "figure 8.17 - codeDump tests and usage in Shout\n\nthis.codeDump.postcs;\t// anything there yet? by default, this is nil.\nthis.codeDump = this.codeDump.addFunc(Shout.defaultCodeDumpFunc); // add Shout\nthis.codeDump.postcs\t// should be there now\n//!! test whether Shout works now\nthis.codeDump = this.codeDump.removeFunc(Shout.defaultCodeDumpFunc);\nthis.codeDump.postcs\t// should be gone now\n\n//!! should be off again\n\nShout { \n\t...\n\t*add { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump\n\t\t\t.removeFunc(defaultCodeDumpFunc) // remove it first so it will \n\t\t\t\t\t\t\t\t\t\t// only be in the list once\n\t\t\t.addFunc(defaultCodeDumpFunc); \n\t}\n\t*remove { var interp = thisProcess.interpreter; \n\t\tinterp.codeDump = interp.codeDump.removeFunc(defaultCodeDumpFunc); \n\t}\n\t...\t\n}\n\n// tests\nShout.add;\n//!! test whether Shout works now - it should!\nShout.remove;\n//!! test whether Shout works now - should be off.",
    "Figure 437": "figure 8.18 - keeping Shout out of the way\n\nShout.close;\nShout(\"blabla\");\t// now typing is impossible, because the new window is in front.\n\nShout(\"blabla blabla\");\t// now one can type, because Shout window was already there.\nShout.close; \n\n\t// this does not work, because the shout window gets put in front later:\nd = Document.current; Shout(\\bla); d.front; \n \n\n\t// This can be wrapped around the call to this.makeWin in Shout:new:\nShout { \n\t...\n\t*new { |message=\"\u00c2\u00a1Shout'er!\"| \n\t\tvar currDoc;\n\n\t\tif (win.isNil or: { win.isClosed }) { \n\t\t\tcurrDoc = Document.current;\n\t\t\ttop = this.basicNew(message); \n\t\t\t\t// wait a little before restoring front window\n\t\t\tdefer ({ currDoc.front }, 0.1);\n\t\t} {\n\t\t\ttop.setMessage(message);\n\t\t};\n\t}\n\t...\t\n}",
    "Figure 438": "figure 8.19 - a fixed serialization method.\n\nserialize {|index, pos, extent = 8|\n\tvar ranges, slice;\n\n\t// get ranges\n\tranges = pos.collect{|pos, i| \n\t\t((pos-(extent*0.5))..(pos+(extent*0.5)-1)) % this.shape[i] \n\t};\n\t// get sub-slice\n\tslice = this.slice(index, *ranges);\n\t// trivial serialization of multidim. slice\n\t^slice.flat\n}",
    "Figure 439": "figure 8.20 - flexible  serialization by lookup.\n\nserialize {|index, pos, extent = 8, how = \\hilbert|\n\t// [...]\n\tslice = this.slice(index, *ranges);\n\t// call function in serTypes dictionary\n\t^serTypes[how].(slice.asArray, extent)\n}",
    "Figure 440": "figure 8.21 \u00e2\u0080\u0094 some initial serialization methods, and adding an alternative. \n\n\t*initClass {|numDims = 4|\n\t\t...\n\t\t// slice here is a 4d hypercube of extent <extent>\n\t\tserTypes = (\n\t\t\thilbert: {|slice, extent|\n\t\t\t\textent.isPowerOfTwo.not.if({\n\t\t\t\t\t\"QCD:serialize: extent has to be a power of two\".error\n\t\t\t\t});\n\t\t\t\tHilbertIndices.serialize(slice)\n\t\t\t},\n\t\t\ttorus: {|slice, extent|\n\t\t\t\tslice.flat;\n\t\t\t},\n\t\t\tscramble: {|slice|\n\t\t\t\tslice.flat.scramble;\n\t\t\t}\n\t\t);\n\t}\n\n\t// add a new serialization type at runtime\nQCD.serTypes.put(\\star, {|slice|\n\tvar starSize = slice.size div:2;\n\tvar numDims = 4;\n\tvar starShape;\n\n\tstarShape = neighbours1.collect({ |nb|  \n\t\t(0..starSize).collect(_ * nb) \n\t}).flatten(1).collect {|indexN| \n\t\tindexN + (starSize.div(2)+1).dup(numDims) \n\t};\n\t\n\tstarShape.collect{|iA| slice.slice(*iA)}\n});",
    "Figure 441": "figure 8.23 - two granular synthdefs and tests\n(\n\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gab1st, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp * AmpComp.ir(freq) * 0.5), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp * AmpComp.ir(freq) * 0.5), \n\t\t\ttimeScale: sustain, doneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\n/*\t\n\t// tests for the synthdefs:\nSynth(\\gab1st);\nSynth(\\percSin);\nSynth(\\percSin, [\\amp, 0.2, \\sustain, 0.1]);\nSynth(\\gab1st, [\\out, 0, \\amp, 0.2, \\freq, 2000, \\sustain, 0.05, \\pan, 0.5] );\n*/\n);",
    "Figure 442": "figure 8.24 - global setup and a player Tdef for the cloud.\n(\nq = q ? (); \n\n\t// some globals\nq.paramRNames = [\\freqRange, \\durRange, \\densRange, \\ampRange, \\panRange]; \nq.paramNames = [\\freq, \\grDur, \\dens, \\amp, \\pan]; \nq.syndefNames = [\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise];\n\n\t// specs for some parameters\nSpec.add(\\xfadeTime, [0.001, 1000, \\exp]);\nSpec.add(\\ring, [0.03, 30, \\exp]);\nSpec.add(\\grDur, [0.0001, 1, \\exp]);\nSpec.add(\\dens, [1, 1000, \\exp]);\n\n\t// make an empty tdef that plays it, \n\t// and put the cloud parameter ranges in the tdef's environment\nTdef(\\cloud0)\n\t.set(\n\t\\synName, \\gab1st,\n\t\\vol, 0.25,\n\t\\current, (\n\t\tfreqRange: [200, 2000],\n\t\tampRange: [0.1, 1],\n\t\tdurRange: [0.001, 0.01], \n\t\tdensRange: [1, 1000],\n\t\tpanRange: [-1.0, 1.0] \n\t)\n); \n\t\t\n\t\t// make the tdef that plays the cloud of sound particles here, \n\t\t// based on parameter range settings.\nTdef(\\cloud0, { |e| \n\n\tloop {\n\t\ts.sendBundle(s.latency, [\n\t\t\t\"/s_new\", e.synName ? \\gab1st, \n\t\t\t-1, 0, 0,\n\t\t\t\\freq, \texprand(e.current.freqRange[0], e.current.freqRange[1]),\n\t\t\t\\amp,\texprand(e.current.ampRange[0], e.current.ampRange[1]) * e.vol,\n\t\t\t\\sustain,\texprand(e.current.durRange[0], e.current.durRange[1]),\n\t\t\t\\pan, \trrand(e.current.panRange[0], e.current.panRange[1])\n\t\t]);\n\t\texprand(e.current.densRange[0].reciprocal, e.current.densRange[1].reciprocal).wait; \n\t}\n}).quant_(0);\t\n);",
    "Figure 443": "figure  8.25\t-  tests for the cloud\n\t\nTdef(\\cloud0).play;\n\n\t// try changing various things from outside the loop. \n\t// change its playing settings \n\nTdef(\\cloud0).envir.current.put('densRange', [ 50, 200 ]); // dense, async\nTdef(\\cloud0).envir.current.put('densRange', [ 1, 10 ]);  // sparse, async\nTdef(\\cloud0).envir.current.put('densRange', [ 30, 30 ]); // synchronous\n\n\t// for faster access, call the tdef's envir d\nd = Tdef(\\cloud0).envir;\nd.current.put('freqRange', [ 800, 1200 ]);\nd.current.put('durRange', [ 0.02, 0.02 ]);\n\nd.current.put('ampRange', [ 0.1, 0.1 ]);\n\nd.current.put('panRange', [ 1.0, 1.0 ]);\nd.current.put('panRange', [ -1.0, 1.0 ]);\n\nd.current.put('densRange', [ 30, 60 ]);\nd.synName = \\percSin;\nd.synName = \\gab1st;\nd.current.put('durRange', [ 0.001, 0.08 ]);",
    "Figure 444": "figure 8.26 - making random settings, and 8 random presets to switch between\n(\n\t// make the Tdef's envir a global variable for easier experimenting\nd = Tdef(\\cloud0).envir;\n\t// a pseudo-method to make random settings, kept in the Tdef's environment\n\t\t// randomize could also do limited variation on existing setting. \nd.randSet = { |d|\n\tvar randSet = ();\t\n\tq.paramRNames.do { |pName, i| \n\t\trandSet.put(pName, \n\t\t\tq.paramNames[i].asSpec.map([1.0.rand, 1.0.rand].sort)\n\t\t);\n\t};\n\trandSet;\n};\n\n/* \ttest randSet: \nd.current = d.randSet;\n*/\n\n// make 8 sets of parameter range settings: \nd.setNames = (1..8).collect { |i| (\"set\" ++ i).asSymbol };\nd.setNames.do { |key| d[key] = d.randSet; }\n\n/*\ttest switching to the random presets\nd.current = d.set1.copy;\t// copy to avoid writing into a stored setting when it is current.\nd.current = d.set3.copy;\t\nd.current = d.set8.copy;\n*/\n);",
    "Figure 445": "figure 8.29 - a lightweight graphical user interface for CloudGenMini \n(\nq.makeCloudGui = { |q, tdef, posPoint| \n\tvar w, ezRangers, fdBox; \n\tvar setMinis, skipjack; \n\t\n\tposPoint = posPoint ? 400@400;\t// where to put the gui window\n\t\n\tw = Window.new(\"CloudGen_mini_sc3\", \n\t\tRect.fromPoints(posPoint, (posPoint + (400@320))), false).front;\tw.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));\n\t\t\n\tw.view.decorator.nextLine; \n\t\t// the range sliders display the current values\n\tezRangers = ();\n\t\n\tq.paramRNames.do { |name, i| \n\t\tezRangers.put(name, \n\t\tEZRanger(w, 400@20, name, q.paramNames[i], \n\t\t\t{ |sl| tdef.envir.current[name] = sl.value; }, \n\t\t\ttdef.envir.current[name], labelWidth: 70, numberWidth: 50, unitWidth: 10)\n\t\t\t.round_([0.1, 0.00001, 0.0001, 0.0001, 0.01][i])\n\t\t);\n\t};\n\t\t// a just in time - gui for the Tdef\n\tTdefGui(tdef, parent: w); \n\n\tw.view.decorator.nextLine;\n\t\n\tButton.new(w, 80@20).states_([[\\randomize]])\n\t\t.action_({ \n\t\t\ttdef.envir.target_(d.randSet);\n\t\t\ttdef.envir.morphtask.stop.play;\n\t\t});\n\t\n\tfdBox = EZNumber.new(w, 110@20, \\xFadeTime, [0, 100, \\amp], \n\t\t{ |nbx| tdef.envir.xfadeTime = nbx.value }, \n\t\t tdef.envir.xfadeTime, false, 65); \n\n\t\t\t// skipjack is a task that survives cmd-period:\n\t\t\t// used here for lazy-updating the control views.\n\tskipjack = SkipJack({  \n\t\tq.paramRNames.do { |name| ezRangers[name].value_(tdef.envir.current[name]) };\n\t\tfdBox.value_(tdef.envir.xfadeTime); \n\t\t\n\t\t// mark last settings that were used by color? \n\t\t// a separate color when changed? \n\t\t\n\t}, 0.5, { w.isClosed }, name: tdef.key);\n\t\n\tw.view.decorator.nextLine;\n\n\t// make a new layoutView for the 8 presets; \n\t// put button to switch to that preset, \n\t// a button to save current settings to that place, \n\t// and a miniview of the settings as a visual reminder in it.\n\t\n\t\t// make 8 setButtons\n\ttdef.envir.setNames.do { |setname, i|\t\n\t\tvar minisliders, setMinis;\n\t\tvar zone = CompositeView.new(w, Rect(0,0,45, 84));\n\t\tzone.decorator = FlowLayout(zone.bounds, 0@0, 5@0); \n\t\tzone.background_(Color.white); \n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20)).states_([[setname]])\n\t\t\t.action_({ \n\t\t\t\t// just switch: // tdef.envir.current.putAll(d[setname] ? ()) \n\t\t\t\ttdef.envir.target = tdef.envir[setname];\n\t\t\t\ttdef.envir.morphtask.stop.play;\n\t\t\t});\n\t\t\n\t\tButton.new(zone, Rect(0,0,45,20))\n\t\t\t.states_([[\"save\" ++ (i + 1)]])\n\t\t\t.action_({ \n\t\t\t\td[setname] = tdef.envir.current.copy; \n\t\t\t\tsetMinis.value;\n\t\t\t});\n\t\t\n\t\tminisliders = q.paramRNames.collect { |paramRname| \n\t\t\tRangeSlider.new(zone, 45@8).enabled_(false);\n\t\t};\n\t\tsetMinis = { \n\t\t\tq.paramRNames.do { |paramRname, i| \n\t\t\t\tvar paramName = q.paramNames[i];\n\t\t\t\tvar myrange = d[setname][paramRname];\n\t\t\t\tvar unmapped = paramName.asSpec.unmap(myrange); \n\t\t\t\tminisliders[i].lo_(unmapped[0]).hi_(unmapped[1]);\n\t\t\t} \n\t\t};\n\t\tsetMinis.value;\n\t};\n\n/* \tSome extras: \n\ta volume slider for simple mixing, \n\ta popup menu for switching syndefnames; \n\ta button to stop/start the skipjack for refreshing, \n\tso one can use numberboxes to enter values.\n*/\n\tEZSlider(w, 245@20, \"vol\", \\amp, { |sl|tdef.set(\\vol, sl.value) }, \n\t\t0.25, false, 20, 36);\n\n\tStaticText.new(w, 55@20).string_(\"synthdef:\").align_(\\right); \n\tPopUpMenu.new(w, Rect(0,0,80,20))\n\t\t.items_([\\gab1st, \\gabWide, \\percSin, \\percSinRev, \\percNoise])\n\t\t.action_({ |pop| tdef.envir.synName = pop.items[pop.value] });\n\t\n\tButton.new(w, 80@20).states_([[\\continuous], [\\fadeStops]])\n\t\t.value_(tdef.envir.stopAfterFade.binaryValue)\n\t\t.action_({ |btn|\n\t\t\ttdef.set(\\stopAfterFade, btn.value == 1)\n\t\t});\n\n\tButton.new(w, 80@20).states_([[\\skipWatching], [\\skipWaiting]])\n\t\t.action_({ |btn|\n\t\t\t[ { skipjack.play }, { skipjack.stop }][btn.value].value\n\t\t});\n\n};\nq.makeCloudGui(Tdef(\\cloud0))\n);",
    "Figure 446": "figure 9.2\n\n(\nvar window, slider, mySynth;\nmySynth = Synth(\\default);\nwindow = SCWindow(\"myWindow\", Rect(100,100, 220, 40));\nslider = SCSlider(window, Rect(8,4, 200, 20))\n\t\t.value_(440.explin(20,20000,0,1))\n\t\t.action_({|view| \n\t\t\tmySynth.set(\\freq,\n\t\t\t\tview.value.linexp(0,1,20,20000).postln\n\t\t\t)\t\n\t\t})\n\t\t.onClose_({mySynth.release;});\nwindow.front;\nCmdPeriod.doOnce({window.close});\n)",
    "Figure 447": "figure 9.3\n\n(\nvar window, slider, mySynth, spec;\nmySynth = Synth(\\default);\nspec = \\freq.asSpec;\nwindow = SCWindow(\"myWindow\", Rect(100,100, 220, 40));\nslider = SCSlider(window, Rect(8,4, 200, 20))\n\t\t.value_(spec.unmap(440))\n\t\t.action_({|view| \n\t\t\tmySynth.set(\\freq,\t\t\t\n\t\t\t\tspec.map(view.value).postln\n\t\t\t)\n\t\t})\n\t\t.onClose_({mySynth.release;});\nwindow.front;\nCmdPeriod.doOnce({window.close});\n)",
    "Figure 448": "figure 9.5\n\n// simple MVC example\n(\nvar window, slider, level, updater, model, numberbox, setValueFunction;\n\n//model\nmodel = (myValue: 1);\nsetValueFunction = {|value| \n\t\t\tmodel [\\myValue] = value; \n\t\t\tmodel.changed(\\value, value);\n};\n\n//view\nwindow = SCWindow(\"myWindow\", Rect(100, 100, 288, 80));\nnumberbox = SCNumberBox(window, Rect(20, 20, 44, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nslider = SCSlider(window, Rect(68, 20, 200, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \n\nlevel = SCLevelIndicator(window, Rect(272, 20, 5, 20))\n\t\t\t.warning_(0.8)\n\t\t\t.critical_(1.0);\n\nwindow.front;\nwindow.onClose_({model.removeDependant(updater);});\n\n//updater\nupdater = {|theChanger, what, val| \n\t\t\t\t\tif(what == \\value, {\n\t\t\t\t\t\tnumberbox.value_(val);\n\t\t\t\t\t\tslider.value_(val);\n\t\t\t\t\t\tlevel.value_(val);\n\t\t\t\t\t});\n\t\t\t\t};\nmodel.addDependant(updater);\n\nsetValueFunction.value(0.4);\n)",
    "Figure 449": "figure 9.6\n\n(\nvar window;\nwindow = SCWindow(\"AppClock\").front;\nTask({\n\t100.do{|i|\n\t\twindow.view.background_(Color.grey(i/100));\n\t\t0.04.wait;\n\t}\n}).play(AppClock);\n)",
    "Figure 450": "figure 9.7\n\n(\nvar window, slider, updater, model, level, numberbox, setValueFunction, oscresponder;\n\n//model\nmodel = (myValue: 1);\nsetValueFunction = {|value| \n\t\t\tmodel [\\myValue] = value; \n\t\t\tmodel.changed(\\value, value);\n};\n\n//view\nwindow = SCWindow(\"myWindow\", Rect(100,100, 288, 80));\nnumberbox = SCNumberBox(window, Rect(20, 20, 44,20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nslider = SCSlider(window, Rect(68,20, 200, 20))\n\t\t\t.value_(model[\\myValue])\n\t\t\t.action_({|view| setValueFunction.value(view.value)}); \nlevel = SCLevelIndicator(window, Rect(272, 20, 5, 20))\n\t\t\t.warning_(0.8)\n\t\t\t.critical_(1.0);\n\t\nwindow.front;\nwindow.onClose_({model.removeDependant(updater); oscresponder.remove;});\n\n//updater\nupdater = {|theChanger, what, val| \n\t\t\t\t\t{\n\t\t\t\t\tif(what == \\value, {\n\t\t\t\t\t\tnumberbox.value_(val);\n\t\t\t\t\t\tslider.value_(val);\n\t\t\t\t\t\tlevel.value_(val);\n\t\t\t\t\t});\n\t\t\t\t\t}.defer;\n\t\t\t\t};\nmodel.addDependant(updater);\n\n// play a Synth on the server\nSynthDef(\"send_trig\",{\n\tSendTrig.kr(Dust.kr(2.0), 0, LFNoise1.kr(1, 0.5, 0.5));\n}).play(s);\n\n// register to receive the message from the Synth above and let it set the model\noscresponder = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;\n\tsetValueFunction.value(msg[3]);\n}).add;\n\n)",
    "Figure 451": "figure 9.8\n\n(\nvar window, button, composite, slider, numberbox;\nwindow = SCWindow(\"myWindow\", Rect(100,100, 288, 80));\nbutton = SCButton(window, Rect(4,4, 100, 20))\n\t\t\t.states_([[\"hide\"], [\"show\"]])\n\t\t\t.action_({|v| \n\t\t\t\tif(v.value==0){\n\t\t\t\t\tcomposite.visible_(true)\t\n\t\t\t\t}{\n\t\t\t\t\tcomposite.visible_(false)\n\t\t\t\t}\n\t\t\t});\n\ncomposite = SCCompositeView(window, Rect(0, 40, 268, 28))\n\t\t\t.background_(Color.blue);\nnumberbox = SCNumberBox(composite, Rect(4, 4, 40,20));\nslider = SCSlider(composite, Rect(48,4, 200, 20));\n\t\nwindow.front;\n)",
    "Figure 452": "figure 9.10\n\n(\nvar window, listView, updater, changeItemGui, model;\n\nmodel = [\\item1, \\item2, \\item3];\n\nwindow = SCWindow(\"double click example\", Rect(200,200,180, 320)).front;\nlistView = SCListView(window, Rect(4,4,172, 310))\n\t\t\t\t.items_(model)\n\t\t\t\t.mouseDownAction_({|view, x, y, modifiers, buttonNumber, clickCount|\n\t\t\t\t\tif(clickCount == 2){\n\t\t\t\t\t\tchangeItemGui.value(view)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.onClose_({model.removeDependant(updater)});\n\nchangeItemGui = {|view|\n\tvar win;\n\twin = SCWindow(\"chnage item\", Rect(200,250, 150, 30)).front;\n\tSCTextField(win, Rect(4,4, 142, 20))\n\t\t.string_(view.item.asString)\n\t\t.action_({|v|\n\t\t\tmodel[view.value] = v.string.asSymbol;\n\t\t\tmodel.changed(\\value);\n\t\t\twin.close;\n\t\t})\n\t\t.focus;\n};\n\nupdater = {|theChanger, what, moreArgs|\n\tlistView.items_(theChanger)\n};\nmodel.addDependant(updater);\n\n)",
    "Figure 453": "figure 9.11\n\n(\n\tvar window, listViews, model, updater;\n\t\n\tmodel = (\tleft: [ \"SinOsc\", \"Saw\", \"LFSaw\", \"WhiteNoise\", \"PinkNoise\", \"BrownNoise\", \"Osc\" ], \n\t\t\t\tright: []);\n\t\n\twindow = SCWindow(\"list view drag & drop\", Rect(200,200, 255, 100)).front;\n\twindow.view.decorator_(FlowLayout(window.view.bounds));\n\t\n\tlistViews = [\\left, \\right].collect{|it|\n\t\tSCListView(window, Rect(10,10,120,70))\n\t\t\t.items_(model[it])\n\t\t\t.canReceiveDragHandler_{ SCView.currentDrag.isKindOf(Symbol) or: SCView.currentDrag.isKindOf(String)}\n\t\t\t.receiveDragHandler_{|v| \n\t\t\t\tvar index;\n\t\t\t\tindex = model[it].indexOfEqual(SCView.currentDrag);\n\t\t\t\tif(index.notNil){\n\t\t\t\t\tv.value_(index);\n\t\t\t\t}{\n\t\t\t\t\tmodel[it] = model[it].add(SCView.currentDrag);\n\t\t\t\t\tmodel.changed(it);\n\t\t\t\t\tv.value_(v.items.size-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t.beginDragAction_{|v| v.item}\n\t\t\t.action_({|view|\n\t\t\t\t[view.value, view.item].postln;\n\t\t\t})\n\t\t\t.onClose_({model.removeDependant(updater)});\n\t};\n\t\n\tupdater = {|theChanger, what, moreArgs| \n\t\t\tswitch(what, \n\t\t\t\t\\left, {listViews[0].items_(model[\\left])},\n\t\t\t\t\\right, {listViews[1].items_(model[\\right])}\n\t\t\t)\n\t\t\t};\n\tmodel.addDependant(updater);\n)",
    "Figure 454": "figure 9.13\n\n\n(\nvar window, userView, value=false;\nwindow = SCWindow(\"toggle view\", Rect(200,200, 166, 66)).front;\nuserView = SCUserView(window, Rect(10,10, 40,40))\n\t\t\t\t.drawFunc_({|v|\n\t\t\t\t\tvar width, height, offset=2;\n\t\t\t\t\twidth =  v.bounds.width;\n\t\t\t\t\theight = v.bounds.height;\n\t\t\t\t\tSCPen.use{\n\t\t\t\t\t\t//draw outline and background\n\t\t\t\t\t\tSCPen.strokeRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\t\t\t\t\t\tSCPen.fillColor_(Color.white);\n\t\t\t\t\t\tSCPen.fillRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\n\t\t\t\t\t\tif(value){\n\t\t\t\t\t\t\t//draw the toggle cross\n\t\t\t\t\t\t\tSCPen.line(Point(offset, height-offset), Point(width-offset, offset));\n\t\t\t\t\t\t\tSCPen.line(Point(offset, offset), Point(width-offset, height-offset));\n\t\t\t\t\t\t\tSCPen.stroke;\n\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t//switch states on mouse-down\n\t\t\t\t.mouseDownAction_({|view|\n\t\t\t\t\tvalue = value.not;\n\t\t\t\t\tview.refresh;\n\t\t\t\t});\n~win = window;\n)",
    "Figure 455": "figure 9.14\n\nTToggle : SCUserView{\n\tvar <> value=false;\n\t\n\tinit{ arg argParent, argBounds;\n\t\tsuper.init(argParent, argBounds);\n\t\tbackground = Color.white\n\t}\n\t\n\t*viewClass{\n\t\t^SCUserView\n\t}\n\t\n\tdraw{\n\t\tvar width, height, offset=2;\n\t\twidth =  this.bounds.width;\n\t\theight = this.bounds.height;\n\t\tSCPen.use{\n\t\t\t//draw outline and background\n\t\t\tSCPen.strokeRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\t\t\tSCPen.fillColor_(Color.white);\t\t\t\t\n\t\t\tSCPen.fillRect(Rect(offset, offset, width-(offset*2), height-(offset*2)));\n\n\t\t\tif(value){\n\t\t\t\t//draw the toggle cross\n\t\t\t\tSCPen.line(Point(offset, height-offset), Point(width-offset, offset));\n\t\t\t\tSCPen.line(Point(offset, offset), Point(width-offset, height-offset));\n\t\t\t\tSCPen.stroke;\n\n\t\t\t};\n\t\t}\n\t}\n\t\n\t//override \n\tmouseDown{arg x, y, modifiers, buttonNumber, clickCount;\n\t\tvalue = value.not;\n\t\tthis.refresh;\n\t\tmouseDownAction.value(this, x, y, modifiers, buttonNumber, clickCount);\t\n\t}\n}",
    "Figure 456": "figure 9.16\n\n(\nvar createGUIFor, synthDefName, eventForSynthDef;\nsynthDefName = \\default;\nSynthDescLib.global.read;\n\n//create a custom ControlSpec if necessary:\nControlSpec.specs.put(\\out, ControlSpec(0, 128, \\lin, 1, 0));\n\n//model \n\neventForSynthDef = {|synthDefName|\n\tvar event, node;\n\tevent = (\n\t\t\tinstrument: synthDefName,\n\t\t\tplay: {\n\t\t\t\tvar args = event.select{|it| it.isKindOf(Number)}.asKeyValuePairs;\n\t\t\t\tnode = Synth(~instrument, args);\n\t\t\t\t\tOSCpathResponder(Server.default.addr, [\"/n_end\", node.nodeID], \n\t\t\t\t\t\t{|time, resp, msg| \n\t\t\t\t\t\t\tnode = nil;\n\t\t\t\t\t\t\tevent.changed(\\play, 0); \n\t\t\t\t\t\t\tresp.remove;\n\t\t\t\t\t\t} \n\t\t\t\t\t).add;\t\t\n\t\t\t\tevent.changed(\\play, 1);\n\t\t\t\t\n\t\t\t},\n\t\t\tstopPlaying:{\n\t\t\t\tif( SynthDescLib.global[synthDefName].hasGate) {\n\t\t\t\t\tnode.release;\n\t\t\t\t}{\n\t\t\t\t\tnode.free;\t\t\t\t\t\n\t\t\t\t};\n\t\t\t\tnode = nil;\n\t\t\t\tevent.changed(\\play, 0);\n\t\t\t\t\n\t\t\t},\n\t\t\tsetArg: {|inevent, argName, value|\n\t\t\t\tinevent.use{\n\t\t\t\t\tif(node.notNil){\n\t\t\t\t\t\tnode.set(argName, value);\n\t\t\t\t\t};\n\t\t\t\t\tinevent.put(argName.asSymbol, value);\n\t\t\t\t\tinevent.changed(argName.asSymbol);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t);\n\tSynthDescLib.global[synthDefName.asSymbol].controls.do{|it|\n\t\tevent.put(it.name.asSymbol, it.defaultValue);\n\t};\n\tevent\n};\n\ncreateGUIFor = {|event, window|\n\tvar controlNames, playButton, height, updater, funcDict;\n\n\t//GUI\n\t\t\n\tcontrolNames = SynthDescLib.global[event[\\instrument]].controls;\n\t\n\theight = controlNames.size * 24 +40;\n\t\n\twindow = SCWindow(\"myWindow\", Rect(100,100, 328, height));\n\twindow.view.decorator_(FlowLayout(window.view.bounds));\n\t\n\tSCStaticText(window, 80@20).string_(event[\\instrument].asString);\n\t\n\tplayButton = SCButton(window, 120@20)\n\t\t\t.states_([[\"play\"],[\"stop\"]])\n\t\t\t.action_({|view| \n\t\t\t\tif(view.value==1){\n\t\t\t\t\tevent.play;\t\n\t\t\t\t}{\n\t\t\t\t\tevent.stopPlaying;\n\t\t\t\t}\n\t\t\t});\n\t\n\tfuncDict = IdentityDictionary.new;\n\t\n\t//register button in funcDict\n\tfuncDict.put(\\play, {|value| {playButton.value_(value)}.defer});\t\n\t\n\twindow.view.decorator.nextLine;\n\t\n\t//create sliders\n\t\n\tcontrolNames.do{|control, i| \n\t\tvar spec, name, action, initValue, slider;\n\t\tname = control.name;\n\t\tspec = name.asSymbol.asSpec ? [0,1].asSpec;\n\t\taction = {|view| event.setArg(name, view.value)};\n\t\tinitValue = control.defaultValue;\n\t\tslider = EZSlider(window, 300@20, name, spec, action, initValue);\n\t\twindow.view.decorator.nextLine;\n\t\t\n\t\t//register slider at controller\n\t\t\n\t\tfuncDict.put(control.asSymbol, {|value|\n\t\t\t{\n\t\t\t\tslider.value_(spec.unmap(value));\n\t\t\t}.defer\n\t\t})\n\t};\n\t\n\t// updater\n\tupdater = {|theChanger, what, value|\n\t\tfuncDict[what].value(value);\n\t};\n\tevent.addDependant(updater);\n\t\n\twindow.front;\n\twindow.onClose_{event.stopPlaying; event.removeDependant(updater)};\n\t\n\n};\n\n//evaluate the GUI function \n\ncreateGUIFor.value(eventForSynthDef.(synthDefName));\n)",
    "Figure 457": "figure 9.18\n\n(\nvar window, button, createSingletonFunc, singletonWindow;\n\ncreateSingletonFunc = {|view|\n\tif(singletonWindow.isNil){\n\t\tsingletonWindow = SCWindow(\"singleton\").front\n\t\t\t.onClose_({singletonWindow = nil});\n\t}{\n\t\tsingletonWindow.front;\n\t}\n};\n\nwindow = SCWindow(\"open Singleton\", Rect(300,300, 200, 40)).front;\nbutton = SCButton(window, Rect(4,4,192, 30))\n\t\t\t.states_([[\"singleton\"]])\n\t\t\t.action_(createSingletonFunc);\n)",
    "Figure 458": "figure 9.20\n\n(\nvar k;\nk= KeyCodeResponder.new;\n//  shift control p\nk.register(   35  ,   true, false, false, true, {\n\tCocoaDialog.getPaths({|paths|\n\t\tDocument.current.selectedString_(paths[0].asCompileString);\n\t});\n});\nDocument.globalKeyDownAction_(k)\n)",
    "Figure 459": "Figure 10.1\n\n// boot the sound synthesis server and prepare a SynthDef for buffer playback\n(\ns.waitForBoot({\n    SynthDef( \\bufPlay, { arg buf, amp = 1.0, speed = 1.0;\n        Out.ar( 0, Pan2.ar( \nPlayBuf.ar( 1, buf, speed * BufRateScale.kr( buf ), loop: 1 ) * amp )\n);\n    }).add;\n    ~buf = Buffer.read( s, \"sounds/a11wlk01.wav\" );\n});\n)\n\n// now replace the action function\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf ]);\n    }, {\n        ~node.free; ~node = nil;\n    })\n};\n)",
    "Figure 460": "Figure 10.2\n\n~amp   = 0.5;  // initial amplitude\n~speed = 1.0;  // initial speed (1.0 is normal, 0.5 is half-speed, etc.)\n(\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~node = Synth( \\bufPlay, [ \\buf, ~buf, \\amp, ~amp, \\speed, ~speed ]);\n    }, {\n        ~node.free; ~node = nil;\n    })};\n)\n~win.setInnerExtent( 370, 72 );  // more suitable dimensions for the window\n~win.resizable = false;\nJSCStaticText( ~win, Rect( 56, 4, 50, 25 )).align_( \\right ).string_( \"Amp:\" );\n(\n~ampSlider = JSCSlider( ~win, Rect( 110, 4, 200, 25 ))\n    .value_( ~amp ) // initial slider position\n    .action_({ arg view;\n        ~amp = view.value;\n        ~node.set( \\amp, ~amp );\n    });\n)\nJSCStaticText( ~win, Rect( 56, 32, 50, 25 )).align_( \\right ).string_( \"Speed:\" );\n~speedSpec = ControlSpec( 1/8, 8, \\exp );\n(\n~speedSlider = JSCSlider( ~win, Rect( 110, 32, 200, 25 ))\n    .value_( ~speedSpec.unmap( ~speed ))  // initial slider position\n    .action_({ arg view;\n        ~speed = ~speedSpec.map( view.value );\n        ~node.set( \\speed, ~speed );\n    });\n)",
    "Figure 461": "Figure 10.4\n\n~node.free; ~node = nil;\n\n(\n~model        = Event.new;\n~model.amp    = ~amp;\n~model.speed  = ~speed;\n~model.node   = ~node;\n~model.buf    = ~buf;\n~model.adjust = { arg mod, key, value, source;\n    mod.put( key, value );\n    mod.changed( key, value, source )};\n\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\amp, value )}, \\amp );\nUpdateListener.newFor( ~model, { arg upd, mod, value;\n    mod.node.set( \\speed, value )}, \\speed );\n\n~playButton.action = { arg view;\n    if( view.value == 1, {\n        ~model.node = Synth( \\bufPlay, [\n            \\buf, ~model.buf, \\amp, ~model.amp, \\speed, ~model.speed ]);\n    }, {\n        ~model.node.free; ~model.node = nil;\n    })};\n~ampSlider.action   = { arg view;\n    ~model.adjust( \\amp, view.value, view )};\n~speedSlider.action = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( view.value ), view )};\n)",
    "Figure 462": "Figure 10.5\n\n(\n~ampText = JSCStaticText( ~win, Rect( ~ampSlider.bounds.right + 2, 4, 50, 25 ));\n~ampTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~ampText.string = \"% dB\".format( value.ampdb.round( 0.1 ))}, \\amp );\n~speedText = JSCStaticText( ~win, Rect( ~speedSlider.bounds.right + 2, 32, 50, 25 ));\n~speedTextUpd = UpdateListener.newFor( ~model, { arg upd, mod, value;\n    ~speedText.string = \"%\\\\%\".format( (value * 100).round( 0.1 ))}, \\speed );\n)\n// note: the sliders must be initially dragged to cause view updates!",
    "Figure 463": "Figure 10.7\n\n(\n~ampSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~ampSlider, {\n        ~ampSlider.value = value;\n    })}, \\amp );\n~speedSliderUpd = UpdateListener.newFor( ~model, { arg upd, mod, value, source;\n    if( source !== ~speedSlider, {\n        ~speedSlider.value = ~speedSpec.unmap( value );\n    })}, \\speed );\n)",
    "Figure 464": "Figure 10.10\n\n// ~win = JSCWindow.new;\n[ \"/local\", 1000, \"[\", \"/new\", \"de.sciss.swingosc.Frame\", \"panel\", \"[\", \"/new\", \"java.awt.Rectangle\", 128, 64, 400, 400, \"]\", 0, \"]\" ]\n[ \"/local\", \"ac1000\", \"[\", \"/new\", \"de.sciss.swingosc.WindowResponder\", \n1000, \"]\", 1001, \"[\", \"/method\", 1000, \"getContentPane\", \"]\" ]]\n[ \"/local\", \"key1001\", \"[\", \"/new\", \"de.sciss.swingosc.KeyResponder\", 1001,\n\"]\" ]\n[ \"/local\", \"cmp1001\", \"[\", \"/new\", \"de.sciss.swingosc.ComponentResponder\",\n1001, \"]\" ]]\n\t\t\n// ~win.front;\n[ \"/set\", 1000, \"visible\", 1 ]\n[ \"/method\", 1000, \"toFront\" ]]\n\n// ~playButton = JSCButton( ~win, Rect( 4, 4, 40, 56 ));\n[ \"/local\", 1002, \"[\", \"/new\", \"de.sciss.gui.MultiStateButton\", \"]\", \n\"ac1002\", \"[\", \"/new\", \"de.sciss.swingosc.ActionResponder\", 1002, \"[\",\n\"/array\", \"selectedIndex\", \"lastModifiers\", \"]\", \"]\" ]\n[ \"/set\", 1002, \"bounds\", \"[\", \"/new\", \"java.awt.Rectangle\", 1, 1, 46, 62,\n\"]\", \"font\", \"[\", \"/ref\", \"font\", \"]\" ]\n[ \"/local\", \"dnd1002\", \"[\", \"/new\", \n\"de.sciss.swingosc.DummyTransferHandler\", 1002, 2, \"]\" ]\n[ \"/local\", \"key1002\", \"[\", \"/new\", \"de.sciss.swingosc.KeyResponder\", 1002,\n\"]\" ]\n[ \"/local\", \"cmp1002\", \"[\", \"/new\", \"de.sciss.swingosc.ComponentResponder\",\n1002, \"]\" ]]\n[ \"/method\", 1001, \"add\", \"[\", \"/ref\", 1002, \"]\" ]\n[ \"/method\", 1001, \"revalidate\" ],\n[ \"/method\", 1001, \"repaint\" ]]\n\n// ~playButton.states = [[ \"Play\", Color.white, Color.green( 0.4 )],\n//                       [ \"Stop\", Color.white, Color.red ]];\n[ \"/method\", 1002, \"removeAllItems\" ]\n[ \"/method\", 1002, \"addItem\", \"Play\", \"[\", \"/new\", \"java.awt.Color\", 1.0, \n1.0, 1.0, 1.0, \"]\", \"[\", \"/new\", \"java.awt.Color\", 0.0, 0.4, 0.0, 1.0,\n\"]\" ]\n[ \"/method\", 1002, \"addItem\", \"Stop\", \"[\", \"/new\", \"java.awt.Color\", 1.0, \n1.0, 1.0, 1.0, \"]\", \"[\", \"/new\", \"java.awt.Color\", 1.0, 0.0, 0.0, 1.0,\n\"]\" ]]",
    "Figure 465": "Figure 10.11\n\n[ \"/component\", 1001, \"resized\", 0, 0, 400, 400 ]\n[ \"/window\", 1000, \"opened\" ]\n[ \"/window\", 1000, \"activated\" ]\n[ \"/window\", 1000, \"gainedFocus\" ]\n[ \"/window\", 1000, \"resized\", 128, 414, 400, 421 ]\n[ \"/component\", 1001, \"resized\", 0, 0, 400, 399 ]\n[ \"/window\", 1000, \"moved\", 128, 414, 400, 421 ]\n[ \"/window\", 1000, \"lostFocus\" ]\n[ \"/window\", 1000, \"deactivated\" ]",
    "Figure 466": "Figure 10.13\n\n(\n~mySlider            = Event.new;\n~mySlider.view       = JSCUserView( ~win, Rect( 110, 32, 200, 145 )).focusVisible_( false );\n~mySlider.pos        = ~speedSpec.unmap( ~model.speed );\n// these will be used in the final draw func:\n~mySlider.pressed    = false;\n~mySlider.project    = false;\n// this will update the slider position and refresh the view:\n~mySlider.adjustPos  = { arg slid, pos;\n    slid.pos         = pos;\n    slid.view.action.value( slid );\n    slid.view.refresh };\n// these will set the slider track curve and refresh the view:\n~mySlider.adjustCurve= { arg slid, curve;\n    slid.curve       = curve;\n    slid.lines       = curve.slide( 2, 1 ).clump( 2 );\n    slid.lineLens    = slid.lines.collect({ arg pair; pair[ 0 ].dist( pair[ 1 ])}).normalizeSum; \n    slid.projections = nil;\n    slid.view.refresh };\n// a primary draw function just to indicate the view's bounds:\n~mySlider.view.drawFunc = { arg view; var b = view.bounds;\n    JPen.line( 0 @ 0, b.width @ b.height );\n    JPen.line( 0 @ b.height, b.width @ 0 );\n    JPen.stroke };\n// make the window a little bigger:\n~win.setInnerExtent( 370, 180 );\n)",
    "Figure 467": "Figure 10.14\n\n(\n~mySlider.adjustCurve([ 0 @ 0, 0.25 @ 1, 0.5 @ 0, 1.0 @ 0.5 ]);\n~mySlider.view.drawFunc = { arg view;\n    var b, scale, lnP1, lnP2, linePos, proj, inner, sum = 0;\n    b     = view.bounds;\n    // scaling factor for coordinates normalized to 0...1\n    scale = b.width @ b.height;\n    // set the initial curve coordinate\n    JPen.moveTo( ~mySlider.curve[ 0 ] * scale );\n    (1..(~mySlider.curve.size-1)).do({ arg i;\n        // create the curve by adding successive line segments\n        JPen.lineTo( ~mySlider.curve[ i ] * scale );\n    });\n    // stroke the curve with a 2-pixel wide black pen\n    JPen.width = 2;\n    JPen.color = Color.black;\n    JPen.stroke;\n    // draw the knob: iterate over the line segments until\n    // the one is found inside which the knob (read from ~mySlider.pos)\n    // is located.\n    block { arg break;\n        ~mySlider.lineLens.do({ arg len, i;\n            // if we have found the line segment...\n            if( sum + len >= ~mySlider.pos, {\n                // calucate the point inside this segment\n                // (proj) and draw a filled circle around it\n                #lnP1, lnP2    = ~mySlider.lines[ i ];\n                linePos        = (~mySlider.pos - sum) / len;\n                proj           = lnP1 + ((lnP2 - lnP1) * linePos);\n                JPen.fillOval( Rect.aboutPoint( proj * scale, 8, 8 ));\n                // if this view is focused, use blue color, otherwise grey\n                JPen.fillColor = Color.hsv( 0.7, view.hasFocus.if( 0.7, 0.0 ), 1.0 );\n                // if the mouse is pressed, the outline should be thicker\n                inner          = if( ~mySlider.pressed, 5, 7 );\n                JPen.fillOval( Rect.aboutPoint( proj * scale, inner, inner ));\n                break.value;\n            });\n            sum = sum + len;\n        });\n    };\n    \n    // a debugging utility to visualize the point projections\n    // of the mouse dragging\n    if( ~mySlider.project, {\n        ~mySlider.projections.do({ arg pt;\n            pt = pt * scale;\n            JPen.line( pt + (-5 @ -5), pt + (5 @  5) );\n            JPen.line( pt + (-5 @  5), pt + (5 @ -5) );\n        });\n        JPen.width = 1; JPen.stroke;\n    });\n};\n)",
    "Figure 468": "Figure 10.15\n\n(\nvar mouseFunc = { arg view, x, y, modifiers, buttonNumber, clickCount;\n    var b, nx, ny, dx, dy, lnP1, lnP2, linePos, lineLenSq,\n        proj, dist, sum = 0, minDist = inf, newValue;\n    \n    b  = view.bounds;\n    nx = x / b.width;\n    ny = y / b.height;\n    ~mySlider.projections = Array( ~mySlider.lines.size );\n    // look up the line segment which is closest to the mouse\n    ~mySlider.lines.do({ arg pair, i;\n        #lnP1, lnP2 = pair;\n        dx          = lnP2.x - lnP1.x;\n        dy          = lnP2.y - lnP1.y;\n        lineLenSq   = (dx*dx) + (dy*dy);\n        dist        = (((nx - lnP1.x) * dx) + ((ny - lnP1.y) * dy)) / lineLenSq;\n        proj        = (lnP1.x + (dist * dx)) @ (lnP1.y + (dist * dy));\n        if( lnP1.x != lnP2.x, {\n            linePos = (proj.x - lnP1.x) / dx;\n        }, {\n            linePos = (proj.y - lnP1.y) / dy;\n        });\n        if( linePos < 0, {\n            proj = lnP1;\n        }, { if( linePos > 1, {\n            proj = lnP2;\n        })});\n        ~mySlider.projections.add( proj );\n        dist = proj.dist( nx @ ny );\n        if( dist < minDist, {\n            newValue = sum + (linePos.clip( 0, 1 ) * ~mySlider.lineLens[i]);\n            minDist  = dist;\n        });\n        sum = sum + ~mySlider.lineLens[ i ];\n    });\n    ~mySlider.pressed = true;\n    ~mySlider.adjustPos( newValue );\n};\n~mySlider.view.mouseDownAction = mouseFunc;\n~mySlider.view.mouseMoveAction = mouseFunc;\n~mySlider.view.mouseUpAction   = { arg view; ~mySlider.pressed = false; view.refresh };\n~mySlider.view.action          = { arg view;\n    ~model.adjust( \\speed, ~speedSpec.map( ~mySlider.pos ), ~mySlider )};\n)",
    "Figure 469": "Figure 10.17\n\n(\n~action = { arg fileName; \"Selected file is '%'\\n\".postf( fileName )};\n~sResp  = JavaObject( \"de.sciss.swingosc.ActionResponder\", nil, ~fileChooser.id );\n~cResp  = OSCpathResponder( g.addr, [ '/action', ~fileChooser.id ], {\n    fork { var file, fileName;\n        file     = ~fileChooser.getSelectedFile__;\n        fileName = file.getAbsolutePath_;\n        file.destroy;\n        ~action.value( fileName.asString );\n    };\n}).add;\n)",
    "Figure 470": "Figure 10.18\n\n(\n~cp.remove( ~fileChooser );\n~frame.dispose;\n~cp.destroy; ~frame.destroy;\n~win.setInnerExtent( 760, 340 );   // again a bit bigger\n~plug = JSCPlugView( ~win, Rect( 370, 2, 386, 336 ), ~fileChooser );\n~action = { arg fileName; var sf, oldBuf;\n    // try to open as a sound file. returns nil if it could not be opened\n    if( (sf = SoundFile.openRead( fileName )).notNil, {\n        sf.close;  // the header info was read, we can close the file\n        if( sf.numChannels == 1, {  // allow mono files only\n            oldBuf = ~model.buf;\n            if( ~model.node.notNil, {  // free old buffer when synth is freed\n                UpdateListener.newFor( ~model.node, { arg upd;\n                    upd.remove; oldBuf.free }, \\n_end );\n                ~model.node.register;\n            }, {\n                oldBuf.free;\n            });\n            ~model.buf = Buffer.read( s, fileName );  // replace buffer\n        }, {\n            \"Sound file must be mono\".error;\n        });\n    });\n};\n)",
    "Figure 471": "Figure 10.19\n\nimport java.io.File;\nimport javax.swing.filechooser.FileFilter;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\n\npublic class SoundFileChooser extends javax.swing.JFileChooser\nimplements java.beans.PropertyChangeListener\n{\n    private final java.util.List listeners = new java.util.ArrayList();\n    \n    public SoundFileChooser() {\n        super();        \n        final FileFilter filter = new FileFilter() {            \n            public boolean accept( File f ) {\n                if( f.isDirectory() ) return true;\n                try {\n                    return( de.sciss.io.AudioFile.retrieveType( f ) !=\n                            de.sciss.io.AudioFileDescr.TYPE_UNKNOWN );\n                }\n                catch( java.io.IOException e ) { return false; }\n            }\n        \n            public String getDescription() { return \"Audio Files\"; }\n        };\n        addChoosableFileFilter( filter );\n        setFileFilter( filter );\n        setControlButtonsAreShown( false );\n        addPropertyChangeListener( SELECTED_FILE_CHANGED_PROPERTY, this );\n        addPropertyChangeListener( DIRECTORY_CHANGED_PROPERTY, this );\n    }\n    \n    public String getSelectedPath() {\n        final File f = getSelectedFile();\n        return f == null ? \"\" : f.getAbsolutePath();\n    }\n    \n    public void setSelectedPath( String path ) {\n        setSelectedFile( new File( path ));\n    }\n    \n    public String getCurrentDirectoryPath() {\n        return getCurrentDirectory().getAbsolutePath();\n    }\n    \n    public void setCurrentDirectoryPath( String path ) {\n        setCurrentDirectory( new File( path ));\n    }\n    \n    public void addChangeListener( ChangeListener l ) { listeners.add( l ); }\n    public void removeChangeListener( ChangeListener l ) { listeners.remove( l ); }\n\n    public void propertyChange( java.beans.PropertyChangeEvent pce ) {\n        final ChangeEvent ce = new ChangeEvent( this );\n        for( int i = 0; i < listeners.size(); i++ ) {\n            ((ChangeListener) listeners.get( i )).stateChanged( ce );\n        }\n    }\n}",
    "Figure 472": "Figure 10.20\n\nJSCSoundFileChooser : JSCView {\n    var <path;       // String : current file selection (or nil)\n    var <directory;  // String : currently visible directory\n    var chResp;      // OSCpathResponder for ChangeResponder\n\n    path_ { arg value;\n        path = value;\n        server.sendMsg( '/set', this.id, \\selectedPath, value );\n    }\n\n    directory_ { arg value;\n        directory = value;\n        server.sendMsg( '/set', this.id, \\currentDirectoryPath, value );\n    }\n\n    prSCViewNew {\n        chResp = OSCpathResponder( server.addr, [ '/change', this.id ], {\n            arg time, resp, msg; var oldPath = path;\n            path        = if( msg[ 4 ] !== '', { msg[ 4 ].asString });\n            directory   = msg[ 6 ].asString;\n            if( oldPath != path, {{ this.doAction }.defer });\n        }).add;\n        ^super.prSCViewNew([[ '/local', this.id, '[', '/new', \"SoundFileChooser\", ']', \"ch\" ++ this.id, '[', '/new', \"de.sciss.swingosc.ChangeResponder\", this.id, '[', '/array', \\selectedPath, \\currentDirectoryPath, ']', ']' ]]);\n    }\n\n    prClose {\n        chResp.remove;\n        ^super.prClose([[ '/method', \"ch\" ++ this.id, \\remove ],\n                        [ '/free', \"ch\" ++ this.id ]]);\n    }\n}",
    "Figure 473": "Figure 10.21\n\n(\n~plug.remove;\t// this implicitly calls ~fileChooser.destroy!\n~soundChooser        = JSCSoundFileChooser( ~win, Rect( 370, 2, 386, 306 ));\n~soundChooser.path   = \"sounds/a11wlk01.wav\".absolutePath;\n~loadButton          = JSCButton( ~win, Rect( 370, 312, 60, 24 )).states_([[ \"Load\" ]]).enabled_( false );\n~infoText            = JSCStaticText( ~win, Rect( 438, 312, 318, 24 ));\n~soundChooser.action = { arg view; var enabled = false, info = \"\", sf;\n    if( view.path.notNil and: { (sf = SoundFile.openRead( view.path )).notNil }, {\n        sf.close;\n        enabled         = sf.numChannels == 1;\n        info            = \"% audio, %-chan. % % kHz, %\".format( sf.headerFormat, sf.numChannels, sf.sampleFormat, sf.sampleRate/1000, (sf.numFrames/sf.sampleRate).asTimeString );\n    });\n    ~loadButton.enabled = enabled;\n    ~infoText.string    = info;\n};\n~loadButton.action   = { ~action.value( ~soundChooser.path )};\n)",
    "Figure 474": "Figure 10.22\n\n(\n~ampSlider.resize     = 2;\n~mySlider.view.resize = 5;\n~ampText.resize       = 3;\n~speedText.resize     = 3;\n~soundChooser.resize  = 6;\n~loadButton.resize    = 9;\n~infoText.resize      = 9;\n~win.resizable        = true;\n)",
    "Figure 475": "Figure 11.3\n// Tasks \n(\nSynthDef(\"task\", { arg out=0, freq=2000;\n\tvar env = EnvGen.kr(Env.perc, 1.0, 0.2, doneAction:2);\n\tvar source = DynKlank.ar(`[ [0.5, 0.8, 1, 1.2, 2, 4]*freq, nil, nil ], PinkNoise.ar(0.007));\n\tOut.ar(out, source * env ! 2);\n}).add;\n\nt = Task({\n\tvar freq;\n\tloop {\n\t\tfreq = ((1..10)*220).choose;\n\t\tSynth(\"task\", [\\freq, freq]);\n\t\t0.3.wait;\n\t}\n})\n)\n\nt.start;\nt.stop;",
    "Figure 476": "Figure 11.4\n// Patterns\n(\nSynthDef(\"pattern\", { arg out=0, freq=220, pan=0, gate=1;\n\tvar ctl = RLPF.ar(Saw.ar(5, 1.0, 2), 25, 0.03);\n \tvar source = SinOsc.ar(ctl * freq) * 0.1;\n\tvar env = EnvGen.kr(Env.adsr, gate, doneAction: 2);\n\tOut.ar(out, Pan2.ar(source * env, pan));\n}).add;\n\ne = Pbind(\n\t\\midinote, Pxrand(#[60, 61, 63, 65, 72], 20), \n\t\\dur, 0.4,\n\t\\pan, Pwhite(-1.0, 1.0, 20),\n\t\\instrument, \\pattern\n);\n)\n\ne.play;",
    "Figure 477": "Figure 11.5\n// ProxySpace\np = p ?? ProxySpace.push(s);\n\n~ctl = { SinOsc.kr(1) * 110 + 440 };\n~out = { arg freq=220, amp=0.5; Ringz.ar(Dust.ar(2, 0.4), freq, 0.8) ! 2 };\n\n~out.play;\n\n~out.map(\\freq, ~ctl);\n\n~ctl = { SinOsc.kr(LFSaw.kr(5, add: 2.0) * 10) * 220 + 440 };\n\nProxyMixer(p);\n\n~out.stop;\n~out.clear;",
    "Figure 478": "Figure 11.7\n// MIDI Example\n(\nSynthDef(\\midi, { arg out=0, midinote=60, dur=0.1;\n\tvar source = Blip.ar(midinote.midicps, 4, 0.2);\n\tvar env = EnvGen.kr(Env.perc(0.1, dur), 1.0, doneAction: 2);\n\tOut.ar(out, (source * env) ! 2);\n\n}).add;\n\nc = NoteOnResponder( { |src, chan, num, vel|\n\t[num, vel].postln;\n\tSynth.new(\\midi, [\\midinote, num, \\dur, vel/512]);\n});\n)\nc.remove;",
    "Figure 479": "Figure 11.8\n// NetAddr and OSCresponder example\nn = NetAddr(\"localhost\", 57120); \nr = OSCresponder(n, '/good/news', { arg time, resp, msg; [time, msg].postln }).add;\n\nn.sendMsg(\"/good/news\", \"you\", \"not you\");\n\nr.remove;\nn.disconnect;",
    "Figure 480": "Figure 11.9\n// GUI Example\n(\n\tSynthDef(\\gui, { arg out=0, freq=8, decay=0.11;\n\t\tvar in = Formlet.ar(Impulse.ar(freq, 0, 0.4), 800, 0.01, decay);\n\t\tOut.ar(out, in ! 2);\n\t}).add;\n)\n(\n\ta = Synth.newPaused(\\gui);\n\tw = Window.new( \"A GUI window\", Rect( 128, 64, 340, 250 ));\n\tw.view.decorator = FlowLayout( w.view.bounds );\n\n\tb = Button.new( w, Rect( 50, 20, 75, 24 ));\n\tb.states = [[ \"Start\"],[ \"Stop\"]];\n\tb.action_({ arg butt;\n\t\tif (butt.value == 1, { a.run }, { a.run(false) });\t\n\t});\n\n\tc = Slider2D.new( w, Rect(50, 120, 330, 200));\n\tc.x_(0.5).y_(0.5).action_({|sl|\n\t\t\ta.setn(\\freq, [sl.x * 10 + 3, sl.y / 5 + 0.01]);\n\t});\n\tw.front;\n)",
    "Figure 481": "Figure 12.1\n//#!/usr/local/bin/sclang\nif (thisProcess.argv.isEmpty) {\n\t\"Missing arguments!\".postln;\n\texit(1);\n};\nthisProcess.argv.do { | argu, i |\n\t\"% : %\\n\".postf(i, argu);\n};\nexit(0);",
    "Figure 482": "Figure 12.3\n// select the following lines and type C-c C-d\n// stop synthesis with C-c C-s\n{\n\tvar trem = LFTri.kr(3).range(-12.dbamp, 0.dbamp);\n\tSinOsc.ar(\n\t\t{ rrand(60, 80).midicps } ! 6,\n\t\tmul: -10.dbamp * trem\n\t).clump(2).sum\n}.play",
    "Figure 483": "Figure 12.4\n// evaluate the following lines by double-clicking on the\n// first paranthesis when `transient-mark-mode' is enabled\n// and pressing C-c C-c\n(\nx = {\nSaw.ar(\nXLine.kr(20, [400,403,407], 20),\nmul: 0.7\n).clump(2).sum\n}.play; \"scel\";\n)\n// evaluate this line by pressing C-c C-c\nx.free; \"rocks\";",
    "Figure 484": "figure 13.1 - Loading the data\n(\nq = q ? ();\nq.execdata = ();\nq.execdata.years = (1977 .. 2008); \n\t// data is: [total for each region, 1977 ... 2007];\nq.execdata.regions = (\n\tTotal: [1099,1,0,2,0,1,2,5,21,18,18,25,11,16,23,14,31,38,31,\n\t\t\t56,45,74,68,98,85,66,71,65,59,60,53,42,37],\n\tNortheast: [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,1,0,0,0],\n\tMidwest: [129,0,0,0,0,1,0,0,0,1,0,0,0,1,5,1,1,4,3,11,9,10,5,12,5,10,9,7,7,14,6,5,2],\n\tSouth: [933,0,0,1,0,0,2,5,21,16,18,24,10,13,17,13,26,30,26,41,29,60,\n\t\t55,74,76,50,61,57,50,43,44,36,35],\n\tWest: [67,1,0,1,0,0,0,0,0,1,0,1,1,2,1,0,4,4,2,2,7,4,8,11,4,4,1,0,2,2,3,1,0],\n\tTexas: [423,0,0,0,0,0,1,0,3,6,10,6,3,4,4,5,12,17,14,19,3,37,20,35,40,17,33,24,23,19,24,26,18]\n);\nq.getReg = { |q, regName| q.execdata.regions[regName].drop(1) };\n)",
    "Figure 485": "figure 13.2 - Mapping the data to pitch in discrete events\n(\nPbindef(\\exec, \n\t\\note, Pseq(q.getReg(\\Midwest)), \n\t\\octave, 3, \n\t\\dur, 5 / q.execdata.years.size\n).play;\n)\n\t// the different regions\nPbindef(\\exec, \\note, Pseq(q.getReg(\\Northeast)));\nPbindef(\\exec, \\note, Pseq(q.getReg(\\West)));\nPbindef(\\exec, \\note, Pseq(q.getReg(\\South)));",
    "Figure 486": "figure 13.3 - Continuous data sonification\n \nb = Buffer.sendCollection(s, q.getReg(\\Northeast), 1); \n(\nNdef(\\exec, { |dur = 5, scale=50, offset=200| \n\tvar vals = PlayBuf.ar(1, b, dur / SampleRate.ir );\n\tPan2.ar(\n\t\tSinOsc.ar(vals  * scale + offset), 0, \n\t\tEnvGen.kr(Env.linen(0.01, dur, 0.01, 0.2), doneAction: 2)\n\t);\n}).play;\n)\n\t// load other regions into buffer\nb.sendCollection(q.getReg(\\Midwest));   Ndef(\\exec).send;\nb.sendCollection(q.getReg(\\West));   Ndef(\\exec).send;\nb.sendCollection(q.getReg(\\South));   Ndef(\\exec).send;",
    "Figure 487": "figure 13.4 - Sound design with noise pulses \n(\nSynthDef( \"noisepulses\", { arg out = 0, sustain=1.0, numPulses = 0, pan = 0.0, amp = 0.2; \n\tOut.ar(out, \n\t\tPanAz.ar(4, \n\t\t\tPinkNoise.ar \n\t\t\t* Decay2.ar(Impulse.ar(numPulses / sustain, 0, numPulses.sign), 0.001, 0.2),\n\t\t\tpan, \n\t\t\tEnvGen.kr( Env.linen(0.0, 0.995, 0.0), levelScale: amp, timeScale: sustain, doneAction: 2)\n\t\t)\n\t);\n}).add;\nSynthDef(\\tick, { |out, amp=0.2, pan| \n\tOffsetOut.ar(out, Pan2.ar(Impulse.ar(0) * Line.kr(amp, amp, 0.001, doneAction: 2), pan)) \n}).add;\n)\n(instrument: \\noisepulses, numPulses: 10, legato: 1, dur: 2).play;\n(instrument: \\tick).play;",
    "Figure 488": "figure 13.5 - Four regions in sequence\n(\nTdef(\\execs, { \n\tvar yearDur = 2;\t// one year is 2 seconds\n\tvar region, numExecs, numyears = q.execdata.years.size; \n\t[\\Northeast, \\Midwest, \\West, \\South].do { |regName, i| \n\n\t\tregion = q.execdata.regions[regName].postln; \n\t\tq.execdata.years.do { |year, i| \n\t\t\tnumExecs = region[i + 1]; \n\t\t\t[regName, year, numExecs].postln;\n\t\t\t(instrument: \\tick).play;\n\t\t\tif (numExecs > 0) {\n\t\t\t\t(instrument: \\noisepulses, legato: 1, \nnumPulses: numExecs, dur: yearDur).play;\n\t\t\t};\n\t\t\tyearDur.wait;\n\t\t};\n\t\tyearDur.wait;\n\t};\n}).play;\n)",
    "Figure 489": "figure 13.6 - Four regions in parallel\n(\n// four channels playing, ordered by total number. \n// On stereo systems, only the first 2 channels play.\nTdef(\\execs, { \n\tvar yearDur = 2;\t// one year is 2 seconds\n\tq.execdata.years.do { |year, i| \n\tvar region, numExecs, numyears = q.execdata.years.size; \n\t\t// ordered by total number, on stereo, only first 2 play.\n\t[\\South, \\Midwest,  \\West, \\Northeast ].do { |regName, j| \n\n\t\tregion = q.execdata.regions[regName].postln; \n\t\t\tnumExecs = region[i + 1]; \n\t\t\t[regName, year, numExecs].postln;\n\t\t\t(instrument: \\tick).play;\n\t\t\tif (numExecs > 0) {\n\t\t\t\t(instrument: \\noisepulses, legato: 1, \ndur: yearDur, \n\t\t\t\t\tnumPulses: numExecs, \n\t\t\t\t\tpan: j * 0.5 - 0.25 \t// to 4 channels\n\t\t\t\t).play;\n\t\t\t};\n\t\t};\n\t\tyearDur.wait;\n\t};\n}).play;\n)",
    "Figure 490": "figure 13.7 - Sonification of tag systems\n(\n// compare two axioms on left and right channels\n// ? = 4 (size of alphabet)\n// v (deletion number) varies [1..6] with horizontal cursor position\n{\n\tvar tag, rules, val;\n\trules = [[0, 1, 1], [1, 3, 2, 0], [1, 2], [3, 1, 1]]; // same rule for both\n\tv = MouseX.kr(1, 6);\n\tval = dup {\n\t\tvar axiom = Array.fill(14, { #[0, 1, 2, 3].choose }); axiom.join.postln;\n\t\tDuty.ar(1 / SampleRate.ir, 0,  Dtag(7e5, v, axiom, rules), doneAction:2);\n\t} * 0.1\n}.play;\n)",
    "Figure 491": "figure 13.12 - Rotational Grain Train\n(\n~rotater = {|amp = 1|\n\tvar rotVel = ~rotVel.kr;\t// rotVel and height from tracking data proxies\n\tBPF.ar(\n\t\tImpulse.ar((rotVel > 0.5) * rotVel * 5).lag(0.0001),\n\t\t(~height.kr * 120 + 36 + [[0, 7], [0, 12], [0, 16]]).midicps, \n\t\t0.2\n\t).collect({ |pair| (pair * [1, 0.125]).sum }) \t* 6 * amp\n};\n)",
    "Figure 492": "figure 13.13 - Rotation Trigger\n(\n~planeTicker = {|saw2sin = 1, filterFreq = 2000, fSpread = 0.4, amp = 0.1|\n\t\n\tvar freq = 3000 * fSpread * (~height.kr * 4 - 1).range(0.5, 2);\n\n\tvar src = SelectX.ar(\n\t\tsaw2sin, \n\t\t[LFSaw.ar(freq) , SinOsc.ar(freq)]\n\t) \n\t* Decay2.ar(\n\t\tTrig1.ar(~zeroCrossing.ar, 0.001) * 0.1, \n\t\t0.001,\n\t\t0.3\n\t);\n\n\tLPF.ar(src, filterFreq, mul: amp * 0.1)\n};\n)",
    "Figure 493": "figure 13.14 - Distances to the Head\n(\n~backCross = {|amp = 1|\n\tvar \tnumObj = 3;\n\tvar \tin = ~isLeft.kr(numObj);\n\tvar \theight = ~height.kr(numObj), \n\t\tfront = ~isFront.kr(numObj); \n\tvar aEnv, fEnv, aEnvNoise;\n\n\tvar trig = Trig1.ar((in - Delay1.kr(in)).abs - 1, 0.00001) > 0.5;\n\t// only trigger if behind the body and near ground\n\ttrig = trig * (front < 0) * (height < 0.26);\n\taEnv = EnvGen.kr(Env.perc(0.05, 2), gate: trig);\n\taEnvNoise = EnvGen.kr(Env.perc(0.01, 0.1), gate: trig);\n\tfEnv = EnvGen.kr(\n\t\tEnv.perc(0.01, 0.1), gate: trig, \n\t\tlevelScale: 900, levelBias: 50\n\t);\n\t\n\taEnv * ((0.2 * WhiteNoise.ar * aEnvNoise) + \n\tSinOsc.ar(fEnv * (height * 8).squared * 0.4, 0, 1.5).softclip) * amp\n};\n)",
    "Figure 494": "figure 13.15 -  Left-right Trigger\n(\n~distances = {|amp = 0.2795| \n\tLFSaw.ar(min((~dist.kr * 2.5 * 90 + 20).midicps, 44100)) * amp\n};\n)",
    "Figure 495": "figure 13.16 - Rain on Bells\n(\n\n~clackUp = { |amp = 0.1|\n\tFormlet.ar(\n\t\t~trigsUp.ar.lag(0.0004), \n\t\t(~height.kr).exprange(25, 2500), \n\t\t0.002,\n\t\t0.05\n\t)\n\t* (~height.kr * 4 ** 2) \n\t* amp\n};\n)",
    "Figure 496": "figure 13.18: Navegar \u00e2\u0080\u0093 sound design for a single country\n(\n~single = { |rootFreq = 220, outProp = 4.5, inProp = 2.2, attack=0.00, decay = 1.0, \n\tdens = 2, amp=0.2, x=1, y = 0, step=0.33333| \n\t\n\tvar numChans = 4; \n\t\n\tvar freqs = rootFreq * [ 1/outProp, 1/inProp, 1, inProp, outProp]; \n\t\n\tvar exciter = (Dust2.ar(dens * [ 1,2,4,2,1] * 0.07)  \t// five individual rd triggers for \n\t\t\t\t\t\t\t\t\t\t// each component, weighted for center\n\t\t\t+ Dust2.ar(dens * 0.3))\t\t\t\t// + some common attacks\n\t\t\t\t.clip2(0.5)\t\n\t\t\t\t.lag(0.0003) \t\t\t\t// slightly filtered\n\t\t\t\t* (dens ** -0.5)\t\t\t\t// amplitude comp for dust density\n\t\t\t+ PinkNoise.ar(0.002)\t\t\t\t// some fused background noise\n\t\t\t* (decay ** -0.5);\t\t\t\t// amplitude comp. for decay\n\t\t\t\t\n\tvar resonator = Formlet.ar( exciter, freqs, \n\t\tRamp.kr(attack, step), decay, \n\t\tAmpComp.kr(freqs.max(50))\n\t).softclip.sum; \n\t\n\tvar pos = atan2(Ramp.kr(y, step), Ramp.kr(x, step)) * (pi.reciprocal) + 1; // look west.\n\n\tPanAz.ar(numChans, LeakDC.ar(resonator, 0.95), pos, Ramp.kr(amp, step));\n};\n~single.play;\n)",
    "Figure 497": "Figure 14.1\n\n(\n/// basic setup\ns = Server.local.boot;\n\ns.doWhenBooted({\n\tSynthDef( \\nicepoc, { |out=0,freq=440,amp=0.1,dur=0.3|\n\t\tOut.ar( out, SinOsc.ar( freq, mul: amp )*EnvGen.kr( Env.perc(0.05,1), timeScale: dur, doneAction:2 ) )\n\t}).add;\n});\n)\n\n// mono, 1 channel:\n(\np = Pbind(\n     \\degree, Pseq([0, 3, 5, 6, 7],5),\n     \\dur, 0.2,\n     \\instrument, \\nicepoc\n).play;\n)\n\np.stop;\n\n// multiple mono:\n// the melody gets played on both channels, the second note in the pattern differs,\n// so when listening to it, the space \"spreads\" out\n(\np = Pbind(\n     \\degree, Pseq([0 ,[3,4], 5, 6, 7],5),\n     \\out, [0,1],\n     \\dur, 0.2,\n     \\instrument, \\nicepoc\n).play;\n)\n\np.stop;",
    "Figure 498": "Figure 14.3\n\n\n// 2 channel panners:\n Pan2.ar( in, pos, level );\n LinPan2.ar( in, pos, level );\n Balance2.ar( left, right, pos, level );\n Rotate2.ar( x, y, pos );\n\n// 4-channel panner:\n Pan4.ar( in, xpos, ypos, level );\n\n// N-channel panner:\n PanAz.ar( numChans, in, pos, level, width, orientation );\n\n// spread M channels over a stereo field:\n Splay.ar( inArray, spread, level, center, levelComp );\n\n// spread M channels over N channels:\n SplayAz.ar( numChans, inArray, spread, level, width, center, orientation, levelComp );",
    "Figure 499": "Figure 14.5\n\n// single tap delay lines\nDelayN.ar(in, maxdelaytime, delaytime, mul, add)\nDelayL.ar(in, maxdelaytime, delaytime, mul, add)\nDelayC.ar(in, maxdelaytime, delaytime, mul, add)\n\n// allpass filters:\nAllpassN.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nAllpassL.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nAllpassC.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\n\n// comb filters (delaylines with feedback):\nCombN.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nCombL.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\nCombC.ar(in, maxdelaytime, delaytime, decaytime, mul, add)\n\n// buffer versions:\n\nBufDelayN.ar(buf, in, delaytime, mul, add)\nBufDelayL.ar(buf, in, delaytime, mul, add)\nBufDelayC.ar(buf, in, delaytime, mul, add)\n\nBufAllpassN.ar(buf, in, delaytime, decaytime, mul, add)\nBufAllpassL.ar(buf, in, delaytime, decaytime, mul, add)\nBufAllpassC.ar(buf, in, delaytime, decaytime, mul, add)\n\nBufCombN.ar(buf, in, delaytime, decaytime, mul, add)\nBufCombL.ar(buf, in, delaytime, decaytime, mul, add)\nBufCombC.ar(buf, in, delaytime, decaytime, mul, add)\n\n\n// special delay lines utilising PlayBuf:\nTap.ar(bufnum, numChannels, delaytime)\nPingPong.ar(bufnum, inputArray, delayTime, feedback, rotate)",
    "Figure 500": "Figure 14.6\n\n // Create a buffer.\nb=Buffer.alloc(s, s.sampleRate, 1); //enough space for one second of mono audio \n\n// Write to the Buffer with BufWr, read using several taps and mix them together:\n(\nSynthDef(\\helpTap, {|bufnum|\n var source, capture;\n source= Impulse.ar(1);\n capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));\n\t Out.ar(0, Mix.new([1,0.95,0.94,0.93,0.8,0.4,0.4]*Tap.ar(bufnum, 1, [0.04,0.1,0.22,0.88,0.9,0.91,0.93])));\n}).add;\n)\n\nx=Synth(\\helpTap,[\\bufnum, b.bufnum]);\nx.free;\n\n( // alternate source; use headphones to avoid feedback\nSynthDef(\\helpTap2, {|bufnum|\n var source, capture;\n source= SoundIn.ar(0);\n capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));\n\t Out.ar(0, Mix.new([1,0.95,0.94,0.93,0.8,0.4,0.4]*Tap.ar(bufnum, 1, [0.04,0.1,0.22,0.88,0.9,0.91,0.93])));\n}).add;\n)\n\nx=Synth(\\helpTap2,[\\bufnum, b.bufnum]);\nx.free;\n\n// free buffer:\nb.free;",
    "Figure 501": "Figure 14.7\n\n\n// convolving two signals with each other:\nConvolution.ar( in, kernel, framesize, mul, add )\n\n// convolving one signal with a buffer:\nConvolution2.ar( in, kernel, trigger, framesize, mul, add )\n// as above with linear interpolation:\nConvolution2L.ar( in, kernel, trigger, framesize, crossfade, mul, add )\n// as above, with two buffers:\nStereoConvolution2L.ar( in, kernelL, kernelR, trigger, framesize, crossfade, mul, add )\n\n// time based convolution (highly inefficient for audio rate)\nConvolution3.ar( in, kernel, trigger, framesize, mul, add )\nConvolution3.kr( in, kernel, trigger, framesize, mul, add )\n\n// partitioned convolution\nPartConv.ar(in, fftsize, irbufnum, mul, add)",
    "Figure 502": "Figure 14.8\n\n\n// one channel input:\nFreeVerb.ar(in, mix, room, damp, mul, add)\n// 2 channel input and output:\nFreeVerb2.ar(in, in2, mix, room, damp, mul, add)\n\n// stereo reverb\n#left, right = GVerb.ar(in, roomsize, revtime, damping, inputbw,\n spread, drylevel, earlyreflevel, taillevel, maxroomsize, mul, add)",
    "Figure 503": "Figure 14.10\n\n\n// 5.1 array (subwoofer must be treated separately)\nVBAPSpeakerArray.new(2, [ -30, 30, 0, -110, 110 ]);\n\n// 16 channel partial dome\nVBAPSpeakerArray.new(3, [[-22.5, 14.97], [22.5, 14.97], [-67.5, 14.97], [67.5, 14.97], [-112.5, 14.97], [112.5, 14.97], [-157.5, 14.97], [157.5, 14.97], [-45, 0], [45, 0], [-90, 0], [90, 0], [-135, 0], [135, 0], [0, 0], [180, 0]]);",
    "Figure 504": "Figure 14.11\n\n\na = VBAPSpeakerArray.new(3, [[-22.5, 14.97], [22.5, 14.97], [-67.5, 14.97], [67.5, 14.97], [-112.5, 14.97], [112.5, 14.97], [-157.5, 14.97], [157.5, 14.97], [-45, 0], [45, 0], [-90, 0], [90, 0], [-135, 0], [135, 0], [0, 0], [180, 0]]); // zig zag partial dome\n\nb = a.loadToBuffer; // send speaker config to the server\n\n(\n// pan around the circle up and down\nx = { |azi = 0, ele = 0, spr = 10|\nvar source;\nsource = PinkNoise.ar(0.2);\nVBAP.ar(16, source, b, LFSaw.kr(0.5, 0).range(-180, 180) * -1, SinOsc.kr(3, 0).range(0, 14.97), spr);\n}.play;\n)",
    "Figure 505": "Figure 14.12\n\n\n// 3D encoding:\nPanB.ar(in, azimuth, elevation, gain)\n// 2D encoding:\nPanB2.kr(in, azimuth, gain)\n// 2D encoding of a stereo signal:\nBiPanB2.kr(inA, inB, azimuth, gain)\n\n// decoding (2D):\nDecodeB2.kr(numChans, w, x, y, orientation)\n\n// rotating (in the horizontal plane):\nRotate2.kr(x, y, pos)\n\n\n/** From AmbisonicUGens in sc3-plugins: **/\n\n// encoding (3D):\nBFEncode1.ar(in, azimuth, elevation, rho, gain, wComp)\nBFEncode2.ar(in, point_x, point_y, elevation, gain, wComp)\n\n// encoding of a stereo signal (3D)\nBFEncodeSter.ar(l, r, azimuth, width, elevation, rho, gain, wComp)\n\n// decoding (3D):\nBFDecode1.ar(w, x, y, z, azimuth, elevation, wComp, mul, add)\n\n// manipulating (3D):\nBFManipulate.ar(w, x, y, z, rotate, tilt, tumble)\n// rotate is rotation around the z-axis, tilt around the x-axis, and tumble around the y-axis",
    "Figure 506": "Figure 14.16\n\n\n// no interpolation\n*arBufN { arg sound = 0, bufnum, location, speakerSpec, speedOfSound = 334, ampType = 'ws'; \n var numChannels, distArray;\n\n// WFSPoint is a 3D representation of a point in cartesian space\n\n speakerSpec = speakerSpec ? [WFSPoint.new(-2.7, 1.8, 0), WFSPoint.new(2.7,1.8, 0)]; //default 2 speakers\n\n if( speakerSpec.class == WFSConfiguration )\n  { speakerSpec = speakerSpec.allSpeakers; };\n\n numChannels = speakerSpec.size; // speakerSpec = Array of WFSPoint objects\n\n location = location ? WFSPoint.new(0,0,0); // the location of the sound source\n\n distArray = Array.fill(numChannels, { |i| speakerSpec.at(i).dist(location)}); // distance of the sound source to each speaker (r_0)\n\n cosPhiArray = Array.fill(numChannels, { |i| speakerSpec.at(i).cosphi(location)}); // cosine phi_0 of the sound source to each speaker (cos phi_0)\n ^BufDelayN.ar(bufnum, sound, \n  distArray / speedOfSound, // delay\n  WFSPan.wfsAmp(distArray,cosPhiArray);\n }\n\n*wfsAmp{ arg inDist, inCosPhi, refDist=4.0, minDist = 0.1;\n // refDist is the reference line distance\n // minDist is the minimal distance to the speaker array (to avoid explosion at /0)\n\n // avoid explosion:\n inDist = inDist.max( minDist );\n\n ^(ampFactor * ((refDist/(refDist + inDist)).sqrt)*(inCosPhi/(inDist.sqrt)))\n}",
    "Figure 507": "Figure 14.17\n\n\ns.boot;\n(\nb = Buffer.alloc(s,2048,1);\nc = Buffer.read(s,\"sounds/a11wlk01.wav\");\nd = Buffer.alloc(s,2048,1);\n)\n\n(\n//make stereo from mono\n// MouseX controls decorrelation\nx = SynthDef(\"PV_DecorrelateStereo\", { arg out=0, bufnum=0, bufnum2, soundBufnum=2;\n var in, chain, chain2;\n in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);\n chain = FFT(bufnum, in);\n chain2 = PV_Copy(chain, bufnum2);\n chain = PV_Decorrelate([chain, chain2], 1,  MouseX.kr);\n Out.ar(out, 0.5 * IFFT(chain));\n}).play(s,[\\out, 0, \\bufnum, b, \\bufnum2, d, \\soundBufnum, c]);\n)\n\nx.free; [b, c, d].do(_.free);",
    "Figure 508": "Figure 14.18\n\n(\nb = Buffer.read(s, \"sounds/a11wlk01.wav\");\nSynthDef(\"grain\",{ arg i_out=0, i_sampbufnum, dur = 0.05, \n pointer, offset = 0.005, amp = 1.0, loop = 1;\n var thisStart, thisDur, grain;\n thisStart = pointer + IRand(0, offset); // adds random time offset\n grain = EnvGen.ar(Env.sine, 1.0, amp, 0.0, dur, 2) \n  * PlayBuf.ar(1,i_sampbufnum, BufRateScale.ir(i_sampbufnum),\n   1, thisStart,loop);\n OffsetOut.ar(i_out,grain); // use OffsetOut for precise sub-block timing\n}).add;\n)\n\n(\nx = {\nvar numGrains = 32; // approximate number of simultaneous grains\nvar numChannels = 2; // adjust for your setup\nvar dur = 0.05, durRand = 0.05, thisDur;\nvar start, now;\nvar numGrainsRecip;\nnumGrainsRecip = numGrains.reciprocal; // save some divides by converting to reciprocal\n\nstart = Main.elapsedTime;\nloop({ \n now = Main.elapsedTime - start;\n thisDur = dur + durRand.rand;\n s.bind({Synth(\"grain\", [i_out: numChannels.rand, i_sampbufnum: b, dur: thisDur, \n  pointer: now * b.sampleRate, amp: numGrainsRecip]);\n }); // send as a bundle for precise sub-block timing\n (thisDur * numGrainsRecip).wait;\n})\n}.fork;\n)\n\nx.stop; b.free;",
    "Figure 509": "Figure 14.19\n\n\nServer.default = s = Server.internal;\ns.boot;\n(\nn = 512; // number of bins\nb = Buffer.alloc(s, n, 1);\nc = Buffer.alloc(s, n, 1);\n\n// create arrays of magnitude scalars and load them to buffers\nd = Array.fill(n, {1.0.linrand});\ne = 1.0 - d;\nd = Buffer.loadCollection(s, d);\ne = Buffer.loadCollection(s, e);\n\nf = Buffer.read(s,\"sounds/a11wlk01.wav\");\n)\n\n(\nx = SynthDef(\"spectral diffusion\", { arg out=0, analBuf, analBufCopy, scalBuf1, scalBuf2, soundBuf;\n var chain1, chain2;\n chain1 = FFT(analBuf, PlayBuf.ar(1, soundBuf, BufRateScale.kr(soundBuf), loop: 1));\n chain2 = PV_Copy(chain1, analBufCopy); // copy the initial analysis\n chain1 = PV_MagMul(chain1, scalBuf1);\n chain2 = PV_MagMul(chain2, scalBuf2); \n Out.ar(out,  0.5 * IFFT([chain1, chain2]));\n}).play(s,[out: 0, analBuf: b, analBufCopy: c, scalBuf1: d, scalBuf2: e, soundBuf: f]);\ns.scope; // compare the two channels\n)\n\n// execute this multiple times to change the distribution\n(\ng = Array.fill(n, {1.0.linrand});\nh = 1 - g;\nd.loadCollection(g);\ne.loadCollection(h);\n)\n\nx.free; [b, c, d, e, f].do(_.free);",
    "Figure 510": "Figure 15.1\n(\nx={\n\tvar in, amp, freq, hasFreq, out;\n\tin = SoundIn.ar(0);\n\tamp = Amplitude.ar(in);\n\t# freq, hasFreq = Pitch.kr(in);\n\tLFTri.ar(freq*[1,2]) * amp;\n}.play\n)\n\nx.free;",
    "Figure 511": "Figure 15.2\nb = Buffer.alloc(s,1024,1);   //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\t\n(  //analyse loudness and poll result\nx={\n\tvar in, fft, loudness;\n\t\n\tin = SoundIn.ar(0); \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tloudness = Loudness.kr(fft); \n\t\n\tloudness.poll(20); //poll for testing 20 times per second\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;",
    "Figure 512": "Figure 15.3\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//d=Buffer.read(s,\"sounds/a11wlk01.wav\");\n\n\n(\nx= {\n\tvar in, fft, array;\n\t\n\t//in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tin = SoundIn.ar(0); \n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tarray = MFCC.kr(fft); \n\t\n\tarray.size.postln; \n\t\n\tOut.kr(0,array); \n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\n\nc= Bus.new('control', 0, 13); \n\n//poll coefficients\nc.getn(13,{arg val; {val.plot;}.defer}); \n\n\n//Continuous graphical display of MFCC values; free routine before closing window\n\n(\nvar ms; \n\nw = Window(\"Thirteen MFCC coefficients\", Rect(200,400,300,300));\n\nms = MultiSliderView(w, Rect(10,10,260,280));\n\nms.value_(Array.fill(13,0.0));\nms.valueThumbSize_(20.0);\nms.indexThumbSize_(20.0);\nms.gap_(0);\n\nw.front;\n\nr = {\n\t\n\tinf.do{\n\t\t\n\t\tc.getn(13,{arg val; {ms.value_(val*0.9)}.defer}); \n\t\t\n\t\t0.04.wait; //25 frames per second\n\t};\n\n}.fork;\n\n)\n\n\n//tidy up\n(\nr.stop;\nb.free;\nc.free;\nx.free;\nw.close;\n)",
    "Figure 513": "Figure 15.4\n// Prepare the buffer\nb = Buffer.alloc(s, 512);\n\n(\nx = {\n\tvar sig, chain, onsets, pips, trigger;\n\t\n\tsig = SoundIn.ar(0); \n\t\n\tchain = FFT(b, sig);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger= SendTrig.kr(onsets);\n\t\n\tpips = SinOsc.ar(880, 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));\n\t\n\tOut.ar(0, ((sig * 0.1) + pips).dup);\n}.play;\n)\n\n(\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\t[time,responder,msg].postln;\n}).add;\n)\n\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer",
    "Figure 514": "Figure 15.5\nb = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000\n\n//track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin); events will be spawned at quarter, eighth and sixteenth note rates\n(\nSynthDef(\\beattrack,{\t\n\tvar trackb,trackh,trackq,tempo;\n\tvar source;\n\tvar bsound,hsound,qsound;\n\t\n\tsource = SoundIn.ar(0);\n\t\n\t#trackb,trackh,trackq,tempo = BeatTrack.kr(FFT(b.bufnum, source));\n\t\n\tbsound = Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);\n\t\n\thsound = Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);\n\t\n\tqsound = Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);\n\t\n\tOut.ar(0, bsound+hsound+qsound);\n}).add;\n)\n\nx = Synth(\\beattrack); // Go!\n\nx.free;\nb.free; // Free the buffer",
    "Figure 515": "Figure 15.6\n//straight forward test file with few transients; training set in e minor from MIREX2006 \n//You will need to substitute your own soundfile to load here\nd=Buffer.read(s,\"/Users/nickcollins/Desktop/ML/training_wav/78.wav\")\n\n\nb = Buffer.alloc(s,4096,1); //for sampling rates 44100 and 48000\n//b = Buffer.alloc(s,8192,1); //for sampling rates 88200 and 96000\n\n(\nx= {\n\tvar in, fft; \n\tvar key;\n\t\n\tin = PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);\n\t\n\tfft = FFT(b.bufnum, in);\n\t\n\tkey = KeyTrack.kr(fft, 2.0, 0.5);\n\t\n\tkey.poll; //write out detected key\n\t\n\tOut.ar(0,Pan2.ar(in)); \n}.play\n)\n\nx.free;\nb.free;",
    "Figure 516": "Figure 15.7\n//Example uses internal server to demonstrate shared busses\n\n(\ns=Server.internal; \nServer.default=s; \n\ns.doWhenBooted({\n\nb = Buffer.alloc(s, 512);\n\n//this SynthDef will make no sound, just analyses input\nSynthDef(\\pitchandonsets,\n{\n\tvar in, amp, freqdata, chain, onsets, trigger;\n\t\n\tin = SoundIn.ar(0);\n\tamp = RunningSum.rms(in, 64); //get rms amplitude value per control block\n\tfreqdata = Pitch.kr(in); \n\t\n\t//allow synchronous polling, Internal Server only\n\tSharedOut.kr(0,freqdata);\t\n\tSharedOut.kr(2,amp);\n\t\n\tchain = FFT(b, in);\n\t\n\t// - move the mouse left/right to change the threshold:\n\tonsets = Onsets.kr(chain, MouseX.kr(0,1), \\complex);\n\t\n\ttrigger = SendTrig.kr(onsets);\n\n}).send(s); \n});\n\n)\n\n\n\n(\nvar freqlist=List(), amplist=List(); \nvar notelist= List(), numnotes=10; //will hold the last 10 notes \nvar lasttime, started=false; \nvar maxlength=0.5, maxkperiods, waittime;\n\nmaxkperiods = ((maxlength*(s.sampleRate))/(s.options.blockSize)).asInteger;\nwaittime = (s.options.blockSize)/(s.sampleRate);\n\n\n// register to receive message\na= OSCresponder(s.addr,'/tr',{ arg time,responder,msg;\n\tvar newnote;\n\t\t\n\tif(started,{\t\n\t\t\n\t//finalise previous note as [starttime, ioi= inter onset interval, dur, medianpitch, maxamp]\t\n\tnewnote = \t[lasttime, time-lasttime, (time-lasttime).min(maxlength), if(freqlist.notEmpty, {freqlist.median.cpsmidi},{nil}),amplist.maxItem.ampdb];\n\t\n\tnewnote.postln;\n\t\t\n\tnotelist.addFirst(newnote);\n\t\n\t//remove oldest note if over size\n\tif(notelist.size>numnotes,{notelist.pop}); \n\t\n\t},{started = true;}); \n\t\n\t//reset lists for collection\n\tfreqlist = List();\n\tamplist = List(); \n\tlasttime = time;\n\t\t\n}).add;\n\nx= Synth(\\pitchandonsets); \n\n//poll values\n{\t\n\t\n\tinf.do{  \n\t\tvar freq, hasfreq, rmsamp;\n\t\t \n\t\tfreq = s.getSharedControl(0);\n\t\thasfreq = s.getSharedControl(1);\n\t\trmsamp = s.getSharedControl(2);\n\t\t\n\t\t//don't allow notes of longer than 500 control periods or so\n\t\tif((hasfreq>0.5) and: (amplist.size<maxkperiods), {freqlist.add(freq)});\n\t\t\n\t\tif(amplist.size<maxkperiods, {amplist.add(rmsamp)});\n\t\t \n\t\t//poll every control period, intensive\n\t\t(waittime).wait;\n\t}; \n\t\n}.fork;\n\n)\n\n\n\n(\na.remove; //Free the OSCresponder\nx.free; // Free the synth\nb.free; // Free the buffer\n)",
    "Figure 517": "Figure 15.8\n//do this first: \nMIDIIn.connect; \t// init for one port midi interface\n\n\n//now:\nm = OnlineMIDI();\n\nm.analyse(3,1.0); //3 seconds window, step size of 1.0 seconds\n\nm.data //poll current data\n\nm.status = true; //prints analysis data as it goes\nm.status= false;\n\n//use analysis data to formulate responses\n\n(\nSynthDef(\\beep2,{arg freq=440,amp=0.1, pan=0.0, dur=0.1; \nvar source; \n\nsource= SinOsc.ar(freq*[1,1.007],0,amp*0.5);\n\nOut.ar(0,Pan2.ar(Mix(source)*Line.kr(1,0,dur, doneAction:2),pan))}).add;\n)\n\n//to echo each note you play on a MIDI keyboard with a sound; your SynthDef must have freq and amp arguments, and deal with duration and freeing the Synth itself.  \n(\nm.playinput= true; \nm.inputsynthdef= \\beep2; \n)\n\n//set a function that gets called after each window is analysed, to schedule events over the next second \n(\nm.response = {|analysis|  \n\tvar number;\n\tnumber= analysis.density; \n\t//number= max(0,(10-(analysis.density))); //inverting number of notes playing\n\t\n\tif(analysis.iois.notEmpty, {\n\t\t{\n\t\t\n\t\tnumber.do{\n\t\t\n\t\tSynth(\\beep2, [\\freq, analysis.pitches.choose.midicps, \\amp, 0.2*(rrand(analysis.volumemin, analysis.volumemax))]);\n\t\t\n\t\tanalysis.iois.choose.wait; //could last longer than the next second, but still fun! \n\t\t\n\t\t}; \n\t\t\n\t\t}.fork;\n\t}); \n\t\n};\n)\n\n\nm.response= nil; //stop",
    "Figure 518": "Figure 16.1: Short grain durations, pitch to colored click \n\n(\t// a gabor grain, gaussian-shaped envelope\nSynthDef(\\gabor, { |out, freq = 440, sustain = 1, pan, amp = 0.1, width = 0.25 |\n\tvar env = LFGauss.ar(sustain, width, loop: 0, doneAction: 2);\n\tvar son = FSinOsc.ar(freq, 0.5pi, env);\n\tOffsetOut.ar(out, Pan2.ar(son, pan, amp));\n\n}, \\ir ! 6).add;\n\n\t// or an approximation with a sine-shaped envelope\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(Env.sine(sustain, amp), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)\n\n(\nPbindef(\\grain,\n\t\\instrument, \\gabor, \\freq, 1000, \n\t\\dur, 0.5, \\sustain, 20/1000, \\amp, 0.2\n).play;\n)\nPbindef(\\grain, \\sustain, 10/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 5/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 3/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 2/Pkey(\\freq));\nPbindef(\\grain, \\sustain, 1/Pkey(\\freq));\n\n\t// successively shorter, end\nPbindef(\\grain, \\sustain, Pseq((10..1)) / Pkey(\\freq)).play;\n\n\t// random drift of grain duration\nPbindef(\\grain, \\sustain, Pbrown(1, 10, 3) / Pkey(\\freq), \\dur, 0.1).play",
    "Figure 519": "Figure 16.2: Perception of short silences.\n\n(\np = ProxySpace.push;\n\n~source = { SinOsc.ar * 0.1 };\n~silence = { |silDur=0.01| \n\tEnvGen.ar(\n\t\tEnv([0, 1, 1, 0, 0, 1, 1, 0], [0.01, 2, 0.001, silDur, 0.001, 2, 0.01]), \n\t\tdoneAction: 2) ! 2\n};\n~listen = ~source * ~silence;\n~listen.play;\n)\n\n~silence.spawn([\\silDur, 0.001]); // sounds like an added pulse \n~silence.spawn([\\silDur, 0.003]);\n~silence.spawn([\\silDur, 0.01]);\n~silence.spawn([\\silDur, 0.03]);\t  // a pause in the sound\n\n\t// try the same examples with noise:\n~source = { WhiteNoise.ar * 0.1 };\t\n\np.pop",
    "Figure 520": "Figure 16.3: Order confusion with sounds in fast succession. \n\tAs grains move closer and closer together, their order becomes ambiguous. \n\n(\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp), timeScale: sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)\n(\nPbindef(\\lo, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 250, \\amp, 0.2, \\dur, 0.5, \\lag, 0\n).play;\nPbindef(\\hi, \n\t\\instrument, \\percSin, \\sustain, 0.05, \n\t\\freq, 875, \\amp, 0.1, \\dur, 0.5, \\lag, 0\n).play;\n)\n\t// try different lag times between them\nPbindef(\\hi, \\lag, 0.1);\nPbindef(\\hi, \\lag, 0.03);\nPbindef(\\hi, \\lag, 0.01);\nPbindef(\\hi, \\lag, 0.003);\n\n\t// hi too early or too late by a fixed time - which one is first?\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.01).postln).play;\nPbindef(\\hi, \\lag, ([-1, 1].choose * 0.02).postln);\n\n\t// is it easier to hear when the sounds are panned apart?\nPbindef(\\hi, \\pan, 0.5); Pbindef(\\lo, \\pan, -0.5);\nPbindef(\\hi, \\pan, 0);   Pbindef(\\lo, \\pan, 0);",
    "Figure 521": "Figure 16.4: multiple grains fuse into one composite.\n\t// when the order changes, the sound is subtly different.\n(\nPbindef(\\grain4, \n\t\\instrument, \\percSin, \\sustain, 0.03, \\amp, 0.2,\n\t\\freq, Pshuf([1000, 600, 350, 250]), // random every each time\n\t\\dur, 0.005\n).play;\n\t\t\t\t// repeat grain cluster \nTdef(\\grain, { loop { Pbindef(\\grain4).play; 1.wait } }).play;\n)\n\t// fixed order\nPbindef(\\grain4, \\freq, Pseq([1000, 600, 350, 250].scramble));\n\n\t// different order every time\nPbindef(\\grain4, \\freq, Pshuf([1000, 600, 350, 250]));",
    "Figure 522": "Figure 16.6 \u00e2\u0080\u0093 Making different envelope shapes\n\nEnv.sine.plot2;\t\t// approx. gaussian \nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\sin).test.plot2; // quasi-gaussian\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\lin).test.plot2; // 3 stage line segments.\nEnv([0, 1, 1, 0], [0.25, 0.5, 0.25] * 0.1, \\welch).test.plot2; // welch curve interpolation\nEnv([1, 0.001], [0.1], \\exp).test.plot2;\t// expoDec (exponential decay);\nEnv([0.001, 1], [0.1], \\exp).test.plot2;\t// revExpoDec (reverse exponential decay);\nEnv.perc(0.01, 0.09).test.plot2;\n\n(\t// a sinc function envelope \nq = q ? ();\nq.makeSinc = { |q, num=1, size=400| \n\tdup({ |x| x = x.linlin(0, size-1, -pi, pi) * num; sin(x) / x }, size);\n}; \na = q.makeSinc(6);\na.plot(bounds: Rect(0,0,409,200), minval: -1, maxval: 1);\n)",
    "Figure 523": "figure 16.9 - SynthDefs with different envelopes\n\n(\t// a gabor (approx. gaussian-shaped) grain\nSynthDef(\\gabor1, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env.sine(sustain, amp2), doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// wider, quasi-gaussian envelope, with a hold time in the middle. \nSynthDef(\\gabWide, { |out, amp=0.1, freq=440, sustain=0.01, pan, width=0.5| \n\tvar holdT = sustain * width;\n\tvar fadeT = 1 - width * sustain * 0.5;\n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(Env([0, 1, 1, 0], [fadeT, holdT, fadeT], \\sin), \n\t\tlevelScale: amp2, \n\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a simple percussive envelope\nSynthDef(\\percSin, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.1, 0.9, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a reversed  percussive envelope\nSynthDef(\\percSinRev, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = EnvGen.ar(\n\t\tEnv.perc(0.9, 0.1, amp2), \n\t\t\ttimeScale: sustain, \n\t\t\tdoneAction: 2\n\t\t);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// an exponential decay envelope\nSynthDef(\\expodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = AmpComp.ir(freq.max(50)) * 0.5 * amp;\n\tvar env = XLine.ar(amp2, amp2 * 0.001, sustain, doneAction: 2);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n\n\t\t\t// a reversed exponential decay envelope\nSynthDef(\\rexpodec, { |out, amp=0.1, freq=440, sustain=0.01, pan| \n\tvar snd = FSinOsc.ar(freq);\n\tvar amp2 = amp * AmpComp.ir(freq.max(50)) * 0.5;\n\tvar env = XLine.ar(amp2 * 0.001, amp2, sustain, doneAction: 2) \n\t\t* (AmpComp.ir(freq) * 0.5);\n\tOffsetOut.ar(out, Pan2.ar(snd * env, pan));\n}, \\ir ! 5).add;\n)",
    "Figure 524": "Figure 16.10: Changing grain duration, frequency, envelope.\n\n\t//",
    "Figure 525": "figure 16.10 - changing grain duration, frequency, envelope\n(\nPbindef(\\grain0,\n\t\\instrument, \\gabor1, \\freq, 500, \n\t\\sustain, 0.01, \\dur, 0.2\t\n).play;\n)\n\t// change grain durations\nPbindef(\\grain0, \\sustain, 0.1);\nPbindef(\\grain0, \\sustain, 0.03);\nPbindef(\\grain0, \\sustain, 0.01);\nPbindef(\\grain0, \\sustain, 0.003);\nPbindef(\\grain0, \\sustain, 0.001);\nPbindef(\\grain0, \\sustain, Pn(Pgeom(0.1, 0.9, 60)));\nPbindef(\\grain0, \\sustain, Pfunc({ exprand(0.0003, 0.03) }));\nPbindef(\\grain0, \\sustain, 0.03);\n\n\t// change grain waveform (sine) frequency\nPbindef(\\grain0, \\freq, 300);\nPbindef(\\grain0, \\freq, 1000);\nPbindef(\\grain0, \\freq, 3000);\nPbindef(\\grain0, \\freq, Pn(Pgeom(300, 1.125, 32)));\nPbindef(\\grain0, \\freq, Pfunc({ exprand(300, 3000) }));\nPbindef(\\grain0, \\freq, 1000);\n\n\t// change synthdef for different envelopes\nPbindef(\\grain0, \\instrument, \\gabor1);\nPbindef(\\grain0, \\instrument, \\gabWide);\nPbindef(\\grain0, \\instrument, \\percSin);\nPbindef(\\grain0, \\instrument, \\percSinRev);\nPbindef(\\grain0, \\instrument, \\expodec);\nPbindef(\\grain0, \\instrument, \\rexpodec);\nPbindef(\\grain0, \\instrument, Prand([\\gabWide, \\percSin, \\percSinRev], inf));",
    "Figure 526": "Figure 16.11: Different control strategies applied to density.\n\n(\t// synchronous - regular time intervals\nPbindef(\\grain0).clear;\nPbindef(\\grain0).play;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, 0.1, \\sustain, 0.06\n);\n)\n\t// different fixed values\nPbindef(\\grain0, \\dur, 0.06) \t// rhythm\nPbindef(\\grain0, \\dur, 0.035)\t\nPbindef(\\grain0, \\dur, 0.02)\t// fundamental frequency 50 Hz\n\n\t// time-changing values: accelerando/ritardando\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02], [4], \\exp), inf));\nPbindef(\\grain0, \\dur, Pn(Penv([0.1, 0.02, 0.06, 0.01].scramble, [3, 2, 1], \\exp), inf));\n\n\t// repeating values: rhythms or tones\nPbindef(\\grain0, \\dur, Pstutter(Pwhite(2, 15), Pfunc({ exprand(0.01, 0.3) })));\n\n\t// introducing irregularity - quasi-synchronous\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.8, 1.2))\nPbindef(\\grain0, \\dur, 0.03 * Pbrown(0.6, 1.4, 0.1)) // slower drift\nPbindef(\\grain0, \\dur, 0.03 * Pwhite(0.2, 1.8))\n\n\t// average density constant, vary degree of irregularity  \nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.1.linrand * 3) + 0.9 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (0.3.linrand * 3) + 0.3 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ (1.0.linrand * 3) + 0.0 }));\nPbindef(\\grain0, \\dur, 0.02 * Pfunc({ 2.45.linrand.squared })); // very irregular\n\n\n(\t// coupling - duration depends on freq parameter\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq  })\n);\n)\n\n\t// different freq movement, different timing\nPbindef(\\grain0, \\freq, Pbrown(48.0, 96.0, 12.0).midicps);\n\n(\t// duration depends on freq, with some variation - tendency mask\nPbindef(\\grain0, \n\t\\freq, Pn(Penv([200, 1200], [10], \\exp), inf),\n\t\\dur, Pfunc({ |ev| 20 / ev.freq * rrand(0.5, 1.5)  })\n);\n)",
    "Figure 527": "Figure 16.12: Control strategies applied to different parameters\n\n(\nPbindef(\\grain0).clear;\nPbindef(\\grain0, \n\t\\instrument, \\expodec, \n\t\\freq, 200,\n\t\\sustain, 0.05, \\dur, 0.07\n).play;\n)\n\t// time-varying freq with envelope pattern\nPbindef(\\grain0, \\freq, Pn(Penv([200, 1200], [10], \\exp), inf));\n\t// random freq\nPbindef(\\grain0, \\freq, 400 * Pwhite(-24.0, 24).midiratio);\n\t// timechanging with random variation\nPbindef(\\grain0, \\freq, Pn(Penv([400, 2400], [10], \\exp), inf) * Pwhite(-24.0, 24).midiratio);\n\n\t// panning\nPbindef(\\grain0, \\pan, Pwhite(-0.8, 0.8));  // random\nPbindef(\\grain0, \\pan, Pn(Penv([-1, 1], [2]), inf)); // tendency\nPbindef(\\grain0, \\pan, Pfunc({ |ev| ev.freq.explin(50, 5000, -1, 1) })); // coupled to freq\n\n\t// time scattering variants\nPbindef(\\grain0, \\dur, 0.1 * Pwhite(0.5, 1.5));\t// random range\nPbindef(\\grain0, \\dur, 0.05 * Prand([0, 1, 1, 2, 4], inf)); // rhythmic random\n\n\t// amplitude - randomized\nPbindef(\\grain0, \\amp, Pwhite(0.01, 0.2));\t// linear\nPbindef(\\grain0, \\amp, Pwhite(-50, -14).dbamp); // exponential - more depth\nPbindef(\\grain0, \\dur, 0.025 * Prand([0, 1, 1, 2, 4], inf)); // could be denser now\n\n\t// random amplitude envelopes with Pseg\n(\nPbindef(\\grain0, \n\t\\amp, Pseg(\n\t\tPxrand([-50, -20, -30, -40] + 10, inf), // level pattern\n\t\tPxrand([0.5, 1, 2, 3], inf), \t\t// time pattern\n\t\tPrand([\\step, \\lin], inf)\t\t\t// curve pattern\n\t).dbamp\n); \n)\n\t// grain sustain time coupled to freq\nPbindef(\\grain0, \\sustain, Pkey(\\freq).reciprocal * 20).play;",
    "Figure 528": "Figure 16.13: GrainFM with individual control proxies\n\n\t//",
    "Figure 529": "figure 16.13   - GrainFM with individual control proxies\np = ProxySpace.push;\n\n(\n~trig = { |dens=10| Impulse.kr(dens) };\n~freq = { MouseX.kr(100, 2000, 1) * LFNoise1.kr(1).range(0.25, 1.75) };\n~moddepth = { LFNoise1.kr(20).range(1, 10) };\n~modfreq = 200;\n~graindur = 0.1;\n\n~grain = { arg envbuf = -1;\n\tGrainFM.ar(2, ~trig.kr, ~graindur.kr, \n\t\t~freq.kr, ~modfreq.kr, ~moddepth.kr, \n\t\tpan: WhiteNoise.kr, envbufnum: envbuf) * 0.2\n};\n~grain.play;\n)\n\t// change control ugens: \n~modfreq = { ~freq.kr * LFNoise2.kr(1).range(0.5, 2.0) }; // modfreq roughly follows freq\n~trig = { |dens=10| Dust.kr(dens)};\t// random triggering, same density\n~freq = { LFNoise0.kr(0.3).range(200, 800) };\n~moddepth = 3; \t// fixed depth\n~graindur = { LFNoise0.kr.range(0.01, 0.1) };",
    "Figure 530": "Figure 16.14: GrainBuf with control proxies\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~grain.set(\\wavebuf, b.bufnum);\n~trig = { |dens=10| Impulse.kr(dens) };\n~graindur = 0.1;\n~filepos = {LFNoise2.kr(0.2).range(0, 1) };\n~rate = { LFNoise1.kr.range(0.5, 1.5) };\n\n~grain = { arg envbuf = -1, wavebuf = 0;\n\tGrainBuf.ar(2, ~trig.kr, ~graindur.kr, wavebuf, \n\t~rate.kr, ~filepos.kr, 2, WhiteNoise.kr, envbuf) * 0.2\n};\n~grain.play;\n)\n\n\t// experiment with control proxies\n~trig = { |dens=20| Impulse.kr(dens) };\n~rate = { LFNoise1.kr.range(0.99, 1.01) };\n~filepos = { MouseX.kr + LFNoise0.kr(100, 0.03) };\n~graindur = 0.05;\n~trig = { |dens=50| Dust.kr(dens) };\n\nc = Buffer.sendCollection(s, Env.perc(0.01, 0.99).discretize, 1);\n~grain.set(\\envbuf, c.bufnum); \n~grain.set(\\envbuf, -1);\n\n~trig = { |dens=50| Impulse.kr(dens) }; ~graindur = 0.05;",
    "Figure 531": "Figure 16.15: Glisson synthesis\n\n(\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\nSynthDef(\"glisson\", \n\t{ arg out = 0, envbuf, freq=800, freq2=1200, sustain=0.001, amp=0.2, pan = 0.0;\n\t\tvar env = Osc1.ar(envbuf, sustain, 2);\n\t\tvar freqenv = XLine.ar(freq, freq2, sustain);\n\t\tOffsetOut.ar(out, \n\t\t\tPan2.ar(SinOsc.ar(freqenv) * env, pan, amp)\n\t\t)\n}, \\ir!7).add;\n)\n\n(\nTdef(\\gliss0, { |e|\n\t100.do({ arg i;\n\t\ts.sendBundle(s.latency, [\"/s_new\", \"glisson\", -1, 0, 0, \n\t\t\t\\freq, i % 10 * 100 + 1000,\n\t\t\t\\freq2, i % 13 * -100 + 3000,\n\t\t\t \\sustain, 0.05, \n\t\t\t \\amp, 0.1,\n\t\t\t \\envbuf, b.bufnum\n\t\t]);\n\t\t(3 / (i + 10)).wait;\n\t});\n}).play;\n)",
    "Figure 532": "Figure 16.16: Pulsar basics \u00e2\u0080\u0093 a set of waveform and control tables\n\n\t//",
    "Figure 533": "figure 16.16 - Pulsar basics - make a set of waveform and control tables\n(\nq = ();\nq.curr = (); \t// make a dict for the set of tables\nq.curr.tab = ();\n\t\t\t\t// random tables for pulsaret  and envelope waveforms:\nq.curr.tab.env = Env.perc.discretize; \nq.curr.tab.pulsaret = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// random tables for the control parameters:\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.curr.tab.amp = 0.2.dup(1024);\nq.curr.tab.pan = Signal.sineFill(1024, { 1.0.rand }.dup(7));\n\n\t\t\t// make buffers from all of them:\nq.bufs = q.curr.tab.collect({ |val, key| Buffer.sendCollection(s, val, 1) });\n)\n\t\t// plot one of them\nq.bufs.pulsaret.plot2(\"a pulsaret\");",
    "Figure 534": "Figure 16.17: Pulsars as nodeproxies using GrainBuf\n\n(\np = ProxySpace.push; \n\n\t\t// fund, form, amp, pan\n~controls = [ 16, 100, 0.5, 0]; \n~pulsar1.set(\\wavebuf, q.bufs.pulsaret.bufnum);\n~pulsar1.set(\\envbuf, q.bufs.env.bufnum);\n\n~pulsar1 = { |wavebuf, envbuf = -1| \n\tvar ctls = ~controls.kr;\n\tvar trig = Impulse.ar(ctls[0]);\n\tvar grdur = ctls[1].reciprocal;\n\tvar rate = ctls[1] * BufDur.kr(wavebuf);\n\t\t\n\tGrainBuf.ar(2, trig, grdur, wavebuf, rate, 0, 4, ctls[3], envbuf);\n};\n~pulsar1.play;\n)\n\n\t// crossfade between control settings\n~controls.fadeTime = 3; \n~controls = [ 16, 500, 0.5, 0]; \t// change formfreq\n~controls = [ 50, 500, 0.5, 0]; \t// change fundfreq\n~controls = [ 16, 100, 0.5, 0]; \t// change both\n~controls = [ rrand(12, 100), rrand(100, 1000)]; \n\n(\t// control parameters from looping tables\n~controls = { |looptime = 10| \n\tvar rate = BufDur.kr(q.bufs.pulsaret.bufnum) / looptime; \n\tA2K.kr(PlayBuf.ar(1, [\\fund, \\form, \\amp, \\pan].collect(q.bufs[_]), \n\t\trate: rate, loop: 1));\n};\n)",
    "Figure 535": "Figure 16.18: Making new tables and sending them to buffers\n\nq.bufs.pulsaret.sendCollection(Array.linrand(1024, -1.0, 1.0)); // noise burst\nq.bufs.pulsaret.read(\"sounds/a11wlk01.wav\", 44100 * 1.5);       // sample\nq.bufs.pulsaret.sendCollection(Pbrown(-1.0, 1.0, 0.2).asStream.nextN(1024));\n\n\t// make a new random fundfreq table, and send it\nq.curr.tab.fund = 200 ** Env({1.0.rand}!8, {1.0.rand}!7, \\sin).discretize.as(Array);\nq.bufs.fund.sendCollection(q.curr.tab.fund);\n\n\t// and a new random formfreq table\nq.curr.tab.form = 500 ** ( 0.5 + Env({rrand(0.0, 1.0)}!8, {1.0.rand}!7, \\sin).discretize.as(Array));\nq.bufs.form.sendCollection(q.curr.tab.form);",
    "Figure 536": "Figure 16.19: A nodeproxy for time-pitch changing\n\np = ProxySpace.push(s.boot);\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\n~timepitch = {arg sndbuf, pitchRatio=1, pitchRd=0.01, grainRate=10, overlap=2, \n\tposSpeed=1, posRd=0.01;\n\t\n\tvar graindur = overlap / grainRate;\n\tvar pitchrate = pitchRatio + LFNoise0.kr(grainRate, pitchRd);\n\tvar position = LFSaw.kr(posSpeed / BufDur.kr(sndbuf)).range(0, 1) \n\t\t+ LFNoise0.kr(grainRate, posRd);\n\t\t\n\tGrainBuf.ar(2, Impulse.kr(grainRate), graindur, sndbuf, pitchrate,\n\t\t\tposition, 4, 0, -1)\n};\n~timepitch.set(\\sndbuf, b.bufnum);\n~timepitch.play;\n);\n\nSpec.add(\\pitchRatio, [0.25, 4, \\exp]);\nSpec.add(\\pitchRd, [0, 0.5, \\amp]);\nSpec.add(\\grainRate, [1, 100, \\exp]);\nSpec.add(\\overlap, [0.25, 16, \\exp]);\nSpec.add(\\posSpeed, [-2, 2]);\nSpec.add(\\posRd, [0, 0.5, \\amp]);\nNodeProxyEditor(~timepitch, 10);\n\n\t// reconstruct original\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 1, \\posRd, 0);\n\n\t// four times as long: tweak pitchRd and posJitter to reduce artifacts\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0);\n\n\t// random read position, random pitch\n~timepitch.set(\\pitchRatio, 1, \\pitchRd, 0.5, \\grainRate, 20, \\overlap, 4, \\posSpeed, 0.25, \\posRd, 0.5);",
    "Figure 537": "Figure 16.20: A constant-Q Synthdef.\n\nb = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n(\nSynthDef(\\constQ, { |out, bufnum=0, amp=0.5, pan, centerPos=0.5, sustain=0.1, \n\trate=1, freq=400, rq=0.3| \n\n\tvar ringtime = (2.4 / (freq * rq) * 0.66).min(0.5); // estimated\n\tvar ampcomp = (rq ** -1) * (400 / freq ** 0.5);\t\n\tvar envSig = EnvGen.ar(Env([0, amp, 0], [0.5, 0.5] * sustain, \\welch));\n\tvar cutoffEnv = EnvGen.kr(Env([1, 1, 0], [sustain+ringtime,0.01]), doneAction: 2);\n\tvar grain = PlayBuf.ar(1, bufnum, rate, 0, \n\t\tcenterPos - (sustain * rate * 0.5) * BufSampleRate.ir(bufnum), \n\t\t1) * envSig;\t\n\tvar filtered = BPF.ar( grain, freq, rq, ampcomp ); \n\n\tOffsetOut.ar(out, Pan2.ar(filtered, pan, cutoffEnv))\n}, \\ir.dup(8)).add;\n)\n\nSynth(\\constQ, [\\bufnum, b, \\freq, exprand(100, 10000), \\rq, exprand(0.01, 0.1), \\sustain, 0.01]);",
    "Figure 538": "Figure 16.21: A stream of constant-Q grains\n(\nPbindef(\\gr1Q, \n\t\\instrument, \\constQ, \\bufnum, b.bufnum,\n\t\\sustain, 0.01, \\amp, 0.2,\n\t\\centerPos, Pn(Penv([1, 2.0], [10], \\lin)), \n\t\\dur, Pn(Penv([0.01, 0.09, 0.03].scramble, [0.38, 0.62] * 10, \\exp)),\n\t\\rate, Pwhite(0.95, 1.05), \n\t\\freq, Pbrown(64.0, 120, 8.0).midicps,\n\t\\pan, Pwhite(-1, 1, inf),\n\t\\rq, 0.03\n).play;\n)\n\t// changing parameters while playing\nPbindef(\\gr1Q, \\rq, 0.1);\nPbindef(\\gr1Q, \\rq, 0.01);\nPbindef(\\gr1Q, \\sustain, 0.03, \\amp, 0.08);\nPbindef(\\gr1Q, \\freq, Pbrown(80, 120, 18.0).midicps);\n\nPbindef(\\gr1Q, \\rq, 0.03);\n\nPbindef(\\gr1Q, \\rate, Pn(Penv([1, 2.0], [6], \\lin)));\n\n\t// variable duration\nPbindef(\\gr1Q, \\dur, Pwhite(0.01, 0.02));\n\n\t// a rhythm that ends\nPbindef(\\gr1Q, \\dur, Pgeom(0.01, 1.1, 40));",
    "Figure 539": "Figure 16.22: A Wavesets object\n\nw = Wavesets.from(\"sounds/a11wlk01.wav\");\n\nw.xings;\t\t\t// all integer indices of the zero crossings found\nw.numXings;\t\t// the total number of zero crossings\nw.lengths;\t\t// lengths of all wavesets\nw.amps;\t\t\t// peak amplitude of every waveset\nw.maxima;\t\t\t// index of positive maximum value in every waveset\nw.minima;\t\t\t// index of negative minimum value in every waveset\n\nw.fracXings;\t\t// fractional zerocrossing points\nw.fracLengths;\t// and lengths: allows more precise looping.\n\t\t\t\t\nw.lengths.plot;\t// show distribution of lengths\nw.amps.plot;\n\n\t// get data for a single waveset: frameIndex, length (in frames), dur\nw.frameFor(140, 1);\t\nw.ampFor(140, 1);\t\t// peak amplitude of that waveset or group\n\t\n\t// extract waveset by hand\nw.signal.copyRange(w.xings[150], w.xings[151]).plot(\"waveset 150\");\nw.plot(140, 1);\t// convenience plotting\nw.plot(1510, 1);\t\n\n\t// plot a group of 5 adjacent wavesets\nw.plot(1510, 5)",
    "Figure 540": "Figure 16.25: Playing Wavesets from buffers.\n\n(\n\t// A wavesets loads the file into a buffer by default.\n\t\tb = w.buffer;\t\t\n\t// Wavesets.prepareSynthDefs loads this synthdef: \n\t\tSynthDef(\\wvst0, { arg out = 0, buf = 0, start = 0, length = 441, playRate = 1, sustain = 1, amp=0.2, pan; \n\t\t\tvar phasor = Phasor.ar(0, BufRateScale.ir(buf) * playRate, 0, length) + start;\n\t\t\tvar env = EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2);\n\t\t\tvar snd = BufRd.ar(1, buf, phasor) * env;\n\t\t\t\n\t\t\tOffsetOut.ar(out, Pan2.ar(snd, pan));\n\t\t}, \\ir.dup(8)).add;\n)\n\n// play from frame 0 to 440, looped for 0.1 secs, so ca 10 repeats. \n(instrument: \\wvst0, bufnum: b.bufnum, start: 0, length: 440, amp: 1, sustain: 0.1).play;\n\n\t// get data from waveset\n(\nvar start, length, sustain, repeats = 20; \n#start, length, sustain = w.frameFor(150, 5);\n\n(\tinstrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\tstart: start, length: length, sustain: sustain * repeats\n).play;\n)\n\n\t// or even simpler: \nw.eventFor(startWs: 150, numWs: 5, repeats: 20, playRate: 1).put(\\amp, 0.5).play;",
    "Figure 541": "Figure 16.26: A pattern to play wavesets\n\n\t// by default, this pattern reconstructs a soundfile segment as is.\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 3000), 1), \n\t\\numWs, 1, \n\t\\playRate, 1, \n\t\\bufnum, b.bufnum, \n\t\\repeats, 1, \n\t\\amp, 0.4,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur; \n\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\t\t[start, length, wsDur * ev[\\repeats] / ev[\\playRate].abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)",
    "Figure 542": "Figure 16.27: Some of Trevor Wishart's transforms\n\n\t// waveset transposition: every second waveset, half speed\nPbindef(\\ws1, \\playRate, 0.5, \\startWs, Pn(Pseries(0, 2, 500), 1)).play;\n\n\t// reverse every single waveset \nPbindef(\\ws1, \\playRate, -1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\t// reverse every 2 wavesets\nPbindef(\\ws1, \\numWs, 2, \\playRate, -1, \\startWs, Pn(Pseries(0, 2, 1000), 1)).play;\n\t// reverse every 20 wavesets\nPbindef(\\ws1, \\numWs, 20, \\playRate, -1, \\startWs, Pn(Pseries(0, 20, 1000), 1)).play;\n\t// restore\nPbindef(\\ws1, \\numWs, 1, \\playRate, 1, \\startWs, Pn(Pseries(0, 1, 1000), 1)).play;\n\n\t// time stretching\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 4).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1, \\repeats, 1).play;\t// restore\n\n\t// waveset omission: drop every second\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pseq([1,1, \\, \\], inf) ).play;\nPbindef(\\ws1, \\numWs, 1, \\freq, Pfunc({ if (0.25.coin, 1, \\) }) ).play; // drop randomly\nPbindef(\\ws1, \\numWs, 1, \\freq, 1, \\startWs, Pn(Pseries(0, 1, 1000)) ).play; // restore\n\n\t// waveset shuffling (randomize waveset order +- 5, 25, 125)\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 5.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 25.rand2 })).play;\nPbindef(\\ws1, \\startWs, Pn(Pseries(0, 1, 1000), 1) + Pfunc({ 125.rand2 })).play;",
    "Figure 543": "Figure 16.28: Waveset substitution\n\t\n\t// the waveform to substitute\nc = Buffer.alloc(s, 512); c.sendCollection(Signal.sineFill(512, [1]));\n(\nPbindef(\\ws1).clear;\nPbindef(\\ws1, \n\t\\instrument, \\wvst0,\n\t\\startWs, Pn(Pseries(0, 1, 1000), 5), \n\t\\numWs, 1, \\playRate, 1, \n\t\\buf, c.bufnum, // sine wave\n\t\\repeats, 1, \n\t\\amp, 1,\n\t[\\start, \\length, \\sustain], Pfunc({ |ev| \n\t\tvar start, length, wsDur, origRate; \n\t\torigRate = ev[\\playRate];\n\t\t\n\t\t\t// get orig waveset specs\n\t\t#start, length, wsDur = w.frameFor(ev[\\startWs], ev[\\numWs]);\n\n\t\t\t// adjust playrate for different length of substituted wave\n\t\tev[\\playRate] = origRate * (512 / length); \n\n\t\t\t// get amplitude from waveset, to scale full volume sine wave\n\t\tev[\\amp] = ev[\\amp] * w.ampFor(ev[\\startWs], ev[\\numWs]);\n\t\t\n\t\t[0, 512, wsDur * ev[\\repeats] / origRate.abs]\n\t}), \n\t\\dur, Pkey(\\sustain)\n).play;\n)\n\t// clearer sinewave-ish segments\nPbindef(\\ws1, \\playRate, 1, \\repeats, 2).play;\nPbindef(\\ws1, \\playRate, 1, \\repeats, 6).play;\nPbindef(\\ws1).stop;\n\n\t// different waveforms\nc.sendCollection(Signal.sineFill(512, 1/(1..4).squared.scramble));\nc.sendCollection(Signal.rand(512, -1.0, 1.0));\nc.sendCollection(Signal.sineFill(512, [1]));\n\nc.plot;",
    "Figure 544": "Figure 16.29: Wavesets played with a Tdef \n\t\n\t// very simple first pass, fixed repeat time\n(\nTdef(\\ws1).set(\\startWs, 400);\nTdef(\\ws1).set(\\numWs, 5);\nTdef(\\ws1).set(\\repeats, 5);\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain; \n\n\tloop { \n\t\t#startFrame, length, wsSustain = w.frameFor(ev.startWs.next, ev.numWs);\n\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * ev.repeats;\n\t\t).play;\n\t\t\n\t\t0.1.wait;\t\n\t}\n}).play;\n)\n\nTdef(\\ws1).set(\\startWs, 420);\nTdef(\\ws1).set(\\repeats, 3);\nTdef(\\ws1).set(\\numWs, 2);\n\n\t\t// drop in a pattern for starting waveset \t\t\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);",
    "Figure 545": "Figure 16.30: Waittime derived from waveset duration and an added gap \n(\nTdef(\\ws1).set(\\gap, 3);\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps; \n\n\tloop { \n\t\treps = ev.repeats.next;\n\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, ev.numWs.next);\t\t\t\n\t\t\n\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\tstart: startFrame, length:  length, \n\t\t\tsustain: wsSustain * reps,\n\t\t\tpan: 1.0.rand2\n\t\t).play;\n\t\t\n\t\t\t// derive waittime from waveset sustain time\n\t\t\t// add gap based on waveset sustain time \n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\t// experiment with dropping in patterns:\n\t// very irregular gaps\nTdef(\\ws1).set(\\gap, { exprand(0.1, 20) });\n\t// sometimes continuous, sometimes gaps\nTdef(\\ws1).set(\\gap, Pbrown(-10.0, 20, 2.0).max(0).asStream);\n\n\t// random repeats\nTdef(\\ws1).set(\\repeats, { exprand(1, 20).round });\n\t// randomize number of wavesets per group\nTdef(\\ws1).set(\\numWs, { exprand(3, 20).round });\nTdef(\\ws1).set(\\numWs, 3, \\repeats, { rrand(2, 5) });\n\nTdef(\\ws1).stop;",
    "Figure 546": "Figure 16.31: Wavesets with pitch contour and dropout rate\n(\nTdef(\\ws1).set(\\startWs, Pn(Pseries(0, 5, 400) + 500, inf).asStream);\n\nTdef(\\ws1).set(\\gap, 0);\nTdef(\\ws1).set(\\pitchContour, 0);\nTdef(\\ws1).set(\\keepCoin, 1.0);\nTdef( 'ws1' ).set( 'repeats' , 5 );\nTdef( 'ws1' ).set( 'numWs' , 3 );\n\nTdef(\\ws1, { |ev|\n\tvar startFrame, length, wsSustain, reps, numWs, len2Avg; \n\tvar squeezer, playRate;\n\tloop { \n\t\treps = ev.repeats.next;\n\t\tnumWs = ev.numWs.next;\n\t\t\n\t\t#startFrame, length, wsSustain = \n\t\t\tw.frameFor(ev.startWs.next, numWs);\t\t\t\n\t\t\n\t\tlen2Avg = length / numWs / w.avgLength;\t\t\n\t\tsqueezer = len2Avg ** ev.pitchContour.next;\n\t\twsSustain = wsSustain / squeezer; \n\t\tplayRate = 1 * squeezer;\n\n\t\tif (ev.keepCoin.next.coin) { \n\t\t\t(instrument: \\wvst0, bufnum: b.bufnum, amp: 1, \n\t\t\t\tstart: startFrame, length:  length, \n\t\t\t\tsustain: wsSustain * reps,\n\t\t\t\tplayRate: playRate, \n\t\t\t\tpan: 1.0.rand2\n\t\t\t).play;\n\t\t};\n\t\t\n\t\t(wsSustain * (reps + ev.gap.next)).wait;\n\t}\n}).play;\n)\n\n\t// try different pitch Contours:\nTdef(\\ws1).set(\\pitchContour, 0); \t// original pitch\n\nTdef(\\ws1).set(\\pitchContour, 0.5); // flattened contour\n\n\t\t// waveset overtone singing - all equal length\nTdef(\\ws1).set(\\pitchContour, 1.0); \n\n\t\t// inversion of contour\nTdef(\\ws1).set(\\pitchContour, 1.5);\nTdef(\\ws1).set(\\pitchContour, 2);\nTdef(\\ws1).set(\\repeats, 3); \n\n\t// waveset omission\nTdef(\\ws1).set(\\keepCoin, 0.75);\nTdef(\\ws1).set(\\keepCoin, 1);\n\n\t// fade out by omission over 13 secs, pause 2 secs \nTdef(\\ws1).set(\\keepCoin, Pn(Penv([1, 0, 0], [13, 2])).asStream).play;\n\n\t// add a pitch contour envelope\nTdef(\\ws1).set(\\pitchContour, Pn(Penv([0, 2, 0], [21, 13])).asStream);",
    "Figure 547": "Figure  17.2 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5, 7]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 548": "Figure  17.3 \n\n(\nPbind(\n\\midinote, Pseq([0, 2, 3, 5.25, 7.5]+60, inf),\n\\dur, 0.3\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 549": "Figure  17.4 \n\n(\nPbind(\n\\note, Pseq([0,2,4,5,7,9,11,12], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 550": "Figure  17.5 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 551": "Figure  17.6 \n\n(\nPbind(\n\\degree, Pseq([0,1,2,3,4,5,6,7], inf),\n\\dur, 0.3,\n\\octave, 5,\n\\scale, (0..11)\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 552": "Figure  17.7 \n\n(\nPbind(\n\\degree, Pseq([0, 2, 2.1, 2.05], inf),\n\\dur, 0.3,\n\\scale, (0..11),\n\\octave, 5\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 553": "Figure  17.8 \n\n(\nPbind(\n\\note, Pwhite(-6,9),\n\\dur, 0.3,\n\\sustain, 1.1,\n\\stepsPerOctave, 7\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 554": "Figure  17.9 \n(\ne=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 4, 8, 11, 14, 17]\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 555": "Figure  17.10 \n\n(\n// previous example should still be running\ne.stream=Pbind(\n\\degree, Pwhite(-3, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 21,\n\\sustain, 1.1,\n\\scale, [0, 3, 5, 8, 10, 13]\n).asStream;\n)\n//////////////////////////////////////////////////////",
    "Figure 556": "Figure  17.11 \n\n(\nvar stepsperoctave=3;\nArray.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\n)\n\n//Using a function to calculate the value at a chosen degree\n(\nf = {|degree, steps|\n2.pow(degree/steps)\n};\n)\n// \tdegree 0\nf.(0, 3);\n// \tdegree 1\nf.(1, 3);\n// \tdegree 2\nf.(2, 3);\n\n//The function is modified to multiply the value by a root frequency in Hertz\n(\nf = {|degree, steps, root=440|\n2.pow(degree/steps)*root\n};\n)\n//\t12 notes per octave, degrees 0,1 and 12\nf.(0,12)\nf.(1, 12)\nf.(12, 12)\n\n//\t14 notes per octave, degrees 0,1, 12 and 14\nf.(0,14)\nf.(1, 14)\nf.(12, 14)\nf.(14,14)\n//////////////////////////////////////////////////////",
    "Figure 557": "Figure 17.12 \n\n(\nSynthDef(\"tone2\", { arg freq = 440, amp=0.5, gate=1, envdur=1.5;\nvar sound, env;\nenv = EnvGen.kr(Env.perc(0.01, envdur), doneAction:2);\nsound = Pan2.ar(SinOsc.ar(freq, 0, amp)*env, 0);\nOut.ar(0, sound);\n}).add;\n)\n(\na=[ 1, 1.030303030303, 1.0606060606061, 1.1212121212121, 1.3636363636364, 1.6060606060606, 2 ]*220;\n\n// Play the all the notes of the tuning\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).play\n)\n// Choose the notes randomly\n(\ne.stream=Pbind(\n\\freq, Pn(Prand( a, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\sustain, 0.6,\n\\instrument, \\tone2\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 558": "Figure 17.13 \n\n(\n~rationames=[1/1, 8/7, 7/6, 6/5, 5/4, 4/3, 7/5, 10/7, 3/2, 8/5, 5/3, 12/7, 7/4];\n~scale=[0,3,5,8,10,12];\ne = Pbind(\n\\freq, Pseq([\nPfunc({\n(~rationames.wrapAt(~scale).[~scale.size.rand])*440\n})\n],inf),\n\\dur, 0.25,\n\\amp, 0.5,\n\\instrument, \\tone2\n).play; // returns an EventStream\n)\n// set a new scale\n~scale=[0,2,5,7,9,11];\n~scale=[0,1,3,5,6,8,9];\n~scale=[0,3,5,8,10,12];\n//////////////////////////////////////////////////////",
    "Figure 559": "Figure 17.14 \n\n(\nvar n, buts, synths, ratios, rationames;\nw = Window(\"tonality diamond\", Rect(200,500,420,150));\nw.view.decorator = FlowLayout(w.view.bounds);\n\nrationames=[\n\"7/4\", \"3/2\",\"5/4\",\"1/1\",\n\"7/5\",\"6/5\",\"1/1\",\"8/5\",\n\"7/6\",\"1/1\",\"5/3\",\"4/3\",\n\"1/1\",\"12/7\",\"10/7\",\"8/7\"\n];\n\nn=rationames.size;\n\nn.do({ |i|\nButton(w, Rect(20,20+(i*30),100,30))\n.states_([[rationames[i], Color.black, \nif((rationames[i])==\"1/1\", {Color.red},{Color.yellow})\n]\n])\n.action_({ arg butt;\nSynth(\\tone2, [\\freq, ((rationames[i]).interpret)*440]);\n\n})\n});\nw.front;\n)\n//////////////////////////////////////////////////////",
    "Figure 560": "Figure 17.16 \n\n(\na=Pbind(\n\\degree, Pwhite(0, 12),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pwhite(0, 14),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 561": "Figure 17.17 \n\n(\na=Pbind(\n\\degree, Pfunc({\n[\n[0, 6, 12].choose, 12.rand\n].choose;\n}),\n\\dur, 0.5,\n\\octave, 4,\n\\amp, 0.4,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n);\nb=Pbind(\n\\degree, Pfunc({\n[\n[0, 7, 14].choose, 14.rand\n].choose;\n}),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.3,\n\\stepsPerOctave, 14,\n\\instrument, \\tone2\n);\nPpar([a, b]).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 562": "Figure 17.18 \n\n(\n~tolerance={|a, b, t, max|\nvar c, d;\nc=[];\nd=[];\na.do({ |aitem, aindex|\nb.do({ |bitem, bindex|\nvar x;\nx = (aitem-bitem).abs;\nif( (x > t) && (x < max),\n{\nc=c.add(aindex);\nd=d.add(bindex);\n//[aitem, bitem].post; \" out of tune \".post; [aindex, bindex].postln;\n//\" \".postln;\n})\n})\n});\n[(0..a.size).difference(c), (0..b.size).difference(d)];\n};\n)\n\n(\n// use the function function with two tunings\nvar mintreshold, maxtreshold, int;\n\n// two different equal tunings expressed linearly\na=Array.fill(12, { |i| (1/12)*(i) });\nb=Array.fill(21, { |i| (1/21)*(i) });\n\nint=1/21;\t\t\t\t// smallest interval\nmintreshold=int*0.15;\nmaxtreshold=int*0.85;\n/*\nintervals inferior to mintreshold are in tune\nintervals between mintreshold and maxtreshold are out of tune\nintervals superior to maxtreshold are in tune\n*/\n\n// print a list of notes from the two tunings which form a dissonant interval\n~tolerance.value(a, b, mintreshold, maxtreshold);\n)\n//////////////////////////////////////////////////////",
    "Figure 563": "Figure 17.19 \n\n(\na=Pbind(\n\\degree, Pfunc({\n// notes which clash with the other tuning have been removed\n[0,4,8,12].choose\n}),\n\\dur, 0.5,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).play;\nb=Pbind(\n// notes which clash with the other tuning have been removed\n\\degree, Pfunc({\n[0,7,14,21].choose\n}),\n\\dur, 0.25,\n\\octave, 4,\n\\amp, 0.35,\n\\sustain, 0.85,\n\\stepsPerOctave, 21,\n\\instrument, \\tone2\n).play;\n)\n\n(\na.stream=Pbind(\n// introducing more notes from that tuning after having changed the threshold\n\\degree, Pfunc({\n[ 0, 1, 4, 7, 8, 9, 9, 12 ].choose\n}),\n\\dur, 0.75,\n\\octave, 5,\n\\amp, 0.4,\n\\sustain, 0.85,\n\\stepsPerOctave, 12,\n\\instrument, \\tone2\n).asStream;\n)\n//////////////////////////////////////////////////////",
    "Figure 564": "Figure 17.20 \n\n(\nf = {|steps| Array.fill(steps, { |i| 2.pow(i/steps) }) };\n//\tCalculation of the twelve equal-note temperament\nx =  f.(12);\n//\tmapping the tuning to a new range beyond an octave\ny = x.linlin(1, 2, 1, 2.25);\n//\tmultiplying by a root frequency\na=y*440;\n\nPbind(\n\\freq, Pfunc({ a.choose }),\n\\dur, 0.25,\n\\octave, 5,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 565": "Figure 17.21 \n\n(\nPbind(\n\\degree, Pwhite(0, 18),\n\\dur, 0.3,\n\\sustain, 1.0,\n\\amp, 0.5,\n\\sustain, 1.1,\n\\instrument, \\tone2,\n\\stepsPerOctave,  18.809\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 566": "Figure 17.22 \n\n(\na=[ 1, 1.09375, 1.1875, 1.28125, 1.375, 1.46875, 1.5625, 1.65625];\nb=a*440;\ne=Pbind(\n\\freq, Pseq( b, inf),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).play\n)\n// play in a different order\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( b, 1)),\n\\dur, 0.2,\n\\amp, 0.5,\n\\instrument, \\tone2,\n\\sustain, 0.6\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 567": "Figure 17.23 \n\n(\n// F. Mogini pattern-based Tuning - 2000.\nx=880;\n\nPbind(\n\\freq, Pn(\nPlazy({\nif(x<=150, {x=x*2});\nif(x>=2000, {x=x/2});\nx=[\n\nx*[1.1428,  1.36, 1.26].choose,\nx/[1.1428,  1.36, 1.26].choose\n\n].choose\n})\n),\n\\dur, 0.14,\n\\sustain, 0.8,\n\\cutoff, Pfunc({ 1.0.rand})\n).play;\n)\n//////////////////////////////////////////////////////",
    "Figure 568": "Figure 17.24 \n\na=(1..16)*100\n(\ne=Pbind(\n\\freq, Pseq( a, inf),\n\\dur, 0.2\n).play\n)\n\n// a beautiful tuning system can be created from the harmonic series.\n(\ne.stream=Pbind(\n\\freq, Pn(Pshuf( a, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).asStream\n)\n//////////////////////////////////////////////////////",
    "Figure 569": "Figure 17.25\n\na=(1..11);\n(\na.size.do({ |i|\nvar x=a[i];\nwhile({x>2},{x=x/2});\na.put(i, x)\n});\n)\n\nb=a.asSet.asArray.sort;\n(\ne=Pbind(\n\\freq, Pn(Pshuf( b*440, 1)),\n\\dur, 0.2,\n\\sustain, 0.8\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 570": "Figure 17.26 \n\na=(1..8);\nb=(9..16);\n(\na.size.do({ |i|\nvar x=a[i];\nvar y=b[i];\n// harmonics below 8 remain in the first octave\nwhile({x>2},{x=x/2});\n// harmonics above 9 remain in the second octave\nwhile({y>4},{y=y/2});\na.put(i, x);\nb.put(i, y);\n});\n)\na;\nb;\nc=(a++b).asSet.asArray.sort;\nc;\n\n(\ne=Pbind(\n\\freq, Pn(Pshuf( c*200, 1)),\n\\dur, 0.2,\n\\sustain, 1.1\n).play\n)\n//////////////////////////////////////////////////////",
    "Figure 571": "Figure 17.27 \n\n(\n// \ta function to expand the tuning from one octave to four octaves\n~harmsfunc={arg stepsperoctave=7;\nvar harms;\n// calculate each note from the tuning\nharms=Array.fill(stepsperoctave, {arg i; 2.pow(i/stepsperoctave)});\nharms.size.do({ |i|\nif( 0.6.coin, {\n// multiply some of the notes to create higher harmonics\nharms.put(i, (harms[i])*[1,2,4,8].choose )\n})\n});\nharms.sort;\n};\n)\n\n//  create an array of virtual harmonics, seven equal-note temperament\n~harms=~harmsfunc.value(7);\n\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).add;\n)\n\n(\ne=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are rpeated so we can notice the effect of harmonics\n\\degree, Pseq([0,1,2,3,4,5,6,7],inf),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).play;\n)\n\nSend the SynthDef function again to obtain new amplitudes for each harmonic\n(\n// send a synth definition with some partials and the current value of ~harms\n\nSynthDef(\\cfstring1, { arg out=0, freq = 360, gate = 1, pan, amp=0.8;\nvar sound, eg, fc, osc, a, b, w;\nvar harms, amps;\n\n// use the harmonics previously calculated\nharms=~harms;\n//\tcreate new amplitudes for each harmonic\namps=Array.fill(harms.size,{1.0.rand}).normalizeSum*0.1;\n\nosc = Array.fill(harms.size, { |i|\nSinOsc.ar(freq * harms[i], 0, amps[i] );\n})++[SinOsc.ar(freq , 0, amp*(0.5.rand+0.2) ), SinOsc.ar(freq*2 , 0, amp*(0.5.rand+0.15) )];\n\neg = EnvGen.kr(Env.asr(0.02,1,1), gate, doneAction:2);\n\nsound = Pan2.ar(eg * Mix.ar(osc), pan);\nOut.ar(0, sound);\n}).add;\n)\n\n// re-evalute the function to create new harmonics (update the SynthDef afterwards)\n~harms=~harmsfunc.value(7);\n//Send the SynthDef function again, as we have done earlier to obtain new amplitudes for each harmonic\n\n// finally playing a random melody to make it less repetitive\n(\ne.stream=Pbind(\n\\instrument, \\cfstring1,\n// frequencies are repeated so we can notice the effect of harmonics\n\\degree,  Pwhite(0, 7),\n\\dur, 0.25,\n\\stepsPerOctave, 7,\n\\octave, 4,\n\\pan, Pfunc({0.5.rand2 })\n).asStream;\n)\n// we could develop further and re-write the SynthDef with a partial argument \n// and also change the partials directly from Pbind\n\n//////////////////////////////////////////////////////",
    "Figure 572": "Figure 17.28 \n\n(\nvar w, keys, steps, octaves;\n\nw = Window.new.name=\"Custom keyboard: 7 steps per octave\";\nsteps = 7;\noctaves= 2;\n// seven steps per octave;\na=Array.fill(7, { |i| (1/7)*(i) })+1;\nb= a++(a*2);\n\nc=Synth(\\default, [\\amp, 0]);\n\nkeys=Array.fill(steps*octaves,{ |i|\n\nButton(w, Rect(20+(i*22),20,20,50))\n.states_([\nif(i.mod(steps)==0,{\n[i.asString, Color.black, Color.red]},{\n[i.asString, Color.black, Color.yellow]});\n\n])\n.action_({ arg butt;\nc.set(\\freq,b[i]*220, \\amp, 0.25)\n});\n});\n\nw.front;\n)\n//////////////////////////////////////////////////////",
    "Figure 573": "Figure 18.1\n/*\nThis example is adapted and extracted from the Non-Realtime Synthesis helpfile itself, accessible from the Main SuperCollider help page.\n*/\n(\nvar f, c, d;\n// open a file for writing raw OSC data to\nf = File(\"~/test.osc\".standardizePath,\"w\");\n// start a sine oscillator at 0.2 seconds.\nc = [ 0.2, [\\s_new, \\default, 1001, 0, 0]];\n// convert the bundle to raw OSC\nd = c.asRawOSC;\nf.write(d.size); // each bundle is preceded by a 32 bit size.\nf.write(d); // write the bundle data.\nf.close;\n)",
    "Figure 574": "Figure 18.2\ns = Server.local;\ns.boot;\n\n// a sample SynthDef\nSynthDef(\\NRT_beep, {arg freq, dur, amp = 0.1;\n\tvar half;\n\thalf = dur * 0.5;\n\tOut.ar(0, SinOsc.ar(freq, 0, \n\t\tEnvGen.kr(Env.new([0, amp, 0], [half, half], [4, -4]))));\n\t}).load(s);\n\n(\nvar score;\n\n// A Score, created from a note-list of time-stamped events.\nscore = Score.new([\n    [0.0,\n        [\\g_new, 1000],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 75.midicps, \\dur, 0.2]\n    ], \n    [0.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.0,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 71.midicps, \\dur, 0.2]\n    ], \n    [1.2,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.4,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.6,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [1.8,\n        [\\n_free, 1001],\n        [\\s_new, \\NRT_beep, 1001, 0, 1000, \\freq, 82.midicps, \\dur, 0.2]\n    ], \n    [2.0,\n        [\\n_free, 1001, 1000]\n    ],\n\t[2.00001, [0]]\n]);\n\nscore.play(s); // play the Score in real-time...\n\n// ... or render in Non-Real-Time\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n)",
    "Figure 575": "Figure 18.3\n(\n//In this example, we use the higher-level server abstraction classes, Group and Synth to handle the\n// node IDs. At least as important though is the use of variables. Now that the relationships are\n// specified rather than the specific values, we can change the gesture dramatically by changing\n// just one or two variables. To transpose everything, we only need to change the value of \n// ~baseNote. To adjust the duration, we only need to change the ~dur variable, and this is now \n// independent of the deltaOn (i.e. independent of the amount of time between the start of one\n// note and the start of the next note).\nvar score;\nvar deltaOn = 0.2;  //amount of time between the start of one note and the start of the next note\nvar dur = 0.4;      //try changing dur to 0.3, 1.4, 3.4, or whatever you like\nvar baseNote = 75;  //transpose the entire fragment up or down\nvar firstPitch  = (baseNote + 0).midicps;  //alter the relationship between any of the pitches\nvar secondPitch = (baseNote - 4).midicps;  // without effecting the others\nvar thirdPitch  = (baseNote + 7).midicps;\n\nscore = Score.new([\n\t[t =  0.0,\n\t\t(g = Group.basicNew(s)).newMsg,\n\t\t//we use environment variables here (identified by the preceding ~) \n\t\t// since we might add or remove events; hence we don't know ahead of \n\t\t// time how many events we have, and therefore how many variables we'll need\n\t\t(~s01 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s01.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s02 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s02.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s03 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t],\n\t[t + dur,\n\t\t~s03.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s04 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, firstPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s04.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s05 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s05.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s06 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, secondPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s06.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s07 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s07.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s08 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s08.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s09 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s09.freeMsg\n\t],\n\t[t = t + deltaOn,\n\t\t(~s10 = Synth.basicNew(\\NRT_beep, s))\n\t\t\t.newMsg(g, [\\freq, thirdPitch, \\dur, dur], \\addToHead)\n\t], \n\t[t + dur,\n\t\t~s10.freeMsg,\n\t\tg.freeMsg\n\t],\n]\n);\n\nscore.sort;\nscore.play(s);\n)",
    "Figure 576": "Figure 18.4\n(\nvar score, graingest;\n\n// seed the randomness\nthisThread.randSeed_(123);\n\n// a sample SynthDef\nSynthDef(\\NRT_grain, {arg freq, dur, amp, pan;\n\tOffsetOut.ar(0, Pan2.ar(\n\t\tSinOsc.ar(freq, 0, \n\t\t\tEnvGen.ar(Env.sine(dur, amp), doneAction: 2)),\n\t\tpan)\n\t\t);\n\t}).load(s);\n\nscore = Score.new;\n\n// envelope times are scaled to 1.\ngraingest = {arg score, starttime, duration, windur, overlaps, freqenv, ampenv, panenv;\n\tvar ratio, curfreq, curamp, curpan, notestart, now = 0.0, note;\n\twhile({\n\t\tratio = now / duration;\n\t\tcurfreq = freqenv[ratio];\n\t\tcuramp = ampenv[ratio];\n\t\tcurpan = panenv[ratio];\n\t\tnotestart = now + starttime;\n\t\tnote = Synth.basicNew(\\NRT_grain);\n\t\tscore.add([notestart, \n\t\t\tnote.newMsg(1, [\\freq, curfreq,\\amp, curamp, \\dur, windur, \\pan, curpan], \\addToHead)]\n\t\t\t);\n\t\t// check the current event's endtime against the global endtime\n\t\tnow = now + (windur / overlaps);\n\t\tnow < duration;\n\t\t});\n\t};\n\n// call the above function to populate the Score\n\ngraingest.value(score, 1.0, 10.0, 100.reciprocal, 1, Env([440, 550], [1]), \n\tEnv([0, 0.2, 0], [0.3, 0.7], [4, -4]), Env([0, 0], [1]));\ngraingest.value(score, 3.0, 3.0, 130.reciprocal, 2, Env([700, 400], [1]),\n\tEnv([0, 0.2, 0], [0.1, 0.9], [4, -1]), Env([-0.7, 0.7], [1]));\n\n// create a number of short gestures\n10.do({arg i;\n\tgraingest.value(score, 5.0.rrand(10.0), 3.0.rrand(5.0), (100 * i).reciprocal, [1, 2, 4].choose,\n\t\tEnv([1000, 800], [1]), Env([0, 0.2, 0], [0.5, 0.5]), Env([0.5.rand2, 0.5.rand2], [1]));\n\t});\n\n// save the endtime to the Score to tell NRT when to stop rendering. The above gestures won't\n// be more the 16 seconds\n\nscore.add([16, [0]]);\n\n// sort the score to ensure events are in the correct order\n\nscore.sort;\n\n// render the Score to the users home folder\n\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, \n\toptions: ServerOptions.new.numOutputBusChannels_(1));\n\t\n// also save the Score to a file\nscore.saveToFile(\"~/test.sc\".standardizePath);\n)",
    "Figure 577": "Figure 18.5\n(\nvar score, sndbuf, starttime, synth, options;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// create a Buffer object for adding to the Score\nsndbuf = Buffer.new;\n\n// for NRT rendering, the buffer messages must be added to the Score\nscore.add([0, sndbuf.allocReadMsg(\"sounds/a11wlk01-44_1.aiff\")]);\n\nstarttime = 0.0;\n\n// a small function to create a series of small notes based on the Buffer\nwhile({\n\tsynth = Synth.basicNew(\\NRT_playback);\n\tscore.add([starttime, \n\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\tstarttime = starttime + 0.05;\n\tstarttime < 10.0;\n\t});\n\n// the dummy command. The soundfile will be 11 seconds long\nscore.add([11, 0]);\n\nscore.sort;\n\n// the ServerOptions for rendering the soundfile\noptions = ServerOptions.new.numOutputBusChannels_(1);\n\n// write the soundfile out to disk\nscore.recordNRT(\"/tmp/trashme\", \"~/test.aiff\".standardizePath, options: options);\n)",
    "Figure 578": "Figure 18.6\n(\nvar score, sndbuf, starttime, synth, options, cond;\n\nSynthDef(\\NRT_playback, {arg buffer, dur, startPos, amp;\n\tOffsetOut.ar(0, PlayBuf.ar(1, buffer, BufRateScale.kr(buffer), \n\t\t\tstartPos: startPos * BufSampleRate.kr(buffer)) *\n\t\tEnvGen.ar(\n\t\t\tEnv.sine(dur, amp),\n\t\t\tdoneAction: 2))\n\t}).load(s);\n\nscore = Score.new;\n\n// set up a Condition to check for when asynchronous events are finished.\n\ncond = Condition.new;\n\n// wrap the code that will run in real-time in a Routine, to allow for the Server to sync\nRoutine.run({\n\t// load the buffer\n\tsndbuf = Buffer.read(s, \"sounds/a11wlk01-44_1.aiff\");\n\t\n\t// pause while the buffer is loaded\n\ts.sync(cond);\n\t\n\t// fill the Score with notes\n\t\n\tstarttime = 0.0;\n\t\n\twhile({\n\t\tsynth = Synth.basicNew(\\NRT_playback);\n\t\tscore.add([starttime, \n\t\t\tsynth.newMsg(s, [\\buffer, sndbuf, \\dur, 0.1, \\startPos, 0.0.rrand(1.0), \\amp, 0.1])]);\n\t\tstarttime = starttime + 0.05;\n\t\tstarttime < 10.0;\n\t\t});\n\t\n\t// the last command is NOT needed, since no soundfile is being rendered\n//\tscore.add([11, 0]);\n\t\n\tscore.sort;\n\t\n\t// again, options won't be needed for real time performance\n//\toptions = ServerOptions.new.numOutputBusChannels_(1);\n\t\n\tscore.play;\n\t// schedule the freeing of the buffer after the Score is done playing\n\tSystemClock.sched(11, {sndbuf.free; \"Buffer resources freed\".postln;});\n\t})\n)",
    "Figure 579": "Figure 18.7\n\n\n// environment variables are used for real-time examples of Ctk objects\n\nn = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg gate = 1, freq, amp;\n\t\tvar src, env;\n\t\tsrc = SinOsc.ar(freq, 0, amp);\n\t\tenv = EnvGen.kr(Env([0, 1, 0], [1, 1], \\sin, 1), gate, doneAction:2);\n\t\tOffsetOut.ar(0, src * env);\n\t\t})\n\t);\n\t\n// create a new note based on 'n', start to play it in 0.1 seconds\na = n.new(0.1).freq_(440).amp_(0.1).gate_(1).play;\n// the release method will set 'gate' to 0.0, and free this node\na.release;\n\n// create another note\na = n.new(0.1).freq_(440).amp_(0.1).play;\n// alter the freq argument in real time\na.freq_(550);\n// alter the freq with a CtkControl that describes an Env\n// CtkControl.env(Env)\na.freq_(CtkControl.env(Env([550, 440, 550], [1, 2], \\exp)));\n// apply a random control to the amp parameter, with an envelope applied to the range. All \n// parameters to the CtkControl can themselves be CtkControls\n// CtkControl.lfo(KRUGen, freq, low, high, phase)\na.amp_(CtkControl.lfo(LFNoise2, 0.5, CtkControl.env(Env([0.1, 0.9], [5])), 0.1));\na.amp_(0.1);\n\n// release the note\na.release;",
    "Figure 580": "Figure 18.8\n// melodic expander\n(\nvar note, keys, durs, now, score, chunk, expander, rangemap;\n\n// \nthisThread.randSeed_(123);\n\n// a simple note player\n\nnote = CtkSynthDef(\\NRT_dut, {arg key, amp, dur;\n\t\tOut.ar(0, SinOsc.ar(key.midicps, 0, XLine.kr(amp, 0.00001, dur)))\n\t\t});\n\n// first, make a melody - these will be used as midikeynums (easier to alter later)\n\nkeys = [ 72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72 ];\n\n// a list of durations\n\ndurs = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5];\n\n// create a var to store 'now' in\n\nnow = 0.0;\n\n// create a CtkScore with the above melody\n\nscore = CtkScore.new;\n\nkeys.do({arg thiskey, inc;\n\tvar thisdur;\n\tthisdur = durs[inc];\n\tscore.add(note.new(now, thisdur).key_(thiskey).amp_(0.2).dur_(thisdur));\n\tnow = now + thisdur;\n\t});\n\n// first, create a function that will return a chunk of the melody the duration of the chunk\n// sets the starttimes of the notes to a base of 0.0\n\nchunk = {arg offset = 0;\n\tvar size, start, end, duration = 0, chunk, copies;\n\t// the size of the current melody - 1 (for array access)\n\tsize = score.notes.size;\n\t// the beginning of the chunk can come from the beginning of the melody to the second to \n\t// last note\n\tstart = 0.rrand(size-1);\n\tend = start.rrand(size);\n\tchunk = score.notes[start..end].collect({arg anote; \n\t\tvar newnote;\n\t\tnewnote = anote.copy(duration + offset);\n\t\tduration = duration + anote.duration;\n\t\tnewnote;\n\t\t});\n\t[chunk, duration];\n\t};\n\n// now, create a function that will add those chunks to the score, and will keep doing this\n// until the score is at least the desired length. Then check the score size, and truncate to \n// desired size.\n\nexpander = {arg len;\n\tvar curchunk, chunkdur, insert, inserttime, insertdur, cursize, newnotes;\tcursize = score.notes.size;\n\twhile({\n\t\tcursize < len\n\t\t}, {\t\t\n\t\tinsert = 0.rrand(cursize - 1);\n\t\tinserttime = score.notes[insert].starttime;\n\t\tinsertdur = score.notes[insert].duration;\n\t\t#curchunk, chunkdur = chunk.value(inserttime + insertdur);\n\t\tscore.notes[(insert+1)..(cursize-1)].do({arg me; \n\t\t\tme.setStarttime(me.starttime + chunkdur)});\n\t\tscore = score.add(curchunk);\n\t\t(score.notes.size > len).if({\n\t\t\tscore.notes.do({arg me, i;\n\t\t\t\t(i > (len - 1)).if({score.notes.remove(me)});\n\t\t\t\t})\n\t\t\t});\n\t\tcursize = score.notes.size;\n\t\t});\n\t};\n\n// rangemap will place the melodic material within a certain range. The user passes \n// in an envelope that will describe the center pitch in an octave range\n\nrangemap = {arg center;\n\tscore.notes.do({arg me;\n\t\tme.key_(me.key.mapIntoRange(12, center[me.starttime]));\n\t\t})\n\t};\n\t\t\n// expand it to 100 notes\nexpander.value(100);\n\n// describe a new range of pitches\nrangemap.value(Env([60, 96], [20]));\n\n// finally, play the CtkScore\n\nscore.play;\n)",
    "Figure 581": "Figure 18.9\n\n(\nvar score, grain, now, thisdur;\nvar ampmap, double;\n\ngrain = CtkNoteObject(\n\tSynthDef(\\NRT_grain, {arg freq, amp, dur, pan = 0;\n\t\tvar src, env;\n\t\tenv = EnvGen.ar(\n\t\t\tEnv([0, 1, 0], [0.5, 0.5], \\sin),\n\t\t\ttimeScale: dur, doneAction: 2, levelScale: amp);\n\t\tsrc = SinOsc.ar(freq, 0, env);\n\t\tOffsetOut.ar(0, Pan2.ar(src, pan));\n\t\t})\n\t);\n\t\nscore = CtkScore.new;\n\nnow = 0;\n\n// create a 3 second granular gesture\n\nwhile({\n\tthisdur = 0.05.rrand(0.1);\n\tscore.add(\n\t\tgrain.new(now, thisdur).freq_(440.rrand(880)).amp_(0.05).dur_(thisdur).pan_(0));\n\tnow = now + 0.01;\n\tnow < 3;\n\t});\n\n// a function to later map the amplitude to a given shape\n// envtimes should be scaled to 1\nampmap = {arg aScore, env;\n\t// scaled the envs times by the CtkScore's duration\n\tenv.times = env.times * aScore.endtime;\n\taScore.notes.do({arg thisNote;\n\t\tvar curtime;\n\t\tcurtime = thisNote.starttime;\n\t\tthisNote.amp_(env[curtime]);\n\t\t});\n\t};\n\n// returns a new copy of the CtkScore with notes\n// double an octave higher\ndouble = {arg aScore, shift = 2;\n\tvar thisScore;\n\tthisScore = aScore.copy;\n\tthisScore.notes.do({arg thisNote;\n\t\tthisNote.freq_(thisNote.freq * shift)\n\t\t});\n\tthisScore;\n\t};\n\t\t\n// a Routine to play the examples\nRoutine.run({\n\tvar scoreDouble;\n\t// play the CtkScore;\n\tscore.play;\n\tscore.endtime.wait;\n\t// remap the amplitudes\n\tampmap.value(score, Env([0, 0.2, 0], [0.1, 0.9], [4, -2]));\n\t1.wait; // pause for a moment\n\t// play it again!\n\tscore.play;\n\tscore.endtime.wait;\n\t// add the CtkScore that octaveDouble returns\n\tscoreDouble = double.value(score, 19.midiratio);\n\tampmap.value(scoreDouble, Env([0, 0.25, 0], [0.6, 0.4], [4, -2]));\n\tscore.add(scoreDouble);\n\t1.wait;\n\tscore.play;\n\tscore.endtime.wait;\n\t// don't like the second version? remove double\n\tscore.ctkscores.remove(scoreDouble);\n\tampmap.value(score, Env([0.15, 0.05], [1]));\n\t1.wait;\n\tscore.play;\n\t}).randSeed_(123)\n)",
    "Figure 582": "Figure 18.10\ns = Server.local;\ns.boot;\n\n~sinosc = CtkSynthDef.new(\\NRT_sinosc, \n\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t}\n);\n\n(\nvar score;\nvar baseNote = 75;\nvar slopeTime = 0.25;\nvar curve = \\sine;\nvar firstPitch = (baseNote + 0).midicps;\nvar firstStart = 0.0;\nvar firstDur = 5.0;\nvar firstAttackTime = slopeTime * 0.5;\nvar firstDecayTime  = slopeTime - firstAttackTime;\nvar firstVibDepth = 0.21;\nvar firstVibRate = 2.3;\nvar firstPeakAmp = 0.25;\nvar firstDecayAmp = 0.01;\nvar secondPitch = (baseNote - 4).midicps;\nvar secondStart = 2.2;\nvar secondDur = 4.0;\nvar secondAttackTime = slopeTime * 0.5;\nvar secondDecayTime  = slopeTime - secondAttackTime;\nvar secondVibDepth = 0.15;\nvar secondVibRate = 1.7;\nvar secondPeakAmp = 0.25;\nvar secondDecayAmp = 0.01;\nvar thirdPitch = (baseNote + 7).midicps;\nvar thirdStart = 3.1;\nvar thirdDur = 3.75;\nvar thirdAttackTime = slopeTime * 0.5;\nvar thirdDecayTime  = slopeTime - thirdAttackTime;\nvar thirdVibDepth = 0.21;\nvar thirdVibRate = 4;\nvar thirdPeakAmp = 0.2;\nvar thirdDecayAmp = 0.25;\n\nscore = CtkScore.new(\n\t~firstGroup = CtkGroup.new(firstStart, firstDur, server: s),\n\t~sinosc.new(firstStart, firstDur, \\tail, ~firstGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, firstVibRate, \n\t\t\t(firstPitch - ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (1/3)))), \n\t\t\t(firstPitch + ((firstPitch / (firstPitch.log2)) * (firstVibDepth * (2/3)))), \n\t\t\tduration: firstDur, addAction: \\head, target: ~firstGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, firstPeakAmp, firstDecayAmp, 0], [firstAttackTime, \n\t\t\t\tfirstDur - (firstAttackTime + firstDecayTime), firstDecayTime], curve), \n\t\t\taddAction: \\head, target: ~firstGroup, server: s)),\n\t~secondGroup = CtkGroup.new(secondStart, secondDur, server: s),\n\t~sinosc.new(secondStart, secondDur, \\tail, ~secondGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, secondVibRate, \n\t\t\t(secondPitch - ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (1/3)))), \n\t\t\t(secondPitch + ((secondPitch / (secondPitch.log2)) * (secondVibDepth * (2/3)))), \n\t\t\tduration: secondDur, addAction: \\head, target: ~secondGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, secondPeakAmp, secondDecayAmp, 0], [secondAttackTime, \n\t\t\t\tsecondDur - (secondAttackTime + secondDecayTime), secondDecayTime], curve), \n\t\t\taddAction: \\head, target: ~secondGroup, server: s)),\n\t~thirdGroup = CtkGroup.new(thirdStart, thirdDur, server: s),\n\t~sinosc.new(thirdStart, thirdDur, \\tail, ~thirdGroup, server: s)\n\t\t.freq_(CtkControl.lfo(SinOsc, thirdVibRate, \n\t\t\t(thirdPitch - ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (1/3)))), \n\t\t\t(thirdPitch + ((thirdPitch / (thirdPitch.log2)) * (thirdVibDepth * (2/3)))), \n\t\t\tduration: thirdDur, addAction: \\head, target: ~thirdGroup, server: s))\n\t\t.amp_(CtkControl.env(\n\t\t\tEnv.new([0, thirdPeakAmp, thirdDecayAmp, 0], [thirdAttackTime, \n\t\t\t\tthirdDur - (thirdAttackTime + thirdDecayTime), thirdDecayTime], curve), \n\t\t\taddAction: \\head, target: ~thirdGroup, server: s))\n);\n\nscore.play;\n)",
    "Figure 583": "Figure 18.11\nVSO_Vib {\n\n\tvar <pitch, <depth, <rate, <control;\n\n\t*new {arg start = 0.0, dur = nil, freq = 1, vibDepth = 0.21, vibRate = 1, \n\t\taddAction = 0, target = 1, server;\n\t\t^super.new.initVSO_Vib(start, dur, freq, vibDepth, vibRate, addAction, \n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_Vib {arg start, dur, freq, vibDepth, vibRate, add = 0, tgt = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tpitch = freq;\n\t\tdepth = vibDepth;\n\t\trate = vibRate;\n\t\tcontrol = CtkControl.lfo(SinOsc, rate, this.getLowerValue,\n\t\t\tthis.getUpperValue, 0, start, dur, add, tgt, server: server);\n\t\n\t}\n\t\n\tgetLowerValue {\n\t\t^(pitch - ((pitch / (pitch.log2)) * (depth * (1/3))));\n\t}\n\n\tgetUpperValue {\n\t\t^(pitch + ((pitch / (pitch.log2)) * (depth * (2/3))));\n\t}\n}",
    "Figure 584": "Figure 18.12\nVSO_ADR {\n\n\tvar <control, <attackDur, <releaseDur, <totalDur;\n\n\t*new {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, attackDur = 0.125, \n\t\treleaseDur = 0.125, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO_ADR(start, dur, peak, decay, attackDur, releaseDur, addAction,\n\t\t\ttarget, server);\n\t}\n\t\n\tinitVSO_ADR {arg start = 0.0, dur =  nil, peak = 0.707, decay = 0.01, aDur = 0.125, \n\t\trDur = 0.125, addAction = 0, target = 1, server;\n\t\tserver = server ?? {Server.default};\n\t\tattackDur = aDur;\n\t\treleaseDur = rDur;\n\t\ttotalDur = dur;\n\t\tcontrol = CtkControl.env(Env.new([0, peak, decay, 0], \n\t\t\t[attackDur, this.decayDur, releaseDur], \\sine), \n\t\t\tstart, addAction, target, server: server, doneAction: 0);\n\t}\n\t\n\tdecayDur {\n\t\t^(totalDur - (attackDur + releaseDur));\n\t}\n\n}",
    "Figure 585": "Figure 18.13\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}",
    "Figure 586": "Figure 18.14\nVSO {\n\n\tclassvar <sinoscdef;\n\tvar <score, group, oscil, freqCntl, <ampCntl;\n\t\n\t*new {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, ampDecayLevel = 0.01, \n\t\tvibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, server;\n\t\t^super.new.initVSO(start, dur, freq, ampPeakLevel, ampDecayLevel, \n\t\t\tvibDepth, vibRate, addAction, target, server);\n\t}\n\n\t*initClass {\n\t\tsinoscdef.isNil.if({\n\t\t\tsinoscdef = CtkSynthDef.new(\\NRT_sinosc, \n\t\t\t\t{arg outbus = 0, freq = 622.254, phase = 0, amp = 1, offSet = 0;\n\t\t\t\t\tOut.ar(outbus, SinOsc.ar(freq, phase, amp, offSet));\n\t\t\t\t})\n\t\t\t});\n\t}\n\n\tinitVSO {arg start = 0.0, dur = nil, freq = 622.254, ampPeakLevel = 0.707, \n\t\tampDecayLevel = 0.01, vibDepth = 0.21, vibRate = 3, addAction = 0, target = 1, \n\t\t\tserver;\n\t\tserver = server ?? {Server.default};\n\t\tgroup = CtkGroup.new(start, dur, addAction: addAction, target: target, \n\t\t\tserver: server);\n\t\tfreqCntl = VSO_Vib.new(start, dur, freq, vibDepth, vibRate, \\head, group, server);\n\t\tampCntl = VSO_ADR.new(start, dur, ampPeakLevel, ampDecayLevel, addAction: \\head, \n\t\t\ttarget: group, server: server);\n\t\toscil = sinoscdef.new(start, dur, \\tail, group, server)\n\t\t\t.freq_(freqCntl.control).amp_(ampCntl.control);\n\t\tscore = CtkScore.new(group, oscil);\n\t}\n\n}",
    "Figure 587": "Figure 18.15\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nscore = CtkScore.new(\n\t(a = VSO.new(0.0, 5.0, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(2.2, 4.0, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(3.1, 3.75, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n)",
    "Figure 588": "Figure 18.16\ns = Server.local;\ns.boot;\n\n(\nvar score;\nvar baseNote = 75;\nvar firstPitch = (baseNote + 0).midicps;\nvar secondPitch = (baseNote - 4).midicps;\nvar thirdPitch = (baseNote + 7).midicps;\n\nd = [2.4, 1.7];\na = NRT_TimeFrame.new(0.0, 11);\nb = NRT_TimeFrame.new(a.starttime + d.at(0), a.endtime - (a.starttime + d.at(0)));\nc = NRT_TimeFrame.new(b.starttime + d.at(1), b.endtime - (b.starttime + d.at(1)));\n\nscore = CtkScore.new(\n\t(a = VSO.new(a.starttime, a.duration, firstPitch, 0.25, 0.01, 0.21, 2.3, server: s)).score,\n\t(b = VSO.new(b.starttime, b.duration, secondPitch, 0.25, 0.01, 0.15, 1.7, server: s)).score,\n\t(c = VSO.new(c.starttime, c.duration, thirdPitch, 0.15, 0.3, 0.21, 4, server: s)).score\n);\nscore.play;\n//N.B. You may notice three \"Node not found\" warnings.\n// This is expected behavior for this version of Ctk\n)",
    "Figure 589": "Figure 18.17\nNRT_TimeFrame {\n\n\tvar >starttime, >duration;\n\t\n\t*new {arg starttime, duration;\n\t\t^super.newCopyArgs(starttime, duration);\n\t}\n\n\tstarttime {\n\t\t^ starttime.value;\n\t}\n\n\tduration {\n\t\t^ duration.value;\n\t}\n\n\tendtime {\n\t\t^(this.starttime != nil).if({\n\t\t\t\t(this.duration != nil).if({\n\t\t\t\t\t//call the getter methods rather than accessing\n\t\t\t\t\t// the variables directly\n\t\t\t\t\tthis.starttime + this.duration;\n\t\t\t\t}, {nil})\n\t\t}, {nil});\n\n\t}\n\n}",
    "Figure 590": "Figure 20.1\n// create the mixer: one channel in, two channels out\nm = MixerChannel(\\fig1, s, 1, 2);\n\n// bring up a mixing board -- you can play with the level and panning controls\n// closing the window, or freeing all of its channels, removes the MixingBoard\nb = MixingBoard(\\Fig1, nil, m);\n\n// a SynthDef should include an outbus argument\n// so that the MixerChannel can tell it where to write its output\n(\nSynthDef(\\fig1, { |outbus, lowfreq = 220, hifreq = 1200, decay = 0.05|\n\tvar\ttrig = Impulse.kr(8);\n\t\t// Do not hard-code the outbus here!\n\t\t// Out.ar(0, ...) is not OK. Out.ar(outbus, ...) is good.\n\tOut.ar(outbus, SinOsc.ar(TExpRand.kr(lowfreq, hifreq, trig)) * Decay2.kr(trig, 0.01, decay));\n}).add;\n)\n\na = m.play(\\fig1, [lowfreq: 100, hifreq: 2000, decay: 0.1]);\n\n// automate panning - this is done with a control-rate synth\nm.automate(\\pan, { SinOsc.kr(LFNoise1.kr(0.5).exprange(0.4, 5.0)) });\n\n// the GUI can show the automation\nm.watch(\\pan);\n\n// add reverb using post-fader send\n// auto-play the reverb synth in the completion function\n(\nr = MixerChannel(\\rvb, s, 2, 2, level:1, completionFunc: { |chan|\n\t\"creating reverb synth\".postln;\n\tchan.playfx({ |outbus|\n\t\tvar\tsig = In.ar(outbus, 2);  // read from channel's bus\n\t\tFreeVerb2.ar(sig[0], sig[1], 1, 0.6, 0.5)\n\t});\n});\n\nb.add(r);  // add to MixingBoard\n)\n\n// feed the signal into the reverb\nm.newPostSend(r, 0.6);\n\n// prints out current state of all mixers in the board\n// the board is accessible also through the MixingBoard.boards array\nb.postSettings;\n\n// fade to black\nm.levelTo(0, 15);\n\n// and release\n// note that on m.free, the synth 'a' is removed also\n// freeing the last MixerChannel in the MixingBoard closes the window\nm.free;\nr.free;",
    "Figure 591": "Figure 20.3\n// Voicer(voices, things, args, bus, target, addAction)\n// target may be a Group, Server, or MixerChannel\nv = Voicer(10, \\default);\n\nv.trigger(440, 1);  // v.trigger(freq, gate, args, latency)\nv.release(440);\n\n// v.gate(freq, dur, gate, args, lat) -- lat = latency\nv.gate(440, 2.0, 1, [pan: -0.5]);\n\nr = fork {\n\tloop {\n\t\t\t// play over a C major scale\n\t\t[60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|\n\t\t\tv.gate(midi.midicps, 0.1, 1, [amp: rrand(0.05, 0.15)],\n\t\t\t\tlat: 0.1);\n\t\t\t0.125.wait;\n\t\t});\n\t}\n};\n\nr.stop;\n\nv.free;",
    "Figure 592": "Figure 20.4\n// let's put a pan global control on the voicer\n\nv = Voicer(10, \\default);\n\n// v.mapGlobal(name, bus, value, spec)\n// \\bipolar is a ControlSpec for the range -1..+1\nv.mapGlobal(\\pan, nil, 0, \\bipolar);\n\nv.gui;\n\n// Pbind works with voicer, using 'voicerNote' event type\np = Pbind(\n\t\\type, \\voicerNote,\n\t\\voicer, v,\n\t\\degree, Pn(Pseries(0, 1, 8), inf),\n\t\\amp, Pwhite(0.05, 0.15, inf),\n\t\\dur, 0.125,\n\t\\legato, 0.8\n).play;\n\np.stop;\n\nv.free;",
    "Figure 593": "Figure 20.5\nv = Voicer(10, \\default);\n\n// 0 = device 0, channel 0\n// for a different device, use [device index, channel]\nk = VoicerMIDISocket(0, v);\n\n// modwheel to control pan\nk.addControl(1, \\pan, 0, \\bipolar);\nv.gui;\n\n// a homegrown variety of just intonation\n// release all notes before executing this!\nk.midiToFreq = TuningRatios(12, tunings: [1, 135/128, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 14/9, 27/16, 16/9, 15/8]);\n\n// per-note argument generation using a Pbind\n// here used to map velocity data onto the amp input\nk.noteOnArgsPat = Pbind(\\amp, Pkey(\\velocity).linlin(0, 127, 0.01, 0.2));\n\n// if you have a footswitch (controller number 64), this handles it properly\nl = VoicerSusPedal(0, 64, v);\n\n// by default, freeing the voicer automatically frees the socket and all attached MIDI controllers\nv.free;",
    "Figure 594": "Figure 20.6\n// \"Hello World\" greeter classes\n\n(\n~greeter = Proto({\n\t~sayhi = { |name|\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n});\n\n// make a subclass with .clone\n~frenchGreeter = ~greeter.clone({\n\t~greeting = \"Bonjour\";\n});\n\n~timeAwareFrenchGreeter = ~frenchGreeter.clone({\n\t~greeting = {\n\t\tvar\thour = Date.getDate.hour;\n\t\tif(hour < 18) { ~dayGreeting } { ~eveningGreeting };\n\t};\n\t~dayGreeting = \"Bonjour\";\n\t~eveningGreeting = \"Bon soir\";\n});\n)\n\n// Use the objects:\n~greeter.sayhi;\n~greeter.sayhi(\"Bob\");\n~frenchGreeter.sayhi(\"Isabelle\");\n~timeAwareFrenchGreeter.sayhi(\"Eric\");",
    "Figure 595": "Figure 20.7\n(\n\t// define PR prototype - Proto(...) => PR(\\name)\nProto({\n\t~sayhi = { |name|\n\t\t\t// ~greeting.value is an internal pseudomethod call\n\t\t\"%, %.\\n\".postf(~greeting.value, name ? ~name);\n\t};\n\t~name = \"Monique\";\t\t// default name\n\t~greeting = \"Hello\";\t\t// default greeting\n}) => PR(\\greeter);\n)\n\n// make working instance as BP\nPR(\\greeter) => BP(\\greeter);\nBP(\\greeter).sayhi(\"Jacqueline\");\nBP(\\greeter).name = \"Zsa Zsa\";\nBP(\\greeter).sayhi;\n\t// changing name in BP does not affect PR\nPR(\\greeter).name;\n\n// override default at chuck time\n// now this greeter belongs just to Bob\nPR(\\greeter).chuck(BP(\\greetBob), parms: (name: \"Bob\"));\nBP(\\greetBob).name;\t// ~name variable is overridden\nBP(\\greetBob).sayhi;\n\n// remove both instances from the repository\nBP([\\greeter, \\greetBob]).free;",
    "Figure 596": "Figure 20.9\n(\nSynthDef(\\bufGrainPan, { |start, time, bufnum, pan, rate = 1, amp = 1,\n\t\tattack = 0.001, decay = 0.02, outbus|\n\tvar sig;\n\tsig = PlayBuf.ar(1, bufnum, rate * BufRateScale.kr(bufnum), 1, start, 0)\n\t\t* EnvGen.kr(Env.linen(attack, time, decay), doneAction:2);\n\tOut.ar(outbus, Pan2.ar(sig, pan, amp));\n}).add;\n\nPR(\\abstractProcess).clone({\n\t\t// BEHAVIORAL components\n\t\t// eventKey refers to ProtoEvent(\\singleSynthPlayer)\n\t~event = (eventKey: \\singleSynthPlayer);\n\t\t// here, manufacture the pattern to play\n\t~asPattern = {\n\t\tPbind(\n\t\t\t\\chan, ~chan,\n\t\t\t\\instrument, \\bufGrainPan,\n\t\t\t\\bufnum, ~buf.bufnum,\n\t\t\t\\delta, BPStream(\\delta),\t// reference to ~delta stream\n\t\t\t\\time, BPStream(\\tfactor) * Pkey(\\delta),\n\t\t\t\\start, BPStream(\\startSec) * ~buf.sampleRate,\n\t\t\t\\pan, BPStream(\\pan),\n\t\t\t\\amp, BPStream(\\amp)\n\t\t)\n\t};\n\t\t// default Pbind streams\n\t~delta = Pwhite(1, 5, inf) * 0.1;\n\t~tfactor = 1;\n\t~maxStart = Pfunc({ ~buf.duration }) - Pkey(\\time);\n\t~startSec = Pwhite(0.0, BPStream(\\maxStart), inf);\n\t~pan = Pwhite(-1.0, 1.0, inf);\n\t~amp = 1;\n\n\t\t// ARCHITECTURAL components\n\t~path = \"sounds/a11wlk01.wav\";\t// default soundfile\n\t~startFrame = 0;\n\t~numFrames = -1;\n\t\t// constructor: auto-load soundfile and create mixer\n\t~prep = {\n\t\t~chan = MixerChannel(~collIndex, s, 2, 2);\n\t\t\"loading %\\n\".postf(~path);\n\t\t~buf = Buffer.read(s, ~path, ~startFrame, ~numFrames,\n\t\t\taction: { \"done loading buffer\".postln });\n\t};\n\t\t// destructor, called on .free\n\t~freeCleanup = {\n\t\t[~chan, ~buf].free;\n\t};\n}) => PR(\\bufSlicer);\n)\n\n// That was the definition. In performance you only need this to play it.\n\nPR(\\bufSlicer) => BP(\\columbia);\nBP(\\columbia).play;\n\n// change process\u00e2\u0080\u0099s stream references while it is playing\n\nBP(\\columbia).tfactor = 0.25;\n\nBP(\\columbia).tfactor = sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55;\n\nBP(\\columbia).delta = Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf));\n\nBP(\\columbia).startSec = Pclutch(Pwhite(0.0, BPStream(\\maxStart), inf), Pdiff(Pkey(\\delta)).abs > 0);\n\n\n// also valid to chuck patterns into a BP\n// \".pan\" is an adverb indicating which variable to replace\nsin(Ptime(inf)) =>.pan BP(\\columbia);\n\nBP(\\columbia).stop;\nBP(\\columbia).free;\t// MixerChannel and Buffer go away also",
    "Figure 597": "Figure 20.10\n// In the definition file:\n(\n(make: { |name|\n\tPR(\\bufSlicer) => BP(name);\n}, type: \\bp) => Fact(\\basic);\n\n(make: { |name|\n\tPR(\\bufSlicer).chuck(BP(name), parms: (\n\t\tpath: \"sounds/a11wlk01-44_1.aiff\",\n\t\ttfactor: sin(Pseries(0, 0.1, inf)) * 0.45 + 0.55,\n\t\tdelta: Pstutter(Pwhite(4, 12, inf), Pxrand((1..6) * 0.05, inf)),\n\t\tstartSec: Pclutch(Pwhite(0.0, Pfunc({ ~buf.duration }) - Pkey(\\time)), Pdiff(Pkey(\\delta)).abs > 0),\n\t\tpan: sin(Ptime(inf)),\n\t\tquant: 1\t// quantize to next beat\n\t))\n}, type: \\bp) => Fact(\\fancy);\n)\n\n// In the performance script:\nFact(\\basic) => BP(\\basic);\n\nBP(\\basic).play;\n\nFact(\\fancy) => BP(\\fancy);\n\nBP(\\fancy).play;\n\nBP([\\basic, \\fancy]).stop;\n\nBP([\\basic, \\fancy]).free;",
    "Figure 598": "Figure 2. A Synth Definition with the first 16 harmonics\n(\nSynthDef(\\simpleSynth, {|freq, amp|\n\tvar signal, harmonics;\n\tharmonics = 16;\n\tsignal = Mix.fill(harmonics, {|i| \n\t\t\t\tSinOsc.ar(freq*(i+1), 1.0.rand, amp * harmonics.reciprocal/(i+1)) \n\t\t\t});\n\tOut.ar(0, signal ! 2);\n}, [0.15, 0.15]).add// lag times so the slider \"sounds\" better\n)\n\n// A line of code testing the synth definition that we created\nSynth(\\simpleSynth, [\\freq, 440, \\amp, 1])",
    "Figure 599": "Figure 3. A GUI to control the frequency and amplitude of our synth\n(\nvar synth, win;\n// we initialize the synth\nsynth = Synth(\\simpleSynth, [\\freq, 100, \\amp, 0]);\n// specify the GUI window\nwin = Window(\"simpleSynth\", Rect(100,100, 230, 90), false);\n// and place the frequency and amplitude sliders in the window\nStaticText(win, Rect(10,10, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"freq\");\nSlider(win, Rect(40,10, 160, 24))\n\t.action_({|sl| synth.set(\\freq, [100, 2000, \\exp].asSpec.map(sl.value)) });\nStaticText(win, Rect(10,46, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"amp\");\nSlider(win, Rect(40,46, 160, 24))\n\t.action_({|sl| synth.set(\\amp, [0, 1.0, \\amp].asSpec.map(sl.value)) });\nwin.onClose_({ synth.free }).front; // we add a \"onClose\" message to the window and \"front\" it.\n)",
    "Figure 600": "Figure 5. A GUI with vertical sliders controlling the frequency and amplitude\n(\nvar synth, win;\nsynth = Synth(\\simpleSynth, [\\freq, 100, \\amp, 0]);\nwin = Window(\"\", Rect(100, 100, 94, 200), false);\nStaticText(win, Rect(20, 170, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"freq\");\nSlider(win, Rect(10, 10, 30, 160))\n\t.action_({|sl| synth.set(\\freq, [100, 2000, \\exp].asSpec.map(sl.value)) });\nStaticText(win, Rect(60, 170, 160, 20)).font_(Font(\"Helvetica\", 9)).string_(\"amp\");\nSlider(win, Rect(50, 10, 30, 160))\n\t.action_({|sl| synth.set(\\amp, [0, 1.0, \\amp].asSpec.map(sl.value)) });\nwin.onClose_({ synth.free }).front; // we add a \"onClose\" message to the window and \"front\" it.\n)",
    "Figure 601": "Figure 7. Irritia. A stochastic patch playing with the envelope view. The mouse can be used to interact with the patch\n(\nvar nNodes, envView, startStop, myWait, timeSlider, mouseTracker;\nvar xLoc, yLoc, mousedown = false;\nvar randLoc = 0.12.rand;\n\nSynthDef(\\irritia, { arg out=0, gate=1, freq=440, pan=0.0; \n\tOut.ar(out, Pan2.ar(LFSaw.ar(freq,0.4,0.05) * EnvGen.kr(Env.sine, gate, doneAction:2), pan))\n}).add;\n\nnNodes = 10;\nmyWait = 0.033;\n\nw = Window(\"irritia\", Rect(200 , 450, 400, 400)).front;\n\nenvView = EnvelopeView(w, Rect(20, 20, 355, 300))\n\t\t\t.thumbHeight_(6.0)\n\t\t\t.thumbWidth_(6.0)\n\t\t\t.fillColor_(Color.grey)\n\t\t\t.background_(Color.white)\n\t\t\t.drawLines_(true)\n\t\t\t.selectionColor_(Color.red)\n\t\t\t.drawRects_(true)\n\t\t\t.resize_(5) // can be resized and stretched\n\t\t\t.value_([{1.0.rand}!nNodes, {1.0.rand}!nNodes]);\n\t\t\t\n// connect all the nodes in the envelope view to each other\nnNodes.do({arg i; envView.connect(i, {|j|j}!nNodes); });\n\n// create a little interaction where mouseactions affect the activity\nUserView(w, Rect(20, 20, 355, 300))\n\t.mouseDownAction_({|view, x, y| mousedown = true; xLoc = x/355; yLoc = (-1+(y/300)).abs; })\n\t.mouseMoveAction_({|view, x, y| xLoc = x/355; yLoc = (-1+(y/300)).abs; })\n\t.mouseUpAction_({mousedown = false});\n\nr = Routine({\n\tinf.do({ |i|\n\t\tenvView.select(envView.size.rand);\n\t\tif(mousedown.not, {\n\t\t\t0.05.coin.if({\n\t\t\t\t0.5.coin.if({\n\t\t\t\t\tmyWait = rrand(0.028, 0.042);\n\t\t\t\t\txLoc = 1.0.rand; \n\t\t\t\t\tyLoc = 1.0.rand;\n\t\t\t\t}); \n\t\t\t\trandLoc = 0.12.rand2; \n\t\t\t});\n\t\t\txLoc = envView.x+rand2(randLoc); \n\t\t\tyLoc = envView.y+rand2(randLoc);\n\t\t}, {\n\t\t\txLoc = (xLoc + envView.x+rand2(0.1.rand))/2;\n\t\t\tyLoc = (yLoc + envView.y+rand2(0.1.rand))/2;\n\t\t});\n\t\tenvView.x_(xLoc);\n\t\tenvView.y_(yLoc);\n\t\tSynth(\\irritia, [\\freq, (yLoc*200)+50, \\pan, (xLoc*2)-1]);\n\t\tmyWait.wait;\n\t});\n}).play(AppClock);\n\nw.onClose_({ r.stop });\n\n)",
    "Figure 602": "Figure 12. A sketch of snow triggering a bell sound on landing\n(\nSynthDef(\\snowBell, { | freq=440, amp=0.4, pan=0 |\n\tvar x, env;\n\tenv = EnvGen.kr(Env.perc(0.001, Rand(550,650)/freq, amp), doneAction:2);\n\tx = Mix.fill(6, {SinOsc.ar(freq*Rand(-10,10), 0, Rand(0.1,0.2))});\n\tx = Pan2.ar(x, pan, env);\n\tOut.ar(0, x);\n}).add;\n)\n\n(\nvar win, msl, trigAction, snowloc, speeds, speed, layers=4, snowcount = 62;\n\n// fill an array with arrays (number of layers) of locations\nsnowloc = {{rrand(0.38,1.5)} ! snowcount} ! layers;\n// fill an array with arrays (number of layers) of step size (speed)\nspeeds = {{rrand(0.01,0.018)} ! snowcount} ! layers;\n\nspeed = 0.1;\n\nwin = Window(\"snow\", Rect(11, 311, 520, 240), border: false).front;\nwin.view.background = Color(0.14,0.17,0.24);\n\nmsl = Array.fill(layers, {|i|\n\t\tMultiSliderView(win, Rect(-1, -1, 522, 242))\n\t\t\t.strokeColor_( Color.new255(rrand(22,35),rrand(22,35),rrand(22,35)) )\n\t\t\t.fillColor_( Color.new255(rrand(222,255),rrand(222,255),rrand(222,255)) )\n\t\t\t.valueThumbSize_(rrand(2.8,3.8))\n\t\t\t.indexThumbSize_(rrand(2.8,3.8))\n\t\t\t.gap_(5)\n\t});\n\n// when the snow falls this happens. (pitch is mapped to index and amplitude to speed)\ntrigAction = {arg drop, amp; Synth(\\snowBell, [\\freq, 400+(drop*20), \\amp, amp, \\pan, rrand(-0.8, 0.8)])};\n\nt = Task({\n\tloop({\n\t\tsnowloc = snowloc.collect({|array, i| \n\t\t\tarray = array.collect({|val, j| \n\t\t\t\tval = val-speeds[i][j]; \n\t\t\t\tif(val< 0.0, {val = 1.0; trigAction.(j, speeds[i][j]*10 )});\n\t\t\t\tval\n\t\t\t});\n\t\t\tarray\n\t\t});\n\t\t/* \n\t\tTask uses the TempoClock by default so we need to \"defer\" the GUI updating \n\t\t(Function:defer uses AppClock) This means that the Task is essentially using \n\t\tthe SystemClock and therefore the timing is better on the sound front. \n\t\tThe AppClock (used for GUI updates) has worse timing.\n\t\t*/\n\t\t{ layers.do({|i| msl[i].value_(snowloc[i]) }) }.defer;\n\t\tspeed.wait;\n\t});\n}).start;\n\n// on stopping the program (Command/Ctrl + dot) the task will stop and the window close\nCmdPeriod.add({ t.stop; win.close; });\n)",
    "Figure 603": "Figure 23.2\n (\n{\tvar f = { | a, b | [a.min(1 - b), b.min(1 - a)] };\n\tvar freq = f.value(MouseX.kr, MouseY.kr) * 400 + 500;\n\tSinOsc.ar(freq) * 0.1\n}.play;\n)\n\n\n(\na = { |freq=100, width=0.5|\n\tvar df, dw;\n\tdf = freq - LastValue.kr(freq);\n\tdw = width - LastValue.kr(width);\n\tfreq = freq + (dw * 100);\n\twidth = width + (df / 100);\n\tPulse.ar(freq, width.clip(0.01, 0.99).poll) * 0.1\n}.play;\n)\n\na.set(\\freq, exprand(200.0, 600.0));\na.set(\\width, 1.0.rand);",
    "Figure 604": "Figure 23.4\n\n// modulating the frequency input to a Pokey UGen results in great variance\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate + mod, audc1: 2r01000000 + amp);\n}.play\n);\n\n// modulating the pure tone bit\n(\n{ \n\tvar rate = MouseX.kr(0, 255);\n\tvar mod = LFPulse.kr(1);\n\tvar amp = 2r1100; // 12 of 16\n\tPokey.ar(rate, audc1: 2r00100000 + (mod * 2r00100000) + amp);\n}.play\n);",
    "Figure 605": "Figure 23.5 \n(\nSynthDef(\\FreqMod, { |car=440, carFine=1, mod=100, modFine=1, index=4, amp=0.3, pan=0| \n\tOut.ar(0, Pan2.ar(PMOsc.ar(car * carFine, mod * modFine, index), pan, amp)); \n}).add; \t\t\n\nc = Controller.new(s, 256);\nc.makeInterface(2, 3, 0, \"Freq Mod controller\");\n\nc[0].setup(\"carFreq\", [50, 4800, \\exp].asSpec, 440);\nc[1].setup(\"carFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\nc[2].setup(\"modFreq\", [10, 4800, \\exp].asSpec, 10);\nc[3].setup(\"modFreqFine\", [0.95, 1.05, \\exp].asSpec, 1);\nc[4].setup(\"mIndex\", [0, 24, \\lin].asSpec, 1);\nc[5].setup(\"amp\", [0, 1, \\lin].asSpec, 0.2);\n);\n\na = Synth(\\FreqMod) // start the synth\n6.do({|i| a.map(i, c[i].index)}); // map the synth control to the controller.\na.free // when finished",
    "Figure 606": "Figure 23.7 \n(\nSynthDef(\\ping, {\n\targ out = 0, mfreq = 69, pan = 0, gain = 0.2, dur = 0.25;\n\tOut.ar(out, Pan2.ar(\n\tSinOsc.ar(mfreq.midicps, 0, \n\tEnvGen.kr(envelope: (Env.perc(0.01, dur)), doneAction: 2)),\n\tpan, gain));\n}).add;\n\n// function to play a synth\nm = {|f, d=0.3, g=0.2, p=0| Synth(\\ping, [\\mfreq, f + 45, \\pan, p, \\gain, g, \\dur, d])};\n\n// function to make a chord\nc = {|a, b, c| [a, b, c].do{|i| m.value(i, 1.2, 0.075, rrand(-1.0, 1.0))}};\n\nt = TempoClock.default.tempo_(116 / 60); // assign clock to t\nb = HierSch.new(t); // start new HierSch, pass in clock\n)\n\n(\n// HierSch schedules\nb.schedAbs(t.beats.ceil + 48, 1, { var offset = [0, 5, 7, 12]; c.value(*[12, 16, 19]+ offset.choose)}, Prand(#[1.5, 3], 30)); // enters last, priority highest\n\nb.schedAbs(t.beats.ceil + 14, 2, {|b, p, d, c| m.value([0, 0, 7, 5, 4].at(c % 5) + [12, 24].choose, 0.4, 0.15, rrand(-1.0, 1.0))}, Pseq(#[2, 2, 2, 1], 15)); // enters middle, priority middle\n\nb.schedAbs(t.beats.ceil, 3, { |b, p, d, c| m.value(VagueList[0, 12, 4, 7, 10, 10, 9, 9, 7].at(c % 9))}, Pseq(#[0.5, 0.5, 0.5, 0.5, 0.25, 0.75, 1, 0.5, 0.5], 17)); // enters first, priority lowest\n)",
    "Figure 607": "Figure 23.8\n\np = LazyEnvir.push;\n~a = ~b * ~c;\n~a.value; \t// => nil\n~b = Pseq([1, 2, 3]).asStream;\n~c = 10;\n~a.value; \t// => 10\n~a.value; \t// => 20\n~b = [1, 2, 3];\n~a.value; \t// => [10, 20, 30];\n~a.postcs;\t// => Maybe((Maybe([ 1, 2, 3 ]) * Maybe(10)))\np.pop",
    "Figure 608": "Figure 23.9\n\n(\nvar x;\nx = { |rates=#[1, 1]| Ringz.ar(Impulse.ar(rates) * 0.1, rates * 80, 1 / rates) }.play;\nfork {\n\tvar str = {:[x, y], \n\t\tx<-(40..2), \n\t\ty<-(x + 1..40),\n\t\tgcd(x, y) == 1,\n\t\tx.isPrime.not and: y.isPrime.not\n\t};\n\t0.5.wait;\n\tstr.do { |primes|\n\t\tx.setn(\\rates, primes.postln);\n\t\t(primes.product / primes.sum / 20).wait;\n\t}\n};\n)",
    "Figure 609": "Figure 23.10\n\n(\nvar dict, maxLength = 0;\ndict = (\n\tab: { (note: [4, 0, 7], legato: 0.1, dur: 1) },\n\tba: { (note: [4, 9, 8], legato: 0.3, dur: 0.3) },\n\taaa: { (note: 5, legato:1.5) },\n\tbbb: { (note: 0, legato:2.5, dur: 0.25) }\n);\n\ndict.keys.do { |key| maxLength = max(maxLength, key.asString.size) };\n\nf = { |str|\n\tvar i = 0, n = 0, substr, event;\n\twhile { i < str.size } {\n\t\tsubstr = str[i..i + n];\n\t\tevent = dict[substr.asSymbol].value;\n\t\tif(event.notNil) {\n\t\t\tsubstr.postln;\n\t\t\ti = i + n + 1;\n\t\t\tn = 0;\n\t\t\tevent.postln.play;\n\t\t\tevent.delta.wait;\n\t\t} {\n\t\t\tif(n + 1 < maxLength) { n = n + 1 } { n = n - 1; i = i + 1 }\n\t\t};\n\t};\n};\n)\n\n// play some sequences\nfork { f.value(\"abbbbaab\"); }\nfork { f.value(\"aaabbbabbaaaabbabaaaaba\"); };",
    "Figure 610": "Figure 24.2\nunion PyrSlot\n{\n\tdouble f;\t\t\t\t\t// double\n\tstruct {\n\t\tint tag;\n\t\tunion {\n\t\t\tint\t\tc;\t\t// character\n\t\t\tint\t\ti;\t\t// integer\n\t\t\tvoid\t\t*ptr;\t// raw pointer\n\t\t\tPyrObject\t*o;\t\t// object pointer\n\t\t\tPyrSymbol\t*s;\t\t// symbol pointer\n\t\t\t...\t\t\t\t// other object pointers\n\t\t} u;\n\t} s;\n};",
    "Figure 611": "Figure 24.4\t\nPyrObjectHdr\n{\n\t// garbage collector links\n\tPyrObjectHdr\t*prev;\n\tPyrObjectHdr\t*next;\n\t// class pointer\n\tPyrClass\t*classptr;\n\t// object size\n\tint\t\tsize;\t\t\t\n\n\t// indexable object format\n\tunsigned char obj_format;\n\t// object size class (power of two)\n\tunsigned char obj_sizeclass;\n\t// object flags\n\tunsigned char obj_flags;\n\t// garbage collector color\n\tunsigned char gc_color;\n\t...\n};",
    "Figure 612": "Figure 24.6\nPyrSymbol\n{\n\t// symbol name\n\tchar\t*name;\n\t// hash value\n\tlong\thash;\n\t// special selector index\n\tshort\tspecialIndex;\n\t// symbol flags\n\tuint8\tflags;\n\t// length of symbol name\n\tuint8\tlength;\n\tunion {\n\t\t// index in method table or primitive table\n\t\tlong index;\n\t\t// pointer to class with this name\n\t\tstruct PyrClass *classobj; name.\n\t\t....\n\t} u;\n\t// class dependancy (used during compilation)\n\tClassDependancy *classdep;\t\n};",
    "Figure 613": "Figure 24.7\n\nVMGlobals\n{\n\t// global context\n\n\tAllocPool\t*allocPool;\n\t// main thread context\n\tPyrProcess\t*process;\n\t// global symbol table\n\tSymbolTable\t*symbolTable;\n\t// garbage collector for this process\n\tPyrGC\t\t*gc;\n\t// class variable array\n\tPyrObject\t*classvars;\n\n\t// next byte code is a tail call\n\tint\t\ttailCall;\n\n\t// true when in 'main' thread\n\tbool\t\tcanCallOS;\n\n\t// thread context\n\t\n\tPyrThread\t*thread;\n\tPyrMethod\t*method;\n\tPyrBlock\t*block;\n\tPyrFrame\t*frame;\n\tPyrMethod\t*primitiveMethod;\n\n\t// current instruction pointer\n\tunsigned char\t*ip;\n\t// current stack pointer\n\tPyrSlot\t\t*sp;\n\n\t// argument pointer for primitive\n\tPyrSlot\t\t*args;\n\t// current receiver\n\tPyrSlot\t\treceiver;\n\t// interpretation result\n\tPyrSlot\t\tresult;\n\t// number of args to pop for primitive\n\tint\t\tnumpop;\n\t// current index into primitive table\n\tlong\t\tprimitiveIndex;\n\t// random number generator state\n\tRGen\t\t*rgen;\n\t// handler for unwinding C stack\n\tjmp_buf\t\tescapeInterpreter;\n\n\t// scratch context\n\tlong\t\texecMethod;\n};",
    "Figure 614": "Figure 24.8\n\nClassDependancy\n{\n\t// next link in list\n\tClassDependancy\t*next;\n\t// superclass dependency\n\tClassDependancy\t*superClassDep;\n\t// subclass list (linked via 'next')\n\tClassDependancy\t*subclasses;\n\t// class name symbol\n\tPyrSymbol\t\t*className;\n\t// superclass name symbol\n\tPyrSymbol\t\t*superClassName;\n\t// file name symbol\n\tPyrSymbol\t\t*fileSym;\n\t// start character position of definition\n\tint\t\t\tstartPos;\n\t// end character position of definition\n\tint\t\t\tendPos;\n\t// line number of definition\n\tint\t\t\tlineOffset;\n};",
    "Figure 615": "Figure 24.9\n\nPyrBlock : PyrObjectHdr\n{\n\t// pointer to PyrMethodRaw\n\tPyrSlot rawData1;\t\t\t\n\t// byte codes, nil if inlined\n\tPyrSlot code;\n\t// method selectors, class names, closures table\n\tPyrSlot selectors;\n\t// literal constants table\n\tPyrSlot constants;\n\t// temporary variable default values\n\tPyrSlot prototypeFrame;\n\t// defining block context\n\t// (nil for methods and toplevel)\n\tPyrSlot contextDef;\n\t// arguments to block\n\tPyrSlot argNames;\n\t// variables in block\n\tPyrSlot varNames;\n\t// source code (for closed functions)\n\tPyrSlot sourceCode;\n};",
    "Figure 616": "Figure 24.10\nPyrMethodRaw\n{\n\t// special method index\n\tunsigned specialIndex;\n\t// method type\n\tunsigned methType;\n\t// prototype frame size\n\tunsigned frameSize;\n\n\t// number of arguments\n\tunsigned numargs;\n\t// 1 if has variable number of arguments\n\tunsigned varargs;\n\t// number of keyword and variable defaults\n\tunsigned numvars;\n\t// number of temporary (local) variables\n\tunsigned numtemps;\n\t// true when frame needs to be heap-allocated\n\tunsigned needsHeapContext;\n\t// numargs + varargs\n\tunsigned posargs;\n};",
    "Figure 617": "Figure 24.11\n\nPyrMethod : PyrBlock\n{\n\tPyrSlot ownerclass;\n\tPyrSlot name;\n\tPyrSlot primitiveName;\n\tPyrSlot filenameSym;\n\tPyrSlot charPos;\n};",
    "Figure 618": "Figure 24.13\n\nPyrFrame : PyrObjectHdr\n{\n\t// defining method\n\tPyrSlot method;\n\t// calling context\n\tPyrSlot caller;\n\t// closure context\n\tPyrSlot context;\n\t// method context\n\tPyrSlot homeContext;\n\t// instruction pointer\n\tPyrSlot ip;\n\t// temporary variable storage\n\tPyrSlot vars[1];\n};",
    "Figure 619": "Figure 24.16\n#include <math.h>\n#include \"GC.h\"\n#include \"PyrKernel.h\"\n#include \"PyrPrimitive.h\"\n\n// Primitive implementation of atan2,\n// calling the function from libm.\nstatic int prAtan2(struct VMGlobals *g, int numArgsPushed)\n{\n\t// Pointer to arguments\n\tPyrSlot *args = g->sp - numArgsPushed + 1;\n\t// Pointer to receiver (self)\n\tPyrSlot* self = args + 0;\n\t// Pointer to argument\n\tPyrSlot* arg  = args + 1;\n\n\tdouble x, y;\n\tint err;\n\t\n\t// Get receiver value\nerr = slotDoubleVal(self, &x);\n// Signal error for invalid input type\n\tif (err != errNone) return err;\n\t\n\t// Get argument value\n\terr = slotDoubleVal(arg, &y);\n// Signal error for invalid input type\n\tif (err != errNone) return err;\n\t\n\t// Compute result\ndouble result = atan2(x, y);\n\n\t// Set top of stack to return value\n\tSetFloat(self, result);\n\t\n\t// Signal success\n\treturn errNone;\n}\n\n// Call this function during initialization,\n// e.g. from initPrimitives() in PyrPrimitive.cpp\nvoid initMyPrimitives()\n{\n\t// Initialize primitive indices\n\tint base = nextPrimitiveIndex(), index = 0;\n\n\t// Define primitive with two arguments (self, operand)\n\tdefinePrimitive(base, index++, \"_MyFloatAtan2\", prAtan2, 2, 0);\n\t// ... define more primitives here ...\n}",
    "Figure 620": "Figure 25.1\n#include \"SC_PlugIn.h\"\n\t\t\t\nstatic InterfaceTable *ft;\n\n// the struct will hold data which we want to \"pass\" from one function to another\n// e.g. from the constructor to the calc func, \n// or from one call of the calc func to the next\nstruct Flanger : public Unit  {\n\tfloat rate, delaysize, fwdhop, readpos;\n\tint writepos;\n};\n\n// function declarations, exposed to C\nextern \"C\" {  \n\tvoid load(InterfaceTable *inTable);\n\tvoid Flanger_Ctor(Flanger *unit);\n\tvoid Flanger_next(Flanger *unit, int inNumSamples);\n}\n\n\nvoid Flanger_Ctor( Flanger *unit ) {\n\t\n\t// Here we must initialise state variables in the Flanger struct.\n\tunit->delaysize = SAMPLERATE * 0.02f; // Fixed 20ms max delay\n\t// Typically with reference to control-rate/scalar-rate inputs.\n\tfloat rate  = IN0(1);\n\t// Rather than using rate directly, we're going to calculate the size of \n\t// jumps we must make each time to scan through the delayline at \"rate\"\n\tfloat delta = (unit->delaysize * rate) / SAMPLERATE;\n\tunit->fwdhop = delta + 1.0f;\n\tunit->rate  = rate;\n\t\n\t// IMPORTANT: This tells scsynth the name of the calculation function\n\t// for this UGen.\n\tSETCALC(Flanger_next);\n\t\n\t// Should also calc 1 sample's worth of output \u00e2\u0080\u0093 \n\t//ensures each ugen's \"pipes\" are \"primed\"\n\tFlanger_next(unit, 1);\n}\n\nvoid Flanger_next( Flanger *unit, int inNumSamples ) {\n\t\n\tfloat *in = IN(0);\n\tfloat *out = OUT(0);\n\t\n\tfloat depth = IN0(2);\n\t\n\tfloat rate    = unit->rate;\n\tfloat fwdhop  = unit->fwdhop;\n\tfloat readpos = unit->readpos;\n\tint writepos  = unit->writepos;\n\tint delaysize = unit->delaysize;\n\n\tfloat val, delayed;\n\t\n\tfor ( int i=0; i<inNumSamples; ++i) {\n\t\tval = in[i];\n\t\t\n\t\t// Do something to the signal before outputting\n\t\t// (not yet done)\n\t\t\n\t\tout[i] = val;\n\t}\n\t\n\tunit->writepos = writepos;\n\tunit->readpos = readpos;\n}\t\n\n\nvoid load(InterfaceTable *inTable) {\n\t\n\tft = inTable;\n\t\n\tDefineSimpleUnit(Flanger);\n}",
    "Figure 621": "Figure 25.2\n#include \"SC_PlugIn.h\"\n\nstatic InterfaceTable *ft;\n\n// the struct will hold data which we want to \"pass\" from one function to another\n// e.g. from the constructor to the calc func, \n// or from one call of the calc func to the next\nstruct Flanger : public Unit  {\n\tfloat rate, delaysize, fwdhop, readpos;\n\tint writepos;\n\t\n\t// a pointer to the memory we'll use for our internal delay\n\tfloat *delayline;\n};\n\n// function declarations, exposed to C\nextern \"C\" {  \n\tvoid load(InterfaceTable *inTable);\n\tvoid Flanger_Ctor(Flanger *unit);\n\tvoid Flanger_next(Flanger *unit, int inNumSamples);\n\tvoid Flanger_Dtor(Flanger *unit);\n}\n\n\nvoid Flanger_Ctor( Flanger *unit ) {\n\t\n\t// Here we must initialise state variables in the Flanger struct.\n\tunit->delaysize = SAMPLERATE * 0.02f; // Fixed 20ms max delay\n\t// Typically with reference to control-rate/scalar-rate inputs.\n\tfloat rate  = IN0(1);\n\t// Rather than using rate directly, we're going to calculate the size of \n\t// jumps we must make each time to scan through the delayline at \"rate\"\n\tfloat delta = (unit->delaysize * rate) / SAMPLERATE;\n\tunit->fwdhop = delta + 1.0f;\n\tunit->rate = rate;\n\tunit->writepos = 0;\n\tunit->readpos = 0;\n\t\n\t// Allocate the delay line\n\tunit->delayline = (float*)RTAlloc(unit->mWorld, unit->delaysize * sizeof(float));\n\t// Initialise it to zeroes\n\tmemset(unit->delayline, 0, unit->delaysize * sizeof(float));\n\t\n\t// IMPORTANT: This tells scsynth the name of the calculation function \n\t//for this UGen.\n\tSETCALC(Flanger_next);\n\t\n\t// Should also calc 1 sample's worth of output \u00e2\u0080\u0093 \n\t//ensures each ugen's \"pipes\" are \"primed\"\n\tFlanger_next(unit, 1);\n}\n\nvoid Flanger_next( Flanger *unit, int inNumSamples ) {\n\t\n\tfloat *in = IN(0);\n\tfloat *out = OUT(0);\n\t\n\tfloat depth = IN0(2);\n\t\n\tfloat rate    = unit->rate;\n\tfloat fwdhop  = unit->fwdhop;\n\tfloat readpos = unit->readpos;\n\tfloat *delayline = unit->delayline;\n\tint writepos  = unit->writepos;\n\tint delaysize = unit->delaysize;\n\n\tfloat val, delayed, currate;\n\t\n\tcurrate = IN0(1);\n\t\n\tif(rate != currate){\n\t\t// rate input needs updating\n\t\trate = currate;\n\t\tfwdhop = ((delaysize * rate * 2) / SAMPLERATE) + 1.0f;\n\t}\n\t\n\tfor ( int i=0; i<inNumSamples; ++i) {\n\t\tval = in[i];\n\t\t\n\t\t// Write to the delay line\n\t\tdelayline[writepos++] = val;\n\t\tif(writepos==delaysize)\n\t\t\twritepos = 0;\n\t\t\n\t\t// Read from the delay line\n\t\tdelayed = delayline[(int)readpos];\n\t\treadpos += fwdhop;\n\t\t// Update position, NB we may be moving forwards or backwards \n\t\t//(depending on input)\n\t\twhile((int)readpos >= delaysize)\n\t\t\treadpos -= delaysize;\n\t\twhile((int)readpos < 0)\n\t\t\treadpos += delaysize;\n\t\t\n\t\t// Mix dry and wet together, and output them\n\t\tout[i] = val + (delayed * depth);\n\t}\n\t\n\tunit->rate = rate;\n\tunit->fwdhop = fwdhop;\n\tunit->writepos = writepos;\n\tunit->readpos = readpos;\n}\t\n\nvoid Flanger_Dtor( Flanger *unit ) {\n\tRTFree(unit->mWorld, unit->delayline);\n}\t\n\nvoid load(InterfaceTable *inTable) {\n\t\n\tft = inTable;\n\t\n\tDefineDtorUnit(Flanger);\n}"
}