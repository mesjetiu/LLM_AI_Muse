title:: Adverbs for Binary Operators
summary:: modify behaviour of binary operators
categories:: Language, Collections
related:: Classes/SequenceableCollection, Classes/Stream

Adverbs are a third argument passed to binary operators that modifies how they iterate over link::Classes/SequenceableCollection::s or link::Classes/Stream::s. The idea for adverbs is taken from the J programming language which is a successor of APL.

section:: Adverbs and SequenceableCollections

Normally when you add two arrays like this:
code::
[10, 20, 30, 40, 50] + [1, 2, 3]
::
You get this result:
code::
[ 11, 22, 33, 41, 52 ]
::
A new array is created which is the length of the longer array and items from each array are added together by wrapped indexing.

Using adverbs can change this behavior. Adverbs are symbols and they follow a '.' (dot) after the binary operator. Adverbs can be applied to all binary operators.

subsection:: adverb 's'

The first adverb is 's' which means 'short'. The add operation now returns the shorter of the two arrays.
code::
[10, 20, 30, 40, 50] +.s [1, 2, 3]
::
returns:
code::
[ 11, 22, 33 ]
::

subsection:: adverb 'f'

Another adverb is 'f' which uses folded indexing instead of wrapped:
code::
[10, 20, 30, 40, 50] +.f [1, 2, 3]
::
returns:
code::
[ 11, 22, 33, 42, 51 ]
::

subsection:: adverb 't'

The table adverb 't' makes an array of arrays where each item in the first array is added to the whole second array and the resulting arrays are collected.
code::
[10, 20, 30, 40, 50] +.t [1, 2, 3]
::
returns:
code::
[ [ 11, 12, 13 ], [ 21, 22, 23 ], [ 31, 32, 33 ], [ 41, 42, 43 ], [ 51, 52, 53 ] ]
::

subsection:: adverb 'x'

The cross adverb 'x' is like table, except that the result is a flat array:
code::
[10, 20, 30, 40, 50] +.x [1, 2, 3]
::
returns:
code::
[ 11, 12, 13, 21, 22, 23, 31, 32, 33, 41, 42, 43, 51, 52, 53 ]
::

section:: Adverbs and Streams

There is currently one adverb defined for streams. This is the cross adverb, 'x'.

Normally when you add two streams like this:
code::
p = (Pseq([10, 20]) + Pseq([1, 2, 3])).asStream;
Array.fill(3, { p.next });
::
you get this:
code::
[ 11, 22, nil ]
::
The items are paired sequentially and the stream ends when the earliest stream ends.

The cross adverb allows you to pair each item in the first stream with every item in the second stream.
code::
p = (Pseq([10, 20]) +.x Pseq([1, 2, 3])).asStream;
Array.fill(7, { p.next });
::
the result is:
code::
[ 11, 12, 13, 21, 22, 23, nil ]
::

You can string these together. Every item in the left stream operand is "ornamented" by the right stream operand.
code::
p = (Pseq([100, 200]) +.x Pseq([10, 20, 30]) +.x Pseq([1, 2, 3, 4])).asStream;
Array.fill(25, { p.next });

[ 111, 112, 113, 114, 121, 122, 123, 124, 131, 132, 133, 134,
  211, 212, 213, 214, 221, 222, 223, 224, 231, 232, 233, 234, nil ]
::

Sound example:
code::
Pbind(\dur, 0.17, \degree, Pwhite(0, 6) +.x Pseq([[0, 2, 4], 1, [0, 2], 3])).trace.play
::



title:: Assignment Statements
categories:: Language
summary:: assigning values to variables

section:: Single Assignment

A single assignment assigns the value of an expression on the right hand side to a variable on the left hand side. A single assignment is in the form:
code::
<variable> = <an expression>
::
examples:
code::
x = [1, 2, 3, 4].rotate(1);
c = a + b;
::

A variable can be assigned a value at any time, including during declaration.

code::
(
// assignment in declaration
var one = 1;
var two = 2;
var four = two + 2;

// reassign
two = two + one;
two = "and now for something completely different"
two = nil;

)
::

In some cases, chains of reassignment are useful:
code::
(
{
	var sig;
	sig = SinOsc.ar(LFNoise0.kr(10).exprange(1, 1000));
	sig = SinOsc.ar(310, sig * 3);
	sig = SinOsc.ar(230, sig * 0.4);
	sig * 0.2
}.play
)
::

section:: Multiple Assignment

A multiple assignment statement assigns the elements of a link::Classes/Collection:: which is the result of an expression on the right hand side, to a list of variables on the left hand side.
A multiple assignment statement is preceded by the symbol code::#::. If the last variable on the left is preceded by three dots, then the entire remainder of the collection is assigned to that variable. There must be at least one variable name before the ellipsis.

The form of a multiple assignment is:
code::
# <list of variables> = <expression>
::
-- or --
code::
# <list of variables> ... <variable> = <expression>
::

examples:
code::
# a, b, c = [1, 2, 3, 4, 5, 6]; // afterwards a=1, b=2, c=3

# a, b ... c = [1, 2, 3, 4, 5, 6]; // afterwards a=1, b=2, c = [3, 4, 5, 6]

# ... a = [1, 2, 3, 4, 5, 6]; // ILLEGAL, just use:    a = [1, 2, 3, 4, 5, 6];
::

Multiple assignment is implemented using the 'at' method and the 'copyToEnd' method.
Your right hand side expression can return any object that responds to these messages.

section:: Instance Variable Assignment

The basic syntax for setting the value of an instance variable is to use the variable's setter method which is the name of the variable with an underscore appended.
code::
point.x_(5); // set point's x coordinate to 5
::
An alternative syntax is to use instance variable assignment.
code::
point.x = 5;
::
This type of assignment is translated to the first form by the compiler. The two syntaxes are equivalent.


section:: Series Assignment to an ArrayedCollection or List

There is a special syntax for doing assignments to a range of values in an link::Classes/ArrayedCollection:: or link::Classes/List::.
code::
a = (0,10..200);
a[5..10] = 1;  // series stepping by 1

a = (0,10..200);
a[7,9..13] = 1; // a series by any step size

a = (0,10..200);
a[..5] = 1;  // from zero to n

a = (0,10..200);
a[12..] = 1;  // from n to the end of the array

a = (0,10..200);
a[1,3..] = 1;  // a series to the end of the array
::



title:: Audio device selection
categories:: Server
summary:: A reference for making audio device selection
related:: Classes/Server, Classes/ServerOptions

This reference provides information on audio device selection, including platform-specific details.

Specific devices can be selected through an instance of link::Classes/ServerOptions::. To access code::ServerOptions:: instance of the default server, you can use code:: Server.default.options::. link::Classes/ServerOptions:: also allows you to specify other important parameters of the device - the sample rate and hardware buffer size.

note::
Device selection won't take effect until the server is (re)booted.
::

section:: macOS

By default the server will boot to your system's default audio devices. If you want to explicitly tell the server to use the internal soundcard, you need to specify both input and output device. The following example comes from a MacBook Pro:
code::
Server.default.options.inDevice_("Built-in Microph");
Server.default.options.outDevice_("Built-in Output");
::

In case of a dedicated audio interface, you might need to specify a single device, e.g.
code::
Server.default.options.device_("MOTU 828");
::

On Windows and macOS you can programmatically obtain a list of available audio devices without booting the server:
code::
ServerOptions.devices; // all devices
ServerOptions.inDevices; // input devices
ServerOptions.outDevices; // output devices
::

subsection:: Sample rate mismatch

One possible reason why a server may fail to boot is a mismatch between input and output devices' sample rates, which may occur when using a different device for input and output (which is the case when using a Mac's internal soundcard). If the server fails to boot due to sample rate mismatch, an error will be posted accordingly.

You should set both input and output devices' sample rate to the same value. You can do this in Audio MIDI Setup:
code::
"open -a 'Audio MIDI Setup'".unixCmd; // execute this to launch it
::

subsection:: Aggregate device

Sometimes you might want to use multiple devices for input or output. macOS provides a way to combine multiple physical devices into a virtual emphasis::Aggregate Device::. To create one, you have to open the Audio MIDI Setup application (in teletype::/Applications/Utilities::). You should do this from an user account with administrator privileges.
code::
"open -a 'Audio MIDI Setup'".unixCmd; // execute this to launch it
::
LIST::
## In the teletype::Audio Devices:: window click on the Plus button on the bottom left and choose teletype::Create Aggregate Device::.
## You can change its name to something specific if desired, for example "InternalAndMOTU".
## Check the teletype::Use:: column on the right for the devices you want to combine.
::
Now you need to tell SuperCollider to use your new aggregate device.
code::
Server.default.options.device = "Aggregate Device"; //or the name you have specified in the previous step
::

After rebooting the server (code::Server.default.reboot::) you should see in the post window that it now uses the Aggregate Device instead of system defaults:
teletype::
[...]
"Aggregate Device" Input Device
[...]
"Aggregate Device" Output Device
::

Note that when you specify a sound device through SuperCollider's code::ServerOptions::, there is no need to use the aggregate device as the system's default device.


section:: Linux

By default, SuperCollider on Linux uses JACK, and the audio device selection is managed by the JACK server. teletype::ServerOptions:: cannot override JACK's selection of audio hardware.

subsection:: Setup with JACK server
The SuperCollider server is considered a JACK emphasis::client::. In the following section, the term emphasis::client:: will refer to the SuperCollider server, from the perspective of JACK.

When the server is compiled to use JACK as the audio backend, the code::ServerOption::'s teletype::device:: can be used in two ways:
to set the client name to register with JACK:
code::
Server.default.options.device = "my_synth";
::
to use a specific JACK server, as well as set the client name:
code::
Server.default.options.device = "JACKServerName:scsynthName";
::
A code::nil:: device is equivalent to code::Server.default.options.device = "default:SuperCollider";::

subsection:: Jack Environment variables

The JACK connections can be configured via the environment variables teletype::SC_JACK_DEFAULT_INPUTS:: and
teletype::SC_JACK_DEFAULT_OUTPUTS::. These allow SuperCollider to detect system preferences for Jack inputs and outputs to/from the scsynth server. 

These variables are written as a string that specifies another jack client or a comma-separated list of jack ports formatted as a string.

If these are not set, SuperCollider will default to connecting SuperCollider's inputs and outputs to your system's inputs and outputs. This is the recommended way of changing the Jack environment variables for SuperCollider from within a SuperCollider script:

code::
// connect first to input channels with system
"SC_JACK_DEFAULT_INPUTS".setenv("system:capture_1,system:capture_2");

// connect all output channels with system
"SC_JACK_DEFAULT_OUTPUTS".setenv("system");
::

As an alternative, these may be also be changed by setting the following environment variables in your STRONG::.bash_profile::, STRONG::.zsh_profile:: or similar startup file for your shell:

code::
export SC_JACK_DEFAULT_INPUTS = "system"
export SC_JACK_DEFAULT_OUTPUTS = "system"
::

section:: Windows

By default the server will boot to your system's default audio devices using teletype::MME:: driver (which usually means higher latency).

On Windows there are multiple audio driver APIs (e.g. teletype::MME::, teletype::WASAPI::, teletype::ASIO:: etc.) that can be used to communicate with audio devices. The API (listed before the device name) needs to match between the input and the output, for example:
code::
o = Server.default.options;
o.inDevice_("Windows WASAPI : Microphone");
o.outDevice_("Windows WASAPI : Speakers");
Server.default.reboot;
::
You can programmatically obtain a list of available audio devices without booting the server:
code::
ServerOptions.devices; // all devices
ServerOptions.inDevices; // input devices
ServerOptions.outDevices; // output devices
::
Partial device name matching is supported in Windows (though not in macOS).

note:: Leaving the code::sampleRate:: (e.g. code::Server.default.options.sampleRate::) as code::nil:: for an code::ASIO:: device will likely result in setting the hardware to run at 44100 Hz.::

subsection:: Choosing the device and the API
list::
##If you need to specify the device, you will need to do so for both input and output (setting both code::.inDevice::, as well as code::.outDevice::), unless you use ASIO
##Both input and output device needs to use the same API (listed before the name, for example teletype::MME::, teletype::WDM-KS:: etc.).
##Both input and output device should use the same sample rate (although some APIs might provide resampling). This can be set in Windows's Audio Control Panel.
::
The following list provides basic reference for different APIs. The most recommended APIs are listed first.

subsection:: List of available APIs
definitionlist::
## ASIO
||
LIST::
## strong::Maximum channel count: :: Supports an arbitrary number of input/output channels, as provided by the hardware
## strong::Typical latency: :: Low
## strong::Caveats: :: Dedicated ASIO driver needs to be provided by the audio device's manufacturer; this is common for most (semi-)professional interfaces, but not necessarily for internal soundcards
## strong::More info: :: Designed for pro-audio devices; control over sampling rate and hardware buffer size is usually provided by the driver's control panel (i.e. not settable by SuperCollider); ASIO stands for Audio Stream Input/Output and was developed by Steinberg
::
## WASAPI
||
LIST::
## strong::Maximum channel count: :: Typically supports mono or stereo only; devices with more than 2 channels might be represented as multiple stereo pairs
## strong::Typical latency: :: Low
## strong::Caveats: :: If the requested sample rate is different than the device's sample rate, the server will not boot
## strong::More info: :: WASAPI stands for Windows Audio Session API and is the most modern Windows audio API
::
## WDM-KS
||
LIST::
## strong::Maximum channel count: :: Typically supports mono or stereo only; devices with more than 2 channels might be represented as multiple stereo pairs
## strong::Typical latency: :: Low
## strong::Caveats: :: On some systems SuperCollider will prevent other applications from using the audio device when using this API
## strong::More info: :: WDM-KS stands for Windows Driver Model Kernel Streaming. It was the first native Windows API providing reasonably low latency
::
## DirectSound
||
LIST::
## strong::Maximum channel count: :: Typically supports mono or stereo only; devices with more than 2 channels might be represented as multiple stereo pairs
## strong::Typical latency: :: Moderate/high
## strong::Caveats: :: It is an older API and typically provides worse performance than the newer ones
## strong::More info: :: DirectSound is part of DirectX and was originally created with game audio in mind
::
## MME
||
LIST::
## strong::Maximum channel count: :: Typically supports mono or stereo only; devices with more than 2 channels might be represented as multiple stereo pairs
## strong::Typical latency: :: High
## strong::Caveats: :: It is the oldest API on this list; it is chosen by default if the user does not specify which device to use
## strong::More info: :: This API might work out-of-the-box, but choosing a newer one instead will usually provide better performance; MME stands for Multimedia Extension (for Windows 3.0)
::
::


If ASIO driver is available, it is probably the best choice to ensure low input/output latency. ASIO drivers usually provide both inputs and outputs through a single device.
note::On Windows, ASIO driver is likely the only option for multichannel operation (allowing to use more than 2 inputs/outputs simultaneously).::

code::
o = Server.default.options;
o.device = "ASIO : UMC ASIO Driver";
Server.default.reboot;
::

subsection:: ASIO4ALL
If you are using an internal soundcard or a device which does not come with an ASIO driver, an alternative is to use ASIO4ALL. It is a virtual ASIO driver, communicating with the soundcard using Windows' native APIs. It might provide better performance with built-in soundcards and it should allow for multichannel operation with such devices (if supported by the hardware). Use a web search engine to find a download link.
note::ASIO4ALL will usually strong::not:: provide a better performance than a dedicated ASIO driver.::
After installing ASIO4ALL, it can be selected as follows (confirm in the post window when the server boots):
code::
Server.default.options.device = "ASIO : ASIO4ALL v2";
::


title:: Classes
categories:: Language>OOP
summary:: explaining classes
related:: Classes/Class, Reference/Assignment, Guides/Intro-to-Objects, Reference/Messages, Guides/Polymorphism, Guides/WritingClasses

All objects in SuperCollider are members of a class that describes the objects' data and interface. The name of a class must begin with a capital letter. Class names are the only global values in the SC language. Since classes are themselves objects, the value of a class name identifier is the object representing that class.

See link::Guides/Intro-to-Objects:: for an introduction to the concepts of classes, objects and messages.

section:: Instance Variables

The data of an object is contained in its instance variables. Instance variables are of two kinds, named and indexed. Each object contains a separate copy of its instance variables.

Some classes' instances have no instance variables at all but instead have an atomic value. Classes whose instances consist of an atomic value are link::Classes/Integer::, link::Classes/Float::, link::Classes/Symbol::, link::Classes/True::, link::Classes/False::, link::Classes/Nil::, link::Classes/Char::, link::Classes/Color::.

Instance variables declaration lists occur after the open curly bracket of the class definition and are preceded by the reserved word code::var::. Instance variables names in the list may be initialized to a default literal value by using an equals sign. Instance variables which are not explicitly initialized will be set to nil. Instance variables that are immutable are defined by the reserved word code::const::.

Instance variables may only be directly accessed and changed from within the class' own methods. Instance variables may be exposed to clients by adding getter and setter messages to the class. A getter message is a message with the same name as the variable which returns the value of that variable when sent to the receiver. A setter message is a message with the name of the variable with an underscore appended which sets the value of the instance variable to the value of the argument to the message.

Getter and setter methods may be defined in the declaration of the instance variable. A getter message for an instance variable is created by typing a less than sign code::<:: before the variable name. A setter message is created by typing a greater than code::>:: sign before the variable name. If both occur then they must occur in the order code::<>::.
code::
var a, <b, >c, <>d;
::
definitionlist::
## a || has no getter or setter.
## b || has a getter but not a setter.
## c || has only a setter.
## d || has both a getter and setter.
::
code::
Point {
	// x and y are instance variables which have both getter and setter methods
	// and default to zero.
	var <>x = 0, <>y = 0;
	...
}

p = Point.new;
p.x_(5);		// send setter message to set x to 5
p.y_(7);		// send setter message to set y to 7
p.x = 5;		// send setter message using setter assignment
p.y = 7;		// send setter message using setter assignment
a = p.x;		// send getter message for x
b = p.y;		// send getter message for y
::

section:: Class Variables

Class variables are values that are shared by all objects in the class. Class variable declaration lists are preceded by the reserved word code::classvar:: and may be interspersed with instance variable declaration lists.
Class variables like instance variables may only be directly accessed by methods of the class. Class variables may also have getter and setter methods created for them using the less than code::<:: and greater than code::>:: symbols.

section:: Instance Methods

The messages of a class' interface are implemented in the methods of the class. When an object is sent a message the method whose name matches the message selector in the receiver's class is executed.

Method definitions follow the class variable and instance variable declarations in the class.

Method definitions are similar to FunctionDefs in syntax. Method definitions begin with the message selector. The message selector must be an identifier or a binary operator. Methods have arguments and variable declarations with the same syntax as in FunctionDefs.
Methods however have an implicit first argument named this which is the receiver of the message. The variable code::this:: may be referred to just like any of the other arguments and variables in the method. You may not assign a value to code::this::.

section:: Class Methods

Class Methods are methods that implement messages sent to the class object. A common example is the message new which is sent to the class object to create a new instance of the class. Class method names have an asterisk code::*:: preceding the message selector.

section:: Determine the class of an object
link::Classes/Object:: defines the method code::isKindOf:::
code::
anObject.isKindOf(aClass)
::
It returns true if the object is of the class or one of its subclasses.

To determine if an object is specifically of type aClass, but not one of its subclasses, use the code::class:: instance variable and the identity equals sign:
code::
anObject.class === aClass
::



title:: Comments
categories:: Language
summary:: source-code comments

Comments begin with code:://:: and go until the end of the line. Comments can also be delimited with code::/*:: and code::*/::.

Examples:
code::
// single line comment

/*
	multi
	line
	comment
*/

/* Unlike C, you can have /* nested */ comments */
::



title::Control Structures
summary:: flow control
categories:: Language
related:: Classes/Boolean

Control structures in SuperCollider are implemented via message sends. Here are a few of those available.
See link::Reference/Syntax-Shortcuts:: for the various ways expressions can be written.

section:: Basic Control Structures

method:: if

Conditional execution is implemented via the code::if:: message. The code::if:: message is sent to an expression which must return a link::Classes/Boolean:: value.

In addition it takes two arguments: a function to execute if the expression is true and another optional function to execute if the expression is false. The code::if:: message returns the value of the function which is executed. If the falseFunc is not present and the expression is false then the result of the if message is nil.

discussion::
Syntax
code::
if(expr) { true body } { false body };

// alternate
if(expr, trueFunc, falseFunc);

// possible but harder to read, so, not preferred
expr.if (trueFunc, falseFunc);
::

Examples
code::
if([false, true].choose) {
	"expression was true".postln  // true function
} {
	"expression was false".postln  // false function
};
)

(
var a = 1, z;
z = if(a < 5) { 100 } { 200 };
z.postln;
)

(
var x;
if(x.isNil) { x = 99 };
x.postln;
)
::


method:: while

The while message implements conditional execution of a loop. If the testFunc answers true when evaluated, then the loopFunc is evaluated and the process is repeated. Once the testFunc returns false, the loop terminates.

discussion::
Syntax
code::
while { testFunc body } { loopFunc body };

// alternate
while({ testFunc body }, { loopFunc body });

// possible but harder to read, so, not preferred
{ testFunc body }.while({ loopFunc body });
::

Example
code::
(
i = 0;
while { i < 5 } { i = i + 1; "boing".postln };
)
::

while expressions are also optimized by the compiler if they do not contain variable declarations in the testFunc and the loopFunc.


method:: for

The for message implements iteration over an integer series from a starting value to an end value stepping by one each time. A function is evaluated each iteration and is passed the iterated numeric value as an argument.

discussion::
Syntax
code::
for(startValue, endValue) { loop body }

// alternate
for(startValue, endValue, function)

// possible but harder to read, so, not preferred
startValue.for ( endValue, function )
::

Example
code::
for(3, 7) { arg i; i.postln };  // prints values 3 through 7
::

method:: forBy

The forBy selector implements iteration over an integer series with a variable step size. A function is evaluated each iteration and is passed the iterated numeric value as an argument.

discussion::
Syntax
code::
forBy(startValue, endValue, stepValue) { loop body };

forBy(startValue, endValue, stepValue, function);

// possible but harder to read, so, not preferred
startValue.forBy(endValue, stepValue, function);
::

Example
code::
forBy(0, 8, 2) { arg i; i.postln };  // prints values 0 through 8 by 2's
::


method:: do

Do is used to iterate over a link::Classes/Collection::. Positive Integers also respond to code::do:: by iterating from zero up to their value. Collections iterate, calling the function for each object they contain. Other kinds of Objects respond to do by passing themselves to the function one time. The function is called with two arguments, the item, and an iteration counter.

discussion::
Syntax
code::
collection.do { loop body };

// alternate
collection.do(function)

// alternates, rarely seen
do(collection, function)
do(collection) { loop body };
::

Example
code::
[ 1, 2, "abc", (3@4) ].do { arg item, i; [i, item].postln; };

5.do { arg item; item.postln }; // iterates from zero to four

"you".do { arg item; item.postln }; // a String is a collection of characters

'they'.do { arg item; item.postln }; // a Symbol is a singular item

(8..20).do { arg item; item.postln }; // iterates from eight to twenty

(8,10..20).do { arg item; item.postln }; // iterates from eight to twenty, with stepsize two

Routine {
	var i = 10;
	while { i > 0 } {
		i.yield;
		i = i - 5.0.rand
	}
}.do { arg item; item.postln };  // 'do' applies to the Routine
::

Note:: The syntax code::(8..20).do:: uses an optimization to avoid generating an array that is used only for iteration (but which would be discarded thereafter). The return value of code:: (8..20).do { |item| item.postln } :: is 8, the starting value.

However, if code::do:: is written as an infix binary operator, as in code::(8..20) do: { |item| item.postln }::, then it will generate the series as an array first, before calling Array:do. One side effect of this is that it is valid to code::do:: over an infinite series within a routine only if code::do:: is written as a method call. If it is written as a binary operator, you will get a "wrong type" error because the array must be finite.

code::
// OK: 'do' is a method call
r = Routine {
	(8 .. ).do { |i|
		i.yield;
	};
};

r.next;
-> 8
-> 9 etc.

// ERROR: 'do' is an operator
r = Routine {
	(8 .. ) do: { |i|
		i.yield;
	};
};

r.next;

ERROR: Primitive '_SimpleNumberSeries' failed.
Wrong type.
::
::

method:: switch

Object implements a switch method which allows for conditional evaluation with multiple cases. These are implemented as pairs of test objects (tested using if this == test.value) and corresponding functions to be evaluated if true.

The switch statement will be inlined if the test objects are all Floats, Integers, Symbols, Chars, nil, false, true and if the functions have no variable or argument declarations. The inlined switch uses a hash lookup (which is faster than nested if statements), so it should be very fast and scale to any number of clauses.

note::Hash lookup by definition implies testing emphasis::identity:: rather than equality: a code::switch:: construction that is not inlined will test code::==::, while one that is inlined will test code::===::. See the examples. One implication is that strings should be avoided: code::switch(text) { "abc" } { ... }:: may not match, even if code::text == "abc"::. Symbols are preferred.::

note::Floating point numbers may sometimes appear to be equal while differing slightly in their binary representation: code::(2/3) == (1 - (1/3)):: is false. Therefore floats should be avoided in code::switch:: constructions.::

discussion::
Syntax
code::
switch(value)
{ testvalue1 } { truebody1 }
{ testvalue2 } { truebody2 }
{ testvalue3 } { truebody3 }
{ testvalue4 } { truebody4 }
...
{ defaultbody };

switch(value,
        testvalue1, trueFunction1,
        testvalue2, trueFunction2,
        ...
        testvalueN, trueFunctionN,
        defaultFunction
);
::

Examples
code::
(
var x = 0; //also try 1
switch(x, 0, { "hello" }, 1, { "goodbye" })
)

(
var x = 0; //also try 1
switch(x) { 0 } { "hello" } { 1 } { "goodbye" };
)

(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
switch (z.choose.postln,
	1,   { \no },
	1.1, { \wrong },
	1.3, { \wrong },
	1.5, { \wrong },
	2,   { \wrong },
	0,   { \true }
).postln;
)
::
or:
code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
x = switch(z.choose)
	{1}   { \no }
	{1.1} { \wrong }
	{1.3} { \wrong }
	{1.5} { \wrong }
	{2}   { \wrong }
	{0}   { \true };
x.postln;
)
::

Inlined vs non-inlined comparison:

code::
(
switch(1.0)
	{ 1 } { "yes" }
	{ "no" }
)

-> no
::

The identity comparison code::1.0 === 1:: is false: while 1.0 and 1 represent the same numeric value, one is floating point and the other is an integer, so they cannot be identical.

code::
(
// 'var x' prevents inlining
switch(1.0)
	{ 1 } { var x; "yes" }
	{ "no" }
)

WARNING: Float:switch is unsafe, rounding via Float:asInteger:switch
-> yes
::


method:: case

Function implements a case method which allows for conditional evaluation with multiple cases. Since the receiver represents the first case this can be simply written as pairs of test functions and corresponding functions to be evaluated if true. Case is inlined and is therefore just as efficient as nested if statements.

discussion::
Example
code::
(
var i, x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
i = z.choose;
x = case
	{ i == 1 }   { \no }
	{ i == 1.1 } { \wrong }
	{ i == 1.3 } { \wrong }
	{ i == 1.5 } { \wrong }
	{ i == 2 }   { \wrong }
	{ i == 0 }   { \true };
x.postln;
)
::

method:: try

Function implements a code::try:: method which allows catching exceptions thrown by code and run the exception handler. For more information see link::Classes/Exception::.
discussion::
Example
code::
try {
	...code... 
} { |error|
	...exception handler...
};
::

method:: protect

Function implements a code::protect:: method which allows protecting code from exceptions thrown by code.
The difference with code::try:: is the exception handler code is always run, even if there is no exception.
If an exception occurs, it is rethrown after the exception handler block is run.
For more information see link::Classes/Exception::.

discussion::
Example
code::
file = File(path, "r");
protect {
	// work with the file here, which might cause an error
} {
	file.close;
};
::

section:: Other Control Structures

Using Functions, many control structures can be defined like the ones above. In the class link::Classes/Collection#Iteration:: there are many more messages defined for iterating over Collections.

section:: Inline optimization

code::if::, code::while::, code::switch:: and code::case:: expressions are optimized (i.e. inlined) by the compiler if they do not contain variable declarations in the functions. The optimization plucks the code from the functions and uses a more efficient jump statement:
code::
(
{
	if(6 == 9) {
		"hello".postln;
	} {
		"world".postln;
	}
}.def.dumpByteCodes
)

BYTECODES: (20)
  0   2C 06    PushInt 6
  2   2C 09    PushInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   F8 00 07 JumpIfFalse 7  (15)
  8   41       PushLiteral "hello"
  9   B0       TailCallReturnFromFunction
 10   C1 3A    SendSpecialMsg 'postln'
 12   FC 00 04 JumpFwd 4  (19)
 15   40       PushLiteral "world"
 16   B0       TailCallReturnFromFunction
 17   C1 3A    SendSpecialMsg 'postln'
 19   F2       BlockReturn
-> < closed FunctionDef >
::

Failure to inline due to variable declarations:
code::
(
{
	if(6 == 9, {
		var notHere;
		"hello".postln;
	},{
		"world".postln;
	})
}.def.dumpByteCodes
)

WARNING: FunctionDef contains variable declarations and so will not be inlined.
  in file 'selected text'
  line 4 char 14:

  		var notHere;

  		"hello".postln;
-----------------------------------
BYTECODES: (13)
  0   2C 06    PushInt 6
  2   2C 09    PushInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   04 00    PushLiteralX instance of FunctionDef - closed
  7   04 01    PushLiteralX instance of FunctionDef - closed
  9   B0       TailCallReturnFromFunction
 10   C3 0B    SendSpecialMsg 'if'
 12   F2       BlockReturn
-> < closed FunctionDef >
::

You can switch on and off the above warning (see: link::Classes/LanguageConfig#*postInlineWarnings::)

code::
LanguageConfig.postInlineWarnings_(true) // warn
LanguageConfig.postInlineWarnings_(false) // ignore it.
::


title:: Emacs Editor
categories:: Frontends
summary:: Using SuperCollider in Emacs

section:: Keyboard shortcuts
Here is a more extensive and elaborate overview of useful shortcuts in the Emacs Editor. For a general reference to Emacs shortcut, check out this link::http://lpn.rnbhq.org/tools/xemacs/emacs_ref.html##Emacs reference::.
definitionlist::
## C-g || Abort current action
## C-h || General help on emacs
::
subsection:: Interpreting code
definitionlist::
## C-c C-d
(C-c C-c) || Interpret Selection
(only if transient-mark-mode is on)
## C-c C-c || Interpret current line
## C-c C-e || Evaluate expression (in minibuffer)
## C-M-x || Interpret defun
## C-c C-f || Interpret current document
::
subsection:: Control the interpreter
definitionlist::
## C-c C-s || Stop (CmdPeriod) / Main.stop
## C-c C-r || Main.run
## C-c C-l || Recompile library
## M-x sclang-stop || Stop interpreter
## C-c C-p p || Show server panels
::
subsection:: Postbuffer and workspace
definitionlist::
## C-c C-w || Switch to workspace
## C-c < || Clear postbuffer
## C-c > || Show postbuffer
::
subsection:: Help files
definitionlist::
## C-M-h || Show help browser
## C-c C-h || Open help file. You do not need to select a word before using the shortcut. It will suggest the word at the current cursor position, or lets you type a word in the minibuffer. There is autocompletion by typing <TAB>.
## E (in the help browser) || open the help file as plain text (in sclang-mode), so it can be edited.
## C-c C-v (in the help browser) || edit the help file as html code.
::
subsection:: Finding things in class source files
definitionlist::
## C-c : || Find definitions (method or class). Again, you can type the word you want to look for in the minibuffer and it suggests the word at the current cursor position.
## C-c ; || Find references to (method or class). (ditto)
## C-c C-k || Open current file at the svn development path location. You need to have set the devpath variable in Platform for this to work properly, e.g.
thisProcess.platform.devpath = "~/svn/SuperCollider3".standardizePath;
::
subsection:: Current code completion and interface
definitionlist::
## C-c [ || Dump interface
## C-c { || Dump full interface
## C-c C-m / C-c RET || Show method arguments (in minibuffer)
## C-c C-n / M-TAB || Autocomplete keyword (either puts in the one possible completion, or pops up a buffer with possibilities from which you can choose one)
::
subsection:: Files and buffers
definitionlist::
## C-x C-f || Open file or new file
## C-x C-s || Save file
## C-x C-w || Save file as
## C-x C-v || Open another file in this buffer
## C-x i || Insert a file at cursor position
## C-x b || Create/switch buffers
## C-x C-b || Show buffer list
## C-x k || Kill buffer
## C-z || Suspend emacs
## C-x C-c || Close down emacs
::
subsection:: Undo and recovery
definitionlist::
## C-x u / C-_ || Undo
## C-x u / C-_ || Redo
## M-x revert-buffer RETURN || undo all changes since last save
## M-x recover-file RETURN || Recover text from an autosave-file
## M-x recover-session RETURN || Recover text from an autosave-files if you edited several files
::
subsection:: Editing
definitionlist::
## M-w || Copy
## C-y || Paste
## C-w || Cut
## C-x C-o || Delete blank lines
::
subsection:: Search and replace
definitionlist::
## C-s || Search / find. This allows you to set a string in the mini-buffer. The occurrences in the text will be highlighted and you can press C-s again and again to jump to next occurrences
## C-r || Search / find backwards.
## M-% || Replace and find next
## M-, || Replace
::
subsection:: Navigating and selecting
definitionlist::
## M-g g || Goto line ...
## C-x a || Select all
## C-M-f || zips you forward to matching parenthesis, so if you hover over the opening bracket, hit
C-<space>, C-M-f, C-c C-c you can quickly execute a block.
## C-M-b || zips you backward to matching parenthesis. If you are just to the right of closing brackets this is handier if you've just finished some code.
## C-f || Move forward a character
## C-b || Move backward a character
## M-f || Move forward a word
## M-b || Move backward a word
## C-n || Move to next line
## C-p || Move to previous line
## C-a || Move to beginning of line
## C-e || Move to end of line
## M-a || Move back to beginning of sentence
## M-e || Move forward to end of sentence
::
subsection:: Formatting
definitionlist::
## M-x show-paren-mode || Paren match highlighting. Can also be set from the options menu.
## M-; || Add comment. If you have a text selected, then that text will become a comment. It will remove the commenting // when you have selected a commented text.
## C-M-j || Continue the comment on the next line.
## C-u M-; || Remove comment. This removes the whole comment, so also the text!
## M-x comment-region || Comments the selected region
## M-x uncomment-region || Uncomments the selected region
## TAB || Auto-aligns tabs according to code.
::

section:: Marks
(info from EmacsWiki)
subsection:: set-mark-command (`C-SPC')
A nice feature that not all know about is what happens if you feed it with a universal argument: ‘C-u C-SPC’. It’s an easy way to navigate back to your previous editing spots by jumping to the positions stored in the buffer’s local mark ring. Repeated calls will cycle through the ring of marks.

If you use TransientMarkMode and you want to set the mark but don’t want to subsequently see the region highlighting, you can use ‘C-SPC C-g’ to set the mark and then deactivate it.

subsection:: pop-global-mark (`C-x C-SPC')
In addition to the ordinary mark ring that belongs to each buffer, Emacs has a single global mark ring. It records a sequence of buffers in which you have recently set the mark, so you can go back to those buffers.

Setting the mark always makes an entry on the current buffer’s mark ring. If you have switched buffers since the previous mark setting, the new mark position makes an entry on the global mark ring also. The result is that the global mark ring records a sequence of buffers that you have been in, and, for each buffer, a place where you set the mark.

‘C-x C-SPC’ (‘pop-global-mark’) jumps to the buffer and position of the latest entry in the global mark ring. It also rotates the ring, so that successive uses of ‘C-x C-SPC’ take you to earlier and earlier buffers.

section:: Customizing Emacs' behavior

You can customize the behaviour of Emacs, by putting things in the startup file of emacs. This file is code:: ~/.emacs ::. You can define options there, for example:
code::
(custom-set-variables
 '(case-fold-search t)
 '(global-font-lock-mode t nil (font-lock))
 '(sclang-runtime-directory "~/SuperCollider/")
 '(show-paren-mode t nil (paren))
 '(transient-mark-mode t)
)
::
nil means that an option is turned off, t or 1 means that it is turned on.
code::
'(sclang-eval-line-forward nil)
::
Configure the text cursor NOT to move after hitting C-c C-c

subsection:: Customize w3m

Normally w3m uses the arrow keys to jump between hyperlinks. For browsing SC help files this is not very useful.
code::
(eval-after-load "w3m"
 '(progn
 (define-key w3m-mode-map [left] 'backward-char)
 (define-key w3m-mode-map [right] 'forward-char)
 (define-key w3m-mode-map [up] 'previous-line)
 (define-key w3m-mode-map [down] 'next-line)
 (setq w3m-auto-show 1)
 ))
::

subsection:: Automatically complete brackets and parentheses
code::
  (setq skeleton-pair t)
  (global-set-key (kbd "(") 'skeleton-pair-insert-maybe)
  (global-set-key (kbd "{") 'skeleton-pair-insert-maybe)
  (global-set-key (kbd "[") 'skeleton-pair-insert-maybe)
  (global-set-key (kbd "\"") 'skeleton-pair-insert-maybe)
  (global-set-key (kbd "'") 'skeleton-pair-insert-maybe)
::

subsection:: Scrollwheel support
code::
;;; scrollwheel support
(defun scroll-up-half ()
  "Scroll up half a page."
  (interactive)
  (scroll-up (/ (window-height) 2))
  )

(defun scroll-down-half ()
  "Scroll down half a page."
  (interactive)
  (scroll-down (/ (window-height) 2))
  )
(global-set-key [(mouse-5)] 'scroll-up-half)
(global-set-key [(mouse-4)] 'scroll-down-half)
::

subsection:: Recent files menu

Recentf is a minor mode that builds a list of recently opened files. This list is automatically saved across Emacs sessions. You can then access this list through a menu. Put this in your `~/.emacs’:
code::
(require 'recentf)
(recentf-mode 1)
::
For adding a shortcut (C-x C-r) to open a recent file add this code as well:
code::
(defun recentf-open-files-compl ()
  (interactive)
  (let* ((all-files recentf-list)
    (tocpl (mapcar (function
       (lambda (x) (cons (file-name-nondirectory x) x))) all-files))
    (prompt (append '("File name: ") tocpl))
    (fname (completing-read (car prompt) (cdr prompt) nil nil)))
    (find-file (cdr (assoc-ignore-representation fname tocpl)))))

(global-set-key "\C-x\C-r" 'recentf-open-files-compl)
::

section:: More info on Emacs

See the link::http://www.emacswiki.org/cgi-bin/wiki##Emacs Wiki::


title:: Event Stream
categories:: Streams-Patterns-Events
related:: Classes/Stream, Classes/Event
summary:: A Stream that returns Events when called

An event stream is a normal link::Classes/Stream:: that returns events when called. (see class link::Classes/Event::). Usually, an event stream requires an event to be passed in, often the default event is used:

code::
t = Pbind(\x, Pseq([1, 2, 3])).asStream; // Pbind, e.g. creates a stream
t.next(Event.default);
t.next(Event.default);
::

An event stream cannot be played directly with a clock, as it returns events and not time values. Therefore, an link::Classes/EventStreamPlayer:: is used, which replaces the event by according time value.

A link::Classes/Pevent:: can be used to wrap a stream in an event:

code::
t = Pevent(Pbind(\x, Pseq([1,2,3])), Event.default).asStream;
t.next;
t.next;
::


title:: Expression Sequence
summary:: sequence of expressions
categories:: Language

A sequence of expressions separated by semicolons and optionally terminated by a semicolon are a single expression whose value is the value of the last expression. Such a sequence may be used anywhere that a normal expression may be used.
code::
max( b = a * 2; b + 5,  10);	// computes the maximum of b+5 and 10
::
In the above example, the sequence: code:: b = a * 2; b + 5 :: acts as a single expression for the first argument to code::max()::.



title:: Functions
summary:: lambda expressions
categories:: Language
related:: Classes/Function, Classes/AbstractFunction, Classes/FunctionDef

section:: Introduction

A link::Classes/Function:: is an expression which defines operations to be performed when it is sent the code::value:: message. In functional languages, a function would be known as a lambda expression.
Function definitions are enclosed in curly brackets code::{}::. Argument declarations, if any, follow the open bracket. Variable declarations follow argument declarations. An expression follows the declarations.
code::
{ arg a, b, c;  var d;   d = a * b; c + d }
::

Functions are not evaluated immediately when they occur in code, but are passed as values just like integers or strings.

A function may be evaluated by passing it the code::value:: message and a list of arguments.

When evaluated, the function returns the value of its expression.
code::
f = { arg a, b; a + b };
f.value(4, 5).postln;
f.value(10, 200).postln;
::

An empty function returns the value nil when evaluated.
code::
{}.value.postln;
::

A function can be thought as a machine able to perform a task on demand, e.g. a calculator. The calculator can receive input (args) and can output a value, the result of the performed operations. The function definition can then be thought as the building of the calculator: once built, the calculator does nothing until it is requested to work (by passing the value method to a function).
The following figure depicts an empty function, input without output, output without input, and the general case with input and output.

image::functions.png#Functions::

section:: Arguments

An argument list immediately follows the open curly bracket of a function definition. An argument list either begins with the reserved word code::arg::, or is contained between two vertical bars. If a function takes no arguments, then the argument list may be omitted.

Names of arguments in the list may be initialized to a default value using the following syntax forms. Arguments which are not explicitly initialized will be set to nil if no value is passed for them.

"arg" style, default value is a literal:
code::{ arg x = 1; .... } :: link::#[1]::

"arg" style, default value is an expression:
code::{ arg x = 10.rand; ... } :: link::#[2]::

"arg" style, default value is a literal but you want to treat it like an expression:
code::{ arg x = (2); ... } :: link::#[2]::

Pipe style, default value is a literal:
code::{ |x = 1| ... } :: link::#[1]::

Pipe style, default value is an expression:
code::{ |x = (10.rand)| ... } :: link::#[2]::

If the last argument in the list is preceded by three dots (an ellipsis), then all the remaining arguments that were passed will be assigned to that variable as an link::Classes/Array::. Arguments must be separated by commas.

examples:
code::
{ arg a, b, c=3; } // is equivalent to:

{ |a, b, c=3| }

{ arg x='stop', y, z=0; } // these args are initialised

{ arg a, b, c ... d; } // any arguments after the first 3 will be assigned to d as an Array
::

If you want all the arguments put in an Array
code::
arg ... z;
::

In general arguments may be initialized to literals or expressions, but in the case of Function:play or SynthDef:play, they may only be initialized to literals.
code::
// this is okay:

{ arg a = Array.geom(4, 100, 3); a * 4 }.value;

// this is not:

{ arg freq = Array.geom(4, 100, 3); Mix(SinOsc.ar(freq, 0, 0.1)) }.play; // silence

// but this is:
{ arg freq =  #[ 100, 300, 900, 2700 ]; Mix(SinOsc.ar(freq, 0, 0.1)) }.play; // silence
::

See link::Reference/Literals:: for more information.

anchor::[1]::
subsection:: [1] Literal argument defaults

Argument defaults that are literals are stored as part of the link::Classes/FunctionDef::. Arguments passed at runtime -- including nil -- always override the defaults:

code::
f = { arg x = 1; x };
f.value(2);  // prints 2

f.value;   // prints 1

f.value(nil);  // prints nil
::

anchor::[2]::
subsection:: [2] Expression argument defaults

Since expressions are evaluated when the function is called, they cannot be stored in the link::Classes/FunctionDef::. They are executed only if the passed-in value is nil.

code::
f = { arg x = 10.rand; x };
f.value(100);  // prints 100

f.value;   // prints a number 0-9

f.value(nil);   // prints a number 0-9!
::

This means you can use expression-style to define a default that cannot be overridden by nil.

code::
f = { arg x = (3); x };
f.value(nil);   // prints 3
::

Note: Parentheses are required when initializing an argument to an expression, if the argument list is written inside code::||:: pipes.

code::
(
var abc = 2;
{ arg x = abc+1; x }   // OK
)

(
var abc = 2;
{ |x = abc+1| x }
)
ERROR: Parse error
   in file 'selected text'
   line 1 char 10:
  { |x = abc•+1| x }
-----------------------------------
ERROR: Command line parse failed

(
var abc = 2;
{ |x = (abc+1)| x }   // OK
)

(
var abc = 2;
{ |x (abc+1)| x }   // In ||, the = may be omitted if () are there
)
::

This is because the pipe character also serves as a binary operator. Without parentheses, expressions such as the following are ambiguous:

code::
{ |a, b, c = a | b | c }
::

The following produce identical function definitions. Expression-style defaults are simply a shortcut syntax for the latter.

code::
{ arg x = 10.rand; x };

{	arg x;
	x ?? { x = 10.rand };
	x
};
::

section:: Variables

Following the argument declarations are the variable declarations. These may be declared in any order. Variable lists are preceded by the reserved word code::var::. There can be multiple var declaration lists if necessary. Variables may be initialized to default values in the same way as arguments. Variable declarations lists may not contain an ellipsis.

code::
var level=0, slope=1, curve=1;
::



title:: Key Value Pairs
summary:: An interface for translating between three common data structures: Dictionaries, Arrays of Associations and of Pairs
categories:: Collections, Interfaces
related::Classes/IdentityDictionary, Classes/Array, Classes/Association

SECTION::Motivation

There are three very similar ways to represent maps between keys and values, each of which have a specific purpose:

TABLE::
## key value pairs || common representation of arguments || code::[\freq, 452, \amp, 0.2]::
## collections of associations || ordering, array and collection methods || code::[0 -> [1, 2, 3], 1 -> [2, 1]]::
## dictionaries: fast lookup || event compatibility || code::(instrument: \sine, freq: 561)::
::

To make it easy to translate between these purposes and representations, there is a uniform set of methods:

TABLE::
##code::asPairs:: || returns an array of key value pairs
##code::asAssociations:: || returns an array of associations
##code::asDict:: || returns an IdentityDictionary.
::

SECTION::Examples

CODE::

// the following all return [\freq, 452, \amp, 0.2]

[\freq, 452, \amp, 0.2].asPairs
[\freq -> 452, \amp -> 0.2].asPairs
(freq: 452, amp: 0.2).asPairs


// the following all return [\freq -> 452, \amp -> 0.2]

[\freq, 452, \amp, 0.2].asAssociations
[\freq -> 452, \amp -> 0.2].asAssociations
(freq: 452, amp: 0.2).asAssociations

// the following all return (freq: 452, amp: 0.2) or the equivalent IdentityDictionary

[\freq, 452, \amp, 0.2].asDict
[\freq -> 452, \amp -> 0.2].asDict
(freq: 452, amp: 0.2).asDict

::




SECTION::Mapping Parameters

The method code::asDict:: optionally takes a code::mergeFunc:: and a code::class:: argument.

CODE::
 // IdentityDictionary[ (a -> 1), (c -> 3), (b -> 2) ]
[\a, 1, \a, 3, \b, 2, \c, 3, \c, 7].asDict;

//  IdentityDictionary[ (a -> 4), (c -> 10), (b -> 2) ]
[\a, 1, \a, 3, \b, 2, \c, 3, \c, 7].asDict({ |new, old| new + old })

// Dictionary[ (what -> was), (how -> wie), (and -> und), (this -> das) ]
["this", "das", "and", "und", "what", "was", "how", "wie"].asDict(class: Dictionary)

// Environment[ (a -> 1), (b -> 2) ]
[\a, 1, \b, 2].asDict(class: Environment)
::

The method code::asEvent:: is a shortcut:
CODE::
[\freq, 100, \amp, 0.1].asEvent // ( 'amp': 0.1, 'freq': 100 )
::

The methods code::asAssociations:: and code::asPairs:: optionally take a code::class:: argument.
CODE::
// SortedList[ (a -> 1871), (b -> 1848), (c -> 1789) ]
(c:1789, b:1848, a:1871).asAssociations(SortedList);

// LinkedList[ a, 1871, c, 1789, b, 1848 ]
(c:1789, b:1848, a:1871).asPairs(LinkedList);
::


title:: Keyboard Shortcuts
summary:: Keyboard shortcuts for SuperCollider
categories:: Frontends

section:: Language-Specific Commands

note:: For shortcuts bindings of teletype::ScIDE::, please consult the menu and/or the shortcut configuration menu.::

table::
## strong::Functions::
|| strong::macOS::
|| strong::GEdit (sced):: footnote::http://artfwo.googlepages.com/sced::
|| strong::Vim (scvim):: footnote::http://www.neisis.net/%7Ealex/scvim::
|| strong::Emacs (scel):: footnote:: link::Reference/EmacsEditor:: ::

## Interpret Selection
|| enter, ctl-c, ctl-return, shift-return
|| ctl-e
|| F5
|| C-c C-d / C-c C-c

## Interpret current line
|| enter, ctl-c, ctl-return, shift-return
|| ctl-e
|| F6
|| C-c C-c

## Interactively evaluate expression...
||
||
||
|| C-c C-e

## Evaluate defun or code-block
||
||
||
|| C-M-x

## Evaluate current document
||
||
||
|| C-c C-f

## Stop
|| cmd-.
|| escape
|| F12
|| C-c C-s

## TempoClock.default.clear
||
||
|| F7
||

## s.freeAll
||
||
|| F8
||

## Run Main-run
|| cmd-r
||
||
|| C-c C-r

## Recompile library
|| cmd-k
||
|| :SClangStart
|| C-c C-l

## Stop interpreter
||
||
|| :SClangKill
|| M-x sclang-stop

## Clear post window
|| cmd-sh-c
||
||
|| C-c <

## Open Help File
|| cmd-d
|| ctl-u
|| K or :SChelp
|| C-c C-h

## Open Class Definition (look up class file, either Class name or Class:method) e.g. Object, Object:dump
|| cmd-j
|| ctl-y
|| ^k or :SCdef
|| C-c :

## Implementations of (which objects have code that defines methods, e.g. 'play')
|| cmd-y
||
||
|| C-c :

## References to (where in the source files is e.g. the method 'play' used?)
|| cmd-sh-Y
||
||
|| C-c ;

## Dump interface
||
||
||
|| C-c [

## Dump full interface
||
||
||
|| C-c {

## Show method arguments
||
||
||
|| C-c C-m / C-c RET

## Autocomplete keyword
||
||
||
|| C-c C-n / M-TAB

## Show server panels
||
||
||
|| C-c C-p p
::

section:: Files
table::
## strong::Functions::
|| strong::macOS::
|| strong::GEdit (sced)::
|| strong::Vim (scvim)::
|| strong::Emacs (scel)::

## Open text document
|| cmd-o
|| ctl-o
|| :e
|| C-x C-f

## New text document
|| cmd-n
|| ctl-n
|| :enew
|| (open non-existent file w. new name)

## Close text document
|| cmd-w
|| ctl-w
|| :close
|| C-x k

## Save text document
|| cmd-s
|| ctl-s
|| :w
|| C-x C-s

## Save text document as
|| cmd-sh-s
|| ctl-sh-s
|| :sav
|| C-x C-w

## HTML doc window => code win
||
|| ctl-t
||
|| E
::

section::Text Editing
table::
## strong::Functions::
|| strong::macOS::
|| strong::GEdit (sced)::
|| strong::Vim (scvim)::
|| strong::Emacs (scel)::

## Undo
|| cmd-z
|| ctl-z
|| u
|| C-x u / C-_

## Redo
|| cmd-sh-Z
|| ctl-sh-z
|| ^R
|| C-x u / C-_

## Copy
|| cmd-c
|| ctl-c
|| "+y
|| M-w

## Paste
|| cmd-v
|| ctl-v
|| "+gP
|| C-y

## Cut
|| cmd-x
|| ctl-x
|| "+x
|| C-w

## Select all
|| cmd-a
|| ctl-a
|| ggVG
|| C-x a

## Select block
||
||
||
||

## Goto line ...
|| cmd-,
|| ctl-i
|| (linenumber)G
|| M-g g

## Find ...
|| cmd-f
|| ctl-f
|| / or *
|| C-s

## Find next
|| cmd-g
|| ctl-g
|| *
|| C-s

## Find previous
|| cmd-d
|| ctl-sh-g
|| #
|| C-r

## Replace and find next
|| cmd-l
||
||
|| M-%

## Replace
|| cmd-=
|| ctl-h
||
|| M-,

## Copy text style only
|| cmd-alt-c
||
||
||

## Paste text style only
|| cmd-alt-v
||
||
||
::

section::Formatting
table::
## strong::Functions::
|| strong::macOS::
|| strong::GEdit (sced)::
|| strong::Vim (scvim)::
|| strong::Emacs (scel)::

## Syntax Colorise
|| cmd-'
|| auto
|| auto
|| auto

## Balance (find next matched parens/curly braces and select everything enclosed)
|| cmd-sh-B
||
||
|| C-<space>, C-M-f

## Balance backwards (find previous matched parens/curly braces and select everything enclosed)
||
||
||
|| C-<space>, C-M-b

## Paren match highlight
||
||
|| auto
|| auto with option Paren-Match-Highlighting

## Comment (add // in front)
|| cmd-/
||
||
|| (select text and) M-;

## Uncomment (remove //s)
|| cmd-sh-/
||
||
|| (select text and) M-;

## Indent / Shift left (move selected text by one tab)
|| cmd-[
||
||
|| TAB (auto-aligns tabs according to code)

## Unindent / Shift right (by one tab)
|| cmd-]
||
||
||

## Insert (): enclose selected text with (txt)
|| cmd-(
||
||
||

## Insert []: enclose selected text with [txt]
|| cmd-alt-[
||
||
||

## Insert {}: enclose selected text with {txt}
|| cmd-{
||
||
||

## Insert /* */: enclose selected text with /*txt*/
|| cmd-*
||
||
||
::



title:: Literals
summary:: values with a direct syntactic representation
related:: Classes/Number, Classes/Integer, Classes/Float, Classes/SimpleNumber, Classes/String, Classes/Array, Classes/Symbol
categories:: Language

Literals are values which have a direct syntactic representation.
The following sections describe the types of literals that can be represented.

section::Numbers

subsection::Integers
An integer is any series of digits optionally preceded by a minus sign:
code::
-13
666
2112
96
::

They can also also be expressed in hexadecimal with the prefix code::0x:: and
either uppercase or lowercase letters:
code::
0xa    // 10
-0xd   // -13
0x29A  // 666
0x840  // 2112
0x60   // 96
::

subsection::Floats
A float, or floating-point number, is one or more decimal digits, followed by a
decimal point, followed by one or more decimal digits.
You must have digits on both sides of the decimal point.
In SuperCollider, floating-point numbers are always 64-bit, except within a
link::Classes/FloatArray::.

Examples of floats:
code::
0.39
98.6
1.0
-0.5
::

Exponential notation is also supported:
code::
1.2e4
1E-4
::

The keyword code::pi:: can also be used by itself, or appended to a float or
integer to create a floating point constant:
code::
pi
2pi
0.5pi
-0.25pi
::

The keyword code::inf:: represents infinity, and is also treated as an instance
of Float.
code::
inf   // and beyond!
-inf
::

subsection::Radix
Numbers can also be written in radices other than base 10 up to base 36.
The radix is specified in base 10, followed by the letter 'r', followed by the
value written in that radix using characters 0-9 and A-Z (or a-z) for digit
values from 0 to 35. For example, you can write hexadecimal numbers as follows:
code::
16rF // 15
16ra9 // 169
36rZIGZAG // 2147341480
::

Binary numbers can be written as follows:
code::
2r01101011
::

Floating point values may also be specified in any base. However, only
uppercase letters may be used past the decimal point for bases greater than 10.
This eliminates ambiguity: if lowercase letters were allowed,
code::36rA.bitNot:: might be a function call, or it might be
code::36rA.BITNOT == 10.320080118934::.
code::
12r4a.abc // wrong
12r4a.ABC // works
12r4A.ABC // better
::

Hexidecimal numbers notated with code::0x:: may only be expressed as integers.

subsection::Scale Degrees
Integer numbers as scale degrees supports accidentals notation by adding the suffixes strong::s:: for sharp and strong::b:: for flat. Accidentals are represented as floating point values.

code::
2s == 2.1  // scale degree two, sharp
2b == 1.9  // scale degree two, flat
2ss == 2.2 // scale degree two, double sharp
2bb == 1.8 // scale degree two, double flat
::

Up to four:

code::
2ssss == 2.4
2bbbb == 1.6
::

With negative scale degrees it reverses:

code::
-2s == -1.9
-2b == -2.1
-2ss == -1.8
-2bb == -2.2
::

Accidentals can also specify cents deviation up to 499 cents:

code::
2b50 == 1.95 // scale degree two, fifty cents flat
2s204 == 2.204 // scale degree two, 204 cents sharp
::

section::Characters

Characters are preceded by a dollar sign:
code::
$A
$B
$C
$.
$$
::

As in C and Java, backslash ('\') is the emphasis::escape character::.
Escaping has two main purposes. First, to insert non-printing characters into a
String. Secondly, to allow a String or Symbol delimiter to be included in the
contents. For String, double-quote marks indicate the beginning and ending of
the String literal. To put a double-quote in the middle of the string, the
normal meaning of double-quote must be suspended ("escaped"), as in
code::"He repeated, \"Madam, I'm Adam,\" only this time he had said it backward."::

In all cases, the \ as an escape character does not appear in the String or
Symbol. This is a frequent source of confusion for Windows file paths:
e.g., code::"C:\Users\Somebody\SuperCollider":: translates into
teletype::C:UsersSomebodySuperCollider::. The way to notate a literal backslash
inside a String or Symbol is with a double-backslash:
code::"C:\\Users\\Somebody\\SuperCollider"::. (Note, however, that it is
preferable to write file paths using forward slashes, regardless of platform:
code::"C:/Users/Somebody/SuperCollider"::.

The following are the recognized escape characters in SuperCollider. A
backslash before any other character will simply produce that character.
code::
$\t  // tab (horizontal tab)
$\f  // form feed
$\v  // vertical tab
$\n  // newline (linefeed)
$\r  // return
$\\  // backslash`
::

section::Symbols and Strings

subsection::Symbols
A symbol can be written in two ways. One method is to enclose the contents in
single quotes. Any printing character may be used within a symbol except for
non-space whitespace characters (code::\f, \n, \r, \t, \v::). Any single quotes
within the symbol must be escaped (code::\'::).
code::
'x'
'aiff'
'BigSwiftyAndAssoc'
'nowhere here'
'somewhere there'
'.+o*o+.'
'\'symbol_within_a_symbol\''
::

A second way of notating symbols is by prefixing the word with a backslash.
This is only legal if the symbol consists of a single word (a sequence
of alphanumeric and/or underscore characters).
code::
\x
\aiff
\Big_Swifty_And_Assoc
\not really a symbol  // illegal
::

subsection::Strings

Strings are written in double quotes:
code::
"This is a string."
::

If two or more strings are lexically adjacent, then they combine into a larger string:
code::
a = "st" "ri" "ng"
a.size // 6
::

Strings may span more than one line. The newline characters become part of the string:
code::
a = "st
ri
ng
"
a.size // 9
::

The SuperCollider IDE uses UTF-8 to decode and display strings.
See link::Classes/String#Character encodings##String:: for more information.

section::Identifiers

Names of methods and variables begin with a lower case alphabetic character,
followed by zero or more alphanumeric or underscore characters.
code::
var abc, z123, trigger_func;
var 1var; // not legal
var _hmm; // not legal
var hmm_; // Although this is legal, avoid it, since setter functions in
          // SuperCollider typically end with underscores.
::

section::Class Names

Class names always begin with a capital letter followed by zero or more
alphanumeric or underscore characters.
code::
Object
Point
Synth
SinOsc
Pan2
MyClass_LikesUnderscores // legal
MyClass_ // legal, but avoid
::

section::Special Values

The singular instances of the classes True, False and Nil can
be expressed with keywords code::true::, code::false::, and code::nil::.
code::
x = true;
y = false;
z = nil;
::

section::Arrays

link::Classes/Array::s of literals are created at compile time and are written with a # preceding the array as follows:
code::
#[1, 2, 'abc', "def", 4]
::
Literal Arrays must be used as is and may not be altered at run time.

In literal Arrays names are interpreted as symbols. This is not the case in regular Arrays, where they are interpreted as variable names:
code::
#[foo, bar]     // this is legal; an Array of Symbols
[foo, bar]      // this is only legal if foo and bar have been declared as variables
::
Arrays and other collections may also be created dynamically which is explained in link::Classes/Collection::.
Using a literal Array is faster than building an array dynamically every time you need it.

When nesting literal arrays, only the outermost literal array needs the '#' character.
code::
#[[1, 2, 3], [4, 5, 6]]
::

Literal Arrays can be useful for things such as tables of constants, for example note names:
code::
(
// build a table of note names
var table = ();
value {
    var semitones = [0, 2, 4, 5, 7, 9, 11];
    var naturalNoteNames = ["c", "d", "e", "f", "g", "a", "b"];

    (0..9).do {|o|
        naturalNoteNames.do {|c, i|
            var n = (o + 1) * 12 + semitones[i];
            table[(c ++ o).asSymbol] = n;
            table[(c ++ "s"  ++ o).asSymbol] = n + 1;
            table[(c ++ "ss" ++ o).asSymbol] = n + 2;
            table[(c ++ "b"  ++ o).asSymbol] = n - 1;
            table[(c ++ "bb" ++ o).asSymbol] = n - 2;
        };
    };
};

// translate note names to midi keys
table.atAll(#[c4, e4, gs4, c5, e5, gs5, c6])
)
::

section:: Compiler limits

There is no theoretical limit on the number of literals in a single function, if those literals are used as freestanding objects. (Of course, there remains the practical limits of system memory and the processor time required to keep track of all the objects.)

The following are a special category of literal, called emphasis::selectors::.

list::
## Class names
## Method names
## Function definitions (enclosed in curly braces code::{  }::)
::

Here, there are four selectors: code::SinOsc::, code::ar::, code::play:: and the entire function containing SinOsc.

code::{ SinOsc.ar(440, 0, 0.1) }.play;::

A single function may contain no more than 256 selectors. If this limit is exceeded, a compiler error is printed:

teletype::ERROR: Selector table too big: too many classes, method selectors or function definitions in this function. Simplify the function.::

note::
Code submitted for interactive execution is first compiled into a function. A very large block of code, spanning several thousand lines, may run into this limitation if it doesn't break down the tasks into smaller functions. In general, code is easier to maintain if it is reasonably emphasis::modular::, with small functions handling clearly-defined parts of the problem. This error message is a signal that the code has become too complex for a loose or "flat" code structure.
::

subsection:: What counts as "inside the function"?

Selectors are counted only toward the function definition currently being compiled.

code::
{ x.foo };

{ x.bar };
::

Both functions contain exactly one selector. They are separate functions. The use of "foo" in one function doesn't affect the number of selectors in another function.

code::
{
	var f = { |n|
		if(n > 1) { n * f.value(n-1) } { 1 }
	};

	f.value(10);
}.value;
::

The outer function includes only the selector code::value::. The other selectors -- code::>::, code::*::, code::-:: -- belong to the inner function definition and don't affect the outer function's number of selectors.

So, one possible easy way to work around the limitation is to break up a large block of code into several functions that are value'd successively:

code::
{
	... a bunch of code ...
}.value;

{
	... a bunch of code ...
}.value;

{
	... a bunch of code ...
}.value;
::


title:: Messages
summary:: Method calls, sending messages to objects
categories:: Language>OOP
related:: Reference/Classes, Classes/Class, Classes/Object, Guides/Intro-to-Objects, Guides/Polymorphism

section:: Introduction

Sending messages is the way things get done in an object oriented language. A message consists of a message selector which names the type of operation, a receiver to which the message is sent and in some cases a list of arguments which give additional information pertaining to the operation.
A message always returns a result. The kind of result depends on the kind of message. In the default case, the return value is the receiver itself.

Messages may be written using binary operators, functional notation or receiver notation.

section:: Binary operator messages

A binary operator selector is any string of characters from the list of legal binary operator characters:
code::
! @ % & * - + = | < > ? /
::

An exception is that no operator may begin with code:://:: or code::/*:: which are comment delimiters.

A binary operator expression consists of two expressions with a binary operator between them.
code::
1 + 2		// sum of one and two
a - b		// difference of a and b
x < 0.0		// answer whether x is less than zero
::

A binary operator can also be an identifier followed by a colon.
code::
10 rrand: 100
::

section:: Operator Precedence

There is none. All binary operators have the same level of precedence and associate from left to right.
For example, the expression:
code::
a * b + c * d
::
is equivalent to:
code::
((a * b) + c) * d
::
and not:
code::
(a * b) + (c * d)
::
Therefore it is usually better style to fully parenthesize your expressions.

section:: Functional notation messages

The message selector precedes the parenthesized argument list. The first argument in the list is actually
the receiver.
code::
sin(x)      // sine of x
max(a, b)   // maximum of a and b
::

section:: Receiver notation messages

A method call in functional notation may be converted to receiver notation by putting the receiver before the method name followed by a dot as shown below.
code::
max(a, b)

// is equivalent to:

a.max(b)

// and

sin(x)

// is equivalent to:

x.sin
::

another example:
code::
g(f(a, b), c)

// is equivalent to:

g(a.f(b), c)

// is equivalent to:

f(a, b).g(c)

// is equivalent to:

a.f(b).g(c)
::

section:: Default Argument Values

You may call a function or method with more or fewer arguments than it was declared to accept. If fewer arguments are passed, those arguments not passed are set to a default value if one is given in the method or function definition, or otherwise to nil.
If too many arguments are passed, the excess arguments are either collected into an Array or ignored depending on whether or not the function or method has an ellipsis argument (explained in link::Reference/Functions::).
When calling a method or function with zero arguments you can omit the parentheses:
code::
// x is declared to take two arguments a and b which default to 1 and 2 respectively.
// It returns their sum. This syntax will be explained in the section on Functions.
x = { arg a=1, b=2; a + b };

z = x.value;            // z is set to 3. (a defaults to 1, b defaults to 2)
z = x.value(10);        // z is set to 12. (a is 10, b defaults to 2)
z = x.value(10, 5);     // z is set to 15. (a is 10, b is 5)
z = x.value(10, 5, 9);  // z is set to 15. (a is 10, b is 5, 9 is ignored)
::

section:: Keyword Arguments

Arguments to Methods may be specified by the name by which they are declared in a method's definition. Such arguments are called keyword arguments.
Any argument may be passed as a keyword argument except for the receiver code::this::.
Keyword arguments must come after any normal (aka emphasis::positional::) arguments, and may be specified in any order.
If a keyword is specified and there is no matching argument then it is ignored and a warning will be printed. This warning may be turned off globally by making the following call:
code::
keywordWarnings(false)
::
If a keyword argument and a positional argument specify the same argument, then the keyword argument value overrides the positional argument value.

For example the code::ar:: class method of the SinOsc class takes arguments named freq, phase, mul, and add in that order. All of the following are legal calls to that method.
code::
SinOsc.ar(800, pi, 0.2, 0); // all normal arguments: freq, phase, mul, add

// freq = 800, mul = 0.2, others get default values.
SinOsc.ar(800, mul: 0.2);

// freq = 800, phase = pi, mul = 0.2, add gets its default value of zero.
SinOsc.ar(phase: pi, mul: 0.2, freq: 800);

// keyword value of 1200 overrides the positional arg value of 800
SinOsc.ar(800, freq: 1200);
::
code::
SinOsc.ar(zorg: 999); // invalid keyword prints warning
::
The arguments to a Function may also be specified by keyword arguments when using the 'value' message.
code::
// function args may be specified by keyword.
{ arg a=1, b=2, c=3; [a, b, c].postln }.value(b: 7, c: 8);
::
You may also use keyword arguments when using the 'perform' method.
code::
SinOsc.perform('ar', phase: pi, mul: 0.2, freq: 800);
::
subsection:: Cost of using keyword arguments

When using keyword arguments there is a runtime cost to do the matching that you should be aware of. The cost can be worth the convenience when speed is not critical.



title:: Modifier Keys
summary:: macOS Modifier key reference
categories:: GUI, Platform>macOS

note:: This document might be outdated.. ::

An integer bit field indicating the modifier keys in effect. You can examine individual flag settings using the C bitwise AND operator.

table::
## 65536 NSAlphaShiftKeyMask || Set if Caps Lock key is pressed.

## 131072 NSShiftKeyMask || Set if Shift key is pressed.

## 262144 NSControlKeyMask || Set if Control key is pressed.

## 524288 NSAlternateKeyMask || Set if Option or Alternate key is pressed.

## 1048576 NSCommandKeyMask || Set if Command key is pressed.

## 2097152 NSNumericPadKeyMask || Set if any key in the numeric keypad is pressed. The numeric keypad is generally on the right side of the keyboard.

## 4194304 NSHelpKeyMask || Set if the Help key is pressed.

## 8388608 NSFunctionKeyMask || Set if any function key is pressed. The function keys include the F keys at the top of most keyboards (F1, F2, and so on) and the navigation keys in the center of most keyboards (Help, Forward Delete, Home, End, Page Up, Page Down, and the arrow keys).

## Arrow keys || Arrow keys have an extra modifier value of 10485760 so for a shift arrow key do a bitwise 'or' with the shift mask: code::10485760 | 131072 = 10616832 // this is the mask for shift arrow key::
::

Three usage examples, direct and with helper methods code::isCaps::, code::isShift::, code::isCtrl::, code::isAlt::, code::isCmd::, code::isNumPad::, code::isHelp::, code::isFun:::

code::
(
w = Window.new.front; w.addFlowLayout;

	// direct, using bit field
Button(w, Rect(0,0,390,50)).states_([["hold shift/alt keys and click"]])
	.action_ { |but, mod|
		if (mod & 131072 == 131072) { "shift key was pressed.".postln; };
		if (mod & 524288 == 524288) { "alt key was pressed.".postln; };
	};

	// using helper methods
Button(w, Rect(0,0,390,50)).states_([["hold any mod keys and click"]])
	.action_ { |but, mod|
		if(mod.isCaps) { "mod pressed: Caps.".postln };
		if(mod.isShift) { "mod pressed: Shift.".postln };
		if(mod.isCtrl) { "mod pressed: Ctrl.".postln };
		if(mod.isAlt) { "mod pressed: Alt.".postln };
		if(mod.isNumPad) { "mod pressed: NumPad.".postln };
		if(mod.isHelp) { "mod pressed: Help.".postln };
		if(mod.isFun) { "mod pressed: Fun.".postln };
	};

	// collecting all modifiers
Button(w, Rect(0,0,390,50)).states_([["hold any mod keys and click"]])
	.action_ { |but, mod|
		var pressed;
		#[\isCaps, \isShift, \isCtrl, \isAlt, \isCmd, \isNumPad, \isHelp, \isFun].do { |x|
			if(mod.perform(x)) { pressed = pressed.add(x) }
		};
		pressed.postln;
	};
)
::


title:: NodeEvent
categories:: Streams-Patterns-Events
related:: Classes/Event
summary:: synth- and group- like interface of Event

description::
The methods link::Classes/Event#-synth:: and link::Classes/Event#-group:: set the parent event of the receiver to specialized events that duplicate the functionality of link::Classes/Synth:: and link::Classes/Group:: objects. These objects follow the naming conventions of patterns (i.e., groups and addActions are integer ID's) and have the same stop/play/pause/resume interface as the EventStreamPlayers created by Pattern-play. So, they can be used interchangeably with patterns in control schemes and GUI's.

The following example creates a group with nodeID = 2 and plays a synth within it.

code::
g = (id: 2).group;
g.play;
a = (group: 2).synth;
a.play;
g.release;
g.stop;
::

subsection::Interface

method:: play
starts synth or group, returns this.delta
method:: stop
if ev[\hasGate] == true set gate to 0, otherwise frees the node
method:: pause
disables the node
method:: resume
reenables the node
method:: set ( key, value)
sets control identified by key to value
method:: split
returns an array of events, one for each synth or group specified by the receiver
method:: map (key, busID)
maps control to control bus
method:: before (nodeID)
moves to immediately before nodeID
method:: after (nodeID)
moves to immediately after nodeID
method:: headOf (nodeID)
moves to immediately to head of nodeID
method:: tailOf (nodeID)
moves to immediately to tail of nodeID

subsection:: Multi-channel expansion
With the exception of ~server, ~latency, and ~instrument any key in the event can have an array as a
value and the standard rules of multi-channel expansion will be followed.

Examples::

code::
// Here is a simple example of its use:

// define a multiple Group event
g = (id: [2,3,4,5,6], group: 0, addAction: 1).group;
g.play; // play it

// make a Synth event
b = ( freq: [500,510], group: [2,3]).synth;
b.play;

b.set(\freq,[1000,1006]);

g.release;

b.play;
h = g.split;	// split into individual group events
c = b.split;	// and synth events
c[0].set(\freq,700);
c[1].set(\freq,400);

h[0].stop;
h[1].stop;

g.stop;
::


title:: NodeProxy roles
summary:: Roles in NodeProxy
categories:: JITLib>NodeProxy
related:: Classes/NodeProxy, Classes/Ndef, Classes/ProxySpace

Similar to Adverbs (see link::Guides/J-concepts-in-SC::), roles allow to specify how a source for a link::Classes/NodeProxy:: is being used. A role is an association of a link::Classes/Symbol:: and the new proxy source object.

The below examples can equally be used for link::Classes/Ndef:: and in link::Classes/ProxySpace::.

code::
// Thus, the following expressions behave in an equivalent way:

a = NodeProxy(s);
a[0] = ...

ProxySpace.push(s);
~a[0] = ...

Ndef(\a, ...)
::

section::Existing roles

definitionList::

## \set -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.

code::
a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;
(
a[1] = \set -> Pbind(
	\dur, Prand([1, 0.5], inf),
	\freq, Pwhite(200.0, 1000, inf),
	\rate, Pdup(4, Prand([1, 3, 6, 10], inf)),
	\dt, Pwhite(0.01, 0.1, inf)
)
);
// modify the source in the meanwhile:
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Dust.ar(rate * 10.dup), freq, dt)*0.1 };

a.nodeMap.postln; // the values are not set in the node map.
a.clear(3);
::

## \pset -> event pattern
|| set all proxy controls to event data

code::
a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;

(
a[1] = \pset -> Pbind(
	\dur, Prand([1, 0.5], inf),
	\freq, Pwhite(200.0, 1000, inf).round(30),
	\rate, Pdup(4, Prand([1, 3, 6, 10], inf)),
	\dt, Pwhite(0.01, 0.1, inf) + 1
)
);

a.nodeMap.postln; // the values are set in the node map.
::

## \xset -> event pattern
|| set all proxy controls to event data, using synth crossfade (see link::#-xset::).
code::

a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;

(
a[1] = \xset -> Pbind(
	\dur, Prand([1, 0.5], inf),
	\freq, Pwhite(200.0, 1000, inf).round(30),
	\rate, Pdup(4, Prand([1, 3, 6, 10], inf)),
	\dt, Pwhite(0.01, 0.1, inf) + 1
)
);

a.fadeTime = 2;
// modify the source in the meanwhile:
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Dust.ar(rate * 10.dup), freq, dt)*0.1 };

a.clear(3);
::

## \seti -> event pattern
|| Set the proxy controls for each channel in a multi-channel proxy with an event pattern of type code::\set::. Contrary to other roles it must be applied separately to each channel of the proxy.

CODE::
// 5-channel NodeProxy
a = NodeProxy.audio(s).mold(5);
// output will be stereo
b = NodeProxy.audio(s).play;

(
a[0] = {
	Blip.ar(
		\freq.kr([200, 201, 202, 204, 205]),
		\harms.kr([100, 100, 100, 100, 100])
	)
};

b[0] = {
    // mix 5 channel input to stereo panorama
	Splay.ar(\in.ar([0, 0, 0, 0, 0]), level: \amp.kr(0.7))
};
)

// route a out to b in
b <<> a;

// apply the role(s)
(
a.numChannels.do { |i|
	// a[0] holds the source!
	a[i+1] = \seti -> Pbind(
		\freq, Prand(#[62, 64, 67, 70, 72].midicps, inf),
		\harms, Pexprand(50, 1000),
		\dur, Prand(#[0.1, 0.2, 0.4], inf),
		// channelOffset is an offset, not a channel index
		\channelOffset, i
	)
}
)

// remove roles again
// either all at once or one by one
a.numChannels.do { |i| a[i+1] = nil };

a.clear; b.clear;
::

## \setbus -> event pattern
|| Set the proxy bus with an event pattern of type code::\c_set::

code::
a = NodeProxy(s);
b = NodeProxy(s).play;
b[0] = { SinOsc.ar(a.kr(4)).sum * 0.2 };
(
a[0] = \setbus -> Pbind(
	\dur, Prand([1, 0.5], inf),
	\value, Pfunc { var z = rrand(300, 4000); [300, 400, z, z + 30.rand2] }
)
);
// modify the other source in the meanwhile:
b[0] = { Pulse.ar(a.ar(4)).sum * 0.2 };

a.clear; b.clear;
::

## \setsrc -> event pattern
|| Set the proxy source at the next index with any object, controlled by a pattern. Note that any existing source at the next index (in the example below it is index 1) is overridden by the procedure.

code::
a = NodeProxy(s);
a.play;
(
a[0] = \setsrc -> Pbind(
	\dur, Prand([1, 0.5, 2], inf),
	\source, Prand ([
		{ SinOsc.ar(SinOsc.ar({5.rand}.dup + 4) * 50 + 400 + 50.rand) * 0.1 },
		{ SinOsc.ar(LFSaw.ar({5.rand}.dup + 4) * 50 + 400 + 50.rand) * 0.1},
		{ LFSaw.ar(SinOsc.ar({5.rand}.dup + 4) * 50 + 400 + 50.rand) * 0.1 },
		{ LFSaw.ar(LFSaw.ar({5.rand}.dup + 4) * 50 + 400 + 50.rand) * 0.1 }
	], inf)
)
);

a.clear(3);
::

## \filter -> function
|| Filter the audio on the proxy's own bus, using the first argument to pass in the sound. The function is any valid UGen function, which may be control or audio rate. Default controls are wet++index, where strong::index:: is the slot of the proxy (default 0), in the example below, the control is code::\wet1::, and it crossfades between the incoming sound source and the effect (wet) signal output.

code::
a = NodeProxy(s).play;
a[0] = { RLPF.ar(Dust2.ar(5!2), LFNoise2.kr(2!2).exprange(200, 5000), 0.05) };
a[1] = \filter -> { |in| CombL.ar(in, 0.2, LFNoise2.kr(0.5!2).exprange(0.01, 0.2), 3) };

a.set(\wet1, 0.2); // set dry/wet mix level to less combs
a.set(\wet1, 0.0); // wet 0 is all dry - cuts combs instantly.

a.clear(3);
::

## \filterIn -> function
|| Like code::\filter::, but the code::\wet:: control now sets the filter strong::input:: level, rather than its output. This lets time-based effects like delays, combs, filters with long ringtimes continue to sound even when the input is already turned off.

code::
a = NodeProxy(s).play;
a[0] = { RLPF.ar(Dust2.ar(5!2), LFNoise2.kr(2!2).exprange(200, 5000), 0.05) };
a[1] = \filterIn -> { |in| CombL.ar(in, 0.2, LFNoise2.kr(0.5!2).exprange(0.01, 0.2), 3) };


a.set(\wet1, 0.5); // set mix level to less effect signal
// wet 0 is all dry - input is off, but comb decay still sounds.
a.set(\wet1, 0.0);

a.clear(3);
::

## \mix -> function
|| Mix in the UGen in the function.

code::
a = NodeProxy(s);
a[0] = { PinkNoise.ar(0.1.dup) };
a.play;
a[1] = \mix -> { Dust.ar(30.dup) };
a.set(\mix1, 0.2);
a.clear(3);
::

::

section::Adding new roles

Roles can be added on the fly. They are kept in a dictionary ( strong::buildMethods:: ) in link::Classes/AbstractPlayControl::. A second dictionary ( strong::proxyControlClasses:: ) provides the wrapper class for a given key.

Here is a new role that allows you to set a control rate node proxy with the help of an event pattern. The new values are in a key named \value.

code::
// add the new role:
(
AbstractPlayControl.proxyControlClasses.put(\stream, PatternControl);
AbstractPlayControl.buildMethods.put(\stream,
	#{ arg pattern, proxy, channelOffset=0, index;
		Pbindf(
			pattern,
			\type, \bus,
			\id, Pfunc { proxy.group.nodeID },
			\array, Pkey(\value),
			\out, Pfunc { proxy.index }
		).buildForProxy( proxy, channelOffset, index )
});
)


// test:
a = NodeProxy.control(s);
a.source = \stream -> Pbind(\value, Pseq([1, 2, 3], inf), \dur, 1.5).trace;

b = NodeProxy(s);
b.source = { SinOsc.ar([340, 440] * a.kr) * 0.1 };
b.play;

a.source = \stream -> Pbind(\value, Pseq([1, 2, 3], inf) + Pwhite(0.0, 0.2, inf), \dur, 0.05);
b.source = { SinOsc.ar([5.6, 10.3] ** a.kr + 300) * 0.1 };
::


title:: Partial Application
summary:: Create Functions via Partial Application
categories:: Language
related:: Reference/Functions

Partial application is a way to create a function by passing only some arguments to a method. The code::_:: character stands in for missing arguments and becomes an argument to the created function.
It only applies to a single method, list, or dictionary call, not to a more complex nested expression.

for example:
code::
f = _ + 2;
::
f is now a function of one argument.
code::
f.value(7); // returns 9
::
it is equivalent to having written:
code::
f = {|x| x + 2 };
::
(except that there is no name 'x' declared)

code::
g = Point(_, _);
::
g is a function of two arguments.
code::
g.value(3, 4);
::

Here are some example usages of this in a collect message. Below each is written the equivalent function.
code::
(1..8).collect(_.isPrime);
(1..8).collect {|x| x.isPrime };

(1..8).collect(_.hash);
(1..8).collect {|x| x.hash };

(1..8).collect([\a, \b, _]);
(1..8).collect {|x| [\a, \b, x] };

(1..8).collect((a:_));
(1..8).collect {|x| (a:x) };

(1..8).collect(Polar(_, pi));
(1..8).collect {|x| Polar(x, pi) };

(1..8).collect((1.._));
(1..8).collect {|x| (1..x) };
::

code::
f = (a:_, b:_); // f is a two argument function
g = f.(_, 5);   // g is a partial application of f
g.(7);          // get the answer

// equivalent to this:
f = {|x, y| (a:x, b:y) }
g = {|z| f.(z, 5) };
g.value(7);
::

An example of what you can't do:
code::
(1..8).collect( Point(100 * _, 50) ); // nested expression won't work.
// only the * gets partially applied, not the surrounding expression.

(1..8).collect {|x| Point(100 * x, 50) }; // need to use a function for this.
::



title:: Resize behaviour
summary:: Resize behavior for View and its subclasses
categories:: GUI

section:: Description
method:: resize
The link::Classes/View#-resize:: method takes nine different values as argument defining the behavior of the view when the containing window is resized. Each view responds relatively to the stretches of its parent view.

table::
## 1 || 2 || 3
## 4 || 5 || 6
## 7 || 8 || 9
::

list::
## 1 - fixed to left, fixed to top
## 2 - horizontally elastic, fixed to top
## 3 - fixed to right, fixed to top

## 4 - fixed to left, vertically elastic
## 5 - horizontally elastic, vertically elastic
## 6 - fixed to right, vertically elastic

## 7 - fixed to left, fixed to bottom
## 8 - horizontally elastic, fixed to bottom
## 9 - fixed to right, fixed to bottom
::

section:: Examples

code::
// resize behaviours
// use the PopUpMenus to mix resize modes
(
var a;

a = { |i|
	var w, b, x,k,t,p;
	k=i;
	i = i + 1;
	w = Window("resize:"+i, Rect(10 + (k%3 * 220), Window.screenBounds.height- [250,460,670].at(k/3), 200, 180));
	b = w.view.bounds;
	x = CompositeView(w, w.view.bounds.insetBy(20,20))
		.background_(Color.rand)
		.resize_(i);

	y = CompositeView(x, x.bounds.moveTo(0,0).insetBy(20,20))
		.background_(Color.rand)
		.resize_(i);

	y.decorator = FlowLayout(y.bounds).gap_(0.0 @ 0.0);

	t = StaticText(y, Rect(0, 0, 40, 40))
		.background_(Color.rand.alpha_(0.8))
		.resize_(i)
		.string_(i)
		.font_(Font("Helvetica", 26));

	p=PopUpMenu(y,40@40).items_((1..9).collect(_.asString)).value_(i-1).resize_(i)
			.action_{|m| t.string_((m.value+1).asString); [p,t].do(_.resize_(m.value+1))};

	w.front;
	w.onClose = {a.do(_.close) };

} ! 9;
)


// the popupmenu contains the various modes

(
w = Window("soundfile test", Rect(200, 200, 720, 250));

p = PopUpMenu(w, Rect(10,10,80,24))
	.items_( Array.fill(9, {arg i; (i+1).asString;}) )
	.action_({ arg sbs;
		a.resize_(sbs.value+1);
	});

f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");

a = SoundFileView(w, Rect(10,40, 700, 180))
	.soundfile_(f)
	.readWithTask(0, f.numFrames, showProgress: false )
	.resize_(1);

w.front;
)
::


title:: SCDoc Syntax
summary:: SCDoc markup language syntax
categories:: HelpSystem
related:: Guides/WritingHelp, Classes/SCDoc, Classes/SCDocHTMLRenderer

section:: Introduction

This document specifies the syntax and link::#Grammar:: of the link::Classes/SCDoc:: markup language.
code::SCDoc Markup:: is used in SuperCollider mainly for helpfiles.
It is a syntax that features semantic a semantic level specific to the requirements of SuperCollider.

note::A guide to writing help can be found at link::Guides/WritingHelp::.::

section:: Specification

A document is split into a header section and a body. The header contains only header tags, which are not allowed in the document body.

SCDoc documents consist of EMPHASIS::tags:: and EMPHASIS::text::.


list::
## Tags consists of single words ending with teletype::\:::: (double-colon).
## Untagged text becomes plain prose.
## Paragraphs are separated by one or more empty lines.
## Tags are case-insensitive: teletype::TITLE\::::, teletype::Title\:::: and teletype::title\:::: are interepreted equally.
## Some tags take the remaining text on the same line as their argument
## Some tags enclose the following text until a single end-tag (double-colon teletype::\::::).
## Some enclosing tags can be nested, while others are modal and ignore any tag until an end-tag.
::


subsection:: Header tags
Header tags take the remaining text in their definition line as their argument.
They expect no end-tag.

definitionlist::
## keyword:: title\::
teletype:: TITLE\:: :: name
|| Title of the document. For class reference documents, this must be the same as the classname.

teletype::
title:: SCDoc
::

## keyword:: categories\::
teletype:: CATEGORIES\:: :: list
|| A comma-separated list of document categories. Mainly used by the link::Browse:: page.

Categories can be hierarchical, where levels are denoted with teletype::>::.

teletype::
categories:: External Control>OSC, Scheduling>Clocks
::

## keyword:: related\::
teletype:: RELATED\:: :: link(s)
|| A comma-separated list of related docs.

teletype::
related:: Classes/SCDoc, Reference/SCDocSyntax
::

## keyword:: summary\::
teletype:: SUMMARY\:: :: text
|| A short summary of this document.

teletype::
summary:: SCDoc markup language syntax
::

## keyword:: redirect\::
teletype:: REDIRECT\:: :: name
|| For class redirect systems, specify the name of the instance variable holding the implementing class.
Example:
teletype::
redirect:: implClass
::

## keyword:: class\::
teletype:: CLASS\:: :: name
|| Deprecated, use TITLE instead.
::

subsection:: Section tags
A document can be divided into sections and subsections. Section bodies consist of everything that follows its section tag until another section tag of same or higher level.

Sections have a link anchor with the same name as the section.
note::Method tags also create such anchors. The methodname then is prefixed with teletype::*:: (class methods) or teletype::-:: (instance methods).::

Structural tags at the same level in the hierarchy may be functionally equivalent but treated differently for rendering or querying purposes.
For example teletype::examples\:::: is equivalent to teletype::section\:::: but imply particular formatting or specially identify the examples section for customised uses like concatenating all examples for classes with a given parent class.

Structural tags can have child elements, for example the items in a list or the subsections and prose in a section.

Level 1 (highest):
definitionlist::
## keyword:: section\::
teletype:: SECTION\:: :: name
|| A named section. The name should be plain text and can not contain any tags.

teletype::
section:: Introduction
::
## keyword:: description\::
teletype:: DESCRIPTION\:: ::
## keyword:: classmethods\::
teletype:: CLASSMETHODS\:: ::
## keyword:: instancemethods\::
teletype:: INSTANCEMETHODS\:: ::
## keyword:: examples\::
teletype:: EXAMPLES\:: ::
|| These tags starts standard sections of a class reference. CLASSMETHODS and INSTANCEMETHODS have special meaning, in that they specify if a documented method is a classmethod or instancemethod.
::

Level 2:
definitionlist::
## keyword:: subsection\::
teletype:: SUBSECTION\:: :: name
|| A named subsection. The name should be plain text and can not contain any tags. Example:
teletype::
subsection:: Some more info
::
::

subsection:: Method tags
These are level 3 subsections:
definitionlist::
## keyword:: method\::
teletype:: METHOD\:: :: methodname(s) [argstring]
|| Document one or more methods, given as a comma-separated list of methodnames.

note::
If multiple methods are documented as a group, the methods must have the same argument name signature for existing arguments. For example, grouping the following methods would be ok:
teletype::
foo (a, b)
bar (a, b, c)
zoo (a)
::
But not:
teletype::
foo (a, x)
bar (a, b, c)
zoo (y)
::
::

Following the method tag should come a short description of the method, and optional description of the arguments and return value. See the link::#tags allowed inside a method:: section below.

SCDoc regards getter and setter methods as read/write interfaces for a single emphasis::property::. This means that you should not write the trailing underscore for setters. Instead, document it as a single property without the underscore, as if there was only a getter, and describe the property that can be set/gotten.

The METHOD tag is normally used inside CLASSMETHODS and INSTANCEMETHODS, but can also be used outside of these sections. In those cases, it documents a generic interface not bound to a specific class, and the arguments and default values should then be given in the optional strong::argstring::

For real methods, the argstring is not allowed, instead the argument names and default values will be auto-filled in.

## keyword:: private\::
teletype:: PRIVATE\:: :: methodname(s)
|| This tag behaves like a section but does not have a section body. It marks one or more methods as private, so that it does not show up under the auto-generated emphasis::Undocumented Methods:: sections. Expects a comma-separated list of methodnames.
## keyword:: copymethod\::
teletype:: COPYMETHOD\:: :: classname methodname
|| This tag behaves like a section but does not have a section body. Copy a method documentation from a class reference and insert it here as if the method was documented in this document. The methodname must be prefixed with teletype::*:: for classmethods and teletype::-:: for instancemethods.

teletype::
copymethod:: SinOsc *ar
::
::

anchor::tags allowed inside a method::
Inside a method section, the following optional tags are allowed, in the order given below.
These tags are level 4 subsections.
definitionlist::
## keyword:: argument\::
teletype:: ARGUMENT\:: :: [argname]
|| One for each argument. The argument section body should contain a description of the given argument.
The strong::argname:: is optional, and will be auto-filled in if not given. If given, it must match the real name of the argument at this position.

If the method has varargs, the argname for the varargs (if given) should be prefixed with three dots and a space (teletype::"... "::)
## keyword:: returns\::
teletype:: RETURNS\:: ::
|| This section should contain a description of the return value, especially the type.
## keyword:: discussion\::
teletype:: DISCUSSION\:: ::
|| This optional section can contain a more detailed discussion and code examples related to this method.
::


teletype::
method:: ar, kr
This is a nice method, try it out!
argument:: freq
The frequency of this thing as a floating point value.
argument:: amp
The amplitude, be careful. Goes to 11.
returns::
An UGen.
::

subsection:: Modal tags
These tags enclose a text and ends with a single teletype::\:::: (double-colon) end-tag.
The enclosed text can not contain any other tags.

definitionlist::
## keyword:: strong\::
teletype:: STRONG\:: ::
|| Render text in bold font.
## keyword:: emphasis\::
teletype:: EMPHASIS\:: ::
|| Render text in emphasized font, typically italics.
## keyword:: soft\::
teletype:: SOFT\:: ::
|| Render text in a soft shade.
## keyword:: link\::
teletype:: LINK\:: ::
|| Create a link to another document. The text should be the document key, which is the path relative the Help folder and without extension, like teletype::Classes/SinOsc:: or teletype::Reference/SCDocSyntax::

Optionally, the path can be followed by teletype::#anchor:: to jump to a specific place in the document, and teletype::#label:: to specify another label for the link.

All kinds of sections automatically creates an anchor with the same name as the section. Methods also creates an anchor, with the methodname prefixed with teletype::*:: for class methods and teletype::-:: for instance methods.

The path can be empty for linking to an anchor inside the current document, and the anchor can be empty to only specify the link label.

teletype::
See section link::#Introduction:: in this document.
Take a look at link::Classes/SCDoc#*indexAllDocuments::
Try link::Search#scdoc#Searching for SCDoc::,
or perhaps link::Classes/SinOsc##go make some music::
::

URL's are automagically turned into links, but can be explicitly created with this tag, if one wants to use another link label.

## keyword:: anchor\::
teletype:: ANCHOR\:: ::
|| Manually create an anchor at this position in the document.
## keyword:: image\::
teletype:: IMAGE\:: ::
|| Insert image, the text should be the relative path to the image.

teletype::
image::foo.png::
::
Optionally an image caption can be given:
teletype::
image::foo.png#Figure 1::
::

And, the image can be clickable and link to another page:
teletype::
image::foo.png#click this image#Classes/SinOsc::
::

Just leave the caption empty if you want a link but no caption.

::

The following tags (CODE and TELETYPE) can be written in two forms, either inline or block.
strong::Inline:: form has the end-tag on the same line, and need any enclosed double-colons that should be part of the text to be escaped with backslash (teletype:: \ ::).
strong::Block:: form has the tag and end-tag on lines by themselves, and can take multi-line text. In block form, only a single end-tag on its own line counts and any end-tags inside the text should not be escaped (except if it's on a single line).

teletype::
code:: inline form ::

code::
block form :: <- needs no escaping
can span multiple lines
\::
::

definitionlist::
## keyword:: code\::
teletype:: CODE\:: ::
|| Render syntax-colored SuperCollider code.
## keyword:: teletype\::
teletype:: TELETYPE\:: ::
|| Render monospace text.
::

subsection:: Lists and tables
List items, table rows and definition terms are denoted with teletype::##:: (double-hash).
Table cells and definition descriptions are denoted with teletype::||:: (double-bar).
Lists and tables can be nested, and ends with the end-tag.
definitionlist::
## keyword:: table\::
teletype:: TABLE\:: ::
|| Create a table. Example:
teletype::
table::
    ## a 1 || a 2 || a 3
    ## b 1 || b 2 || b 3
    ## c 1 || c 2 || c 3
\::
::
Renders:
table::
## a 1 || a 2 || a 3
## b 1 || b 2 || b 3
## c 1 || c 2 || c 3
::

## keyword:: definitionlist\::
teletype:: DEFINITIONLIST\:: ::
|| A definition list item consists of one or more terms prefixed with teletype::##:: followed by a description prefixed with teletype::||::. Example:
teletype::
definitionlist::
 	## foo
 	## bar
 	|| Common dummy-variable names.
 	## SuperCollider
 	|| A very nice computer software.
\::
::
## keyword:: list\::
teletype:: LIST\:: ::
|| Create a simple bulleted list. Items are prefixed with teletype::##::
## keyword:: numberedlist\::
teletype:: NUMBEREDLIST\:: ::
|| Create a numbered list. Items are prefixed with teletype::##::
## keyword:: tree\::
teletype:: TREE\:: ::
|| Create a tree structure. Typically nested with more TREE tags. Items are prefixed with teletype::##::
::

subsection:: Notes and warnings
These can have other tags in them, and ends with the end-tag.
definitionlist::
## keyword:: note\::
teletype:: NOTE\:: ::
|| Create a NOTE box with important content.
note:: like this ::
## keyword:: warning\::
teletype:: WARNING\:: ::
|| Create a WARNING box with very important content.
warning:: like this ::
## keyword:: footnote\::
teletype:: FOOTNOTE\:: ::
|| Create a footnote which will be rendered at the end of the document.
At the position of the FOOTNOTE tag, the footnote number will be rendered with a link to the footnote.
Example:
teletype::
Hello I'm a geek footnote::
According to http://en.wikipedia.org/wiki/Geek the word geek is a slang term, with different
meanings ranging from "a computer expert or enthusiast" to "a carnival performer who performs
sensationally morbid or disgusting acts"
\::
::
The result looks like this:
Hello I'm a geek footnote::
According to http://en.wikipedia.org/wiki/Geek the word geek is a slang term, with different meanings ranging from "a computer expert or enthusiast" to "a carnival performer who performs sensationally morbid or disgusting acts"
::

::

subsection:: Other tags
definitionlist::
## keyword:: keyword\::
teletype:: KEYWORD\:: :: keyword(s)
|| Specify one or more searchable keywords for this document.
An anchor named the keyword prefixed with teletype::kw_:: will be created at the position of this tag.
## keyword:: classtree\::
teletype:: CLASSTREE\:: :: classname
|| Render a class tree of subclasses starting from the given class.
::

section:: Grammar
The following is an exact specification of the grammar:
teletype::
start             ::= document
document          ::= START_FULL dochead optsections
                    | START_PARTIAL sections
                    | START_METADATA dochead optsections
dochead           ::= { headline } headline
headline          ::= ( headtag words2 | "CATEGORIES::" commalist | "RELATED::"
                      commalist ) eol
headtag           ::= "CLASS::"
                    | "TITLE::"
                    | "SUMMARY::"
                    | "REDIRECT::"
sectiontag        ::= "CLASSMETHODS::"
                    | "INSTANCEMETHODS::"
                    | "DESCRIPTION::"
                    | "EXAMPLES::"
optsections       ::= [ sections ]
sections          ::= sections section
                    | section
                    | subsubsections
section           ::= ( "SECTION::" words2 eol | sectiontag ) optsubsections
optsubsections    ::= [ subsections ]
subsections       ::= subsections subsection
                    | subsection
                    | subsubsections
subsection        ::= "SUBSECTION::" words2 eol optsubsubsections
optsubsubsections ::= [ subsubsections ]
subsubsections    ::= subsubsections subsubsection
                    | subsubsection
                    | body
subsubsection     ::= "METHOD::" methnames optMETHODARGS eol methodbody
                    | "COPYMETHOD::" words eol
                    | "PRIVATE::" commalist eol
optMETHODARGS     ::= [ METHODARGS ]
methnames         ::= { METHODNAME COMMA } METHODNAME
methodbody        ::= optbody optargs optreturns optdiscussion
optbody           ::= [ body ]
optargs           ::= [ args ]
args              ::= { arg } arg
arg               ::= "ARGUMENT::" ( words eol optbody | eol body )
optreturns        ::= [ "RETURNS::" body ]
optdiscussion     ::= [ "DISCUSSION::" body ]
body              ::= blockA
                    | blockB
blockA            ::= [ blockB | blockA ] bodyelem
blockB            ::= [ blockA ] prose
bodyelem          ::= rangetag body "::"
                    | listtag listbody "::"
                    | "TABLE::" tablebody "::"
                    | "DEFINITIONLIST::" deflistbody "::"
                    | blocktag wordsnl "::"
                    | "CLASSTREE::" words eol
                    | "KEYWORD::" commalist eol
                    | EMPTYLINES
                    | "IMAGE::" words2 "::"
prose             ::= { proseelem } proseelem
proseelem         ::= anyword
                    | URL
                    | inlinetag words "::"
                    | "FOOTNOTE::" body "::"
                    | NEWLINE
inlinetag         ::= "LINK::"
                    | "STRONG::"
                    | "SOFT::"
                    | "EMPHASIS::"
                    | "CODE::"
                    | "TELETYPE::"
                    | "ANCHOR::"
blocktag          ::= CODEBLOCK
                    | TELETYPEBLOCK
listtag           ::= "LIST::"
                    | "TREE::"
                    | "NUMBEREDLIST::"
rangetag          ::= "WARNING::"
                    | "NOTE::"
listbody          ::= { "##" body } "##" body
tablerow          ::= "##" tablecells
tablebody         ::= { tablerow } tablerow
tablecells        ::= { optbody "||" } optbody
defterms          ::= { "##" body } "##" body
deflistrow        ::= defterms "||" optbody
deflistbody       ::= { deflistrow } deflistrow
anywordurl        ::= anyword
                    | URL
anyword           ::= TEXT
                    | COMMA
words             ::= { anyword } anyword
words2            ::= { anywordurl } anywordurl
eol               ::= NEWLINE
                    | EMPTYLINES
anywordnl         ::= anyword
                    | eol
wordsnl           ::= { anywordnl } anywordnl
nocommawords      ::= nocommawords TEXT
                    | nocommawords URL
                    | TEXT
                    | URL
commalist         ::= { nocommawords COMMA } nocommawords
::



title:: Scoping and Closure
summary:: scoping of variables
categories:: Language

SuperCollider has nested scoping of variables. A function can refer not only to its own arguments and variables, but also to those declared in any enclosing (defining) contexts.

For example, the function defined below within makeCounter can access all of the arguments and variables declared in code::makeCounter::.
Other code can call the returned function at some later time and it can access and update the values contained in code::makeCounter:: at the time when the inner function was instantiated.
code::
(
var makeCounter;
makeCounter = { arg curVal=0, stepVal=1;
     // return a function :
    {
        var temp;
        // temp is local to this function, curVal & stepVal in the
        // enclosing function are referred to here within.
        temp = curVal;
        curVal = curVal + stepVal;
        temp                       // return result
    }
};

// Each invocation of makeCounter creates a new set of variables curVal and stepVal:

x = makeCounter.value(10, 1);
z = makeCounter.value(99, 100);
)
::

x and z are functions which refer to different instances of the variables curVal and stepVal
code::
x.value.postln; // posts 10
x.value.postln; // posts 11
z.value.postln; // posts 99
z.value.postln; // posts 199
x.value.postln; // posts 12
x.value.postln; // posts 13
z.value.postln; // posts 299
z.value.postln; // posts 399
::

Note that even though the function which defines curVal and stepVal has completed execution, its variables are still accessible to those functions that were defined within its context.
This is known as lexical closure, the capturing and availability of variables defined in outer contexts by inner contexts even when the outer contexts may have completed execution.



title:: Server Architecture
summary:: SuperCollider 3 Synth Server Architecture
categories:: Server>Architecture
related:: Classes/Server, Reference/Server-Command-Reference, Reference/AudioDeviceSelection

copyright © 2002 James McCartney
note:: Converted to new help system 2010 by Jonatan Liljedahl. Some stuff in this doc are outdated. ::

section:: Introduction

The SuperCollider 3 Synth Server is a simple but powerful synthesis engine. While synthesis is running, new modules can be created, destroyed and repatched, sample buffers can be created and reallocated. Effects processes can be created and patched into a signal flow dynamically at scheduled times.  All running modules are ordered in a tree of nodes that define an order of execution. Patching between modules is done through global audio and control buses.

All commands are received via TCP or UDP using a simplified version of link::Browse#OpenSoundControl#Open Sound Control:: (OSC). The synth server and its client(s) may be on the same machine or across a network. The synth server does not send or receive MIDI. It is expected that the client will send all control commands. If MIDI is desired, it is up to the client to receive it and convert it to appropriate OSC commands for the synth engine.

Synth definitions are stored in files generated by the SuperCollider language application. Unit generator definitions are Mach-O bundles (not to be confused with CFBundles). The Unit generator API is a simple C interface.

section:: Main Design Concepts

subsection:: Node
A Node is an addressable node in a tree of nodes run by the synth engine. There are two types, Synths and Groups. The tree defines the order of execution of all Synths. All nodes have an integer ID.

subsection:: Group
A Group is a collection of Nodes represented as a linked list. A new Node may be added to the head or tail of the group. The Nodes within a Group may be controlled together. The Nodes in a Group may be both Synths and other Groups. At startup there is a top level group with an ID of zero that defines the root of the tree. If the server was booted from within SCLang (as opposed to from the command line) there will also be a 'default group' with an ID of 1 which is the default target for all new Nodes. See link::Classes/RootNode:: and link::Reference/default_group:: for more info.

subsection:: Synth
A Synth is a collection of unit generators that run together. They can be addressed and controlled by commands to the synthesis engine. They read input and write output to global audio and control buses. Synths can have their own local controls that are set via commands to the server.

subsection:: Synth Definition
Synths are created from Synth Definitions. Synth Definition files are created by the SuperCollider language application and are loaded into the synth server. Synth Definitions are referred to by name.

subsection:: Audio Buses
Synths send audio signals to each other via a single global array of audio buses.  Audio buses are indexed by integers beginning with zero. Using buses rather than connecting synths to each other directly allows synths to connect themselves to the community of other synths without having to know anything about them specifically. The lowest numbered buses get written to the audio hardware outputs. Immediately following the output buses are the input buses, read from the audio hardware inputs. The number of bus channels defined as inputs and outputs do not have to match that of the hardware.

subsection:: Control Buses
Synths can send control signals to each other via a single global array of control buses.  Buses are indexed by integers beginning with zero.

subsection:: Buffers
Buffers are arrays of 32 bit floating point values with a small descriptive header. Buffers are stored in a single global array indexed by integers beginning with zero. Buffers may be safely allocated, loaded and freed while synthesis is running, even while unit generators are using them. Buffers are used for wave tables, sample buffers, delay lines, envelopes, or for any other need which can use an array of floating point values. Sound files may be loaded into or written from buffers.

subsection:: Unit Generator Definitions
Unit Generator Definitions are plug-ins loaded automatically when the program starts. They are binary code libraries that are used as building blocks by Synths to build synthesis algorithms. Unit Generator Definitions have names that match the names of SuperCollider language classes used in building Synth Definitions.


section:: Command Line Arguments

One of -u or -t must be supplied. Both may be supplied.
definitionlist::
## -u udp-port-number
|| a port number 0-65535.

## -t tcp-port-number
|| a port number 0-65535

## -v verbosity
|| Controls the verbosity of server messages. A value of 0 is normal behaviour. -1 suppresses informational messages. -2 suppresses informational and many error messages, as well as messages from Poll. The default is 0.

## -a num-audio-bus-channels
|| number of audio bus channels (default = 1024). The space allocated for audio buses is: (numchannels * (blocksize + 1) * 4)

## -i num-input-bus-channels
|| number of audio input bus channels (default = 8)

## -o num-output-bus-channels
|| number of audio output bus channels (default = 8)

## -c num-control-bus-channels
|| number of control bus channels (default = 16384). The space allocated for control buses is: (numchannels * 8)

## -b num-buffers
|| number of sample buffers (default = 1024)

## -n max-nodes
|| maximum number of nodes (default = 1024)

## -d max-synth-defs
|| maximum number of synth definitions (default = 1024)

## -D 1 or 0
|| if zero, then synth definitions will not be loaded on start up. (default = 1)

## -z block-size
|| The number of samples in one control period. (default = 64)

## -Z preferred-hardware-buffer-size
|| If non-zero, it will attempt to set the hardware buffer frame size. (default = 0)

## -S preferred-sample-rate
|| If non-zero, it will attempt to set the hardware sample rate. (default = 0)

## -m real-time-memory-size
|| The number of kilobytes of real time memory. This memory is used to allocate synths and any memory that unit generators themselves allocate. (default = 8192)

## -r random-number-generators
|| The number of seedable random number generators. (default = 64)

## -w max-interconnect-buffers
|| The maximum number of buffers that are allocated for buffers to interconnect unit generators. Sets the limit of complexity of synth defs that can be loaded at runtime. This value will be increased if a more complex synth-def is loaded at start up time, but it cannot be increased once synthesis has begun. (default = 64)

## -l max-logins
|| maximum number of named return addresses stored (default = 64). also maximum number of tcp connections accepted

## -p session-password
|| When using TCP, the session password must be the first command sent. The default is no password. UDP ports never require passwords, so if password protection is desired, use TCP.

## -H device-name
## -H input-device-name output-device-name
|| name of the hardware I/O device. If not provided, the default device is used. See link::Reference/AudioDeviceSelection:: for more details.
note::
To specify only input device and use default output, or only output device and use default input, use an empty string: code::'-H "" output-device-name':: or code::'-H input-device-name ""'::
::

## -I input-streams-enable-string
|| Allows turning off input streams that you are not interested in on the device. If the string is 01100, for example, then only the second and third input streams on the device will be enabled. Turning off streams can reduce CPU load.

## -O output-streams-enable-string
|| Allows turning off output streams that you are not interested in on the device. If the string is 11000, for example, then only the first two output streams on the device will be enabled. Turning off streams can reduce CPU load.

## -N cmd-filename input-filename output-filename sample-rate header-format sample-format
|| Run in non-real-time mode.

The cmd-filename should be a file that contains OSC bundles sorted in ascending time order. If cmd-filename is the underscore character _, then OSC will be streamed from standard input.

The audio input will taken from input-filename. If input-filename is the underscore character _, then no input file will be read.

Output will be written to output-filename.

The output file's sample rate is specified by sample-rate. The output file header-format should be one of: AIFF, WAVE, NeXT. The output file sample-format should be one of: int16, int24, int32, float, double. The number of channels in the output file is specified with the -o argument.
::

subsection:: Example
code::
scsynth -u 57117 >synth_log &

	Accept commands via UDP on port 57117.
	Send output to file "synth_log"
	Run asynchronously: &.

scsynth -N score.osc _ out.aiff 48000 AIFF int24

	Run in non real time mode with command file score.osc,
	no input file, and output file named out.aiff.
	Sample rate is 48000. Output file header format is aiff,
	sample format is 24 bit integer.
::

section:: Binary Format of Messages

Messages are similar in format to Open Sound Control messages, except that pattern matching of the command name is not performed. When streamed via TCP, messages are each preceded by a 32 bit integer giving the length in bytes of the message. UDP datagrams contain this length information already.

subsection:: Types
All values are in network byte order.
table::
## long || a 64 bit integer. Used for time stamps only.
## int || a 32 bit integer.
## float || a 32 bit single precision floating point number.
## double || a 64 bit double precision floating point number.
## string || an OSC format string: 8 bit ASCII characters, zero padded to a multiple of 4 bytes.
## bytes || a buffer of data preceded by a 32 bit length field and padded to a multiple of 4 bytes.
::

subsection:: Tags
Command arguments have single character tags which occur in a tag string to identify their types.
table::
## 'i' || an int
## 'f' || a float
## 's' || a string
## 'b' || bytes
## 'd' || a double
## 't' || a timestamp
::

subsection:: Command
a Command consists of:
table::
## string || the command name. See the Command Reference below.
## string || a string with tags defined by the types of the arguments to follow. The tag string begins with a comma ',' character.
## ... || any combination of arguments of types: int, float, string or bytes.
::

subsection:: Bundle
a Bundle consists of:
table::
## time stamp || long. Time stamps are in the same format as defined by Open Sound Control :  The top 32 bits are seconds since 1900 and the lower 32 bits represent the 32 bit fraction of one second.
## ... || a series of Commands each preceded by a 32-bit integer byte length.
::

subsection:: Message
a Message consists of:

definitionlist::
## using UDP ||
    list::
    ## one Bundle or one Command.
    ::
## using TCP ||
    list::
    ## int32 - the length in bytes of the following message.
	## one Bundle or one Command.
	::
::

section:: Glossary
definitionlist::
## buffer || a header and array of floating point sample data. Buffers are used for sound files, delay lines, arrays of global controls, and arrays of inter-synth patch points.

## group || a linked list of nodes. groups provide ways to control execution of many nodes at once. a group is a kind of node.

## MIDI || a protocol for sending music control data between synthesizers.

## node || an object in a tree of objects executed in a depth first traversal order by the synth engine. There are two types of nodes, synths and groups.

## Open Sound Control || a protocol defined by CNMAT at UCBerkeley for controlling synthesizers. See http://cnmat.cnmat.berkeley.edu/OSC/ .

## OSC || see Open Sound Control.

## synth || a sound processing module. Similar to "voice " in other systems. Synths are referred to by a number.

## synth definition || a definition for creating new synths. similar to "instrument" in other systems.

## TCP || a protocol for streaming data over a network.

## UDP || a protocol for sending datagrams over a network.
::



title:: Server Command Reference
summary:: SuperCollider Server Synth Engine Command Reference
categories:: Server>Architecture

The following is a list of all server commands and their arguments.

Each command has a command number which can be sent to the server as a 32 bit integer instead of an OSC style string. Command numbers are listed at the end of this document.

If a command's description contains the word strong::Asynchronous::, then that command will be passed to a background thread to complete so as not to steal CPU time from the audio synthesis thread. All asynchronous commands send a reply to the client when they are completed. Many asynchronous commands can contain an OSC message or bundle to be executed upon completion. eg.
code::
    ["/d_load", "synthdefs/void.scsyndef",
        ["/s_new", "void", 1001, 1, 0] // completion message
    ]
::

section:: Top-Level Commands

subsection:: /quit

Quit program. Exits the synthesis server.

definitionlist::
## Asynchronous. || Replies to sender with strong::/done:: just before completion.
::

subsection:: /notify
Register to receive notifications from server
table::
## strong::int:: || 1 to receive notifications, 0 to stop receiving them.
## strong::int:: || client ID (optional)
::
If the first argument is 1, server will remember your return address and send you notifications; if 0, server will stop sending notifications.

definitionlist::
## Asynchronous. || Replies to sender with strong::/done /notify clientID [maxLogins]:: when complete. If this client has registered for notifications before, this may be the same ID. Otherwise it will be a new one. Clients can use this ID in multi-client situations to avoid conflicts when allocating resources such as node IDs, bus indices, and buffer numbers. strong::maxLogins:: is only returned when the client ID argument is supplied in this command. strong::maxLogins:: is not supported by supernova.
::

subsection:: /status

Query the status. Replies to sender with the following message:
definitionlist::
## /status.reply || table::
## int || 1. unused.
## int || number of unit generators.
## int || number of synths.
## int || number of groups.
## int || number of loaded synth definitions.
## float || average percent CPU usage for signal processing
## float || peak percent CPU usage for signal processing
## double || nominal sample rate
## double || actual sample rate
::

note:: teletype::/status:: messages won't be posted, if the server is in teletype::/dumpOSC:: mode::

::

subsection:: /cmd
Plug-in defined command.
table::
## strong::string:: || command name
## strong::...:: || any arguments
::
Commands are defined by plug-ins.

subsection:: /dumpOSC
Display incoming OSC messages.
table::
## strong::int:: || code
::
Turns on and off printing of the contents of incoming Open Sound Control messages. This is useful when debugging your command stream.

The values for the code are as follows:
table::
## 0 || turn dumping OFF.
## 1 || print the parsed contents of the message.
## 2 || print the contents in hexadecimal.
## 3 || print both the parsed and hexadecimal representations of the contents.
::

subsection:: /sync
Notify when async commands have completed.
table::
## strong::int:: || a unique number identifying this command.
::
Replies with a strong::/synced:: message when all asynchronous commands received before this one have completed. The reply will contain the sent unique ID.

definitionlist::
## Asynchronous. || Replies to sender with strong:: /synced, ID :: when complete.
::

subsection:: /clearSched

Clear all scheduled bundles. Removes all bundles from the scheduling queue.

subsection:: /error
Enable/disable error message posting.
table::
## strong::int:: || mode
::
Turn on or off error messages sent to the SuperCollider post window. Useful when sending a message, such as strong::/n_free::, whose failure does not necessarily indicate anything wrong.

The values for mode are as follows:
table::
## 0 || turn off error posting until the next ['/error', 1] message.
## 1 || turn on error posting.
::
For convenience of client-side methods, you can also suppress errors temporarily, for the scope of a single bundle.
table::
## -1 || turn off locally in the bundle -- error posting reverts to the "permanent" setting for the next message or bundle.
## -2 || turn on locally in the bundle.
::
These "temporary" states accumulate within a single bundle -- so if you have nested calls to methods that use bundle-local error suppression, error posting remains off until all the layers have been unwrapped.
If you use ['/error', -1] within a self-bundling method, you should always close it with ['/error', -2] so that subsequent bundled messages will take the correct error posting status.
However, even if this is not done, the next bundle or message received will begin with the standard error posting status, as set by modes 0 or 1.

Temporary error suppression may not affect asynchronous commands in every case.

subsection:: /version

Query the SuperCollider version. Replies to sender with the following message:
definitionlist::
## /version.reply || table::
## string || Program name. May be "scsynth" or "supernova".
## int || Major version number. Equivalent to sclang's code::Main.scVersionMajor::.
## int || Minor version number. Equivalent to sclang's code::Main.scVersionMinor::.
## string || Patch version name. Equivalent to the sclang code code::"." ++ Main.scVersionPatch ++ Main.scVersionTweak::.
## string || Git branch or tag name.
## string || First seven hex digits of the commit hash.
::
::

The standard human-readable version string can be constructed by concatenating code:: major_version ++ "." ++ minor_version ++ patch_version ::. Since version information is easily accessible to sclang users via the methods described above, this command is mostly useful for alternate clients.

The git branch/tag name and commit hash could be anything if the user has forked SC, so they should only be used for display and user interface purposes.

section:: Synth Definition Commands

subsection:: /d_recv
Receive a synth definition file.
table::
## strong::bytes:: || buffer of data.
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Loads a file of synth definitions from a buffer in the message. Resident definitions with the same names are overwritten.

definitionlist::
## Asynchronous. || Replies to sender with strong::/done:: when complete.
::

subsection:: /d_load
Load synth definition.
table::
## strong::string:: || pathname of file. Can be a pattern like code:: "synthdefs/perc-*" ::
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Loads a file of synth definitions. Resident definitions with the same names are overwritten.

definitionlist::
## Asynchronous. || Replies to sender with strong::/done:: when complete.
::

subsection:: /d_loadDir
Load a directory of synth definitions.
table::
## strong::string:: || pathname of directory.
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Loads a directory of synth definitions files. Resident definitions with the same names are overwritten.

definitionlist::
## Asynchronous. || Replies to sender with strong::/done:: when complete.
::

subsection:: /d_free
Delete synth definition.
table::
## N * strong::string:: || synth def name
::

Removes a synth definition. The definition is removed immediately, and does not wait for synth nodes based on that definition to end.

section:: Node Commands

subsection:: /n_free
Delete a node.
table::
## N * strong::int:: || node ID
::

Stops a node abruptly, removes it from its group, and frees its memory. A list of node IDs may be specified. Using this method can cause a click if the node is not silent at the time it is freed.

subsection:: /n_run
Turn node on or off.
table::
## N * || table::
    ## strong::int:: || node ID
    ## strong::int:: || run flag
    ::
::
list::
## If the run flag set to zero then the node will not be executed.
## If the run flag is set back to one, then it will be executed.
::
Using this method to start and stop nodes can cause a click if the node is not silent at the time run flag is toggled.

subsection:: /n_set
Set a node's control value(s).
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::float:: or strong::int:: || a control value
    ::
::

Takes a list of pairs of control indices and values and sets the controls to those values. If the node is a group, then it sets the controls of every node in the group.

This message now supports array type tags ($[ and $]) in the control/value component of the OSC message.  Arrayed control values are applied in the manner of n_setn (i.e., sequentially starting at the indexed or named control).

subsection:: /n_setn
Set ranges of a node's control value(s).
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || number of sequential controls to change (M)
    ## M * strong::float:: or strong::int:: || control value(s)
    ::
::

Set contiguous ranges of control indices to sets of values. For each range, the starting control index is given followed by the number of controls to change, followed by the values. If the node is a group, then it sets the controls of every node in the group.

subsection:: /n_fill
Fill ranges of a node's control value(s).
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || number of values to fill (M)
    ## strong::float:: or strong::int:: || value
    ::
::

Set contiguous ranges of control indices to single values. For each range, the starting control index is given followed by the number of controls to change, followed by the value to fill. If the node is a group, then it sets the controls of every node in the group.

subsection:: /n_map
Map a node's controls to read from a bus.
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || control bus index
    ::
::

Takes a list of pairs of control names or indices and bus indices and causes those controls to be read continuously from a global control bus. If the node is a group, then it maps the controls of every node in the group. If the control bus index is -1 then any current mapping is undone. Any n_set, n_setn and n_fill command will also unmap the control.

subsection:: /n_mapn
Map a node's controls to read from buses.
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || control bus index
    ## strong::int:: || number of controls to map
    ::
::

Takes a list of triplets of control names or indices, bus indices, and number of controls to map and causes those controls to be mapped sequentially to buses. If the node is a group, then it maps the controls of every node in the group. If the control bus index is -1 then any current mapping is undone. Any n_set, n_setn and n_fill command will also unmap the control.

subsection:: /n_mapa
Map a node's controls to read from an audio bus.
table::
## strong::int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || audio bus index
    ::
::

Takes a list of pairs of control names or indices and audio bus indices and causes those controls to be read continuously from a global audio bus. If the node is a group, then it maps the controls of every node in the group. If the audio bus index is -1 then any current mapping is undone. Any n_set, n_setn and n_fill command will also unmap the control. For the full audio rate signal, the argument must have its rate set to \ar.

subsection:: /n_mapan
Map a node's controls to read from audio buses.
table::
## strong:: int:: || node ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || audio bus index
    ## strong::int:: || number of controls to map
    ::
::

Takes a list of triplets of control names or indices, audio bus indices, and number of controls to map and causes those controls to be mapped sequentially to buses. If the node is a group, then it maps the controls of every node in the group. If the audio bus index is -1 then any current mapping is undone. Any n_set, n_setn and n_fill command will also unmap the control. For the full audio rate signal, the argument must have its rate set to \ar.

subsection:: /n_before
Place a node before another.
table::
## N * || table::
    ## strong::int:: || the ID of the node to place (A)
    ## strong::int:: || the ID of the node before which the above is placed (B)
    ::
::
Places node A in the same group as node B, to execute immediately before node B.

subsection:: /n_after
Place a node after another.
table::
## N * || table::
    ## strong::int:: || the ID of the node to place (A)
    ## strong::int:: || the ID of the node after which the above is placed (B)
    ::
::
Places node A in the same group as node B, to execute immediately after node B.

subsection:: /n_query
Get info about a node.
table::
## N * strong::int:: || node ID
::
The server sends an /n_info message for each node to registered clients.
See Node Notifications below for the format of the /n_info message.

subsection:: /n_trace
Trace a node.
table::
## N * strong::int:: || node IDs
::

Causes a synth to print out the values of the inputs and outputs of its unit generators for one control period. Causes a group to print the node IDs and names of each node in the group for one control period.

subsection:: /n_order
Move and order a list of nodes.
table::
## strong::int:: || add action (0,1,2 or 3 see below)
## strong::int:: || add target ID
## N * strong::int:: || node IDs
::

Move the listed nodes to the location specified by the target and add action, and place them in the order specified. Nodes which have already been freed will be ignored.
definitionlist::
## add actions: || table::
    ## 0 || construct the node order at the head of the group specified by the add target ID.
    ## 1 || construct the node order at the tail of the group specified by the add target ID.
    ## 2 || construct the node order just before the node specified by the add target ID.
    ## 3 || construct the node order  just after the node specified by the add target ID.
    ::
::

section:: Synth Commands

subsection:: /s_new
Create a new synth.
table::
## strong::string:: || synth definition name
## strong::int:: || synth ID
## strong::int:: || add action (0,1,2, 3 or 4 see below)
## strong::int:: || add target ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
	## strong::float:: or strong::int:: or strong::string::|| floating point and integer arguments are interpreted as control value.
                                                              a symbol argument consisting of the letter 'c' or 'a' (for control or audio) followed by the bus's index.
    ::
::

Create a new synth from a synth definition, give it an ID, and add it to the tree of nodes. There are four ways to add the node to the tree as determined by the add action argument which is defined as follows:
definitionlist::
## add actions: || table::
    ## 0 || add the new node to the head of the group specified by the add target ID.
    ## 1 || add the new node to the tail of the group specified by the add target ID.
    ## 2 || add the new node just before the node specified by the add target ID.
    ## 3 || add the new node just after the node specified by the add target ID.
    ## 4 || the new node replaces the node specified by the add target ID. The target node is freed.
    ::
::
Controls may be set when creating the synth. The control arguments are the same as for the n_set command.

If you send strong::/s_new:: with a synth ID of -1, then the server will generate an ID for you. The server reserves all negative IDs. Since you don't know what the ID is, you cannot talk to this node directly later. So this is useful for nodes that are of finite duration and that get the control information they need from arguments and buses or messages directed to their group. In addition no notifications are sent when there are changes of state for this node, such as strong::/go::, strong::/end::, strong::/on::, strong::/off::.

If you use a node ID of -1 for any other command, such as strong::/n_map::, then it refers to the most recently created node by strong::/s_new:: (auto generated ID or not). This is how you can map  the controls of a node with an auto generated ID. In a multi-client situation, the only way you can be sure what node -1 refers to is to put the messages in a bundle.

This message now supports array type tags ($[ and $]) in the control/value component of the OSC message.  Arrayed control values are applied in the manner of n_setn (i.e., sequentially starting at the indexed or named control). See the link::Guides/NodeMessaging:: helpfile.

subsection:: /s_get
Get control value(s).
table::
## strong::int:: || synth ID
## N * strong::int:: or strong::string:: || a control index or name
::

Replies to sender with the corresponding strong::/n_set:: command.

subsection:: /s_getn
Get ranges of control value(s).
table::
## strong::int:: || synth ID
## N * || table::
    ## strong::int:: or strong::string:: || a control index or name
    ## strong::int:: || number of sequential controls to get (M)
    ::
::
Get contiguous ranges of controls. Replies to sender with the corresponding strong::/n_setn:: command.

subsection:: /s_noid
Auto-reassign synth's ID to a reserved value.
table::
## N * strong::int:: || synth IDs
::

This command is used when the client no longer needs to communicate with the synth and wants to have the freedom to reuse the ID. The server will reassign this synth to a reserved negative number. This command is purely for bookkeeping convenience of the client. No notification is sent when this occurs.

section:: Group Commands

subsection:: /g_new
Create a new group.
table::
## N * || table::
    ## strong::int:: || new group ID
    ## strong::int:: || add action (0,1,2, 3 or 4 see below)
    ## strong::int:: || add target ID
    ::
::

Create a new group and add it to the tree of nodes.
There are four ways to add the group to the tree as determined by the add action argument which is defined as follows (the same as for strong::/s_new::):
definitionlist::
## add actions: || table::
    ## 0 || add the new group to the head of the group specified by the add target ID.
    ## 1 || add the new group to the tail of the group specified by the add target ID.
    ## 2 || add the new group just before the node specified by the add target ID.
    ## 3 || add the new group just after the node specified by the add target ID.
    ## 4 || the new node replaces the node specified by the add target ID. The target node is freed.
    ::
::
Multiple groups may be created in one command by adding arguments.

subsection:: /p_new
Create a new parallel group.
table::
## N * || table::
    ## strong::int:: || new group ID
    ## strong::int:: || add action (0,1,2, 3 or 4 see below)
    ## strong::int:: || add target ID
    ::
::
Create a new parallel group and add it to the tree of nodes. Parallel groups are relaxed groups, their child nodes are evaluated in unspecified order.
There are four ways to add the group to the tree as determined by the add action argument which is defined as follows (the same as for strong::/s_new::):
definitionlist::
## add actions: || table::
    ## 0 || add the new group to the head of the group specified by the add target ID.
    ## 1 || add the new group to the tail of the group specified by the add target ID.
    ## 2 || add the new group just before the node specified by the add target ID.
    ## 3 || add the new group just after the node specified by the add target ID.
    ## 4 || the new node replaces the node specified by the add target ID. The target node is freed.
    ::
::
Multiple groups may be created in one command by adding arguments.

subsection:: /g_head
Add node to head of group.
table::
## N * || table::
    ## strong::int:: || group ID
    ## strong::int:: || node ID
    ::
::

Adds the node to the head (first to be executed) of the group.

subsection:: /g_tail
Add node to tail of group.
table::
## N * || table::
    ## strong::int:: || group ID
    ## strong::int:: || node ID
    ::
::
Adds the node to the tail (last to be executed) of the group.

subsection:: /g_freeAll
Delete all nodes in a group.
table::
## N * strong::int:: || group ID(s)
::
Frees all nodes in the group. A list of groups may be specified.

subsection:: /g_deepFree
Free all synths in this group and all its sub-groups.
table::
## N * strong::int:: || group ID(s)
::
Traverses all groups below this group and frees all the synths. Sub-groups are not freed. A list of groups may be specified.

subsection:: /g_dumpTree
Post a representation of this group's node subtree.
table::
## N * || table::
    ## strong::int:: || group ID
    ## strong::int:: || flag; if not 0 the current control (arg) values for synths will be posted
    ::
::

Posts a representation of this group's node subtree, i.e. all the groups and synths contained within it, optionally including the current control values for synths.

subsection:: /g_queryTree
Get a representation of this group's node subtree.
table::
## N * || table::
    ## strong::int:: || group ID
    ## strong::int:: || flag: if not 0 the current control (arg) values for synths will be included
    ::
::
Request a representation of this group's node subtree, i.e. all the groups and synths contained within it. Replies to the sender with a strong::/g_queryTree.reply:: message listing all of the nodes contained within the group in the following format:
table::
## strong::int:: || flag: if synth control values are included 1, else 0
## strong::int:: || node ID of the requested group
## strong::int:: || number of child nodes contained within the requested group
## then for each node in the subtree: || table::
    ## strong::int:: || node ID
    ## strong::int:: || number of child nodes contained within this node. If -1 this is a synth, if >=0 it's a group
    ## then, if this node is a synth:
    ## strong::symbol:: || the SynthDef name for this node.
	## then, if flag (see above) is true:
    ## strong::int:: || numControls for this synth (M)
    ## M * || table::
        ## strong::symbol:: or strong::int:: || control name or index
        ## strong::float:: or strong::symbol:: || value or control bus mapping symbol (e.g. 'c1')
        ::
    ::
::

N.B. The order of nodes corresponds to their execution order on the server. Thus child nodes (those contained within a group) are listed immediately following their parent. See the method Server:queryAllNodes for an example of how to process this reply.

section:: Unit Generator Commands

subsection:: /u_cmd
Send a command to a unit generator.
table::
## strong::int:: || node ID
## strong::int:: || unit generator index
## strong::string:: || command name
## strong::...:: || any arguments
::
Sends all arguments following the command name to the unit generator to be performed. Commands are defined by unit generator plug ins.

section:: Buffer Commands

Buffers are stored in a global array, indexed by integers starting at zero.

subsection:: /b_alloc
Allocate buffer space.
table::
## strong::int:: || buffer number
## strong::int:: || number of frames
## strong::int:: || number of channels (optional. default = 1 channel)
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Allocates zero filled buffer to number of channels and samples.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_alloc bufNum:: when complete.
::

subsection:: /b_allocRead
Allocate buffer space and read a sound file.
table::
## strong::int:: || buffer number
## strong::string:: || path name of a sound file.
## strong::int:: || starting frame in file (optional. default = 0)
## strong::int:: || number of frames to read (optional. default = 0, see below)
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Allocates buffer to number of channels of file and number of samples requested, or fewer if sound file is smaller than requested. Reads sound file data from the given starting frame in the file. If the number of frames argument is less than or equal to zero, the entire file is read.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_allocRead bufNum:: when complete.
::

subsection:: /b_allocReadChannel
Allocate buffer space and read channels from a sound file.
table::
## strong::int:: || buffer number
## strong::string:: || path name of a sound file
## strong::int:: || starting frame in file
## strong::int:: || number of frames to read
## N * || N >= 0
    table::
    ## strong::int:: || source file channel index
    ::
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::

As b_allocRead, but reads individual channels into the allocated buffer in the order specified. If the channels argument is absent or empty all channels are read in the order they appear in the file.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_allocReadChannel bufNum:: when complete.
::


subsection:: /b_read
Read sound file data into an existing buffer.
table::
## strong::int:: || buffer number
## strong::string:: || path name of a sound file.
## strong::int:: || starting frame in file (optional. default = 0)
## strong::int:: || number of frames to read (optional. default = -1, see below)
## strong::int:: || starting frame in buffer (optional. default = 0)
## strong::int:: || leave file open (optional. default = 0)
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Reads sound file data from the given starting frame in the file and writes it to the given starting frame in the buffer. If number of frames is less than zero, the entire file is read.
If reading a file to be used by link::Classes/DiskIn:: ugen then you will want to set "leave file open" to one, otherwise set it to zero.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_read bufNum:: when complete.
::


subsection:: /b_readChannel
Read sound file channel data into an existing buffer.
table::
## strong::int:: || buffer number
## strong::string:: || path name of a sound file
## strong::int:: || starting frame in file
## strong::int:: || number of frames to read
## strong::int:: || starting frame in buffer
## strong::int:: || leave file open
## N * || N >= 0
    table::
    ## strong::int:: || source file channel index
    ::
## strong::bytes:: || completion message
::

As strong::b_read::, but reads individual channels in the order specified. The number of channels requested must match the number of channels in the buffer.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_readChannel bufNum:: when complete.
::


subsection:: /b_write
Write sound file data.
table::
## strong::int:: || buffer number
## strong::string:: || path name of a sound file.
## strong::string:: || header format.
## strong::string:: || sample format.
## strong::int:: || number of frames to write (optional. default = -1, see below)
## strong::int:: || starting frame in buffer (optional. default = 0)
## strong::int:: || leave file open (optional. default = 0)
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::

Write a buffer as a sound file.
definitionlist::
## Header format is one of: || "aiff", "next", "wav", "ircam"", "raw"
## Sample format is one of: || "int8", "int16", "int24", "int32", "float", "double", "mulaw", "alaw"
::
Not all combinations of header format and sample format are possible.
If number of frames is less than zero, all samples from the starting frame to the end of the buffer are written.
If opening a file to be used by DiskOut ugen then you will want to set "leave file open" to one, otherwise set it to zero. If "leave file open" is set to one then the file is created, but no frames are written until the DiskOut ugen does so.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_write bufNum:: when complete.
::


subsection:: /b_free
Free buffer data.
table::
## strong::int:: || buffer number
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Frees buffer space allocated for this buffer.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_free bufNum:: when complete.
::


subsection:: /b_zero
Zero sample data.
table::
## strong::int:: || buffer number
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
Sets all samples in the buffer to zero.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_zero bufNum:: when complete.
::


subsection:: /b_set
Set sample value(s).
table::
## strong::int:: || buffer number
## N * || table::
    ## strong::int:: || a sample index
    ## strong::float:: || a sample value
    ::
::
Takes a list of pairs of sample indices and values and sets the samples to those values.

subsection:: /b_setn
Set ranges of sample value(s).
table::
## strong::int:: || buffer number
## N * || table::
    ## strong::int:: || sample starting index
    ## strong::int:: || number of sequential samples to change (M)
    ## M * strong::float:: || a sample value
    ::
::
Set contiguous ranges of sample indices to sets of values. For each range, the starting sample index is given followed by the number of samples to change, followed by the values.

subsection:: /b_fill
Fill ranges of sample value(s).
table::
## strong::int:: || buffer number
## N * || table::
    ## strong::int:: || sample starting index
    ## strong::int:: || number of samples to fill (M)
    ## strong::float:: || value
    ::
::
Set contiguous ranges of sample indices to single values. For each range, the starting sample index is given followed by the number of samples to change, followed by the value to fill. This is only meant for setting a few samples, not whole buffers or large sections.


subsection:: /b_gen
Call a command to fill a buffer.
table::
## strong::int:: || buffer number
## strong::string:: || command name
## strong::...:: || command arguments
::
Plug-ins can define commands that operate on buffers. The arguments after the command name are defined by the command. The currently defined link::Reference/Server-Command-Reference#Buffer Fill Commands#buffer fill commands:: are listed below in a separate section.

code::/b_gen:: does not accept a completion message as the final argument.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_gen bufNum:: when complete.
::


subsection:: /b_close
Close soundfile.
table::
## strong::int:: || buffer number
## strong::bytes:: || an OSC message to execute upon completion. (optional)
::
After using a buffer with link::Classes/DiskOut::, close the soundfile and write header information.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done /b_close bufNum:: when complete.
::


subsection:: /b_query
Get buffer info.
table::
## N * strong::int:: || buffer number(s)
::

Responds to the sender with a strong::/b_info:: message.  The arguments to /b_info are as follows:
table::
## N * || table::
    ## strong::int:: || buffer number
    ## strong::int:: || number of frames
    ## strong::int:: || number of channels
    ## strong::float:: || sample rate
    ::
::

subsection:: /b_get
Get sample value(s).
table::
## strong::int:: || buffer number
## N * strong::int:: || a sample index
::

Replies to sender with the corresponding strong::/b_set:: command.

subsection:: /b_getn
Get ranges of sample value(s).
table::
## strong::int:: || buffer number
## N * || table::
    ## strong::int:: || starting sample index
    ## strong::int:: || number of sequential samples to get (M)
    ::
::

Get contiguous ranges of samples. Replies to sender with the corresponding strong::/b_setn:: command. This is only meant for getting a few samples, not whole buffers or large sections.


section:: Control Bus Commands

subsection:: /c_set
Set bus value(s).
table::
## N * || table::
    ## strong::int:: || a bus index
    ## strong::float:: or strong::int:: || a control value
    ::
::
Takes a list of pairs of bus indices and values and sets the buses to those values.

subsection:: /c_setn
Set ranges of bus value(s).
table::
## N * || table::
    ## strong::int:: || starting bus index
    ## strong::int:: || number of sequential buses to change (M)
    ## M * || table::
        ## strong::float:: or strong::int:: || a control value
        ::
    ::
::
Set contiguous ranges of buses to sets of values. For each range, the starting bus index is given followed by the number of channels to change, followed by the values.

subsection:: /c_fill
Fill ranges of bus value(s).
table::
## N * || table::
    ## strong::int:: || starting bus index
    ## strong::int:: || number of buses to fill (M)
    ## strong::float:: or strong::int:: || value
    ::
::
Set contiguous ranges of buses to single values. For each range, the starting sample index is given followed by the number of buses to change, followed by the value to fill.

subsection:: /c_get
Get bus value(s).
table::
## N * strong::int:: || a bus index
::
Takes a list of buses and replies to sender with the corresponding strong::/c_set:: command.

subsection:: /c_getn
Get ranges of bus value(s).
table::
## N * || table::
    ## strong::int:: || starting bus index
    ## strong::int:: || number of sequential buses to get (M)
    ::
::
Get contiguous ranges of buses. Replies to sender with the corresponding strong::/c_setn:: command.


section:: Non Real Time Mode Commands

subsection:: /nrt_end
End real time mode, close file.  Not yet implemented.

This message should be sent in a bundle in non real time mode.
The bundle timestamp will establish the ending time of the file.
This command will end non real time mode and close the sound file.
Replies to sender with strong::/done:: when complete.


section:: Replies to Commands

These messages are sent by the server in response to some commands.

subsection:: /done
An asynchronous message has completed.
table::
## strong::string:: || the name of the command
## strong::other:: || (optional) some commands provide other information, for example a buffer index.
::
Sent in response to all asynchronous commands. Sent only to the sender of the original message.

subsection:: /fail
An error occurred.
table::
## strong::string:: || the name of the command
## strong::string:: || the error message.
## strong::other:: || (optional) some commands provide other information, for example a buffer index.
::
There was a problem. Sent only to the sender of the original message.

subsection:: /late
A command was received too late.
not yet implemented
table::
## strong::int:: || the high 32 bits of the original time stamp.
## strong::int:: || the low 32 bits of the original time stamp.
## strong::int:: || the high 32 bits of the time it was executed.
## strong::int:: || the low 32 bits of the time it was executed.
::
The command was received too late to be executed on time. Sent only to the sender of the original message.

section:: Node Notifications from Server

These messages are sent as notification of some event to all clients who have registered via the strong::/notify:: command.

All of these have the same arguments:
table::
## strong::int:: || node ID
## strong::int:: || the node's parent group ID
## strong::int:: || previous node ID, -1 if no previous node.
## strong::int:: || next node ID, -1 if no next node.
## strong::int:: || 1 if the node is a group, 0 if it is a synth
## The following two arguments are only sent if the node is a group:
## strong::int:: || the ID of the head node, -1 if there is no head node.
## strong::int:: || the ID of the tail node, -1 if there is no tail node.
::

subsection:: /n_go
A node was started.
This command is sent to all registered clients when a node is created.

subsection:: /n_end
A node ended.
This command is sent to all registered clients when a node ends and is deallocated.

subsection:: /n_off
A node was turned off.
This command is sent to all registered clients when a node is turned off.

subsection:: /n_on
A node was turned on.
This command is sent to all registered clients when a node is turned on.

subsection:: /n_move
A node was moved.
This command is sent to all registered clients when a node is moved.

subsection:: /n_info
Reply to /n_query.
This command is sent to all registered clients in response to an strong::/n_query:: command.


section:: Trigger Notification
These messages are sent as notification of some event to all clients who have registered via the strong::/notify:: command.

subsection:: /tr
A trigger message.
table::
## strong::int:: || node ID
## strong::int:: || trigger ID
## strong::float:: || trigger value
::
This command is the mechanism that synths can use to trigger events in clients.
The node ID is the node that is sending the trigger. The trigger ID and value are determined by inputs to the SendTrig unit generator which is the originator of this message.


section:: Buffer Fill Commands

These are the currently defined fill routines for use with the strong::/b_gen:: command.

subsection:: Wave Fill Commands

There are three defined fill routines for sine waves.

The flags are defined as follows:
table::
## 1 || normalize - Normalize peak amplitude of wave to 1.0.
## 2 || wavetable - If set, then the buffer is written in wavetable format so that it can be read by interpolating oscillators.
## 4 || clear - if set then the buffer is cleared before new partials are written into it. Otherwise the new partials are summed with the existing contents of the buffer.
::

These flags can be added together to create a unique single integer flag that describes the true/false combinations for these three options:

table::
## 3 || 1 + 2 || normalize + wavetable
## 5 || 1 + 4 || normalize + clear
## 6 || 2 + 4 || wavetable + clear
## 7 || 1 + 2 + 4 || normalize + wavetable + clear
::

definitionlist::
## sine1 ||
table::
## strong::int:: || flags, see above
## N * || table::
    ## strong::float:: || partial amplitude
    ::
::
Fills a buffer with a series of sine wave partials. The first float value specifies the amplitude of the first partial, the second float value specifies the amplitude of the second partial, and so on.

## sine2 ||
table::
## strong::int:: || flags, see above
## N * || table::
    ## strong::float:: || partial frequency (in cycles per buffer)
    ## strong::float:: || partial amplitude
    ::
::
Similar to sine1 except that each partial frequency is specified explicitly instead of being an integer series of partials. Non-integer partial frequencies are possible.

## sine3 ||
table::
## strong::int:: || flags, see above
## N * || table::
    ## strong::float:: || partial frequency (in cycles per buffer)
    ## strong::float:: || partial amplitude
    ## strong::float:: || partial phase
    ::
::
Similar to sine2 except that each partial may have a nonzero starting phase.

## cheby ||
table::
## strong::int:: || flags, see above
## N * || table::
    ## strong::float:: || amplitude
    ::
::
Fills a buffer with a series of chebyshev polynomials, which can be defined as:
code::
cheby(n) = amplitude * cos(n * acos(x))
::
The first float value specifies the amplitude for n = 1, the second float value specifies the amplitude for n = 2, and so on. To eliminate a DC offset when used as a waveshaper, the wavetable is offset so that the center value is zero.
::

subsection:: Other Commands

definitionlist::
## copy ||
table::
## strong::int:: || sample position in destination
## strong::int:: || source buffer number
## strong::int:: || sample position in source
## strong::int:: || number of samples to copy
::
Copy samples from the source buffer to the destination buffer specified in the b_gen command. If the number of samples to copy is negative, the maximum number of samples possible is copied.
definitionlist::
## Asynchronous. || Replies to sender with strong::/done:: when complete.
::

::

section:: Command Numbers

These are the currently defined command numbers. More may be added to the end of the list in the future.
code::
enum {
    cmd_none = 0,

    cmd_notify = 1,
    cmd_status = 2,
    cmd_quit = 3,
    cmd_cmd = 4,

    cmd_d_recv = 5,
    cmd_d_load = 6,
    cmd_d_loadDir = 7,
    cmd_d_freeAll = 8,

    cmd_s_new = 9,

    cmd_n_trace = 10,
    cmd_n_free = 11,
    cmd_n_run = 12,
    cmd_n_cmd = 13,
    cmd_n_map = 14,
    cmd_n_set = 15,
    cmd_n_setn = 16,
    cmd_n_fill = 17,
    cmd_n_before = 18,
    cmd_n_after = 19,

    cmd_u_cmd = 20,

    cmd_g_new = 21,
    cmd_g_head = 22,
    cmd_g_tail = 23,
    cmd_g_freeAll = 24,

    cmd_c_set = 25,
    cmd_c_setn = 26,
    cmd_c_fill = 27,

    cmd_b_alloc = 28,
    cmd_b_allocRead = 29,
    cmd_b_read = 30,
    cmd_b_write = 31,
    cmd_b_free = 32,
    cmd_b_close = 33,
    cmd_b_zero = 34,
    cmd_b_set = 35,
    cmd_b_setn = 36,
    cmd_b_fill = 37,
    cmd_b_gen = 38,

    cmd_dumpOSC = 39,

    cmd_c_get = 40,
    cmd_c_getn = 41,
    cmd_b_get = 42,
    cmd_b_getn = 43,
    cmd_s_get = 44,
    cmd_s_getn = 45,

    cmd_n_query = 46,
    cmd_b_query = 47,

    cmd_n_mapn = 48,
    cmd_s_noid = 49,

    cmd_g_deepFree = 50,
    cmd_clearSched = 51,

    cmd_sync = 52,

    cmd_d_free = 53,

    cmd_b_allocReadChannel = 54,
    cmd_b_readChannel = 55,

    cmd_g_dumpTree = 56,
    cmd_g_queryTree = 57,


    cmd_error = 58,

    cmd_s_newargs = 59,

    cmd_n_mapa = 60,
    cmd_n_mapan = 61,
    cmd_n_order = 62,

    cmd_p_new = 63,

    cmd_version = 64,

    NUMBER_OF_COMMANDS = 65
};
::

copyright © 2002 James McCartney
-
soft::converted to ScDoc format 2011 by Jonatan Liljedahl::



title:: Server Plugin API
summary:: Reference for writing unit generators
categories:: Internals
related:: Guides/WritingUGens

section:: Input rates

These four constants identify the calculation rates of inputs in SuperCollider.

definitionlist::
## code::calc_ScalarRate::
|| Initial rate. Conventionally known in the language as ".ir".

## code::calc_BufRate::
|| Control rate. Conventionally known in the language as ".kr".

## code::calc_FullRate::
|| Audio rate. Conventionally known in the language as ".ar".

## code::calc_DemandRate::
|| Demand rate.
::

section:: UGen basics

These helper macros assume that there is a ugen object called code::unit:: in the local scope.

definitionlist::
## code::IN(index)::
|| A single block of audio-rate input as a float* at the given index. Index 0 is the first input to the ugen, index 1 the second input, and so forth.

## code::IN0(index)::
|| A single sample of control-rate input as a float, at the given index.

## code::OUT(index)::
|| A single block of audio-rate output as a float* at the given index.

## code::OUT0(index)::
|| A single sample of control-rate input as a float, at the given index.

## code::INRATE(index)::
|| Get the rate of a given input index. This will be one of the four rates.

## code::INBUFLENGTH(index)::
|| Get the block size of a given input index.

## code::SAMPLERATE::
|| Sample rate of the server in Hertz.

## code::SAMPLEDUR::
|| Sample period of the server in seconds.

## code::BUFLENGTH::
|| Length in samples of an audio buffer (that is, the number of samples in a control period).

## code::BUFRATE::
|| Control rate of the server in Hertz.

## code::BUFDUR::
|| Control period of the server in seconds.

## code::FULLRATE::
||

## code::FULLBUFLENGTH::
||
::

section:: Buffers

definitionlist::
## code::GET_BUF::
|| The recommended way to retrieve a buffer. Take the first input of this UGen and use it as a buffer number. This dumps
a number of variables into the local scope:

list::
## code::buf:: - a pointer to the code::SndBuf:: instance
## code::bufData:: - the raw float data from the buffer
## code::bufChannels:: - the number of channels in the buffer
## code::bufSamples:: - the number of samples in the buffer
## code::bufFrames:: - the number of frames in the buffer
::

The buffer is locked using the code::LOCK_SNDBUF:: macro. Buffer lock operations are specific to supernova, and don't
do anything in vanilla scsynth.

## code::GET_BUF_SHARED::
|| Like code::GET_BUF::, but the buffer is locked using code::LOCK_SNDBUF_SHARED::.

## code::SIMPLE_GET_BUF::
|| Like code::GET_BUF::, but only creates the code::buf:: variable and does not lock the buffer.

## code::SIMPLE_GET_BUF_EXCLUSIVE::
|| Like code::SIMPLE_GET_BUF::, but locks the buffer with code::LOCK_SNDBUF::.

## code::SIMPLE_GET_BUF_SHARED::
|| Like code::SIMPLE_GET_BUF::, but locks the buffer with code::LOCK_SNDBUF_SHARED::.
::

The following macros are for use in supernova. They still exist in scsynth, but will have no effect.

code::
ACQUIRE_BUS_AUDIO(index)
ACQUIRE_BUS_AUDIO_SHARED(index)
RELEASE_BUS_AUDIO(index)
RELEASE_BUS_AUDIO_SHARED(index)
LOCK_SNDBUF(buf)
LOCK_SNDBUF_SHARED(buf)
LOCK_SNDBUF2(buf1, buf2)
LOCK_SNDBUF2_SHARED(buf1, buf2)
LOCK_SNDBUF2_EXCLUSIVE_SHARED(buf1, buf2)
LOCK_SNDBUF2_SHARED_EXCLUSIVE(buf1, buf2)
ACQUIRE_SNDBUF(buf)
ACQUIRE_SNDBUF_SHARED(buf)
RELEASE_SNDBUF(buf)
RELEASE_SNDBUF_SHARED(buf)
ACQUIRE_BUS_CONTROL(index)
RELEASE_BUS_CONTROL(index)
::

section:: RGen

RGen is a pseudorandom number generator API. Most ugen developers are not interested in seeding their own RGens and
would prefer to draw from a global RGen instance supplied by SuperCollider. This can be retrieved with the code:

code::
RGen& rgen = *unit->mParent->mRGen;
::

definitionlist::
## code::uint32 RGen\::trand()::
|| Return a uniformly distributed random 32-bit integer.

## code::double RGen\::drand()::
|| Return a uniformly distributed random double in [0,1).

## code::float RGen\::frand()::
|| Random float in [0,1).

## code::float RGen\::frand0()::
|| Random float in [1,2).

## code::float RGen\::frand2()::
|| Random float in [-1,1).

## code::float RGen\::frand8()::
|| Random float in [-0.125,0.125).

## code::float RGen\::fcoin()::
|| Either -1 or +1.

## code::float RGen\::flinrand()::
|| Linearly distributed random float in [0,1), with a bias towards the 0 end.

## code::float RGen\::fbilinrand()::
|| Bilinearly distributed random float in (-1,1), with a bias towards 0.

## code::float RGen\::fsum3rand()::
|| A crude but fast approximation to a Gaussian distribution. Results are always in the range (-1,1). The variance is
1/6 and the standard deviation is 0.41. footnote:: The formula is code::(rand() + rand() + rand() - 1.5) * 2/3::,
technically a shifted and stretched order-3 Irwin-Hall distribution. ::

## code::int32 RGen\::irand(int32 scale)::
|| Random int in [0,scale).

## code::int32 RGen\::irand2(int32 scale)::
|| Random int in [-scale,+scale].

## code::int32 RGen\::ilinrand(int32 scale)::
|| Linearly distributed random int in [0,scale), with a bias towards the 0 end.

## code::int32 RGen\::ibilinrand(int32 scale)::
|| Bilinearly distributed random int in (-scale,scale), with a bias towards the 0.

## code::double RGen\::linrand()::
|| Linearly distributed random double in [0,1), with a bias towards the 0 end.

## code::double RGen\::bilinrand()::
|| Bilinearly distributed random double in (-1,1), with a bias towards 0.

## code::double RGen\::exprandrng(double lo, double hi)::
|| Exponentially distributed random double in [lo,hi).

## code::double RGen\::exprand(double scale)::
||

## code::double RGen\::biexprand(double scale)::
||

## code::double RGen\::exprand(double scale)::
||

## code::double RGen\::sum3rand(double scale)::
|| Double version of code::RGen\::fsum3rand::.
::

section:: Unary operators

definitionlist::
## code::bool sc_isnan(float/double x)::
|| Checks whether code::x:: is NaN. This is a legacy function, use code::std\::isnan:: instead.

## code::bool sc_isfinite(float/double x)::
|| Checks whether code::x:: is finite. This is a legacy function, use code::std\::isfinite:: instead.

## code::int32 sc_grayCode(int32 x)::
|| Convert binary to Gray code.
::

The following unary functions are available for both float32 and float64, and are the same as in sclang (minus the "sc_"
prefixes):

list::
## code::sc_midicps::
## code::sc_cpsmidi::
## code::sc_midiratio::
## code::sc_ratiomidi::
## code::sc_octcps::
## code::sc_cpsoct::
## code::sc_ampdb::
## code::sc_dbamp::
## code::sc_cubed::
## code::sc_sqrt::
## code::sc_hanwindow::
## code::sc_welwindow::
## code::sc_triwindow::
## code::sc_rectwindow::
## code::sc_scurve::
## code::sc_ramp::
## code::sc_sign::
## code::sc_distort::
## code::sc_softclip::
## code::sc_ceil::
## code::sc_floor::
## code::sc_reciprocal::
## code::sc_frac::
## code::sc_log2:: (legacy -- use code::std\::log2(std\::abs(x))::)
## code::sc_log10:: (legacy -- use code::std\::log10(std\::abs(x))::)
## code::sc_trunc:: (legacy -- use code::std\::trunc::)
::

The following unary functions are available for both float32 and float64, but have no sclang equivalent:

definitionlist::
## code::zapgremlins(x)::
|| Replaces NaNs, infinities, very large and very small numbers (including denormals) with zero. This is useful in ugen
feedback to safeguard from pathological behavior. (Note lack of sc_ prefix.)

## code::sc_bitriwindow(x)::
|| Alternative to code::sc_triwindow:: using absolute value.

## code::sc_scurve0(x)::
|| Same as code::sc_scurve::, but assumes that code::x:: is in the interval [0, 1].

## code::sc_distortneg(x)::
|| A one-sided distortion function. Same as code::distort:: for code::x > 0::, and the identity function for code::x <= 0::.

## code::taylorsin(x)::
|| Taylor series approximation of code::sin(x):: out to code::x**9 / 9!::. (Note lack of sc_ prefix.)

## code::sc_lg3interp(x1, a, b, c, d)::
|| Cubic Lagrange interpolator.

## code::sc_CalcFeedback(delaytime, decaytime)::
|| Determines the feedback coefficient for a feedback comb filter with the given delay and decay times.

## code::sc_wrap1(x)::
|| Wrap code::x:: around ±1, wrapping only once.

## code::sc_fold1(x)::
|| Fold code::x:: around ±1, folding only once.
::

section:: Binary operators

definitionlist::
## code::sc_wrap(in, lo, hi [, range])::
||

## code::sc_fold(in, lo, hi [, range [, range2]])::
||

## code::sc_pow(a, b)::
|| Compute code::pow(a, b)::, retaining the sign of code::a::.

## code::sc_powi(x, unsigned int n)::
|| Compute code::x^n::, not necessarily retaining the sign of code::x::.

## code::sc_hypotx(x, y)::
|| Compute code::abs(x) + abs(y) - (min(abs(x), abs(y)) * (sqrt(2) - 1))::, the minimum distance one will have to travel
from the origin to (x,y) using only orthogonal and diagonal movements.
::

The following functions are the same as in sclang (minus the "sc_" prefixes):

list::
## code::sc_mod(in, hi):: (floats, doubles, ints)
## code::sc_round(x, quant):: (floats, doubles, ints)
## code::sc_roundUp(x, quant):: (floats, doubles, ints)
## code::sc_trunc(x, quant):: (floats, doubles, ints)
## code::sc_gcd(a, b):: (ints, longs, floats)
## code::sc_lcm(a, b):: (ints, longs, floats)
## code::sc_bitAnd(a, b):: (ints)
## code::sc_bitOr(a, b):: (ints)
## code::sc_leftShift(a, b):: (ints)
## code::sc_rightShift(a, b):: (ints)
## code::sc_unsignedRightShift(a, b):: (ints)
## code::sc_thresh(a, b)::
## code::sc_clip2(a, b)::
## code::sc_wrap2(a, b)::
## code::sc_fold2(a, b)::
## code::sc_excess(a, b)::
## code::sc_scaleneg(a, b)::
## code::sc_amclip(a, b)::
## code::sc_ring1(a, b)::
## code::sc_ring2(a, b)::
## code::sc_ring3(a, b)::
## code::sc_ring4(a, b)::
## code::sc_difsqr(a, b)::
## code::sc_sumsqr(a, b)::
## code::sc_sqrsum(a, b)::
## code::sc_sqrdif(a, b)::
## code::sc_atan2(a, b):: (legacy -- use code::std\::atan2::)
::

section:: Constants

The following constants are doubles:

list::
## code::pi::
## code::pi2:: = pi/2
## code::pi32:: = 3pi/2
## code::twopi:: = 2pi
## code::rtwopi:: (1/2pi)
## code::log001:: = log(0.001)
## code::log01:: = log(0.01)
## code::log1:: = log(0.1)
## code::rlog2:: = 1/log(2)
## code::sqrt2:: = sqrt(2)
## code::rsqrt2:: = 1/sqrt(2)
## code::truncDouble:: = 3 * 2^51 (used to truncate precision)
::

The following constants are floats:

list::
## code::pi_f::
## code::pi2_f::
## code::pi32_f::
## code::twopi_f::
## code::sqrt2_f::
## code::rsqrt2_f::
## code::truncFloat:: = 3 * 2^22 (used to truncate precision)
::

section:: Unroll macros

The macros in this section are legacy features. They are seen in many of SuperCollider's built-in ugens, and are
intended to provide more efficient alternatives to the standard code::for (int i = 0; i < inNumSamples; i++) { out[i]
= in[i] }:: loop. These efficiency savings are negligible on modern systems and use of these macros is not recommended,
especially since they make debugging difficult.

definitionlist::
## code::LOOP(length, stmt)::
|| Execute code code::stmt::, code::length:: times.

## code::LOOP1(length, stmt)::
|| A faster drop-in alternative to code::LOOP::, which assumes that code::length > 0:: so a branch instruction is saved.

## code::LooP(length) stmt::
|| An alternative to LOOP/LOOP1 that is more debugger-friendly. The body of the loop comes after the call to code::LooP::.

## code::ZIN(index)::
|| Similar to code::IN::, but subtracts 1 from the pointer to correct for off-by-one errors when using code::LOOP:: and code::ZXP::.

## code::ZOUT(index)::
|| Same as code::OUT::, but subtracts 1 from the pointer to correct for off-by-one errors when using code::LOOP:: and code::ZXP::.

## code::ZIN0(index)::
|| Alias for code::IN0::.

## code::ZOUT0(index)::
|| Alias for code::OUT0::.

## code::ZXP(z)::
|| Pre-increment and dereference code::z::.

## code::ZX(z)::
|| Dereference code::z::.

## code::PZ(z)::
|| Pre-increment code::z::.

## code::ZP(z)::
|| Does nothing.

## code::ZOFF::
|| Return 1.
::


title:: Sclang Startup File
summary:: The sclang startup file
categories:: Language

Once the class library is finished compiling the interpreter looks for a file at code::Platform.userConfigDir +/+ "startup.scd":: and if such a
file exists, executes any code within it (this happens within link::Classes/Main#-startup::). By creating a file in this location you can make user
specific customizations.

definitionList::
## Linux   || teletype::~/.config/SuperCollider/startup.scd::, according to the xdg base directory specification
## macOS   || teletype::~/Library/Application Support/SuperCollider/startup.scd::
## Windows || teletype::C:\\SuperCollider\\startup.scd:: (or similar, depending on the location of the SuperCollider installation)
::


A common example would be to alter the options of the local and internal Servers:
code::
// placing the following code in the file will cause these modifications to be made
// at startup (see also: ServerOptions)

Server.local.options.numOutputBusChannels = 4;	// change number of input and output channels
Server.local.options.numInputBusChannels = 4;
Server.internal.options.numOutputBusChannels = 4;
Server.internal.options.numInputBusChannels = 4;

Server.local.options.device = "Built-in Audio";	// use a specific soundcard
Server.local.options.device = "MOTU Traveler";
Server.local.options.device = "TASCAM US-122";
Server.local.options.device = "Jack Router";
Server.local.options.device = nil;				// use the system default soundcard

Server.local.options.blockSize = 128; // increase block size (default is 64)
Server.internal.options.blockSize = 128;

Server.local.options.sampleRate = 96000; // increase sampling rate (if your hardware supports it)
Server.internal.options.sampleRate = 96000;
Server.internal.options.sampleRate = nil;	// use the currently selected samplerate of the soundcard

// change the standard archive path to a custom one:
Archive.archiveDir = "~/scwork".standardizePath;

// hook up jack ports to audio channels
"SC_JACK_DEFAULT_INPUTS".setenv("system");
"SC_JACK_DEFAULT_OUTPUTS".setenv("system");

::
Naturally the file must contain only valid SC expressions.


title:: Syntax Shortcuts
summary:: syntactic sugar
categories:: Language
related:: Overviews/SymbolicNotations

section:: Introduction

This file shows a number of syntax equivalences in the compiler.

Because of the multiple syntax equivalences, some expressions can be written in many different ways. All of the following do the same thing and compile to the same code.
code::
// new argument syntax

(1..10).collect({ |n| n.squared });  // receiver syntax
collect((1..10), { |n| n.squared }); // function call syntax
(1..10).collect { |n| n.squared };   // receiver syntax with trailing-block argument
collect ((1..10)) { |n| n.squared }; // function call syntax with trailing-block argument
(1..10) collect: { |n| n.squared };  // binary operator syntax


// old argument syntax

(1..10).collect({ arg n; n.squared });  // receiver syntax
collect((1..10), { arg n; n.squared }); // function call syntax
(1..10).collect { arg n; n.squared };   // receiver syntax with trailing-block argument
collect ((1..10)) { arg n; n.squared }; // function call syntax with trailing-block argument
(1..10) collect: { arg n; n.squared };  // binary operator syntax


// partial application syntax

(1..10).collect(_.squared);   // receiver syntax
collect((1..10), _.squared);  // function call syntax
(1..10) collect: _.squared;   // binary operator syntax
::

You could even start expanding out the equivalent of (1..10) which is really a shortcut for code:: series(1, nil, 10) ::. This could also be written code:: 1.series(nil,10) ::. This adds another 26 variations to the 13 variations above.

section:: Defining functions and classes

subsection:: shorter argument lists in definitions
table::
## instead of writing: || you can write:
## code:: { arg x; x < 2 } :: || code:: { |x| x < 2 } ::
## code:: { arg x = 123; x < 2 } :: || code:: { |x = 123| x < 2 } ::
## code:: { arg x = 10.rand; x < 2 } :: || code:: { |x = (10.rand)| x < 2 } :: or code:: {|x(10.rand)| x < 2 } ::
::
note::
When using the new code::||:: syntax, the default value needs to be enclosed in parenthesis if it's not a literal.
::

subsection:: partial application
table::
## instead of writing: || you can write:
## code:: { |x| object.msg(a, x, b) } :: || code:: object.msg(a, _, b) ::
## code:: { |x,y| object.msg(a, x, y) } :: || code:: object.msg(a, _, _) ::
## code:: { |x| a + x } :: || code:: a + _ ::
## code:: { |x| [a, b, x] } :: || code:: [a, b, _] ::
## code:: { |x| (a: x) } :: || code:: (a: _) ::
::
note::
There are some limitations to the extent of the surrounding expression that code::_:: can capture. See link::Reference/Partial-Application:: for details.
::

subsection:: defining instance variable accessor methods
table::
## instead of writing: || you can write:
## code::
Thing { var x;
    x { ^x }
    x_ { arg z; x = z; }
}
:: || code::
Thing { var <>x; }
::
::


section:: Sending messages, calling functions, and instantiating objects

subsection:: function-call and receiver notations
table::
## instead of writing: || you can write:
## code:: f(x, y) :: || code:: x.f(y) ::
## code:: f(g(x)) :: || code:: x.g.f ::
::

subsection:: calling the 'value' method
table::
## instead of writing: || you can write:
## code:: f.value(x) :: || code:: f.(x) ::
::

subsection:: instantiate object
table::
## instead of writing: || you can write:
## code:: Point.new(3, 4) :: || code:: Point(3, 4) ::
::

subsection:: calling an instance variable setter method
table::
## instead of writing: || you can write:
## code:: p.x_(y) :: || code:: p.x = y :: or code:: x(p) = y ::
::

subsection:: calling performList
table::
## instead of writing: || you can write:
## code:: object.performList(\method, a, b, array) :: || code:: object.method(a, b, *array) ::
::



subsection:: moving blocks out of argument lists (trailing-block arguments)
table::
## instead of writing: || you can write:
## code:: if (x < 3, { \abc }, { \def }) :: || code:: if (x < 3) { \abc } { \def } ::
## code:: z.do({ |x| x.play }) :: || code:: z.do { |x| x.play } ::
## code:: while({ a < b }, { a = a * 2 }) :: || code:: while { a < b } { a = a * 2 } ::
## code:: Pfunc({ rrand(3, 6) }) :: || code:: Pfunc { rrand(3, 6) } ::
::

note::
Trailing arguments must be literal blocks. No other expression may be used as a trailing argument, even if it evaluates to a Function. For example, you cannot use a variable name as a trailing argument, even if this variable was assigned a Function.

Using a selector as an infix binary operator (discussed in the next section) enables a visually similar construct that does allow arbitrary expressions as operands, but these binary-operator constructs technically do not have trailing arguments.
code::
(
var f = { |n| (2**n) + (3**n) };
collect((1..5), f); // valid
(1..5).collect(f);  // valid
(1..5) collect: f;  // valid (selector as binary operator)
)
(1..5).collect f;   // syntax error (non-block as a trailing argument)
collect((1..5)) f;  // syntax error (ibid.)
::
A fairly common case when this syntactic restriction matters: a partial application using the code::_:: syntax is an expression evaluating to a Function, but it is not a literal block. Therefore:
code::
do(6) _.postln  // syntax error
6.do _.postln   // syntax error
do(6, _.postln) // valid
6.do(_.postln)  // valid
6 do: _.postln  // valid
::
::

subsection:: use a selector (method name) as a binary operator
table::
## instead of writing: || you can write:
## code:: div(x, y) :: || code:: x div: y ::
::

warning::
When switching between various forms of call syntax, one has to be mindful that a selector as a binary operator has equal precedence with most other binary operators, but has lower precedence than the receiver dot notation (code::.::). Therefore, replacing a receiver syntax (dot) with a selector written as a binary operator can change the result of some expressions, as illustrated below:

code::
4 + 5.div(2) // -> 6
4 + 5 div: 2 // -> 4

// This is a left-to-right application of two dots,
// the first of which has a trailing block argument.
(1..3).collect { |x| x + 1 }.bubble
// -> [ [ 2, 3, 4 ] ]

// This is a selector binary operator ("collect:") applied
// to two arguments, the second of which is the result
// of applying "bubble" (via dot syntax) to a function.
(1..3) collect: { |x| x + 1 }.bubble
// -> [ [ a Function ], [ a Function ], [ a Function ] ]

// Changing precedence in the above with explicit parentheses
((1..3) collect: { |x| x + 1 }).bubble
// -> [ [ 2, 3, 4 ] ]

// Or by uniform use of selectors as binary operators
(1..3) collect: { |x| x + 1 } bubble: 0
::
::


Native infix operators like code::+:: can also be written in (longer) function-call form, e.g.:

table::
## infix: || function call:
## code:: 1 + 2 :: || code:: (+)(1, 2) ::
::

The latter form is usually not a shortcut, except when one wants to dynamically change the adverb of an operator, for instance that of code::+++::, because adverbs in the infix notation are interpreted as literals.

code::
(
var a = (_+_) ! [3, 3]; // -> [ [ 0, 1, 2 ], [ 1, 2, 3 ], [ 2, 3, 4 ] ]
(0..2) collect: (+++)(a, 99, _) flatten: 3; // iterated adverb
)
(0..2) collect: (a +++._ 99) flatten: 3;    // syntax error
(
var a = (_+_) ! [3, 3];
(0..2) collect: {|v| a +++.v 99} flatten: 3 // the literal adverb \v is used
)
::


section:: Collections

subsection:: create a collection
table::
## instead of writing: || you can write:
## code:: Set.new.add(3).add(4).add(5) :: || code:: Set[3, 4, 5] ::
## code:: Array[3, 4, 5] :: || code:: [3, 4, 5] ::
::

subsection:: indexing elements
table::
## instead of writing: || you can write:
## code:: z.at(i) :: || code:: z[i] ::
## code:: z.put(i, y) :: || code:: z[i] = y ::
::

subsection:: accessing subranges of Arrays
table::
## instead of writing: || you can write:
## code:: a.copyRange(4, 8) :: || code:: a[4..8] ::
## code:: a.copyToEnd(4) :: || code:: a[4..] ::
## code:: a.copyFromStart(4) :: || code:: a[..4] ::
::

subsection:: creating arithmetic series
table::
## instead of writing: || you can write:
## code:: Array.series(16, 1, 1) :: or code:: series(1, nil, 16) :: || code:: (1..16) ::
## code:: Array.series(6, 1, 2) :: or code:: series(1, 3, 11) :: || code:: (1, 3..11) ::
::
There is also the similar syntax for creating an iterating link::Classes/Routine:::
table::
## instead of writing: || you can write:
## code:: seriesIter(1, 3, 11) :: || code:: (:1, 3..11) ::
::
note::
SuperCollider also supports link::Guides/ListComprehensions::.
::

As a simple (non-combinatorial) example, the following are equivalent ways of listing the first 10 primes:

code::
(:1..) select: _.isPrime nextN: 10;
{: x, x <- (1..), x.isPrime }.nextN(10);
::

subsection:: creating Events
table::
## instead of writing: || you can write:
## code:: Event[\a -> 1, \b -> 2] :: || code:: (a: 1, b: 2) ::
::

subsection:: creating Arrays with key-value pairs
table::
## instead of writing: || you can write:
## code:: [\a, 1, \b, 2] :: || code:: [a: 1, b: 2] ::
::

section:: Other shortcuts

subsection:: multiple assignment
table::
## instead of writing: || you can write:
## code:: x = z.at(0); y = z.at(1); :: || code:: # x, y = z; ::
::

subsection:: accessing environment variables
table::
## instead of writing: || you can write:
## code:: 'myName'.envirGet :: || code:: ~myName ::
## code:: 'myName'.envirPut(9) :: || code:: ~myName = 9 ::
::

subsection:: shorthand for Symbols
table::
## instead of writing: || you can write:
## code:: 'mySymbol' :: || code:: \mySymbol ::
::
note::
The shorthand only admits a subset of the symbols that may be enclosed in single quotes. See link::Reference/Literals#Symbols:: for details.
::

subsection:: creating a Ref
table::
## instead of writing: || you can write:
## code:: Ref.new(thing) :: || code:: `thing ::
::



title:: Synth Definition File Format
summary:: Description of Synth Definition file format used by SC synth server
categories:: Server>Architecture
related:: Classes/SynthDef

Synth definition files are read by the synth server and define collections of unit generators and their connections. These files are currently written by  the SuperCollider language application, but theoretically could be written by any program.
Such a program would need knowledge of the SC unit generators and their characteristics, such as number of inputs and outputs and available calculation rates. The code to write these files is open and available in the SuperCollider language app.

In the current SuperCollider 3.6 development version, there are two versions of SynthDef:

list::
## strong::SynthDef:: - The original SynthDef file format, backward compatible with .scsyndef files saved using earlier versions of SuperCollider.
## strong::SynthDef2:: - A revised version that extends SynthDef's capacity.
::

This document describes SynthDef2's format. See link::#Original SynthDef format:: for the differences between SynthDef and SynthDef2.

section:: Basic types
All data is stored big endian. All integers, unless otherwise noted, are signed. All data is packed, not padded or aligned.
definitionlist::
## int32 || a 32 bit integer.
## int16 || a 16 bit integer.
## int8 || an 8 bit integer.
## float32 || a 32 bit IEEE floating point number.
## pstring || a pascal format string: a byte (an strong::unsigned:: int8) giving the length followed by that many bytes.
::

section:: File Format

a strong::synth-definition-file:: is :
list::
## int32 - four byte file type id containing the ASCII characters: "SCgf"
## int32 - file version, currently 2.
## int16 - number of synth definitions in this file (D).
## [ strong::synth-definition:: ] * D
::

a strong::synth-definition:: is :
list::
## pstring - the name of the synth definition
## int32 - number of constants (K)
## [float32] * K - constant values
## int32 - number of parameters (P)
## [float32] * P - initial parameter values
## int32 - number of parameter names (N)
## [ strong::param-name:: ] * N
## int32 - number of unit generators (U)
## [ strong::ugen-spec:: ] * U
## int16 - number of variants (V)
## [ strong::variant-spec:: ] * V
::

a strong::param-name:: is :
list::
## pstring - the name of the parameter
## int32 - its index in the parameter array
::

a strong::ugen-spec:: is :
list::
## pstring - the name of the SC unit generator class
## int8 - calculation rate
## int32 - number of inputs (I)
## int32 - number of outputs (O)
## int16 - special index
## [ strong::input-spec:: ] * I
## [ strong::output-spec:: ] * O
::

an strong::input-spec:: is :
list::
## int32 - index of unit generator or -1 for a constant
## if (unit generator index == -1) :
list::
## int32 - index of constant
::
## else :
list::
## int32 - index of unit generator output
::
::

an strong::output-spec:: is :
list::
## int8 - calculation rate
::

a strong::variant-spec:: is :
list::
## pstring - the name of the variant
## [float32] * P - variant initial parameter values
::

section:: File Format as Tree

soft::added by Jonatan Liljedahl::

subsection::synth-definition-file
tree::
## int32 - four byte file type id containing the ASCII characters: "SCgf"
## int32 - file version, currently 2.
## int16 - number of synth definitions in this file (D).
## [ strong::synth-definition:: ] * D
    tree::
    ## pstring - the name of the synth definition
    ## int32 - number of constants (K)
    ## [float32] * K - constant values
    ## int32 - number of parameters (P)
    ## [float32] * P - initial parameter values
    ## int32 - number of parameter names (N)
    ## [ strong::param-name:: ] * N
        tree::
        ## pstring - the name of the parameter
        ## int32 - its index in the parameter array
        ::
    ## int32 - number of unit generators (U)
    ## [ strong::ugen-spec:: ] * U
        tree::
        ## pstring - the name of the SC unit generator class
        ## int8 - calculation rate
        ## int32 - number of inputs (I)
        ## int32 - number of outputs (O)
        ## int16 - special index
        ## [ strong::input-spec:: ] * I
            tree::
            ## int32 - index of unit generator or -1 for a constant
            ## if (unit generator index == -1)
                tree::
                ## int32 - index of constant
                ::
            ## else
                tree::
                ## int32 - index of unit generator output
                ::
            ::
        ## [ strong::output-spec:: ] * O
            tree::
            ## int8 - calculation rate
            ::
        ::
    ## int16 - number of variants (V)
    ## [ strong::variant-spec:: ] * V
        tree::
        ## pstring - the name of the variant
        ## [float32] * P - variant initial parameter values
        ::
    ::
::

section:: Original SynthDef format

The original SynthDef format differs in that the following items are teletype::int16:: instead of teletype::int32::.

note:: The following list describes what has changed between SynthDef and SynthDef2. It is not a complete description of the original SynthDef file format. ::

list::
## int32 - file version, currently 1. (This is emphasis::2:: for the new format.)

## a strong::synth-definition:: is :
list::
## int16 - number of constants (K)
## int16 - number of parameters (P)
## int16 - number of parameter names (N)
## int16 - number of unit generators (U)
::
## a strong::param-name:: is :
list::
## int16 - its index in the parameter array
::

## a strong::ugen-spec:: is :
list::
## int16 - number of inputs (I)
## int16 - number of outputs (O)
::

## an strong::input-spec:: is :
list::
## int16 - index of unit generator or -1 for a constant
## int16 - index of constant
## int16 - index of unit generator output
::
::


section:: Glossary

definitionlist::
## calculation rate || the rate that a computation is done. There are three rates numbered 0, 1, 2 as follows:
definitionlist::
## 0 = scalar rate || one sample is computed at initialization time only.
## 1 = control rate || one sample is computed each control period.
## 2 = audio rate || one sample is computed for each sample of audio output.
::
Outputs have their own calculation rate. This allows MultiOutUGens to have outputs at different rates. A one output unit generator's calculation rate should match that of its output.

## constant || a single floating point value that is used as a unit generator input.

## parameter || a value that can be externally controlled using server commands /s.new, /n.set, /n.setn, /n.fill, /n.map .

## parameter name || a string naming an index in the parameter array. This allows one to refer to the same semantic value such as 'freq' or 'pan' in different synths  even though they exist at different offsets in their respective parameter arrays.

## special index || this value is used by some unit generators for a special purpose. For example, UnaryOpUGen and BinaryOpUGen use it to indicate which operator to perform. If not used it should be set to zero.

## synth || a collection of unit generators that execute together. A synth is a type of node.

## synth definition || a specification for creating synths.

## unit generator ||  a basic signal processing module with inputs and outputs. unit generators are connected together to form synths.
::

section:: Notes

Unit generators are listed in the order they will be executed. Inputs must refer to constants or previous unit generators. No feedback loops are allowed. Feedback must be accomplished via delay lines or through buses.

subsection:: For greatest efficiency:

Unit generators should be listed in an order that permits efficient reuse of connection buffers, which means that a depth first topological sort of the graph is preferable to breadth first.

There should be no duplicate values in the constants table.

copyright © 2002 James McCartney - converted to new help system 2010 by Jonatan Liljedahl, updated for version 2 by Scott Wilson 2011



title:: asTarget
summary:: Convert to a valid Node Target
categories:: Server>Nodes
related:: Classes/Node

method:: asTarget

The classes listed below implement the method code::asTarget::. This is used widely in the link::Classes/Node:: classes ( link::Classes/Group:: and link::Classes/Synth:: ) to convert non-Node objects to an appropriate target.
This allows nil and instances of link::Classes/Server:: to be used as targets. This can be useful when writing classes which create nodes internally, but in most cases there should be little need to call asTarget in normal use.

For an updated list of which classes that implements code::asTarget::, see asTarget in link::Overviews/Methods#asTarget::

definitionlist::
## link::Classes/Node#-asTarget:: || Returns the instance of Node itself. The subclasses of Node (Synth and Group) are valid targets and require no conversion.

## link::Classes/Server#-asTarget:: || Returns a link::Classes/Group:: object representing the link::Reference/default_group:: of this instance of Server. Note that this object may not be identical with other objects representing the default group, but will be equivalent.
code::
s = Server.default;
g = s.asTarget;     // the default group of s
h = s.defaultGroup; // and again
g == h;             // true
g === h;            // false
::

## link::Classes/Nil#-asTarget:: || Returns a link::Classes/Group:: object representing the link::Reference/default_group:: of the current default link::Classes/Server::.
code::
s = Server.default;
g = nil.asTarget;
g == s.defaultGroup; // true
::

## link::Classes/Integer#-asTarget:: || Returns a link::Classes/Group:: object representing a group node on the current default Server with this Integer as its node ID number.
Note:: Although this can be convenient in some cases, it does not create the corresponding node on the default server, nor does it check to make sure that it exists. As well it does not directly access the server's NodeIDAllocator, so duplication of node IDs is possible. For these reasons this method should be used with care. When not dealing with the default Server, Group-basicNew is safer and simpler, as otherwise one needs to set the server instance variable to ensure correct targeting. ::
code::
/////// Showing the problems

s = Server.default;
s.boot;
g = s.nextNodeID.asTarget;
x = Synth.head(g, "default");   // but g doesn't exist on the server
s.sendMsg(*g.addToHeadMsg);     // now it's sent to the default server, in the default group
x = Synth.head(g, "default");   // now this works
x.free; g.free;

// if not using the default Server Integer-asTarget can be problematic

Server.default = Server.local;
Server.default.boot;            // quit the default server
i = Server.internal; i.boot;
g = i.nextNodeID.asTarget;
i.sendMsg(*g.addToHeadMsg);     // seems to work, but...
x = Synth.head(g, "default");   // oops, this goes to the default server, so Group not Found
g.server == Server.default;     // true, so that's the problem
g.server = i;
x = Synth.head(g, "default");   // now to the right place
x.free; g.free;
::
code::
/////// A more practical example

s = Server.default;
s.boot;
s.sendMsg(\g_new, x = s.nextNodeID);
// ...

// now if we need to use Node objects for some reason
y = Synth.head(x.asTarget, "default");

// this is simpler than Group.basicNew(s, x);, providing you're using the default server:
z = Synth.head(Group.basicNew(s, x), "default");

y.free; z.free; x.asTarget.free;
::
::



title:: Default Group
summary:: An automatically created Group in sclang
categories:: Server>Nodes
related:: Classes/Group, Classes/RootNode, Classes/Node, Guides/NodeMessaging, Guides/Order-of-execution

tree::
## root node (id:0)
tree::
## default group (id:1)
::
::

When a Server is booted, there is a top level group with an ID of 0 that
defines the root of the tree. This is represented by a subclass of Group:
link::Classes/RootNode::.

Separate from the root group is sclang's notion of a "default group," which is
automatically created when the server is booted. You can access it with the
method link::Classes/Server#-defaultGroup::. This group is the default
enclosing group for all Nodes, i.e. it's what you get if you don't specify. In
general, you should create new Nodes within the default group of a Server
rather than in its RootNode. In a single-client setup, the default group will
have an ID of 1.

Keep in mind that default groups are a client-side concept, and you are
responsible for creating them if you're running scsynth from the command line
or NRT mode, or developing an alternate client. footnote::
When booting the server from the command line, you can create the default group manually with:
code::
s.initTree;
::
::

This is the default target for all Nodes when using object style and is what
you will get if you supply a link::Classes/Server:: as a target. If you don't
specify a target or pass in nil, you will get the default group of the default
Server.
code::
s.boot;
a = Synth.new(\default); // creates a synth in the default group of the default Server
a.group; // note the Group ID
a.group == Server.default.defaultGroup;
// -> true
::
The default group serves an important purpose: It provides a predictable basic Node tree so that methods such as Server-scope, Server-record, etc. can function without running into order of execution problems. In the example below the scoping node will come after the default group.
code::
s.boot;

{ SinOsc.ar(mul: 0.2) }.scope(1);

// watch the post window;
s.queryAllNodes;

// our SinOsc synth is within the default group (ID 1)
// the scope node comes after the default group, so no problems

s.quit;
::
Note that the default group is persistent: It is created in Server's code::initTree:: method (executed along with any code stored in its tree instance variable; see Server for more detail) and is recreated upon reboot, after pressing Cmd-., and after all nodes are freed. When using osc messages this means that a target node of id 1 can always be used:
code::
s.sendMsg("/s_new", "snd", 1832,0,1); // add to head of group 1
::
The default group can be specifically freed, but there is generally no reason that one would want to do so.

In general one should add nodes to the default group rather than the RootNode unless one has a specific reason to do so (i.e. adding some new functionality such as recording and scoping which is dependent upon a predictable basic node order). When using object style the default group is the default target for all new nodes, so nodes will normally not be added to the RootNode unless that is explicitly specified. It is of course possible to do so, but it should only be done with a proper understanding of the issues involved.

For instance, if one were to place an 'effects' synth after the default group and call Server-record or Server-scope, the resulting recording or scope synths may not be correctly ordered:
tree::
## default group
tree::
## source synth1
## source synth2
::
## recording synth
## effects synth
::
In the above example the recording synth might not capture the output of the effects synth since it comes later in the node order.

A better method in this case is to create a group within the default group and place the effects synth after that.
tree::
## default group
tree::
## source group
tree::
## source synth1
## source synth2
::
## effects synth
::
## recording synth
::

section:: Default groups in multi-client setups

See link::Guides/MultiClient_Setups:: for more info.

The default group mechanism is also used to separate clients in a multi-client
setup. Every client registering with a server has its own individual default
group. All nodes belonging to one client are in its default group and can be
specifically addressed.

This keeps nodes cleanly separated by default, but a client also knows the
default groups of all other clients. This is accessible via the method
link::Classes/Server#-defaultGroups::, which is an array mapping client IDs
to default groups.


title:: gui
categories:: GUI, Common methods
summary:: Create a Graphical User Interface
related:: Classes/ObjectGui

method:: gui
The code::gui:: message is of common use in SC. It originated in the crucial library where it is used to create an link::Classes/ObjectGui:: or an ObjectGui subclass as part of a Model View Controller system.

The implementation and accepted arguments to .gui varies.  This helpfile explains the default behavior of Object and hence of all Object subclasses that haven't implemented their own .gui method. This helpfile and the implementation come from the original crucial library.

Any object can create a GUI, albeit a very simple one that just displays the object's string representation on a view:

code::
nil.gui;
"2".gui;
2.gui;
[1,nil,"tree"].gui;
::

This means that any object can be .gui(ed) without knowing exactly what the object is.  This is identical in purpose to .asString which is used for posting an object's representation to the post window.


section:: Argument conventions

The convention as stated in crucial library states that the .gui method should accept parent and bounds as its arguments in the same manner as a View does.

code::
thing.gui(parent,bounds);
// or with optional additional arguments:
things.gui(parent,bounds,arg1,arg2,...argN)
::

This convention hasn't been followed by many who have written their own .gui methods (perhaps calling it that rather than .makeView or .makeWindow because they liked that .gui was nice and short to type)

This is the default implementation for Object, and is thus the implementation for all subclasses that have not written an explicit .gui method

definitionlist::
## parent ||
list::
##  a Window,
##  a FlowView
##  CompositeVIew
##  HLayoutView
##  VLayoutView
##  nil (which will create a Window with a FlowView on it) 
::
## bounds ||
list::
## anything that responds to asRect:
## Nil - the gui will use its own default size
## Point - width @ height
::
::

Usually the bounds are not specified.  The object's gui class first adds a container, lays its things inside that container and then shrinks the container to fit it. If you do specify a bounds, the container will be set to exactly that size.

Add a view to a parent view (window)
code::
(
	f = FlowView.new;
	nil.gui(f);
	"2".gui(f);
	2.gui(f);
)
::


method:: guiClass

Each class can specify an associated guiClass, which is a subclass of ObjectGui.
Writing useful subclasses is the purpose of the ObjectGui system and many can be found in the crucial library.

Examples specifying guiClass:

code::
	Object-guiClass {  ^ObjectGui }
	Server-guiClass {  ^ServerGui }
	AbstractPlayer-guiClass { ^AbstractPlayerGui }
	Patch-guiClass { ^PatchGui }
::

For any class where it is appropriate, a separate gui class is implemented, usually inheriting much of its behavior from the gui class of its superclass.

see link::Classes/ObjectGui::


title:: Alignment
summary:: Alignment options within the GUI system
categories:: GUI

Alignment in GUI classes is represented with the following symbols:

list::
## \left
## \center
## \right
::

Additionally, the following symbols are available in Qt GUI:

list::
## \topLeft
## \top
## \topRight
## \bottomLeft
## \bottom
## \bottomRight
::


title:: if
categories::Core, Common methods
related:: Reference/Control-Structures
summary:: conditional execution

method:: if

section::example
code::
if ( [false, true].choose,				// Boolean expression (chooses one at random)
	{ "expression was true".postln },	// true function
	{ "expression was false".postln }	// false function
)

(
var a = 1, z;
z = if (a < 5, { 100 },{ 200 });
z.postln;
)
::

UGens can also use if

the condition ugen is 0 / 1

code::
(
	{
		if( LFNoise1.kr(1.0,0.5,0.5) , SinOsc.ar, Saw.ar )
	}.play
)
::

section:: optimization

the functions will be inlined, which plucks the code from the functions and uses a more efficient jump statement.

code::
{
	if( 6 == 9,{
		"hello".postln;
	},{
		"hello".postln;
	})
}.def.dumpByteCodes

BYTECODES: (18)
  0   FE 06    PushPosInt 6
  2   FE 09    PushPosInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   F8 00 06 JumpIfFalse 6  (14)
  8   42       PushLiteral "hello"
  9   A1 00    SendMsg 'postln'
 11   FC 00 03 JumpFwd 3  (17)
 14   41       PushLiteral "hello"
 15   A1 00    SendMsg 'postln'
 17   F2       BlockReturn
a FunctionDef in closed FunctionDef
::




failure to inline due to variable declarations
code::
{

	if( 6 == 9,{
		var notHere;
		"hello".postln;
	},{
		"hello".postln;
	})

}.def.dumpByteCodes

WARNING: FunctionDef contains variable declarations and so will not be inlined.
   in file 'selected text'
   line 4 char 14 :
  		var notHere;•
  		"hello".postln;
-----------------------------------
BYTECODES: (12)
  0   FE 06    PushPosInt 6
  2   FE 09    PushPosInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   04 00    PushLiteralX instance of FunctionDef in closed FunctionDef
  7   04 01    PushLiteralX instance of FunctionDef in closed FunctionDef
  9   C3 0B    SendSpecialMsg 'if'
 11   F2       BlockReturn
a FunctionDef in closed FunctionDef
::

code::
{
	if( 6 == 9,{
		"hello".postln;
	},{
		"hello".postln;
	})
}.def.dumpByteCodes

BYTECODES: (18)
  0   FE 06    PushPosInt 6
  2   FE 09    PushPosInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   F8 00 06 JumpIfFalse 6  (14)
  8   42       PushLiteral "hello"
  9   A1 00    SendMsg 'postln'
 11   FC 00 03 JumpFwd 3  (17)
 14   41       PushLiteral "hello"
 15   A1 00    SendMsg 'postln'
 17   F2       BlockReturn
a FunctionDef in closed FunctionDef
::


title:: loop / repeat
summary:: Repeat stuff
categories::Core,Common methods

method:: loop, repeat

Create an object that behaves like a stream that returns values for a limited (or infinite) number of times.

For a full list of implementing classes, see link::Overviews/Methods#loop:: and link::Overviews/Methods#repeat::

definitionlist::
## link::Classes/Function#-loop:: ||
	repeats the function forever.
code::
	f = { 3.yield };
	x = Routine({ f.loop });
	10.do({ x.next.postln })
::

## link::Classes/Object#-repeat:: (n) ||
	repeat to yield the object
code::
	x = 5;
	y = x.repeat(6);
	y.nextN(8);
::

## link::Classes/Pattern#-repeat:: (n) ||

code::
	x = Prand([1, 2]).repeat(6).asStream;
	x.nextN(8);
::

## link::Classes/Pattern#-loop:: ||

code::
	x = Prand([1, 2]).loop.asStream;
	x.nextN(8);
::

## link::Classes/Stream#-repeat:: (n) ||

	embeds the stream repeatedly

code::
	x = Routine({ 3.do({ arg i; i.yield }) }).repeat(6);
	x.nextN(8);
::

## link::Classes/Stream#-loop:: ||

	embeds the stream repeatedly

code::
	x = Routine({ 3.do({ arg i; i.yield }) }).loop;
	x.nextN(8);
::
::


title::matchItem
categories::Common methods
summary::test if object fulfils a constraint

Implemented by: link::Classes/Object::, link::Classes/Collection::, link::Classes/Nil::, link::Classes/Function::

method:: matchItem(item)

matchItem(item) may be passed to different objects that behave as constraints. More Objects may be conceived to implement matchItem to extend the interface.

See also: link::Classes/Dictionary#-matchAt::.

section:: Object-matchItem
Test if strong::item:: is identical to strong::object::.
code::
a = [1, 2, 3, "wort", "1", [pi, 2pi]];
a.any { |x| x.matchItem(3) }; // true
a.any { |x| x.matchItem(5) }; // false
a.any { |x| x.matchItem("wort") }; // false, because "wort" == "wort" but not identical.
::

section::Collection-matchItem
Test if strong::item:: is included in strong::collection::.
code::
a = [1, 2, 3, "wort", "1", [pi, 2pi]];
a.any { |x| x.matchItem(pi) }; // true
::

section::Nil-matchItem
returns true (link::Classes/Nil:: serves as a "joker", a stand-in for anything).
code::
a = [nil, 1, 2, 3, "wort", "1", [pi, 2pi]];
a.any { |x| x.matchItem(10000.rand) }; // true always
::

section::Function-matchItem
Test strong::item:: by passing it to a function which should return a link::Classes/Boolean::.
code::
a = [10, 20, 30, { |item| item.isPrime }];
a.any { |x| x.matchItem(3) }; // true
a.any { |x| x.matchItem(4) }; // false
a.any { |x| x.matchItem(10) }; // true
::


title:: Color groups
categories:: GUI>Accessories
summary:: A list of color groups within a palette, and their meaning

A palette (see link::Classes/QPalette::) consists of colors assigned to various color roles (see  link::Reference/palette_color_roles::) within the three color groups. The following is a list of possible symbols to denote color groups, and their meanings.

table::
## strong::Group::      || strong::Meaning::
## 'active'             || Contains colors used by views on the active window.
## 'inactive'           || Contains colors used by views on inactive windows.
## 'disabled'           || Contains colors used by disabled views.
## 'normal'             || A synonym for 'active'.
::


title:: Color roles
categories:: GUI>Accessories
summary:: A list of color roles within a palette, and their meaning

A palette (see link::Classes/QPalette::) consists of colors assigned to various color roles within the three color groups (see link::Reference/palette_color_groups::). The following is a list of possible symbols to denote color roles, and their meanings.

table::
## strong::Role::    || strong::Meaning::
## 'window'          || Window background. Views may also use this role, for example to derive the color of their border. It is also the background of StaticText.
## 'windowText'      || Text on top of 'window', for example in StaticText.
## 'button'          || Everything button-alike. For example Button background, as well as Slider thumb.
## 'buttonText'      || Text on top of 'button'.
## 'brightText'      || May be used for text on pressed Button.
## 'base'            || Background of views that display a lot of text (TextView, ListView, etc.).
## 'baseText'        || Text on top of 'base'.
## 'alternateBase'   || ListView may use alternate background colors for rows.
## 'toolTipBase'     || Background of tooltips.
## 'toolTipText'     || Text of tooltips.
## 'highlight'       || Used to indicate selection, as in ListView, etc.
## 'highlightText'   || Selected text / item.
## 'link'            || Default color for links on a web page.
## 'linkVisited'     || Default color for visited links on a web page.
::

Additionally, the following roles are used to create 3D effects:

table::
## strong::Role::    || strong::Meaning::
## 'light'           || Lighter than 'button'.
## 'midlight'        || Between 'button' and 'light'.
## 'middark'         || Between 'button' and 'dark'.
## 'dark'            || Darker than 'button'.
## 'shadow'          || A very dark color.
::


title:: play
summary:: Start a process
categories:: Common methods

method:: play
The code::play:: message is of common use in sc. Different objects respond to it in various
ways, but the simple meaning is: strong::start a process::.
It is usually implemented by objects in contributed libraries as well.

play usually returns the playing object which might not be the same as the one
the message was sent to.

opposite: code::stop::

section:: Clocks, Routines, Streams and Patterns
For a full list of which classes that implements code::play::, see link::Overviews/Methods#play::

subsection:: clock.play (stream)
returns: the clock
code::
(
r = Routine.new({ "...playing".postln; 1.wait; "ok, that was it".postln });
SystemClock.play(r);
)
::
See link::Classes/Clock#*play::

subsection:: routine.play (clock)
returns: the routine
code::
Routine.new({ "...playing".postln; 1.wait; "ok, that was it".postln }).play;
::
See link::Classes/Routine#-play::

subsection:: stream.play (clock)
returns: the stream

the stream will loop until it returns nil
code::
FuncStream({ "ok, that was it".postln; 1 }).play;
::
See link::Classes/FuncStream#-play::

subsection:: pausestream.play (clock) / task.play (clock)
returns: the stream
code::
a = PauseStream.new(FuncStream.new({ "ok, that was it".postln; 1 }));
a.play;
a.stop;
a.play;
a.stop;

a = Task.new({ loop({ "ok, that was it".postln; 1.wait; }) });
a.play;
a.stop;
::
See link::Classes/Stream#-play:: and link::Classes/Task#-play::

subsection:: pattern.play (clock, protoEvent)
returns: an link::Classes/EventStreamPlayer::
code::
(
Pseq([
	Pbind(\freq, Pn(500, 1)),
	Pbind(\dur, Pn(0.1, 1))
], 2).play;
)
::
See link::Classes/Pattern#-play::

section:: Playing single Synths from SynthDefs on the server

The following play messages both cause a SynthDef to be written, send it to the server
and start a synth with it there.

note::
Some UGens are added in this process.
list::
## an link::Classes/Out:: UGen for playing the audio to the first audio busses. If the function returns an Out UGen, this is omitted. ##an envelope with a code::gate:: control for releasing and crossfading. If the function provides its own releasable envelope, this is omitted.
::
Also note that they should not be used in quickly running automated processes,
as there are more efficient alternatives ( see link::Guides/SynthDefsVsSynths:: )
::

subsection:: function.play (target, outbus, fadeTime, addAction, args)

returns: a link::Classes/Synth::
table::
## outbus || on what bus to play (default: 0)
## fadeTime || in what time to fade out when released (default: 0.02)
## addAction || where to add the node (\addToHead by default)
## args || controls to set when starting the synth
::


See link::Classes/Function#-play::

code::
a = { PinkNoise.ar([0.1, 0.1]) }.play;
a.release;

// setting argument
a = { |freq = 500| HPF.ar(PinkNoise.ar([1, 1] * 0.4), freq) }.play;
a.set(\freq, 1000)
a.release;

// passing argument with play:
a = { |freq = 500| HPF.ar(PinkNoise.ar([1, 1] * 0.4), freq) }.play(args: [\freq, 10000]);

// note that you can use Out ugens but you do not need to
{ Out.ar(1, PinkNoise.ar(0.1)) }.play;
{ XOut.ar(0, MouseX.kr(0,1), PinkNoise.ar(0.1*[1,1])) }.play; // mouse x controls level
::

subsection:: synthDef.play (target, args, addAction)
returns: a link::Classes/Synth::

Note that you need an out ugen to hear the result.
Examples of how to write to the busses in the helpfiles: link::Classes/Out:: / link::Classes/ReplaceOut:: / link::Classes/XOut:: / link::Classes/OffsetOut::

Nevertheless, synths can also run without any writing activity: (see e.g. link::Classes/SendTrig::)

Some operations provide an out ugen internally: see for example code::function.play::, which plays out
to a bus number provided in the argument passed to code::.play::

code::
(
x = SynthDef(\test, { arg out, amp=0.1;
	var sound;
	sound = PinkNoise.ar(amp * [1,1]);
	Out.ar(out, sound);
}).play;
)

//set the synth
x.set(\amp, 0.2);
//free the synth
x.free;
::
See link::Classes/SynthDef#-play::

note:: code::Synth.play(function):: is synonymous, for backwards compatibility with sc2 ::



title:: playN
summary:: distribute audio over multiple non-adjacent channels
categories:: JITLib>NodeProxy
related:: Classes/Monitor, Classes/Bus, Classes/NodeProxy, Classes/Ndef, Classes/ProxySpace

method:: playN

playN is a multichannel play method for link::Classes/Monitor:: and link::Classes/NodeProxy:: (see also: link::Classes/ProxySpace::, link::Classes/Ndef::) that supports playing proxy outputs over strong::non-adjacent channels::; somewhat like a splitter/line mixer.

code::
// examples

s.boot;

p = ProxySpace.push;
s.scope(8);

	// a 3 channel test sound
~test3 = { SinOsc.ar([2, 3, 5] * 100) * 0.2 };

	// compare: play out of 3 adjacent channels
~test3.play(3);
~test3.play(6);

~test3.stop;
~test3.play;	// play remembers old (series) output settings;


	// outs
~test3.playN([2, 4,7]) // playN to 3 non-adjacent channels

	// set outs, amps and vol:
(
~test3.playN(
	outs: [2,3,5],
	amps: [0.5, 0.25, 0.125],
	vol: 1
);
)
~test3.vol_(2);

~test3.stop;
~test3.playN;	// remembers last state.

		// if playN has been used, one can set outs while playing.
		// note: this does not work reliably with the .play method!
~test3.monitor.outs_([3,2,1]);

		// set amps while playing.
		// note: this does not work with play method!
~test3.monitor.amps_(1/[1, 2, 3]).vol_(1);
~test3.playN;
~test3.monitor.outs_([2, 4, 7]);


	// one can also spread out one channel to several, with given amplitudes:
(
~test3.playN(
	outs: [1, 3, [5,6,7]],
	amps: [0.5, 0.25, [0.125,0.25, 0.5]],
	vol: 2
);
)

~test3.stop;
~test3.playN;

		// do changes while off:
~test3.stop;
~test3.monitor.outs_([2, 4, [5,6,3]]);
~test3.monitor.amps_(1/[1, 2, [3,2,1]]);
~test3.playN;

		// the most comfortable way to edit those parameters is using a text file:
~test3.playNDialog;


	// output mapping can be prepared before playN is used:
~test3.clear;

~test3 = { SinOsc.ar([2, 3, 5] * 100) * 0.2 };

~test3.vol_(0.5);		// vol can be set already

	// outs and amps require making a monitor first;
~test3.initMonitor;

~test3.monitor.outs_([3, 5, 6]);

~test3.monitor.amps_([1, 2, 3]);

~test3.playN;

~test3.end;
~test3.clear;

p.clean;
p.pop;
::


title:: plot
summary:: Plot data in a graph
categories:: Common methods, GUI


section:: Description
The link::Overviews/Methods#plot#plot method:: provides the ability to plot data in a GUI window. The method is implemented in the link::Classes/ArrayedCollection:: class but is also available for other classes for convenience, including link::Classes/Function::, link::Classes/Bus::, link::Classes/Env::, link::Classes/Buffer::, link::Classes/SoundFile::, link::Classes/Wavetable::.

method:: plot
All arguments are optional.
note::The arguments available vary from object to object. The below list is only for explanation of possible arguments.::


argument:: name
The name to be used as the GUI window title.

argument:: bounds
A link::Classes/Rect:: providing coordinates for the GUI location.

argument:: discrete
Plots are line-plots by default. Set this to code::true:: for bar charts.

argument:: numChannels
The number of interleaved channels that an array represents. For Buffers this argument is not available, since it's filled in automatically.

argument:: minval
Minimum value(s) for the display range. For a Buffer this defaults to code::-1:: but can be changed.

argument:: maxval
Maximum value(s) for the display range. For a Buffer this defaults to code::+1:: but can be changed.

argument:: separately
When finding the right display range in multi channel plots, do this together for all or keep them separate.

argument:: parent
By default the plot is placed in a new GUI window. This argument can be used to specify an existing GUI container to send the plot to.

argument:: labels
By default labels appear at the top left of the plot giving a data readout based on mouse position. Set this argument to code::false:: to prevent them appearing.


discussion::
If code::minval:: and/or code::maxval:: are set to code::nil:: (this is default, except for link::Classes/Buffer::s), they will be automatically calculated from the dataset minimum and/or maximum. For multi-channel data, code::minval:: and code::maxval:: may be arrays, specifying the range independently for each channel (including use of code::nil::, in which case the min/max will be calculated for the specific channel rather than for the overall dataset). When the receiver contains code::nil:: items, the plot fails with an error.

Hitting the strong::E-key:: on the keyboard when the window is focussed toggles the lock, and the window can be used to edit the data.

section:: Examples

note:: See some of the classes linked above for more examples ::

code::
// Arrays
[5, 6, 7, 6.5, 4.5, 3.5].plot("Some data")
[5, 6, 7, 6.5, 4.5, 3.5].plot("Some data, in stereo", numChannels:2)
[5, 6, 7, 6.5, 4.5, 3.5].plot("Some data, in stereo", numChannels:2, discrete: true)

{ |i| { |j| j + 1 * (i + 1) % 6 }.dup(100) }.dup(5).plot("Some 2-d data");

// 3-channel interlaced data
b = [{1.0.rand}.dup(50), { 20.0.rand - 30 }.dup(50),{ 10.0.rand }.dup(50)].lace(150);
b.plot(numChannels:3); // Common rescaling
b.plot(numChannels:3, separately: false);
b.plot(numChannels:3, minval: [nil, -100, nil], maxval: [nil, nil, 10]); // multichannel range parameters

// Envelopes
Env.adsr(0.4, 0.4, 0.8, 0.9).plot

// Buffers
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.plot; // +-1 range
b.plot(minval: nil, maxval: nil); // auto range
b.plot(minval: 0, maxval: nil); // semi-auto range

// UGen functions
{ LFDNoise3.ar(XLine.ar(1000, 100, 0.1) ! 3) }.plot(0.1);
::


title::Random Seed
summary:: Random generator seed
categories::Core>Kernel, Random
related:: Guides/Randomness, Classes/RandSeed, Classes/Pseed, Classes/Thread

section:: Introduction

Every link::Classes/Thread:: in sclang has a (pseudo-) random number generator that is responsible for all randomization within this thread. Each random number generator has its own seed (starting point) from which the series of values is generated. This seed can be set and after that, the randgen (being strictly deterministic) produces exactly the same numbers again.

In order to save disk space, you can reproduce any sequence of randomized data just by one Integer number that you can write down in your notebook.

method:: randSeed

code::
// every thread, also a Routine, has a random generator seed:
(
r = Routine({
	loop({#[1,2,3,4,5].choose.yield })
});
r.randSeed = 1923;
)

// using the routine to fill an array
Array.fill(7, r);

// setting the random generator seed back to our initial seed
r.randSeed = 1923;

// causes this array to be identical
Array.fill(7, r);
::

subsection::Inheriting Seeds

When a routine is created, it inherits its random number generator from the parent thread (link::Classes/Thread#.thisThread#thisThread::). If no particular randSeed is set (the normal case), then the same random number generator object provides numbers to both the parent and the child (one stream of random numbers, distributed between both).

The parent thread is whichever Routine is in force at the moment of creating a new Routine. If no Routine is evaluating at that moment, then the parent is the sclang process main link::Classes/Thread::. By default, all Routines inherit the random number generator from the main thread.

To set the main random seed for the entire application, then, evaluate code::thisThread.randSeed = yourSeed:: outside of the context of any Routine, as in the example below.

code::
thisThread.randSeed = 1923;

// create a function that returns a Routine

r = { Routine({
	loop({#[1,2,3,4,5].choose.yield })
}) };

Array.fill(7, r.value);

// reset the seed
thisThread.randSeed = 1923;

Array.fill(7, r.value);
::

When you set code::randSeed:: on a Routine, the Routine switches to its own random number generator, independent of any other. Subsequently, Routines created within this Routine will inherit its unique random number generator.

code::
(
thisThread.randSeed = 1000;
TempoClock.sched(0, { 1000.rand.debug("main RNG"); 1 });

fork {
	2.1.wait;
	thisThread.randSeed = 1000;
	loop { 1000.rand.debug("routine RNG"); 1.wait }
};
)

main RNG: 592 // sequence is 592, 876, 614, 236...
main RNG: 876
main RNG: 614
routine RNG: 592 // sequence is 592, 876...
main RNG: 236
routine RNG: 876
::

Note that this inheritance takes place only at the moment of creating a new Routine. Calling code::next:: or code::play:: on the child Routine does not override that Routine's random number generator.

subsection:: Audio example

code::
// use the seed to completely reproduce a sound:
(
SynthDef(\help_randomSeed, { arg out=0, freq=440;
	Out.ar(out,
		Line.kr(1, 0, 0.3, doneAction: Done.freeSelf) *
		Resonz.ar(
			Dust2.ar([10, 10], 270) + WhiteNoise.ar(4),
		freq, 0.01)
	)
}).send(s);

SynthDef(\help_setRandomSeed, { arg seed=1956, tbus=0.0;
		RandSeed.kr(tbus, seed);
}).send(s);
)

// run a patch
(
x = Synth(\help_setRandomSeed);
r = Routine({
	loop({
		Synth(\help_randomSeed, [\freq, rrand(440, 700)]);
		0.25.wait;
	})
}).play;
)


// make a reset task

(
d = 1250;// seed
t = Task({
	loop({
		x.set(\seed, d, \tbus, 1.0); r.randSeed = d;
		0.1.wait;
		x.set(\tbus, 0.0);
		1.9.wait;
	})
});
)

// sound starts to loop
t.start;

d = 1251; // different loop
d = 1925;


// sound is just like random again, not interested in anything.
t.stop;
::



title:: softPut
summary:: set a (number) parameter in an environment conditionally
categories:: JITLib>GUI
related:: Reference/softSet, Reference/softVol_

description::
code::softPut:: is an extension method to link::Classes/Dictionary:: that changes an existing numerical value for key in a dictionary only in two conditions:
list::
## if the new value is close enough to the current value at that key;
## or if the setting controller knows the previous value and sends it along. the idea here is that if the controller knows it did the last value change, it has authority to jump now.
::
Typical uses would be switching to a new preset, then using a faderbox, and avoiding sudden controller jumps that could occur (soft takeover).

method:: softPut (param, val, within = 0.025, lastVal, mapped = true, spec)
argument:: param
the name of the parameter (key) to set
argument:: val
the value to set the param to (can be mapped or unmapped)
argument:: within
the normalized range within which the set is accepted - default is 0.025
argument:: mapped
a flag whether strong::val:: is mapped (within the range of param.asSpec) or unmapped (0.0-1.0)
argument:: lastVal
the previous value that a control has set - see last examples.
argument:: spec
a link::Classes/ControlSpec:: can be passed in. if nil, param.asSpec is used.
note::
if no spec is given, or no value exists yet, softSet simply allows setting.
::

examples::
code::
(
e = (amp: 0.1, dur: 0.2);
Tdef(\test, {
	var dur;
	loop {
		dur = e.dur;
		(amp: e.amp, dur: dur, degree: 7.rand).play;
		dur.wait;
	};
}).play;
)

e.put(\amp, 0.03);	// just set it
e.put(\amp, 0.1);
e.softPut(\amp, 0.11);	// small change, OK to set
e.put(\amp, 0.1);
e.softPut(\amp, 0.15);	// no bigger change
e.softPut(\amp, 0.15, 0.1);	// bigger change is OK with larger within value

e.softPut(\amp, 0.01);	// no
e.softPut(\amp, 0.01, lastVal: 0.15);	// can make big jumps when lastVal is close to current.

	// no spec for dur exists by default:
	\dur.asSpec

e.softPut(\dur, 0.05);	// so this always really sets.
::

code::

	// PatternProxies ( e.g. Tdefs, Pdefs) have a softSet method, which
	// forwards softPut to their envirs:

Pdef(\test, Pbind(\degree, Pseq((0..7), inf))).play;

Pdef(\test).set(\amp, 0.03)
Pdef(\test).envir.softPut(\amp, 0.06); // no, too big
Pdef(\test).envir.softPut(\amp, 0.06, 0.1); // ok with wider range

	// equivalent:
Pdef(\test).set(\amp, 0.03)
Pdef(\test).softSet(\amp, 0.1); // no, too big
Pdef(\test).softSet(\amp, 0.06, 0.1); // ok with wider "within"
Pdef(\test).get(\amp)

Pdef(\test).softSet(\amp, 0.5); // no!
Pdef(\test).softSet(\amp, 0.5, lastVal: 0.06); // ok!
Pdef(\test).softSet(\amp, 0.05, lastVal: 0.5); // ok

Pdef(\test).softSet(\dur, 0.05); // alsways ok, no spec for dur.
Pdef(\test).softSet(\dur, 0.1); // ok

Pdef(\test).softSet(\dur, 0.05, spec: [0.03, 3, \exp]); // not OK with that spec
::

code::

	// softPut and softSet can be risky - one can lose a parameter when moving a controller
	// too quickly. So, if we know the last value (e.g. because the same controller
	// knows it has set to that value), it is OK to jump:

	// example of softSet, softSet which knows lastVal,
	// softVol_ and softVol_ which knows lastVol:
(
w = Window("softSet, softVol", Rect(500, 200, 400, 240)).front;
w.view.addFlowLayout;
PdefGui(Pdef(\test), 2, w, 340@80);

	// can lose control if wiggled too fast
EZSlider(w, 340@30, \softSetDur, [0.03, 3, \exp], { |sl|
	Pdef(\test).softSet(\dur, sl.value, 0.05)
});

	// knows it was in control
EZSlider(w, 340@30, \knowsLast, [0.03, 3, \exp], Routine { |sl|
	var newVal, lastVal;
	loop {
		newVal = sl.value;
		Pdef(\test).softSet(\dur, newVal, 0.05, lastVal: lastVal);
		lastVal = newVal;
		\dummy.yield;
	}
});
)
::


title:: softSet
summary:: set a proxy param value conditionally
categories:: JITLib>GUI
related:: Reference/softVol_, Reference/softPut

description::
code::softSet:: is an extension method to link::Classes/NodeProxy:: and link::Classes/Ndef:: that sets a nodeproxy param value only in two conditions:
list::
## if the new value is close enough to the current param value;
## or if the setting controller knows the previous value and sends it along. the idea here is that if the controller knows it did the last value change, it has authority to jump now.
::
Typical uses would be switching to a preset, then using a faderbox, and avoiding sudden controller jumps that could occur (soft takeover).

method:: softSet (param, val, within = 0.025, mapped=false, lastVal, spec)
argument:: param
the name of the parameter to set
argument:: val
the value to set the param to (can be mapped or unmapped)
argument:: within
the normalized range within which the set is accepted - default is 0.025
argument:: lastVal
the previous value that a control has set - see last examples.
argument:: mapped
a flag whether strong::val:: is mapped (within the range of param.asSpec) or unmapped (0.0-1.0)
argument:: spec
a link::Classes/ControlSpec:: can be passed in. if nil, param.asSpec is used.
note::
if no spec is given, softSet simply allows setting.
::

examples::
code::
Ndef(\test, { |freq=200| Splay.ar(SinOsc.ar(freq * Array.rand(12, 0.95, 1.05))) });
Ndef(\test).play(vol: 0.1);

Ndef(\test).gui(4)

Ndef(\test).set(\freq, 300);

		// 3 midi steps == 0.02362;
Ndef(\test).softSet(\freq, 320, 0.03); // ok
Ndef(\test).softSet(\freq, 280, 0.03); // ok
Ndef(\test).softSet(\freq, 200, 0.03); // returns false if too big jump

Ndef(\test).set(\freq, 600);

	// softSet can be risky - one can lose a parameter when moving a controller
	// too quickly. So, if we know the last value (e.g. because the same controller
	// knows it has set to that value), it is OK to jump:
Ndef(\test).softSet(\freq, 330, 0.03, lastVal: 630);

Ndef(\test).softSet(\freq, rrand(300, 350), 0.01);	// sometimes yes, sometimes no


	// use unmapped, i.e. normalized values to set:

Ndef(\test).set(\freq, 600);	// ok
Ndef(\test).softSet(\freq, 0.5, 0.05, mapped: false);	// ok
Ndef(\test).softSet(\freq, 0.45, 0.03, mapped: false);	// no, too big
Ndef(\test).softSet(\freq, 0.3, 0.03, mapped: false, lastVal: 0.5);	// but ok if lastVal is close


	// example of softSet, softSet which knows lastVal,
	// softVol_ and softVol_ which knows lastVol:
(
w = Window("softSet, softVol", Rect(500, 200, 400, 240)).front;
w.view.addFlowLayout;
NdefGui(Ndef(\test), 2, w);

	// can lose control if wiggled too fast
EZSlider(w, 340@30, \softSet, \freq, { |sl|
	Ndef(\test).softSet(\freq, sl.value, 0.05)
});

	// knows it was in control
EZSlider(w, 340@30, \knowsLast, \freq, Routine { |sl|
	var newVal, lastVal;
	loop {
		newVal = sl.value;
		Ndef(\test).softSet(\freq, newVal, 0.05, lastVal: lastVal);
		lastVal = newVal;
		\dummy.yield;
	}
});

	// same for volume - not too safe
EZSlider(w, 340@30, \softVol, \amp, { |sl|
	Ndef(\test).softVol_(sl.value, 0.05)
});
	// safer
EZSlider(w, 340@30, \knowLastV, \amp, Routine { |sl|
	var newVal, lastVal;
	loop {
		newVal = sl.value;
		Ndef(\test).softVol_(sl.value, 0.05, lastVal: lastVal);
		lastVal = newVal;
		\dummy.yield;
	}
});
)
::


title:: softVol_
summary:: set a nodeproxy's vol conditionally
categories:: JITLib>GUI
related:: Reference/softSet, Reference/softPut

description::
Extension method to link::Classes/NodeProxy:: to set vol conditionally.

method:: softVol
setter.

argument:: val
the volume value to set to
argument:: within
the normalized range within which the set is accepted
argument:: pause
a flag whether to pause the nodeproxy when volume is 0.
waits for 0.2 seconds for volume to go down first.
argument:: lastVal
the previous value that the controller has set - can be
argument:: spec
a link::Classes/ControlSpec:: can be passed in. if nil, code::\amp.asSpec:: is used.

Examples::
code::
Ndef(\test, { |freq=200| Splay.ar(SinOsc.ar(freq * Array.rand(12, 0.95, 1.05))) });
Ndef(\test).play(vol: 0.1);

	// example of softSet, softSet which knows lastVal,
	// softVol_ and softVol_ which knows lastVol:
(
w = Window("softVol", Rect(500, 200, 400, 240)).front;
w.view.addFlowLayout;
NdefGui(Ndef(\test), 2, w);

	// same for volume - not too safe
EZSlider(w, 340@30, \softVol, \amp, { |sl|
	Ndef(\test).softVol_(sl.value, 0.05)
});
	// safer
EZSlider(w, 340@30, \knowLastV, \amp, Routine { |sl|
	var newVal, lastVal;
	loop {
		newVal = sl.value;
		Ndef(\test).softVol_(sl.value, 0.05, lastVal: lastVal);
		lastVal = newVal;
		\dummy.yield;
	}
});
)
::


