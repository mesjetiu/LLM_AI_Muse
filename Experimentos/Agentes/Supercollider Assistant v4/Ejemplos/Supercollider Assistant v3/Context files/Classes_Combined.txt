class:: A2K
summary:: Audio to control rate converter.
related:: Classes/K2A
categories::  UGens>Conversion


Description::

Audio to control rate converter. Only needed in specific cases.


classmethods::

method::kr

argument::in
The input signal.



class:: APF
summary:: FIXME: APF purpose.
categories::  UGens>Filters>Linear, UGens>Undocumented


Description::

FIXME: APF description.


classmethods::

method::ar, kr

argument::in

FIXME: explain parameter in.


argument::freq

FIXME: explain parameter freq.


argument::radius

FIXME: explain parameter radius.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.



CLASS:: AbstractDispatcher
summary:: Dispatches incoming messages to Functions
categories:: External Control>Abstract Classes
related:: Classes/AbstractWrappingDispatcher, Classes/OSCMessageDispatcher, Classes/OSCMessagePatternDispatcher, Classes/MIDIMessageDispatcher, Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractResponderFunc

DESCRIPTION::
Instances of AbstractDispatcher dispatch incoming messages (e.g. MIDI, OSC), to registered instances of link::Classes/AbstractResponderFunc::. There will be a default dispatcher for each message type, but one can have multiple dispatchers per type in order to implement custom dispatching for groups of ResponderFuncs. (The main example of this is OSC pattern matching with link::Classes/OSCMessagePatternDispatcher::.) Normally users do not need to access dispatcher instances directly.

Dispatchers must be registered at the appropriate central point (e.g. Main:recvOSCfunc for OSC messages). In this capacity their interfaces mimic link::Classes/Function:: and link::Classes/FunctionList::.


CLASSMETHODS::
private:: initClass

METHOD:: all
Get a collection of all currently active dispatchers.

returns:: An link::Classes/IdentitySet::.

METHOD:: new
Make a new dispatcher.

returns:: A new instance.


INSTANCEMETHODS::
private:: init

METHOD:: add
Add a responder func to this dispatcher. Subclasses should override this to do any necessary bookkeeping. Generally this method should add this dispatcher as a dependant of the responder func, so that it can respond to any changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to add.

METHOD:: remove
Remove a responder func from this dispatcher.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to remove.

METHOD:: value
Evaluate an incoming message to see if it matches. Subclasses should override this message to take appropriate arguments. If a matching responder func is found, this method should call value on it, passing the message.

METHOD:: valueArray
As link::#-value:: above, but with the arguments passed as a single link::Classes/Array::. This method is needed so that subclasses can work in FunctionLists in central message registration points such as Main:recvOSCMessage.

argument:: args
An link::Classes/Array:: containing the message and appropriate arguments.

METHOD:: register
Register this dispatcher at the appropriate central point (e.g. Main:recvOSCfunc) to receive its message type. Subclasses should take care to not override any other registered objects. (So for example use Main:addOSCFunc for OSC messages rather than Main:recvOSCfunc_.) Generally speaking, dispatchers should register themselves automatically if needed when a responder func is added.

METHOD:: unregister
Remove this dispatcher from the appropriate central registration point, i.e. deactivate it. Generally speaking a dispatcher should unregister itself automatically when its last responder func is removed.

METHOD:: free
link::#-unregister:: this dispatcher and remove it from link::#*all::. After this the dispatcher should be discarded.

METHOD:: typeKey
Subclasses should override this method to return a key indicating the type of message this dispatcher responds to, e.g. code::'OSC matched':: or code::'MIDI control'::.

returns:: A link::Classes/Symbol::.

METHOD:: update
Subclasses should override this to do any necessary updating when a dispatchers responder funcs indicate they have changed via the standard dependancy mechanism. The default implementation does nothing.



class::AbstractFunction
summary::An object which responds to a set of messages that represent mathematical functions
categories::Core>Kernel
related::Classes/UGen,Classes/Pattern,Classes/Function,Overviews/Operators

description::

An AbstractFunction is an object which responds to a set of messages that represent
mathematical functions. Subclasses override a smaller set of messages to respond
to the mathematical functions.

The intent is to provide a mechanism for functions that do not calculate values directly but instead compose structures for calculating (lazy evaluation).

Function, Pattern, Stream and UGen are subclasses of AbstractFunction.
For example, if you multiply two UGens together the receiver responds by returning a new
instance of class BinaryOpUGen which has the two operands as inputs.

code::
{ var a, b; a = LFSaw.ar(220); b = LFPulse.ar(1442); [a, b, a * b] }.plot;
::

For an overview of common operators, see link::Overviews/Operators::, for specific examples, see also e.g. link::Classes/Function::, link::Classes/UGen::, link::Classes/Pattern::.
To see which classes implement a specific method, see that method in the generated link::Overviews/Methods:: overview.

instanceMethods::

subsection::Unary Messages

The following messages return an object which represents a delayed unary operation, i.e. an operation on one object. For example, the reciprocal of a function will result in a new function that, when called, returns the reciprocal of the evaluation of the operand.

All of the following messages send the message composeUnaryOp to the receiver with the
unary message selector as an argument.
See link::Classes/UnaryOpFunction::.

method::neg
code::
a = { 10.rand.postln }; b = a.neg; b.value;
// Patterns, Streams, UGens, and Proxies are AbstractFunctions, too:
a = Pgeom(1, 2, 5).neg; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.neg] }.plot;
::
method::reciprocal
code::
a = { 10.rand.postln }; b = a.reciprocal; b.value;
a = Pgeom(1, 2, 5).reciprocal; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500) + 2; [a, a.reciprocal] }.plot;
::
method::bitNot
Bitwise integer negation.
method::abs
Absolute value
code::
a = { 10.rand - 10.rand }; b = a.abs; b.value;
a = Pseries(3, -1.8, inf).abs; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.abs] }.plot;
::
method::asFloat
code::
a = { "123.471".scramble }; b = a.asFloat; b.value;
::
method::asInt
Deprecated. Use code::asInteger:: instead.
method::asInteger
code::
a = { "123471".scramble }; b = a.asInteger; b.value;
::
method::ceil, floor, frac
code::
a = { 10.0.rand2.postln }; b = a.ceil; b.value;
a = { 10.0.rand2.postln }; b = a.floor; b.value;
a = Pgeom(1, 1.2, inf).ceil; a.asStream.nextN(8);
a = Pgeom(1, 1.2, inf).floor; a.asStream.nextN(8);
{ a = SinOsc.ar(150) * 1.5; [a, a.ceil, a.floor, a.frac] }.plot.superpose_(true);
::
method::sign
Returns a function that returns -1 if receiver returns a negative number, 1 if positive, and 0 if zero.
code::
a = { 10.0.rand2.postln }; b = a.sign; b.value;
{ a = LFNoise1.ar(1500) * 1.5; [a, a.sign] }.plot;
::
method::squared
code::
a = { |x| x + 1 }; b = a.squared; [a.value(1), b.value(1)];
a = Pseries(0, 1, inf).squared; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.squared] }.plot;
::
method::cubed
code::
a = { |x| x + 1 }; b = a.cubed; [a.value(1), b.value(1)];
a = Pseries(0, 1, inf).cubed; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.cubed] }.plot;
::
method::sqrt
code::
a = { |x| x + 1 }; b = a.sqrt; [a.value(1), b.value(1)];
a = Pseries(0, 1, inf).sqrt; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.sqrt] }.plot;
::
method::exp
Returns e to the power of this.
code::
a = { |x| x + 1 }; b = a.exp; [a.value(1), b.value(1)];
a = Pseries(0, 0.25, inf).exp; a.asStream.nextN(8);
{ a = LFNoise1.ar(1500); [a, a.exp] }.plot;
::
method::midicps
Converts midinote into cycles per seconds (Hz).
code::
a = { |x, root = 60| x + root }; b = a.midicps; [a.value(9), b.value(9)];
a = Pseries(60, 1, inf).midicps; a.asStream.nextN(12);
{ a = LFNoise1.ar(1) * 5 + 60; Pulse.ar(a.round.midicps) * 0.1 }.play;
::
method::cpsmidi
Converts cycles per seconds (Hz) into midinote.
code::
a = { |x| #[440, 720, 801, 1020.2].at(x) }; b = a.cpsmidi; [a.value(3), b.value(3)];
a = Pseries(220, 220, inf).cpsmidi; a.asStream.nextN(12); // overtone series as midinotes
// follow but round to next midinote
{ a = Pitch.kr(SoundIn.ar).at(1); Pulse.ar(a.cpsmidi.round.midicps) * 0.1 }.play;
::
method::midiratio
method::ratiomidi
method::ampdb
method::dbamp
method::octcps
method::cpsoct
method::log
method::log2
method::log10
method::sin
method::cos
method::tan
method::asin
method::acos
method::atan
method::sinh
method::cosh
method::tanh
method::rand
method::rand2
method::linrand
method::bilinrand
method::sum3rand
method::distort
method::softclip
method::coin
method::even
method::odd
method::isPositive
method::isNegative
method::isStrictlyPositive
method::rho
method::theta

subsection::Binary Messages

The following messages return an object which represents a delayed binary operation, i.e. an operation between two objects. For example, adding two functions will result in a new function that, when called, adds the results of the evaluation of the two operands.

All of the following messages send the message composeBinaryOp to the receiver with the
binary message selector and the second operand as arguments.
See: link::Classes/BinaryOpFunction::.


Examples:
code::
(
// Add two functions:
var x = { |x| x + 1000 } + { |x| x * 100 };
// Evaluate the result, passing in one argument:
x.value(2); // posts 1202
)
// either operand can be another object:
(
// Add two functions:
var x = 1871 + { |x| x * 12 };
x.value(12);
)
::
code::
(
// Add two UGens
{
 SinOsc.ar(440, 0, 0.2) + PinkNoise.ar(0.1);
}.play
)
::
// Add two Patterns
code::
(Pseq([1, 2, 3, 4]) + Prand([0, 0.1, -0.1], inf)).asStream.nextN(5);
::
// Add two NodeProxies
code::
Ndef(\x, { SinOsc.ar(440, 0, 0.2) });
Ndef(\y, { PinkNoise.ar(0.1) });
Ndef(\z, Ndef(\x) + Ndef(\y)).play;
::

method::+
code::
({ |x| x.squared } + 3).value(2);
::
method::-
code::
({ |x| x.squared } - 3).value(2);
::
method::*
code::
({ |x| x.squared } * { |x| x.squared }).value(2);
::
method::/
code::
({ |x| x.squared } / 4).value(2);
::
method::div
code::
({ |x| x.squared } div: 3).value(2);
::
method::%
code::
({ |x| x.squared } % 3).value(2);
::
method::**
code::
({ |x| x.squared } ** 3).value(2);
::
method::min
code::
({ |x| x.squared } min: 0).value(2);
::
method::max
code::
({ |x| x.squared } max: 0).value(2);
::
method::<
code::
({ |x| x.squared } < 3).value(2);
::
method::<=
code::
({ |x| x.squared } <= 3).value(2);
::
method::>
code::
({ |x| x.squared } > 3).value(2);
::
method::>=
code::
({ |x| x.squared } >= 3).value(2);
::
method::&
code::
a = { |min, max| ({ rrand(min, max) } ! 4).postln };
(a & a).value(0, 8);
::
method::|
code::
a = { |min, max| ({ rrand(min, max) } ! 4).postln };
(a | a).value(0, 8);
::
method::lcm
code::
a = { |min, max| rrand(min, max).postln };
(a lcm: a).value(0, 8);
::
method::gcd
code::
a = { |min, max| rrand(min, max).postln };
(a gcd: a).value(0, 8);
::
method::round
code::
a = { |max| max.rand.postln };
(a round: 0.5).value(1.0);
::
method::trunc
code::
a = { |max| max.rand.postln };
(a trunc: 2).value(10);
::
method::atan2
code::
a = { 1.0.rand2 };
a.atan2.dup(10);
::
method::hypot
code::
a = { 1.0.rand2 };
a.hypot.dup(10);
::
method::hypotApx
code::
a = { 1.0.rand2 };
a.hypotApx.dup(10);
::
method::>>
code::
a = { [2r10010, 2r101011, 2r11100].choose.postln };
b = a >> 2;
b.value.asBinaryDigits.join;
::
method::+>>
code::
a = { [2r10010, 2r101011, 2r11100].choose.postln };
b = a +>> 2;
b.value.asBinaryDigits.join;
::
method::ring1

(a * b) + a

code::
({ [5, 6, 2].choose.postln } ring1: { [2, -1, 3].choose.postln }).value

// UGens are also abstract functions
(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
ring1(a, b) * 0.1 }.play;
)
::
method::ring2

((a*b) + a + b)

code::
({ [5, 6, 2].choose.postln } ring2: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
ring2(a, b) * 0.1 }.play;
)
::
method::ring3

(a * a * b)

code::
({ [5, 6, 2].choose.postln } ring3: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
ring3(a, b) * 0.1 }.play;
)
::
method::ring4

((a*a *b) - (a*b*b))

code::
({ [5, 6, 2].choose.postln } ring4: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
ring4(a, b) * 0.1 }.play;
)
::
method::difsqr

(a*a) - (b*b)

code::
({ [5, 6, 2].choose.postln } difsqr: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
difsqr(a, b) * 0.1 }.play;
)
::
method::sumsqr

(a*a) + (b*b)

code::
({ [5, 6, 2].choose.postln } sumsqr: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
sumsqr(a, b) * 0.1 }.play;
)
::
method::sqrdif

(a - b) ** 2

code::
({ [5, 6, 2].choose.postln } sqrdif: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
ring4(a, b) * 0.1 }.play;
)
::
method::sqrsum

(a + b) ** 2

code::
({ [5, 6, 2].choose.postln } sqrsum: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
sqrsum(a, b) * 0.1 }.play;
)
::
method::absdif

(a - b).abs

code::
({ [5, 6, 2].choose.postln } absdif: { [2, -1, 3].choose.postln }).value

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
absdif(a, b) * 0.1 }.play;
)
::

method::moddif
absolute difference in modulo arithmetics.

method::amclip
0 when b <= 0, a*b when b > 0

method::scaleneg
a * b when a < 0, otherwise a.

method::clip2
clips receiver to +/- aNumber

method::excess
Returns the difference of the receiver and its clipped form.
method::<!
method::rrand
code::
a = { |x| sin(x) } rrand: { |x| sin(x) *  -1 };
(0..1000).normalize(0, 5pi).collect(a).plot;

(
{ a = SinOsc.ar(335); b = SinOsc.ar(MouseX.kr(1, 1000, 1));
rrand(a, b) * 0.1 }.play;
)
::
method::exprand
method::rotate
method::dist
method::bitAnd
method::bitOr
method::bitXor
method::bitHammingDistance
method::@

subsection:: Messages with more arguments (n-ary Operators)

The following messages return an object which represents a delayed n-ary operation, i.e. an operation between several objects (often three). For example, rescaling a function with linlin will result in a new function that, when called, scales the results of the evaluation of all operands.

All of the following messages send the message code::composeNAryOp:: to the receiver with the
binary message selector and the other operands as arguments.
See link::Classes/NAryOpFunction::.

method::clip
method::wrap
method::fold
method::blend
method::linlin
method::linexp
method::explin
method::expexp

subsection:: other

method::applyTo

Interface that allows us to combine selectors (Symbols) and Functions. Sends valueArray(args) to this.
discussion::
code::
// example:

f = [{ |a, b| a * b * 100.rand }, { |a, b| sin(a) * sin(b) }, '*', '/'];
f.choose.postcs.applyTo(3, 4);

// this is used in SequenceableCollection reduce:
(1..10).reduce('+');
(1..10).reduce({ |a, b| a * b * 1.0.rand });
::

method::asUGenInput

returns:: the result of sending the value(for) message to this.
discussion::
code::
// example:
(
var f, g, product;
f = { SinOsc.ar(400) };
g = { LFPulse.kr(8)  };
product = f * g * 0.1;
{ Pan2.ar(product, SinOsc.kr(0.3)) }.play;
)
::

method::sampled
Sample a function.
discussion::
code::
//sample a function
f = { |x| sin(3*x)*cos(8*x) }
f.plotGraph(from:0,to:2);
f.sampled(10,0,2).plotGraph(from:0,to:2);
f.sampled(80,0,2).plotGraph(from:0,to:2);

//on complicated functions a sampled function is less cpy heavy.
f = { |x| 60.collect{ 2**((x-rrand(0.0,1.0))) }.sum/60 };
f.plotGraph(from:0,to:1);
g = f.sampled(200);
g.plotGraph(from:0,to:1);
{ 200.collect{ f.(rand(0.0,1.0)) } }.bench;
{ 200.collect{ g.(rand(0.0,1.0)) } }.bench;
::

method::plotGraph
Sample the function with n points, in the range [from, to], and plot it in a Plotter.
Returns a link::Classes/Plotter::.

argument:: n
Number of values displayed in the plot window (500 by default).
argument:: from
Minimum value passed to the function.
argument:: to
Maximum value passed to the function.

argument:: name
See link::Reference/plot::
argument:: bounds
See link::Reference/plot::
argument:: discrete
See link::Reference/plot::
argument:: numChannels
See link::Reference/plot::
argument:: minval
See link::Reference/plot::
argument:: maxval
See link::Reference/plot::
argument:: separately
See link::Reference/plot::

returns:: a link::Classes/Plotter::

discussion::
code::
// plot x.squared transfer function with x between -1 and 1.
// here the x-axis shows n, the number of points 
{ |x| x.squared }.plotGraph(n: 200, from: -1, to: 1);

// as plotGraph returns a Plotter, you can apply a domain spec to show x value on the x-axis
{ |x| x.squared }.plotGraph(n: 200, from: -1, to: 1).domainSpecs_([-1, 1, \lin].asSpec).refresh;
::

subsection::Function Composition

When unary, binary or n-ary operators are applied to an abstract function, it returns an object that represents
this operation, without evaluating the function: link::Classes/UnaryOpFunction::, link::Classes/BinaryOpFunction::, link::Classes/NAryOpFunction::.
Note that different subclasses like link::Classes/Pattern:: or link::Classes/UGen:: have their own composition scheme analogous to the one of AbstractFunction itself. For more about functions, see link::Classes/Function::.

code::
// compose a function that will return an array of random length
a = { |n| { 16.rand } ! n } <> { |x, y| rrand(4, 8) };
a.value;
// compose a function from a that selects only odd values
b = { |x| x.select(_.odd) } <> a;
b.value;

// operator composition
// compose a function that multiplies a random integer by 2
{ rrand(1, 5) } * 2
::

note::
The comparison operators code::<::, code::<=::, code::>:: and code::>=:: automatically perform function composition, as does code::*:: in the example above.

Equality comparisons have two possible meanings: to compare the objects as they exist right now, or a composite operator that will evaluate the operands in the future and check the equality of those results. Both are needed at different times, and are supported by different operators: code::==:: for an immediate equality check (which always returns a Boolean result), or code::|==|:: for a "lazy" equality operator to be performed later.
::

code::
f = { 2.rand };  // a function

// eager (immediate) equality
// false: the function as itself is not the same as '1'
g = (f == 1);

g.value;  // still false

// lazy equality
g = (f |==| 1);  // a BinaryOpFunction

g.value;  // true or false, depending on f's result
::

examples::

code::
// examples

a = { 1.0.rand } + 8;
a.value;


y = { 8 } + { 1.0.rand };
y.value;
::

code::
// arguments are passed into both functions

y = { |x=0| x } + { 1.0.rand };
y.value(10);


y = { |x=0| x * 3 } + { |x=0| x + 1.0.rand };
y.value(10);

y.postcs;

y = { |x=0| x * 3 } + { |x=0| x + 1.0.rand } * { |x=0| [50, 100].choose + x } + 1.0;
y.value(10);
::

code::
// environments can be used as a lookup with valueEnvir:

(
Environment.use {
	~y = 10;
	~x = 2;
	~z = { |x=8| x } + { |y=0| y + 1.0.rand };
	~z.valueEnvir;
}
)
::

code::
// n-ary operators:

a = blend({ 3.0.rand }, { 1000.rand }, { |frac| frac });
a.value(0.5);

a.value((0, 0.06..1)); // creates a range of values..
::


CLASS:: AbstractGridLines
summary:: Calculates the numerical values suitable for grid lines to be used for plotting or other UI elements.
categories:: GUI>Accessories
related:: Classes/GridLines, Classes/LinearGridLines, Classes/ExponentialGridLines, Classes/DrawGrid, Classes/ControlSpec, Classes/Plotter, Reference/plot

DESCRIPTION::
code::AbstractGridLines:: and its subclasses are strategy objects that find suitable intervals for plotting grid lines and labels. The data range and warping behavior (e.g. linear or exponential) are derived from the corresponding link::Classes/ControlSpec::. The instance methods of code::AbstractGridLines:: are used by link::Classes/DrawGrid:: (which is in turn used by link::Classes/Plotter::) for getting logically spaced intervals that span the data for drawing grid lines on a plot.

code::AbstractGridLines:: shouldn't be instantiated directly. Instead, the link::Classes/GridLines:: factory class or the link::Classes/ControlSpec#-grid:: method should be used to return the appropriate code::AbstractGridLines:: subclass for the given spec.

code::
\freq.asSpec.grid
::

Subclasses of code::AbstractGridLines:: correspond to the range and warp behavior of their assigned code::ControlSpec::. For example, code::LinearGridLines:: and code::ExponentialGridLines:: represent data on a linear and exponential scale, respectively.
code::
(
// LinearGridLines
var linGrid = ControlSpec(0, 100, \lin, units: "Time").grid;
// ExponentialGridLines
var expGrid = \freq.asSpec.grid;

DrawGrid.test(linGrid, expGrid);
)
::
This default implementation does not know anything about the data is displaying:
code::
DrawGrid.test(nil, \midinote.asSpec.grid);
::
A theoretical code::MidinoteGridLines:: could be written that labels these correctly, shows octaves and individual notes depending on the current zoom. Or a teletype::DegreeGridLines:: could draw pitch degree grid lines behind a frequency plot.

Note that the code::AbstractGridLines:: does not know which axis it is to be used on and could also be used in polar plots or in 3D rendering.

CLASSMETHODS::

METHOD:: new

argument:: spec
A link::Classes/ControlSpec:: that defines the numerical range, warp, and step.

returns:: An instance of this class.

note:: code::AbstractGridLines:: shouldn't be instantiated directly. Instead, the link::Classes/GridLines:: factory class or the link::Classes/ControlSpec#-grid:: method should be used to return the appropriate code::AbstractGridLines:: subclass.
::

INSTANCEMETHODS::

METHOD:: spec
Get/set the code::ControlSpec:: that defines the numerical range, warp, and step.

returns:: A link::Classes/ControlSpec::.

METHOD:: asGrid
Return this object.

discussion::
code::nil.asGrid:: returns a code::BlankGridLines:: (a subclass of code::AbstractGridLines::) which produces no drawn lines. So if code::nil:: is passed to the strong::grid:: argument of code::DrawGrid::, no lines are drawn on the corresponding axis.


METHOD:: niceNum
Rounds a value to a logical "nice number" that is within the same order of magnitude. See the discussion below for details.

argument:: val
The value you'd like to make nicer.

argument:: round
A boolean. Roughly speaking, rounding will allow the returned number to be above or below the input strong::val:: (similar to a code::round:: operation), while when code::false:: the returned number will tend to be higher than strong::val:: (similar to code::ceil::).

returns:: The nice number.

discussion::
This method is used to support internal calculations for determining grid line values, though it may be useful for other applications.

Observe the rounding behavior:
code::
(
var g = GridLines([0, 10000].asSpec);
"in val / rounded / not rounded".postln;
10.collect{ 10000.rand }.sort.do({ |x|
    postf("% / % / %\n", x, g.niceNum(x, true), g.niceNum(x, false))
})
)
::
The implementation is based on: link::https://www.sciencedirect.com/book/9780080507538/graphics-gems##A. S. Glassner, Ed., Graphics Gems. San Diego: Morgan Kaufmann, 1990::.


METHOD:: looseRange
Returns the logical minimum and maximum that will contain the strong::min:: and strong::max::, determed internally using link::#-niceNum::.

argument:: min
Minimum value to include in the returned range.

argument:: max
Maximum value to include in the returned range.

argument:: ntick
The number of lines ("ticks") you would like within the range of code::[min, max]::, default: code::5::.

returns:: An link::Classes/Array:: with the lower and upper bounds of the range containing your strong::min:: and strong::max::, i.e. code::[rangeMin, rangeMax]::.


METHOD:: getParams

Specifically for use by link::Classes/DrawGrid::.
This returns a link::Classes/Dictionary:: with keys: code::'lines'::, an array of values where lines should be drawn, and code::'labels'::, an array of 2-element arrays code::[value, "formatted label"]:: for each line.

Note that the highest and lowest values returned don't necessarily contain your strong::valueMin:: and strong::valueMax::, but rather represent the values where grid lines will be drawn by code::DrawGrid:: (endcap lines are subsequently drawn at the data/grid bounds).

argument:: valueMin
Minimum value of the data to be plotted. The lowest grid line value returned may be higher than this value.

argument:: valueMax
Maximum value of the data to be plotted. The highest grid line value returned may be lower than this value.

argument:: pixelMin
Lower bound of the grid's range, in pixels. Used to calculate the size of the available grid space when determining grid values based on strong::tickSpacing:: (if strong::numTicks:: is code::nil::).

argument:: pixelMax
Upper bound of the grid's range, in pixels. Used to calculate the size of the available grid space when determining grid values based on strong::tickSpacing:: (if strong::numTicks:: is code::nil::).

argument:: numTicks
Explicit number of ticks you would like to see on the graph (though the result is approximate). Set to code::nil:: if you'd like the number of ticks to be found automatically, based on strong::pixelMin::, strong::pixelMax::, and strong::tickSpacing::.

argument:: tickSpacing
Minimum distance between ticks (in pixels). This value is only used when strong::numTicks:: is code::nil::.

returns:: A link::Classes/Dictionary::.


METHOD:: formatLabel
Format a numerical value for display as text, rounded to a desired precision.

argument:: val
The value to round and convert to a text label.

argument:: numDecimalPlaces
Number of decimal places to represent in the returned code::String::.

returns:: A link::Classes/String::.


private:: prCheckWarp, ideals


class:: AbstractIn
summary:: Abstract class for in ugens
categories:: UGens>InOut



CLASS:: AbstractMessageMatcher
summary:: Matches incoming messages to Functions
categories:: External Control>Abstract Classes
related:: Classes/AbstractResponderFunc, Classes/AbstractWrappingDispatcher

DESCRIPTION::
Instances of subclasses of AbstractMessageMatcher are used by subclasses of link::Classes/AbstractWrappingDispatcher:: to match multiple parameters of incoming messages (i.e. OSC or MIDI) to instances of subclasses of link::Classes/AbstractResponderFunc::. This class and its subclasses are private and generally users should not need to address them directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: func
Get or set this object's response link::Classes/Function::.

returns:: A link::Classes/Function:: or similar object.

METHOD:: value
Evaluate an incoming message to see if it matches. Subclasses should override this message to take appropriate arguments. If a match is found, this method should call value on this object's func, passing the message as appropriate arguments.

METHOD:: valueArray
As link::#-value:: above, but with the arguments passed as a single link::Classes/Array::. This method is needed so that subclasses can work in FunctionLists.

argument:: args
An link::Classes/Array:: containing the message and appropriate arguments.


class:: AbstractOut
summary:: Abstract class for out ugens
categories:: UGens>InOut

classmethods::
private:: categories

instancemethods::
method:: numOutputs
returns::
number of output buses (default: 0, overridden in subclasses)



CLASS:: AbstractResponderFunc
summary:: Abstract superclass of responder func objects
categories:: External Control>Abstract Classes
related:: Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractDispatcher

DESCRIPTION::
AbstractResponderFunc is the abstract superclass of responder funcs, which are classes which register one or more functions to respond to a particular type of input. It provides some common functionality such as introspection. Its two main subclasses are link::Classes/OSCFunc::, and link::Classes/MIDIFunc::. By default responder funcs do not persist beyond Cmd-. (see link::#-permanent:: below).

Instances will register with a dispatcher (an instance of a subclass of link::Classes/AbstractDispatcher::), which will actually dispatch incoming messages to an instance's Function(s).


CLASSMETHODS::

private:: initClass

METHOD:: allFuncProxies
Get all current instances of this classes concrete subclasses, sorted by type.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: allEnabled
As allFuncProxies above, but only return those instances currently listening for input.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: allDisabled
As allFuncProxies above, but only return those instances currently not listening for input.

returns:: An link::Classes/IdentityDictionary::.


INSTANCEMETHODS::
private:: cmdPeriod, prFunc

METHOD:: func
Get or set this objects response function.

returns:: The getter returns a link::Classes/Function:: or similar object.

METHOD:: srcID
Get this object's source.

returns:: The return type will depend on subclass. For link::Classes/OSCFunc:: this will be a link::Classes/NetAddr::, for link::Classes/MIDIFunc:: a UID. This can be nil, which indicates that the object will respond to any source.

METHOD:: enabled
Check if this object is currently responding to incoming messages.

returns:: A link::Classes/Boolean::.

METHOD:: dispatcher
et this object's dispatcher. This is the object which matches incoming messages with responder funcs. Instances can use custom dispatchers to support arbitrary matching schemes.

returns:: An instance of an appropriate subclass of link::Classes/AbstractDispatcher::. (The return type will depend on subclass.)

METHOD:: permanent
Get or set whether this responder func is persists when the user executes Cmd-. If false this will be disabled and removed from the global lists. The default is false.

argument:: bool
A link::Classes/Boolean:: indicating if this object is permanent.

returns:: The getter returns a link::Classes/Boolean::.

METHOD:: enable
Enable this object to receive incoming messages. This is done automatically at creation time.

METHOD:: disable
Stop this object from receiving incoming messages.

METHOD:: add
Add a new function to the list of functions which will be executed when this object receives an incoming message.

argument:: newFunc
A link::Classes/Function:: or similar object to be added.

METHOD:: remove
Remove a function from the list of functions which will be executed when this object receives an incoming message.

argument:: removeFunc
The link::Classes/Function:: to be removed.

METHOD:: gui
Open a subclass specific GUI. (Not yet implemented)

returns:: The GUI object.

METHOD:: oneShot
Indicate that this object should execute only once and then free itself.

METHOD:: fix
A synonym for link::#-permanent::

METHOD:: free
Disable this object and remove it from the global lists. This should be done when you are finished using this object.

METHOD:: clear
Remove all active functions from this object's function list.


EXAMPLES::

See link::Classes/OSCFunc:: and link::Classes/MIDIFunc::.


class:: AbstractServerAction
summary:: register actions to be taken for a server
related:: Classes/Server, Classes/ServerBoot, Classes/ServerTree, Classes/ServerQuit
categories:: Control

description::

This is an strong::abstract superclass:: for singletons like link::Classes/ServerQuit::, which provides a place for registering functions and objects for events that should happen when something happens in the server.
No direct call to AbstractServerAction is required.

note:: not fully working on Linux and windows.
Setting the computer to sleep on these systems causes the actions to be called.
As to date in Linux, JACK does not survive a sleep, it nevertheless behaves correctly for the time being.
::

ClassMethods::

method::functionSelector
Subclasses return specific function selectors for objects that implement this as interface.
Selectors are:
list::
## doOnServerBoot - link::Classes/ServerBoot::
## doOnServerQuit - link::Classes/ServerQuit::
## doOnServerTree - link::Classes/ServerTree::
::

not for registry with a server, but analogous are:
list::
## doOnCmdPeriod - link::Classes/CmdPeriod::
## doOnStartUp - link::Classes/StartUp::
## doOnShutDown - link::Classes/ShutDown::
::

method::add
Add an action or object for registry.

argument::object
Can either be a link::Classes/Function:: to be evaluated (as first arg the server is passed in), or an link::Classes/Object:: that implements the message returned by link::#-functionSelector::. strong::One object is only registered once::, so that multiple additions don't cause multiple calls.

argument::server
Server for which to register. If the symbol strong::\default:: is passed in, the action is called for the current default server. If the symbol strong::\all:: is passed in, the action is called for all current servers. If server is nil, it is added to \all.

method::remove
Remove an item or object from registry. If server is nil, remove from strong::all:: key.

method::removeServer
Remove all items that are registered for a given server.

Examples::

code::
// ServerBoot
s.boot;
f = { |server| "------------The server '%' has booted.------------\n".postf(server) };
ServerBoot.add(f, \default);
s.quit; // quit the server and observe the post
s.boot;
ServerBoot.remove(f, \default); // remove it again
s.quit;
s.boot;// no post.
ServerBoot.add(f, Server.internal);
Server.internal.quit;
Server.internal.boot;
ServerBoot.removeAll; // clear all
::

code::
// ServerQuit
s.boot;
f = { |server| "------------The server '%' has quit.------------\n".postf(server) };
ServerQuit.add(f, \default);
s.quit; // quit the server and observe the post
s.boot;
ServerQuit.remove(f, \default); // remove it again
s.quit; // no post.
ServerQuit.add(f, Server.internal);
Server.internal.boot;
Server.internal.quit;
ServerQuit.removeAll; // clear all
::

code::
// ServerTree
s.quit;
f = { |server| "-------The server '%' has initialised tree.-------\n".postf(server) };
g = { |server| 10.do { Group(server).postln } };
ServerBoot.add(f, \default);
ServerTree.add(g, \default);
s.boot; // boot and see how the actions are evaluated in order
// "cmd-period" (or equivalent) resends the groups.

ServerBoot.removeAll; // clear all
ServerTree.removeAll; // clear all
::


class:: AbstractSystemAction
summary:: register actions to be taken for system events
related:: Classes/CmdPeriod, Classes/StartUp, Classes/ShutDown, Classes/ServerBoot, Classes/ServerTree, Classes/ServerQuit
categories:: Control


ClassMethods::

method::removeAll
Remove all items from registry.


CLASS:: AbstractWrappingDispatcher
summary:: A dispatcher which wraps functions to support multiple paramter matching
categories:: External Control>Abstract Classes
related:: Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessageDispatcher, Classes/OSCMessagePatternDispatcher, Classes/MIDIMessageDispatcher, Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractResponderFunc

DESCRIPTION::
AbstractWrappingDispatcher extends AbstractDispatcher to provide the facility to wrap response functions in specialised objects (instances of subclasses of link::Classes/AbstractMessageMatcher:: to efficiently support matching of multiple parameters. Its subclasses link::Classes/OSCMessageDispatcher:: and link::Classes/MIDIMessageDispatcher:: match using a flat dictionary lookup of the 'most significant' parameter, and only attempt to match other parameters if an initial match is found. This approach is faster than others (such as multi-level dictionaries) for most configurations.


CLASSMETHODS::


INSTANCEMETHODS::
private:: init

METHOD:: wrappedFuncs
Get a dictionary of all currently wrapped functions, stored using their owning responder funcs as keys.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: add
Add a responder func to this dispatcher. Subclasses should extend this to do any necessary bookkeeping. Generally this method should add this dispatcher as a dependant of the responder func, so that it can respond to any changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to add.

METHOD:: remove
Remove a responder func from this dispatcher.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to remove.

METHOD:: updateFuncForFuncProxy
This method is called within link::#-update:: to update any changes to one of this dispatcher's responder funcs' function(s). Users should not call this method directly, but subclasses may need to extend this method to do additional bookkeeping.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

METHOD:: wrapFunc
Subclasses should override this method to implement wrapping of functions by instances of appropriate subclasses of link::Classes/AbstractMessageMatcher::.

METHOD:: getKeysForFuncProxy
Subclasses should override this to return an Array containing all the keys at which the specified responder func's functions are stored in this dispatchers active dictionary.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

returns:: An link::Classes/Array::.

METHOD:: update
Subclasses of link::Classes/AbstractResponderFunc:: should call update on their dispatcher whenever their function (or something else significant) changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

argument:: what
A link::Classes/Symbol:: indicating what has changed. Currently the only thing supported is code::\function::.

METHOD:: free
This method removes this dispatcher from its responder func's dependants dictionaries, and deactivates it. Users should only call this method if you are finished with this dispatcher.




class:: AllpassC
summary:: Schroeder allpass delay line with cubic interpolation.
related:: Classes/AllpassL, Classes/AllpassN, Classes/BufAllpassC
categories::  UGens>Delays


Description::

A Schroeder allpass filter is given by the difference equations

code::
s(t) = x(t) + k * s(t - D)
y(t) = -k * s(t) + s(t - D)
::

where code::x(t):: is the input signal, code::y(t):: is the output signal,
code::D:: is the delay time, and code::k:: is the allpass coefficient.

In this UGen, code::k:: is computed as
code::k == 0.001 ** (delay / decay.abs) * decay.sign:: (0.001 is -60 dBFS).

See also
link::Classes/AllpassN::  which uses no interpolation, and
link::Classes/AllpassL::  which uses linear interpolation.
Cubic interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
The output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// Since the allpass delay has no audible effect as a resonator on
// steady-state sound ...

{ AllpassC.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)


// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassC.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

::


class:: AllpassL
summary:: Schroeder allpass delay line with linear interpolation.
related:: Classes/AllpassC, Classes/AllpassN, Classes/BufAllpassL
categories::  UGens>Delays


Description::

A Schroeder allpass filter is given by the difference equations

code::
s(t) = x(t) + k * s(t - D)
y(t) = -k * s(t) + s(t - D)
::

where code::x(t):: is the input signal, code::y(t):: is the output signal,
code::D:: is the delay time, and code::k:: is the allpass coefficient.

In this UGen, code::k:: is computed as
code::k == 0.001 ** (delay / decay.abs) * decay.sign:: (0.001 is -60 dBFS).

See also
link::Classes/AllpassN::  which uses no interpolation, and
link::Classes/AllpassC::  which uses cubic interpolation.
Cubic interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ AllpassL.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassL.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

::



class:: AllpassN
summary:: Schroeder allpass delay line with no interpolation.
related:: Classes/AllpassC, Classes/AllpassL, Classes/BufAllpassN
categories::  UGens>Delays


Description::

A Schroeder allpass filter is given by the difference equations

code::
s(t) = x(t) + k * s(t - D)
y(t) = -k * s(t) + s(t - D)
::

where code::x(t):: is the input signal, code::y(t):: is the output signal,
code::D:: is the delay time, and code::k:: is the allpass coefficient.

In this UGen, code::k:: is computed as
code::k == 0.001 ** (delay / decay.abs) * decay.sign:: (0.001 is -60 dBFS).

This UGen quantizes the delay time to the nearest sample period, and will
produce aliasing artifacts if the delay time is modulated. If these
are undesirable properties, the more CPU-expensive alternatives are
link::Classes/AllpassL:: which uses linear interpolation, and
link::Classes/AllpassC:: which uses cubic interpolation.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative, then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ AllpassN.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

::



class:: AmpComp
summary:: Basic psychoacoustic amplitude compensation.
related:: Classes/AmpCompA
categories::  UGens>Analysis>Amplitude


Description::

Implements the (optimized) formula:

code::
compensationFactor = (root / freq) ** exp
::


Higher frequencies are normally perceived as louder, which AmpComp
compensates.


classmethods::

method::ar, kr, ir

argument::freq

Input frequency value. For freq == root, the output is 1.0.


argument::root

Root freq relative to which the curve is calculated
(usually lowest freq).


argument::exp

Exponent: how steep the curve decreases for increasing freq.

discussion::
Note that for frequencies very much smaller than root the amplitudes can become very high.
In this case limit the freq with code::freq.max(minval)::, or use AmpCompA.

Examples::

code::
// compare a sine without compensation

{ SinOsc.ar(MouseX.kr(300, 15000, 1)) * 0.1 }.play;

// with one that uses amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.kr(freq, 300)
}.play;
)


// different sounds cause quite different loudness perception,
// and the desired musical behavior can vary, so the exponent can be tuned:
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	Pulse.ar(freq) * 0.1 * AmpComp.kr(freq, 300, 1.3)
}.play;
)

// the curves:

// exp = 0.3333
(200,210..10000).collect {|freq| (200/freq) ** 0.3333 }.plot;

// nearly linear for semitone steps:

(48..72).midicps.collect {|freq| (48.midicps/freq) ** 0.3333 }.plot;
{ AmpComp.ar(Line.ar(48, 72, 1).midicps, 48.midicps) }.plot(1.0);

// exp = 1.2
(200,210..10000).collect {|freq| (200/freq) ** 1.2 }.plot;
(48..72).midicps.collect {|freq| (200/freq) ** 1.2 }.plot;
{ AmpComp.ar(Line.ar(48, 72, 1).midicps, 48.midicps, 1.2) }.plot(1.0);


// amplitude compensation in frequency modulation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.ar(freq, 300)
}.play;
)

// without amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1
}.play;
)

// in granular synthesis:
(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp * AmpComp.ir(freq));
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction: Done.freeSelf)
		)
	}
).add;
)

// send grains
(
fork {
	loop {
		s.sendBundle(0.1, [\s_new, \pgrain, -1,1,1]);
		0.02.wait;
	};
}
)


// try different synth defs:


// without AmpComp:

(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp);
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction: Done.freeSelf)
		)
	}
).add;
)

// with AmpCompA
(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp * AmpCompA.ir(freq));
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction: Done.freeSelf)
		)
	}
).add;
)
::



class:: AmpCompA
summary:: Basic psychoacoustic amplitude compensation (ANSI A-weighting curve).
related:: Classes/AmpComp
categories::  UGens>Analysis>Amplitude


Description::

Higher frequencies are normally perceived as louder, which AmpCompA
compensates. Following the measurements by Fletcher and Munson, the
ANSI standard describes a function for loudness vs. frequency.

Note that this curve is only valid for standardized amplitude.
footnote:: Function freq → dB, derived from http://www.beis.de/Elektronik/AudioMeasure/WeightingFilters.html and modified to map freq → amp.
code::
(
var k =  3.5041384e16;
var c1 = 424.31867740601;
var c2 = 11589.093052022;
var c3 = 544440.67046057;
var c4 = 148698928.24309;
f = {|f|
var r = squared(f);
var m1 = pow(r,4);
var n1 = squared(c1 + r);
var n2 = c2 + r;
var n3 = c3 + r;
var n4 = squared(c4 + r);
var level = k * m1 / (n1 * n2 * n3 * n4);
sqrt(level)
};
)
::

::


For a simpler but more flexible curve, see  link::Classes/AmpComp::

classmethods::

method::ar, kr, ir

argument::freq
Input frequency value. For freq == root, the output is rootAmp.

argument::root
Root freq relative to which the curve is calculated (usually lowest freq).

argument::minAmp
Amplitude at the minimum point of the curve (around 2512 Hz).

argument::rootAmp
Amplitude at the root frequency.

discussion::
Apart from code::freq::, the values are not modulatable

Examples::

code::

// compare a sine without compensation

{ SinOsc.ar(MouseX.kr(300, 15000, 1)) * 0.1 }.play;

// with one that uses amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	SinOsc.ar(freq) * 0.3 * AmpCompA.kr(freq)
}.play;
)


// adjust the minimum and root amp
// (in this way one can flatten out the curve for higher amplitudes)

(
{
	var freq;
	freq = MouseX.kr(300, 18000, 1);
	Formant.ar(300, freq, 20, 0.1) * AmpCompA.kr(freq, 300, 0.6, 0.3)
}.play;
)

// the curve:

{ AmpCompA.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);

// freqs:

{ AmpCompA.ar(Line.ar(0, 20000, 1)) }.plot(1.0);

// compare with AmpComp (exponential decay)

{ AmpComp.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);

// freqs:

{ AmpComp.ar(Line.ar(40, 20000, 1), 40) }.plot(1.0);



// amplitude compensation in frequency modulation (using Fletscher-Munson curve)
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpCompA.ar(freq, 300)
}.play;
)

// amplitude compensation in frequency modulation (using AmpComp exponential decay)
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.ar(freq, 300)
}.play;
)


// without amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1
}.play;
)
::

class:: Amplitude
summary:: Amplitude follower
categories:: UGens>Analysis>Amplitude

description::
Tracks the peak amplitude of a signal.

classmethods::

method:: ar, kr

argument::in
Input signal

argument::attackTime
20dB convergence time for following attacks.

argument::releaseTime
20dB convergence time for following decays.

argument::mul

argument::add

examples::

code::
(
// use input amplitude to control SinOsc frequency
{
    SinOsc.ar(
            Amplitude.kr(
                        Blip.ar(3, 20) * LFNoise1.kr(0.1).range(0, 1),
                        MouseX.kr(0.001, 1, 1),
                        MouseY.kr(0.001, 1, 1),
                        1200,
                        400
            ),
            0, 0.3)
}.play;
)
::

code::
// use input amplitude to control Pulse amplitude - use headphones to prevent feedback.
{ Pulse.ar(90, 0.3, Amplitude.kr(SoundIn.ar(0))) }.play;
::

code::
(
// use input amplitude to control SinOsc frequency - use headphones to prevent feedback.
{
    SinOsc.ar(
            Amplitude.kr(
                        SoundIn.ar(0),
                        0.01,
                        0.01,
                        1200,
                        400
            ),
            0, 0.3)
}.play;
)
::


class:: AnalogIn
summary:: Read data from an analog input
related:: Classes/AnalogOut, Classes/DigitalIn, Classes/DigitalOut, Classes/DigitalIO
categories::  UGens>Bela


Description::

Read a DC-coupled analog input connected to a sensor (e.g.: a potentiometer or CV in).

note::
This UGen only works on Bela
::

classmethods::

method::ar

argument::analogPin

Analog pin number to read. Pin numbers begin at 0. This value can be modulated at audiorate.

argument::mul

argument::add

method::kr

argument::analogPin

Analog pin number to read. Pin numbers begin at 0.

argument::mul

argument::add

Examples::

code::
// modulate frequency of a sine oscillator

(
SynthDef("help-AnalogIn",{ arg out=0;
	Out.ar(out,
	  SinOsc.ar( AnalogIn.ar( 0 ).exprange( 200, 5000 ), 0, 0.1 )
	)
}).play;
)
::



class:: AnalogOut
summary:: Write data to an analog output
related:: Classes/AnalogIn, Classes/DigitalIn, Classes/DigitalOut, Classes/DigitalIO
categories::  UGens>Bela


Description::

Writes an output to a DC-coupled analog output (e.g.: CV out).

note::
This UGen only works on Bela
::

classmethods::

method::ar

argument::analogPin

Analog pin number to read. Pin numbers begin at 0. This value can be modulated at audiorate.

argument::output

Value to write out to the pin.

argument::mul

argument::add

method::kr

argument::analogPin

Analog pin number to read. Pin numbers begin at 0.

argument::output

Value to write out to the pin.

argument::mul

argument::add

Examples::

code::
// write a sine oscillator's output to a pin

(
SynthDef("help-AnalogOut",{ arg out=0;
    AnalogOut.ar( 0 , SinOsc.ar( 10 ) );
}).play;
)
::


CLASS::AppClock
categories::Scheduling>Clocks
summary::Clock running on main application thread
related::Classes/SystemClock, Classes/TempoClock

DESCRIPTION::
SystemClock is more accurate, but cannot call GUI primitives.

You will need to use the link::Classes/SystemClock:: to get accurate/musical scheduling.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

private::initClass, prSchedNotify

method::sched
The float you return specifies the delta to resched the function for. Returning nil will stop the task from being rescheduled.
code::
(
AppClock.sched(0.0,{ arg time;
	["AppClock has been playing for ",time].postln;
	rrand(0.1,0.9);
});
)
::
code::
(
t = Main.elapsedTime;
"It is now % seconds after the computer booted.".format(t).postln;
AppClock.sched(2.0, { "It is now % sec later".format(Main.elapsedTime - t).postln; nil })
)
::

method::schedAbs

Schedules a task to be performed at a particular time. Because code::AppClock:: is not intended to schedule with high precision, this time is approximate.

When the scheduling time is up, the task's code::awake:: method is called. If the method
returns a number, the task will be rescheduled for the time equal to the last scheduling
time plus the returned value.

See also: link::Classes/Clock#Scheduling::, link::Classes/Object#-awake::.

code::
(
t = Main.elapsedTime;
"It is now % seconds after the computer booted.".format(t).postln;
AppClock.schedAbs(t + 1.0, { "It is now % sec later".format(Main.elapsedTime - t).postln; nil })
)
::



method::clear
Clear the AppClock's scheduler to stop it.
code::
AppClock.clear;
::

method::play
The link::Classes/Routine:: (or link::Classes/Task::) yields a float value indicating the delta (secs) for the AppClock to wait until resuming the Routine.
code::
(
var w, r;
w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;
r = Routine({ arg appClockTime;
	["AppClock has been playing for secs:",appClockTime].postln;
	60.do({ arg i;
		0.05.yield;
		w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
		w.alpha = cos(i*0.1pi)*0.5+0.5;
	});
	1.yield;
	w.close;
});
AppClock.play(r);
)
::

method::tick
AppClock.tick is called periodically by the SuperCollider language interpreter. This updates the link::Classes/Scheduler:: and causes any scheduled tasks to be executed. You should never call this method yourself.


class:: ApplicationStart
summary:: register functions to be evaluated on Application start
related:: Classes/StartUp, Classes/ServerBoot
categories:: Control, Platform>macOS

description::

Available in macOS SuperCollider.app only.

ApplicationStart allows you to register functions or objects to perform an action only  on application start.
The functions will be evaluated last; After the library has been compiled, the startup file has run and StartUp actions have been evaluated.

See also link::Classes/StartUp:: for functions that are evaluated emphasis::every:: time the ClassLibrary is recompiled.

ClassMethods::

method::add
Registers an object or function. Objects will be receive a strong::doOnApplcationStart:: message on application start. Functions will be evaluated.

method::remove
Removes a function that was previously registered.

method::run
Evaluates the functions or objects in order.

Examples::

code::
SomeStartClass {
	*initClass {
		ApplicationStart.add {
			// something to do when the app has been launched...
		}
	}
}

// or...
SomeStartClass {
	*initClass {
		ApplicationStart.add(this);
	}
	*doOnApplicationStart { "something started".postln }
}
::


CLASS::Archive
summary::storing objects to file
categories:: Collections, Files
related::Classes/Library, Classes/Object, Classes/LibraryBase

DESCRIPTION::
Archives can write any object to disk and read from file again. Complex structures of objects can thus be restored. Writing an object to file as a strong::compile string:: is usually more readable, but does not account for the internal structure of the object.

There is only one global instance: Archive.global, which is initialized automatically.

CLASSMETHODS::

private::initClass

method::global
set or get the global archive instance

method::archiveDir
set or get the directory that the archive is written to.
Default: link::Classes/Platform::.userAppSupportDir.

method::write
write the global archive now. This is called automatically when SuperCollider quits.
The default filename is "/archive.sctxar"

method::read
read the global archive now. This is called automatically when SuperCollider recompiles or starts.
The default filename is "/archive.sctxar"

EXAMPLES::

code::
// make a storage place for various objects:
q = (); // Event

q[\a_long_array] = Array.rand(128, 0.0, 1.0);
q[\pi_squared] = pi * pi;
q[\favourite_sound] = { { SinOsc.ar([300, 330]).sum * LFPulse.kr(2 + [0, 0.01]) * 0.1 }.play };
q[\same_long_array] = q[\a_long_array]; // same objects may appear several times

Archive.global.put(\myData, q);


Archive.global.at(\myData).postcs;

// after a recompile:
s.boot;

q = Archive.global.at(\myData);
q.postcs;
q[\favourite_sound].value;
::


class:: Array
summary:: fixed size collection
related:: Reference/Literals, Classes/List
categories:: Collections>Ordered

description::
Arrays are ArrayedCollections whose slots may contain any object. Arrays have a fixed maximum size beyond which they cannot grow. For expandable arrays, use the link::Classes/List:: class.

strong::Literal Arrays:: can be created at compile time, and are very efficient. See link::Reference/Literals:: for information.

For handling strong::multidimensional arrays::, there are specific methods which are covered in the helpfile link::Guides/J-concepts-in-SC::.

note::
For Arrays, the code::add:: method may or may not return the same Array object. It will add the argument to the receiver if there is space, otherwise it returns a new Array object with the argument added. Thus the proper usage of code::add:: with an Array is to always assign the result as follows:
code::
    z = z.add(obj);
::
This allows an efficient use of resources, only growing the array when it needs to. The link::Classes/List:: class manages the Array internally, and in many cases is more suitable.
::

Elements can be put into an existing slot with code::a.put(2,obj):: and accessed with
code::a.at(2):: or code::a[2]::

See link::Classes/ArrayedCollection:: for the principal methods: at, put, clipAt, wrapAt, etc...


ClassMethods::

method::new
Create a new array with size 0 that can grow up to the fixed size.
argument::maxSize
The maximum size of the array.

method::newClear
Create a new array with all slots filled with nils.
argument::indexedSize
The size of the array.

method::with
Create a new Array whose slots are filled with the given arguments.
This is the same as the method in ArrayedCollection, but is reimplemented here to be more efficient.
code::
Array.with(7, 'eight',  9).postln;
::

copymethod:: Collection *fill

copymethod:: Collection *fill2D

copymethod:: Collection *fillND

copymethod:: Collection *newFrom

copymethod:: ArrayedCollection *geom

copymethod:: ArrayedCollection *series

copymethod:: ArrayedCollection *iota

copymethod:: SequenceableCollection *interpolation

copymethod:: SequenceableCollection *rand

copymethod:: SequenceableCollection *rand2

copymethod:: SequenceableCollection *linrand

copymethod:: SequenceableCollection *exprand

copymethod:: SequenceableCollection *fib





InstanceMethods::

copymethod:: ArrayedCollection -at

copymethod:: ArrayedCollection -put

copymethod:: ArrayedCollection -insert

copymethod:: ArrayedCollection -clipAt

copymethod:: ArrayedCollection -wrapAt

copymethod:: ArrayedCollection -foldAt

copymethod:: ArrayedCollection -clipPut

copymethod:: ArrayedCollection -wrapPut

copymethod:: ArrayedCollection -foldPut

copymethod:: ArrayedCollection -swap

copymethod:: ArrayedCollection -replace

copymethod:: ArrayedCollection -++

copymethod:: ArrayedCollection -add

copymethod:: ArrayedCollection -addAll

copymethod:: ArrayedCollection -addFirst

copymethod:: ArrayedCollection -removeAt

copymethod:: ArrayedCollection -collect

copymethod:: ArrayedCollection -do

copymethod:: ArrayedCollection -reverseDo

copymethod:: ArrayedCollection -deepCollect

copymethod:: ArrayedCollection -reshape

copymethod:: ArrayedCollection -windex

copymethod:: ArrayedCollection -size

copymethod:: ArrayedCollection -normalize

copymethod:: ArrayedCollection -normalizeSum

copymethod:: ArrayedCollection -plot

method::reverse
Returns a new Array whose elements are reversed. The receiver is unchanged.
code::
x = [1, 2, 3];
z = x.reverse;
x.postln;
z.postln;
::

method::scramble
Returns a new Array whose elements have been scrambled. The receiver is unchanged.
code::
[1, 2, 3, 4, 5, 6].scramble.postln;
::

method::mirror
Return a new Array which is the receiver made into a palindrome.
The receiver is unchanged.
code::
[1, 2, 3, 4].mirror.postln;
::

method::mirror1
Return a new Array which is the receiver made into a palindrome with the last element removed.
This is useful if the list will be repeated cyclically, the first element will not get played twice.
The receiver is unchanged.
If the receiver is a single-element array, a copy is returned.
code::
[1, 2, 3, 4].mirror1.postln;
::

method::mirror2
Return a new Array which is the receiver concatenated with a reversal of itself.
The center element is duplicated. The receiver is unchanged.
code::
[1, 2, 3, 4].mirror2.postln;
::

method::stutter
note::It is recommended to use code::dupEach:: instead. This method is retained for backwards compatibility.::
Return a new Array whose elements are repeated n times. The receiver is unchanged.
code::
[1, 2, 3].stutter(2).postln;
::
argument::n
Number of repeats.

method::dupEach
Return a new Array whose elements are repeated n times. The receiver is unchanged.
code::
[1, 2, 3].dupEach(2).postln;
::
argument::n
Number of repeats.

method::rotate
Return a new Array whose elements are in rotated order. The receiver is unchanged.
code::
[1, 2, 3, 4, 5].rotate(1).postln;
[1, 2, 3, 4, 5].rotate(-1).postln;
[1, 2, 3, 4, 5].rotate(3).postln;
::
argument::n
Number of elements to rotate. Negative n values rotate left, positive n values
rotate right.

method::pyramid
Return a new Array whose elements have been reordered via one of 10 "counting" algorithms.
Run the examples to see the algorithms.
code::
10.do({ arg i;
	[1, 2, 3, 4].pyramid(i + 1).postcs;
});
::
argument::patternType
Choose counting algorithm. The algorithms are numbered 1 through 10.

method::pyramidg
Like pyramid, but keep the resulting values grouped in subarrays.
code::
// compare:
[1, 2, 3, 4].pyramid(1).postln;
[1, 2, 3, 4].pyramidg(1).postln;
::

method::sputter
Return a new Array of length maxlen with the items partly repeated (random choice of given probability).
code::
// compare:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sputter(0.5, 16).postln;
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sputter(0.8, 8).postln;
::
argument::probability
Probability of repeat.
argument::maxlen
The length of the new Array.

method::lace
Returns a new Array whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size length. The receiver is unchanged.
code::
x = [ [1, 2, 3], 6, List["foo", 'bar']];
y = x.lace(12);
x.postln;
y.postln;
::

method::permute
Returns a new Array whose elements are the nthPermutation of the elements of the receiver. The receiver is unchanged.
code::
x = [ 1, 2, 3];
6.do({|i| x.permute(i).postln;});
::

method::allTuples
Returns a new Array whose elements contain all possible combinations of the receiver's subcollections.
code::
[[1, 2, 3, 4, 5], [10, 20, 30]].allTuples;
[[1, 2, 3, 4, 5], [10, 20, 30], [5, 6]].allTuples;
::

method::wrapExtend
Returns a new Array whose elements are repeated sequences of the receiver, up to size length. The receiver is unchanged.
code::
x = [ 1, 2, 3, "foo", 'bar' ];
y = x.wrapExtend(9);
x.postln;
y.postln;
::

method::foldExtend
Same as wrapExtend but the sequences fold back on the list elements.
code::
x = [ 1, 2, "foo"];
y = x.foldExtend(9);
x.postln;
y.postln;
::

method::clipExtend
Same as wrapExtend but the sequences "clip" (return their last element) rather than wrapping.
code::
x = [ 1, 2, "foo"];
y = x.clipExtend(9);
x.postln;
y.postln;
::

method::slide
Return a new Array whose elements are repeated subsequences from the receiver.
Easier to demonstrate than explain.
code::
[1, 2, 3, 4, 5, 6].slide(3, 1).postcs;
[1, 2, 3, 4, 5, 6].slide(3, 2).postcs;
[1, 2, 3, 4, 5, 6].slide(4, 1).postcs;
::

method::shift
Shift the values of the array n steps to the right (n positive) or to the left(n negative),
dropping the excess and filling empty space with zero.
code::
[1, 2, 3, 4, 5, 6].shift(3).postln;
[1, 2, 3, 4, 5, 6].shift(-3).postln;
::

method::containsSeqColl
Returns true if the receiver Array contains any instance of SequenceableCollection
code::
[1, 2, 3, 4].containsSeqColl.postln
[1, 2, [3], 4].containsSeqColl.postln
::

method::powerset
Returns all possible combinations of the array's elements.
code::
[1, 2, 3].powerset.postln
[1, 2, 3].powerset.sort({ |a, b| a.size > b.size }); // sort by size, big first
[1, 2, 3].powerset.sort({ |a, b| a.size > b.size }).reverse; // by size, small first
::
powerset is also supported in Collection:
code::
Set[1, 2, 3].powerset;
List[1, 2, 3].powerset
(a: 1, b: 2, c: 3).powerset;
::

method::envirPairs
Given an array of symbols, this returns an array of pairs of (symbol, value) from the current environment.
This can then be used as arguments for a Synth, or in an OSC message.
code::
e = (freq: 340, amp: 0.001, strangeness: 0.85);
e.use {
	[\amp, \taste, \strangeness].envirPairs;
}
::

method::flop
Invert rows and columns in a two dimensional Array (turn inside out).
See also: Function, SequenceableCollection.
code::
[[1, 2, 3], [4, 5, 6]].flop;
[[1, 2, 3], [4, 5, 6], [7, 8]].flop; // shorter array wraps
[].flop; // result is always 2-d.
::

method::multiChannelExpand
Used by UGens to perform multi channel expansion. Same as flop.

method::source
Some UGens return Arrays of OutputProxy when instantiated. This method allows you to
get at the source UGen.
code::
z = Pan2.ar;
z.postln;
z.source.postln;
::

method::fork
Used within Routines and assumes an array of functions, from which subroutines are created. The subroutines are played while the outer Routine carries on. The join parameter expresses after how many subroutines complete the outer Routine is allowed to go on. By default this happens after all subroutines have completed.
code::
// an array of routine functions:
(
a = [
	{ 1.wait; \done_one.postln },
	{ 0.5.wait; \done_two.postln },
	{ 0.2.wait; \done_three.postln }
];
)
// join after 0
(
Routine {
	"join = 0.".postcln;
	a.fork(0); \doneAll.postln;
}.play;
)
// join after 1
(
Routine {
	"join = 1.".postcln;
	a.fork(1); \doneAll.postln;
}.play;
)
// join after all
(
Routine {
	"join = a.size (default).".postcln;
	a.fork; \doneAll.postln;
}.play;
)
::

method::poll
apply an array of Poll units to an array of UGens (see those helpfiles for more details).
code::
(
x = {
	SinOsc.ar([0.1, 0.2], 0).poll * 0.1
}.play;
)
x.trace; // By tracing the Synth you can see the two Poll units we created
x.free
::

method::dpoll
apply an array of Dpoll units to an array of UGens (see those helpfiles for more details).

method::atIdentityHash
This method is used by IdentitySet to search for a key among its members.

method::atIdentityHashInPairs
This method is used by IdentityDictionary to search for a key among its members.

method::asString
Returns a string representing the Array. May not be compilable due to elision (...) of excessive arguments.

method::asCompileString
Returns a string that will compile to return an Array equal to the receiver.

method::isValidUGenInput
Returns true. Arrays are valid UGen inputs.

method::asRawOSC
Returns the OSC message as an Int8Array. Receiver must be a bundle.
code::
[0.1, [\s_new, \default, -1, 1, 1, \freq, 1961]].asRawOSC;
::

subsection:: Bela

method:: belaScope
Send this Array's content to Bela's Oscilloscope (see link::Classes/BelaScope:: for required setup)
argument:: scopeChannel
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument:: server
The server on which BelaScope is running. If not specified, it looks for the first server for which BelaScope was already initialized. If none is found, it attempts to initialize a link::Classes/BelaScope:: instance on link::Classes/Server#*default::.
returns:: This Array.


CLASS::Array2D
summary::two-dimensional array
related::Classes/Array
categories::Collections>Ordered

DESCRIPTION::
Represents a two-dimensional array of data. The number of rows and columns is fixed.

note:: It is possible to implement a similar behaviour using an "array-of-arrays" - see the examples towards the bottom of this page for comparison.::

CLASSMETHODS::

method::new
Create an array of the specified size.
code::
a = Array2D.new(3,4);
a[2,2] = 1;
a.postln
::

method::fromArray
Build an Array2D from the supplied array.
code::
a = Array2D.fromArray(3,4, [9,8,7,6,5,4,3,2,1,2,3,4]);
a[2,2] = 1;
a.postln
::

INSTANCEMETHODS::

private::printOn, storeOn

method::at
Get a value from the array.
code::
a.at(2,3);
a[2,3];
::

method::put
Put a value into the array.
code::
a.put(2,3, 72);
a[2,3] = 72;
::

method::colsDo
Iterate over the columns. Each column will be passed to strong::func:: in turn.
code::
a.colsDo(_.postln);
::

method::rowsDo
Iterate over the rows. Each row will be passed to strong::func:: in turn.
code::
a.rowsDo(_.postln);
::

method::colAt
Retrieve a single column.
code::
a.colAt(2);
::

method::rowAt
Retrieve a single row.
code::
a.rowAt(2);
::

method::asArray
Return a flat array containing the elements.
code::
a.postln;
a.asArray.postln;
::
returns:: link::Classes/Array::

EXAMPLES::

code::
// "a" is an array-of-arrays
a = { { 100.0.rand }.dup(100) }.dup(100);
// "b" is an equivalent Array2D, made using the "fromArray" class method
b = Array2D.fromArray(100,100, a.flat);

// Accessing
a[15][22]
b[15, 22]

// Speed comparison 1: random access
bench { 100.do(a[100.rand][100.rand]) }
bench { 100.do(b[100.rand, 100.rand]) }

// Speed comparison 2: iteration
bench { 100.do(a.do { |row| row.do { |item| item * 2 } }) }
bench { 100.do(b.do { |item| item * 2 }) }
::


CLASS::ArrayedCollection
categories::Collections>Ordered
summary:: Abstract superclass of Collections of fixed maximum size

DESCRIPTION::
ArrayedCollection is an abstract class, a subclass of SequenceableCollections whose elements are held in a vector of slots. Instances of ArrayedCollection have a fixed maximum size beyond which they may not grow.

Its principal subclasses are link::Classes/Array:: (for holding objects), and link::Classes/RawArray::, from which link::Classes/Int8Array::, link::Classes/FloatArray::, link::Classes/Signal:: etc. inherit.

CLASSMETHODS::

method::newClear
Creates a new instance with strong::indexedSize:: indexable slots. The slots are filled with link::Classes/Nil::, zero or something else appropriate to the type of indexable slots in the object.
code::
Array.newClear(4).postln;
::

method::with
Create a new ArrayedCollection whose slots are filled with the given arguments.
code::
Array.with(7, 'eight',  9).postln;
::

method::series
Fill an ArrayedCollection with an arithmetic series.
code::
Array.series(5, 10, 2).postln;
::

method::geom
Fill an ArrayedCollection with a geometric series.
code::
Array.geom(5, 1, 3).postln;
::

method::iota
Fills an ArrayedCollection with a counter. See link::Guides/J-concepts-in-SC:: for more examples.
code::
Array.iota(2, 3);
Array.iota(2, 3, 4);
::


INSTANCEMETHODS::

method::size
Return the number of elements the ArrayedCollection.

method::maxSize
Return the maximum number of elements the ArrayedCollection can hold. For example, link::Classes/Array::s may initialise themselves with a larger capacity than the number of elements added.
code::
[4, 5, 6].maxSize; // gosh
::

method::at
Return the item at strong::index::.

The index can also be an Array of indices to extract specified elements. Example:
code::
x = [10,20,30];
y = [0,0,2,2,1];
x[y]; // returns [ 10, 10, 30, 30, 20 ]
::

method::clipAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be clipped to the last index.
code::
y = [ 1, 2, 3 ];
y.clipAt(13).postln;
::

method::wrapAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be wrapped around to 0.
code::
y = [ 1, 2, 3 ];
y.wrapAt(3).postln; // this returns the value at index 0
y.wrapAt(4).postln; // this returns the value at index 1
y.wrapAt([-2, 1])   // index can also be a collection or negative numbers
::

method::foldAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be folded back.
code::
y = [ 1, 2, 3 ];
y.foldAt(3).postln; // this returns the value at index 1
y.foldAt(4).postln; // this returns the value at index 0
y.foldAt(5).postln; // this returns the value at index 1
::

method::plot
Plot values in a GUI window.  See link::Reference/plot:: for more details. When the receiver contains code::nil:: items, the plot fails with an error.

method::swap
Swap the values at indices i and j.
code::
[ 1, 2, 3 ].swap(0, 2).postln;
::

method::put
Put strong::item:: at strong::index::, replacing what is there.

method::clipPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be clipped to the last index.

method::wrapPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be wrapped around to 0.

method::foldPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be folded back.

method::putEach
Put the strong::values:: in the corresponding indices given by strong::keys::. If one of the two argument arrays is longer then it will wrap.
code::
y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
y.putEach([4, 7], [\smelly, \head]);
y.putEach([2, 3, 5, 6], \wotsits);
::

method::indexOf
Return the first index containing an item which matches strong::item::. Elements are checked for identity (not for equality).
code::
y = [ \the, \symbol, \collection, \contains, \my, \symbol ];
y.indexOf(\symbol);
::

method::includes
Return a boolean indicating whether the collection contains anything matching strong::item::. Elements are checked for identity (not for equality).
code::
y = [ \the, \symbol, \collection, \contains, \my, \symbol ];
y.includes(\symbol);
y.includes(\solipsism);
::

method::indexOfGreaterThan
Return the first index containing an item which is greater than strong::item::.
code::
y = [ 10, 5, 77, 55, 12, 123];
y.indexOfGreaterThan(70);
::

method::removeAt
Remove and return the element at strong::index::, shrinking the size of the ArrayedCollection.
code::
y = [ 1, 2, 3 ];
y.removeAt(1);
y.postln;
::

method::takeAt
Similar to link::#-removeAt::, but does not maintain the order of the items following the one that was removed. Instead, the last item is placed into the position of the removed item and the array's size decreases by one.
code::
y = [ 1, 2, 3, 4, 5 ];
y.takeAt(1);
y.postln;
::

method::takeThese
Removes all items in the receiver for which the strong::func:: answers true. The function is passed two arguments, the item and an integer index. Note that order is not preserved. See link::#-takeAt::.
code::
y = [ 1, 2, 3, 4 ];
y.takeThese({ arg item, index; item.odd; });	//remove odd items
y.postln;
::

method::add
Adds an item to an ArrayedCollection if there is space. This method may return a new ArrayedCollection. For this reason, you should always assign the result of add to a variable - never depend on code::add:: changing the receiver.
code::
(
// z and y are the same object
var y, z;
z = [1, 2, 3];
y = z.add(4);
z.postln;
y.postln;
)

(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.add(5);
z.postln;
y.postln;
)
::

method::addAll
Adds all the elements of aCollection to the contents of the receiver. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::addAll:: to a variable - never depend on add changing the receiver.
code::
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addAll([7, 8, 9]);
z.postln;
y.postln;
)
::

method::extend
Extends the object to match strong::size:: by adding a number of strong::item::s. If strong::size:: is less than receiver size then truncate. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::extend:: to a variable - never depend on add changing the receiver.
code::
(
var y, z;
z = [1, 2, 3, 4];
y = z.extend(10, 9);		//fill up with 9 until the size equals 10
z.postln;
y.postln;
)
::

method::fill
Inserts the item into the contents of the receiver. note::the difference between this and link::Classes/Collection#*fill#Collection's *fill::.::
code::
(
var z;
z = [1, 2, 3, 4];
z.fill(4).postln;
z.fill([1,2,3,4]).postln;
)
::

method::insert
Inserts the item into the contents of the receiver. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::insert:: to a variable - never depend on add changing the receiver.
code::
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.insert(1, 999);
z.postln;
y.postln;
)
::

method::move
Moves an item from one position to another.

code::
[10, 20, 1000, 40, 50].move(2, 0) // move 1000 to index 0
::

argument::fromIndex
The position in the array from which the element is removed.
argument::toIndex
The position in the array before which the element is inserted again.




method::addFirst
Inserts the item before the contents of the receiver, possibly returning a new collection.
code::
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addFirst(999);
z.postln;
y.postln;
)
::

method::pop
Remove and return the last element of the ArrayedCollection.
code::
(
var z;
z = [1, 2, 3, 4];
z.pop.postln;
z.postln;
)
::

method::grow
Increase the size of the ArrayedCollection by strong::sizeIncrease:: number of slots, possibly returning a new collection.

method::growClear
Increase the size of the ArrayedCollection by strong::sizeIncrease:: number of slots, returning a new collection with link::Classes/Nil::s in the added slots.
code::
// Compare:
[4,5,6].grow(5);
[4,5,6].growClear(5);
::

method::copyRange
Return a new ArrayedCollection which is a copy of the indexed slots of the receiver from strong::start:: to strong::end::. If strong::end:: < strong::start::, an empty ArrayedCollection is returned.
code::
(
var y, z;
z = [1, 2, 3, 4, 5];
y = z.copyRange(1,3);
z.postln;
y.postln;
)
::
warning:: code::x.copyRange(a, b):: is strong::not:: equivalent to code::x[a..b]::. The latter compiles to link::#-copySeries::, which has different behavior when strong::end:: < strong::start::. ::

method::copySeries
Return a new ArrayedCollection consisting of the values starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::. If strong::second:: is code::nil::, a step of 1 or -1 is used as appropriate.

code::x.copySeries(a, nil, c):: is equivalent to code::x[a..c]::, and code::x.copySeries(a, b, c):: is equivalent to code::x[a,b..c]::

code::
(
var y, z;
z = [1, 2, 3, 4, 5, 6];
y = z.copySeries(0, 2, 5);
y.postln;
)
::

note::If the intent is to copy emphasis::forward:: in an array, and you are calculating start and end indices such that code::end:: may be less than code::start::, it is not safe to use code::copySeries:: or the shortcut syntax code::x[a..b]:: because it will adapt to use a positive or negative step as needed. In this case, code::copyRange:: is recommended.

code::
a = Array.series(10, 0, 1);
a[2..0];  // [ 2, 1, 0 ]
a.copyRange(2, 0);  // [  ]
::
::

method::seriesFill
Fill the receiver with an arithmetic progression. The first element will be strong::start::, the second strong::start + step::, the third strong::start + step + step:: ...
code::
(
var y;
y = Array.newClear(15);
y.seriesFill(5, 3);
y.postln;
)
::

method::putSeries
Put strong::value:: at every index starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::x.putSeries(a, b, c, val):: can also be written as code::x[a, b..c] = val::
code::
(
var y, z;
z = [1, 2, 3, 4, 5, 6];
y = z.putSeries(0, 2, 5, "foo");
y.postln;
)
::

method::++
Concatenate the contents of the two collections into a new ArrayedCollection.
code::
(
var y, z;
z = [1, 2, 3, 4];
y = z ++ [7, 8, 9];
z.postln;
y.postln;
)
::

method::reverse
Return a new ArrayedCollection whose elements are reversed.
code::
(
var y, z;
z = [1, 2, 3, 4];
y = z.reverse;
z.postln;
y.postln;
)
::

method::do
Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
['a', 'b', 'c'].do({ arg item, i; [i, item].postln; });
::

method::reverseDo
Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
['a', 'b', 'c'].reverseDo({ arg item, i; [i, item].postln; });
::

method::collect
Answer a new collection which consists of the results of function evaluated for each item in the collection. The function is passed two arguments, the item and an integer index. See link::Classes/Collection:: helpfile for examples.

method::deepCollect
The same as link::#-collect::, but can look inside sub-arrays up to the specified strong::depth::.
code::
a = [99, [4,6,5], [[32]]];
a.deepCollect(1, {|item| item.isArray}).postln;
a.deepCollect(2, {|item| item.isArray}).postln;
a.deepCollect(3, {|item| item.isArray}).postln;
::

method::windex
Interprets the array as a list of probabilities which should sum to 1.0 and returns a random index value based on those probabilities.
code::
(
Array.fill(10, {
	[0.1, 0.6, 0.3].windex;
}).postln;
)
::

method::normalizeSum
Returns the Array resulting from :
code::
(this / this.sum)
::
so that the array will sum to 1.0.

This is useful for using with windex or wchoose.
code::
[1, 2, 3].normalizeSum.postln;
::

method::normalize
Returns a new Array with the receiver items normalized between strong::min:: and strong::max::.
code::
[1, 2, 3].normalize;			//default min=0, max= 1
[1, 2, 3].normalize(-20, 10);
::

method::perfectShuffle
Returns a copy of the receiver with its items split into two equal halves, then reconstructed by interleaving the two halves. note::use an even number of item pairs in order to not loose any items in the shuffle.::
code::
(
var y, z;
z = [ 1, 2, 3, 4, 5, 6 ];
y = z.perfectShuffle;
z.postln;
y.postln;
)
::

method::performInPlace
Performs a method in place, within a certain region [from..to], returning the same array.
code::
a = (0..10);
a.performInPlace(\normalizeSum, 3, 6);
::

method::rank
Rank is the number of dimensions in a multidimensional array.
code::
a = [4,7,6,8];
a.rank;
a = [[4,7],[6,8]];
a.rank;
::

method::shape
For a multidimensional array, returns the number of elements along each dimension.
code::
a = [4,7,6,8];
a.shape;
a = [[4,7],[6,8]];
a.shape;
::

method::reshape
For a multidimensional array, rearranges the data using the desired number of elements along each dimension. The data may be extended using wrapExtend if needed.
code::
a = [4,7,6,8];
a.reshape(2,2);
a.reshape(2,3);
::

method::find
Finds the starting index of a number of elements contained in the array. This method expects a collection as an argument. So for finding only one element, have a look at link::Classes/SequenceableCollection#-indexOfEqual::.
Elements are checked for equality (not for identity).
code::
a = (0..10);
a.find([4, 5, 6]);
::

method::replace
Return a new array in which a number of elements have been replaced by another. Elements are checked for equality (not for identity).
code::
a = (0..10) ++ (0..10);
a.replace([4, 5, 6], 100);
a.replace([4, 5, 6], [1734, 1985, 1860]);
::
this method is inherited by link::Classes/String:: :
code::
a = "hello world";
a.replace("world", "word");
::

method::asRandomTable
Return an integral table that can be used to generate random numbers with a specified distribution.
(see link::Guides/Randomness:: helpfile for a more detailed example)
code::
(
a = (0..100) ++ (100..50) / 100; // distribution
a = a.asRandomTable;
)
::

method::tableRand
Returns a new random number from a random table.
code::
(
a = (0..100) ++ (100..50) / 100; // distribution
a = a.asRandomTable;
20.do { a.tableRand.postln };
)
::

method::msgSize
Return the size of an osc message in bytes
code::
a = ["/s_new", "default", -1, "freq", 440];
a.msgSize;
::

method::bundleSize
Return the size of an osc bundle in bytes
code::
a = [["/s_new", "default", -1, "freq", 440], ["/s_new", "default", -1, "freq", 220]];
a.bundleSize;
::

method::asciiPlot
For an ArrayedCollection containing numbers (e.g. audio data) this renders a plot in the post window using asterisks and spaces (works best if you use a monospace font in your post window).
code::
a = (0, pi/10 .. 5pi).collect{|val| val.sin};
a.asciiPlot;
::


CLASS::Association
summary::relate two objects
categories::Collections

DESCRIPTION::
Associates a key with a value.
Associations can be created via the -> operator which is defined in class link::Classes/Object::.

Associations are used internally in link::Classes/Dictionary::.

CLASSMETHODS::

method::new
Create an Association between two objects.
code::
(
x = 'name' -> 100;
x.postln;
)
::
argument::key
any object
argument::value
any object

INSTANCEMETHODS::

subsection::Accessing

method::key
the key object.

method::value
the value object.

subsection::Testing

method::==
Compare the keys of two Associations.

method::<
Compare the keys of two Associations.

method::hash
Compute the hash value of the Association.

subsection::Writing to streams

method::printOn
Write a string representation to the stream.

method::storeOn
Write a compilable string representation to the stream.

EXAMPLES::

code::
// associations can be a good way to store named data in order:
(
a = [\x -> 700, \y -> 200, \z -> 900];

fork {
	a.do { |assoc|
		assoc.key.postln;
		assoc.value.postln;
		(freq: assoc.value).play;
		2.wait;
	}
};
)
::


class:: AudioIn
summary:: Read audio input.
related:: Classes/In, Classes/SoundIn
categories::  UGens>InOut


Description::

Reads audio from the sound input hardware.

note::
This is provided for backwards compatibility with SC2 code. For normal use link::Classes/SoundIn::, which has bus numbers beginning at 0, as AudioIn may be deprecated and removed at some point in the future.
::

classmethods::

method::ar

argument::channel

Input channel number to read. Channel numbers begin at 1.

argument::mul

argument::add

Examples::
Patching input to output
code::
// patching input to output

// beware of the feedback

(
ServerOptions.inDevices.postln;	//  post available audio input devices
s.meter;	// display level meters for monitoring
SynthDef(\helpAudioIn, { |out|
	var input = AudioIn.ar(1); // first input
	// delay output to tame feedback in case of microphones are configured:
	Out.ar(out, CombN.ar(input * -25.dbamp, 0.5, 0.5, 0.001))
}).play
)
::



class:: BAllPass
summary:: All Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::
method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = { // thru
BAllPass.ar(
	SoundIn.ar([0, 1]),
	MouseX.kr(10, 18000, \exponential),
	0.8, // rq
	0.5); // mul
}.play)
z.release;

(
z = { // like a bandpass
	var sig;
	sig = SoundIn.ar([0,1]) * 0.5;
	BAllPass.ar(sig, MouseX.kr(10, 18000, \exponential), 0.8) + sig.neg
}.play)
z.release;
::


class:: BBandPass
summary:: Band Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: bw
the bandwidth in octaves between -3 dB frequencies.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = {
BBandPass.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;

(
z = {
BBandPass.ar(
	WhiteNoise.ar ! 2,
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;
::


class:: BBandStop
summary:: Band reject filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: bw
the bandwidth in octaves between -3 dB frequencies.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = {
BBandStop.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;

(
z = {
BBandStop.ar(
	WhiteNoise.ar ! 2,
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.1); // mul
}.play)
z.release;

(
z = { // drill...
BBandStop.ar(
	SinOsc.ar(1000) ! 2,
	MouseX.kr(800, 1200, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.1); // mul
}.play)
z.release;

(
z = { // nada
BBandStop.ar(
	SinOsc.ar(1000) ! 2,
	1000,
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;
::


class:: BEQSuite
summary:: Base class for B Equalization Suite
categories:: UGens>Filters>BEQSuite

description::

definitionList::
## link::Classes/BLowPass:: || 12dB/oct rolloff - 2nd order resonant Low Pass Filter
## link::Classes/BLowPass4:: || 24dB/oct rolloff - 4th order resonant Low Pass Filter (pseudo UGen)
## link::Classes/BHiPass:: || 12dB/oct rolloff - 2nd order resonant Hi Pass Filter
## link::Classes/BHiPass4:: || 24dB/oct rolloff - 4th order resonant Hi Pass Filter (pseudo UGen)
## link::Classes/BPeakEQ:: || Parametric Equalizer
## link::Classes/BLowShelf:: || Low resonant Shelf
## link::Classes/BHiShelf:: || High resonant Shelf
## link::Classes/BBandPass:: || Band Pass Filter
## link::Classes/BBandStop:: || Band Reject Filter
## link::Classes/BAllPass:: || All Pass Filter
::

The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

SC3 port and coding - blackrain 06.17.2005

SC3 plugin UGens - Joshua Parmenter 06.22.2005

Some ideas from emphasis::"Cookbook formulae for audio EQ biquad filter coefficients":: by Robert Bristow-Johnson.



class:: BHiPass
summary:: 12db/oct rolloff - 2nd order resonant  Hi Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q.  bandwidth / cutoffFreq.
argument:: mul
argument:: add

method:: sc
calculate filter coefficients.

examples::
code::
s.boot;
(
z = {
	BHiPass.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.0, 1.0, \linear), // rq
		0.5); // mul
}.play
)
z.release;
::


class:: BHiPass4
summary:: 24db/oct rolloff - 4th order resonant  Hi Pass Filter [1]
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

[1] this is a pseudo link::Classes/UGen::. BHiPass4 is built by cascading 2 link::Classes/SOS:: sections.

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q.  bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = {
	BHiPass4.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.1, 1.0, \linear), // rq
		0.5); // mul
}.play)
z.release;
::


class:: BHiShelf
summary:: Hi Shelf
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
center frequency.
argument:: rs
the reciprocal of S. Shell boost/cut slope. When S = 1, the shelf slope is as steep as it can be and remain monotonically increasing or decreasing gain with frequency. The shelf slope, in dB/octave, remains proportional to S for all other values for a fixed code::freq/SampleRate.ir:: and code::db::.
argument:: db
gain. boost/cut the center frequency in dBs.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = { // toy around with boost/cut
BHiShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(2200, 18000, \exponential),
	1.0, // rs
	MouseY.kr(18.0, -18.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy around with rs
BHiShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(2200, 18000, \exponential),
	MouseY.kr(0.1, 1.0, \linear), // rs
	6, // db
	0.5); // mul
}.play)
z.release;
::


class:: BLowPass
summary:: 12db/oct rolloff - 2nd order resonant Low Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

method:: sc
calculate filter coefficients.

examples::
code::
s.boot;
(
z = {
	BLowPass.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.0, 1.0, \linear), // rq
		0.5); // mul
}.play
)
z.release;
::


class:: BLowPass4
summary:: 24db/oct rolloff - 4th order resonant Low Pass Filter [1]
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

[1] this is a composite pseudo link::Classes/UGen::. BLowPass4 is built by cascading 2 link::Classes/SOS:: sections.

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = {
	BLowPass4.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.1, 1.0, \linear), // rq - compensate for 2 biquad sections.
		0.5); // mul
}.play)
z.release;
::


class:: BLowShelf
summary:: Low Shelf
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rs
the reciprocal of S. Shell boost/cut slope. When S = 1, the shelf slope is as steep as it can be and remain monotonically increasing or decreasing gain with frequency. The shelf slope, in dB/octave, remains proportional to S for all other values for a fixed code::freq/SampleRate.ir:: and code::db::.
argument:: db
gain. boost/cut the center frequency in dBs.
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = { // toy around with boost/cut
BLowShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(40, 6000, \exponential),
	1.0, // rs
	MouseY.kr(24.0, -24.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy around with rs
BLowShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 6000, \exponential),
	MouseY.kr(0.1, 1.0, \linear), // rs
	6,
	0.5); // mul
}.play)
z.release;
::


class:: BPF
summary:: 2nd order Butterworth bandpass filter.
related:: Classes/BRF, Classes/HPF, Classes/LPF
categories::  UGens>Filters>Linear


Description::

A second order band pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Centre frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::rq

The reciprocal of Q. Q is conventionally defined as freq / bandwidth, meaning rq = (bandwidth / freq).

argument::mul

argument::add

Examples::

code::
{ BPF.ar(Saw.ar(200,0.5), FSinOsc.kr(XLine.kr(0.7,300,20),0,3600,4000), 0.3) }.play;

{ BPF.ar(Saw.ar(200,0.5), MouseX.kr(100, 10000, 1), 0.3) }.play;

	// BPF on control signals:
(
{ 	var vib = BPF.kr(PinkNoise.kr, MouseX.kr(1, 100, 1), 0.3) * 10;
	SinOsc.ar(vib * 200 + 600) * 0.2 }.play;
)
::



class:: BPZ2
summary:: Two zero fixed midpass.
related:: Classes/BRZ2, Classes/HPZ2, Classes/LPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.5 * (in(i) - in(i - 2)).
::

This filter cuts out 0 Hz and the Nyquist frequency.


classmethods::

method::ar, kr

argument::in

The input signal.

Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ BPZ2.ar(WhiteNoise.ar(0.25)) }.play;
::



class:: BPeakEQ
summary:: Parametric equalizer
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: db
boost/cut the center frequency (in dBs).
argument:: mul
argument:: add

examples::
code::
s.boot;
(
z = { // toy with boost/cut
BPeakEQ.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	0.8, // rq
	MouseY.kr(12.0, -12.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy with rq
BPeakEQ.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(10, 0.4, \linear), // rq
	6, // boost/cut - +6dB
	0.5); // mul
}.play)
z.release;
::


class:: BRF
summary:: 2nd order Butterworth band reject filter.
related:: Classes/BPF, Classes/HPF, Classes/LPF
categories::  UGens>Filters>Linear


Description::

A second order band reject filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


Examples::

code::
{ BRF.ar(Saw.ar(200,0.1), FSinOsc.kr(XLine.kr(0.7,300,20),0,3800,4000), 0.3) }.play;

{ BRF.ar(Saw.ar(200,0.5), MouseX.kr(100, 10000, 1), 0.3) }.play;


	// BRF on control signals:
(
{ 	var vib = BRF.kr(SinOsc.kr([1, 3, 10], 0, [1, 0.5, 0.25]).sum, MouseX.kr(1, 10, 1), 0.3);
	SinOsc.ar(vib * 200 + 600) * 0.2 }.play;
)
::



class:: BRZ2
summary:: Two zero fixed midcut.
related:: Classes/BPZ2, Classes/HPZ2, Classes/LPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.5 * (in(i) + in(i - 2)).
::


This filter cuts out frequencies around ½ of the Nyquist frequency.


classmethods::

method::ar, kr

argument::in

The input signal.


Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ BRZ2.ar(WhiteNoise.ar(0.25)) }.play;
::



CLASS::Bag
summary::Unordered collection of objects
related::Classes/IdentityBag, Classes/Set
categories::Collections>Unordered

DESCRIPTION::
A Bag is an unordered collection of objects. In some languages it is referred to as a counted set. A Bag keeps track of the number of times objects are inserted and requires that objects be removed the same number of times. There is only one instance of an object in a Bag even if the object has been added to the Bag multiple times (test is for strong::equality::)

Most of Bag's methods are inherited from Collection.
The contents of a Bag are unordered. You must not depend on the order of items in a set.

CLASSMETHODS::

method::new
Creates a Bag with an initial capacity for strong::n:: objects.

INSTANCEMETHODS::

private::setDictionary

method::contents
Returns the dictionary that stores the objects in pairs (obj -> numberOfObjects)
code::
Bag["a", "b", "c", "c"].contents;
::
returns:: link::Classes/Dictionary::

method::itemCount
Count the number of strong::item::s.
code::
Bag[1, 2, 2, 3, 300, 2].itemCount(2);
::

subsection::Adding and Removing

method::add
Add an object to the Bag. A Bag may contain multiple entries of the same object.
code::
Bag[1, 2, 3].add(4).postln;

Bag[1, 2, 3].add(3).postln;

Bag["abc", "def", "ghi"].add("jkl").postln;

Bag["abc", "def", "ghi"].add("def").postln;
::

method::remove
Remove an object from the Bag.
code::
Bag[1, 2, 3].remove(3).postln;
::

subsection::Iteration

method::do
Evaluates strong::function:: for each item in the Bag.
The function is passed two arguments, the item and an integer index.
code::
Bag[1, 2, 3, 300].do({ arg item, i; item.postln });

Bag[1, 2, 2, 3, 300].do({ arg item, i; item.postln });
::
argument::function
args to function: item, i

method::countsDo
Evaluates strong::function:: for each unique item in the Bag along with that item's count.
The function is passed two arguments, the item, the quantity of that item in the Bag and an integer index.
code::
Bag[1, 2, 3, 300].countsDo({ arg item, count, i; [item,count].postln });

Bag[1, 2, 2, 3, 300].countsDo({ arg item, count, i; [item,count].postln });
::

subsection::Testing

method::includes
Answer whether an object is contained in the Bag.
code::
Bag[1, 2, 3, 4].includes(3);
::
returns:: link::Classes/Boolean::

EXAMPLES::

subsection::Difference between Bag and IdentityBag:
code::
// the two strings are equal, but not identical
"something" == "something"; // true
"something" === "something" // false

a = Bag.new;
a.add("something");
a.add("something");
a.contents; // only one object in the bag really

a = IdentityBag.new;
a.add("something");
a.add("something");
a.contents; // two objects in the bag
::



class:: Balance2
summary:: Stereo signal balancer
related:: Classes/LinPan2, Classes/Pan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Equal power panning balances two channels. By panning from left (pos=-1) to right (pos=1) you are decrementing the level of the left channel from 1 to 0 taking the square root of the linear scaling factor, while at the same time incrementing the level of the right channel from 0 to 1 using the same curve. In the center position (pos=0) this results in a level for both channels of 0.5.sqrt (~=0.707 or -3dB). The output of Balance2 remains a stereo signal.

classmethods::
private:: categories

method::ar, kr

argument::left
channel 1 of input stereo signal

argument::right
channel 2 of input stereo signal

argument::pos
pan position, -1 is left, +1 is right

argument::level
a control rate level input.

Examples::
code::
// a stereo signal, both channels at 0dB
{[SinOsc.ar(440), SinOsc.ar(440)]}.play

// using Balance on a stereo signal with the position parameter at 0, effectively the same sound but both channels at -3dB
{Balance2.ar(SinOsc.ar(440), SinOsc.ar(440), 0)}.play

// pan sweep from left to right
{Balance2.ar(SinOsc.ar(440), SinOsc.ar(1000), Line.kr(-1,1,5))}.play

// other examples
{Balance2.ar(LFSaw.ar(44),Pulse.ar(33),FSinOsc.kr(0.5), 0.1) }.play;
{var source; source= SinOsc.ar([440,550]); Balance2.ar(source[0],source[1],LFNoise0.kr(4),0.3) }.play;
::


class:: Ball
summary:: physical model of bouncing object
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/TBall, Classes/Spring

Description::
Ball models the path of a bouncing object that is reflected by a vibrating surface.

classmethods::
private:: categories

method:: ar, kr

argument::in
modulated surface level

argument::g
gravity

argument::damp
damping on impact

argument::friction
proximity from which on attraction to surface starts

examples::
mouse x controls switch of level:
code::
(
{
	var f, sf;
	sf = K2A.ar(MouseX.kr > 0.5) > 0;
	f = Ball.ar(sf, MouseY.kr(0.01, 20, 1), 0.01);
	f = f * 10 + 500;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
::

mouse x controls modulation rate, mouse y controls gravity:
code::
(
{
	var f, sf, g;
	sf = LFNoise0.ar(MouseX.kr(1, 100, 1));
	g = MouseY.kr(0.1, 10, 1);
	f = Ball.ar(sf, g, 0.01, 0.01);
	f = f * 140 + 500;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
::

the general german police choir. mouse x controls damping, mouse y controls gravity:
code::
(
{
	var f, sf, g;
	sf = LFPulse.ar(0.6, 0.2, 0.5);
	g = MouseY.kr(0.1, 10, 1);
	d = MouseX.kr(0.0001, 1, 1);
	f = Ball.ar(sf, g, d);
	f = f * 140 + 400;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
::



class:: BasicOpUGen
summary:: Common superclass to operations on UGen
categories:: UGens>Algebraic
related:: Classes/UnaryOpUGen, Classes/BinaryOpUGen, Overviews/Operators

description::
Common superclass to operations on UGens

instancemethods::

method::operator
set or get the operator



class:: BeatTrack
summary:: Autocorrelation beat tracker
categories:: UGens>Analysis, UGens>FFT
related:: Classes/BeatTrack2

description::
Autocorrelation based beat tracker; footnote::
Research note: This UGen is a derivation following:
Davies, M. E. P.  and Plumbley, M. D. Beat Tracking With A Two State Model. Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP 2005), Philadelphia, USA, March 19-23, 2005

The UGen was converted by Nick Collins for beat tracking research in the course of his PhD and uses an original C implementation of Matthew Davies' MATLAB model. It first appeared as part of BBCut2 as AutoTrack but has now been added to core to enhance SuperCollider's realtime machine listening options.
:: the underlying model assumes 4/4, but it should work on any isochronous beat structure, though there are biases to 100-120 bpm; a fast 7/8 may not be tracked in that sense.
There are four k-rate outputs, being ticks at quarter, eighth and sixteenth level from the determined beat, and the current detected tempo. Note that the sixteenth note output won't necessarily make much sense if the music being tracked has swing; it is provided just as a convenience.

This beat tracker determines the beat, biased to the midtempo range by weighting functions. It does not determine the measure level, only a tactus.
It is also slow reacting, using a 6 second temporal window for its autocorrelation maneouvres. Don't expect human musician level predictive tracking.

On the other hand, it is tireless, relatively general (though obviously best at transient 4/4 heavy material without much expressive tempo variation), and can form the basis of computer processing that is decidedly faster than human.

classmethods::
private:: categories

method:: kr

argument:: chain
[fft] Audio input to track, already passed through an FFT UGen; the expected size of FFT is 1024 for 44100 and 48000 sampling rate, and 2048 for double those. No other sampling rates are supported.
argument:: lock
[sk] If this argument is greater than 0.5, the tracker will lock at its current periodicity and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected in the output until lock goes back below 0.5.
returns::
Four k-rate outputs:
code::
#quarternotetick, eighthnotetick, sixteenthnotetick, tempo = BeatTrack.kr(chain, 0)
::

instancemethods::
private:: init

examples::

code::

//this is a one minute pop song; you should load something equivalent for testing
d = Buffer.read(s, "/Volumes/data/stevebeattrack/samples/100.wav");


//you can also test at 48000 and it should work
(
a = SynthDef(\help_beattrack, { |out, vol=1.0, beepvol=1.0, lock=0|
	var in, fft, resample;
	var trackb, trackh, trackq, tempo;
	var bsound, hsound, qsound, beep;

	in = PlayBuf.ar(1,d, BufRateScale.kr(d),1,0,1);
	//in = SoundIn.ar(0);

	fft = FFT(LocalBuf(1024), in); // for sampling rates 44100 and 48000

	#trackb, trackh, trackq, tempo = BeatTrack.kr(fft, lock);

	beep = SinOsc.ar(1000, 0.0, Decay.kr(trackb, 0.1));

	Out.ar(out, Pan2.ar((vol * in) + (beepvol * beep), 0.0))

}).play
)

a.set(\vol,0.0);
a.set(\vol,1.0);

a.set(\beepvol,1.0);
a.set(\beepvol,0.0);

a.set(\lock,1); //fix it rigidly from current phase/period solution
a.set(\lock,0); //unfix, back to tracking
::

track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin) and spawning stuff at quarters, eighths and sixteenths:

code::
(
SynthDef(\help_beattrack2, { |out|
	var trackb, trackh, trackq, tempo;
	var source;
	var bsound, hsound, qsound;

	source = SoundIn.ar(0);

	#trackb, trackh, trackq, tempo = BeatTrack.kr(FFT(LocalBuf(1024)));

	bsound = Pan2.ar(LPF.ar(WhiteNoise.ar * Decay.kr(trackb, 0.05), 1000), 0.0);

	hsound = Pan2.ar(BPF.ar(WhiteNoise.ar * Decay.kr(trackh, 0.05), 3000, 0.66), -0.5);

	qsound = Pan2.ar(HPF.ar(WhiteNoise.ar * Decay.kr(trackq, 0.05),5000), 0.5);

	Out.ar(out, bsound + hsound + qsound);
}).play;
)
::



class:: BeatTrack2
summary:: Template matching beat tracker
categories:: UGens>Analysis, UGens>FFT
related:: Classes/BeatTrack

description::
This beat tracker footnote::
Research note: Designed by Nick Collins following work by Jean Laroche
:: is based on exhaustively testing particular template patterns against feature streams; the testing takes place every 0.5 seconds. The two basic templates are a straight (groove=0) and a swung triplet (groove=1) pattern of 16th notes; this pattern is tried out at scalings corresponding to the tempi from 60 to 180 bpm.
This is the cross-correlation method of beat tracking. A majority vote is taken on the best tempo detected, but this must be confirmed by a consistency check after a phase estimate. Such a consistency check helps to avoid wild fluctuating estimates, but is at the expense of an additional half second delay.
The latency of the beat tracker with default settings is thus at least 2.5 seconds; because of block-based amortisation of calculation, it is actually around 2.8 seconds latency for a 2.0 second temporal window.

This beat tracker is designed to be flexible for user needs; you can try out different window sizes, tempo weights and combinations of features. However, there are no guarantees on stability and effectiveness, and you will need to explore such parameters for a particular situation.

classmethods::
private:: categories

method:: kr

argument:: busindex
[sk] Audio input to track, already analysed into N features, passed in via a control bus number from which to retrieve consecutive streams.

argument:: numfeatures
[s] How many features (ie how many control buses) are provided

argument:: windowsize
[s] Size of the temporal window desired (2.0 to 3.0 seconds models the human temporal window). You might use longer values for stability of estimate at the expense of reactiveness.

argument:: phaseaccuracy
[s] Relates to how many different phases to test. At the default, 50 different phases spaced by phaseaccuracy seconds would be tried out for 60bpm; 16 would be tried for 180 bpm. Larger phaseaccuracy means more tests and more CPU cost.

argument:: lock
[sk] If this argument is greater than 0.5, the tracker will lock at its current periodicity and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected in the output until lock goes back below 0.5.

argument:: weightingscheme
[s] Use (-2.5) for flat weighting of tempi, (-1.5) for compensation weighting based on the number of events tested (because different periods allow different numbers of events within the temporal window) or otherwise a bufnum from 0 upwards for passing an array of 120 individual tempo weights; tempi go from 60 to 179 bpm in steps of one bpm, so you must have a buffer of 120 values.

returns::
Six k-rate outputs:
code::
#beattick, eighthtick, groovetick, tempo, phase, groove = BeatTrack2.kr(busindex, numfeatures)
::

instancemethods::
private:: init

examples::

code::

// you should load something useful for testing, like a one minute pop song
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

//very feature dependent
(
SynthDef(\help_beattrack2_1, { |out, vol=1.0, beepvol=1.0, lock=0, bufnum|
	var in, kbus;
	var trackb, trackh, trackq, tempo, phase, period, groove;
	var bsound, hsound, qsound, beep;
	var fft;
	var feature1, feature2, feature3;

	in = PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), 1, 0, 1);
	//in = SoundIn.ar(0);

	//Create some features
	fft = FFT(LocalBuf(1024), in); //for sampling rates 44100 and 48000
	//fft = FFT(LocalBuf(2048), in); //for sampling rates 88200 and 96000

	feature1 = RunningSum.rms(in, 64);
	feature2 = MFCC.kr(fft,2); //two coefficients
	feature3 = A2K.kr(LPF.ar(in,1000));

	kbus = Out.kr(0, [feature1, feature3] ++ feature2);

	//Look at four features
	#trackb, trackh, trackq, tempo, phase, period, groove = BeatTrack2.kr(0, 4, 2.0, 0.02, lock, -2.5);

	beep= SinOsc.ar(1000, 0.0, Decay.kr(trackb, 0.1));
	beep = Pan2.ar((vol * in) + (beepvol * beep), 0.0);
	Out.ar(out, beep);
}).add;
)

a = Synth(\help_beattrack2_1, [\bufnum, b]);
a.set(\vol, 0.0);
a.set(\vol, 1.0);

a.set(\beepvol, 1.0);
a.set(\beepvol, 0.0);

a.set(\lock, 1); //fix it rigidly from current phase/period solution
a.set(\lock, 0); //unfix, back to tracking

a.free;
::

code::
//same thing, trying with Onsets UGen raw output
(
a= SynthDef(\help_beattrack2_1, { |out, vol=1.0, beepvol=1.0, lock=0, bufnum|
	var in, kbus;
	var trackb, trackh, trackq, tempo, phase, period, groove;
	var bsound, hsound, qsound, beep;
	var fft;
	var feature1, feature2, feature3;

	in = PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum),1,0,1);
	//in = SoundIn.ar(0);

	//Create some features
	fft = FFT(LocalBuf(1024), in); // for sampling rates 44100 and 48000
	//fft = FFT(LocalBuf(2048), in); // for sampling rates 88200 and 96000

	feature1 = Onsets.kr(fft, odftype:\mkl, rawodf:1);

	feature2 = Onsets.kr(fft, odftype:\complex, rawodf:1);//two coefficients

	kbus= Out.kr(0, [feature1,feature2]);

	//Look at four features
	#trackb, trackh, trackq, tempo, phase, period, groove = BeatTrack2.kr(0, 2, 3.0, 0.02, lock, -2.5);


	beep = SinOsc.ar(1000, 0.0, Decay.kr(trackb, 0.1));
	beep = Pan2.ar((vol * in) + (beepvol * beep), 0.0);
	Out.ar(out, beep);
}).add;
)

a = Synth(\help_beattrack2_1, [\bufnum, b]);

::

code::
//favour higher tempi in own weighting scheme
(
c = Array.fill(120, { |i| 0.5 + (0.5 * (i / 120)) });
e = Buffer.sendCollection(s, c, 1);
)
::


code::
// track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin) and spawning stuff at quarters, eighths and sixteenths
(
SynthDef(\help_beattrack2_2, { |out|
	var trackb, trackh, trackq, tempo;
	var source, kbus;
	var bsound, hsound, qsound;

	source = SoundIn.ar(0);

	//downsampling automatic via kr from ar
	kbus = Out.kr(0, LPF.ar(source, 1000)); //([feature1, feature3]++feature2);

	#trackb, trackh, trackq, tempo = BeatTrack2.kr(0,1,weightingscheme: e.bufnum);

	bsound = Pan2.ar(LPF.ar(WhiteNoise.ar * (Decay.kr(trackb, 0.05)), 1000), 0.0);
	hsound = Pan2.ar(BPF.ar(WhiteNoise.ar * (Decay.kr(trackh, 0.05)), 3000, 0.66),-0.5);
	qsound = Pan2.ar(HPF.ar(WhiteNoise.ar * (Decay.kr(trackq, 0.05)), 5000), 0.5);

	Out.ar(out, source + bsound + hsound + qsound);
}).play;
)
::


code::
// geometric tempo placement very similar to linear, and linear easier to deal with looking up related tempi at double and half speed
(
var startbps = 1, endbps = 3;
var numtempi = 100;
var ratio, tempi, periods;

ratio = (endbps / startbps) ** (numtempi-1).reciprocal;

tempi = Array.geom(numtempi, startbps, ratio);

periods = tempi.reciprocal;

Post << (tempi*60) << nl;
Post << periods << nl;
)

//create linear periods
Post << ((Array.series(120,1,2/120)).reciprocal) << nl;

//tempo weights
 Post << (Array.fill(120,{arg i;  0.2*((1.0- ((abs(i-60))/60.0))**0.5) + 0.8; })) << nl;
::



class:: BelaScope
summary:: Bela's Oscilloscope interface
categories::  UGens>Bela

Description::
note::
This UGen only works on Bela
::
Allows to scope signals on Bela's built-in Oscilloscope, which can be accessed from Bela's web interface.
It is not needed to interact directly with this class, as UGens, Arrays, Busses, Functions and Servers can be scoped via their .belaScope() method.

subsection:: Setup

Using BelaScope requires:
list::
## an instance of Server running on a Bela (either locally or remotely).

## ServerOptions.belaMaxScopeChannels should be set > 0 for Bela's server.
It represents the maximum number of channels that is possible to scope on that server, and affects resources allocation.
If set <= 0, the server won't instantiate any Scope object, and any attempt to instantiate a BelaScope from sclang will throw an error.
::

subsection:: Usage
Once a Bela server is started with options.belaMaxScopeChannels > 0, it is possible to scope UGens and Busses using their .belaScope() methods. See examples below.

classmethods::

method::scope
Send an array of UGen data to Bela's oscilloscope.

argument::channelOffset
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument::signals
Array of UGens to scope

returns:: the array of code::signals:: passed in as an argument. This allows for transparent usage of code::.belaScope():: in processing chains

code::
{ BelaScope.scope(0, SinOsc.ar) }.play;
// same using UGen::belaScope() shortcut method:
{ SinOsc.ar().belaScope(0) }.play

// transparent usage in chains:
// scoping LFNoise0 before and after .range, while still using it to modulate SinOsc
{ SinOsc.ar(LFNoise0.kr(10).belaScope(0).range(20,100).belaScope(1)) }.play
::

method::monitorBus
Scope a Bus on Bela's oscilloscope
argument::channelOffset
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument::busindex
Index of the audio bus to scope

argument::numChannels
Number of bus channels to scope

argument::target
Bela's SuperCollider server, or any node on that server. The bus is monitored strong::after:: this target, or after this server's link::Classes/RootNode:: if a server is provided as target.

argument::rate
A symbol. The default is code::\audio::. Anything else will use control rate.

returns:: A link::Classes/Synth:: used to monitor the bus.

code::
// scope 2 channels from audio bus 4 on Bela Oscilloscope's channel 3
BelaScope.monitorBus(3, 4, 2, ~belaServer)
// same using Server::belaScope() shortcut method:
~belaServer.belaScope(3, 4, 2)
// same using Bus::belaScope() shortcut method
Bus(\audio, 4, 2, ~belaServer).belaScope(3)
::

Examples::

code::
~belaServer = Server.remote(\Bela, NetAddr("192.168.6.2", 57110));

// UGens: usage like .poll
// scope the LFNoise0, and still use it to modulate a SinOsc
{ var freq = LFNoise0.kr.range(20,2000); SinOsc.ar(freq.belaScope(0)) }.play(~belaServer)

// scope an Array of UGens:
{ var freq = LFNoise0.kr.range(20,2000) ! 4; SinOsc.ar(freq.belaScope(0)) }.play(~belaServer)

// Bus: scope 3 channels from bus number 10 on Bela Oscilloscope's channel 4
b = Bus(\audio, 10, 6, ~belaServer);
{ SinOsc.ar }.play(~belaServer, outbus:b);
b.belaScope(4);

// Server: usage like .scope
// scope busses 10 and 11 on Bela's Oscilloscope channel 2
~belaServer.belaScope(2, 10, 2)
// scope main output busses on Bela's Oscilloscope channel 0
~belaServer.belaScope

// Function: usage like .scope
// play and scope a multi-output function; scope starting on BelaScope channel 4
{ SinOsc.ar(LFNoise0.ar([1,2,3]).exprange(20,20000)) * LFNoise1.ar([1,2,3]).exprange(0.001, 0.1) }.belaScope(4, ~belaServer)
::


class:: BelaScopeOut
summary:: Bela's Oscilloscope interface
categories::  UGens>Bela

Description::
note::
This UGen only works on Bela
::
This UGen effectively sends audio signals to Bela Oscilloscope, analogously to how link::/Classes/Out:: writes to a bus.
It can be used directly, or through link::Classes/UGen#-belaScope::, link::Classes/Array#-belaScope::, link::Classes/Bus#-belaScope::, link::Classes/Function#-belaScope:: and link::Classes/Server#-belaScope:: convenience functions.

classmethods::

method::ar
argument::offset
The Bela Oscilloscope's channel where to start writing. This is read only at construction time and thus it's not modulatable.
argument::channelsArray
An array of UGens to be scoped.



class:: BendResponder
summary:: allow functions to be registered to respond to MIDI pitchbend events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::

ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::value
An link::Classes/Integer:: between 0 and 16383 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next pitch bend message, reset self to match src, chan.
code::
(
c = BendResponder({ |src,chan,value|
		[src,chan,value].postln;
	});
	c.learn; // wait for the first bend message
)
BendResponder.removeAll
::


Examples::

code::
(
	c = BendResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
::

code::
(
	c = BendResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		(3..6), // only channels 3 - 6
		nil // any value
	)
)

c.remove
::


class:: BiPanB2
summary:: 2D Ambisonic B-format panner.
related:: Classes/DecodeB2, Classes/PanB, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Encode a two channel signal to two dimensional ambisonic B-format. This
puts two channels at opposite poles of a 2D ambisonic field. This is one
way to map a stereo sound onto a soundfield. It is equivalent to:

code::
PanB2(inA, azimuth, gain) + PanB2(inB, azimuth + 1, gain)
::

classmethods::

method::ar, kr

argument::inA
Input signal A

argument::inB
Input signal B.

argument::azimuth
Position around the circle from -1 to +1.

-1 is behind, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind.

argument::gain
Amplitude control.


Examples::

code::

(
{
	var w, x, y, p, q, a, b, c, d;

	p = LFSaw.ar(200);
	q = LFSaw.ar(301);

	// B-format encode
	#w, x, y = BiPanB2.ar(p, q, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)

::



class:: BinaryOpFunction
summary:: represent a binary operation on a function
categories:: Core
related:: Classes/UnaryOpFunction, Classes/NAryOpFunction, Classes/BinaryOpStream, Classes/Pbinop, Overviews/Operators

description::

Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

instanceMethods::

private::storeOn

method::value

Executes each of the operand functions and then performs the selector on the result.

method::valueArray

the same as link::#-value::

examples::

code::
// example
a = 5 + 7; // result is 12.
a = { b } + 7; // result is  a BinaryOpFunction
b = 5;
a.value; // now it is evaluated, and the result is calculated
b = 8;
a.value; // again, with a different value.
::

code::
// sound example
(
var a = { 19.rand };
var b = { [5, 8, 9].choose };
var c = a + b;
fork {
	15.do {
		(instrument: \default, note: [c.value, a.value]).play;
		0.3.wait;
	}
}
)
::


class:: BinaryOpStream
summary:: two streams combined by a binary operator
related:: Classes/UnaryOpStream, Classes/NAryOpStream
categories:: Streams-Patterns-Events

description::

A BinaryOpStream is created as a result of a binary math operation on a pair of Streams. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from both streams. It responds to strong::reset:: by resetting both Streams.

Examples::

code::
x = Routine { 6.do { arg i; i.yield; } } + 64;
x.dump
::

code::
(
x = Routine { 6.do { arg i; i.yield; } } + 64;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
::

code::
(
x = Routine { 6.do { arg i; i.yield; } } + Routine { (1..7).do { arg i; (1 / i).yield; } };
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
::


class:: BinaryOpUGen
summary:: Apply a binary operation to the values of an input UGen
related:: Classes/UnaryOpUGen, Classes/BinaryOpFunction, Classes/Pbinop, Overviews/Operators
categories:: UGens>Algebraic

description::
BinaryOpUGens are created as the result of a binary operator applied to a link::Classes/UGen::.
code::
(SinOsc.ar(200) * ClipNoise.ar).dump;
(SinOsc.ar(200).thresh(0.5)).dump;
::
The use of the binary operators code::*:: and code::thresh:: above each instantiate a BinaryOpUGen. The operators themselves  (which are methods) are not to be confused with the resulting BinaryOpUGen (which is an object). The unary and binary operators are defined in link::Classes/UGen::'s superclass link::Classes/AbstractFunction::, which creates the
BinaryOpUGen as a result of the operation.

When operating on UGens instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation. For the immediate operations on numbers, see for example link::Classes/SimpleNumber::.

See link::Overviews/Operators:: for an overview of common operators.

classmethods::
private:: new1

method::new
return a new instance that applies the operator code::selector:: to the UGens code::a:: and code::b:: normally, this is implicitly called when applying an operator to a link::Classes/UGen::.
argument:: selector
The selector symbol for the binary operator
argument:: a
left operand
argument:: b
right operand
returns:: A new instance of BinaryOpUGen

instancemethods::
private:: init, optimizeGraph, constantFolding

examples::

code::
a = WhiteNoise.ar; // a WhiteNoise
b = a + 2; // a BinaryOpUGen.
b.operator; // +

// sound example
(
{
	var a = LFSaw.ar(300);
	var b = LFSaw.ar(329.1);
	a % b * 0.1
}.play;
)
::

subsection::The comparison operators

The operators code:: >, >=, <, <= :: are particularly useful for triggering. They should not be confused with their use in conditionals. Compare:

code::
if(1 > 0) { "1 is greater than 0".postln }; // > returns a boolean
::

with

code::
// trigger an envelope
(
{
    var trig;
    trig = SinOsc.ar(1) > 0.1;
    EnvGen.kr(Env.perc, trig, doneAction: Done.none) * SinOsc.ar(440,0,0.1)
}.play
) // > outputs 0 or 1
::

See link::Overviews/Operators:: or the implementation of these in link::Classes/AbstractFunction:: for more detail.

Since the equality operator ( code::==:: ) is used to distinguish objects including UGens, it cannot be used to create a BinaryOpUGen by application. Instead, to get a trigger value each time two signals are the same (instead of just finding out whether two UGens are the same), one can instantiate a BinaryOpUGen directly:

code::
(
{
    var a = SinOsc.ar(1).round(0.1);
    var b = SinOsc.ar(1.2).round(0.1);
    BinaryOpUGen('==', a, b) * 0.1
}.play;
)
::



class:: Blip
summary:: Band limited impulse oscillator.
related:: Classes/Impulse
categories::  UGens>Generators>Deterministic


Description::

Band Limited ImPulse generator. All harmonics have equal amplitude.
This is the equivalent of 'buzz' in  emphasis::MusicN:: languages.

emphasis::Synth-O-Matic:: (1990) had an impulse generator
called blip, hence that name here rather than 'buzz'.

It is improved from other implementations in that it will crossfade
in a control period when the number of  harmonics changes,
so that there are no audible pops. It also eliminates the divide in
the formula by using a 1/sin table (with special precautions taken for
1/0).  The lookup tables are linearly interpolated for better quality.

warning::
This waveform in its raw form could be damaging to your ears at high
amplitudes or for long periods.
::

classmethods::

method::ar

argument::freq
Frequency in Hertz.

argument::numharm
Number of harmonics. This may be lowered internally if it would cause aliasing.

argument::mul

argument::add

Examples::

code::
// modulate frequency
{ Blip.ar(XLine.kr(20000,200,6),100,0.2) }.play;

// modulate numharmonics
{ Blip.ar(200,Line.kr(1,100,20),0.2) }.play;
::



class::Boolean
summary:: abstract class whose instances represent a logical value
categories::Core
related:: Reference/Control-Structures

description::
Boolean is the superclass of link::Classes/True:: and link::Classes/False:: which are the concrete realizations.
In code True and False are represented by the literal values code::true:: and code::false::.

instanceMethods::

private:: while
private:: storeOn
private:: trace
private:: printOn
private:: archiveAsCompileString

method::xor

returns:: the exclusive or of the receiver and another Boolean.

method::and

If the receiver is true then answer the evaluation of function.
If the receiver is false then function is not evaluated and the message answers false.

method::or

If the receiver is false then answer the evaluation of function.
If the receiver is true then function is not evaluated and the message answers true.

method::&&

returns:: true if the receiver is true and aBoolean is true.

method::||

returns:: true if either the receiver is true or aBoolean is true.

method::nand

returns:: true unless both the operands are true (Sheffer stroke)

method::not

returns:: true if the receiver is false, and false if the receiver is true.

method::if

If the receiver is true, answer the evaluation of the trueFunc. If the receiver is false, answer the evaluation of the falseFunc.

method::asInteger
method::binaryValue

returns:: 1 if the receiver is true, and 0 if the receiver is false.

method::asBoolean
method::booleanValue
Returns:: The receiver. The same message is understood by link::Classes/SimpleNumber:: and can be used to convert it to boolean.

method::keywordWarnings

turn on/off warnings if a keyword argument is not found




class:: BrownNoise
summary:: Brown Noise.
related:: Classes/ClipNoise, Classes/GrayNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic

Description::
Generates noise whose spectrum falls off in power by 6 dB per octave.

classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

compare:
code::
{ BrownNoise.ar(0.1) }.play;
{ WhiteNoise.ar(0.1) }.play;
::

brownian noise as a frequency modulator:
code::
{ SinOsc.ar(BrownNoise.ar(100, 200)) * 0.1 }.play;
::

filtered brown noise:
code::
{ BPF.ar(BrownNoise.ar(0.1.dup), MouseX.kr(40, 17000, 1), 0.2) }.play;
::


class:: BufAllpassC
summary:: Buffer based all pass delay line with cubic interpolation.
related:: Classes/BufAllpassL, Classes/BufAllpassN, Classes/AllpassC
categories::  UGens>Delays>Buffer


Description::

All pass delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassN::  which uses no
interpolation, and  which  link::Classes/BufAllpassL::  uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufAllpassL
summary:: Buffer based all pass delay line with linear interpolation.
related:: Classes/BufAllpassC, Classes/BufAllpassN, Classes/AllpassL
categories::  UGens>Delays>Buffer


Description::

All pass delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassN::  which uses no
interpolation, and  which  link::Classes/BufAllpassC::  uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassL.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufAllpassN
summary:: Buffer based all pass delay line with no interpolation.
related:: Classes/BufAllpassC, Classes/BufAllpassL, Classes/AllpassN
categories::  UGens>Delays>Buffer


Description::

All pass delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassC::  which uses cubic
interpolation, and  which  link::Classes/BufAllpassL::  uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.

classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufChannels
summary:: Current number of channels of soundfile in buffer.
related:: Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current number of channels of soundfile.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current number of channels.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes. Use code::.kr:: instead.
::



class:: BufCombC
summary:: Buffer based comb delay line with cubic interpolation.
related:: Classes/BufCombL, Classes/BufCombN, Classes/CombC
categories::  UGens>Delays>Buffer


Description::

Comb delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombN::  which uses no
interpolation, and  link::Classes/BufCombL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombC.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufCombL
summary:: Buffer based comb delay line with linear interpolation.
related:: Classes/BufCombC, Classes/BufCombN, Classes/CombL
categories::  UGens>Delays>Buffer


Description::

Comb delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombN::  which uses no
interpolation, and  link::Classes/BufCombC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombL.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufCombN
summary:: Buffer based comb delay line with no interpolation.
related:: Classes/BufCombC, Classes/BufCombL, Classes/CombN
categories::  UGens>Delays>Buffer


Description::

Comb delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombL::  which uses linear
interpolation, and  link::Classes/BufCombC::  which uses cubic
interpolation. Cubic interpolation is more computationally
expensive than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul

argument::add

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;

::



class:: BufDelayC
summary:: Buffer based simple delay line with cubic interpolation.
related:: Classes/BufDelayL, Classes/BufDelayN, Classes/DelayC
categories::  UGens>Delays>Buffer


Description::

Simple delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayN::  which uses no
interpolation, and  link::Classes/BufDelayL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayC.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayC.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);

::



class:: BufDelayL
summary:: Buffer based simple delay line with linear interpolation.
related:: Classes/BufDelayC, Classes/BufDelayN, Classes/DelayL
categories::  UGens>Delays>Buffer


Description::

Simple delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayN::  which uses no
interpolation, and  link::Classes/BufDelayC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayL.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayL.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);

::



class:: BufDelayN
summary:: Buffer based simple delay line with no interpolation.
related:: Classes/BufDelayC, Classes/BufDelayL, Classes/DelayN
categories::  UGens>Delays>Buffer


Description::

Simple delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayL::  which uses linear
interpolation, and  link::Classes/BufDelayC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::mul

argument::add

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayN.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayN.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);

::



class:: BufDur
summary:: Current duration of soundfile in buffer.
related:: Classes/BufChannels, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current duration of soundfile.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current duration.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
::

Examples::

code::
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

{ BufRd.ar(1, b,  Sweep.ar(Impulse.ar(BufDur.kr(b).reciprocal), BufSampleRate.kr(b))) }.play;

b.free

::



class:: BufFrames
summary:: Current number of frames allocated in the buffer.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current number of allocated frames.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current number of allocated frames.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
::

Examples::

code::

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// indexing with a phasor
{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufFrames.kr(b))) }.play;

// indexing by hand
{ BufRd.ar(1, b, K2A.ar(MouseX.kr(0, BufFrames.kr(b)))) }.play;

b.free

::



class:: BufInfoUGenBase
categories:: UGens>Base
summary:: Base class for buffer info ugens

description::
This is the superclass for the various buffer info ugens.



class:: BufRateScale
summary:: Buffer rate scaling in respect to server samplerate.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info


Description::
Returns a ratio by which the playback of a soundfile is to be scaled.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

Returns:: a ratio by which the playback of a soundfile is to be scaled.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
::

Examples::

code::
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
x = { arg rate=1;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)))
}.play;
)
::



class:: BufRd
summary:: Buffer reading oscillator.
related:: Classes/BufWr
categories::  UGens>Buffer


Description::

Read the content of a buffer at an index.

In comparison to link::Classes/PlayBuf:: :
PlayBuf plays through the buffer by itself, BufRd only moves its read point by the phase input and
therefore has no pitch input. BufRd has variable interpolation.

classmethods::
private:: categories
method::ar, kr

argument::numChannels
Number of channels that the buffer will be. This must be a fixed
integer. The architecture of the SynthDef cannot change after it
is compiled.
note::
If you supply a  code::bufnum::  of a buffer that has a
different  code::numChannels::  then you have specified to
the BufRd, it will post a warning and output the channels it can.
::

argument::bufnum
The index of the buffer to use.

argument::phase
Audio rate modulateable index into the buffer.
Warning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz). ::

argument::loop
1 means true, 0 means false. This is modulateable.


argument::interpolation
1 means no interpolation, 2 is linear, 4 is cubic interpolation.

instancemethods::
private:: init, argNamesInputsOffset, checkInputs

Examples::

code::

(
// read a whole sound into memory
s = Server.local;
// note: not *that* columbia, the first one
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

//use any AUDIO rate ugen as an index generator

{ BufRd.ar(1, b, SinOsc.ar(0.1) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFNoise1.ar(1) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFNoise1.ar(10) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFTri.ar(0.1) + LFTri.ar(0.23) * BufFrames.ir(b)) }.play;
// original duration
{ BufRd.ar(1, b, LFSaw.ar(BufDur.ir(b).reciprocal).range(0, BufFrames.ir(b)) ) }.play;


//use a phasor index into the file

{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufFrames.kr(b))) }.play;


//change rate and interpolation
(
x = { arg rate=1, inter=2;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)), 1, inter)
}.play;
)

x.set(\rate, 0.9);
x.set(\rate, 0.6);
x.set(\inter, 1);
x.set(\inter, 0);


//write into the buffer with a BufWr
(
y = { arg rate=1;
	var in;
	in = SinOsc.ar(LFNoise1.kr(2, 300, 400), 0, 0.1);
	BufWr.ar(in, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)));
	0.0 //quiet
}.play;
)

//read it with a BufRd
(
x = { arg rate=1;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)))
}.play;
)



x.set(\rate, 5);
y.set(\rate, 2.0.rand);
x.set(\rate, 2);

b.free

::



class:: BufSampleRate
summary:: Buffer sample rate.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSamples
categories::  UGens>Buffer>Info


Description::
Returns the buffer's current sample rate.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns::
the buffer's current sample rate.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
::

Examples::

code::
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// compares a 1102.5 Hz sine tone (11025 * 0.1, left) with a 1100 Hz tone (right)
// the apollo sample has a sample rate of 11.025 kHz
(
{
	var freq;
	freq = [ BufSampleRate.kr(b) * 0.1, 1100];
	SinOsc.ar(freq, 0, 0.1)
}.play;
)

b.free;
::



class:: BufSamples
summary:: Current number of samples in buffer.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate
categories::  UGens>Buffer>Info

Description::

Returns the current number of allocated samples. A sample is not the same as a frame (compare with link::Classes/BufFrames:: ); a frame includes the samples in each channel of the buffer. Only for a mono buffer are samples the same as frames.
code::
samples = frames * numChannels
::


classmethods::

method::kr, ir

argument::bufnum
Buffer index.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
::

examples::
code::
// example; this buffer is mono, so the number of samples matches the number of frames
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// indexing with a phasor
{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufSamples.kr(b))) }.play;

// indexing by hand
{ BufRd.ar(1, b, K2A.ar(MouseX.kr(0, BufSamples.kr(b)))) }.play;

b.free;
::



class:: BufWr
summary:: Buffer writing oscillator.
related:: Classes/BufRd
categories::  UGens>Buffer

Description::
Write to a buffer at an index.

note:: BufWr (in difference to  link::Classes/BufRd:: ) does not do multichannel expansion, because input is an array. ::

classmethods::
private:: categories

method::ar, kr

argument::inputArray
Input UGens (channelArray).

argument::bufnum
The index of the buffer to use.

argument::phase
Modulateable index into the buffer (has to be audio rate).
Warning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz) ::

argument::loop
1 means true, 0 means false. This is modulateable.

instancemethods::
private:: checkInputs

Examples::

code::

(
// allocate a buffer for writinig into
s = Server.local;
s.sendMsg("/b_alloc", 0, 44100 * 2);
)


//write into the buffer with a BufWr
(
y = { arg rate=1;
	var in;
	in = SinOsc.ar(LFNoise1.kr(2, 300, 400), 0, 0.1);
	BufWr.ar(in, 0, Phasor.ar(0, BufRateScale.kr(0) * rate, 0, BufFrames.kr(0)));
	0.0 //quiet
}.play;
)

//read it with a BufRd
(
x = { arg rate=1;
	BufRd.ar(1, 0, Phasor.ar(0, BufRateScale.kr(0) * rate, 0, BufFrames.kr(0)))
}.play(s);
)



x.set(\rate, 5);
y.set(\rate, 2.0.rand);
x.set(\rate, 2);

::



class:: Buffer
summary:: Client-side representation of a buffer on a server
categories:: Server>Abstractions

description::

A Buffer object is a client-side abstraction for a server-side buffer. (SuperCollider's server-client architecture is a common source of confusion when working with Buffer objects, so please see link::Guides/ClientVsServer::.)

A buffer is most often used to hold sampled audio, such as a soundfile loaded into memory, but can be used to hold other types of data as well. Technically speaking, a buffer on the server is a globally available, multichannel array of 32-bit floating-point numbers. It also has an associated sample rate, represented in Hertz as a 64-bit float.

The Buffer class encapsulates a number of common tasks, OSC messages, and capabilities related to server-side buffers – see the examples lower down this document for many examples of using Buffers for sound playback and recording.

Buffers are commonly used with link::Classes/PlayBuf::, link::Classes/RecordBuf::, link::Classes/DiskIn::, link::Classes/DiskOut::, link::Classes/BufWr::, link::Classes/BufRd::, and other UGens. (See their individual help files for more examples.) Buffers can be freed or altered even while being accessed. See link::Reference/Server-Architecture:: for some technical details.

Buffer objects should not be created or modified within a link::Classes/SynthDef::. If this is needed, see link::Classes/LocalBuf::.

subsection:: Buffer Numbers and Allocation

Although the number of buffers on a server is set at the time it is booted, memory must still be allocated within the server app before they can hold values. (At boot time all buffers have a size of 0.)

link::Classes/Server::-side buffers are identified by number, starting from 0. When using Buffer objects, buffer numbers are automatically allocated from the Server's bufferAllocator. When you call code::.free:: on a Buffer object it will release the buffer's memory on the server, and free the buffer number for future reallocation. See link::Classes/ServerOptions:: for details on setting the number of available buffers.

Normally you should not need to supply a buffer number (see link::Classes/Buffer#*alloc::). You should only do so if you are sure you know what you are doing. Similarly, in normal use you should not need to access the buffer number, since instances of Buffer can be used directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

subsection:: Multichannel Buffers

Multichannel buffers interleave their data. Thus the actual number of available values when requesting or setting values by index using methods such as code::set, setn, get, getn::, etc., is equal to code::numFrames * numChannels::.
Indices start at 0 and go up to code::(numFrames * numChannels) - 1::.
In a two channel buffer for instance, index 0 will be the first value of the first channel, index 1 will be the first value of the second channel, index 2 will be the second value of the first channel, and so on.

In some cases it is simpler to use multiple single channel buffers instead of a single multichannel one.

subsection:: Completion Messages and Action Functions

Many buffer operations (such as reading and writing files) are asynchronous, meaning that they will take an arbitrary amount of time to complete. Asynchronous commands are passed to a background thread on the server so as not to steal CPU time from the audio synthesis thread.
Since they can last an arbitrary amount of time it is convenient to be able to specify something else that can be done immediately on completion.
The ability to do this is implemented in two ways in Buffer's various methods: completion messages and action functions.

A completion message is a second OSC command which is included in the message which is sent to the server. (See link::Guides/NodeMessaging:: for a discussion of OSC messages.)
The server will execute this immediately upon completing the first command.
An action function is a link::Classes/Function:: which will be evaluated when the client receives the appropriate reply from the server, indicating that the previous command is done.
Action functions are therefore inherently more flexible than completion messages, but slightly less efficient due to the small amount of added latency involved in message traffic. Action functions are passed the Buffer object as an argument when they are evaluated.

With Buffer methods that take a completion message, it is also possible to pass in a function that returns an OSC message. As in action functions this will be passed the Buffer as an argument.
It is important to understand however that this function will be evaluated after the Buffer object has been created (so that its bufnum and other details are accessible), but before the corresponding message is sent to the server.

subsection:: Bundling

Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities.
See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

subsection:: Server message data types
The server expects teletype::numFrames::, teletype::numChannels:: and get/set index arguments to be integers. As a courtesy, the Buffer methods to construct server messages (method names ending in 'Msg') convert floating-point numbers to integers for these arguments. Users constructing messages manually should take care with these data types.

classmethods::
private:: initClass, initServerCache, clearServerCaches

subsection:: Creation with Immediate Memory Allocation

method:: alloc
Create and return a Buffer and immediately allocate the required memory on the server. The buffer's values will be initialised to 0.0.
argument:: server
The server on which to allocate the buffer. The default is the default Server.
argument:: numFrames
The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels. (A floating-point value is truncated to integer.)
argument:: numChannels
The number of channels for the Buffer. The default is 1. (A floating-point value is truncated to integer.)
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
code::
// Allocate 8 second stereo buffer
s.boot;
b = Buffer.alloc(s, s.sampleRate * 8.0, 2);
b.free;
::

method:: allocConsecutive
Allocates a range of consecutively-numbered buffers, for use with UGens like link::Classes/VOsc:: and link::Classes/VOsc3:: that require a contiguous block of buffers, and returns an array of corresponding Buffer objects.
argument:: numBufs
The number of consecutively indexed buffers to allocate.
argument:: server
The server on which to allocate the buffers. The default is the default Server.
argument:: numFrames
The number of frames to allocate in each buffer. Actual memory use will correspond to numFrames * numChannels. (A floating-point value is truncated to integer.)
argument:: numChannels
The number of channels for each buffer. The default is 1. (A floating-point value is truncated to integer.)
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed each Buffer and its index in the array as arguments when evaluated.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
N.B. You must treat the array of Buffers as a group. Freeing them individually or reusing them can result in allocation errors. You should free all Buffers in the array at the same time by iterating over it with do.
code::
s.boot;
// allocate an array of Buffers and fill them with different harmonics
(
b = Buffer.allocConsecutive(8, s, 4096, 1, { |buf, i|
	buf.sine1Msg((1..((i+1)*6)).reciprocal) // completion Messages
});

a = { VOsc.ar(SinOsc.kr(0.5, 0).range(b.first.bufnum + 0.1, b.last.bufnum - 0.1),
	[440, 441], 0, 0.2) }.play;
)
a.free;

// iterate over the array and free it
b.do(_.free);
::

method:: read
Allocate a buffer and immediately read a soundfile into it. This method sends a query message as a completion message so that the Buffer's instance variables will be updated automatically.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
N.B. You cannot rely on the buffer's instance variables being instantly updated, as there is a small amount of latency involved. action will be evaluated upon receipt of the reply to the query, so use this in cases where access to instance variables is needed.
code::
// read a soundfile
s.boot;
p = Platform.resourceDir +/+ "sounds/a11wlk01.wav";
b = Buffer.read(s, p);

// now play it
(
x = SynthDef(\help_Buffer, { arg out = 0, bufnum;
    Out.ar( out,
	    PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum))
    )
}).play(s,[\bufnum, b]);
)
x.free; b.free;

// with an action function
// note that the vars are not immediately up-to-date
(
b = Buffer.read(s, p, action: { arg buffer;
    ("After update:" + buffer.numFrames).postln;
    x = { PlayBuf.ar(1, buffer, BufRateScale.kr(buffer)) }.play;
});
("Before update:" + b.numFrames).postln;
)
x.free; b.free;
::

method:: readChannel
As link::#*read:: above, but takes an link::Classes/Array:: of channel indices to read in, allowing one to read only the selected channels.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
code::
s.boot;
// first a standard read so we can see what's in the file
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff");
// Platform.resourceDir +/+ "sounds/SinedPink.aiff" contains SinOsc on left, PinkNoise on right
b.plot;
b.free;

// Now just the sine
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
b.plot;
b.free;

// Now just the pink noise
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1]);
b.plot;
b.free;

// Now reverse channel order
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1, 0]);
b.plot;
b.free;
::

method:: readNoUpdate
As link::#*read:: above, but without the automatic update of instance variables. Call code::updateInfo:: (see below) to update the vars.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
// with a completion message
s.boot;
(
SynthDef(\help_Buffer,{ arg out=0, bufnum;
	Out.ar( out,
		PlayBuf.ar(1,bufnum,BufRateScale.kr(bufnum))
	)
}).add;

y = Synth.basicNew(\help_Buffer); // not sent yet
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav",
	completionMessage: { arg buffer;
		// synth add its s_new msg to follow
		// after the buffer read completes
		y.newMsg(s,[\bufnum, buffer],\addToTail)
	});
)
// note vars not accurate
b.numFrames; // nil
b.updateInfo;
b.numFrames; // 188893
// when done...
y.free;
b.free;
::

method:: cueSoundFile
Allocate a buffer and preload a soundfile for streaming in using link::Classes/DiskIn::.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The frame of the soundfile that DiskIn will start playing at.
argument:: numChannels
The number of channels in the soundfile.
argument:: bufferSize
This must be a multiple of  (2 * the server's block size). 32768 is the default and is suitable for most cases.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
s.boot;
(
SynthDef(\help_Buffer_cue,{ arg out=0,bufnum;
	Out.ar(out,
		DiskIn.ar( 1, bufnum )
	)
}).add;
)

(
s.makeBundle(nil, {
	b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", 0, 1);
	y = Synth(\help_Buffer_cue, [\bufnum, b], s);
});
)
b.free; y.free;
::

method:: loadCollection
Load a large collection into a buffer on the server. Returns a Buffer object.
argument:: server
The server on which to create the buffer.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: numChannels
The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.

discussion::
This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use code::sendCollection::, below. The file is automatically deleted after loading. This allows for larger collections than setn, below, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
s.boot;
(
a = FloatArray.fill(44100 * 5.0, {1.0.rand2}); // 5 seconds of noise
b = Buffer.loadCollection(s, a);
)

// test it
b.get(20000,{|msg| (msg == a[20000]).postln});
// play it
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 0) * 0.5 }.play;
b.free; x.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.loadCollection(s, m, 2, {|buf|
	x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;
::

method:: sendCollection
Stream a large collection into a buffer on the server using multiple setn messages. Returns a Buffer object.
argument:: server
The server on which to create the buffer.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: numChannels
The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work. See the example in link::#*loadCollection:: above, to see how to do this.
argument:: wait
An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
This allows for larger collections than setn, below. This is not as safe as link::#*loadCollection:: above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) }); // a LARGE collection
b = Buffer.sendCollection(s, a, 1, 0, {arg buf; "finished".postln;});
)
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;
::

method:: loadDialog
As link::#*read:: above, but gives you a load dialog window to browse for a file. Cocoa compatible.
argument:: server
The server on which to allocate the buffer.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
code::
s.boot;
(
b = Buffer.loadDialog(s, action: { arg buffer;
	x = { PlayBuf.ar(buffer.numChannels, buffer, BufRateScale.kr(buffer)) }.play;
});
)
x.free; b.free;
::

subsection:: Creation without Immediate Memory Allocation
method:: new
Create and return a new Buffer object, without immediately allocating the corresponding memory on the server. This combined with 'message' methods can be flexible with bundles.
argument:: server
The server on which to allocate the buffer. The default is the default Server.
argument:: numFrames
The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.
argument:: numChannels
The number of channels for the Buffer. The default is 1.
argument:: bufnum
An explicitly specified buffer number. Supplying a number bypasses the server's buffer allocator, which can lead to conflicts. The best practice is to leave this unset and let the buffer number allocator choose the next available bufnum.
discussion::
code::
s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
c = Buffer.new(s, 44100 * 4.0, 2);
b.query; // numFrames = 0
s.sendBundle(nil, b.allocMsg, c.allocMsg); // sent both at the same time
b.query; // now it's right
c.query;
b.free; c.free;
::

subsection:: Cached Buffers

To assist with automatic updates of buffer information (see code::updateInfo:: and code::read::), buffer objects are cached in a collection associated with the link::Classes/Server:: object hosting the buffers.
Freeing a buffer removes it from the cache; quitting the server clears all the cached buffers. (This also occurs if the server crashes unexpectedly.)

You may access cached buffers using the following methods.

It may be simpler to access them through the server object:
code::
myServer.cachedBufferAt(bufnum)
myServer.cachedBuffersDo(func)

b = Buffer.alloc(s, 2048, 1);
Buffer.cachedBufferAt(s, 0);	// assuming b has bufnum 0
s.cachedBufferAt(0);			// same result
s.cachedBuffersDo({ |buf| buf.postln });
::

method:: cachedBufferAt
Access a buffer by its number.

method:: cachedBuffersDo
Iterate over all cached buffers. The iteration is not in any order, but will touch all buffers.


InstanceMethods::

subsection:: Variables

The following variables have getter methods.

method:: server
Returns the Buffer's Server object.

method:: bufnum
Returns the buffer number of the corresponding server-side buffer. In normal use you should not need to access this value, since instances of Buffer can be used directly as UGen inputs or Synth args.
discussion::
code::
s.boot;
b = Buffer.alloc(s,44100 * 8.0,2);
b.bufnum.postln;
b.free;
::

method:: numFrames
Returns the number of sample frames in the corresponding server-side buffer. Note that multichannel buffers interleave their samples, so when dealing with indices in methods like get and getn, the actual number of available values is numFrames * numChannels.

method:: numChannels
Returns the number of channels in the corresponding server-side buffer.

method:: sampleRate
Returns the sample rate of the corresponding server-side buffer.

Changing this value only changes what the buffer thinks its sample rate is. It does not resample the buffer's content.

method:: path
Returns a string containing the path of a soundfile that has been loaded into the corresponding server-side buffer.


subsection:: Explicit allocation

These methods allocate the necessary memory on the server for a Buffer previously created with link::#*new::.

method:: alloc, allocMsg
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
b.query; // numFrames = 0
b.alloc;
b.query; // numFrames = 352800
b.free;
::

method:: allocRead, allocReadMsg
Read a soundfile into a buffer on the server for a Buffer previously created with link::#*new::. Note that this will not autoupdate instance variables. Call code::updateInfo:: in order to do this.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file. (A floating-point value is truncated to integer.)
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file. (A floating-point value is truncated to integer.)
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
s.boot;
b = Buffer.new(s);
b.allocRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;
::

method:: allocReadChannel, allocReadChannelMsg
As link::#-allocRead:: above, but allows you to specify which channels to read.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file. (A floating-point value is truncated to integer.)
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file. (A floating-point value is truncated to integer.)
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided. If absent or an empty array all channels will be read from soundfile in order.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
s.boot;
b = Buffer.new(s);
// read only the first channel (a Sine wave) of a stereo file
b.allocReadChannel(Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;
::

subsection:: Other methods

method:: read
Read a soundfile into an already allocated buffer.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: fileStartFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file. (A floating-point value is truncated to integer.)
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file. (A floating-point value is truncated to integer.)
argument:: bufStartFrame
The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer. (A floating-point value is truncated to integer.)
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).
A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
method:: readMsg
	construct the message for a read command. args are like those for read,
	except that last arg is completionMessage.

discussion::
Note that if the number of frames in the file is greater than the number of frames in the buffer, it will be truncated. Note that readMsg will not auto-update instance variables. Call updateInfo in order to do this.

method:: readChannel
As link::#-read:: above, but allows you to specify which channels to read.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: fileStartFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file. (A floating-point value is truncated to integer.)
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file. (A floating-point value is truncated to integer.)
argument:: bufStartFrame
The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer. (A floating-point value is truncated to integer.)
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).
A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided. The number of channels requested must match this Buffer's numChannels.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: readChannelMsg
	as above for single channel, with last arg being completionMessage.

method:: cueSoundFile, cueSoundFileMsg
A convenience method to cue a soundfile into the buffer for use with a link::Classes/DiskIn::. The buffer must have been allocated with a multiple of (2 * the server's block size) frames.  A common size is 32768 frames.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file. (A floating-point value is truncated to integer.)
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
s.boot;
//create with cueSoundFile class method
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);
x = { DiskIn.ar(1, b) }.play;
b.close;	// must call close in between cueing
// now use like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// have to do all this to clean up properly!
x.free; b.close; b.free;
::

method:: write, writeMsg
Write the contents of the buffer to a file. See link::Classes/SoundFile:: for information on valid values for headerFormat and sampleFormat.
argument:: path
A String representing the path of the soundfile to be written.
If no path is given, Buffer writes into the default recording directory with a generic name.
argument:: headerFormat
A String.
argument:: sampleFormat
A String.
argument:: numFrames
The number of frames to write. The default is -1, which will write the whole buffer. (A floating-point value is truncated to integer.)
argument:: startFrame
The index of the frame in the buffer from which to start writing. The default is 0, which is the beginning of the buffer. (A floating-point value is truncated to integer.)
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskOut you will want this to be true. The default is false which is the correct value for all other cases.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: free, freeMsg
Release the buffer's memory on the server and return the bufferID back to the server's buffer number allocator for future reuse.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: zero, zeroMsg
Sets all values in this buffer to 0.0.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: set, setMsg
Set the value in the buffer at index to be equal to float. Additional pairs of indices and floats may be included in the same message. (Floating-point values for index are truncated to integer.)
discussion::
Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to code::numFrames * numChannels::. Indices start at 0.
code::
s.boot;
b = Buffer.alloc(s, 4, 2);
b.set(0, 0.2, 1, 0.3, 7, 0.4); // set the values at indices 0, 1, and 7.
b.getn(0, 8, {|msg| msg.postln});
b.free;
::

method:: setn, setnMsg
Set a contiguous range of values in the buffer starting at the index startAt to be equal to the Array of floats or integers, values. The number of values set corresponds to the size of values. Additional pairs of starting indices and arrays of values may be included in the same message. (Floating-point values for index are truncated to integer.)
discussion::
Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to code::numFrames * numChannels::. You are responsible for interleaving the data in values if needed. Multi-dimensional arrays will not work. Indices start at 0.

N.B. The maximum number of values that you can set with a single setn message is 1633 when the server is using UDP as its communication protocol. Use link::#-loadCollection:: and link::#-sendCollection:: to set larger ranges of values.
code::
s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0,1) }));
b.getn(0, b.numFrames, {|msg| msg.postln});
b.setn(0, [1, 2, 3], 4, [1, 2, 3]);
b.getn(0, b.numFrames, {|msg| msg.postln});
b.free;
::

method:: loadCollection
Load a large collection into this buffer. This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use sendCollection, below. The file is automatically deleted after loading.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: startFrame
The index of the frame at which to start loading the collection. The default is 0, which is the start of the buffer.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.

discussion::
This allows for larger collections than setn, above, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it was created.
The number of channels and frames will have been determined when the buffer was allocated. You are responsible for making sure that the size of collection is not greater than numFrames, and for interleaving any data if needed.
code::
s.boot;
(
v = Signal.sineFill(128, 1.0/[1,2,3,4,5,6]);
b = Buffer.alloc(s, 128);
)
(
b.loadCollection(v, action: {|buf|
	x = { PlayBuf.ar(buf.numChannels, buf, BufRateScale.kr(buf), loop: 1)
		* 0.2 }.play;
});
)
x.free; b.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.alloc(s, 16384, 2);
)
(
b.loadCollection(m, 0, {|buf|
	x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;
::

method:: sendCollection
Stream a large collection into this buffer using multiple setn messages.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: startFrame
The index of the frame at which to start streaming in the collection. The default is 0, which is the start of the buffer.
argument:: wait
An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
This allows for larger collections than setn. This is not as safe as loadCollection, above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) });
b = Buffer.alloc(s, 2000000);
)
b = b.sendCollection(a, action: {arg buf; "finished".postln;});
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;
::

method:: get, getMsg
Send a message requesting the value in the buffer at index. action is a Function which will be passed the value as an argument and evaluated when a reply is received. (Floating-point values for index are truncated to integer.)
discussion::
code::
s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0.0, 1.0) }));
b.get(0, {|msg| msg.postln});
b.free;
::

method:: getn, getnMsg
Send a message requesting the a contiguous range of values of size count starting from index. action is a Function which will be passed the values in an Array as an argument and evaluated when a reply is received. (Floating-point values for index and count are truncated to integer.)
discussion::
N.B. The maximum number of values that you can get with a single getn message is 1633 when the server is using UDP as its communication protocol. Use link::#-loadToFloatArray:: and link::#-getToFloatArray:: to get larger ranges of values.

method:: loadToFloatArray
Write the buffer to a file and then load it into a FloatArray.
argument:: index
The index in the buffer to begin writing from. The default is 0.
argument:: count
The number of values to write. The default is -1, which writes from index until the end of the  buffer.
argument:: action
A Function which will be passed the resulting FloatArray as an argument and evaluated when loading is finished.
discussion::
This is safer than getToFloatArray but only works with a server on your local machine. In general this is the safest way to get a large range of values from a server buffer into the client app.
code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// same as Buffer.plot
b.loadToFloatArray(action: { arg array; a = array; { a.plot }.defer; "done".postln });
b.free;
::

method:: getToFloatArray
Stream the buffer to the client using a series of getn messages and put the results into a FloatArray.
argument:: index
The index in the buffer to begin writing from. The default is 0. (A floating-point value is truncated to integer.)
argument:: count
The number of values to fetch. The default is -1, which gets from index until the end of the  buffer. (A floating-point value is truncated to integer.)
argument:: wait
The amount of time in seconds to wait between sending getn messages. Longer times are safer. The default is 0.01 seconds which seems reliable under normal circumstances. A setting of 0 is not recommended.
argument:: timeout
The amount of time in seconds after which to post a warning if all replies have not yet been received. the default is 3.
argument:: action
A Function which will be passed the resulting FloatArray as an argument and evaluated when all replies have been received.
discussion::
This is more risky than loadToFloatArray but does works with servers on remote machines. In high traffic situations it is possible for data to be lost. If this method has not received all its replies by timeout it will post a warning saying that the method has failed. In general use loadToFloatArray instead wherever possible.
code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// like Buffer.plot
b.getToFloatArray(wait:0.01,action:{arg array; a = array; { a.plot }.defer; "done".postln });
b.free;
::

method:: normalize, normalizeMsg
Normalizes the buffer so that the peak absolute value is newmax (which defaults to 1). If your buffer is in Wavetable format then set the asWavetable argument to true.

method:: fill, fillMsg
Starting at the index startAt, set the next numFrames to value. Additional ranges may be included in the same message. (Floating-point values for startAt or numFrames are truncated to integer.)

method:: copyData, copyMsg
Starting at the index srcStartAt, copy numSamples samples from this to the destination buffer buf starting at dstStartAt. If numSamples is negative, the maximum number of samples possible is copied. The default is start from 0 in the source and copy the maximum number possible starting at 0 in the destination. (Floating-point values for srcStartAt, numSamples and dstStartAt are truncated to integer.)

discussion::
Note: This method used to be called copy, but this conflicts with the method for object-copying. Therefore Buffer:copy is now intended to create a copy of the client-side Buffer object. Its use for copying buffer data on the server is deprecated. If you see a deprecation warning, the data will still be copied on the server and your code will still work, but you should update your code for the new method name.
code::
s.boot;
(
SynthDef(\help_Buffer_copy, {
	arg out = 0, buf;
	Line.ar(0, 0, dur: BufDur.kr(buf), doneAction: Done.freeSelf);
	Out.ar(out, PlayBuf.ar(1, buf));
}).add;
)

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
c = Buffer.alloc(s, 120000);
)

Synth(\help_Buffer_copy, [\buf, b]);

// copy the whole buffer
b.copyData(c);
Synth(\help_Buffer_copy, [\buf, c]);

// copy some samples
c.zero;
b.copyData(c, numSamples: 4410);
Synth(\help_Buffer_copy, [\buf, c]);

// buffer "compositing"
c.zero;
b.copyData(c, numSamples: 4410);
b.copyData(c, dstStartAt: 4410, numSamples: 15500);
Synth(\help_Buffer_copy, [\buf, c]);

b.free;
c.free;
::

method:: close, closeMsg
After using a Buffer with a DiskOut or DiskIn, it is necessary to close the soundfile. Failure to do so can cause problems.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: plot
Plot the contents of the Buffer in a GUI window.
argument:: name
The name of the resulting window.
argument:: bounds
An instance of Rect determining the size of the resulting view.
argument:: minval
the minimum value in the plot
argument:: maxval
the maximum value in the plot
argument:: separately
a boolean whether to use separate display ranges or a single shared range.
discussion::
code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.plot;
b.free;
::

method:: play
Plays the contents of the buffer on the server and returns a corresponding Synth.
argument:: loop
A Boolean indicating whether or not to loop playback. If false the synth will automatically be freed when done. The default is false.
argument:: mul
A value by which to scale the output. The default is 1.
discussion::
code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.play; // frees itself
x = b.play(true);
x.free; b.free;
::

method:: query
Sends a b_query message to the server, asking for a description of this buffer. The results are posted to the post window. Does not update instance vars.
argument:: action
An optional Function to be called which takes the arguments code::msgType, bufnum, numFrames, numChannels, sampleRate::. Providing a function here will bypass code::query::'s normal behaviour, i.e., the usual buffer information will not be posted.
method:: updateInfo
Sends a b_query message to the server, asking for a description of this buffer. Upon reply this Buffer's instance variables are automatically updated.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
code::
s.boot;
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.numFrames; // incorrect, shows nil
b.updateInfo({|buf| buf.numFrames.postln; }); // now it's right
b.free;
::

subsection:: Buffer Fill Commands
These correspond to the various b_gen OSC Commands, which fill the buffer with values for use. See link::Reference/Server-Command-Reference:: for more details.

method:: gen, genMsg
This is a generalized version of the commands below.
argument:: genCommand
A String indicating the name of the command to use. See Server-Command-Reference for a list of valid command names.
argument:: genArgs
An Array containing the corresponding arguments to the command.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.

method:: sine1, sine1Msg
Fill this buffer with a series of sine wave harmonics using specified amplitudes.
argument:: amps
An Array containing amplitudes for the harmonics. The first float value specifies the amplitude of the first partial, the second float value specifies the amplitude of the second partial, and so on.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
code::
s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0 / [1, 2, 3, 4], true, true, true);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;
::

method:: sine2, sine2Msg
Fill this buffer with a series of sine wave partials using specified frequencies and amplitudes.
argument:: freqs
An Array containing frequencies (in cycles per buffer) for the partials.
argument:: amps
An Array containing amplitudes for the partials. This should contain the same number of items as freqs.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
code::
s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine2([1.0, 3], [1, 0.5]);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;
::

method:: sine3, sine3Msg
Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases.
argument:: freqs
An Array containing frequencies (in cycles per buffer) for the partials.
argument:: amps
An Array containing amplitudes for the partials. This should contain the same number of items as freqs.
argument:: phases
An Array containing initial phase for the partials (in radians). This should contain the same number of items as freqs.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.

method:: cheby, chebyMsg
Fill this buffer with a series of Chebyshev polynomials, which can be defined as: code::cheby(n) = amplitude  * cos(n * acos(x))::. To eliminate a DC offset when used as a waveshaper, the wavetable is offset so that the center value is zero.

Similar functionality can be found in link::Classes/Signal#*chebyFill#Signal.chebyFill:: and link::Classes/Wavetable#*chebyFill#Wavetable.chebyFill::.  If you require Chebyshev polynomials that do not include the offset compensation, it is recommended to use one of these.
argument:: amps
An Array containing amplitudes for the harmonics. The first float value specifies the amplitude for n = 1, the second float value specifies the amplitude for n = 2, and so on.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
note::
In previous versions, offsetting (to ensure the center value is zero) was performed incorrectly.  This was fixed in version 3.7, so any code that may have relied on the (wrong) behavior may need to be changed.  If using a Chebyshev buffer as a waveshaper, the simplest fix is to wrap the link::Classes/Shaper:: in a link::Classes/LeakDC:: UGen.
::
code::
s.boot;
b = Buffer.alloc(s, 512, 1, {arg buf; buf.chebyMsg([1,0,1,1,0,1])});
(
x = {
	Shaper.ar(
		b,
		SinOsc.ar(300, 0, Line.kr(0,1,6)),
		0.5
	)
}.play;
)
x.free; b.free;
::


class:: Bus
summary:: Representation of a bus on the server
categories:: Server>Abstractions
related:: Classes/Server

description::
The clientside representation of an audio or control bus on a server.  Encapsulates all the link::Browse#OpenSoundControl#OSC:: messages a Bus can receive.  Manages allocation and deallocation of bus indices so that you don't need to worry about conflicts. The number of control busses, audio busses, and input and output busses is fixed and cannot be changed after the server has been booted.

For more information see link::Guides/ClientVsServer:: and link::Reference/Server-Architecture::.

Note that using the Bus class to allocate a multichannel bus does not 'create' a multichannel bus, but rather simply reserves a series of adjacent bus indices with the bus' link::Classes/Server:: object's bus allocators. code::abus.index:: simply returns the first of those indices. When using a Bus with an link::Classes/In:: or link::Classes/Out:: ugen there is nothing to stop you from reading to or writing from a larger range, or from hardcoding to a bus that has been allocated. You are responsible for making sure that the number of channels match and that there are no conflicts.

Bus objects should not be created or modified within a link::Classes/SynthDef::.

Note::
The lowest code::n:: bus indices are reserved for hardware output and input, where
code::
n = server.options.numOutputBusChannels + server.options.numInputBusChannels
::
definitionlist::
## Hardware output buses || code:: 0 .. (numOutputBusChannels - 1) ::
## Hardware input buses || code:: numOutputBusChannels .. (numOutputBusChannels + numInputBusChannels - 1) ::
## First private bus index || code:: numOutputBusChannels + numInputBusChannels ::
::
Do not try to use hardware I/O buses as private buses.
::

ClassMethods::

method:: control
Allocate a control bus on the server.

argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: audio
Allocate an audio bus on the server.

argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: alloc
Allocate a bus of either rate as specified by code::rate::.
argument:: rate
Rate symbol: \control or \audio
argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: new
This method does not allocate a bus index, but assumes that you
already have allocated the appropriate bus index and can supply it
yourself.

method:: newFrom
This method creates a new Bus that is a subset of the bus. The bus will be at the same rate as the input bus.
offset is the index into the given bus. numChannels is the desired number of channels.
If the combination of offset and numChannels is outside the input bus' range, an error will be thrown.

InstanceMethods::

method:: index
Get the Bus' index. Normally you should not need to do this since instances of Bus can be passed directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

method:: free
Return the bus' indices to the server's bus allocator so they can be reallocated.

method:: rate
Get the Bus' rate. This is a symbol, either \control or \audio.

method:: numChannels
Get the Bus' number of channels.

method:: server
Get the Bus' server object.

method:: asMap
Returns:: a symbol consisting of the letter 'c' or 'a' (for control or audio) followed by the bus's index. This may be used when setting a synth node's control inputs to map the input to the control bus.
discussion::
See the link::Classes/Node:: help file for more information on mapping controls to buses.
code::
(
a = Bus.control(s, 1).set(440);
b = Bus.control(s, 1).set(0.01);
)
(
SynthDef(\rlpf, { |out, ffreq, rq|
	Out.ar(out, RLPF.ar(WhiteNoise.ar(0.2), ffreq, rq))
}).play(s, [\ffreq, a.asMap, \rq, b.asMap]);
)
::

method:: subBus
Get a new Bus that is a subset of this bus (see code::newFrom::).

subsection:: Asynchronous Control Bus Methods

The following commands apply only to control buses and are asynchronous. For synchronous access to control busses please
consult link::#Synchronous Control Bus Methods::.

method:: value
Set all channels to this float value. This command is asynchronous.

method:: set
A list of values for each channel of the control bus.  The list of values supplied should not be greater than the number of channels. This command is asynchronous.

method:: setn
As set but takes an array as an argument.

method:: get
Get the current value of this control bus. This command is asynchronous.
argument:: action
a function that will be evaluated when the server responds, with the current value of the bus passed as an argument. This will be a float for a single channel bus, or an array of floats for a multichannel bus. The default action posts the bus values.


method:: getn
Get the current values of this control bus. This command is asynchronous.
argument:: count
the number of channels to read, starting from this bus' first channel.
argument:: action
a function that will be evaluated when the server responds, with the current values of the bus in an array passed as an argument.


subsection:: Synchronous Control Bus Methods

Synchronous access to control busses only works for servers with a shared memory interface. You can check with link::Classes/Server#-hasShmInterface#hasShmInterface:: if the server provides these methods.

note:: Before 3.5 the internal server could be controlled via shared control busses and link::Classes/SharedIn:: and
link::Classes/SharedOut::. These classes have been deprecated and will be removed.  ::

method:: getSynchronous
Get the current value of this control bus. This command is synchronous.

returns::
Value of the control bus.

method:: getnSynchronous
Get the current values of this control bus. This command is synchronous.
argument:: count
The number of channels to read, starting from this bus' first channel.
returns::
Array of values.

method:: setSynchronous
A list of values for each channel of the control bus.  The list of values supplied should not be greater than the number of channels. This command is synchronous.

method:: setnSynchronous
As setSynchronous but takes an array as an argument.


subsection:: Conveniences for multichannel buses
method:: setAt
set the bus value(s) beginning at offset. asynchronous.

method:: setnAt
set the bus to the list of values supplied. asynchronous.

method:: setPairs
set the bus values by pairs of index, value, ... asynchronous

subsection:: Using Buses like UGens

method:: kr, ar
use a bus like a UGen. The numChannels and offset arguments can be used to get a subset of the bus.
discussion::
By default, all the bus channels are used. E.g. in an 8 channel bus,
list::
## code::b.kr:: will return an link::Classes/In:: ugen reading from all the 8 channels of the bus;
## code::b.kr(4):: will return the first four channels, and
## code::b.kr(2, 5):: will return two channels, starting from the bus's channels at index 5 and 6.
::

subsection:: OSC Bundle Methods

method:: getMsg
Returns a msg of the type /c_get for use in osc bundles.

method:: getnMsg
Returns a msg of the type /c_getn for use in osc bundles.
argument:: count
the number of channels to read, starting from this bus' first channel. The default is this bus' numChannels.

method:: setMsg
Returns a msg of the type /c_set for use in osc bundles.

method:: setnMsg
Returns a msg of the type /c_setn for use in osc bundles.
argument:: values
an array of values to which adjacent channels should be set, starting at this bus' first channel.

method:: fillMsg
Returns a msg of the type /c_fill for use in osc bundles.
argument:: value
the value to which this bus' channels will be set.

subsection:: Monitoring with an oscilloscope

method:: scope
Displays a bus in a link::Classes/Stethoscope::, using the Bus' link::#-numChannels::, link::#-index::, and link::#-rate:: properties.
code::
s.boot
b=Bus.audio(s, 2);
a={SinOsc.ar([330,440], 0, 0.4)}.play(s, b) //you won't hear this if you only have two channels
b.scope

a.free;
b.free;
::

subsection:: Bela

method:: belaScope
Scope all channels from this Bus to Bela's Oscilloscope (see link::Classes/BelaScope:: for required setup).
It is required that this Bus is on Server running on a Bela, which is thus capable of using BelaScope.

argument:: scopeChannel
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

returns:: A link::Classes/Synth::, linking this Bus to BelaScope's bus.

Examples::
code::
s.boot;

(
// something to play with
SynthDef(\help_Bus, { arg out=0,ffreq=100;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
			ffreq, 0.1)
			.clip2(0.4);
	Out.ar(out, x);
}).add;

)

x = Synth(\help_Bus);

// get a bus
b = Bus.control(s);

// map the synth's second input (ffreq) to read
// from the bus' output index
x.map(1, b);

// By setting the bus' value you send a /c_fill message
// to each channel of the bus setting it to supplied float value
b.value = 100;
b.value = 1000;
b.value = 30;

// Since this is a single channel bus this has the same effect
b.set(300);
b.numChannels.postln;

// multi-channel:  b.set(300,350);
// Get the current value. This is asynchronous so you can't rely on it happening immediately.
(
a = "waiting";
b.get({arg value; a = value; ("after the server responds a is set to:" + a).postln;});
("a is now:" + a).postln;
)

x.free;

	// buses can also be used with kr or ar like UGens:
(

SynthDef(\help_Bus, { |out|
	var ffreq = b.kr;
	Out.ar(out,
		RLPF.ar(
			LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
			ffreq, 0.1
		).clip2(0.4)
	);
}).play;
)

b.free; // release it so it may be reallocated!


// using and setting multichannel buses:

(
b = Bus.control(s, 4);

x = SynthDef(\helpBusMulti, { |out|
	var freqs = b.kr;
	Out.ar(out, Splay.ar(SinOsc.ar(freqs) * Decay2.ar(Dust.ar(10 ! 4), 0.001, 0.1)) * 0.5);
}).play;
)

	// set bus beginning at index 0:
	// none of these methods checks whether the indexes remain
	// within the bus's range.

b.set(234, 345, 456, 567);
b.getn;
b.setn([100, 200, 300, 400]);
b.getn;

	// get to individual channels
b.setAt(3, 500);
b.getn;
b.setAt(1, 300, 400);
b.getn;
b.setnAt(1, [250, 350]);
b.getn;
	// set by pairs of index, value ...
b.setPairs(3, 600, 0, 200);
b.getn;

b.set(300, 500, 700, 900);

(	// just get the first 2 channels
x = SynthDef(\helpBusMulti, { |out|
	Out.ar(out, SinOsc.ar(b.kr(2)) * 0.2)
}).play;
)
b.set(300, 303);
x.free;

(	// just channels[[2, 3]];
y = SynthDef(\helpBusMulti, { |out|
	Out.ar(out, LFNoise2.ar(b.kr(2, 2)) * 0.2);
}).play;
)
b.setAt(2, 1200);
b.setAt(3, 2400);

y.free;
b.free;
::


class:: BusPlug
summary:: a listener on a bus
categories:: JITLib>NodeProxy, Live Coding
related:: Classes/Bus, Classes/Monitor, Classes/InBus, Classes/NodeProxy, Classes/Ndef

description::
A BusPlug is represents a listener on a private link::Classes/Bus:: that makes it easy to play back to multiple channels. It is mainly in use as a superclass of NodeProxy, but it can be used for general channel routings as well. Most methods are documented in the link::Classes/NodeProxy:: helpfile.

code::
s.boot;
z = Bus.control(s, 16);
z.setn({ |i| (i * 5).nthPrime } ! 16 * 5 + 100);
a = BusPlug.for(z);
{ Splay.ar(SinOsc.ar(a.kr(3, MouseX.kr(0, 25)))) * 0.1 }.play; // selectively play 3 channel of the 16, modulate offset
::

ClassMethods::



method::new
Create a new (neutral) instance on the given server.

method::for
Create an instance with a given link::Classes/Bus::.

method::audio
Create a new audio rate instance on the given server.

method::control
Create a new control rate instance on the given server.

method::defaultNumAudio
Default number of channels when initializing in audio rate and no specific number is given (default: 2).

method::defaultNumControl
Default number of channels when initializing in control rate and no specific number is given (default: 1).

method::defaultReshaping
default reshaping behaviour for BusPlug and its sublass NodeProxy. See: link::#-reshaping::

InstanceMethods::

private::makeBusArg, prepareForProxySynthDef, wakeUpToBundle, playNToBundle, playToBundle, newMonitorToBundle, clock

method::server
Return the server that the BusPlug runs on.

method::clear
Free the bus, end the monitor.


subsection::Making copies

method::copy
copies the hidden internal state to make the new BusPlug independent of the old, running on a new link::Classes/Bus::. By design, the link::Classes/Monitor:: is copied, but is not running (use play to start it in the same configuration). If needed, you can also copy the link::Classes/Monitor:: only (see: link::Classes/NodeProxy#-copy::).

method::copyState
Copy the internal settings of one proxy into another. Old state is cleared, the bus is freed.

argument::proxy
The object whose internal state is being copied.


method::reshaping
Determines how to behave when link::#-initBus:: is called.
Current options:
list::
## teletype::nil:: Once initialized, keep the same bus - this is the default
## teletype::\static:: Same as nil, but allows you to override the default in instances
## teletype::\elastic:: On a change, shrink and grow according to need, replace bus. Monitoring is adjusted.
## teletype::\expanding:: On a change, only grow according to need, replace bus. Monitoring is adjusted.
::

subsection::In UGen graphs and Patterns

method::ar, kr
Return a link to numChannels of my output. If uninitialized, creates a matching bus. Normally, strong::ar defaults to stereo, kr to mono::. This can be set in the classvars: link::#*defaultNumAudio::, link::#*defaultNumControl::

For consistency, it always returns an array of signals when no numChannels are given. To make it a single ugen output, use code::numChannels = 1:: . See also: link::Classes/InBus::.

argument::numChannels
Number of channels returned. If the receiver is neutral or reshaping is elastic, initialize it to this number. If this is more than the available channels, use the clip behaviour (below). If set to code::1::, it will return an instance of link::Classes/InBus::, otherwise an Array of one or more instances of InBus.

argument::offset
Channel offset when reading a bus that has more channels than numChannels, cross fading between adjacent channels.

argument::clip
If set to 'wrap', exceeding channels will wrap around, if set to 'clip', repeat the last one.


method::asUGenInput
Returns the appropriate output to read from the BusPlug bus (an link::Classes/InBus:: UGen)
code::
b = BusPlug.new;
{ Blip.ar(b + 5) }.play;
b.bus.set(12);
::

method::embedInStream
Returns the map argument for the bus, if the bus has multiple channels, it will return an array of map args.
code::
b = BusPlug.new;
x = Pbind(\z, b).asStream;
x.next(()); // returns the map argument for the bus
b.defineBus(\audio, 3);
x.next(()); // returns map arguments for the audio rate bus
::

method::asControlInput
Returns the map argument for the bus, just like link::#-embedInStream::

subsection::Monitoring and Routing

method::isPlaying
Returns true if server is running and bus not nil. link::Classes/NodeProxy:: this returns true if the group is playing.

method::isMonitoring
Returns true if monitor is playing

method::play
Play from a bus index with a number of channels to another index with a number of channels, within a link::Classes/Group:: (i.e. a target group or server).

argument::out
bus index

argument::numChannels
number of channels to output. If BusPlug is neutral or reshaping is elastic, initialize it to this number. If this is more than the available channels, wrap around. If this is not given, and reshaping is elastic, it will automatically expand.

argument::group
target link::Classes/Group:: or link::Classes/Server:: in which to play the monitor synths.

argument::multi
keep old playback links and add new one

argument::vol
overall volume  at which to monitor

argument::fadeTime
fade in / fade out time

argument:: addAction
Where in the node tree to play the monitor synths




method::playN
Play back on non-contiguous channels. See: link::Classes/Monitor:: and link::Reference/playN::

argument::outs
array of destination channels (or single value)


argument::amps
array of amplitudes for each channel (or single value)

argument::ins
array of source channel offsets within the bus (or single value)

argument:: vol
Overall volume (multiplied by amps)

argument:: fadeTime
array of fadeTimes (or single value) for fade in / fade out

argument:: group
target link::Classes/Group:: or link::Classes/Server:: in which to play the monitor synths.

argument:: addAction
Where in the node tree to play the monitor synths



method::stop
stop to play out public channels.

argument::fadeTime
decay time for this action

argument::reset
if set to true, reset all monitor state. Otherwise, the previous play arguments are kept.


method::monitor
returns the current monitor (see link::Classes/Monitor::)




subsection::Bus changes
These methods are a little numerous, because they are important for implementing link::Classes/NodeProxy:: behavior. Mostly the methods link::#-bus:: and link::#-initBus:: will be sufficient in normal use.

note::The old bus is freed when a new bus is made.::

method::isNeutral
Returns true if no bus has been initialized so far.

method::bus
Set or get the bus. If BusPlug monitor is playing, restart the monitor to adequately play back the new bus.

method::setBus
set the bus object by passing a link::Classes/Bus::.
note::you have to stop and play explicitly::

method::defineBus
make a new bus for the BusPlug with a given rate and number of channels.

method::initBus
Make a new bus only if necessary. This depends on the current bus and the link::#-reshaping:: mode.

returns::Boolean (true if successful).






Examples::

code::
// using as a control bus listener

s.boot;
z = Bus.control(s, 16);
a = BusPlug.for(z);

m = { Mix(SinOsc.ar(a.kr(16), 0, 0.1)) }.play;

z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));
z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));
z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));

m.free;


m = { SinOsc.ar(a.kr(2, MouseX.kr(0, 19)), 0, 0.1) }.play; // modulate channel offset

z.setn(Array.rand(16, 300, 1320).put(16.rand, rrand(500, 1000)));


m.free; z.free;

// using as a audio monitor

p = BusPlug.audio(s,2);
d = { Out.ar(p.index, PinkNoise.ar([0.1, 0.1])) }.play;


p.play; // monitor whatever plays in p (the execution order does not matter)



d.free;
d = { Out.ar(p.index, PinkNoise.ar([0.1, 0.1])) }.play;

p.stop;
p.play;

// also p can play to another bus:

p.stop;
p.play(12);

// listen to that bus for a test:
x = { InFeedback.ar(12,2) }.play;
x.free;
::


class:: Button
summary:: A multi-state button
categories:: GUI>Views

description::
A multi-state button.

subsection:: Some Important Issues Regarding Button

Failure to set any states at all results in an invisible button.

The button performs its action upon releasing the mouse. In musical contexts, you might want to use code::mouseDownAction_():: to set a function to be performed on pressing the mouse (see link::Classes/View::, and examples below).

If the drag contains a number, then code::valueAction_():: is performed using the code::currentDrag::. If the drag contains anything else, code::action:: is set to the current drag. You could, for example, drag a function to a Button, and action would then be set to that function.

classmethods::

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
discussion::
Example:
code::
(
w = Window.new("The Four Noble Truths");

b = Button(w, Rect(20, 20, 340, 30))
		.states_([
			["there is suffering", Color.black, Color.red],
			["the origin of suffering", Color.white, Color.black],
			["the cessation of suffering", Color.red, Color.white],
			["there is a path to cessation of suffering", Color.blue, Color.clear]
		])
		.action_({ arg butt;
			butt.value.postln;
		});
w.front;
)
::

instancemethods::

private::prDoAction

method:: states
An array of labels and colors defining the states of the button.
argument:: stateArray
An link::Classes/Array:: of arrays of the form code:: [ [String, strColor, bgColor] , .... ] ::

code::


(
w = Window.new;
a = Button(w, Rect(130, 130, 100, 100));
w.front;
)

// change the states:
a.states = [["yes", Color.grey, Color.white], ["no", Color.white, Color.grey]];
a.states = [["yes", Color.grey, Color.white], ["no", Color.white, Color.grey], ["perhaps", Color.black, Color.green(0.8)], []];

// change the states on action:
(
a.action = { |view|
	if(view.value == 3) { a.states =  [[["yes", "no"].choose, Color.grey, Color.white]] }
}
);
::

method:: value
Sets or returns the index of the current state. This will strong::not:: evaluate the function assigned to strong::action:: (see link::Classes/View::).
argument:: argVal
The index of an item in the states array.

method:: valueAction
Sets the button to display the item at index strong::anInt:: of the states array, and evaluates strong::action:: (see link::Classes/View::), if the value has changed.
argument:: anInt
The index of an item in the states array.

method:: string
Sets or gets the text of the currently active state.
code::
(
w = Window("but", Rect(300, 300, 200, 200)).front;
b = Button(w, Rect(30, 40, 140, 50));
b.string = "hello button";
)
::

method:: font
Sets the Font of the button. Default value is the default font: Font.default .
argument:: aFont
An instance of link::Classes/Font::.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: doAction
The method called by the primitive upon releasing the mouse.
argument:: modifiers
A key modifier number, which is passed to the strong::action:: as its second argument upon mouse-releasing the button.

method:: defaultKeyDownAction
discussion::
The default keydown actions are:
table::
## key || action || comment
## " " || value + 1 || space
## \r || value + 1
## \n || value + 1
## 3.asAscii || value + 1 || enter key or cmd-C on macOS
::
To change these use code::defaultKeyDownAction_::, see link::Classes/View::.

method:: properties
A list of properties to which this view responds. See link::Classes/View::.
returns::
[ \bounds, \visible, \enabled, \canFocus, \resize, \background, \minWidth, \maxWidth, \minHeight, \maxHeight, \value, \font, \states, \focusColor ]

method:: defaultGetDrag
The method called by default when initiating a drag strong::from:: a Button. Returns the same as link::#-value::.

method:: defaultCanReceiveDrag
The method called by default when attempting to drop a drag in this object. By default, Button will respond only to drags where the drag contains a link::Classes/Number:: or link::Classes/Function::.

method:: defaultReceiveDrag
The default method called when a drag has been received. If the drag contains a number, then action is set to the current drag. Otherwise code::valueAction_():: is performed using the code::currentDrag::.

examples::
code::
(
w = Window.new("Example");

b = Button(w, Rect(90, 20, 200, 30))
		.states_([
			["sine", Color.black, Color.rand],
			["saw", Color.black, Color.rand],
			["noise", Color.black, Color.rand],
			["pulse", Color.black, Color.rand]
		])
		.action_({ arg butt;
			butt.value.postln;
		});
w.front;
)

// does not do action
b.value = 2;

// does action if it results in a change of value
b.valueAction = 3;

// clips to size of states
b.valueAction = -1;

// floats no problem
b.valueAction = 3.3;
::

In a musical context, a button-down press is more meaningful than a button-up (release) as it's more intuitive to press a button on the beat. For that you can use link::Classes/View::'s link::Classes/View#-mouseDownAction:: (a superclass of Button).
code::
(
s.waitForBoot({
	w = Window.new;
	b = Button(w, Rect(20, 20, 80, 26))
			.states_([["play", Color.black, Color.rand]])
			.mouseDownAction_({
				a = {EnvGen.kr(Env.adsr, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.4)}.play;
			})
			.action_({ arg butt, mod;
				a.release(0.3);
			});
	w.front;
})
)
::


If you drag a function to a button, the button's action is set to that function. you can us this for swapping functions.
code::
(
s.waitForBoot({
	var w, p, snd, b;

	w = Window.new;

	b = Button(w, Rect(20, 20, 80, 26))
			.states_([["start a sound", Color.black, Color.green], ["stop", Color.black, Color.red]])
			.action_({});

	v = VLayoutView(w, Rect(140, 20, 200, 300)); //Group the following views
	StaticText(v, Rect(20, 20, 180, 60))
		.string_("The button does nothing at first, so try dragging a function to the button");

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { SinOsc.ar(440,0,0.6) }.play} { snd.free }; } //a button action function
			)
		.string_("a play sine function").align_(\center).background_(Color.rand);

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { Saw.ar(440,0.4) }.play} { snd.free }; } //a button action function
			)
		.string_("a play saw function").align_(\center).background_(Color.rand);

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { WhiteNoise.ar(0.4) }.play } { snd.free }; } //a button action function
			)
		.string_("a play noise function").align_(\center).background_(Color.rand);

	p = CmdPeriod.add({ b.value_(0) }); // set button to 0 on hitting Cmd-period
	w.onClose_{ snd.free; CmdPeriod.removeAll };//clean up when window is closed
	w.front;
})
)
::

Using Routine to set button states on the fly.
code::
(
var update, w, b;
	w = Window.new("State Window", Rect(150,Window.screenBounds.height - 140, 380, 60));

	// a convenient way to set the button label
	update = {
		|but, string| but.states = [[string.asString, Color.black, Color.red]];
		but.refresh;
	};

	b = Button(w, Rect(10, 10, 360, 40));
	b.font_(Font("Impact", 24));

	update.value(b, "there is only one state");

	// if an action should do something different each time it is called, a routine is the
	// right thing to use. This is better than creating variables outside and setting them
	// from the action function to keep state from one action to the next

	b.action_(Routine { |butt|
		rrand(15, 45).do { |i|
			update.value(butt, "%. there is still only 1 state".format(i + 2));
			0.yield; // stop here
		};
		w.close;
	});
	w.front;
)
::

Using Routine to set button states on the fly 2.
code::
(
s.waitForBoot({
	var update, w, b;

	w = Window.new("State Window", Rect(150, Window.screenBounds.height - 140, 380, 60));

	// a convenient way to set the button label
	update = { |but, string|
	but.states = [[string.asString, Color.black, Color.red]]; but.refresh };

	b = Button(w, Rect(10, 10, 360, 40));
	b.font_(Font("Impact", 24));

	update.value(b, "there is only one state");

	// if an action should do something different each time it is called, a routine is the
	// right thing to use. This is better than creating variables outside and setting them
	// from the action function to keep state from one action to the next

	b.action_(Routine { |butt|
		var synth, guessVal;

		update.value(butt, "there are only two states");
		0.yield; // stop here

		update.value(butt, "click me");
		0.yield; // stop here

		update.value(butt, "click me again");
		0.yield; // stop here ..

		// create a synth
		synth = { |freq = 1000, rate = 5|
			Ringz.ar(
				Impulse.ar(rate.lag(4) * [1,1.01]), freq, rrand(0.01, 0.1), 0.3
			)
		}.play;
		0.yield;

		guessVal = exprand(200.0, 18000).round;
		synth.set(\freq, guessVal); // set the synth
		update.value(butt, "?");
		0.yield;

		update.value(butt, guessVal.asString + "Hz"); // display frequency
		0.yield;

		synth.set(\rate, rrand(10, 50)); // set trigger rate
		// start an independent process
		fork({ 5.wait; synth.release; update.value(butt, "."); 1.wait; w.close }, AppClock);
	});
	CmdPeriod.doOnce({w.close});
	w.front;
});
)
::

Complex drag and drop example try dragging the buttons to white slot, and then between white slots, or simply out of the view.
code::
(
var w, f, slots;
var insert, remove;

slots = Dictionary.new;

remove = {arg slot, id;
	[slot, id].postln;
};

insert = {arg slot, fx;
	if(fx != ""){
		slots["slot"++slot].value_(0).states_([[fx, Color.white, Color.blue]]);
		[slot, fx].postln;
	}{
		slots["slot"++slot].value_(0).states_([["", Color.white, Color.white]]);
		remove.value(slot, fx);
	};
};

w = Window.new("",Rect(200, 400, 448, 180));
w.view.decorator = f = FlowLayout(w.view.bounds);

StaticText(w, 400@20).string_("Drag & Drop holding down Cmd-key");
f.nextLine;
6.do{arg i;
	var fxwin, winOpen = false, empty = ["", Color.white, Color.white];

	slots["slot" ++ i] = Button.new(w, 70@70)
		.states_([empty])
		.action_({|v|
			if((slots["slot" ++ i].states[0][0] != "") && ( winOpen == false)) {
				fxwin = Window(slots["slot" ++ i].states[0][0], Rect(rrand(0, 500),rrand(0, 500),200, 200)).front;
				fxwin.view.background_(Color.rand);
				fxwin.onClose_({ winOpen = false});
				winOpen = true
			} {
				if(winOpen == true) {
					fxwin.front
				}
			}; })
		.canReceiveDragHandler_({ View.currentDrag.isString })
		.receiveDragHandler_({ insert.value(i, View.currentDrag) })
		.beginDragAction_({
			var drag;
			drag = slots["slot" ++ i].states[0][0];
			slots["slot" ++ i].value_(0).states_([empty]);
			remove.value(i, View.currentDrag);
			drag; })
		.keyDownAction_({ arg view,char,modifiers,unicode,keycode;
			switch(keycode)
				{ 51 } {
					slots["slot"++i].value_(0).states_([empty]);
					slots["slot"++i].refresh;
					remove.value(i, View.currentDrag);
				}; });
};

f.nextLine;

["a", "b", "c", "d", "e", "f"].do{ arg item, i;
	Button.new(w, 70@70)
	.states_([ [ item ] ])
	.action_({ |v| })
	.beginDragAction_({item})
};
w.front;
)
::


class:: CCResponder
summary:: allow functions to be registered to respond to MIDI control change events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/NoteOnResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which controller number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::value
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next CC message, reset to match src, chan, cc num.
code::
(

c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
	});
	c.learn; // wait for the first controller
)
CCResponder.removeAll
::


Examples::

code::
(
	c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any CC number
		nil // any value
	)
)

c.remove
::

code::
(
	c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
		},
		nil, // any source
		nil, // any channel
		80, // CC number 80
		{ |val| val < 50 } // any value less than 50
	)
)

c.remove
::


class:: COsc
summary:: Chorusing wavetable oscillator.
related:: Classes/Osc, Classes/OscN, Classes/VOsc, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

Chorusing wavetable lookup oscillator. Produces sum of two signals at

code::
(freq ± (beats / 2)).
::

Due to summing, the peak amplitude is not the same as the wavetable and can be twice of that.


classmethods::

method::ar, kr

argument::bufnum

The number of a buffer filled in wavetable format.


argument::freq

Frequency in Hertz.


argument::beats

Beat frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

(
b = Buffer.alloc(s, 512, 1, {arg buf; buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])});
{ COsc.ar(b.bufnum, 200, 0.7, 0.25) }.play;
)

::



class:: CSVFileReader
summary:: file reader for comma separated data
related:: Classes/File
categories:: Files

description::
CSVFileReader reads comma-separated text files into 2D arrays line by line.

For tab delimited files use link::Classes/TabFileReader::. For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
(
// write a test file:
f = File("CSVReadTest.sc", "w");
f.write(
"Some,comma,delimited,items, in line 1

and then, some more, with several commas,,,, in line 3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = CSVFileReader.read("CSVReadTest.sc").postcs;

	// can skip empty lines:
x = CSVFileReader.read("CSVReadTest.sc", true).postcs;

	// can skip blank entries caused by multiple commas:
x = CSVFileReader.read("CSVReadTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("CSVReadTest.sc", "r"); f.isOpen;
t = CSVFileReader(f);
t.read(true, true).postcs;
f.close;

(
// write a test file with numbers:
f = File("CSVReadTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ ","); };
f.close;
)

x = CSVFileReader.read("CSVReadTestNum.sc", true, true).postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or do it immediately:
x = CSVFileReader.readInterpret("CSVReadTestNum.sc").postcs;

(
// write a test file with several lines of numbers:
f = File("CSVReadTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, ",", Char.nl)); };
f.close;
)


x = CSVFileReader.readInterpret("CSVReadTestNum.sc", true, true).postln;
::


TITLE:: CallOnce
summary:: execute a function (at most) once
categories::Streams-Patterns-Events
related:: Classes/EventStreamCleanup

DESCRIPTION::
Unlike a link::Classes/Thunk::, which takes no arguments, a CallOnce does allow arguments to be passed to the function it wraps, but the function is executed at most once. A CallOnce can also be "cancelled" with a code::clear:: call, without ever executing the wrapped function, even if CallOnce's code::value:: is called later.

The general contract for CallOnce is that any calls into the function after the first would do the same or less (cleanup) work as the first call did. Thus, subsequent calls are completely redundant and can be answered with the result from the first call, even if the arguments change on subsequent calls. Prototypical use case: if a cleanup is called with a code::releaseResource: false:: argument, e.g. because the resource was already released by link::Classes/CmdPeriod::, it is assumed that the cleanup will not be called later with a code::releaseResource: true:: argument.

Since it executes its function (at most) once, CallOnce is not a general-purpose function memoization facility for functions with arguments.

Basic example (see end of page for more):

code::
c = CallOnce { |flag| if(flag) { "woking...".postln; "done:" + flag } };
c.value(true);  // -> done: true (and posts "woking...")
c.value(false); // -> done: true (nothing posted)
::

CLASSMETHODS::

method::new

argument::function
a function that typically executes some cleanup and may return a desired value. The function is wrapped in the CallOnce for later execution.

INSTANCEMETHODS::

METHOD:: clear
Cancels the CallOnce, meaning that subsequent calls to code::value:: will not execute the wrapped function at all.
returns:: the CallOnce.

METHOD:: didEvaluate
Report if the CallOnce is considered already evaluated.
returns:: code::false:: if neither code::clear:: nor code::value:: were called previously; code::true:: otherwise.

METHOD:: value
If code::clear:: was called previously, the code::value:: call has no side-effect. Otherwise, on the first call to code::value:: the function wrapped by the CallOnce is evaluated with the arguments provided to code::value:: and the result of this evaluation is stored as the CallOnce's result, used to answer all subsequent calls to code::value::.

argument::  ... args
Arguments to use in the call to the wrapped function, if the call happens. If code::didEvaluate:: already returns code::true:: (before the current call to code::value::) then the current code::args:: are irrelevant because the wrapped function is not called anymore.

returns::
list::
## code::nil:: if code::clear:: was called on the CallOnce before any calls to code::value::, otherwise
## the value that was computed by the function (wrapped by the CallOnce) on the first call to CallOnce's code::value::
::
EXAMPLES::

code::
r = 1; // some resource
c = CallOnce {  r = r - 1; postln("Resource is now released:" + r); r };
c.didEvaluate; // -> false
c.value;       // -> 0 (and posts "Resource is now released: 0")
c.didEvaluate; // -> true
c.value;       // -> 0 (but posts nothing)
c.clear;       // even if is "cancelled" now
c.value;       // -> 0; the computed value is preserved

c = CallOnce { "not called".postln }
c.didEvaluate; // -> false
c.clear;       // "cancels" the cleanup
c.didEvaluate; // -> true
c.value;       // -> nil

// use with an argument
(
r = 1; // some resource
c = CallOnce { |releaseResource|
	if(releaseResource) {
		r = r - 1; "Resource is now released:" + r
	} {
		"nothing to do"
	}
};
)
d = c.copy // saved for later, separate execution state

// correct use sequence (non-increasing cleanup-work sequence):
c.value(true);
c.value(true);
c.value(false);
r; // -> 0

d.didEvaluate; // -> false (copy didn't evaluate yet)

// semantically incorrect (contract breaking) use sequence
d.value(false) // -> nothing to do
d.value(true)  // -> nothing to do
::






class:: Changed
categories:: UGens>Triggers, UGens>Filters>Linear
summary:: Triggers when a value changes

description::
Triggers when a value changes.

classmethods::
method:: ar, kr
A special case fixed filter.

argument:: input
signal input
argument:: threshold
threshold

discussion::
Implements the formula:
code::
out(i) = abs(in(i) - in(i-1)) > thresh
::

examples::

detect changes in a signal:
code::
(
{
	var changingSignal = LFNoise0.ar(1000);
	var changed = Changed.ar(changingSignal);
	[changingSignal, changed]
}.plot
);
::



class:: ChaosGen
summary:: UGens that cause chaos
categories:: UGens>Generators>Chaotic

description::
"ChaosGen" is an emphasis::abstract class:: - in other words, a class that you do not use directly. Instead, use one of its subclasses.
Various things inherit from this abstract class, including link::Classes/HenonN::, link::Classes/LinCongL::, link::Classes/LatoocarfianL::, link::Classes/GbmanL::, link::Classes/CuspL::, link::Classes/StandardL::, and more.

These chaotic UGens generally each represent a deterministic set of equations, which can take different starting parameters. The equations define a system whose evolution over time is highly sensitive to initial conditions, and can exhibit highly intricate behaviour.

To learn more, start here: http://en.wikipedia.org/wiki/Chaos_theory

To see all classes which derive from the ChaosGen class, run this line:

code::
ChaosGen.allSubclasses.do(_.postln)
::


class::Char
summary::ASCII character
related::Classes/String
categories:: Core

description::
An ASCII character represented as a signed 8-bit integer (-128 to 127).
Valid ASCII values are in the range 0-127.
Chars may be written as literals using the $ sign. For example: $a, $b, $c.
Some special characters can be expressed as literals using escape sequences (for example, code::$\n:: for newline).
See link::Reference/Literals#Characters:: for more information.

Chars may be created from link::Classes/Integer##Integers:: using the methods link::Classes/Integer#-asAscii:: and link::Classes/Integer#-asDigit::.

Note that, while Char does not support encodings aside from ASCII—such as
multi-byte encodings like UTF-8 and UTF-16, or the full Latin-1 (ISO 8859-1)
character set—Chars with negative values are perfectly legal, and may be strung
together in strings that use these encodings.

The SuperCollider IDE uses UTF-8 to decode and display strings.
See link::Classes/String:: for more information.

classmethods::

method::nl
Newline code::($\n)::.

method::ret
Carriage return code::($\r)::.

method::tab
Horizontal tab code::($\t)::.

method::ff
Form feed code::($\f)::.

method::vtab
Vertical tab code::($\v)::.

method::space
Single space code::($ )::.

method::comma
Comma code::($,)::.

method::bullet
Asterisk code::($*)::.

method::binaryOpCharacters
A string containing all characters allowed in a binary operator: code::"!@%&*-+=|<>?/"::.

instancemethods::
private:: archiveAsCompileString

subsection::conversion

method::ascii

returns:: the integer ASCII value of a Char.

method::digit

returns:: an integer value from 0 to 9 for chars $0 to $9, and values 10 to 35 for chars $a to $z
or $A to $Z.

method::toUpper

returns:: the upper case version of a char. Nonalphabetic chars return themselves.

method::toLower

returns:: a lower case version of a char. Nonalphabetic chars return themselves.

subsection:: Testing

method::isAlpha

returns:: whether the char is an alphabetic character.

method::isAlphaNum

returns:: whether the char is an alphabetic or numeric character.

method::isPrint

returns:: whether the char is printable.

method::isPunct

returns:: whether the char is a punctuation character.

method::isSpace

returns:: true if the char is white space: any of code::[$ , $\f, $\n, $\r, $\t, $\v]::.

method::isDecDigit

returns:: true if the char is a decimal digit $0 to $9.

method::isFileSafe

returns:: true if the char is safe for use in a filename.
Excludes the path separators / and :
discussion::
code::
 for(0,255,{ arg i;
	var a;
	[i,a = i.asAscii,a.isAlphaNum,a.isPrint,a.isPunct,a.isControl].postln;
});
::


class:: CheckBadValues
summary:: Test for infinity, not-a-number, and denormals
categories:: UGens>Info

description::
This link::Classes/UGen:: tests for infinity, NaN (not a number), and denormals. If one of these is found, it posts a warning. Its output is as follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 = a denormal.

classmethods::

method:: ar, kr
argument:: in
the link::Classes/UGen:: whose output is to be tested.
argument:: id
an id number to identify this link::Classes/UGen::. The default is 0.
argument:: post
One of three post modes:

list::
## 0 = no posting;
## 1 = post a line for every bad value;
## 2 = post a line only when the floating-point classification changes (e.g., normal -> NaN and vice versa)
::

The default post mode is 2. Post mode 1 is retained for backward compatibility; be aware that it generates a large amount of output.

examples::
code::
{ CheckBadValues.kr(SinOsc.ar); 0}.play // nothing wrong here

{ CheckBadValues.kr(1 / 0, 1).poll; 0 }.play // check infinity

x = { arg test = -1; CheckBadValues.kr(test); 0 }.play // check NaN
x.set(\test, -1.sqrt);

// don't post, but do something with the output
(
x = { arg freq = 440;
	var good;
	good = BinaryOpUGen('==', CheckBadValues.kr(freq, 0, 0), 0);
	SinOsc.ar(freq, 0, 0.1) * good // silence the output if freq is bad
}.play;
)
x.set(\freq, -1.sqrt);

// the UGen method checkBadValues passes through the input for quick testing
{ SinOsc.ar(440, 0, 0.1).checkBadValues }.play
::


CLASS:: CheckBox
summary:: A view that toggles between two states.
categories:: GUI>Views

DESCRIPTION::

A view that toggles between two states when clicked, displaying or hiding a check mark accordingly.

CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::



SUBSECTION:: Data



METHOD:: value
	Stating which of the two states the view is currently in, false meaning unchecked and true meaning checked. Default to false.

	argument::
		A Boolean.

METHOD:: valueAction
	Sets link::#-value:: and triggers link::#-action::.

	argument::
		A Boolean.

METHOD:: string
	The text displayed next to the check mark.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user toggles the state.



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Boolean.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.


EXAMPLES::

CODE::
(
var w = Window().front;
var c = CheckBox(w, Rect(10, 10, 50, 50), "test");
c.action_{ | v | v.value.postln };
)
::


class::Class
summary::A Class describes the structure and implementation of a set of objects which are its instances.
categories::Core>Kernel, Language>OOP
related:: Guides/WritingClasses, Reference/Classes

ClassMethods::
method:: allClasses
returns:: an link::Classes/Array:: of all Classes


method:: initClass

When SuperCollider starts up, just after it has compiled the library, it initializes all the classes from Object down, a depth first traversal of subclasses.

This method can be overloaded in any class that requires initialization of classvars or other resources.

note::
Each class will be initialized once, thus each class' code::initClass:: is called exactly once during the initialization phase.
::

method:: initClassTree

used in link::#*initClass:: to assure the initialisation of code::aClass:: before using it. Wherever necessary, it recursively initializes all classes required by code::aClass::.

In some cases it is required that another class and its resources are initialized before you initialize your own. This can be accomplished by


code::
YourClass {
    *initClass {
		// initialize OtherClass before continuing
        Class.initClassTree(OtherClass);

        ..

        // use OtherClass

        ..
    }

    ..

}
::

Pre-initialized data such as link::Classes/SynthDef::s should be deferred to link::Classes/StartUp::

code::
YourClass {
    *initClass {
        StartUp.add {
            ..
        }
    }

    ..

}
::

InstanceMethods::

method::browse

Open a graphical browser for this Class. Shows methods, arguments, variables, subclasses, and has buttons for navigating to the superclass, source, helpfile, etc.

method::findMethod

Find the Method referred to by name. If not found, return nil.

method::findRespondingMethodFor

As above, but climb the class tree to see if the method is inherited from a superclass. If not found, return nil.

method::dumpAllMethods

Post all instance methods which instances of this class responds too, including inherited ones. code::this.class.dumpAllMethods:: will post all class methods which this class responds to.

method::dumpByteCodes

Dump the byte codes of the named method.

method::dumpClassSubtree

Post the tree of all Classes that inherit from this class.

method::dumpInterface

Post all the methods defined by this Class and their arguments.

method::dumpFullInterface

Post all the class and instance methods that this class responds to (i.e. those defined in this class and those inherited by it).

method::help

Opens the help file for this Class if it exists.

method::helpFilePath

Returns the path of this Class's helpfile as a String.

method::helpFileForMethod

Opens the helpfile for the class in which the responding method is implemented.

code::
Array.helpFileForMethod('select'); // This will open the Collection helpfile
::

method::asClass

Return this.

method::asString

Return the name of the class as a String.


subsection:: Accessing

method::name

A Symbol that is the name of the class.

method::nextclass

The next class in a linked list of all classes.

method::superclass

The Class from which this class directly inherits.

method::superclasses

An Array of this class's superclasses, going back to Object.

method::subclasses

An Array of the direct subclasses of this.

method::allSubclasses

An Array of all subclasses of this.

method::methods

An Array of the methods of this class.

method::instVarNames

An Array of the names of the instance variables for this class.

method::classVarNames

An Array of the names of the class variables for this class.

method::iprototype

An Array of the initial values of instance variables.

method::cprototype

An Array of the initial values of class variables.

method::filenameSymbol

A Symbol which is a path to the file which defines the Class.



class:: Clip
summary:: Clip a signal outside given thresholds.
related:: Classes/Fold, Classes/Wrap
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#clip2#clip2:: in that it
allows one to set both low and high thresholds.


classmethods::

method::ar, kr

argument::in

Signal to be clipped.


argument::lo

Low threshold of clipping. Must be less then hi.


argument::hi

High threshold of clipping. Must be greater then lo.


Examples::

code::

s.boot;

{ Clip.ar(SinOsc.ar(440, 0, 0.2), -0.07, 0.07) }.scope;

::



class:: ClipNoise
summary:: Clip Noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose values are either -1 or 1. This produces
the maximum energy for the least peak to peak amplitude.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ ClipNoise.ar(0.2) }.play;
::



CLASS::Clock
categories::Scheduling>Clocks
summary::abstract superclass for clocks
related::Classes/AppClock, Classes/SystemClock, Classes/TempoClock

DESCRIPTION::
Clock is an abstract class: it only defines an abstract set of methods that
all clocks should implement. See its subclasses: link::Classes/SystemClock::,
link::Classes/TempoClock::, link::Classes/AppClock:: for specific
implementations.

subsection:: Scheduling

A Clock keeps track of time and allows strong::tasks:: to be
strong::scheduled:: for some time in the future (e.g. using
link::Classes/TempoClock#-sched#sched::,
link::Classes/TempoClock#-schedAbs#schedAbs:: or
link::Classes/TempoClock#-play#play:: methods).
A task can be any link::Classes/Object::. When the time at which a task was scheduled is up, the task is emphasis::awoken::, i.e. its
link::Classes/Object#-awake#awake:: method is evaluated. If the value returned by
this method is a number, the task is automatically strong::rescheduled:: for the
time equal to its last scheduled time plus the return value (in
link::Classes/TempoClock#-beats#beats::).

subsection:: Useful Tasks

Objects of different classes may do different things in response to being
scheduled on a clock by having own implementation of the code::awake:: method.
The link::Classes/Object#-awake:: method that all classes inherit simply
calls the same object's link::Classes/Object#-next#next:: method, forwarding the
code::beats:: argument as well as the return value, so subclasses may implement
either one to equivalent effect, as far as clock scheduling is concerned.
footnote:: However, note that the code::next:: method is also involved in the
concept of link::Tutorials/Streams-Patterns-Events1.html#Streams#streams::.::

Examples of useful objects to be scheduled on clocks:
list::
## link::Classes/Function#-awake:: method is implemented so as to call
the function's own link::Classes/Function#-value:: method, effectively running
the code within the function.
## link::Classes/Routine#-awake:: calls own link::Classes/Routine#-next::, in
turn starting or resuming the Routine's Function.
## Some subclasses of link::Classes/Stream:: will have its code::next:: method
do something useful aside from returning a new value in a stream.
::

subsection:: Scheduling and Threads

Whenever a task is awaken, its code::awake:: method is called in the context of
the link::Classes/Process#-mainThread#main thread::. Just before that, the main
thread's link::Classes/Thread#-beats#logical time:: is set to the scheduling
time of the awaken task, and its link::Classes/Thread#-clock#clock:: is set to
the scheduling clock. Note however that if the task is a link::Classes/Routine::
 it will then immediately start or resume its Function, setting itself as the
link::Classes/Thread#.thisThread#current thread::.



class:: CmdPeriod
summary:: register objects to be cleared when Cmd-. is pressed
related:: Classes/ShutDown, Classes/ServerQuit
categories:: Control

description::

CmdPeriod allows you to register objects to perform an action when the user presses Cmd-. These objects must implement a method called strong::-cmdPeriod:: which performs the necessary tasks. (You can add such a method in your custom classes.) Note that since link::Classes/Function:: implements strong::-cmdPeriod:: as a synonym for strong::-value::, it is possible to register any function (and thus any arbitrary code) for evaluation when Cmd-. is pressed.

ClassMethods::

method::add
Registers an object to be cleared when Cmd-. is pressed. This object will stay registered until it is explicitly removed, and will thus respond to additional presses of Cmd-.

method::remove
Removes an object that was previously registered.

method::removeAll
Removes all objects that have been registered.

method::doOnce
Registers an object to be evaluated once, and then unregistered.

method::objects
Get or set the list of objects that are called when CmdPeriod is evaluated.

method::era
The number of times CmdPeriod has been called since startup.

Examples::

code::
(
f = {"foo".postln };
g = {"bar".postln };
CmdPeriod.add(f);
CmdPeriod.add(g);
)

// Now press Cmd-.

CmdPeriod.remove(g);

// Now press Cmd-. Only f executes

CmdPeriod.remove(f); // must explicitly cleanup


// Now press Cmd-.

CmdPeriod.add(g); // one object is added only once.
CmdPeriod.add(g); // one object is added only once.


// Now press Cmd-.

// remove it again.
CmdPeriod.remove(g);


// note that often you want to automatically remove the function once it is evaluated
// instead of

f = { "foo".postln; CmdPeriod.remove(f) };
CmdPeriod.add(f);

// you can write:

CmdPeriod.doOnce { "foo".postln }

// a typical example:
(
w = Window.new("close on cmd-.").front;
CmdPeriod.doOnce { w.close };
)


// in some cases you might need to defer the function by a short amount of time
a = { Synth(\default)};
a.value;
CmdPeriod.add({{a.value}.defer(0.01)});

// remove all
CmdPeriod.removeAll

::


class:: CoinGate
summary:: Statistical gate.
categories::  UGens>Generators>Stochastic


Description::

When CoinGate receives a trigger, it tosses a coin
and either passes the trigger or doesn't.


classmethods::

method::ar, kr

argument::prob

Value between 0.0 and 1.0 determines probability of either possibilities.


argument::in
The trigger input.

Examples::

code::

(
a = SynthDef("help-TCoin", { arg out=0, prob=0.5;
	var trig;
	trig = CoinGate.kr(prob, Impulse.kr(10));
	Out.ar(out,
		SinOsc.ar(
			TRand.kr(300.0, 400.0, trig),0,0.2
		)
	)
}).play;
)

a.set(\prob, 1.0);
a.set(\prob, 0.0);
a.set(\prob, 0.1);


(
a = SynthDef("help-TCoin", { arg out=0, prob=0.5;
	var trig;
	trig = Impulse.ar(20, 0, SinOsc.kr(0.5,0,1,1));
	Out.ar(out,
		Mix.fill(3, {Ringz.ar(CoinGate.ar(prob, trig*0.5), #[1,1.5]*Rand(1000, 9000), 0.01)})
	)
}).play;
)

a.set(\prob, 1.0);
a.set(\prob, 0.0);
a.set(\prob, 0.1);

::


CLASS::Collection
summary::Abstract superclass of all collections
related::Classes/List, Classes/Array, Classes/Dictionary, Classes/Bag, Classes/Set, Classes/SortedList
categories::Collections

DESCRIPTION::
Collection is an abstract class. You do not create direct instances of Collection.
There are many types of Collections including link::Classes/List::, link::Classes/Array::, link::Classes/Dictionary::, link::Classes/Bag::, link::Classes/Set::, link::Classes/SortedList::, etc. See link::Overviews/Collections:: for a complete class tree.

CLASSMETHODS::

method::newFrom
Creates a new Collection from another collection. This supports the interface for the method "as".
code::
Array.newFrom(Set[4, 2, 1]);
Set.newFrom(Array[4, 2, 1]);
[1, 2, 3, 4, 3, 2].as(Set); // as(someClass) calls someClass.newFrom(this)
::

method::with
Creates a new Collection from the args.
code::
Array.with(4, 2, 1);
::

method::fill
Creates a Collection of the given size, the elements of which are determined by evaluation the given function. The function is passed the index as an argument.
code::
Array.fill(4, { arg i; i * 2 });
Bag.fill(14, { arg i; i.rand });
::

argument::size
The size of the collection which is returned. If nil, it returns an empty collection. If an array of sizes is given, the resulting collection has the appropriate dimensions (see: link::#*fillND).
::

code::
Array.fill([2, 2, 3], { arg i, j, k;  i * 100 + (j * 10) + k });
::

argument::function
The function which is called for each new element - the index is passed in as a first argument. The function be anything that responds to the message "value".

code::
Array.fill(10, { arg i; 2 ** i });
Array.fill(10, Pxrand([0, 1, 2], inf).iter);
Array.fill(10, 7); // an object that doesn't respond with a new value is just repeatedly added.
::

method::fill2D
Creates a 2 dimensional Collection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed row and column indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
Array.fill2D(2, 4, 0);
Array.fill2D(3, 4, { arg r, c; r*c+c; });
::

method::fill3D
Creates a 3 dimensional Collection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed plane, row and column indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
Array.fill3D(2, 3, 4, { arg p, r, c; p; });
::

method::fillND
Creates a N dimensional Collection where N is the size of the array strong::dimensions::. The items are determined by evaluation of the supplied function. The function is passed N number of indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
Array.fillND([4, 4], { arg a, b; a+b; });				// 2D
Array.fillND([4, 4, 4], { arg a, b, c; a+b*c; });		// 3D
Array.fillND([1, 2, 3, 4], { arg a, b, c, d; b+d; });	// 4D
::

INSTANCEMETHODS::

subsection::Accessing

method::size
Answers the number of objects contained in the Collection.
code::
List[1, 2, 3, 4].size;
::

method::isEmpty
Answer whether the receiver contains no objects.
code::
List[].isEmpty;
::


subsection::Adding and Removing

method::add
Add anObject to the receiver.
code::
List[1, 2].add(3);
::

method::addAll
Add all items in aCollection to the receiver.
code::
List[1, 2].addAll(List[3, 4]);
::

method::remove
Remove anObject from the receiver. Answers the removed object.
code::
(
var a;
a = List[1, 2, 3, 4];
a.remove(3);
a;
)
::

method::removeAll
Remove all items in aCollection from the receiver.
code::
List[1, 2, 3, 4].removeAll(List[2, 3]);
::
note::that multiple items in the receiver will not necessarily be removed
code::
~closet = [\hat, \hat, \hat, \coat, \coat, \shoe, \shoe];
~closet.removeAll([\hat, \coat, \shoe, \shoe]); // Doesn't empty the closet, just removes what we wanted to
::
See link::#-removeEvery:: for a related method that removes all occurrences.
::

method::removeEvery
Remove all occurrences of the items in aCollection from the receiver.
code::
List[1, 2, 3, 2, 3, 2, 3, 4].removeEvery(List[2, 3]);
::

method::removeAllSuchThat
Remove all items in the receiver for which function answers link::Classes/True::. The function is passed two arguments, the item and an integer index. Answers the objects which have been removed.
code::
(
var a;
a = List[1, 2, 3, 4];
a.removeAllSuchThat({ arg item, i; item < 3 });
a;
)
::

method::putEach
Put the values in the corresponding indices given by keys. If one of the two argument arrays is longer then it will wrap.
code::
y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
y.putEach([4, 7], [\smelly, \head]);
y.putEach([2, 3, 5, 6], \wotsits);
::

method::atAll
Return a collection of all the items for the keys.
code::
y = [\a, \b, \c];
y.atAll([0, 2]);
::

subsection::Testing

method::includes
Answer whether anObject is contained in the receiver.
code::
List[1, 2, 3, 4].includes(3);
::

method::includesEqual
Answer whether anObject is contained in the receiver. In contrast to link::#-includes:: this tests for equality - not identity.
code::
List["a", "b", "c"].includesEqual("c");  //true
List["a", "b", "c"].includes("c");       //false
List[ List[1, 2], List[3, 4] ].includesEqual(List[3, 4]);  //true
List[ List[1, 2], List[3, 4] ].includes(List[3, 4]);       //false
::

method::includesAny
Answer whether any item in aCollection is contained in the receiver.
code::
List[1, 2, 3, 4].includesAny(List[4, 5]);
::

method::includesAll
Answer whether all items in aCollection are contained in the receiver.
code::
List[1, 2, 3, 4].includesAll(List[4, 5]);
::

method::matchItem
Returns link::Classes/True:: if this includes the strong::item::.

See also link::Reference/matchItem::.


subsection::Iteration

method::do
Evaluates strong::function:: for each item in the collection. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].do({ arg item, i; item.postln });
::

method::collect
Answer a new collection which consists of the results of strong::function:: evaluated for each item in the collection. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].collect({ arg item, i; item + 10 });
::
If you want to control what type of collection is returned, use link::#-collectAs::(function, class).

method::select
Answer a new collection which consists of all items in the receiver for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].select({ arg item, i; item.even });
::
If you want to control what type of collection is returned, use link::#-selectAs::(function, class).

method::reject
Answer a new collection which consists of all items in the receiver for which strong::function:: answers link::Classes/False::. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].reject({ arg item, i; item.even });
::
If you want to control what type of collection is returned, use link::#-rejectAs::(function, class).

method::detect
Answer the first item in the receiver for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].detect({ arg item, i; item.even });
::

method::detectIndex
Similar to link::#-detect:: but returns the index instead of the item itself.
code::
List[1, 2, 3, 4].detectIndex({ arg item, i; item.even });
::

method::inject
In functional programming, the operation known as a left fold.
inject takes an initial value and a function and combines the elements of the collection by applying the function to the accumulated value and an element from the collection starting from the first element in the collection. The strong::function:: takes two arguments and returns the new value. The accumulated value is initialized to strong::initialValue::.
code::
[1,2,3,4,5].inject(0, _+_); // 15

[1,2,3,4,5].inject(1, _*_); // 120

// same as .collect(_.squared)
[1,2,3,4,5].inject([], {|a,b| a ++ b.squared }); // [ 1, 4, 9, 16, 25 ]
[1,2,3,4,5].inject([], {|a,b| [b] ++ a ++ [b]}); // [ 5, 4, 3, 2, 1, 1, 2, 3, 4, 5 ]
[1,2,3,4,5].inject([], {|a,b| a ++ b ++ a});
[1,2,3,4,5].inject([], {|a,b| a ++ a ++ b});
::

method::injectr
In functional programming, the operation known as a right fold.
inject takes an initial value and a function and combines the elements of the collection by applying the function to the accumulated value and an element from the collection starting from the last element in the collection. The strong::function:: takes two arguments and returns the new value. The accumulated value is initialized to strong::initialValue::.
code::
[1,2,3,4,5].injectr([], _++_); // [ 5, 4, 3, 2, 1 ]

[1,2,3,4,5].inject([], _++_); // [ 1, 2, 3, 4, 5 ]
::

method::collectInPlace
Iterate over the collection and replace each item with a new one, returned by the function. This can be useful when one wants to aviod creating a new array in memory. In most cases, it is better to use link::#-collect::.

code::
a = [1, 5, 3, 4];
a.collectInPlace { |x| 2 ** x };
a; // changed

// compare:
a = [1, 5, 3, 4];
a.collect { |x| 2 ** x };
a; // remains unchanged
::

method::collectCopy
Like link::#-collect::, but the collection is copied before iteration. This is recommended wherever the function may change the collection itself.

code::
a = [1, 5, 2, 3, 4];
b = a.collectCopy { |x| if(x.even) { a.remove(x); "removed" } { x }  };
a;
b;
::

method::any
Answer whether strong::function:: answers link::Classes/True:: for any item in the receiver. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].any({ arg item, i; item.even });
::

method::every
Answer whether strong::function:: answers link::Classes/True:: for every item in the receiver. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].every({ arg item, i; item.even });
::

method::count
Answer the number of items for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].count({ arg item, i; item.even });
::

method::occurrencesOf
Answer the number of items in the receiver which are equal to anObject.
code::
List[1, 2, 3, 3, 4, 3, 4, 3].occurrencesOf(3);
::

method::sum
Answer the sum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
code::
List[1, 2, 3, 4].sum;
(0..8).sum { |i| 1 / (2 ** i) };
::

method::maxItem
Answer the maximum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the maximum of all items in the receiver.
code::
List[1, 2, 3, 4].maxItem({ arg item, i; item + 10 });
::

method::minItem
Answer the minimum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the minimum of all items in the receiver.
code::
List[1, 2, 3, 4].minItem({ arg item, i; item + 10 });
::

method::maxIndex
Answer the index of the maximum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the maximum of all items in the receiver.
code::
List[1, 2, 3, 4].maxIndex({ arg item, i; item + 10 });
[3.2, 12.2, 13, 0.4].maxIndex;
::

method::minIndex
Answer the index of the minimum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the minimum of all items in the receiver.
code::
List[1, 2, 3, 4].minIndex({ arg item, i; item + 10 });
List[3.2, 12.2, 13, 0.4].minIndex;
::

method::maxSizeAtDepth
Returns the maximum size of all subcollections at a certain depth (dimension)

argument::rank
The depth at which the size of the collection is measured

code::
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(2);
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(1);
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(0);
Set[].maxSizeAtDepth(0);
Set[[]].maxSizeAtDepth(0);
Set[[]].maxSizeAtDepth(1);
::

method::maxDepth
Returns the maximum depth of all subcollections.

argument::max
Internally used only.

code::
Set[Set[1, 2, 3], Set[Set[41, 52], 5, 6], 1, 2, 3].maxDepth
::

method::iter
Returns a link::Classes/Routine:: that returns the elements one by one.
code::
r = Set[10, 2, -3, -4].iter;
r.next;
r.next;
r.next;
r.next; // nil.
::

subsection::Conversion

method::asBag
Answer a link::Classes/Bag:: to which all items in the receiver have been added.
code::
List[1, 2, 3, 4].asBag;
::

method::asList
Answer a link::Classes/List:: to which all items in the receiver have been added.
code::
Set[1, 2, 3, 4].asList;
::

method::asSet
Answer a link::Classes/Set:: to which all items in the receiver have been added.
code::
List[1, 2, 3, 4].asSet;
::

method::asSortedList
Answer a link::Classes/SortedList:: to which all items in the receiver have been added.
code::
List[2, 1, 4, 3].asSortedList;
::

method::asDict
Answer a corresponding dictionary. This is part of the link::Reference/Key-Value-Pairs:: interface.
argument::mergeFunc
Use this function to decide what to do with duplicate keys.
argument::class
The class of the dictionary to be returned. By default this is an link::Classes/IdentityDictionary::.

method::asAssociations
Answer an array of link::Classes/Association::s. If the first item of the list is already an associiation, return itself.  This is part of the link::Reference/Key-Value-Pairs:: interface.
argument::class
The class of the collection to be returned. By default this is an link::Classes/Array::.

method::asPairs
Answer an array with alternating key value pairs, like code::[\freq, 1848, \amp, 0.2]::. This is part of the link::Reference/Key-Value-Pairs:: interface.
argument::class
The class of the collection to be returned. By default this is an link::Classes/Array::.


method::asEvent
Answer an link::Classes/Event::: with the key value pairs. See link::Reference/Key-Value-Pairs::.


method::asDictWith
used internally by code::asDict::.


method::powerset
Returns all possible combinations of the collection's elements.
code::
Set[1, 2, 3].powerset;

// generate the von neumann ordinals. (warning: only count to four at maximum!)
a = Set[];
a = a.powerset;
a = a.powerset;
a = a.powerset;

u = { |set| set.unify }; // union (count down)
n = { |set| set.powerset }; // powerset (count up)
a = Set[]; // empty set (zero)
n.(n.(a)); // two
u.(n.(n.(a))) == n.(a); // two - one == one
u.(u.(n.(n.(a)))) == u.(n.(a)); // two - two == one - one
::

method::flopDict
Takes a collection of dictionaries and returns a single dictionary with arrays of all dictionaries' elements.
If unbubble is link::Classes/True:: (default), and if one element is singular, the array is replaced by this element.
code::
[(degree: 7, x: 4), (degree: 8, x: 5), (degree: -2, dur: 2.5)].flopDict;
[(degree: 7, x: 4), (degree: 8, x: 5), (degree: -2, dur: 2.5)].flopDict(false);
::

method::histo
Returns a histogram of the collection by counting the number of values that fall into each of the strong::steps:: subdivisions (default: 100) between strong::min:: and strong::max::.
If not provided, strong::min:: and strong::max:: default to the smallest and largest value in the collection, respectively.
If there are any values outside this range, it posts a note.

See also: link::Classes/Collection#-plotHisto::.

code::
{ 1.0.linrand }.dup(10000).histo(1000).plot(discrete: true);
::
code::
(
var data, steps = 15;
var minmax, range, binwidth;

data = { 15.0.rand + 3 }.dup(100);
minmax = [data.minItem, data.maxItem];
range = minmax[1] - minmax[0];
binwidth = range / steps;

data.histo(steps).plot(minval: 0)
.plotMode_(\steps)
.axisLabelY_("Occurrences")
.axisLabelX_("Bins")
.domainSpecs_(minmax.asSpec)
.domain_(binwidth * (0..steps-1) + data.minItem)
;
)
// or use Collection:-plotHisto for convenience
{ 15.0.rand + 3 }.dup(100).plotHisto(15);
::

method::invert
Subtractively invert a collection about a value (default: sum of minimal and maximum value).
It can be used to invert a pitch list about a given axis.
code::
[0, 1, 4, 7].invert(0);
[0, 1, 2, 3].invert(1);
[3, 2, 9, 7].invert(11); // becomes [ 19, 20, 13, 15 ]
// if axis is nil, invert uses the registral center
[3, 2, 9, 7].invert; // becomes [ 8, 9, 2, 4 ]
// invert chords
[[0, 5, 7], [5, 7, 11], [6, 7, 9]].invert(5);
::

subsection::Writing to streams

method::printOn
Print a representation of the collection to a stream.

method::storeOn
Write a compilable representation of the collection to a stream.

method::printItemsOn
Print a comma separated compilable representation of the items in the collection to a stream.

method::storeItemsOn
Write a comma separated compilable representation of the items in the collection to a stream.

subsection::Set specific operations

method::sect
Return the set theoretical intersection of this and strong::that::.
code::
a = [1, 2, 3]; b = [2, 3, 4, 5];
sect(a, b);
::

method::union
Return the set theoretical union of this and strong::that::.
code::
a = [1, 2, 3]; b = [2, 3, 4, 5];
union(a, b);
::

method::difference
Return the set of all items which are elements of this, but not of strong::that::.
code::
a = [1, 2, 3]; b = [2, 3, 4, 5];
difference(a, b);
::

method::symmetricDifference
Return the set of all items which are not elements of both  this and strong::that::.
this -- that
code::
a = [1, 2, 3]; b = [2, 3, 4, 5];
symmetricDifference(a, b);
::

method::isSubsetOf
Returns link::Classes/True:: if all elements of this are also elements of strong::that::
code::
a = Set[1, 2, 3, 4];
Set[1, 2].isSubsetOf(a); // true
Set[1, 5].isSubsetOf(a); // false
::


class:: Color
summary:: An object which stores color values
categories:: GUI>Accessories
related:: Classes/Object

description::
An object which stores red, green, blue, and alpha values in instance variables, and provides numerous class and instance methods for creating and manipulating these values.

classmethods::

method:: new
Create a new instance with float values.
argument:: red
An instance of link::Classes/Float:: between 0 and 1.
argument:: green
An instance of link::Classes/Float:: between 0 and 1.
argument:: blue
An instance of link::Classes/Float:: between 0 and 1.
argument:: alpha
An instance of link::Classes/Float:: between 0 and 1.

method:: new255
Create a new instance from 8-bit integer values between 0 and 255.
argument:: red
An instance of link::Classes/Integer:: between 0 and 255.
argument:: green
An link::Classes/Integer:: between 0 and 255.
argument:: blue
An link::Classes/Integer:: between 0 and 255.
argument:: alpha
An link::Classes/Integer:: between 0 and 255.

method:: fromArray
Same as code::Color.new(*array)::.
argument:: array
An instance of link::Classes/Array::. 1-4 values between 0 and 1. See link::#*new::.

method:: fromHexString
Creates a new instance from a hex color string.
argument:: string
A link::Classes/String::.
discussion::
The string should be a 6 character web color, or a 3 character CSS style color. A preceding # is optional.
code::
Color.fromHexString("#FF6600");
::

method:: black
Nothing is darker.

method:: white
Nothing is lighter.

method:: clear
Nothing is more clear.

method:: gray
American shades of grey.
argument:: gray
Shades between 0 (black) and 1 (white) as link::Classes/Float::.
argument:: alpha
Transparency of gray between 0 and 1 as link::Classes/Float::.

method:: grey
British shades of grey.
argument:: grey
Shades between 0 (black) and 1 (white) as link::Classes/Float::.
argument:: alpha
Transparency of grey between 0 and 1 as link::Classes/Float::.

method:: red, green, blue, cyan, magenta, yellow
Create a new red, green, blue, cyan, magenta or yellow Color.
argument:: val
An instance of link::Classes/Float:: between 0 and 1, where 1 is the bright, fully saturated color, and 0 is black.
argument:: alpha
Transparency between 0 and 1 as link::Classes/Float::.

method:: rand
A random RGB Color where the colors are randomly chosen between code::lo:: and code::hi::. See link::#*new::.
argument:: lo
An instance of link::Classes/Float:: between 0 and 1.
argument:: hi
An instance of link::Classes/Float:: between 0 and 1.

method:: hsv
Maps hsv and alpha values to rgb between 0 and 1.
argument:: hue
link::Classes/Float:: between 0 and 0.999.
argument:: sat
link::Classes/Float:: between 0 and 1.
argument:: val
link::Classes/Float:: between 0 and 1.
argument:: alpha
link::Classes/Float:: between 0 and 1.


instancemethods::
private:: printOn, hash

method:: red, green, blue, alpha
Get/set one of the instance variables, code::red::, code::green::, code::blue::, or code::alpha::.
returns::
An instance of link::Classes/Float:: between 0 and 1.

method:: hexString
Returns a link::Classes/String:: containing a 6 character web color code, preceded by a #.
code::
Color(1.0, 0.4).hexString;
::

method:: ==
Binary operator.
code::
// returns true
Color.new255(0, 0, 255, 255) == Color.new(0, 0, 1, 1)
::

method:: scaleByAlpha
Returns a Color, where code::red::, code::green::, and code::blue:: are scaled by the code::alpha:: value, and alpha is set to 1.
code::
// returns true:
Color(1, 0.5, 1, 0.5).scaleByAlpha == Color(0.5, 0.25, 0.5, 1)
::

method:: blend
Interpolates the code::red::, code::green::, code::blue::, and code::alpha:: values of two Colors, linearly weighting between the first and the second.
argument:: that
A second Color.
argument:: blend
0 means only this, while 1 means only that.

method:: vary
Returns a random variation of a Color.
argument:: val
Varies the RGB values +- this amount.
argument:: lo
Low-clips the RGB variation here.
argument:: hi
High-clips the RGB variation here.
argument:: alphaVal
Varies the alpha value +/- this amount, and clips it between 0 and 1.

method:: complementary
Returns the complementary color.
code::
// returns true:
Color(1, 0.5, 1, 0.5).complementary == Color(0.0, 0.5, 0.0, 0.5)
::

method:: multiply
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: divide
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: subtract
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: add
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: symmetricDifference
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: screen
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: lighten
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: darken
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: hueBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: saturationBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: valueBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: asHSV
Returns an array with code::[hue, saturation, value, alpha]::, as values between 0 and 1.

method:: asArray
Returns an array with code::[red, green, blue, alpha]::, as values between 0 and 1.

method:: storeArgs
Returns an array with code::[red, green, blue, alpha]::.

method:: setStroke
For use with link::Classes/Pen::. Sets the code::stroke:: of link::Classes/Pen:: to this.

method:: setFill
For use with link::Classes/Pen::. Sets the code::fill:: of link::Classes/Pen:: to this.

method:: set
For use with link::Classes/Pen::. Sets the code::stroke:: and code::fill:: of link::Classes/Pen:: to this.

method:: round
Round the color.

examples::
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	// set the Color
	Pen.translate(200, 200);
	30.do{
		Pen.width = 3.0.rand;
		Color.blue(rrand(0.0, 1), rrand(0.0, 0.5)).setStroke;
		Color.red(rrand(0.0, 1), rrand(0.0, 0.5)).setFill;
		Pen.addAnnularWedge(
			0@0,
			rrand(10, 50),
			rrand(51, 100),
			2pi.rand,
			2pi.rand
		);
		Pen.perform([\stroke, \fill].choose);
	}
};
w.refresh;
)
::

section:: X-windows colors
code::
'alice blue' -> Color.new255(240, 248, 255),
'AliceBlue' -> Color.new255(240, 248, 255),
'antique white' -> Color.new255(250, 235, 215),
'AntiqueWhite' -> Color.new255(250, 235, 215),
'AntiqueWhite1' -> Color.new255(255, 239, 219),
'AntiqueWhite2' -> Color.new255(238, 223, 204),
'AntiqueWhite3' -> Color.new255(205, 192, 176),
'AntiqueWhite4' -> Color.new255(139, 131, 120),
'aquamarine' -> Color.new255(127, 255, 212),
'aquamarine1' -> Color.new255(127, 255, 212),
'aquamarine2' -> Color.new255(118, 238, 198),
'aquamarine3' -> Color.new255(102, 205, 170),
'aquamarine4' -> Color.new255(69, 139, 116),
'azure' -> Color.new255(240, 255, 255),
'azure1' -> Color.new255(240, 255, 255),
'azure2' -> Color.new255(224, 238, 238),
'azure3' -> Color.new255(193, 205, 205),
'azure4' -> Color.new255(131, 139, 139),
'beige' -> Color.new255(245, 245, 220),
'bisque' -> Color.new255(255, 228, 196),
'bisque1' -> Color.new255(255, 228, 196),
'bisque2' -> Color.new255(238, 213, 183),
'bisque3' -> Color.new255(205, 183, 158),
'bisque4' -> Color.new255(139, 125, 107),
'black' -> Color.new255(0, 0, 0),
'blanched almond' -> Color.new255(255, 235, 205),
'BlanchedAlmond' -> Color.new255(255, 235, 205),
'blue' -> Color.new255(0, 0, 255),
'blue violet' -> Color.new255(138, 43, 226),
'blue1' -> Color.new255(0, 0, 255),
'blue2' -> Color.new255(0, 0, 238),
'blue3' -> Color.new255(0, 0, 205),
'blue4' -> Color.new255(0, 0, 139),
'BlueViolet' -> Color.new255(138, 43, 226),
'brown' -> Color.new255(165, 42, 42),
'brown1' -> Color.new255(255, 64, 64),
'brown2' -> Color.new255(238, 59, 59),
'brown3' -> Color.new255(205, 51, 51),
'brown4' -> Color.new255(139, 35, 35),
'burlywood' -> Color.new255(222, 184, 135),
'burlywood1' -> Color.new255(255, 211, 155),
'burlywood2' -> Color.new255(238, 197, 145),
'burlywood3' -> Color.new255(205, 170, 125),
'burlywood4' -> Color.new255(139, 115, 85),
'cadet blue' -> Color.new255(95, 158, 160),
'CadetBlue' -> Color.new255(95, 158, 160),
'CadetBlue1' -> Color.new255(152, 245, 255),
'CadetBlue2' -> Color.new255(142, 229, 238),
'CadetBlue3' -> Color.new255(122, 197, 205),
'CadetBlue4' -> Color.new255(83, 134, 139),
'chartreuse' -> Color.new255(127, 255, 0),
'chartreuse1' -> Color.new255(127, 255, 0),
'chartreuse2' -> Color.new255(118, 238, 0),
'chartreuse3' -> Color.new255(102, 205, 0),
'chartreuse4' -> Color.new255(69, 139, 0),
'chocolate' -> Color.new255(210, 105, 30),
'chocolate1' -> Color.new255(255, 127, 36),
'chocolate2' -> Color.new255(238, 118, 33),
'chocolate3' -> Color.new255(205, 102, 29),
'chocolate4' -> Color.new255(139, 69, 19),
'coral' -> Color.new255(255, 127, 80),
'coral1' -> Color.new255(255, 114, 86),
'coral2' -> Color.new255(238, 106, 80),
'coral3' -> Color.new255(205, 91, 69),
'coral4' -> Color.new255(139, 62, 47),
'cornflower blue' -> Color.new255(100, 149, 237),
'CornflowerBlue' -> Color.new255(100, 149, 237),
'cornsilk' -> Color.new255(255, 248, 220),
'cornsilk1' -> Color.new255(255, 248, 220),
'cornsilk2' -> Color.new255(238, 232, 205),
'cornsilk3' -> Color.new255(205, 200, 177),
'cornsilk4' -> Color.new255(139, 136, 120),
'cyan' -> Color.new255(0, 255, 255),
'cyan1' -> Color.new255(0, 255, 255),
'cyan2' -> Color.new255(0, 238, 238),
'cyan3' -> Color.new255(0, 205, 205),
'cyan4' -> Color.new255(0, 139, 139),
'dark goldenrod' -> Color.new255(184, 134, 11),
'dark green' -> Color.new255(0, 100, 0),
'dark khaki' -> Color.new255(189, 183, 107),
'dark olive green' -> Color.new255(85, 107, 47),
'dark orange' -> Color.new255(255, 140, 0),
'dark orchid' -> Color.new255(153, 50, 204),
'dark salmon' -> Color.new255(233, 150, 122),
'dark sea green' -> Color.new255(143, 188, 143),
'dark slate blue' -> Color.new255(72, 61, 139),
'dark slate gray' -> Color.new255(47, 79, 79),
'dark slate grey' -> Color.new255(47, 79, 79),
'dark turquoise' -> Color.new255(0, 206, 209),
'dark violet' -> Color.new255(148, 0, 211),
'DarkGoldenrod' -> Color.new255(184, 134, 11),
'DarkGoldenrod1' -> Color.new255(255, 185, 15),
'DarkGoldenrod2' -> Color.new255(238, 173, 14),
'DarkGoldenrod3' -> Color.new255(205, 149, 12),
'DarkGoldenrod4' -> Color.new255(139, 101, 8),
'DarkGreen' -> Color.new255(0, 100, 0),
'DarkKhaki' -> Color.new255(189, 183, 107),
'DarkOliveGreen' -> Color.new255(85, 107, 47),
'DarkOliveGreen1' -> Color.new255(202, 255, 112),
'DarkOliveGreen2' -> Color.new255(188, 238, 104),
'DarkOliveGreen3' -> Color.new255(162, 205, 90),
'DarkOliveGreen4' -> Color.new255(110, 139, 61),
'DarkOrange' -> Color.new255(255, 140, 0),
'DarkOrange1' -> Color.new255(255, 127, 0),
'DarkOrange2' -> Color.new255(238, 118, 0),
'DarkOrange3' -> Color.new255(205, 102, 0),
'DarkOrange4' -> Color.new255(139, 69, 0),
'DarkOrchid' -> Color.new255(153, 50, 204),
'DarkOrchid1' -> Color.new255(191, 62, 255),
'DarkOrchid2' -> Color.new255(178, 58, 238),
'DarkOrchid3' -> Color.new255(154, 50, 205),
'DarkOrchid4' -> Color.new255(104, 34, 139),
'DarkSalmon' -> Color.new255(233, 150, 122),
'DarkSeaGreen' -> Color.new255(143, 188, 143),
'DarkSeaGreen1' -> Color.new255(193, 255, 193),
'DarkSeaGreen2' -> Color.new255(180, 238, 180),
'DarkSeaGreen3' -> Color.new255(155, 205, 155),
'DarkSeaGreen4' -> Color.new255(105, 139, 105),
'DarkSlateBlue' -> Color.new255(72, 61, 139),
'DarkSlateGray' -> Color.new255(47, 79, 79),
'DarkSlateGray1' -> Color.new255(151, 255, 255),
'DarkSlateGray2' -> Color.new255(141, 238, 238),
'DarkSlateGray3' -> Color.new255(121, 205, 205),
'DarkSlateGray4' -> Color.new255(82, 139, 139),
'DarkSlateGrey' -> Color.new255(47, 79, 79),
'DarkTurquoise' -> Color.new255(0, 206, 209),
'DarkViolet' -> Color.new255(148, 0, 211),
'deep pink' -> Color.new255(255, 20, 147),
'deep sky blue' -> Color.new255(0, 191, 255),
'DeepPink' -> Color.new255(255, 20, 147),
'DeepPink1' -> Color.new255(255, 20, 147),
'DeepPink2' -> Color.new255(238, 18, 137),
'DeepPink3' -> Color.new255(205, 16, 118),
'DeepPink4' -> Color.new255(139, 10, 80),
'DeepSkyBlue' -> Color.new255(0, 191, 255),
'DeepSkyBlue1' -> Color.new255(0, 191, 255),
'DeepSkyBlue2' -> Color.new255(0, 178, 238),
'DeepSkyBlue3' -> Color.new255(0, 154, 205),
'DeepSkyBlue4' -> Color.new255(0, 104, 139),
'dim gray' -> Color.new255(105, 105, 105),
'dim grey' -> Color.new255(105, 105, 105),
'DimGray' -> Color.new255(105, 105, 105),
'DimGrey' -> Color.new255(105, 105, 105),
'dodger blue' -> Color.new255(30, 144, 255),
'DodgerBlue' -> Color.new255(30, 144, 255),
'DodgerBlue1' -> Color.new255(30, 144, 255),
'DodgerBlue2' -> Color.new255(28, 134, 238),
'DodgerBlue3' -> Color.new255(24, 116, 205),
'DodgerBlue4' -> Color.new255(16, 78, 139),
'firebrick' -> Color.new255(178, 34, 34),
'firebrick1' -> Color.new255(255, 48, 48),
'firebrick2' -> Color.new255(238, 44, 44),
'firebrick3' -> Color.new255(205, 38, 38),
'firebrick4' -> Color.new255(139, 26, 26),
'floral white' -> Color.new255(255, 250, 240),
'FloralWhite' -> Color.new255(255, 250, 240),
'forest green' -> Color.new255(34, 139, 34),
'ForestGreen' -> Color.new255(34, 139, 34),
'gainsboro' -> Color.new255(220, 220, 220),
'ghost white' -> Color.new255(248, 248, 255),
'GhostWhite' -> Color.new255(248, 248, 255),
'gold' -> Color.new255(255, 215, 0),
'gold1' -> Color.new255(255, 215, 0),
'gold2' -> Color.new255(238, 201, 0),
'gold3' -> Color.new255(205, 173, 0),
'gold4' -> Color.new255(139, 117, 0),
'goldenrod' -> Color.new255(218, 165, 32),
'goldenrod1' -> Color.new255(255, 193, 37),
'goldenrod2' -> Color.new255(238, 180, 34),
'goldenrod3' -> Color.new255(205, 155, 29),
'goldenrod4' -> Color.new255(139, 105, 20),
'gray' -> Color.new255(190, 190, 190),
'gray0' -> Color.new255(0, 0, 0),
'gray1' -> Color.new255(3, 3, 3),
'gray10' -> Color.new255(26, 26, 26),
'gray100' -> Color.new255(255, 255, 255),
'gray11' -> Color.new255(28, 28, 28),
'gray12' -> Color.new255(31, 31, 31),
'gray13' -> Color.new255(33, 33, 33),
'gray14' -> Color.new255(36, 36, 36),
'gray15' -> Color.new255(38, 38, 38),
'gray16' -> Color.new255(41, 41, 41),
'gray17' -> Color.new255(43, 43, 43),
'gray18' -> Color.new255(46, 46, 46),
'gray19' -> Color.new255(48, 48, 48),
'gray2' -> Color.new255(5, 5, 5),
'gray20' -> Color.new255(51, 51, 51),
'gray21' -> Color.new255(54, 54, 54),
'gray22' -> Color.new255(56, 56, 56),
'gray23' -> Color.new255(59, 59, 59),
'gray24' -> Color.new255(61, 61, 61),
'gray25' -> Color.new255(64, 64, 64),
'gray26' -> Color.new255(66, 66, 66),
'gray27' -> Color.new255(69, 69, 69),
'gray28' -> Color.new255(71, 71, 71),
'gray29' -> Color.new255(74, 74, 74),
'gray3' -> Color.new255(8, 8, 8),
'gray30' -> Color.new255(77, 77, 77),
'gray31' -> Color.new255(79, 79, 79),
'gray32' -> Color.new255(82, 82, 82),
'gray33' -> Color.new255(84, 84, 84),
'gray34' -> Color.new255(87, 87, 87),
'gray35' -> Color.new255(89, 89, 89),
'gray36' -> Color.new255(92, 92, 92),
'gray37' -> Color.new255(94, 94, 94),
'gray38' -> Color.new255(97, 97, 97),
'gray39' -> Color.new255(99, 99, 99),
'gray4' -> Color.new255(10, 10, 10),
'gray40' -> Color.new255(102, 102, 102),
'gray41' -> Color.new255(105, 105, 105),
'gray42' -> Color.new255(107, 107, 107),
'gray43' -> Color.new255(110, 110, 110),
'gray44' -> Color.new255(112, 112, 112),
'gray45' -> Color.new255(115, 115, 115),
'gray46' -> Color.new255(117, 117, 117),
'gray47' -> Color.new255(120, 120, 120),
'gray48' -> Color.new255(122, 122, 122),
'gray49' -> Color.new255(125, 125, 125),
'gray5' -> Color.new255(13, 13, 13),
'gray50' -> Color.new255(127, 127, 127),
'gray51' -> Color.new255(130, 130, 130),
'gray52' -> Color.new255(133, 133, 133),
'gray53' -> Color.new255(135, 135, 135),
'gray54' -> Color.new255(138, 138, 138),
'gray55' -> Color.new255(140, 140, 140),
'gray56' -> Color.new255(143, 143, 143),
'gray57' -> Color.new255(145, 145, 145),
'gray58' -> Color.new255(148, 148, 148),
'gray59' -> Color.new255(150, 150, 150),
'gray6' -> Color.new255(15, 15, 15),
'gray60' -> Color.new255(153, 153, 153),
'gray61' -> Color.new255(156, 156, 156),
'gray62' -> Color.new255(158, 158, 158),
'gray63' -> Color.new255(161, 161, 161),
'gray64' -> Color.new255(163, 163, 163),
'gray65' -> Color.new255(166, 166, 166),
'gray66' -> Color.new255(168, 168, 168),
'gray67' -> Color.new255(171, 171, 171),
'gray68' -> Color.new255(173, 173, 173),
'gray69' -> Color.new255(176, 176, 176),
'gray7' -> Color.new255(18, 18, 18),
'gray70' -> Color.new255(179, 179, 179),
'gray71' -> Color.new255(181, 181, 181),
'gray72' -> Color.new255(184, 184, 184),
'gray73' -> Color.new255(186, 186, 186),
'gray74' -> Color.new255(189, 189, 189),
'gray75' -> Color.new255(191, 191, 191),
'gray76' -> Color.new255(194, 194, 194),
'gray77' -> Color.new255(196, 196, 196),
'gray78' -> Color.new255(199, 199, 199),
'gray79' -> Color.new255(201, 201, 201),
'gray8' -> Color.new255(20, 20, 20),
'gray80' -> Color.new255(204, 204, 204),
'gray81' -> Color.new255(207, 207, 207),
'gray82' -> Color.new255(209, 209, 209),
'gray83' -> Color.new255(212, 212, 212),
'gray84' -> Color.new255(214, 214, 214),
'gray85' -> Color.new255(217, 217, 217),
'gray86' -> Color.new255(219, 219, 219),
'gray87' -> Color.new255(222, 222, 222),
'gray88' -> Color.new255(224, 224, 224),
'gray89' -> Color.new255(227, 227, 227),
'gray9' -> Color.new255(23, 23, 23),
'gray90' -> Color.new255(229, 229, 229),
'gray91' -> Color.new255(232, 232, 232),
'gray92' -> Color.new255(235, 235, 235),
'gray93' -> Color.new255(237, 237, 237),
'gray94' -> Color.new255(240, 240, 240),
'gray95' -> Color.new255(242, 242, 242),
'gray96' -> Color.new255(245, 245, 245),
'gray97' -> Color.new255(247, 247, 247),
'gray98' -> Color.new255(250, 250, 250),
'gray99' -> Color.new255(252, 252, 252),
'green' -> Color.new255(0, 255, 0),
'green yellow' -> Color.new255(173, 255, 47),
'green1' -> Color.new255(0, 255, 0),
'green2' -> Color.new255(0, 238, 0),
'green3' -> Color.new255(0, 205, 0),
'green4' -> Color.new255(0, 139, 0),
'GreenYellow' -> Color.new255(173, 255, 47),
'grey' -> Color.new255(190, 190, 190),
'grey0' -> Color.new255(0, 0, 0),
'grey1' -> Color.new255(3, 3, 3),
'grey10' -> Color.new255(26, 26, 26),
'grey100' -> Color.new255(255, 255, 255),
'grey11' -> Color.new255(28, 28, 28),
'grey12' -> Color.new255(31, 31, 31),
'grey13' -> Color.new255(33, 33, 33),
'grey14' -> Color.new255(36, 36, 36),
'grey15' -> Color.new255(38, 38, 38),
'grey16' -> Color.new255(41, 41, 41),
'grey17' -> Color.new255(43, 43, 43),
'grey18' -> Color.new255(46, 46, 46),
'grey19' -> Color.new255(48, 48, 48),
'grey2' -> Color.new255(5, 5, 5),
'grey20' -> Color.new255(51, 51, 51),
'grey21' -> Color.new255(54, 54, 54),
'grey22' -> Color.new255(56, 56, 56),
'grey23' -> Color.new255(59, 59, 59),
'grey24' -> Color.new255(61, 61, 61),
'grey25' -> Color.new255(64, 64, 64),
'grey26' -> Color.new255(66, 66, 66),
'grey27' -> Color.new255(69, 69, 69),
'grey28' -> Color.new255(71, 71, 71),
'grey29' -> Color.new255(74, 74, 74),
'grey3' -> Color.new255(8, 8, 8),
'grey30' -> Color.new255(77, 77, 77),
'grey31' -> Color.new255(79, 79, 79),
'grey32' -> Color.new255(82, 82, 82),
'grey33' -> Color.new255(84, 84, 84),
'grey34' -> Color.new255(87, 87, 87),
'grey35' -> Color.new255(89, 89, 89),
'grey36' -> Color.new255(92, 92, 92),
'grey37' -> Color.new255(94, 94, 94),
'grey38' -> Color.new255(97, 97, 97),
'grey39' -> Color.new255(99, 99, 99),
'grey4' -> Color.new255(10, 10, 10),
'grey40' -> Color.new255(102, 102, 102),
'grey41' -> Color.new255(105, 105, 105),
'grey42' -> Color.new255(107, 107, 107),
'grey43' -> Color.new255(110, 110, 110),
'grey44' -> Color.new255(112, 112, 112),
'grey45' -> Color.new255(115, 115, 115),
'grey46' -> Color.new255(117, 117, 117),
'grey47' -> Color.new255(120, 120, 120),
'grey48' -> Color.new255(122, 122, 122),
'grey49' -> Color.new255(125, 125, 125),
'grey5' -> Color.new255(13, 13, 13),
'grey50' -> Color.new255(127, 127, 127),
'grey51' -> Color.new255(130, 130, 130),
'grey52' -> Color.new255(133, 133, 133),
'grey53' -> Color.new255(135, 135, 135),
'grey54' -> Color.new255(138, 138, 138),
'grey55' -> Color.new255(140, 140, 140),
'grey56' -> Color.new255(143, 143, 143),
'grey57' -> Color.new255(145, 145, 145),
'grey58' -> Color.new255(148, 148, 148),
'grey59' -> Color.new255(150, 150, 150),
'grey6' -> Color.new255(15, 15, 15),
'grey60' -> Color.new255(153, 153, 153),
'grey61' -> Color.new255(156, 156, 156),
'grey62' -> Color.new255(158, 158, 158),
'grey63' -> Color.new255(161, 161, 161),
'grey64' -> Color.new255(163, 163, 163),
'grey65' -> Color.new255(166, 166, 166),
'grey66' -> Color.new255(168, 168, 168),
'grey67' -> Color.new255(171, 171, 171),
'grey68' -> Color.new255(173, 173, 173),
'grey69' -> Color.new255(176, 176, 176),
'grey7' -> Color.new255(18, 18, 18),
'grey70' -> Color.new255(179, 179, 179),
'grey71' -> Color.new255(181, 181, 181),
'grey72' -> Color.new255(184, 184, 184),
'grey73' -> Color.new255(186, 186, 186),
'grey74' -> Color.new255(189, 189, 189),
'grey75' -> Color.new255(191, 191, 191),
'grey76' -> Color.new255(194, 194, 194),
'grey77' -> Color.new255(196, 196, 196),
'grey78' -> Color.new255(199, 199, 199),
'grey79' -> Color.new255(201, 201, 201),
'grey8' -> Color.new255(20, 20, 20),
'grey80' -> Color.new255(204, 204, 204),
'grey81' -> Color.new255(207, 207, 207),
'grey82' -> Color.new255(209, 209, 209),
'grey83' -> Color.new255(212, 212, 212),
'grey84' -> Color.new255(214, 214, 214),
'grey85' -> Color.new255(217, 217, 217),
'grey86' -> Color.new255(219, 219, 219),
'grey87' -> Color.new255(222, 222, 222),
'grey88' -> Color.new255(224, 224, 224),
'grey89' -> Color.new255(227, 227, 227),
'grey9' -> Color.new255(23, 23, 23),
'grey90' -> Color.new255(229, 229, 229),
'grey91' -> Color.new255(232, 232, 232),
'grey92' -> Color.new255(235, 235, 235),
'grey93' -> Color.new255(237, 237, 237),
'grey94' -> Color.new255(240, 240, 240),
'grey95' -> Color.new255(242, 242, 242),
'grey96' -> Color.new255(245, 245, 245),
'grey97' -> Color.new255(247, 247, 247),
'grey98' -> Color.new255(250, 250, 250),
'grey99' -> Color.new255(252, 252, 252),
'honeydew' -> Color.new255(240, 255, 240),
'honeydew1' -> Color.new255(240, 255, 240),
'honeydew2' -> Color.new255(224, 238, 224),
'honeydew3' -> Color.new255(193, 205, 193),
'honeydew4' -> Color.new255(131, 139, 131),
'hot pink' -> Color.new255(255, 105, 180),
'HotPink' -> Color.new255(255, 105, 180),
'HotPink1' -> Color.new255(255, 110, 180),
'HotPink2' -> Color.new255(238, 106, 167),
'HotPink3' -> Color.new255(205, 96, 144),
'HotPink4' -> Color.new255(139, 58, 98),
'indian red' -> Color.new255(205, 92, 92),
'IndianRed' -> Color.new255(205, 92, 92),
'IndianRed1' -> Color.new255(255, 106, 106),
'IndianRed2' -> Color.new255(238, 99, 99),
'IndianRed3' -> Color.new255(205, 85, 85),
'IndianRed4' -> Color.new255(139, 58, 58),
'ivory' -> Color.new255(255, 255, 240),
'ivory1' -> Color.new255(255, 255, 240),
'ivory2' -> Color.new255(238, 238, 224),
'ivory3' -> Color.new255(205, 205, 193),
'ivory4' -> Color.new255(139, 139, 131),
'khaki' -> Color.new255(240, 230, 140),
'khaki1' -> Color.new255(255, 246, 143),
'khaki2' -> Color.new255(238, 230, 133),
'khaki3' -> Color.new255(205, 198, 115),
'khaki4' -> Color.new255(139, 134, 78),
'lavender' -> Color.new255(230, 230, 250),
'lavender blush' -> Color.new255(255, 240, 245),
'LavenderBlush' -> Color.new255(255, 240, 245),
'LavenderBlush1' -> Color.new255(255, 240, 245),
'LavenderBlush2' -> Color.new255(238, 224, 229),
'LavenderBlush3' -> Color.new255(205, 193, 197),
'LavenderBlush4' -> Color.new255(139, 131, 134),
'lawn green' -> Color.new255(124, 252, 0),
'LawnGreen' -> Color.new255(124, 252, 0),
'lemon chiffon' -> Color.new255(255, 250, 205),
'LemonChiffon' -> Color.new255(255, 250, 205),
'LemonChiffon1' -> Color.new255(255, 250, 205),
'LemonChiffon2' -> Color.new255(238, 233, 191),
'LemonChiffon3' -> Color.new255(205, 201, 165),
'LemonChiffon4' -> Color.new255(139, 137, 112),
'light blue' -> Color.new255(173, 216, 230),
'light coral' -> Color.new255(240, 128, 128),
'light cyan' -> Color.new255(224, 255, 255),
'light goldenrod' -> Color.new255(238, 221, 130),
'light goldenrod yellow' -> Color.new255(250, 250, 210),
'light gray' -> Color.new255(211, 211, 211),
'light grey' -> Color.new255(211, 211, 211),
'light pink' -> Color.new255(255, 182, 193),
'light salmon' -> Color.new255(255, 160, 122),
'light sea green' -> Color.new255(32, 178, 170),
'light sky blue' -> Color.new255(135, 206, 250),
'light slate blue' -> Color.new255(132, 112, 255),
'light slate gray' -> Color.new255(119, 136, 153),
'light slate grey' -> Color.new255(119, 136, 153),
'light steel blue' -> Color.new255(176, 196, 222),
'light yellow' -> Color.new255(255, 255, 224),
'LightBlue' -> Color.new255(173, 216, 230),
'LightBlue1' -> Color.new255(191, 239, 255),
'LightBlue2' -> Color.new255(178, 223, 238),
'LightBlue3' -> Color.new255(154, 192, 205),
'LightBlue4' -> Color.new255(104, 131, 139),
'LightCoral' -> Color.new255(240, 128, 128),
'LightCyan' -> Color.new255(224, 255, 255),
'LightCyan1' -> Color.new255(224, 255, 255),
'LightCyan2' -> Color.new255(209, 238, 238),
'LightCyan3' -> Color.new255(180, 205, 205),
'LightCyan4' -> Color.new255(122, 139, 139),
'LightGoldenrod' -> Color.new255(238, 221, 130),
'LightGoldenrod1' -> Color.new255(255, 236, 139),
'LightGoldenrod2' -> Color.new255(238, 220, 130),
'LightGoldenrod3' -> Color.new255(205, 190, 112),
'LightGoldenrod4' -> Color.new255(139, 129, 76),
'LightGoldenrodYellow' -> Color.new255(250, 250, 210),
'LightGray' -> Color.new255(211, 211, 211),
'LightGrey' -> Color.new255(211, 211, 211),
'LightPink' -> Color.new255(255, 182, 193),
'LightPink1' -> Color.new255(255, 174, 185),
'LightPink2' -> Color.new255(238, 162, 173),
'LightPink3' -> Color.new255(205, 140, 149),
'LightPink4' -> Color.new255(139, 95, 101),
'LightSalmon' -> Color.new255(255, 160, 122),
'LightSalmon1' -> Color.new255(255, 160, 122),
'LightSalmon2' -> Color.new255(238, 149, 114),
'LightSalmon3' -> Color.new255(205, 129, 98),
'LightSalmon4' -> Color.new255(139, 87, 66),
'LightSeaGreen' -> Color.new255(32, 178, 170),
'LightSkyBlue' -> Color.new255(135, 206, 250),
'LightSkyBlue1' -> Color.new255(176, 226, 255),
'LightSkyBlue2' -> Color.new255(164, 211, 238),
'LightSkyBlue3' -> Color.new255(141, 182, 205),
'LightSkyBlue4' -> Color.new255(96, 123, 139),
'LightSlateBlue' -> Color.new255(132, 112, 255),
'LightSlateGray' -> Color.new255(119, 136, 153),
'LightSlateGrey' -> Color.new255(119, 136, 153),
'LightSteelBlue' -> Color.new255(176, 196, 222),
'LightSteelBlue1' -> Color.new255(202, 225, 255),
'LightSteelBlue2' -> Color.new255(188, 210, 238),
'LightSteelBlue3' -> Color.new255(162, 181, 205),
'LightSteelBlue4' -> Color.new255(110, 123, 139),
'LightYellow' -> Color.new255(255, 255, 224),
'LightYellow1' -> Color.new255(255, 255, 224),
'LightYellow2' -> Color.new255(238, 238, 209),
'LightYellow3' -> Color.new255(205, 205, 180),
'LightYellow4' -> Color.new255(139, 139, 122),
'lime green' -> Color.new255(50, 205, 50),
'LimeGreen' -> Color.new255(50, 205, 50),
'linen' -> Color.new255(250, 240, 230),
'magenta' -> Color.new255(255, 0, 255),
'magenta1' -> Color.new255(255, 0, 255),
'magenta2' -> Color.new255(238, 0, 238),
'magenta3' -> Color.new255(205, 0, 205),
'magenta4' -> Color.new255(139, 0, 139),
'maroon' -> Color.new255(176, 48, 96),
'maroon1' -> Color.new255(255, 52, 179),
'maroon2' -> Color.new255(238, 48, 167),
'maroon3' -> Color.new255(205, 41, 144),
'maroon4' -> Color.new255(139, 28, 98),
'medium aquamarine' -> Color.new255(102, 205, 170),
'medium blue' -> Color.new255(0, 0, 205),
'medium orchid' -> Color.new255(186, 85, 211),
'medium purple' -> Color.new255(147, 112, 219),
'medium sea green' -> Color.new255(60, 179, 113),
'medium slate blue' -> Color.new255(123, 104, 238),
'medium spring green' -> Color.new255(0, 250, 154),
'medium turquoise' -> Color.new255(72, 209, 204),
'medium violet red' -> Color.new255(199, 21, 133),
'MediumAquamarine' -> Color.new255(102, 205, 170),
'MediumBlue' -> Color.new255(0, 0, 205),
'MediumOrchid' -> Color.new255(186, 85, 211),
'MediumOrchid1' -> Color.new255(224, 102, 255),
'MediumOrchid2' -> Color.new255(209, 95, 238),
'MediumOrchid3' -> Color.new255(180, 82, 205),
'MediumOrchid4' -> Color.new255(122, 55, 139),
'MediumPurple' -> Color.new255(147, 112, 219),
'MediumPurple1' -> Color.new255(171, 130, 255),
'MediumPurple2' -> Color.new255(159, 121, 238),
'MediumPurple3' -> Color.new255(137, 104, 205),
'MediumPurple4' -> Color.new255(93, 71, 139),
'MediumSeaGreen' -> Color.new255(60, 179, 113),
'MediumSlateBlue' -> Color.new255(123, 104, 238),
'MediumSpringGreen' -> Color.new255(0, 250, 154),
'MediumTurquoise' -> Color.new255(72, 209, 204),
'MediumVioletRed' -> Color.new255(199, 21, 133),
'midnight blue' -> Color.new255(25, 25, 112),
'MidnightBlue' -> Color.new255(25, 25, 112),
'mint cream' -> Color.new255(245, 255, 250),
'MintCream' -> Color.new255(245, 255, 250),
'misty rose' -> Color.new255(255, 228, 225),
'MistyRose' -> Color.new255(255, 228, 225),
'MistyRose1' -> Color.new255(255, 228, 225),
'MistyRose2' -> Color.new255(238, 213, 210),
'MistyRose3' -> Color.new255(205, 183, 181),
'MistyRose4' -> Color.new255(139, 125, 123),
'moccasin' -> Color.new255(255, 228, 181),
'navajo white' -> Color.new255(255, 222, 173),
'NavajoWhite' -> Color.new255(255, 222, 173),
'NavajoWhite1' -> Color.new255(255, 222, 173),
'NavajoWhite2' -> Color.new255(238, 207, 161),
'NavajoWhite3' -> Color.new255(205, 179, 139),
'NavajoWhite4' -> Color.new255(139, 121, 94),
'navy' -> Color.new255(0, 0, 128),
'navy blue' -> Color.new255(0, 0, 128),
'NavyBlue' -> Color.new255(0, 0, 128),
'old lace' -> Color.new255(253, 245, 230),
'OldLace' -> Color.new255(253, 245, 230),
'olive drab' -> Color.new255(107, 142, 35),
'OliveDrab' -> Color.new255(107, 142, 35),
'OliveDrab1' -> Color.new255(192, 255, 62),
'OliveDrab2' -> Color.new255(179, 238, 58),
'OliveDrab3' -> Color.new255(154, 205, 50),
'OliveDrab4' -> Color.new255(105, 139, 34),
'orange' -> Color.new255(255, 165, 0),
'orange red' -> Color.new255(255, 69, 0),
'orange1' -> Color.new255(255, 165, 0),
'orange2' -> Color.new255(238, 154, 0),
'orange3' -> Color.new255(205, 133, 0),
'orange4' -> Color.new255(139, 90, 0),
'OrangeRed' -> Color.new255(255, 69, 0),
'OrangeRed1' -> Color.new255(255, 69, 0),
'OrangeRed2' -> Color.new255(238, 64, 0),
'OrangeRed3' -> Color.new255(205, 55, 0),
'OrangeRed4' -> Color.new255(139, 37, 0),
'orchid' -> Color.new255(218, 112, 214),
'orchid1' -> Color.new255(255, 131, 250),
'orchid2' -> Color.new255(238, 122, 233),
'orchid3' -> Color.new255(205, 105, 201),
'orchid4' -> Color.new255(139, 71, 137),
'pale goldenrod' -> Color.new255(238, 232, 170),
'pale green' -> Color.new255(152, 251, 152),
'pale turquoise' -> Color.new255(175, 238, 238),
'pale violet red' -> Color.new255(219, 112, 147),
'PaleGoldenrod' -> Color.new255(238, 232, 170),
'PaleGreen' -> Color.new255(152, 251, 152),
'PaleGreen1' -> Color.new255(154, 255, 154),
'PaleGreen2' -> Color.new255(144, 238, 144),
'PaleGreen3' -> Color.new255(124, 205, 124),
'PaleGreen4' -> Color.new255(84, 139, 84),
'PaleTurquoise' -> Color.new255(175, 238, 238),
'PaleTurquoise1' -> Color.new255(187, 255, 255),
'PaleTurquoise2' -> Color.new255(174, 238, 238),
'PaleTurquoise3' -> Color.new255(150, 205, 205),
'PaleTurquoise4' -> Color.new255(102, 139, 139),
'PaleVioletRed' -> Color.new255(219, 112, 147),
'PaleVioletRed1' -> Color.new255(255, 130, 171),
'PaleVioletRed2' -> Color.new255(238, 121, 159),
'PaleVioletRed3' -> Color.new255(205, 104, 137),
'PaleVioletRed4' -> Color.new255(139, 71, 93),
'papaya whip' -> Color.new255(255, 239, 213),
'PapayaWhip' -> Color.new255(255, 239, 213),
'peach puff' -> Color.new255(255, 218, 185),
'PeachPuff' -> Color.new255(255, 218, 185),
'PeachPuff1' -> Color.new255(255, 218, 185),
'PeachPuff2' -> Color.new255(238, 203, 173),
'PeachPuff3' -> Color.new255(205, 175, 149),
'PeachPuff4' -> Color.new255(139, 119, 101),
'peru' -> Color.new255(205, 133, 63),
'pink' -> Color.new255(255, 192, 203),
'pink1' -> Color.new255(255, 181, 197),
'pink2' -> Color.new255(238, 169, 184),
'pink3' -> Color.new255(205, 145, 158),
'pink4' -> Color.new255(139, 99, 108),
'plum' -> Color.new255(221, 160, 221),
'plum1' -> Color.new255(255, 187, 255),
'plum2' -> Color.new255(238, 174, 238),
'plum3' -> Color.new255(205, 150, 205),
'plum4' -> Color.new255(139, 102, 139),
'powder blue' -> Color.new255(176, 224, 230),
'PowderBlue' -> Color.new255(176, 224, 230),
'purple' -> Color.new255(160, 32, 240),
'purple1' -> Color.new255(155, 48, 255),
'purple2' -> Color.new255(145, 44, 238),
'purple3' -> Color.new255(125, 38, 205),
'purple4' -> Color.new255(85, 26, 139),
'red' -> Color.new255(255, 0, 0),
'red1' -> Color.new255(255, 0, 0),
'red2' -> Color.new255(238, 0, 0),
'red3' -> Color.new255(205, 0, 0),
'red4' -> Color.new255(139, 0, 0),
'rosy brown' -> Color.new255(188, 143, 143),
'RosyBrown' -> Color.new255(188, 143, 143),
'RosyBrown1' -> Color.new255(255, 193, 193),
'RosyBrown2' -> Color.new255(238, 180, 180),
'RosyBrown3' -> Color.new255(205, 155, 155),
'RosyBrown4' -> Color.new255(139, 105, 105),
'royal blue' -> Color.new255(65, 105, 225),
'RoyalBlue' -> Color.new255(65, 105, 225),
'RoyalBlue1' -> Color.new255(72, 118, 255),
'RoyalBlue2' -> Color.new255(67, 110, 238),
'RoyalBlue3' -> Color.new255(58, 95, 205),
'RoyalBlue4' -> Color.new255(39, 64, 139),
'saddle brown' -> Color.new255(139, 69, 19),
'SaddleBrown' -> Color.new255(139, 69, 19),
'salmon' -> Color.new255(250, 128, 114),
'salmon1' -> Color.new255(255, 140, 105),
'salmon2' -> Color.new255(238, 130, 98),
'salmon3' -> Color.new255(205, 112, 84),
'salmon4' -> Color.new255(139, 76, 57),
'sandy brown' -> Color.new255(244, 164, 96),
'SandyBrown' -> Color.new255(244, 164, 96),
'sea green' -> Color.new255(46, 139, 87),
'SeaGreen' -> Color.new255(46, 139, 87),
'SeaGreen1' -> Color.new255(84, 255, 159),
'SeaGreen2' -> Color.new255(78, 238, 148),
'SeaGreen3' -> Color.new255(67, 205, 128),
'SeaGreen4' -> Color.new255(46, 139, 87),
'seashell' -> Color.new255(255, 245, 238),
'seashell1' -> Color.new255(255, 245, 238),
'seashell2' -> Color.new255(238, 229, 222),
'seashell3' -> Color.new255(205, 197, 191),
'seashell4' -> Color.new255(139, 134, 130),
'sienna' -> Color.new255(160, 82, 45),
'sienna1' -> Color.new255(255, 130, 71),
'sienna2' -> Color.new255(238, 121, 66),
'sienna3' -> Color.new255(205, 104, 57),
'sienna4' -> Color.new255(139, 71, 38),
'sky blue' -> Color.new255(135, 206, 235),
'SkyBlue' -> Color.new255(135, 206, 235),
'SkyBlue1' -> Color.new255(135, 206, 255),
'SkyBlue2' -> Color.new255(126, 192, 238),
'SkyBlue3' -> Color.new255(108, 166, 205),
'SkyBlue4' -> Color.new255(74, 112, 139),
'slate blue' -> Color.new255(106, 90, 205),
'slate gray' -> Color.new255(112, 128, 144),
'slate grey' -> Color.new255(112, 128, 144),
'SlateBlue' -> Color.new255(106, 90, 205),
'SlateBlue1' -> Color.new255(131, 111, 255),
'SlateBlue2' -> Color.new255(122, 103, 238),
'SlateBlue3' -> Color.new255(105, 89, 205),
'SlateBlue4' -> Color.new255(71, 60, 139),
'SlateGray' -> Color.new255(112, 128, 144),
'SlateGray1' -> Color.new255(198, 226, 255),
'SlateGray2' -> Color.new255(185, 211, 238),
'SlateGray3' -> Color.new255(159, 182, 205),
'SlateGray4' -> Color.new255(108, 123, 139),
'SlateGrey' -> Color.new255(112, 128, 144),
'snow' -> Color.new255(255, 250, 250),
'snow1' -> Color.new255(255, 250, 250),
'snow2' -> Color.new255(238, 233, 233),
'snow3' -> Color.new255(205, 201, 201),
'snow4' -> Color.new255(139, 137, 137),
'spring green' -> Color.new255(0, 255, 127),
'SpringGreen' -> Color.new255(0, 255, 127),
'SpringGreen1' -> Color.new255(0, 255, 127),
'SpringGreen2' -> Color.new255(0, 238, 118),
'SpringGreen3' -> Color.new255(0, 205, 102),
'SpringGreen4' -> Color.new255(0, 139, 69),
'steel blue' -> Color.new255(70, 130, 180),
'SteelBlue' -> Color.new255(70, 130, 180),
'SteelBlue1' -> Color.new255(99, 184, 255),
'SteelBlue2' -> Color.new255(92, 172, 238),
'SteelBlue3' -> Color.new255(79, 148, 205),
'SteelBlue4' -> Color.new255(54, 100, 139),
'tan' -> Color.new255(210, 180, 140),
'tan1' -> Color.new255(255, 165, 79),
'tan2' -> Color.new255(238, 154, 73),
'tan3' -> Color.new255(205, 133, 63),
'tan4' -> Color.new255(139, 90, 43),
'thistle' -> Color.new255(216, 191, 216),
'thistle1' -> Color.new255(255, 225, 255),
'thistle2' -> Color.new255(238, 210, 238),
'thistle3' -> Color.new255(205, 181, 205),
'thistle4' -> Color.new255(139, 123, 139),
'tomato' -> Color.new255(255, 99, 71),
'tomato1' -> Color.new255(255, 99, 71),
'tomato2' -> Color.new255(238, 92, 66),
'tomato3' -> Color.new255(205, 79, 57),
'tomato4' -> Color.new255(139, 54, 38),
'turquoise' -> Color.new255(64, 224, 208),
'turquoise1' -> Color.new255(0, 245, 255),
'turquoise2' -> Color.new255(0, 229, 238),
'turquoise3' -> Color.new255(0, 197, 205),
'turquoise4' -> Color.new255(0, 134, 139),
'violet' -> Color.new255(238, 130, 238),
'violet red' -> Color.new255(208, 32, 144),
'VioletRed' -> Color.new255(208, 32, 144),
'VioletRed1' -> Color.new255(255, 62, 150),
'VioletRed2' -> Color.new255(238, 58, 140),
'VioletRed3' -> Color.new255(205, 50, 120),
'VioletRed4' -> Color.new255(139, 34, 82),
'wheat' -> Color.new255(245, 222, 179),
'wheat1' -> Color.new255(255, 231, 186),
'wheat2' -> Color.new255(238, 216, 174),
'wheat3' -> Color.new255(205, 186, 150),
'wheat4' -> Color.new255(139, 126, 102),
'white' -> Color.new255(255, 255, 255),
'white smoke' -> Color.new255(245, 245, 245),
'WhiteSmoke' -> Color.new255(245, 245, 245),
'yellow' -> Color.new255(255, 255, 0),
'yellow green' -> Color.new255(154, 205, 50),
'yellow1' -> Color.new255(255, 255, 0),
'yellow2' -> Color.new255(238, 238, 0),
'yellow3' -> Color.new255(205, 205, 0),
'yellow4' -> Color.new255(139, 139, 0),
'YellowGreen' -> Color.new255(154, 205, 50)
::


class:: CombC
summary:: Comb delay line with cubic interpolation.
related:: Classes/CombL, Classes/CombN, Classes/BufCombC
categories::  UGens>Delays


Description::

Comb delay line with cubic interpolation. See also  link::Classes/CombN::
which uses no interpolation, and  link::Classes/CombL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.

The feedback coefficient is given by the equation code:: fb == 0.001 ** (delay / decay.abs) * decay.sign :: where 0.001 is -60 dBFS.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

Large decay times are sensitive to DC bias, so use a link::Classes/LeakDC:: if this is an issue.

Infinite decay times are permitted. A decay time of code::inf:: leads to a feedback coefficient of 1, and a decay time of code::-inf:: leads to a feedback coefficient of -1.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

// large delay lines
(
s.options.memSize= 8192*2;
s.reboot;
)
({
	var in, del1, del2, del3, del4;
	in = SoundIn.ar(0);
	del1 = CombC.ar(in, 8, LFNoise2.kr(0.01).range(1, 8), 1);
	del2 = CombC.ar(del1, 8, LFNoise2.kr(0.01).range(1, 8), 1);
	del3 = CombC.ar(del2, 8, LFNoise2.kr(0.01).range(1, 8), 1);
	del4 = CombC.ar(del3, 8, LFNoise2.kr(0.01).range(1, 8), 1);
	(del1 + del2 + del3 + del4)!2;
}.play;
);

::



class:: CombL
summary:: Comb delay line with linear interpolation.
related:: Classes/CombC, Classes/CombN, Classes/BufCombL
categories::  UGens>Delays


Description::

Comb delay line with linear interpolation. See also  link::Classes/CombN::
which uses no interpolation, and  link::Classes/CombC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.

The feedback coefficient is given by the equation code:: fb == 0.001 ** (delay / decay.abs) * decay.sign :: where 0.001 is -60 dBFS.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

Large decay times are sensitive to DC bias, so use a link::Classes/LeakDC:: if this is an issue.

Infinite decay times are permitted. A decay time of code::inf:: leads to a feedback coefficient of 1, and a decay time of code::-inf:: leads to a feedback coefficient of -1.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombL.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

::



class:: CombN
summary:: Comb delay line with no interpolation.
related:: Classes/CombC, Classes/CombL, Classes/BufCombN
categories::  UGens>Delays


Description::

Comb delay line with no interpolation. See also  link::Classes/CombL::
which uses linear interpolation, and  link::Classes/CombC::  which uses
cubic interpolation. Cubic and linear interpolation are more computationally
expensive, but more accurate.

This UGen will create aliasing artifacts if you modulate the delay time, which is also quantized to the nearest sample period. If these are undesirable properties, use CombL or CombC. But if your delay time is fixed and sub-sample accuracy is not needed, this is the most CPU-efficient choice with no loss in quality.

The feedback coefficient is given by the equation code:: fb == 0.001 ** (delay / decay.abs) * decay.sign :: where 0.001 is -60 dBFS.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative, then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

Large decay times are sensitive to DC bias, so use a link::Classes/LeakDC:: if this is an issue.

Infinite decay times are permitted. A decay time of code::inf:: leads to a feedback coefficient of 1, and a decay time of code::-inf:: leads to a feedback coefficient of -1.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;

::



class:: Compander
summary:: Compressor, expander, limiter, gate, ducker
categories:: UGens>Dynamics
related:: Classes/Normalizer, Classes/CompanderD, Classes/Limiter

description::
General purpose (hard-knee) dynamics processor.

classmethods::
method:: ar
argument::in
The signal to be compressed / expanded / gated.

argument::control
The signal whose amplitude determines the gain applied to the input signal. Often the same as in (for standard gating or compression) but should be different for ducking.

argument::thresh
Usually between 0 and 1. Amplitude threshold of the control signal, which determines the break point between slopeBelow and slopeAbove. The control signal amplitude is calculated using RMS.

argument::slopeBelow
Slope of applied amplitude curve if control signal amplitude is below code::thresh::. If > 1.0, the amplitude drops off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor.

argument::slopeAbove
Slope of applied amplitude curve if control signal amplitude is above code::thresh::.
Values < 1.0 achieve compression (louder signals are attenuated) whereas values > 1.0 expand (louder signals are made even louder). A value of code::1/3:: achieves a 3:1 compression.

argument::clampTime
time (in seconds) it takes for the amplitude adjustment to kick in fully after the control signal is above code::thresh::. Usually a small value around 10ms (0.01), often set as low as 2ms (0.002).

argument::relaxTime
time (in seconds) for the amplitude adjustment to be released (control signal below code::thresh::). Usually longer than code::clampTime::; depending on the input and control signal, setting both times too short results in (possibly unwanted) artifacts.

argument::mul
output is multiplied by this value.
argument::add
value added to the output.

discussion::
See for example http://en.wikipedia.org/wiki/Audio_level_compression for a more in-depth explanation.

examples::

Clean signal (for reference)
code::
(
{
	Decay2.ar(
		Impulse.ar(8, 0, LFSaw.kr(0.3, 1, -0.3, 0.3)),
		0.001,
		0.3
	)
	* Mix.ar(Pulse.ar([80, 81], 0.3))
}.play;
)
::

Noise gate

code::
(
{
	var z;

	// signal (clean)
	z = Decay2.ar(
		Impulse.ar(8, 0, LFSaw.kr(0.3, 1, -0.3, 0.3)),
		0.001,
		0.3
	)
	* Mix.ar(Pulse.ar([80, 81], 0.3));

	// apply gate (mouse x sets treshold)
	Compander.ar(z, z,
		thresh: MouseX.kr(0.001, 1),
		slopeBelow: 10,
		slopeAbove:  1,
		clampTime:   0.01,
		relaxTime:   0.01
	)
}.play;
)
::
Compressor
code::
(
{
	var z;

	// signal (clean)
	z = Decay2.ar(
		Impulse.ar(8, 0, LFSaw.kr(0.3, 1, -0.3, 0.3)),
		0.001,
		0.3
	)
	* Mix.ar(Pulse.ar([80, 81], 0.3));

	// apply compression  (mouse x sets amount)
	Compander.ar(z, z,
		thresh: MouseX.kr(0.01, 1),
		slopeBelow: 1,
		slopeAbove: 0.5,
		clampTime:  0.01,
		relaxTime:  0.01
	)
}.play;
)
::
Limiter
code::
(
{
	var z;

	// signal (clean)
	z = Decay2.ar(
		Impulse.ar(8, 0, LFSaw.kr(0.3, 1, -0.3, 0.3)),
		0.001,
		0.3
	)
	* Mix.ar(Pulse.ar([80, 81], 0.3));


	// apply limiter (mouse x sets amount)
	Compander.ar(z, z,
		thresh: MouseX.kr(0.01, 1),
		slopeBelow: 1,
		slopeAbove: 0.1,
		clampTime:  0.01,
		relaxTime:  0.01
	)
}.play;
)
::
Sustainer
code::
(
// note the pops at the beginning of signal due to lack of lookahead
{
	var z;

	// signal (clean)
	z = Decay2.ar(
		Impulse.ar(8, 0, LFSaw.kr(0.3, 1, -0.3, 0.3)),
		0.001,
		0.3
	)
	* Mix.ar(Pulse.ar([80, 81], 0.3));

	// apply sustainer
	Compander.ar(z, z,
		thresh: MouseX.kr(0.1, 1),
		slopeBelow: 0.1,
		slopeAbove: 1,
		clampTime:  0.01,
		relaxTime:  0.01
	) * 0.1
}.play;
)
::


class:: CompanderD
summary:: Compressor, expander, limiter, gate, ducker.
related:: Classes/Amplitude, Classes/Compander, Classes/Normalizer, Classes/Limiter
categories::  UGens>Dynamics


Description::

CompanderD passes the signal directly to the control input, but
adds a delay to the process input so that the lag in the gain clamping
will not lag the attacks in the input sound.


classmethods::

method::ar

argument::in
The signal to be compressed / expanded / gated.

argument::thresh
Control signal amplitude threshold, which determines the break point between slopeBelow and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.

argument::slopeBelow
Slope of the amplitude curve below the threshold. If this slope > 1.0, the amplitude will drop off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor.

argument::slopeAbove
Same thing, but above the threshold. Values < 1.0 achieve compression (louder signals are attenuated); > 1.0, you get expansion (louder signals are made even louder). For 3:1 compression, you would use a value of 1/3 here.

argument::clampTime
The amount of time it takes for the amplitude adjustment to kick in fully. This is usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as 2 milliseconds (0.002).

argument::relaxTime
The amount of time for the amplitude adjustment to be released. Usually a bit longer than clampTime; if both times are too short, you can get some (possibly unwanted) artifacts.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Discussion::
If any of this is confusing, see http://en.wikipedia.org/wiki/Audio_level_compression



CLASS:: Complex
summary:: complex number
categories:: Math
related::Classes/Polar, Classes/SimpleNumber, Classes/Float, Classes/Integer

DESCRIPTION::
A class representing complex numbers.
Note that this is a simplified representation of a complex number, which does not implement the full mathematical notion of a complex number.

CLASSMETHODS::
method:: new
Create a new complex number with the given real and imaginary parts.
argument:: real
the real part
argument:: imag
the imaginary part

returns:: a new instance of Complex.
discussion::
code::
a = Complex(2, 5);
a.real;
a.imag;
::

INSTANCEMETHODS::

subsection:: math support
method:: real
The real part of the number.

method:: imag
The imaginary part of the number.

method:: conjugate
the complex conjugate.
discussion::
code::
Complex(2, 9).conjugate
::

method:: +
Complex addition.
discussion::
code::
Complex(2, 9) + Complex(-6, 2)
::

method:: -
Complex subtraction
discussion::
code::
Complex(2, 9) - Complex(-6, 2)
::

method:: *
Complex multiplication
discussion::
code::
Complex(2, 9) * Complex(-6, 2)
::

method:: /
Complex division.
discussion::
code::
Complex(2, 9) / Complex(-6, 2)
::

method:: exp
Complex exponentiation with base e.
discussion::
code::
exp(Complex(2, 9))
::
code::
exp(Complex(0, pi)) == -1 // Euler's formula: true
::

method:: squared
Complex self multiplication.
discussion::
code::
squared(Complex(2, 1))
::

method:: cubed
complex triple self multiplication.
discussion::
code::
cubed(Complex(2, 1))
::

method:: sqrt
Complex square root
discussion::
returns the principal root
code::
Complex(4, 1.neg).sqrt

// compare...
Complex(4, 1.neg).pow(2.reciprocal)
::

method:: **
method:: pow
Complex exponentiation
discussion::
not implemented for all combinations - some are mathematically ambiguous.
code::
Complex(0, 2) ** 6
::
code::
2.3 ** Complex(0, 2)
::
code::
Complex(2, 9) ** 1.2 // not defined
::


method:: <
the comparison of just the real parts.
discussion::
code::
Complex(2, 9) < Complex(5, 1);
::

method:: ==
the comparison assuming that the reals (floats) are fully embedded in the complex numbers
discussion::
code::
Complex(1, 0) == 1;
Complex(1, 5) == Complex(1, 5);
::

method:: neg
negation of both parts
discussion::
code::
Complex(2, 9).neg
::

method:: reciprocal
the reciprocal of a complex number
discussion::
code::
Complex(3, 4).reciprocal
1 / Complex(3, 4) // same, but less efficient
::

method:: abs
the absolute value of a complex number is its magnitude.
discussion::
code::
Complex(3, 4).abs
::

method:: magnitude
distance to the origin.

method:: magnitudeApx

method:: rho
the distance to the origin.

method:: angle, phase, theta
the angle in radians.


subsection:: conversion
method:: asPoint
Convert to a link::Classes/Point::.

method:: asPolar
Convert to a Polar

method:: asInteger
real part as link::Classes/Integer::.

method:: asFloat
real part as link::Classes/Float::.

method:: asComplex
returns this


subsection:: misc
method:: coerce
method:: hash
a hash value
method:: printOn
print this on given stream
method:: performBinaryOpOnSignal
method:: performBinaryOpOnComplex
method:: performBinaryOpOnSimpleNumber
method:: performBinaryOpOnUGen




EXAMPLES::

Basic example:
code::
a = Complex(0, 1);
a * a; // returns Complex(-1, 0);
::

Julia set approximation:
code::
f = { |z| z * z + Complex(0.70176, 0.3842) };

(
var n = 80, xs = 400, ys = 400, dx = xs / n, dy = ys / n, zoom = 3, offset = -0.5;
var field = { |x| { |y| Complex(x / n + offset * zoom, y / n + offset * zoom) } ! n } ! n;

w = Window("Julia set", bounds:Rect(200, 200, xs, ys)).front;
w.view.background_(Color.black);
w.drawFunc = {
	n.do { |x|
		n.do { |y|
			var z = field[x][y];
			z = f.(z);
			field[x][y] = z;
			Pen.color = Color.gray(z.rho.linlin(-100, 100, 1, 0));
 			Pen.addRect(
				Rect(x * dx, y * dy, dx, dy)
			);
			Pen.fill
		}
	}
};

fork({ 6.do { w.refresh; 2.wait } }, AppClock)
)
::


class:: CompositeView
summary:: A view that contains other views.
categories:: GUI>Views
related:: Classes/FlowView, Classes/FlowLayout

description::

note::
In Qt GUI, every view can be a parent to other views, so CompositeView redirects to the same class as link::Classes/View:: - you can use the latter equivalently.
::

CompositeView can be used as the parent of other views, while also being a child of a Window or another CompositeView itself. Aside from that it has not special methods of its own.

note::
In Cocoa GUI, this view accepts key actions, but not mouse clicks or drags.
::


classmethods::
private:: key


examples::

subsection:: Coordinate System

Containers use relative coordinates, i.e.  views are placed relative to the upper left corner of the container.
code::
(
w = Window.new;

c = CompositeView(w, Rect(50, 0, 300, 300));
a = Slider2D(c, Rect(0, 0, 100, 100)); // actually displays at (50, 0)
b = Slider2D(c, Rect(100, 100, 100, 100));

c.background = Color.rand;

w.front;
)

c.bounds_(Rect(100, 0, 300, 300)); // contents adjust since coords are relative
c.resize_(6); // contents adjust since coords are relative
::

subsection:: Keydown Bubbling

Key actions "bubble up" to the parent view if a view does not define one itself. In the following example, a and b do not have keyDown actions themselves, so the key event is passed to c, the parent, which defines the key down action. d's parent is the SCTopView, which has no key down action. See also link::Classes/View::.
code::
( //Click on the different views and hit keys on the keyboard.

w = Window.new;

c = CompositeView(w, Rect(0, 0, 200, 200)).background_(Color.grey.alpha_(0.3));

a = Slider2D(c,Rect(0, 0, 100, 100)).background_(Color.rand);
b = Slider2D(c,Rect(100, 100, 100, 100)).background_(Color.rand);

w.front;

c.keyDownAction = {
	"keydown bubbled up to c".postln;
};

// d is on window w, not on composite view c
d = Slider2D(w,Rect(200, 200, 100, 100));
d.background = Color.black;
)
::

subsection:: Decorators

A 'decorator' object can be set to handle layout management. All views added to the CompositeView will now be placed by the decorator. Currently the only one existing is link::Classes/FlowLayout::. You can use the ContainerView's addFlowLayout method as a short cut to assigning FlowLayout to decorator.
code::
(
a = Window.new;

b = CompositeView(a,Rect(0, 0, 500, 500));
b.decorator = FlowLayout(b.bounds);
//b.addFlowLayout; // you can also write this for convenience

// adding views to b automatically use the decorator
// no need to use parent.decorator.place
c = Slider2D(b,Rect(0, 0, 100, 100)); // size matters
d = Slider2D(b,Rect(0, 0, 100, 100)); // origin doesn't

a.front;
)
::

You can also use an empty composite view nicely as a spacer in link::Classes/VLayoutView::, link::Classes/HLayoutView::, or views that have a link::Classes/FlowLayout:: as their decorator.
code::
(
a = Window.new;
b = CompositeView(a, Rect(0, 0, 500, 500));

b.decorator = FlowLayout(Rect(0, 0, 500, 500));

Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);
CompositeView(b, Rect(0, 0, 70, 100)); // just used for spacing
Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);
Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);

b.decorator.nextLine;

Slider2D(b, Rect(0, 0, 100, 100)).background_(Color.rand);
Slider2D(b, Rect(0, 0, 100, 100)).background_(Color.rand);
CompositeView(b, Rect(0, 0, 70, 100)); // just used for spacing
Slider2D(b,Rect(0,0,100,100)).background_(Color.rand);

a.front;
)
::

subsection:: Hiding / Swapping

You can stack CompositeViews on top of each other and use a button show only one of them:
code::
(
var colors = [Color.blue, Color.red, Color.green];
a = Window.new;
q = 3;

b = Button(a, Rect(0, 0, 160, 20));

b.states = Array.fill(q, { arg i;
	[i.asString, Color.white, colors.wrapAt(i)]
});

b.action = { arg butt;
	p.visible = false;
	p = c.at(butt.value);
	p.visible = true;
};

c = Array.fill(q, { arg i;
	b = CompositeView(a, Rect(0, 25, 300, 300));
	b.background = colors[i].alpha_(0.2);
	b.visible = false;
	b;
});

5.do{ arg i; Slider(c[0], Rect(10, i * 30 + 10, 150, 25)).value_(1.0.rand) };
5.do{ arg i; Slider(c[1], Rect(i * 30 + 10, 10, 25, 150)).value_(1.0.rand) };
Slider2D(c[2], Rect(10, 10, 155, 150)).x_(1.0.rand).y_(1.0.rand);

p = c.at(0); // previous
p.visible = true; // show first one

a.front;
)
::

subsection:: Nested Example

In this example, the link::Classes/StaticText:: accepts mouse clicks, since container views can't:
code::
(
w = Window.new.front;
v = CompositeView.new(w, w.view.bounds.insetBy(10)).background_(Color.rand);
v.decorator = FlowLayout(v.bounds);

l = "SUPERCOLLIDER".scramble;
t = Array.fill(9, {arg i; var n, r, q;
	n = CompositeView.new(v, Rect(20, 20, 121, 121)).background_(Color.rand);
	q = StaticText(n, n.bounds.moveTo(0,0).insetBy(25)).string_(l[i]).align_(\center);
	q.enabled = true;
	q.font = Font("Geneva", 10);
	q.background_(Color.rand);
	q.mouseDownAction = {
		n.background_(Color.rand);
		q.font=q.font.size_(5 + q.font.size + 7 % 60)
	};
});
)
::


class::CondVar
categories::Scheduling
summary::Condition variable: block one or more threads until some condition is true

CondVar is a strong::condition variable::, a low-level synchronization tool which allows one or more threads to wait
until some condition becomes true. Although it has "variable" in the name, a condition variable doesn't wrap a variable
like, for example, link::Classes/FlowVar:: does. The condition referred to here is totally external to the CondVar
object, and can be any arbitrary state in your code. CondVar supports two fundamental operations: waiting and
signalling.  Waiting means suspending execution of the current thread until the relevant condition becomes true at some
point in the future. Signalling means indicating to other threads that the condition is now true, and that they should
continue executing.

When waiting on a CondVar, you may optionally pass a predicate (an object, usually a Function, that returns a
Boolean when evaluated with code::value::) as an argument. This leads to two general ways of using CondVar:

list::
## Manually checking your condition

	numberedlist::
	## First, check the condition in case it is already true.
	## If the condition is false, call wait or waitFor without a predicate. This suspends execution of the current thread.
	## When the CondVar is signalled or a timeout expires, the thread continues execution. You should then check the
		condition again, and continue waiting if it is not satisfied.
	::

This usually takes the form of a while loop of the form: code::while { /* condition is false */ } { /* wait on condition
*/ }::.

## Have CondVar check your condition for you: call wait or waitFor with a predicate, which takes care of the three steps above.
::

The following code illustrates these two approaches:

code::
// Version 1: `wait` without predicate -- while loop required
(
var c = CondVar();
// Our resource here will be a "message", which is set to some string
// when available, and set to empty when unavailable. This resource is
// initially unavailable.
var message = "";

// We add these delays to be clear about which thread runs first. Try
// changing these values to see what happens!
var waitThreadDelay = 1;
var signalThreadDelay = 2;

// These two forked threads will share the condition variable, `c`,
// and the condition state, `message`.
fork {
	waitThreadDelay.wait;
	while { message.isEmpty } {
		"Resource is unavailable, waiting now".postln;
		c.wait;
	};
	"Resource is available, message is: '%'\n".postf(message);
};

fork {
	signalThreadDelay.wait;
	message = "meow, world!";
	c.signalOne;
	"Resource was made available and waiting thread was signaled".postln;
};
)

// Version 2: `wait` with predicate -- no while loop required
(
var c = CondVar(), message = "";
var waitThreadDelay = 1;
var signalThreadDelay = 2;

fork {
	waitThreadDelay.wait;
	c.wait({ message.notEmpty });
	"Resource is available, message is: '%'\n".postf(message);
};

fork {
	signalThreadDelay.wait;
	message = "meow, world!";
	c.signalOne;
	"Resource was made available and waiting thread was signaled".postln;
};
)
::

Internally, CondVar is little more than a queue of threads which are waiting for the condition to become true. When
signaling, you have the choice of waking only the next waiting thread on the queue, if one exists (code::signalOne::),
or waking all waiting threads in the queue (code::signalAll::).

Note that threads in the queue do not resume immediately upon a signal. They are scheduled to resume immediately after
the signalling thread relinquishes control, either by code::yield:: or code::wait::, or by reaching the end of a playing
Routine. In the examples above, the code::signalOne:: Routine simply ends, so there is no need to code::yield:: anything.

In other languages, you may see that condition variables also use a mutex for synchronization. This is typically
necessary to protect shared access to the condition state.  However, since SuperCollider's interpreter is
single-threaded, each running thread implicitly holds the global interpreter mutex and more fine-grained mutexes are
unnecessary.

classmethods::

method::new

Create a new instance.

instancemethods::

private::prSleepThread, prWakeThread, prRemoveWaitingThread, prConvertTimeoutBeatsToSafeValue
private::prWait, prWaitFor

method::wait

The behavior depends on whether a code::predicate:: is given. If no code::predicate:: is given, this method simply
blocks the current thread until it is woken by code::signalOne:: or code::signalAll::. Otherwise, this method is
equivalent to code::while { predicate.value.not } { cond.wait }::. In other words, the thread only blocks if the
predicate is false, otherwise it blocks and only resumes once the thread has been signalled and the predicate is true.

This method must only be called within a link::Classes/Routine:: or Routine wrapper (for example, link::Classes/Task::
or link::Classes/Tdef::).

argument::predicate

A condition to be checked before blocking, and before resuming after being woken by code::signalOne:: or
code::signalAll::. If code::predicate.value.not:: is code::true::, execution resumes.  Typically, this is a Function
that returns a Boolean.

code::predicate:: is always executed on the thread which called code::wait::. If evaluating the predicate throws an
exception, the exception will propagate up on the thread which called code::wait::, and the thread will no longer be
waiting on this CondVar.

When code::wait:: returns, the predicate was true. It may not be true later, for instance if it depends on external
factors such as the system time or the state of the server.

returns::this object

method::waitFor

Similar to code::wait::, but the thread will also be unblocked if the relative timeout code::timeoutBeats:: expires.

If code::predicate:: is code::nil::, this method blocks the current thread until it is woken by code::signalOne:: or
code::signalAll::, or the timeout expires. If code::predicate:: is not code::nil::, this method returns immediately if
code::predicate.value:: is true, and otherwise blocks either until the timeout expires, or until the thread is woken by
code::signalOne:: or code::signalAll:: and code::predicate.value:: is true.

Because the interpreter's thread scheduler is not preemptive, an expiring timeout will only wake the thread if other
threads are idle. You are not guaranteed that the thread will be woken close to the timeout duration expiring, or even
that it will be woken at all. This could happen, for example, if some other thread enters an infinite loop and never
yields.

This method must only be called within a link::Classes/Routine:: or Routine wrapper (for example, link::Classes/Task:: or link::Classes/Tdef::).

argument::timeoutBeats

A duration in beats to wait before timing out. This value is converted according to the following rules: if its class is
Integer or Float, it remainds unchanged; otherwise, if it responds to code::asInteger::, this method is called;
otherwise, if it responds to code::asFloat::, this method is called. After this, if the resulting value is not an
Integer or a Float, an error is thrown. An error is also thrown if the resulting value is code::inf:: or not a number
(NaN).  If the resulting value is less than or equal to 0, code::waitFor:: returns the result of code::predicate.value::
immediately if code::predicate:: is not nil and code::false:: otherwise.

These strict checks are made to protect the thread which handles timeouts.

argument::predicate

A condition to be checked before blocking, and before resuming after being woken by code::signalOne:: or
code::signalAll:: or a timeout. Typically, this is a Function that returns a Boolean.

code::predicate:: is always executed on the thread which called code::wait::. If evaluating the predicate throws an
exception, the exception will propagate up on the thread which called code::wait::, and the thread will no longer be
waiting on this CondVar.

returns::

If the thread was woken because the timeout expired, then returns code::predicate.value:: if one was given and
code::false:: if code::predicate:: was code::nil::.  Otherwise, returns code::true::.

In other words, if code::predicate:: is non-nil, a return value of code::true:: means that code::predicate.value:: was
true when the thread resumed.

method::signalOne

Wakes one thread waiting on this Condition. Threads are woken in the order in which they called code::wait:: or
code::waitFor::. If a thread is woken and was waiting with a predicate, and that predicate is still code::false::, it
will code::wait:: again and be placed at the end of the queue of threads waiting on this CondVar. Another thread will
not be woken in that case.

returns::this object

method::signalAll

Wakes all threads waiting on this Condition. Threads are woken in the order in which they called code::wait:: or
code::waitFor::. If threads were waiting with predicates and their predicates are still code::false:: after being woken,
they will block again in the same order as before this method was called.

returns::this object

method::shallowCopy, copy, deepCopy

Throws a code::ShouldNotImplementError::; CondVars cannot be copied, shallow copied, or deep copied.

examples::

subsection::Simple interactive example

code::
(
c = CondVar();

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you to run 'c.signalOne'...".postln;
	c.wait;
	"the condition is no longer waiting".postln;
	1.wait;
	"waited for another second, now waiting for you...".postln;
	c.wait;
	"the condition is no longer waiting".postln;
	1.wait;
	"the end".postln;
}.play;
)

// Run this line to unblock the routine
c.signalOne;
::

subsection::Producer-consumer queue: single producer, single consumer

The following example shows a CondVar used to manage a simple producer-consumer queue with one consumer and one producer.

The producer thread adds "tasks" to the queue, while the consumer thread removes and "processes" them. When there is no
work to do, the consumer has to wait until work is available. When there is too much work to do, the producer thread
should avoid creating more tasks. Try playing with the wait times for each thread to see what happens.

code::
(
var full = CondVar(), empty = CondVar();
var queue = Array();
var maxQueueSize = 5;
// The producer and consumer will wait between tasks for a duration
// somewhere in these ranges.  Over time, you'll see the queue grow
// and shrink between 0 and maxQueueSize, but CondVar keeps everything
// synchronized.
var producerWaitTimeRange = [0.1, 1];
var consumerWaitTimeRange = [0.1, 1];

// The "wait"s in each thread simulate doing some task asynchronously,
// during which time other tasks might be created. If our tasks were
// always created and/or executed synchronously, there would be no
// need for a queue shared between two threads.

// producer thread
fork {
	var counter = 0; // Our "task" is just an increasing number for now
	var task;
	loop {
		// This guarantees that when we return from `wait`, there is
		// enough room in the queue to add another task. To get past
		// this, we have to wait until the consumer calls
		// signalOne.
		full.wait({ queue.size < maxQueueSize });

		task = counter;
		counter = counter + 1;
		queue = queue.add(task);
		postf("Producer created a task: %. Current queue size: %\n",
			task, queue.size);

		// Now that we've added a task to the queue, we have to let
		// the consumer thread know in case it was waiting on us.
		empty.signalOne;

		wait(rrand(producerWaitTimeRange[0], producerWaitTimeRange[1]));
	}
};

// consumer thread
fork {
	var task;
	loop {
		// As in the producer thread, this blocks us until both the
		// queue has something in it, and we've been signaled by the
		// producer.
		empty.wait({ queue.notEmpty });

		task = queue.removeAt(0);
		postf("Consumer processed a task: %. Current queue size: %\n",
			task, queue.size);

		// We need to signal to the producer, in case it was waiting
		// on us to insert something into the queue.
		full.signalOne;

		wait(rrand(consumerWaitTimeRange[0], consumerWaitTimeRange[1]));
	}
};
)
::

subsection::Producer-consumer queue: multiple producers, multiple consumers

Here is another producer-consumer example with multiple producers and multiple consumers. Note how easily the code above
can be generalized.

code::
(
var full = CondVar(), empty = CondVar();
var queue = Array();
var counter = 0; // The task counter is shared among all producers this time

// Try experimenting with these parameters
var maxQueueSize = 10;
var numProducers = 3;
var numConsumers = 3;
var producerWaitTimeRange = [0.3, 1.5];
var consumerWaitTimeRange = [0.3, 1.5];

// producer threads
numProducers.do { |index|
	fork {
		var task;
		loop {
			full.wait({ queue.size < maxQueueSize });

			task = counter;
			counter = counter + 1;
			queue = queue.add(task);
			postf("Producer % created a task: %. Current queue size: %\n",
				index, task, queue.size);

			// Even though there might be multiple consumers waiting
			// on this condition, only one of them can possibly make
			// use of the new task we just created.  So we use
			// signalOne instead of signalAll.
			empty.signalOne;

			wait(rrand(producerWaitTimeRange[0], producerWaitTimeRange[1]));
		}
	}
};

// consumer thread
numConsumers.do { |index|
	fork {
		var task;
		loop {
			empty.wait({ queue.notEmpty });

			task = queue.removeAt(0);
			postf("Consumer % processed a task: %. Current queue size: %\n",
				index, task, queue.size);

			full.signalOne;

			wait(rrand(consumerWaitTimeRange[0], consumerWaitTimeRange[1]));
		}
	}
}
)
::

subsection::Using timeouts

Sometimes, you want to wait on an external condition that may never come true, or you want to do something else in case
you've been waiting for a long time. This is a good place to use code::waitFor::. In our example, we're using a Routine
that sometimes fails to set the desired condition to simulate this "unreliable" task. Some practical examples of this
might be a long asynchronous task on the server or in a call to unixCmd that doesn't finish in time, or doesn't produce
the result we were looking for.

code::
(
var condition = CondVar();

// Our "unreliable" task will half the time signal us that it's done,
// but half the time it will fail to do so.
fork {
	var coinFlip;
	1.wait;
	coinFlip = 0.5.coin;
	postf("Flip gave us: % ; %signalling the condition\n", coinFlip,
		if(coinFlip, "not ", ""));
	if(coinFlip) { condition.signalOne };
};

fork {
	// In this case, the random coin flip succeeding is our entire
	// condition, so we don't pass any predicate to waitFor.
	if(condition.waitFor(2)) {
		"Coin flip succeeded!".postln
	} {
		"Coin flip failed, and we timed out".postln
	};
};
)
::

We can also rewrite this example so that we get signalled no matter what, but the condition might still not come true.

code::
(
var condition = CondVar();
var coinFlip = false;

fork {
	// The coin flip now has multiple chances to succeed, but it still
	// might not do so within our 2-second window.
	5.do { |i|
		0.2.wait;
		coinFlip = 0.25.coin;
		"Flip number %: got %\n".postf(i + 1, coinFlip);
		condition.signalOne;
	}
};

fork {
	// We don't exit `waitFor` unless we timeout, or we get signalled
	// *and* the predicate is true.
	if(condition.waitFor(2, { coinFlip })) {
		"Coin flip succeeded!".postln
	} {
		"Coin flip failed, and we timed out".postln
	};
};
)
::


CLASS::Condition
categories::Scheduling
summary::Block the execution of a thread

CLASSMETHODS::

method::new
Create a new instance, set the strong::test:: variable.

INSTANCEMETHODS::

method::test
Answer whether the condition will block or not (boolean).

method::wait
Wait until the condition is true and signalled. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
c = Condition(false); fork { 0.5.wait; "started ...".postln; c.wait;  "... and finished.".postln };
c.test = true;
c.signal;
::

method::hang
Wait for strong::value:: time, regardless of test. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
c = Condition.new; fork { 0.5.wait; "started ...".postln; c.hang;  "... and finished.".postln };
c.unhang;
::

method::signal
If link::#-test:: is true, reschedule blocked threads.

method::unhang
Resume threads.

EXAMPLES::

code::
(
c = Condition.new(false);

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
		c.test = false;
		c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"the end".postln;
}.play;
)

// continue
(
c.test = true;
c.signal;
)

// a typical use is a routine that can pause under certain conditions:
(
c = Condition.new;
fork { loop { 1.wait; "going".postln; c.wait } };
)
c.test = true; c.signal;
c.test = false;
::

code::
// the same, using hang

(
c = Condition.new;

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
}.play;
)

// continue
c.unhang;
::

Waiting for Synths to end (waitForFree) uses a Condition implicitly:
code::
(
SynthDef(\help, { |out|
	var mod = LFNoise2.kr(ExpRand(0.5, 2)) * 0.5;
	var snd =  mod * Blip.ar(Rand(200, 800) * (mod + 1));
	Out.ar(out, snd);
	FreeSelf.kr(mod < 0); // free the synth when amplitude goes below 0.
}).add;
)

(
fork {
	10.do {
		"started a synth".postln;
		Synth(\help).waitForFree;
		"This one ended. Wait a second,  I will start the next one.".postln;
		1.wait;
	};
	"This is it.".postln;
}
);
::


class:: ContiguousBlockAllocator
summary:: for better handling of dynamic allocation
related:: Classes/Server, Classes/PowerOfTwoAllocator, Guides/MultiClient_Setups
categories:: Control

description::

The default allocator used in servers to allocate bus numbers and buffer numbers. Compared to its predecessor, link::Classes/PowerOfTwoAllocator::, it can reserve a block of numbers at the beginning of its range, and it can offset its entire range of numbers to support multiple clientIDs.

ClassMethods::

method::new
Create a new allocator with emphasis::size:: slots. You may block off the first emphasis::pos:: slots (the server's audioBusAllocator does this to reserve the hardware input and output buses).

InstanceMethods::

private::prReserve, prSplit, addToFreed, blocks, findNext, findPrevious, prFindNext, prFindPrevious, removeFromFreed

subsection:: Public interface

method::alloc
Return the starting index of a free block that is emphasis::n:: slots wide. The default is 1 slot.

Note that the returned address is not guaranteed to be the lowest possible address that can satisfy the requested size. It should be adjacent to a previously allocated block, however (to minimize fragmentation of the address space).

method::free
Free a previously allocated block starting at emphasis::address::.

method::reserve
Mark a specific range of addresses as used so that the alloc method will not return any addresses within that range. 

method::findAvailable
Given an integer width of a desired block, find and return a code::ContiguousBlock:: object whose code::start:: is the beginning address of the block and whose code::size:: is the width. This method only queries the allocator; it does not change the state. If you obtain an address using code::findAvailable::, there is no guarantee that a later call will not return the same address. So, in general, use link::#-alloc:: to request an address. (code::alloc:: calls code::findAvailable:: and then code::reserve::.)

This method could be considered "half-private": It may be useful for queries, but in general, you can get everything you need from link::#-alloc::, link::#-free:: and link::#-reserve::.

subsection:: Status and debugging

You may query these state variables, but it is not recommended to change them outside of the public interface.

method::debug
	Post internal state of allocator for debugging.

method::size
	The number of id numbers it can allocate.

method::pos
	The allocator's offset for a reserved block (e.g. for hardware input and output buses).

method::addrOffset
	The offset of the allocator's address range, which is used to accomodate multiple clientIDs.

method::top
	The address of the last empty block.

EXAMPLES::

code::
c = ContiguousBlockAllocator(10);
c.alloc(5);  // 0 = first available
c.alloc(2);  // 5
c.alloc(4);  // nil -- no block of 4 available

c.free(1);  // no-op: nothing at 1 to free

c.free(0);

c.alloc(3);  // 0: tries to reuse previously-freed space first

c.alloc(3);  // 7


// Adjacency
c = ContiguousBlockAllocator(24);

// reserve every 4th
(0, 4 .. 23).do { |i| c.reserve(i) };

10.do { c.findAvailable(1).postln };
::

In the last line of the second example, code::findAvailable:: may locate any of indices 1, 5, 9, 13, or 17. (21 would not be used until a suitable block could not be found in the other empty spaces.) If you were to allocate a single address, then the empty block of three would always be reduced to an empty block of two (instead of dividing the empty space in half and having two empty single-address blocks).

It may be surprising that the algorithm does not favor lower-index blocks, but if two addresses A and B have been previously used and freed, there is no inherent reason to prefer A if A < B.


class:: Control
summary:: Bring signals and floats into the ugenGraph function of a SynthDef.
related:: Classes/NamedControl, Classes/LagControl, Classes/TrigControl
categories::  UGens>Synth control

Description::

A Control is a UGen that can be set and routed externally to interact with a running Synth.
Typically, Controls are created from the arguments of a SynthDef function.

Generally you do not create Controls yourself. (See Arrays example
below).

The rate may be either .kr (continuous control rate signal) or .ir (a
static value, set at the time the synth starts up, and subsequently
unchangeable). For .ar, see link::Classes/AudioControl::

SynthDef creates these when compiling the ugenGraph function. They are
created for you, you use them, and you don't really need to worry about
them if you don't want to.

For a more concise combination of name, default value and lag, see link::Classes/NamedControl::

classmethods::

method::kr, ir

argument::values

default values.


method::names

argument::names

adds control names to the SynthDef.


Examples::

code::
(
SynthDef(\help_Control, { | freq = 200 |

	freq.inspect; // at the time of compiling the def

}).add
);

// synonym:
(
SynthDef(\help_Control, {

	\freq.kr(200).inspect; // at the time of compiling the def

}).add
);
::

What is passed into the ugenGraph function is an link::Classes/OutputProxy::, and its source is a Control.

The main explicit use of Control is to allow Arrays to be sent to running Synths:
code::
// a synth def that has 4 partials
(
SynthDef(\help_Control, { arg out=0, i_freq;
	var klank, harm, amp, ring;

	// harmonics
	harm = Control.names([\harm]).ir(Array.series(4, 1, 1).postln);
	// amplitudes
	amp = Control.names([\amp]).ir(Array.fill(4, 0.05));
	// ring times
	ring = Control.names([\ring]).ir(Array.fill(4, 1));

	klank = Klank.ar(`[harm, amp, ring], { ClipNoise.ar(0.01) }.dup, i_freq);

	Out.ar(out, klank);
}).add;
)

a = Synth(\help_Control, [\i_freq, 300, \harm, [1, 3.3, 4.5, 7.8]]);
a.free;
a = Synth(\help_Control, [\i_freq, 300, \harm, [2, 3, 4, 5]]);
a.free;

(
SynthDef(\help_Control_Sines, { arg out=0;
	var sines, control, numsines;
	numsines = 20;
	control = Control.names(\array).kr(Array.rand(numsines, 400.0, 1000.0));
	sines = Mix(SinOsc.ar(control, 0, numsines.reciprocal)) ;
	Out.ar(out, sines ! 2);
}).add
)

b = Synth(\help_Control_Sines);
b.setn(\array, Array.rand(20, 200, 1600));
b.setn(\array, Array.rand(20, 200, 1600));



(
SynthDef(\help_Control_DynKlank, { arg out=0, freq = 440;
	var klank, harm, amp, ring;

	// harmonics
	harm = Control.names(\harm).kr(Array.series(4, 1, 1));
	// amplitudes
	amp = Control.names(\amp).kr(Array.fill(4, 0.05));
	// ring times
	ring = Control.names(\ring).kr(Array.fill(4, 1));
	klank = DynKlank.ar(`[harm, amp, ring], {ClipNoise.ar(0.003)}.dup, freq);
	Out.ar(out, klank);
}).add
)

a = Synth(\help_Control_DynKlank, [\freq, 300]);
b = Synth(\help_Control_DynKlank, [\freq, 400]);


a.setn(\harm,   Array.rand(4, 1.0, 4.7))
a.setn(\amp, Array.rand(4, 0.005, 0.1))
a.setn(\ring, Array.rand(4, 0.005, 1.0))

b.setn(\harm,   Array.rand(4, 1.0, 4.7))
b.setn(\amp, Array.rand(4, 0.005, 0.1))
b.setn(\ring, Array.rand(4, 0.005, 1.0))
::

subsection:: Symbols

Inside SynthDefs and UGen functions, symbols can be used to conveniently specify control inputs of different rates and with lags (see: link::Classes/NamedControl::, and link::Classes/Symbol::)

definitionlist::
## code:: \name.kr(val, lag) ::
|| Return a control rate link::Classes/NamedControl:: input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.
code::
a = { SinOsc.ar(\freq.kr(440, 1.2)) }.play;
a.set(\freq, 330);
a.release;
a = { SinOsc.ar(\freq.kr([440, 460], 1.2)) }.play;
a.setn(\freq, [330, 367]);
a.release;
::

## code:: \name.ar(val, lag) ::
|| Return an audio rate link::Classes/NamedControl:: input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.

## code:: \name.ir(val) ::
|| Return an initialization rate link::Classes/NamedControl:: input with a default value (val). If val is an array, the control will be multichannel.

## code:: \name.tr(val) ::
|| Return a link::Classes/TrigControl:: input with a default value (val). If val is an array, the control will be multichannel.
code::
a = { Ringz.ar(T2A.ar(\trig.tr), \freq.kr(500, 1), 0.8) }.play;
a.set(\freq, 330, \trig, 1);
a.set(\freq, 830, \trig, 1);
a.release;
::
::



class:: ControlDur
summary:: Duration of one block
categories:: UGens>Info
related:: Classes/ControlRate

description::
Returns the current block duration of the server in seconds. Equivalent to  1 / link::Classes/ControlRate::.

classmethods::
method:: ir

examples::
code::
{ ControlDur.ir.poll }.play;

{ (1/ControlDur.ir).poll }.play;

{ ControlRate.ir.poll }.play;
::


class:: ControlName
summary:: Object to store control information of SynthDef (used internally)
related:: Classes/SynthDesc, Classes/SynthDef
categories:: UGens>Synth control

description::
For an explicit creation of control names see: link::Classes/NamedControl::, link::Classes/Control::

examples::
code::
a = SynthDescLib.global; // the global library of SynthDescs
x = a.synthDescs.at(\default); // get the default SynthDesc
x.controls.do { |ctl| [\name, ctl.name, \defaultValue, ctl.defaultValue].postln };"";
::

instancemethods::
private:: printOn

method::name
The name of the control.
returns:: a link::Classes/Symbol::

method::index
The index of the control.
returns:: an link::Classes/Integer::

method::rate
The rate of the control.
returns:: a link::Classes/Symbol:: like code::'audio':: or code::'control'::

method::defaultValue
Default value of this control. Will be an link::Classes/Array:: for multichannel controls.

method::numChannels
The number of channels.
returns:: an link::Classes/Integer::

method:: spec
The link::Classes/ControlSpec:: for this control. If set, it will be added to the specs metadata for the current SynthDef.at

code::
(
d = SynthDef(\tone, { |out = 0, freq = 200|
	var sig;

	freq.spec = ControlSpec(20, 20000);
	sig = SinOsc.ar(freq);

	Out.ar(out, sig);
}).add;
)

d.specs.freq.postln;
::


class:: ControlRate
summary:: Server control rate.
related:: Classes/RadiansPerSample, Classes/SampleDur, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Get the current control rate of the server.


classmethods::

method::ir

returns::
The current control rate of the server.

equivalent to 1 / link::Classes/ControlDur::

Examples::
code::
{ ControlRate.ir.poll }.play;
::

compare ControlRate (.kr) and link::Classes/SampleRate:: (.ar)
code::
( 
{
	var freq = 400;
	
	// pulses at control rate:
	(LFPulse.ar(ControlRate.ir,0,0.01,2,-1) * [1,0,0,0]) 
	
	// Sinewave at control rate:
	+ (SinOsc.kr(freq) * [0,1,0,0])
	
	// pulses at sample rate:
	+ (LFPulse.ar(SampleRate.ir/2,0,0.1,2,-1) * [0,0,1,0]) 
	
	// Sinewave at sample rate:
	+ (SinOsc.ar(freq) * [0,0,0,1])
	
}.plot(0.01);
)
::

listen to difference:
code::
(
{
	K2A.ar( SinOsc.kr(400, mul:[1,0]))
	     +  SinOsc.ar(400, mul:[0,1])
}.scope
)
::

More about difference between .kr (control rate) and .ar (audio rate) can be found in link::Tutorials/Mark_Polishook_tutorial/08_Rates::

play a sine tone at control rate
code::
{ SinOsc.ar(ControlRate.ir) * 0.1 }.play;
::



class:: ControlSpec
summary:: numerical input specification
related:: Classes/Warp
categories:: Control, Spec

description::

The original, and most common spec (see link::Classes/Spec::). A ControlSpec is used by GUI sliders and knobs to specify the range and curve of the controls. ControlSpec may be used in many ways to map from linear 0..1 range to your desired range and back.

The most common way to create a ControlSpec is by
code::
anObject.asSpec // the object may be an array or a symbol
::

ClassMethods::

private::initClass

method::new

argument::minval
The minimum value of the range.

argument::maxval
The maximium value of the range.

argument::warp
a link::Classes/Warp::, a symbol (e.g. \lin or \exponential: Default value is \lin), or something else that returns a Warp when sent the message .asWarp. A CurveWarp is defined by a number.

argument::step
The smallest possible increment.

argument::default
The default value.

argument::units
The units, e.g. "hz". Used by some gui's as a unit label.

argument::grid

InstanceMethods::

method::map
Maps and constrains a strong::value:: between 0 and 1 to the range between minval and maxval.

method::unmap
Maps and constrains a strong::value:: between minval and maxval to the range between 0 and 1.
code::
g = ControlSpec(0.01, 2000, \exp, 0.1, 220, "Hz");
g.map(0.5); // convert from [0..1] to [0.01..2000]
g.unmap(1000); // convert from [0.01..2000] to [0..1]

// fore and back translation should be close to identical:
g.unmap(g.map(0.5));
::

method::clipLo
The lower of maxval and minval.

method::clipHi
The higher of maxval and minval.

method::constrain
Returns code::value.asFloat.clip(clipLo, clipHi).round(step)::.

method::range
Returns code::maxval - minval::.

method::guessNumberStep
Used for EZ GUI classes for guessing a sensible strong::step:: if none is specified.

method::gridClass
Returns the link::Classes/AbstractGridLines:: subclass corresponding to the current spec, in particular its warp behavior.

method::grid
Get/set an instance of the link::Classes/AbstractGridLines:: subclass that describes the range and warp behavior of the current spec, e.g. for use by link::Classes/DrawGrid:: for drawing grids in link::Classes/Plotter::.

Examples::

code::
g = ControlSpec(0.01, 2000, \exp, 0.1, 220, "Hz");

// or alternatively

[0.001, 2000, \exp, 0.1, 220, "hz"].asSpec;

// or add it to the ControlSpec.specs IdentityDictionary:

ControlSpec.specs[\myFreq] = ControlSpec(0.01, 2000, \exp, 0.01, 440, units: "Hz");
::

code::
// array is used as arguments to ControlSpec.new(minval, maxval, warp, step, default)
[300,3000,\exponential,100].asSpec.dump
Instance of ControlSpec {    (0313FC08, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Integer 300
    maxval : Integer 3000
    warp : Symbol 'exponential'
    step : Integer 100
    default : Integer 300
}

// partially specified ...
[-48,48].asSpec.dump
Instance of ControlSpec {    (0313FF18, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Integer -48
    maxval : Integer 48
    warp : Symbol 'linear'
    step : Float 0
    default : Integer -48
}

// a Symbol
\freq.asSpec.dump
Instance of ControlSpec {    (180F4910, gc=3C, fmt=00, flg=00, set=03)
  instance variables [8]
    minval : Integer 20
    maxval : Integer 20000
    warp : instance of ExponentialWarp (17FEDB30, size=1, set=1)
    step : Integer 0
    default : Integer 440
    units : " Hz"
    clipLo : Integer 20
    clipHi : Integer 20000
}


// nil becomes a default ControlSpec
nil.asSpec.dump
Instance of ControlSpec {    (0313FF18, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Float 0
    maxval : Float 1
    warp : Symbol 'linear'
    step : Float 0
    default : Float 0
}
::

code::
// make a frequency spec with an exponential range from 20 to 20000,
// give it a rounding of 30 (Hz)
a = \freq.asSpec;
a.step = 100;

// equivalent:
a = [20, 20000, 'exp', 100, 440].asSpec;
a.dump;

a.constrain(800); // make sure it is in range and round it.
a.constrain(803); // make sure it is in range and round it.

a.map(0.5);
a.map(0.0); // returns min
a.map(1.5); // exceeds the area: clip, returns max

a.unmap(4000);
a.unmap(22.0);
::

code::
// like in envelopes, a CurveWarp is created by a number:

a = [0, 1, -4].asSpec;
a.map(0.5);
a.unmap(0.99);
a.map((0..10).normalize).plot;

// look at different distributions:
(
var invals = (0..10).normalize;
(-4..4).do { |curve|
	var a = [0, 1, curve].asSpec;
	a.map(invals).plot;
}
);
::

code::
// using spec for sliders:
(
var w, c, d;
w = Window.new("control", Rect(128, 64, 340, 160));
w.front;
c = Slider.new(w, Rect(10, 10, 300, 30));
d = StaticText.new(w, Rect(10, 40, 300, 30));
c.action = {
	d.string = "unmapped value"
	+ c.value.round(0.01)
	+ "......"
	+ "mapped value"
	+ a.map(c.value)
};
)
::

code::
// ControlSpec-map can also be used to map ugens
(
var spec;
spec = [ 100, 18000, \exp].asSpec;
{
	var freq,osc;
	osc = SinOsc.kr(0.1).range(0,1);
	freq = spec.map( osc );

	freq.dump;// BinaryOpUGen

	SinOsc.ar(
		freq.poll
	)
}.play
)
::


class:: Convolution
summary:: Real-time convolver.
related:: Classes/Convolution2, Classes/Convolution2L, Classes/Convolution3
categories::  UGens>FFT, UGens>Convolution


Description::

Strict convolution of two continuously changing inputs. Also see
link::Classes/Convolution2::  for a cheaper CPU cost alternative for the
case of a fixed kernel which can be changed with a trigger message.


See also  link::http://www.dspguide.com/ch18.htm::  by Steven W.
Smith.


classmethods::

method::ar

argument::in

Processing target.


argument::kernel

Processing kernel.


argument::framesize

Size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).
Convolution uses twice this number internally.
Note that the convolution gets progressively more expensive to run for higher powers!
The maximum value you can use is 2^16=16384.
(This upper limit is half of "SC_FFT_MAXSIZE" defined in the SC source code.)
Larger convolutions than this can be done using link::Classes/PartConv::.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(

{
	var input, kernel;

	input = SoundIn.ar(0);
	kernel = Mix.ar(LFSaw.ar([300,500,800,1000] * MouseX.kr(1.0, 2.0), 0, 1.0));

	// must have power of two framesize
	Convolution.ar(input,kernel, 1024, 0.5)
}.play;

)

(
// must have power of two framesize- FFT size will be sorted by Convolution to be double this
// maximum is currently a=8192 for FFT of size 16384

a = 2048;
s = Server.local;

// kernel buffer
g = Buffer.alloc(s, a, 1);
)

(

// random impulse response

g.set(0, 1.0);

100.do({ arg i; g.set(a.rand, 1.0.rand) });


{
	var input, kernel;

	input = SoundIn.ar(0);
	kernel = PlayBuf.ar(1, g.bufnum,BufRateScale.kr(g.bufnum), 1, 0, 1);

	Convolution.ar(input, kernel, 2 * a, 0.5)
}.play;

)
::



class:: Convolution2
summary:: Real-time fixed kernel convolver.
related:: Classes/Convolution, Classes/Convolution2L, Classes/Convolution3
categories::  UGens>FFT, UGens>Convolution


Description::

Strict convolution with fixed kernel which can be updated using a trigger
signal.

Internally, this unit uses FFT to accelerate the calculation, which means that
(a) you must specify a "framesize", and
(b) if the kernel is longer than this framesize, the end of it will be ignored.

See also link::http://www.dspguide.com/ch18.htm:: by Steven W.
Smith.


classmethods::

method::ar

argument::in

Processing target.


argument::kernel

Buffer index for the fixed kernel, may be modulated in
combination with the trigger. It's size must be <= framesize.


argument::trigger

Update the kernel on a change from non-positive to positive
value.


argument::framesize

Size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).
Convolution uses twice this number internally.
Note that the convolution gets progressively more expensive to run for higher powers!
The maximum value you can use is 2^16=16384.
(This upper limit is half of "SC_FFT_MAXSIZE" defined in the SC source code.)
Larger convolutions than this can be done using link::Classes/PartConv::.

argument::mul

argument::add

Examples::

code::
( // allocate three buffers
b = Buffer.alloc(s,2048);
c = Buffer.alloc(s,2048);
d = Buffer.alloc(s,2048);

b.zero;
c.zero;
d.zero;
)

(
50.do({ |it| c.set(20*it+10, 1.0.rand); });
3.do({ |it| b.set(400*it+100, 1); });
20.do({ |it| d.set(40*it+20, 1); });
)


(
SynthDef("conv-test", { |out, kernel, trig = 0|
	var input;

	input = Impulse.ar(1);

	//must have power of two framesize
	Out.ar(out, Convolution2.ar(input, kernel, trig, 2048, 0.5));
}).add

)


x = Synth.new("conv-test",[\kernel,b.bufnum]);

// changing the buffer number:
x.set(\kernel,c.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.
x.set(\kernel,d.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20*it+10, 1); });// changing the buffers' contents
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.

x.set(\kernel,b.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.


// next example
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
	{ var input, kernel;

	input=SoundIn.ar(0);

	//must have power of two framesize
	Out.ar(0,Convolution2.ar(input,b.bufnum,0,512, 0.5));
	 }.play;

)


// another example
(
//must have power of two framesize- FFT size will be sorted by Convolution2 to be double this
//maximum is currently a=8192 for FFT of size 16384
a=2048;
s = Server.local;
//kernel buffer
g = Buffer.alloc(s,a,1);
)

(
g.set(0,1.0);
100.do({ arg i; g.set(a.rand, (i+1).reciprocal)});
)

(
// random impulse response

{
	var input,inputAmp,threshhold,gate;

	input = SoundIn.ar(0);
	inputAmp = Amplitude.kr(input);
	threshhold = 0.02;	// noise gating threshold
	gate = Lag.kr(inputAmp > threshhold, 0.01);

	Convolution2.ar(input*gate,g.bufnum,0, a, 0.5)
}.play;

)

// one last example
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);
)

(
{
	var input, kernel;

	input = SoundIn.ar(0);

	//must have power of two framesize
	Convolution2.ar(input,b.bufnum,0, 512, 0.5)
}.play;

)
::

Instead of triggering the kernel update yourself, as in the first example, you can use a UGen trigger signal to do so. In the next example, we use two Convolution2 UGens in order to continuously and smoothly change the impulse response: link::Classes/RecordBuf:: is used to record a random frequency link::Classes/Saw:: oscillator every code::trigPeriod:: seconds.
Right after the recording (trigPeriod gets delayed by the buffer duration link::Classes/BufDur::, using the link::Classes/TDelay:: UGen) the two convolution UGens alternatively update their kernels (using two triggers convTrigs). At the frequency of the kernel updates a crossfader link::Classes/XFade2:: moves between conv1 and conv2, using a triangle oscillator link::Classes/LFTri:: at half the trigger frequency as a panning input. The result is a constantly shifting spectral colorization of the Dust impulses:

code::
b = Buffer.alloc( s, 2048, 1, _.zeroMsg );
(
	x = { arg i_kernel, density = 100, trigPeriod = 5.0, cutOff = 1000, minFreq = 200, maxFreq = 2000;
		var input, trigFreq, recTrig, irSig, convTrig, convTrigs, bufFrames, conv1, conv2;

		input		= LPF.ar( Dust2.ar( density ), cutOff );
		trigFreq		= trigPeriod.reciprocal;
		recTrig		= Impulse.kr( trigFreq );
		irSig		= Saw.ar( TExpRand.kr( minFreq, maxFreq, recTrig ), 0.4 );
		RecordBuf.ar( irSig, i_kernel, recTrig, loop: 0, trigger: recTrig );
		convTrig		= TDelay.kr( recTrig, BufDur.ir( i_kernel ));
		// split updates across two triggers. Note that [ 1, 0 ] creates
		// a MultiChannel expansion!
		convTrigs		= PulseDivider.kr( convTrig, 2, [ 1, 0 ]);
		bufFrames		= BufFrames.ir( i_kernel );
		// create the two alternatingly updated convolution ugens
		#conv1, conv2	= Convolution2.ar( input, i_kernel, convTrigs, bufFrames );

		XFade2.ar( conv1, conv2, LFTri.kr( trigFreq * 0.5, 1 )) ! 2;
	}.play( s, [ \i_kernel, b ]);
)

x.set( \trigPeriod, 0.1 );	// fast changes
x.set( \trigPeriod, 10.0 );	// slow changes
x.free;	// delete synth
::



class:: Convolution2L
summary:: Real-time convolver with linear interpolation
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution3, Classes/StereoConvolution2L
categories::  UGens>FFT, UGens>Convolution

Description::
Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.

See emphasis:: Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing: chapter 18:: -
http://www.dspguide.com/ch18.htm

classmethods::
private:: categories

method::ar

argument::in
processing target

argument::kernel
buffer index for the fixed kernel, may be modulated in combination with the trigger

argument::trigger
update the kernel on a change from <=0 to >0

argument::framesize
size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).
Convolution uses twice this number internally.
Note that the convolution gets progressively more expensive to run for higher powers!
The maximum value you can use is 2^16=16384.
(This upper limit is half of "SC_FFT_MAXSIZE" defined in the SC source code.)
Larger convolutions than this can be done using link::Classes/PartConv::.


argument::crossfade
The number of periods over which a crossfade is made. The default is 1. This must be an integer.

argument::mul

argument::add

Examples::

code::
// allocate three buffers
(
b = Buffer.alloc(s, 2048);
c = Buffer.alloc(s, 2048);
d = Buffer.alloc(s, 2048);

b.zero;
c.zero;
d.zero;
)

(
50.do { |it| c.set(20 * it + 10, 1.0.rand) };
3.do { |it| b.set(400 * it + 100, 1) };
20.do { |it| d.set(40 * it + 20, 1) };
)
::
code::
(
SynthDef(\conv_test, { |out, kernel, t_trig=0|
	var input = Impulse.ar(1);
	var framesize = 2048; // must have power of two
	var result = Convolution2L.ar(input, kernel, t_trig, framesize, 1, 0.5);
	Out.ar(out, result);
}).add
)

x = Synth(\conv_test, [\kernel, b]);

// changing the buffer number:
x.set(\kernel, c);
x.set(\t_trig, 1); // after this trigger, the change will take effect.
x.set(\kernel, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

d.zero;
40.do { |it| d.set(20 * it + 10, 1) };// changing the buffers' contents
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
::

code::
// longer crossfade
(
SynthDef(\conv_test2, { |out, kernel, t_trig=0|
	var input = Impulse.ar(1);
	var framesize = 2048; // must have power of two
	var result = Convolution2L.ar(input, kernel, t_trig, 2048, 5, 0.5);
	Out.ar(out, result);
}).add
)

x = Synth(\conv_test2, [\kernel, b]);

// changing the buffer number:
x.set(\kernel, c);
x.set(\t_trig, 1); // after this trigger, the change will take effect.
x.set(\kernel, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

d.zero;

40.do { |it| d.set(20 * it + 10, 1) };// changing the buffers' contents

x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
::

code::
// next example

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var input = SoundIn.ar(0);
	var framesize = 2048; // must have power of two
	Convolution2L.ar(input, b, 0, 512, 1, 0.5);
}.play
)
::

code::
// another example

(
// must have power of two framesize- FFT size will be sorted by Convolution2 to be double this
// maximum is currently a=8192 for FFT of size 16384
a = 2048;
// kernel buffer
g = Buffer.alloc(s, a, 1);
)

(
g.set(0, 1.0);
100.do { |i| g.set(a.rand, (i + 1).reciprocal) };
)

(
// random impulse response
{
	var input, inputAmp, threshhold, gate;

	input = SoundIn.ar(0);
	inputAmp = Amplitude.kr(input);
	threshhold = 0.02;	// noise gating threshold
	gate = Lag.kr(inputAmp > threshhold, 0.01);

	Convolution2L.ar(input * gate, g, 0, a, 1, 0.5);
}.play
)

g.free;

::

code::
// one last example
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1, 2, 3, 4, 5, 6], true, true, true);
)

(
{
	var input = SoundIn.ar(0);
	var framesize = 512;
	Convolution2L.ar(input, b, 0, framesize, 1, 0.5);
}.play
)

b.free;

::



class:: Convolution3
summary:: Time based convolver.
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution2L
categories::  UGens>Convolution

Description::
Strict convolution with fixed kernel which can be updated using a trigger signal. The convolution is performed in the time domain.


note::
Doing convolution in time domain is highly inefficient, and probably only useful for either very short kernel sizes, or for control rate signals.
See link::Classes/Convolution2:: and link::Classes/Convolution2L:: for more efficient convolution UGens.
::

classmethods::
private:: categories

method::ar, kr

argument::in
processing target

argument::kernel
buffer index for the fixed kernel, may be modulated in combination with the trigger

argument::trigger
update the kernel on a change from <=0 to >0

argument::framesize
maximum size of the buffer containing the kernel

argument:: mul

argument:: add


class:: Crackle
summary:: Chaotic noise function.
related:: Classes/LatoocarfianN, Classes/Logistic
categories::  UGens>Generators>Stochastic


Description::

A noise generator based on a chaotic function.


classmethods::

method::ar, kr

argument::chaosParam

A parameter of the chaotic function with useful values from
just below 1.0 to just above 2.0. Towards 2.0 the sound crackles.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ Crackle.ar(1.95, 0.5) }.play;

// modulate chaos parameter
{ Crackle.ar(Line.kr(1.0, 2.0, 3), 0.5, 0.5) }.play;
::



class:: CuspL
summary:: Cusp map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/CuspN

description::
A linear-interpolating sound generator based on the difference equation:

teletype::
	x(n+1) = a - b * sqrt(|x(n)|)
::

sclang code translation:

code::
(
var a = 1.0, b = 1.9, xi = 0, size = 64;
plot(size.collect { xi = a - (b * sqrt(abs(xi))) });
)
::

classmethods::

method:: ar
argument::freq
Iteration frequency in Hertz
argument::a
Equation variable
argument::b
Equation variable
argument::xi
Initial value of x

examples::
code::
// vary frequency
{ CuspL.ar(MouseX.kr(20, SampleRate.ir), 1.0, 1.99) * 0.3 }.play(s);

// mouse-controlled params
{ CuspL.ar(SampleRate.ir/4, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1)) * 0.3 }.play(s);

// as a frequency control
{ SinOsc.ar(CuspL.ar(40, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1))*800+900)*0.4 }.play(s);
::


class:: CuspN
summary:: Cusp map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/CuspL

description::
A non-interpolating sound generator based on the difference equation:

teletype::
	x(n+1) = a - b * sqrt(|x(n)|)
::

sclang code translation:

code::
(
var a = 1.0, b = 1.9, xi = 0, size = 64;
plot(size.collect { xi = a - (b * sqrt(abs(xi))) });
)
::

classmethods::

method:: ar
argument::freq
Iteration frequency in Hertz
argument::a
Equation variable
argument::b
Equation variable
argument::xi
Initial value of x
argument::mul
argument::add

examples::
code::
// vary frequency
{ CuspN.ar(MouseX.kr(20, SampleRate.ir), 1.0, 1.99) * 0.3 }.play(s);

// mouse-controlled params
{ CuspN.ar(SampleRate.ir/4, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1)) * 0.3 }.play(s);

// as a frequency control
{ SinOsc.ar(CuspN.ar(40, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1))*800+900)*0.4 }.play(s);
::


TITLE:: CustomViewAction
summary:: A MenuAction that can contain a View.
categories:: GUI
related:: Classes/MenuAction, Classes/Menu, Classes/ToolBar, Classes/MainMenu

DESCRIPTION::
A CustomViewAction is a link::Classes/MenuAction:: that contains a link::Classes/View:: instead of an icon or text.
This enables embedding of interactive components to a link::Classes/Menu:: or link::Classes/ToolBar::.

CODE::
(
~view = View().layout_(HLayout(
	ToolBar(
		MenuAction("Min", { ~slider.value = 0 }),
		MenuAction("Max", { ~slider.value = 1 }),
		CustomViewAction(
			~slider = Slider().orientation_(\horizontal)
		),
		Menu(
			MenuAction("Randomize", { ~multi.value = 4.collect({ 1.0.rand }) }),
			CustomViewAction(
				~multi = MultiSliderView().drawLines_(true).elasticMode_(true).value_([0, 1, 0, 1])
			)
		).title_("Submenu")
	).minWidth_(400)
)).front;
)
::

CLASSMETHODS::

METHOD:: new
    Create a new CustomViewAction

    argument::
        A View.
    argument::
        A Function to execute when this item is selected.
        Note:: In some cases, the View that the CustomViewAction contains will absorb mouse clicks, making it difficult to select this menu item (and thus trigger the action). ::

INSTANCEMETHODS::

METHOD:: defaultView
    Set the View that is attached to this CustomViewAction.

    argument::
        A View.


class:: DC
summary:: Create a constant amplitude signal
related:: Classes/LeakDC
categories::  UGens>Generators>Single-value

Description::

This UGen simply outputs the initial value you give it.

classmethods::

method::ar, kr

argument::in
constant value to output, cannot be modulated, set at initialisation time

examples::
code::
//won't work (the output is 0.5*0.0), which is why we need the DC UGen!
{0.5}.play

//constantly zero
{DC.ar(0.0) }.play;


//DC offset; will click on start and finish
{DC.ar(0.5) + SinOsc.ar(440,0,0.1) }.play;


//test - note the transient before LeakDC adapts and suppresses the offset
{LeakDC.ar(DC.ar(0.5))}.play;


// show scope
s.scope
::



class:: Date
summary:: an object describing a point in time
categories:: Control


ClassMethods::

method::new
Create a new Date with the given properties (all are Integer values, except teletype::rawSeconds::, which is a Float). These arguments are also the names of instance variables of the Date object.

The constructor initializes the instance in one of the following ways (in order of priority):

numberedlist::
## If teletype::Date.new:: is called without any arguments, it will return the strong::current time::, the same as calling link::#*localtime::.

code::
// The following are equivalent, they return "now" (at the time of call):
Date.new;
Date.localtime;
::

## If a teletype::rawSeconds:: argument is specified, it is used to set (overwrite) all the other properties (teletype::year::, teletype::month::, teletype::day::, teletype::hour::, teletype::minute::, teletype::second::, teletype::dayOfWeek::), regardless of whether they are nil or not.

code::
(
var d = Date.new.postln;
var e = Date(rawSeconds: d.rawSeconds); // create a new Date with the same time
d == e; // true
)
::

## The most typical usage is to create a Date from a year/month/day and possibly hour/minute/second.  All of these properties (except teletype::year::) have default values (teletype::month=1::, teletype::day=1::, teletype::hour=0::, teletype::minute=0::, teletype::second=0::). teletype::rawSeconds:: is computed based on the other properties. There is no default year -- if no teletype::year:: is provided, an error is thrown.

code::
Date(1969, 7, 20, 20, 18); // -> Sun Jul 20 20:18:00 1969
Date(2016); // -> Fri Jan  1 00:00:00 2016
d = Date(2010, day: 15, minute: 30); // -> Fri Jan 15 00:30:00 2010
[d.asString, d.dayOfWeek, d.rawSeconds]; // dayOfWeek and rawSeconds were computed
::
::

It is possible to specify dates with "out of range" values that will be resolved into a valid range -- this allows simple date offset calculations to be performed (see example below).

code::
(
// Simple date/time offsetting can be performed:
("One hundred days before Christmas:" + Date(2010, 12, 25 - 100).format("%B %d")).postln;

// Invalid dates are "corrected"
Date(2017, 2, 29).postln; // March 1: 2017 was not a leap year!
)
::

note::The teletype::dayOfWeek:: argument is strong::always calculated::.  If it is specified, the value will be overwritten (it only remains a constructor argument for reasons of backward compatibility).

code::
// There is no point (but no harm) in specifying the dayOfWeek argument,
// as it will always be calculated:
Date(2017, 10, 31, dayOfWeek: 0).dayOfWeek; // calculated to be 2 (Tuesday), not 0 (Sunday)
::
::

method::fromString
Create a new Date object from a date/time string, which is parsed according to the provided format string.

code::
Date.fromString("2017-10-25 [13:25:55]", "%Y-%m-%d [%H:%M:%S]");
Date.fromString("1981.9.30 @ 17:33", "%Y.%m.%d @ %H:%M");

(
// Round-trip via string, using "stamp"
var stampString = Date(2013, 5, 25, 10, 9, 8).stamp;
var d = Date.fromString(stampString, "%y%m%d_%H%M%S");
(stampString + "-->" + d).postln;
)
::

argument:: string
The date/time string to parse, for example teletype::"2017-10-25 13:25:55"::.

argument:: format
The format to use to parse the date string. Note that the supported input formats are slightly different from those of the link::#-format:: (output) method. In particular, some of the "combined" formats (such as teletype::%F:: or teletype::%T::) are not supported for input, you must expand them out (teletype::"%F":: -> teletype::"%Y-%m-%d":: and teletype::"%T":: -> teletype::"%H:%M:%S"::).  The full list of supported input format flags may be found link::http://www.boost.org/doc/libs/1_63_0/doc/html/date_time/date_time_io.html##here::.

To parse the above example string, you would use teletype::"%Y-%m-%d %H:%M:%S"::.

method::getDate
Get current date from system and create a date object from it.
code::
(
var a = Date.getDate;
a.rawSeconds.postln;
a.dayOfWeek.postln;
a
)
::

method::localtime
Get current localized time from system and create a date object from it.

method::gmtime
Get current strong::Greenwich Mean Time (GMT):: from system and create a date object from it.

method::seed
Get current date and return a value suitable for seeding a random number generator. See also link::Reference/randomSeed##randomSeed::.
code::
(
var a = Date.seed;
thisThread.randSeed = a;
20.do { [1,0].choose.post }; "".postln;
thisThread.randSeed = a;
25.do { [1,0].choose.post }; "".postln;
)
::

InstanceMethods::

method::rawSeconds
Get or set the receiver's raw time in seconds (relative to the "epoch" of January 1, 1970).

If you modify this property, the other properties will not update. See note at link::#-resolve:: -- there is no "resolveFromRawSeconds" method, but you can generate a new self-consistent Date instance by passing the teletype::rawSeconds:: as an argument to link::#*new::.

note::
This value is not portable between machines, because of differences in the way the underlying time functions are implemented, and because of time zone differences.  To save/restore Date values between runs and on different platforms, it is recommended strong::not:: to use the rawSeconds value.  Instead, you should serialize the Date to a string, for example:
::

code::
(
var savedDateStr = Date.localtime.format("%Y%m%d_%H%M%S").postcs;
var loadedDate = Date.fromString(savedDateStr, "%Y%m%d_%H%M%S").postln;
)
::

method::localtime
Set the receiver's time to current localtime.

method::gmtime
Set the receiver's time to current strong::Greenwich Mean Time (GMT)::.

method::dayStamp
Obtain a string with the year, month and day in the format strong::YYMMDD::.

method::hourStamp
Obtain a string in the format strong::H:M:S::.

method::secStamp
Obtain a string with the seconds.

method::stamp
Obtain a string in the format strong::YYMMDD_HHMMSS::.

method::asSortableString
Obtain a string in an alphabetically sortable standard database format.

method::asctime
Obtain a string in the format WeekdayName MonthName Time Year.

method::asString
Returns asctime.

method::resolve
Resolve any inconsistencies in the Date object, updating all the fields (in particular teletype::dayOfWeek:: and teletype::rawSeconds::) as necessary.

If the instance properties (teletype::year::, teletype::month::, teletype::day::, teletype::hour::, teletype::minute::, teletype::second::) are modified, the Date will be in an inconsistent state -- its teletype::rawSeconds:: won't reflect the modifications, and the properties may fall outside of "normal" ranges (teletype::month: 1-12, day:1-31, hour: 0-23, minute/second: 0-59::).  Also, using the string conversion methods may give strange results. Calling the teletype::resolve:: method will put things back into a consistent state.

code::
// Simple date/time offsetting can be performed:
d = Date(2017, 9, 30, 10, 30); // -> Sat Sep 30 10:30:00 2017
[d.dayOfWeek, d.rawSeconds]; // -> [ 6, 1506760200 ]
d.hour = d.hour - 13; // -> Sat Sep 30 -03:30:00 2017
d.month = d.month + 4; // -> Sat ??? 30 -03:30:00 2017
d.minute = d.minute + 200; // -> Sat ??? 30 -03:230:00 2017
d.rawSeconds; // hasn't changed: still 1506760200

// Now resolve everything back into reasonable ranges, applying the offsets:
d.resolve; // -> Tue Jan 30 00:50:00 2018
[d.dayOfWeek, d.rawSeconds]; // -> [ 2, 1517269800 ]
::

note::
There is no "resolveFromRawSeconds" method.  If you modify the teletype::rawSeconds:: property, the other properties strong::won't:: change to reflect it.  If you want to "resolve" in the other direction, simply create a new Date object using the teletype::rawSeconds:::

code::
d = Date(1999, 12, 31); // -> Fri Dec 31 00:00:00 1999
d.rawSeconds; // -> 946594800

// Add 1 million seconds (~11.6 days)
d.rawSeconds = d.rawSeconds + 1e6; // still shows -> Fri Dec 31 00:00:00 1999
d.rawSeconds; // -> 947594800
// rawSeconds different but the other properties haven't changed

// If we were to call d.resolve, then rawSeconds would be reset to match all
// the other properties.  So in this case, where we want to "resolve" from the
// rawSeconds, just create a new Date object:
d = Date(rawSeconds: d.rawSeconds);
// -> Tue Jan 11 13:46:40 2000
::
::

method::format
Obtain a date string with a given format. The character % is replaced by the appropriate value, which is derived from the letter that follows.
code::
Date.getDate.format("Today is %A. It is around %I o'clock (%p), in %B.");
Date.getDate.format("%d/%m/%Y %H:%M");  // DD/MM/YYYY hh:mm
::

discussion::

A list of formats can be found here: http://www.opengroup.org/onlinepubs/009695399/functions/strftime.html


definitionList::

## %a
|| Replaced by the locale's abbreviated weekday name. [ tm_wday]

## %A
|| Replaced by the locale's full weekday name. [ tm_wday]

## %b
|| Replaced by the locale's abbreviated month name. [ tm_mon]

## %B
|| Replaced by the locale's full month name. [ tm_mon]

## %c
|| Replaced by the locale's appropriate date and time representation.

## %C
|| Replaced by the year divided by 100 and truncated to an integer, as a decimal number [00,99]. [ tm_year]

## %d
|| Replaced by the day of the month as a decimal number [01,31]. [ tm_mday]

## %D
|| Equivalent to %m / %d / %y. [ tm_mon, tm_mday, tm_year]

## %e
|| Replaced by the day of the month as a decimal number [1,31]; a single digit is preceded by a space. [ tm_mday]

## %F
|| Equivalent to %Y - %m - %d (the ISO 8601:2000 standard date format). [ tm_year, tm_mon, tm_mday]

## %g
|| Replaced by the last 2 digits of the week-based year (see below) as a decimal number [00,99]. [ tm_year, tm_wday, tm_yday]

## %G
|| Replaced by the week-based year (see below) as a decimal number (for example, 1977). [ tm_year, tm_wday, tm_yday]

## %h
|| Equivalent to %b. [ tm_mon]

## %H
|| Replaced by the hour (24-hour clock) as a decimal number [00,23]. [ tm_hour]

## %I
|| Replaced by the hour (12-hour clock) as a decimal number [01,12]. [ tm_hour]

## %j
|| Replaced by the day of the year as a decimal number [001,366]. [ tm_yday]

## %m
|| Replaced by the month as a decimal number [01,12]. [ tm_mon]

## %M
|| Replaced by the minute as a decimal number [00,59]. [ tm_min]

## %n
|| Replaced by a <newline>.

## %p
|| Replaced by the locale's equivalent of either a.m. or p.m. [ tm_hour]

## %r
|| Replaced by the time in a.m. and p.m. notation; in the POSIX locale this shall be equivalent to %I :%M :%S%p. [ tm_hour, tm_min, tm_sec]

## %R
|| Replaced by the time in 24-hour notation (%H : %M ). [ tm_hour, tm_min]

## %S
|| Replaced by the second as a decimal number [00,60]. [ tm_sec]

## %t
|| Replaced by a <tab>.

## %T
|| Replaced by the time ( %H : %M : %S ). [ tm_hour, tm_min, tm_sec]

## %u
|| Replaced by the weekday as a decimal number [1,7], with 1 representing Monday. [ tm_wday]

## %U
|| Replaced by the week number of the year as a decimal number [00,53]. The first Sunday of January is the first day of week 1; days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]

## %V
|| Replaced by the week number of the year (Monday as the first day of the week) as a decimal number [01,53]. If the week containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1. Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]

## %w
|| Replaced by the weekday as a decimal number [0,6], with 0 representing Sunday. [ tm_wday]

## %W
|| Replaced by the week number of the year as a decimal number [00,53]. The first Monday of January is the first day of week 1; days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]

## %x
|| Replaced by the locale's appropriate date representation.

## %X
|| Replaced by the locale's appropriate time representation.

## %y
|| Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]

## %Y
|| Replaced by the year as a decimal number (for example, 1997). [ tm_year]

## %z
|| Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ), or by no characters if no timezone is determinable. For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich). If tm_isdst is zero, the standard time offset is used. If tm_isdst is greater than zero, the daylight savings time offset is used. If tm_isdst is negative, no characters are returned. [ tm_isdst]

## %Z
|| Replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists. [ tm_isdst]

## %%
|| Replaced by %.
::

If a conversion specification does not correspond to any of the above, the behavior is undefined.

method::<
method::<=
method::>
method::>=
Compare two Dates based on their rawSeconds.
code::
Date(1999, 12, 31, 23, 59, 59) < Date(2000, 1, 1, 0, 0, 0);
Date(1999, 12, 31, 23, 59, 59) <= Date(2000, 1, 1, 0, 0, -1);
Date(2005, 1, 1) > Date(2004, 1, 2);
Date(2005, 2, 13) >= Date(2005, 2, 13);
::

method::==
method::!=
Test whether two Dates are equal/unequal, based on their rawSeconds.
code::
Date(2016, 11, 4) == Date(2016, 10, 4 + 31);
Date(2016) != Date(2017);
::


class:: Dbrown
summary:: Demand rate brownian movement generator.
related:: Classes/Dibrown, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dbrown returns numbers in the continuous range between
code::lo::  and  code::hi:: ,
link::Classes/Dibrown::  returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pbrown::,  link::Classes/BrownNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::step

Maximum step for each new value.


argument::length

Number of values to create. Use code::inf:: for an infinite number.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dbrown(0, 15, 1, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Dbufrd
summary:: Buffer read demand ugen
categories:: UGens>Buffer, UGens>Demand
related:: Classes/Dbufwr

classmethods::

method:: new
argument:: bufnum
buffer number to read from
argument:: phase
index into the buffer
argument:: loop
when phase exceeds number of frames in buffer, loops when set to 1 (default :1)
discussion::
all inputs can be either demand ugen or any other ugen.

examples::
code::
b = Buffer.alloc(s, 24, 1);
b.setn(0, { exprand(200, 500) } ! b.numFrames);
b.getn(0, b.numFrames, {|x| x.postln })

(
{ var indexPattern;
	indexPattern = Dseq([Dseq([0, 3, 5, 0, 3, 7, 0, 5, 9], 3), Dbrown(0, 23, 1, 5)], inf);
	SinOsc.ar(
		Demand.kr(Dust.kr(10), 0, Dbufrd(b, indexPattern))
	) * 0.1
}.play;
)

// buffer as a time pattern

c = Buffer.alloc(s, 24, 1);
c.setn(0, { [1, 0.5, 0.25].choose } ! c.numFrames);
c.getn(0, c.numFrames, {|x| x.postln })

(
{ var indexPattern;
	indexPattern = Dseq([Dseq([0, 3, 5, 0, 3, 7, 0, 5, 9], 3), Dbrown(0, 23, 1, 5)], inf);
	SinOsc.ar(
		Duty.kr(
			Dbufrd(c, Dseries(0, 1, inf)) * 0.5,
			0,
			Dbufrd(b, indexPattern)
		)
	) * 0.1
}.play;
)

// free buffers

b.free; c.free;
::



class:: Dbufwr
summary:: Buffer write demand ugen
categories:: UGens>Buffer, UGens>Demand
related:: Classes/Dbufrd

classmethods::

method:: new
argument:: input
single channel input
argument:: bufnum
buffer number to write to (single channel buffer)
argument:: phase
index into the buffer
argument:: loop
when phase exceeds number of frames in buffer, loops when set to 1 (default :1)
discussion::
all inputs can be either demand ugen or any other ugen.

examples::
code::
// alloc a single channel buffer
b = Buffer.alloc(s, 24, 1);
b.setn(0, { 210 } ! b.numFrames);

// post some info:
fork { loop { 0.5.wait; b.getn(0, b.numFrames, {|x| x.postln }) } };

// write demand sequence into a buffer
(
{
var read, write, readpos, writepos, writetrig;

	writetrig = Dust.kr(1);
	readpos = Dseries(0, 1, inf);
	writepos = Dseq([Dseries(0, 3, 30), Dseries(0, 1, 30)], inf);

	read = Dbufrd(b, readpos);
	write = Dbufwr(Dseq([Dseries(1, 1, 16), Dwhite(1, 16, 8)], inf) * 60, b, writepos);

	Demand.kr(writetrig, 0, write); // write on trigger

	SinOsc.ar(
		Demand.kr(Impulse.kr(16), 0, read).lag(0.01) * [1, 1.01]
	) * 0.1

}.play;
)

// write into buffer with mouse clicks
(
{
	var val = MouseY.kr(1000, 200, 1); // cursor y pos controls frequency
	var pos = MouseX.kr(0, BufFrames.kr(b) - 1); // cursor x position controls buffer pos
	var write = MouseButton.kr; // button controls write action
	Demand.kr(write, 0, Dbufwr(val, b, pos, 1));
	SinOsc.ar(
		Duty.kr(Dseq([0.5, 0.75, 0.5, 1.0], inf) * 0.2, 0, Dbufrd(b, Dseries(0, 1, inf)))
	) * 0.1
}.play;
)

// write demand sequence into a buffer
b.free; b = Buffer.alloc(s, 2, 1);
fork { loop { 0.5.wait; b.getn(0, b.numFrames, {|x| x.postln }) } };
b.setn(0, [1, 0]);

(
{
var read, write, readpos, writepos, writetrig;

	writetrig = Impulse.kr(2);
	readpos = Dbufrd(b, 1); // first buffer val is position
	writepos = Dbufrd(b, 0); // second buffer val is position
	read = Dbufrd(b, readpos);

	write = Dbufwr(read, b, writepos);

	Demand.kr(writetrig, 0, write); // write on trigger
}.play;
)

// free buffer:
b.free;
::



TITLE:: Dconst
summary:: Constrain a demand-rate stream to a given sum
categories:: UGens>Demand

DESCRIPTION::
A demand-rate analog to link::Classes/Pconst::. It outputs values from the child demand stream until the sum of those values reaches or exceeds a given total. The last value will be truncated so that the sum of Dconst's output values will match the total exactly.

CLASSMETHODS::

METHOD:: new

ARGUMENT:: sum
The sum to reach. This may be a number, demand UGen or any other UGen. When a Dconst instance resets, one value will be taken for the sum, and it can't be modulated until the next reset.

ARGUMENT:: in
A demand-rate stream, providing the output values.

ARGUMENT:: tolerance
Because of floating point rounding error, it isn't safe to stop only when the output's running sum is equal to the desired total. teletype::tolerance:: is how close the running sum can get to stop the output: code::abs(runningsum - sum) <= tolerance::.

returns:: A demand-rate stream.


EXAMPLES::

code::
// fast notes of random duration for 0.5 seconds
// then a single note for 0.5 seconds
(
a = {
	var freq = Duty.kr(
		Dseq([
			Dconst(0.5, Dwhite(0.05, 0.08, inf)),
			0.5
		], inf),
		0,
		// workaround for the lack of Dexprand
		Dwhite(0, 1, inf).linexp(0, 1, 200, 600)
	);
	VarSaw.ar(Lag.kr(freq, 0.02), 0, 0.3, 0.1).dup
}.play;
)

a.free;
::


class:: Ddup
summary:: Demand rate input replicator
categories:: UGens>Demand

classmethods::
method:: new
argument:: n
number of repeats (can be a demand ugen)
argument:: in
input ugen
discussion::
structurally related: link::Classes/Pdup::

examples::
code::
(
{
	var freq, trig;
	var in = Dseq([1, 2, 3], inf);
	var rep = Ddup(Diwhite(2, 8, inf), in);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, rep).poll(trig) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
::



class:: DebugNodeWatcher
summary:: watches a server address for debug-related messages
related:: Reference/Server-Command-Reference, Classes/Node, Classes/NodeWatcher
categories:: Control, Server>Nodes

description::
Posts when these messages are received from the server:
n_go n_end n_off n_on

For debugging, it can be useful to see every node start and end. It doesn't require registration, reacts to each message.

Examples::

code::
s.boot;

d = DebugNodeWatcher(s);
d.start;

y = Group.new;
y.run(false);
y.free;

d.stop;
::


class:: Decay
summary:: Exponential decay
related:: Classes/Decay2
categories:: UGens>Filters>Linear, UGens>Envelopes

Description::

This is essentially the same as  link::Classes/Integrator::  except that
instead of supplying the coefficient directly, it is calculated from a 60
dB decay time. This is the time required for the integrator to lose 99.9%
of its value or -60dB. This is useful for exponential decaying envelopes
triggered by impulses.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::decayTime
60 dB decay time in seconds.

argument::mul

argument::add

Examples::

code::
plot({ Decay.ar(Impulse.ar(1), 0.01) });

// used as an envelope
play({ Decay.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.2, PinkNoise.ar, 0) });
::



class:: Decay2
summary:: Exponential decay
related:: Classes/Decay
categories::  UGens>Filters>Linear, UGens>Envelopes


Description::
link::Classes/Decay::  has a very sharp attack and can produce clicks.
Decay2 rounds off the attack by subtracting one Decay from another.
code:: Decay2.ar(in, attackTime, decayTime):: is equivalent to:

code::
Decay.ar(in, decayTime) - Decay.ar(in, attackTime)
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::attackTime

60 dB attack time in seconds.


argument::decayTime

60 dB decay time in seconds.


argument::mul

argument::add


Examples::

code::
// since attack and decay are a difference of two Decays,
// swapping the values, the envelope turns upside down:
plot({ Decay2.ar(Impulse.ar(1), 0.001, 0.01) })
plot({ Decay2.ar(Impulse.ar(1), 0.01, 0.001) })

// used as an envelope
{ Decay2.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.01, 0.2, FSinOsc.ar(600)) }.play;

// compare the above with Decay used as the envelope
{ Decay.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.2, FSinOsc.ar(600), 0)  }.play;
::



class:: DecodeB2
summary:: 2D Ambisonic B-format decoder.
related:: Classes/BiPanB2, Classes/PanB, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Decode a two dimensional ambisonic B-format signal to a set of speakers
in a regular polygon. The outputs will be in clockwise order. The
position of the first speaker is either center or left of center.


classmethods::

method::ar, kr

argument::numChans

Number of output speakers. Typically 4 to 8.


argument::w

The B-format signal.


argument::x

The B-format signal.


argument::y

The B-format signal.


argument::orientation

Should be zero if the front is a vertex of the polygon. The first
speaker will be directly in front. Should be 0.5 if the front
bisects a side of the polygon. Then the first speaker will be the
one left of center.

returns::
An array of channels, one for each speaker.

Examples::

code::

(
{
	var w, x, y, p, a, b, c, d;

	p = PinkNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)

::



class:: DegreeToKey
summary:: Convert signal to modal pitch.
categories::  UGens>Conversion


Description::

The input signal value is truncated to an integer value and used as an
index into an octave repeating table of note values. Indices wrap around
the table and shift octaves as they do.


classmethods::

method::ar, kr

argument::bufnum

Index of the buffer which contains the steps for each scale
degree.


argument::in

The input signal.


argument::octave

The number of steps per octave in the scale.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

(
// modal space
// mouse x controls discrete pitch in dorian mode
var scale, buffer;
scale = FloatArray[0, 2, 3.2, 5, 7, 9, 10]; // dorian scale
buffer = Buffer.alloc(s, scale.size,1, {|b| b.setnMsg(0, scale) });

play({
	var mix;

	mix =

	// lead tone
	SinOsc.ar(
		(
			DegreeToKey.kr(
				buffer.bufnum,
				MouseX.kr(0,15),		// mouse indexes into scale
				12,					// 12 notes per octave
				1,					// mul = 1
				72					// offset by 72 notes
			)
			+ LFNoise1.kr([3,3], 0.04)	// add some low freq stereo detuning
		).midicps,						// convert midi notes to hertz
		0,
		0.1)

	// drone 5ths
	+ RLPF.ar(LFPulse.ar([48,55].midicps, 0.15),
		SinOsc.kr(0.1, 0, 10, 72).midicps, 0.1, 0.1);

	// add some 70's euro-space-rock echo
	CombN.ar(mix, 0.31, 0.31, 2, 1, mix)
})
)

::


class:: DelTapRd
categories:: UGens>Buffer, UGens>Delays
summary:: Tap a delay line from a DelTapWr UGen
related:: Classes/DelTapWr

description::
Tap a delay line from a link::Classes/DelTapWr:: UGen.

note:: If you run a code::DelTapRd.ar:: and a code::DelTapWr.ar:: in tandem, keep in mind that they read and write in blocks
equal to the server's block size. If the delay time is greater than the buffer size minus a block, the write and read
heads might interfere in unintended ways. Use a slightly larger buffer if this happens. ::

classmethods::
private:: categories

method:: ar, kr

argument:: buffer
buffer where DelTapWr has written signal.  Max delay time is based on buffer size.
argument:: phase
the current phase of the DelTapWr UGen. This is the output of DelTapWr.
argument:: delTime
A delay time in seconds.
argument:: interp
the kind of interpolation to be used. 1 is none, 2 is linear, 4 is cubic.
argument:: mul
argument:: add

examples::
See link::Classes/DelTapWr#examples:: for examples.



class:: DelTapWr
categories:: UGens>Buffer, UGens>Delays
summary:: Write to a buffer for a DelTapRd UGen
related:: Classes/DelTapRd

description::
Write to a buffer for a link::Classes/DelTapRd:: UGen.

note:: If you run a code::DelTapRd.ar:: and a code::DelTapWr.ar:: in tandem, keep in mind that they read and write in blocks
equal to the server's block size. If the delay time is greater than the buffer size minus a block, the write and read
heads might interfere in unintended ways. Use a slightly larger buffer if this happens. ::

classmethods::
private:: categories

method:: ar, kr
argument:: buffer
the buffer to write signal into. Max delay time is based on buffer size.
argument:: in
the signal to write to the buffer.
returns::
phase - DelTapWr outputs its current sample value for use in the phase argument in DelTapRd

examples::
code::
// a Buffer for the UGens to use, one second at the current sample rate
b = Buffer.alloc(s, s.sampleRate * 1, 1);

// write a signal into a delay, tap it at multiple times
SynthDef(\test, { |out, buffer|
	var src, tapPhase, tap1, tap2, tap3;
	src = WhiteNoise.ar(0.2) * Decay.kr(Dust.kr(3), 0.2);
	tapPhase = DelTapWr.ar(buffer, src);
	#tap1, tap2, tap3 = DelTapRd.ar(buffer, tapPhase,
		[0.2, 0.27, 0.303],  	// tap times
		1,  					// no interp
		[1.0, 0.4, 0.2] 		// muls for each tap
	);
	Out.ar(out, [src + tap2, tap1 + tap3])
}).add;

x = Synth(\test, [\buffer, b]);
x.free;
b.free;
::

code::
// a Buffer for the UGens to use
b = Buffer.alloc(s, 44100, 1);

// write a signal into a delay, tap it at multiple times
SynthDef(\write, { |buffer, cout|
	var src, tapPhase, tap1, tap2, tap3;
	src = WhiteNoise.ar(0.2) * Decay.kr(Dust.kr(3), 0.7);
	tapPhase = DelTapWr.ar(buffer, src);
	Out.kr(cout, tapPhase);
	}).add;

SynthDef(\readFilt, { |out, buffer, cin|
	var phase, src, filt;
	phase = In.kr(cin);
	src = DelTapRd.ar(buffer, phase, [0.01, 0.2]);
	filt = BPF.ar(src, 880, 0.01) * 10;
	Out.ar(out, filt);
}).add;

c = Bus.control;

x = Synth(\write, [\buffer, b, \cout, c]);
y = Synth(\readFilt, [\buffer, b, \cin, c]);

x.free;
b.free;
::



class:: Delay1
summary:: Single sample delay.
related:: Classes/Delay2
categories::  UGens>Delays


Description::

Delays the input by 1 audio frame or control period.


classmethods::

method::ar, kr

argument::in
Input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
For audio-rate signals the delay is 1 audio frame, and for control-rate signals the delay is 1 control period.


Examples::

code::

(
plot({
	var z;
	z = Dust.ar(1000);
	[z, z - Delay1.ar(z)] 	// [ original, subtract delayed from original ]
}))

::



class:: Delay2
summary:: Two sample delay.
related:: Classes/Delay1
categories::  UGens>Delays


Description::

Delays the input by 2 samples.


classmethods::

method::ar, kr

argument::in
Input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
plot({
	var z;
	z = Dust.ar(1000);
	[z, z - Delay2.ar(z)] 	// [ original, subtract delayed from original ]
}))

::



class:: DelayC
summary:: Simple delay line with cubic interpolation.
related:: Classes/DelayL, Classes/DelayN, Classes/BufDelayC
categories::  UGens>Delays


Description::

Simple delay line with cubic interpolation. See also
link::Classes/DelayN::  which uses no interpolation, and
link::Classes/DelayL::  which uses linear interpolation. Cubic
interpolation is more computationally expensive than linear,
but more accurate.

The term "delay" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombC.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

discussion::
note::
DelayC needs at least 4 samples buffer. Therefore the minimum code::maxdelaytime:: and code::delaytime:: must be code::SampleDur.ir * 4::.
::

Examples::
code::
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayC.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayC.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
::



class:: DelayL
summary:: Simple delay line with linear interpolation.
related:: Classes/DelayC, Classes/DelayN, Classes/BufDelayL
categories::  UGens>Delays


Description::

Simple delay line with linear interpolation. See also
link::Classes/DelayN::  which uses no interpolation, and
link::Classes/DelayC::  which uses cubic interpolation. Cubic
interpolation is more computationally expensive than linear,
but more accurate.

The term "delay" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombL.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayL.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayL.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
::



class:: DelayN
summary:: Simple delay line with no interpolation.
related:: Classes/Delay1, Classes/Delay2, Classes/DelayC, Classes/DelayL, Classes/BufDelayN
categories::  UGens>Delays


Description::

Simple delay line with no interpolation. See also
link::Classes/DelayL::  which uses linear interpolation, and
link::Classes/DelayC::  which uses cubic interpolation.

This UGen will create aliasing artifacts if you modulate the delay time, which is also quantized to the nearest sample period. If these are undesirable properties, use DelayL or DelayC. But if your delay time is fixed and sub-sample accuracy is not needed, this is the most CPU-efficient choice with no loss in quality.

The term "delay" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombN.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds, used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayN.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayN.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
::



class:: Demand
summary:: Demand results from demand rate UGens.
related:: Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

When there is a trigger at the trig input, a value is demanded each UGen
in the list and output. The unit generators in the list should be
'demand' rate.

When there is a trigger at the reset input, the demand rate UGens in the
list are reset.

classmethods::
private:: categories

method::ar, kr

argument::trig
Trigger. Can be any signal. A trigger happens when the signal
changes from non-positive to positive.

argument::reset
Trigger. Resets the list of UGens when triggered.

argument::demandUGens
List of demand-rate UGens to get values from. When the shortest stream ends, this ugen will set the link::Classes/Done##'done' flag::.

discussion::
By design, a reset trigger only resets the demand ugens; it does not reset the value at Demand's output. Demand continues to hold its value until the next value is demanded, at which point its output value will be the first expected item in the list.
To jump to the start value upon receipt of a reset trigger, one can add (+) the two triggers together:
code::
(
a = { |t_trig, t_reset|
	var	d = Demand.kr(t_trig + t_reset, t_reset, Dseries(0, 1, inf));
	d.poll(t_trig + t_reset);
	0.0;
}.play
)
a.set(\t_trig, 1); // do this a few times -- the demand value should increase by 1 each time
a.set(\t_reset, 1);	// goes immediately back to 0
::

One demand ugen represents a single stream of values, so that embedding the same ugen twice calls this stream twice. To isolate a demand ugen, use a function:
code::
{
var a, b, t = Impulse.kr(2);
a = { Dseq([1, 2, 3, 4, 5], inf) } * 100;
b = a + 1;
Demand.kr(t, 0, [a, b]).poll(t)
}.play
::


Examples::

code::

// examples

(
{
	var trig, seq, freq;
	trig = Impulse.kr(24);
	seq = Drand([Dseq((1..5).mirror1, 1), Drand((4..10), 8)], 2000);
	freq = Demand.kr(trig, 0, seq * 100);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed.scaleneg(MouseX.kr(-1,1)) * 0.1;
}.play;
)

(
{
	var trig, seq, freq;
	trig = Impulse.kr(12);
	seq = Drand([Dseq((1..5).mirror1, 1), Drand((4..10), 8)], 2000) * Drand([1,2,4,8],2000);
	freq = Demand.kr(trig, 0, seq * 100);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed.scaleneg(MouseX.kr(-1,1)) * 0.1;
}.play;
)




(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Diwhite(60, 72, inf).midicps;
	freq = Demand.kr(trig, 0, seq);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)

(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Dseq([72, 75, 79, Drand([82,84,86])], inf).midicps;
	freq = Demand.kr(trig, 0, seq);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)


(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Dswitch1(
		[
			Diwhite(60, 72, inf),
			Dseq([72, 75, 79, Drand([82,84,86])], inf)
		],
		LFPulse.kr(0.2)
	);
	freq = Demand.kr(trig, 0, seq.midicps);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)


(
{
	var freq, trig, reset, seq1, seq2;
	trig = Impulse.kr(10);
	seq1 = Drand([72, 75, 79, 82] - 12, inf).midicps;
	seq2 = Dseq([72, 75, 79, Drand([82,84,86])], inf).midicps;
	freq = Demand.kr(trig, 0, [seq1, seq2]);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)

(
{
	var trig, seq;
	trig = Impulse.kr(8);
	seq = Drand([
		Dseq([4,0,0,1,2,1,0,1]),
		Dseq([4,0,2,0,1,0,1,1]),
		Dseq([4,0,0,2,0,0,1,1]),
		Dseq([4,0,1,2,0,1,2,0]),
		Dseq([4,1,1,1,2,2,3,3]),
		Dseq([4,1,0,1,0,1,0,1])
	], inf);
	trig = Demand.kr(trig, 0, seq * 0.4) * trig;
	{LPF.ar(PinkNoise.ar, 5000)}.dup * Decay.kr(trig, 0.5);
}.play;
)

::



class:: DemandEnvGen
summary:: Demand rate envelope generator
related:: Classes/Demand, Classes/Duty, Classes/TDuty
categories::  UGens>Demand, UGens>Envelopes

Description::
Plays back break point envelope contours (levels, times, shapes) given by demand ugens. The next values are called when the next node is reached.

classmethods::
private:: categories

method::ar, kr

argument::level

A demand UGen or any other UGen returning level values. If this ends, the

code::doneAction::  is evaluated.


argument::dur

A demand UGen or any other UGen returning time values. If this ends, the

code::doneAction::  is evaluated.


argument::shape

A demand UGen or any other UGen: the number given is the shape
number according to link::Classes/Env::.


argument::curve

A demand UGen or any other UGen returning curve values. if shape is 5, this is the
curve factor.

The possible values are:
table::
## 0 || flat segments
## 1 || linear segments, the default
## 2 || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## 3 || sinusoidal S shaped segments.
## 4 || sinusoidal segments shaped like the sides of a Welch window.
## a Float || a curvature value for all segments.
## An Array of Floats || curvature values for each segments.
::

argument::gate

If gate is x ≥ 1, the UGen runs.


If gate is 0 > x > 1, the UGen is released at the next
level (doneAction).


If gate is x < 0, the UGen is sampled and held.


argument::reset

If reset crosses from non-positive to positive, the UGen is reset
at the next level. If it is > 1, it is reset immediately.


argument::levelScale

demand ugen returning level scaling values


argument::levelBias

demand ugen returning level offset values


argument::timeScale

demand ugen returning time scaling values


argument::doneAction

A doneAction that is evaluated when level or duration stream
ends. See link::Classes/Done::  for more detail.


Examples::

code::
// frequency envelope with random times
(
	{
		var freq;
		freq = DemandEnvGen.ar(
				Dseq([204, 400, 201, 502, 300, 200], inf),
				Drand([1.01, 0.2, 0.1, 2], inf) * MouseY.kr(0.01, 3, 1),
				7 // cubic interpolation
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// frequency modulation
(
	{
		var freq, list;
		list = { exprand(200, 1000.0) } ! 32;
		freq = DemandEnvGen.ar(
				{ Dseq(list.scramble, inf) } ! 2,
				SampleDur.ir * MouseY.kr(1, 3000, 1),
				5, // curve interpoaltion
				MouseX.kr(-0.01, -4) // curve must be negative for fast interpol.
			);
		SinOsc.ar(freq) * 0.1

	}.play;
)


//  gate
// mouse x on right side of screen toggles gate
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dwhite(300, 1000, inf).round(100),
				0.1,
				5, 0.3, // curve: 0.3
				MouseX.kr > 0.5,
				1
			);
		SinOsc.ar(freq * [1, 1.21]) * 0.1

	}.play;
)

// sample and hold (0.5 > gate > 0)
// mouse x on right side of screen toggles gate
// mouse y scales frequency
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dwhite(300, 1000, inf).round(100),
				0.1,
				5, 0.3,
				MouseX.kr > 0.5 + 0.1
			);
		SinOsc.ar(freq * [1, 1.21]) * 0.1

	}.play;
)

// gate
// mouse x on right side of screen toggles gate
// mouse button does soft reset
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),
				Dseq([0.2, 0.1, 0.2, 0.3, 0.1], inf),
				Dseq([1, 0, 0, 6, 1, 1, 0, 2], inf), // shapes
				0,
				MouseX.kr > 0.5, // gate
				MouseButton.kr > 0.5, // reset
				doneAction: Done.none
			);
		SinOsc.ar(freq * [1, 1.001]) * 0.1

	}.play;
)


//  gate
// mouse x on right side of screen toggles sample and hold
// mouse button does hard reset
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),
				0.1,
				3, 0,
				MouseX.kr > 0.5 - 0.1, // gate: sample and hold
				MouseButton.kr > 0.5 * 2, // hard reset
				doneAction: Done.none
			);
		SinOsc.ar(freq * [1, 1.001]) * 0.1

	}.play;
)





// short sequence with doneAction, linear
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([1300, 500, 800, 300, 400], 1),
				0.2,
				1,
				doneAction: Done.freeSelf
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// short sequence with doneAction, step
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([1300, 500, 800, 300, 400], 1),
				0.2,
				0,
				doneAction: Done.freeSelf
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)



// a linear ramp
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([300, 800], 1),
				1,
				1
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)



// random gate:  release. gate low level > 0.
// only end points are kept as release levels
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([500, 800], inf),
				0.03,
				1,0, // linear
				ToggleFF.kr(Dust.kr(5)) + 0.1 // gate


			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// random gate: sample and hold. gate low level = 0.
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([500, 800, 600], inf),
				0.03,
				1,0, // linear
				ToggleFF.kr(Dust.kr(5)), // gate
				0 // reset

			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)




// lfnoise1
(
	{
			DemandEnvGen.ar(
				Dwhite(-0.1, 0.1, inf),
				SampleDur.ir * MouseY.kr(0.5, 20),
				5,
				-4
			);


	}.play;
)

// lfbrownnoise
(
	{
			DemandEnvGen.ar(
				Dbrown(-0.1, 0.1, 0.1, inf),
				SampleDur.ir * MouseY.kr(1, 100, 1)
			);


	}.play;
)






// hardsyncing a saw
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0,
				K2A.ar(1),
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)

			)


	}.scope;
)


// softsyncing a saw
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0,
				K2A.ar(1),
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1)) + [0, 0.3]

			)


	}.scope;
)



// hardsyncing a saw, some random elements
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				3, 0,
				1,
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)

			)


	}.scope;
)

// softsyncing a saw, some random elements
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0, // linear interpolation
				1,
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1))

			)


	}.scope;
)


// multichannel expansion
// mouse x on right side of screen toggles gate
// mouse y controls speed

(
	{
		var freq;
		freq = DemandEnvGen.kr(
				{ Dseq([300, 800, Drand([1000, 460, 300], 1), 400], inf) + 3.0.rand } ! 2,
				MouseY.kr(0.001, 2, 1),
				5, -4,
				MouseX.kr > 0.5
			);
		SinOsc.ar(freq) * 0.1

	}.play;
)
::


class:: DetectIndex
summary:: Search a buffer for a value
categories:: UGens>Buffer

description::
Search a buffer for a value.

classmethods::
method:: ar, kr

argument:: bufnum
index of the buffer
argument:: in
the input signal.
returns::
index

examples::
code::
(
var max = 300;
t = Array.series(max, 0, 1).curdle(0.06).scramble.flat;
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ) );


{
	var index, in, out, f0, fdiff;
	var bufnum = b;
	var input;
	input = MouseX.kr(0, max).round(1); // round to precision
	index = DetectIndex.kr(bufnum, input);
	index.poll;
	SinOsc.ar(index.linexp(0, max, 200, 700)) * 0.1
}.play;
)

b.free;
::



class:: DetectSilence
summary:: Detect when input falls below an amplitude threshold
categories::  UGens>Synth control, UGens>Analysis>Amplitude


Description::

When the absolute value of the input signal remains below the threshold for a given window of time, output 1. Otherwise, output 0. If the output transitions from 0 to 1, doneAction is also evaluated.

code::
// this frees after the Decay has become quiet enough for a long enough time
{ var signal = Decay.ar(Impulse.ar(0), 2, PinkNoise.ar(0.2)); DetectSilence.ar(signal, doneAction: Done.freeSelf); signal }.play;
::

If the input signal starts with silence at the beginning of the synth's duration, then DetectSilence will wait indefinitely until the first sound before starting to monitor for silence. To avoid a hanging silent sound where the input may remain zero, you can add an code::Impulse.ar(0):: to its input.

DetectSilence does not distinguish a DC-biased signal from a loud signal. If your signal has DC bias, you should wrap it in link::Classes/LeakDC::.

warning:: DetectSilence can be tricky with multi-channel input! See below. ::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::amp

When input falls below this for long enough, evaluate

code::doneAction:: .


argument::time

The minimum duration for which input must fall below

code::amp::  before this triggers.


argument::doneAction

An integer representing the doneAction. See

link::Classes/Done::  for more detail.

returns::
This UGen outputs 1 if silence is detected, otherwise 0.

Examples::

code::

(
SynthDef("detectSilence-help", { arg out;
	var z;
	z = SinOsc.ar(Rand(400, 700), 0, LFDNoise3.kr(8).max(0)).softclip * 0.3;
	DetectSilence.ar(z, doneAction: Done.freeSelf);
	Out.ar(out, z);
}).add;
)

Synth("detectSilence-help");
Synth("detectSilence-help");
Synth("detectSilence-help");


(
Task({
	loop({
		Synth("detectSilence-help");
		[0.5, 1].choose.wait;
	})
}).play;
)

::

section::DetectSilence and multiple inputs

Be careful feeding multiple inputs into DetectSilence, since multichannel expansion can lead to confusing behavior. This code

code::DetectSilence.ar([left, right] + Impulse.ar(0), doneAction: 2)::

spawns strong::two:: DetectSilences, and the enclosing Synth frees itself when left OR right becomes silent. (The code::Impulse.ar(0):: is there to ensure that DetectSilence starts detecting silence right away rather than waiting for non-silence.)

Usually you want to detect silence for both inputs, so what's a good way to change that OR into an AND? The solution is strong::not:: to sum code::(left + right) / 2.sqrt::, because there may be phase cancellation in that sum. Instead, use DetectSilence's output instead of its doneAction, and use FreeSelf to do the freeing. Recall that DetectSilence outputs 1 if silence is detected, and 0 otherwise. Taking the product of multiple DetectSilences will return 1 only if all the DetectSilences are 1. So here is the correct solution to freeing a Synth when both code::left:: and code::right:: first fall silent:

code::FreeSelf.kr(DetectSilence.ar([left, right] + Impulse.ar(0)).product)::

It's also possible to mix the signals with full-wave rectification to avert phase cancellation issues (code::[left, right].abs.sum / 2.sqrt::).


class:: Dgeom
summary:: Demand rate geometric series UGen.
related:: Classes/Demand, Classes/Dseries, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
Demand rate geometric series UGen.

See link::Classes/Pgeom:: for structurally related equivalent.


classmethods::

method::new

argument::start
Start value. Can be a number or any other UGen.


argument::grow
Value by which to grow (x = x[-1] * grow).  Can be a number or
any other UGen.

argument::length
Number of values to create.

discussion::
The arguments can be a number or any other ugen

Examples::

code::

// example

(
{
	var a, freq, trig;
	a = Dgeom(1, 1.2, 15);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dgeom(1, 1.2, inf);
	trig = Dust.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



CLASS:: Dialog
summary:: Shows various system dialogs
categories:: GUI>Accessories
related:: Classes/FileDialog, Classes/File

DESCRIPTION::
This class allows to show various system dialogs. link::#*openPanel:: will show a dialog for selecting a file to open, and link::#*savePanel:: will show a dialog for selecting or creating a file to save to.

The methods here are convenience functions built on top of link::Classes/FileDialog::.

CLASSMETHODS::
PRIVATE:: key

METHOD:: openPanel
	Shows a dialog for selection of an existing file (or multiple files) to open. It does not do anything with the file, instead it just passes the chosen filenames to the given result handler.

	ARGUMENT:: okFunc
		An object to be evaluated when OK is pressed. As argument, either a single filename is passed as a String, or an Array of Strings for multiple selected items is passed, depending on the strong::multipleSelection:: argument. The paths will always be absolute paths.
	ARGUMENT:: cancelFunc
		An object to be evaluated when Cancel is pressed.
	ARGUMENT:: multipleSelection
		A Boolean indicating whether multiple files can be selected.
	ARGUMENT:: path
		A string. The dialog will initially display the contents of this path. The default is the current
		user's home directory.
	DISCUSSION::
	Example:
code::
(
Dialog.openPanel({ arg path;
	path.postln;
},{
	"cancelled".postln;
});
)
::

METHOD:: savePanel
	Shows a dialog for selecting or creating a file to save to. It does not do anything with the selected file, and does not create any file; instead it just passes the chosen filename to the given result handler.

	ARGUMENT:: okFunc
		An object to be evaluated when OK is pressed. The chosen filename (as an absolute path) is passed as a String as argument. If the file already exists, the user will be asked to confirm.
	ARGUMENT:: cancelFunc
		An object to be evaluated when Cancel is pressed.
	ARGUMENT:: path
		A string. The dialog will initially display the contents of this path. The default is the current
		user's home directory.
	DISCUSSION::
	Example:
code::
(
Dialog.savePanel({ arg path;
	path.postln;
},{
	"cancelled".postln;
});
)
::

METHOD:: getPaths
	note::Deprecated. Use link::#*openPanel:: instead. ::

	Implements the same functionality as *openPanel, only the last argument is named differently and defaults to true.


class:: Dibrown
summary:: Demand rate brownian movement generator.
related:: Classes/Dbrown, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dbrown::  returns numbers in the continuous range between
code::lo::  and  code::hi:: ,
Dibrown returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pbrown::,  link::Classes/BrownNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::step

Maximum step for each new value.


argument::length

Number of values to create. Use code::inf:: for an infinite number.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dibrown(0, 15, 1, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



CLASS::Dictionary
summary::associative collection mapping keys to values
related::Classes/Environment, Classes/Event
categories::Collections>Unordered

DESCRIPTION::
A Dictionary is an associative collection mapping keys to values.
Two keys match if they are strong::equal::. (i.e. == returns true.)

The contents of a Dictionary are strong::unordered::. You must not depend on the order of items in a Dictionary.
You must only rely on equality for the keys. E.g. symbols and strings can both be used as keys because the matching is done by equality (==) and not by identity (===). For identity matching, where strings can not be used as keys, see: link::Classes/IdentityDictionary:: and link::Classes/Event::.

note::
Setting code::nil:: as a value erases the key from the Dictionary. This means that code::nil:: itself can't be used as a Dictionary value.
::

code::
d = Dictionary();
d.put(\a, 440);
d.keys; // Set[\a]
d.put(\a, nil); // removes the value 440
d.keys; // Set[]
::

CLASSMETHODS::

method::new
Creates a Dictionary with an initial capacity for strong::n:: key value mappings.

method::newFrom
Creates a new Dictionary from another collection.
code::
d= Dictionary.newFrom([\a, 1, \b, 2, \c, 4]);
::
argument::aCollection
any Object that responds to keysValuesDo (usually a List or an Array).

discussion::
A new Dictionary can also be created from an array of link::Classes/Association::s:
code::
Dictionary.with(*[\a->1,\b->2,\c->3])
::
Or from a single Association like:
code::
d = Dictionary[\a -> 1];
::

INSTANCEMETHODS::

subsection::Adding and Removing

method::add
Add strong::anAssociation:: to the Dictionary. If the key value pair already exists in the Dictionary, the key's value will be replaced.
code::
(
d = Dictionary.new;
d.add(\monkey -> 0).postln;
d.add(\robot -> 1).postln;	// Add robot as a key with a value of 1
d.add(\monkey -> 2).postln;	// Replaces the value for the key monkey with 2
)
::

method::put
Associate two objects and add them to the Dictionary.
code::
d = Dictionary.new;
d.put("abc", 10);

// using an event:
d = ();
d.put("abc", 10);
::
argument::key
key to associate with object. This can be any objects, but is often a link::Classes/Symbol::.
argument::value
an object

method::removeAt
Remove the key and the value associated with it from the Dictionary.
code::
d = Dictionary[\monkey -> 99];
d.removeAt(\monkey);
::

method::putAll
Add all items of each argument to the dictionary.
code::
d = Dictionary.new;
d.putAll(Dictionary[\hello -> 9, \whello -> "world"], Dictionary["abd" -> 6]);
::
argument:: ... dictionaries
any Object that responds to keysValuesDo (usually a Dictionary).

method::putPairs
Add all items to the dictionary, using them as key and value pairwise.
code::
d = Dictionary.new;
d.putPairs([\hello, 10, \whello, "lord", "abc", 7]);
::

subsection::Accessing

method::at
Access the value associated with the key.
code::
d = Dictionary[\robot -> 99];
d.at(\robot);	// Get the value associated with key
d[\robot];	// different syntax, same behaviour
d.at(\monkey);	// Key doesn't exist: return Nil
::

method::atFail
Access the value associated with the key. If the key does not exist, return the result of teletype::function::.

method::keys
Return a link::Classes/Set:: of all keys.
code::
d = Dictionary.newFrom([\hello, 9, \whello, "world"]);
d.keys;
::

method::values
Return a link::Classes/List:: of all values.
code::
d = Dictionary.newFrom([\hello, 9, \whello, "world"]);
d.values;
::

method::atAll
Return an link::Classes/Array:: of all values for the given keys.
code::
d = Dictionary.newFrom([\hello, 9, \whello, "world", \z, 99, \c, 0.33]);
d.atAll([\hello, \z, \hello, \c, \whello]);
::

method::getPairs
Return an link::Classes/Array:: with all keys and values pairwise.

discussion::

code::
d = Dictionary.newFrom([\hello, 9, \whello, 77, \z, 99]);
d.getPairs;
::

Note that, unlike link::#-asPairs::, getPairs will return nil with an empty Dictionary.

code::
d = Dictionary.new;
d.getPairs;
::

method::associationAt
Access the link::Classes/Association:: that has the given key. Element is checked for equality (not identity).
code::
d = Dictionary["robot" -> 99];
d.associationAt("robot");	// Get the value associated with key
::

method::findKeyForValue
Try to find a given value and return its key. Element is checked for equality (not identity).
code::
d = Dictionary.newFrom([\hello, 1, \whello, 77]);
d.findKeyForValue(1);
::

method::matchAt
The dictionary's keys are used as conditions against which the arbitrary item is matched. See: link::Reference/matchItem::
Returns the associated value or nil if no key is matching the item.
note::
if an item matches multiple criteria, the value returned is arbitrary. This is because a dictionary is an unordered collection. It's the user's responsibility to make sure that criteria are mutually exclusive.
::
list::
## If the key is an object, the item will be matched by identity (if key === item, the value will be returned).
## If the key is a collection, the item is matched if it's contained in the collection.
## If the key is a function, the function is evaluated with the item as an argument and the item is matched if the function returns true.
::
code::
(
d = Dictionary.newFrom([
	0, \zero,
    \abc, \alpha,
    [1, 2, 3, 5, 8, 13, 21], \fibonacci,
    { |x| try { x.even } }, \even // try is needed because argument might not be a number
    ]);
);

d.matchAt(0)    // matches both 'zero' and 'even', either may be returned
d.matchAt(1)
d.matchAt(2)	// matches both 'fibonacci' and 'even', either may be returned
d.matchAt(4)
d.matchAt(\abc)
::

method::trueAt
Returns link::Classes/True:: if the item at the key is true, otherwise false. This method is also valid in link::Classes/Object::.

method::falseAt
Returns link::Classes/False:: if the item at the key is not true, otherwise true. This method is inherited from link::Classes/Object::.

subsection::Testing
method::includes
Returns true if the specified item is stored in the Dictionary as a value. Element is checked for equality (not for identity). For identity matching see subclasses: link::Classes/IdentityDictionary:: or link::Classes/Event::.
code::
var d = Dictionary.newFrom([\a, "hey", \b, "hello"]);
d.includes("hey").postln; // -> true
::

method::includesKey
Returns true if the specified item is stored in the Dictionary as a key. Element is checked for equality (not for identity). For identity matching see subclasses: link::Classes/IdentityDictionary:: or link::Classes/Event::.
code::
var d = Dictionary.newFrom(["hey", 1, "hello", 2]);
d.includesKey("hey").postln; // -> true
::

subsection::Iteration/Enumeration
Most methods for iteration work analogously to Dictionary's superclasses, see e.g. link::Classes/Collection::.

method::do, collect, reject, select
code::
// do, collect, reject, select
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.do { |item, i| [item, i].postln };
d.collect { |item| item + 100 };
d.reject { |item| item.size > 4 };
d.select { |item| item.size > 4 };
::

method::keysValuesDo
Iterate over the associations, and evaluate the function for each, passing key and value as argument.
code::
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.keysValuesDo { |key, value| postln("the key: " ++ key ++ " the value: " ++ value) };
::

method::keysValuesChange
Iterate over the associations, and evaluate the function for each, passing key and value as argument. Replace the value with the return value from the function (similar to link::#-collect::, but modifies the dictionary strong::in place::).
code::
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.keysValuesChange { |key, value| "the key: " ++ key ++ " the value: " ++ value };
d;
::

method::keysDo
Iterate over the associations, and evaluate the function for each, passing key as argument.
code::
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.keysDo { |key| postln("the key: " ++ key) };
::

method::associationsDo
Iterate over the associations, and evaluate the function for each.
code::
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.associationsDo { |assoc| postln("the association: " ++ assoc) };
::

method::pairsDo
Iterate over the associations, and evaluate the function for each, passing key and value as argument. Identical to link::#-keysValuesDo::

method::invert
Return a new dictionary with all the values as keys and vice versa.
code::
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d.invert;
::

subsection::Other instance methods

method::order
Return an array of keys which corresponds to the order of the values of the dictionary.
code::
d = Dictionary[\a -> 5, \b -> 7, \c -> 1, \d -> 0];
d.order;
d.atAll(d.order);	// returns items in order
::

method::powerset
Return the set of all subsets: here an array of all sub-dictionaries.
code::
d = Dictionary[\a -> 5, \b -> 7, \c -> 1, \d -> 0];
d.powerset;
::

method::merge
Combine two dictionaries into a new one by applying a function to each value. If strong::fill:: is true (default: true), values missing from one of them are kept as they are.
code::
d = Dictionary[\a -> 5, \b -> 7, \d -> 0];
e = Dictionary[\a -> 3, \b -> -3, \c -> 1];
merge(d, e, { |a, b| a + b });
merge(d, e, { |a, b| a + b }, false);
::
argument::that
another dictionary.
argument::func
a link::Classes/Function::.
argument::fill
a link::Classes/Boolean::.

method::blend
Blend two dictionaries into a new one by interpolating each value. If strong::fill:: is true (default: true), values missing from one of them are kept as they are.
code::
d = Dictionary[\a -> 5, \b -> 7, \d -> 0];
e = Dictionary[\a -> 3, \b -> -3, \c -> 1];
blend(d, e, 0.3);
blend(d, e, 0.3, false);

d = Dictionary[\a -> 500, \b -> 0.001];
e = Dictionary[\a -> 300, \b -> 0.1];
blend(d, e, 0.3, specs: (a: \freq, b: \rq));
::
argument::that
another dictionary.
argument::blend
the blend ratio as a link::Classes/Float:: between 0.0 and 1.0.
argument::fill
a link::Classes/Boolean::.
argument::specs
a dictionary of link::Classes/Spec::s that are applied to each before blending.

method::asSortedArray
Return the values in a sorted array of key value pairs. Sorted by key.
code::
d = Dictionary[\a -> 5, \b -> 7, \c -> 1, \d -> 0];
d.asSortedArray;
::

method::asDict
If no arguments are passed, return itself.  This is part of the link::Reference/Key-Value-Pairs:: interface.
argument::mergeFunc
This argument is not used, but exists to make the method compatible with link::Classes/Collection#-asDict::.
argument::class
A dictionary class to convert to, if given (conversion is done via code::newFrom::).

method::asPairs
Return the values in an array of alternating key value pairs, like code::[\freq, 1848, \amp, 0.2]::.  This is part of the link::Reference/Key-Value-Pairs:: interface.
argument::class
The class of the collection to be returned. By default this is an link::Classes/Array::.

discussion::

code::
d = Dictionary[\a -> 5, \b -> 7, \c -> 1, \d -> 0];
d.asPairs;
::

Note that, unlike link::#-getPairs::, asPairs will return an empty Array with an empty Dictionary.

code::
d = Dictionary.new;
d.asPairs;
::

method::asKeyValuePairs
See link::#-asPairs::.


method::embedInStream

argument::event
The inval, usually in an event stream. See also link::Classes/Event::.

If the event is not nil, yields a copy, adding all the elements of the receiver event (this leaves the receiver unchanged). If it is nil, return the receiver.

Because this pattern is mostly used in the context of events, the following code examples use the shortcut for the subclass link::Classes/Event:: instead of the Dictionary.

code::
a = (note: 2);
b = (note: [3, 5]);
Pseq([a, b]).play;
::

If a key "embedInStream" is given, use this function instead. The behaviour of the event can be configured easily this way.

The arguments event (the receiver) and inevent (the inevent) are passed to the function. note::In infinite patterns, you strong::must:: call yield or embedInStream in the function, otherwise it will loop forever.::


code::
(
a = (
	pattern: Pbind(\note, Pgeom(1, 1.1, { 20.rand }), \dur, 0.05),
	embedInStream: { |event, inevent| event[\pattern].embedInStream(inevent) }
);
b = (note: [3, 5]);
c = (freq: 402, dur: 0.3);
Prand([a, b, c], inf).trace.play;
)

// change the events while playing
c[\freq] = [900, 1002, 1102];
c[\freq] = [200, 101, 1102];
::


A generator for dictionaries:

code::
(
d = (
	a: 5, b: 7, c: 1,
	rout: Routine { |inval|
		inf.do { |i|
			var event = d.copy.put(\count, i);
			inval = event.embedInStream(inval);
		}
	}
);
)

// draw new values
d.rout.((z:999));
d.rout.((z:1, a:0));
d.rout.(());
::

SECTION::Overview

subsection::The Difference between Dictionary, IdentityDictionary, Environment, and Event

Often, the subclass link::Classes/Event:: is used as an IdentityDictionary, because there is a syntactical shortcut:
code::
a = (foo: 7);	// return a new Event.
a.put(\foo, 2.718);
a.at(\foo);
a[\foo] = 3.5;	// different syntax for put
::

Event, Environment and IdentityDictionary differ mainly insofar from Dictionary as the strong::keys:: are taken to be identical (===) objects (see IdentityDictionary), instead of equal (==) objects. By consequence, the subclasses are also faster for indexing. Apart from this, the subclasses add specific functionality only.
code::
// preliminary identity and equality of strings and symbols
"hello" == "hello";	// true, but
"hello" === "hello";	// false. However:
\hello === \hello;	// true

// compare: Dictionary will only store one "hello"
Dictionary["hello" -> 0, "hello" -> 1]; // Dictionary[ (hello -> 1) ]
// while Event will store both "hello" because they are not identical
("hello": 0, "hello": 1); // ( "hello": 1, "hello": 0 )

// for symbols as keys, Dictionary and Event show the same behaviour:
Dictionary[\hello -> 1, \hello -> 0]; // Dictionary[ (hello -> 0) ]
( \hello: 1, \hello: 0 ); // ( 'hello': 0 )
::


class:: DigitalIO
summary:: Read or write data to a digital pin
related:: Classes/AnalogIn, Classes/AnalogOut, Classes/DigitalIn, Classes/DigitalOut
categories::  UGens>Bela


Description::

Reads or writes digital data from or to a digital pin.
The pin number of this UGen can be modulated, as well as its I/O mode, which allows to tri-state the pin.

note::
This UGen only works on Bela.
::

note::
If you do not need to change the pin mode or the pin, you should use the UGen link::Classes/DigitalIn:: or link::Classes/DigitalOut::
::

classmethods::

method::ar

The output of this UGen is always the last value read when the digital pin was an input.

argument::digitalPin

Digital pin number to write to. Pin numbers begin at 0. This value can be modulated at audiorate.

argument::output

Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0. This value can be modulated at audio rate.

argument::pinMode

Value to write out to the pin - the pin will be an input when the argument is smaller than 0.5, otherwise an output. This value can be modulated at audiorate.

argument::mul

argument::add

method::kr

The output of this UGen is always the last value read when the digital pin was an input.

argument::digitalPin

Digital pin number to write to. Pin numbers begin at 0.

argument::output

Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0.

argument::pinMode

Value to write out to the pin - the pin will be an input when the argument is smaller than 0.5, otherwise an output.

argument::mul

argument::add

Examples::

code::
// write a sine oscillator's output to a pin, and read the pin value at other times

(
SynthDef("help-DigitalIO",{ arg out=0;
    DigitalIO.ar( 0, SinOsc.ar( 10 ),LFPulse.kr( 0.1 ) ).poll;
}).play;
)

::


class:: DigitalIn
summary:: Read data from a digital input
related:: Classes/AnalogIn, Classes/AnalogOut, Classes/DigitalOut, Classes/DigitalIO
categories::  UGens>Bela


Description::

Reads digital data from a digital sensor input (e.g.: a button or trigger input).

note::
This UGen only works on Bela.
::

note::
If you want to modulate the pin number, you should use the UGen link::Classes/DigitalIO::
::

classmethods::

method::ar

argument::digitalPin

Digital pin number to read. Pin numbers begin at 0. This value cannot be modulated.

argument::mul

argument::add

method::kr

argument::digitalPin

Digital pin number to read. Pin numbers begin at 0. This value cannot be modulated.

argument::mul

argument::add


Examples::

code::
// turn on and off a sine oscillator

(
SynthDef("help-DigitalIn",{ arg out=0;
	Out.ar(out,
	  SinOsc.ar( 500, 0, 0.1 * DigitalIn.ar( 0 ) )
	)
}).play;
)
::



class:: DigitalOut
summary:: Write data to a digital output
related:: Classes/AnalogIn, Classes/AnalogOut, Classes/DigitalIn, Classes/DigitalIO
categories::  UGens>Bela


Description::

Writes digital data to a digital output (e.g.: an LED or a trigger/gate output).

note::
This UGen only works on Bela.
::

note::
If you want to modulate the pin number, you should use the UGen link::Classes/DigitalIO::
::

classmethods::

method::ar

argument::digitalPin

Digital pin number to write to. Pin numbers begin at 0. This value cannot be modulated.

argument::output

Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0.

argument::mul

argument::add


method::kr

argument::digitalPin

Digital pin number to write to. Pin numbers begin at 0. This value cannot be modulated.

argument::output

Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0.

argument::mul

argument::add


Examples::

code::
// write a sine oscillator's output to a pin

(
SynthDef("help-DigitalOut",{ arg out=0;
    DigitalOut.ar( 0, SinOsc.ar( 10 ) );
}).play;
)

::


class:: DiskIn
summary:: Stream in audio from a file.
related:: Classes/PlayBuf, Classes/VDiskIn, Classes/DiskOut
categories::  UGens>InOut, UGens>Buffer

Description::

Continuously play a longer soundfile from disk. This requires a buffer to
be preloaded with one buffer size of sound.

DiskIn cannot alter playback rate. See link::Classes/VDiskIn:: for a
disk-streaming UGen with rate control.


classmethods::
private:: categories

method::ar

argument::numChannels
Number of channels. This must match the number of channels in the buffer.

argument::bufnum
Buffer number
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument:: loop
If set to 1, the soundfile will loop.

Note:: If the buffer has a larger number of frames than the sound file there will be a noticeable gap between the first and the following loop iterations. In that case chose a smaller buffer size or use link::Classes/PlayBuf##PlayBuf:: instead::

discussion::
This UGen will set the link::Classes/Done##'done' flag:: when finished playing.





instancemethods::
private:: init

Examples::

code::
s.boot; // start the server

// examples below will use this synthdef
(
SynthDef("help-Diskin", { |out, bufnum = 0|
	Out.ar(out, DiskIn.ar(1, bufnum));
}).add
)
::

subsection:: Normal usage (with Buffer; "Object Style")
code::
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);

x = { DiskIn.ar(1, b.bufnum) }.play;

b.close;

// again
// note the like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0);

x.free; b.close; b.free;



// loop it (for better looping use PlayBuf!)
(
p = Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff";
a = SoundFile.new;
a.openRead(p);
d = a.numFrames/s.sampleRate; // get the duration
a.close; // don't forget
b = Buffer.cueSoundFile(s, p, 0, 1);
f = { DiskIn.ar(1, b.bufnum) };
x = f.play;
r = Routine({
	loop({ d.wait; x.free; x = f.play; b.close( b.cueSoundFileMsg(p, 0)) });
}).play; )
r.stop; x.free; b.close; b.free; // you need to do all these to properly cleanup



// cue and play right away
(
SynthDef("help-Diskin", { |out, bufnum = 0|
	Out.ar(out, DiskIn.ar(1, bufnum));
}).add;
)

(
x = Synth.basicNew("help-Diskin");
m = { arg buf; x.addToHeadMsg(nil, [\bufnum, buf.bufnum])};

b = Buffer.cueSoundFile(s,Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1, completionMessage: m);

)

::

subsection:: OSC Messaging Style
code::
// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 1);

// open an input file for this buffer, leave it open
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 65536, 0, 1);

// create a diskin node
s.sendMsg("/s_new", "help-Diskin", x = s.nextNodeID, 1, 1);

s.sendMsg("/b_close", 0); // close the file (very important!)


// again
// don't need to reallocate and Synth is still reading
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 0, 0, 1);

s.sendMsg("/n_free", x); // stop reading

s.sendMsg("/b_close", 0); // close the file.

s.sendMsg("/b_free", 0); // frees the buffer
::



class:: DiskOut
summary:: Record to a soundfile to disk.
related:: Classes/RecordBuf, Classes/DiskIn, Classes/VDiskIn
categories::  UGens>InOut, UGens>Buffer

Description::
Record to a soundfile to disk. Uses a link::Classes/Buffer::.

See link::Classes/RecordBuf:: for recording into a buffer in memory.

subsection:: Disk recording procedure

Recording to disk involves several steps, which should be taken in the right order. link::Classes/Server#-record:: performs these steps for you. To record arbitrary buses using DiskOut explicitly, make sure to do the following:

numberedlist::
## Define a DiskOut link::Classes/SynthDef::, as shown in the example below.
## Allocate a link::Classes/Buffer:: for recording.
list::
## The buffer size should be a power of two.
## A duration of at least one second is recommended: code::s.sampleRate.nextPowerOfTwo::.
## Do not allocate the buffer inside the SynthDef.
## Keep the buffer in a variable.
::
## Specify the file path and recording format using link::Classes/Buffer#-write::, with the teletype::leaveOpen:: flag set to code::true::. This is the only way to set the file path and recording format.
## Create a link::Classes/Synth:: node to run the DiskOut UGen.
## When recording is finished, stop the DiskOut synth.
## Close the buffer: code::b.close::. This step updates the recorded file's audio header. Without it, the file will be unusable.
## Free the buffer: code::b.free::.
::

These steps are illustrated in the Examples section. In general, only the "Object Style" approach is needed. ("Messaging Style" is provided as a historical reference, but it isn't needed for typical use.)

classmethods::
private:: categories

method::ar

argument::bufnum
The number of the buffer to write to (prepared with /b-write or
Buffer.write)
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument::channelsArray
The Array of channels to write to the file.
Note:: The number of channels in the buffer and the channelsArray must be the same, otherwise DiskOut will fail silently (and not write anything to your file). ::

returns:: The number of frames written to disk.

instancemethods::
private:: checkInputs

Examples::
code::
s.boot; // start the server
(
// something to record
SynthDef("bubbles", { |out|
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps; // glissando function
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(out, zout)
}).add;

// this will record to the disk
SynthDef("help-Diskout", { |bufnum|
	DiskOut.ar(bufnum, In.ar(0,2));
}).add;

// this will play it back
SynthDef("help-Diskin-2chan", { |out, bufnum = 0|
	Out.ar(out, DiskIn.ar(2, bufnum))
}).add;
)
::

subsection:: Object Style
code::
// start something to record
x = Synth("bubbles");

// allocate a disk i/o buffer
b= Buffer.alloc(s, 65536, 2);

// create an output file for this buffer, leave it open
b.write("~/diskouttest.wav".standardizePath, "wav", "int16", 0, 0, true);
// create the diskout node; making sure it comes after the source
d = Synth.tail(nil, "help-Diskout", ["bufnum", b]);
// stop recording
d.free;
// stop the bubbles
x.free;
// close the buffer and the soundfile
b.close;
// free the buffer
b.free;

// play it back
(
x = Synth.basicNew("help-Diskin-2chan");
m = { |buf| x.addToHeadMsg(nil, [\bufnum,buf])};

b = Buffer.cueSoundFile(s,"~/diskouttest.wav".standardizePath, 0, 2, completionMessage: m);
)
x.free; b.close; b.free; // cleanup
::

subsection:: Messaging Style
code::
// The same thing done in Messaging Style (less overhead but without the convenience of objects)
// This does nothing different from the Messaging Style example.
// If any of the following is confusing, stick to Object Style
// and ignore this part.

// start something to record
s.sendMsg("/s_new", "bubbles", 2003, 1, 1);

// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 2); // Buffer number is 0

// create an output file for this buffer, leave it open
s.sendMsg("/b_write", 0, "~/diskouttest.wav".standardizePath, "wav", "int16", 0, 0, 1);

// create the diskout node
s.sendMsg("/s_new", "help-Diskout", 2004, 3, 2003, "bufnum", 0);

s.sendMsg("/n_free", 2004); // stop recording
s.sendMsg("/n_free", 2003); // stop the bubbles

s.sendMsg("/b_close", 0); // close the file.
s.sendMsg("/b_free", 0);
::



class:: Diwhite
summary:: Demand rate white noise random generator.
related:: Classes/Dwhite, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dwhite::  returns numbers in the continuous range between
code::lo::  and  code::hi:: .
Diwhite returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pwhite::,  link::Classes/WhiteNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::length

Number of values to create.


Examples::

code::

(
{
	var a, freq, trig;
	a = Diwhite(0, 15, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Document
redirect:: implementationClass
summary:: Editor-specific text document editing
categories:: Frontends
related:: Classes/EmacsDocument, Classes/ScelDocument

description::
The Document class represents a text document within the context of your text editing environment. You can use the class to programmatically create, modify, and query these documents.

Document used to be an abstract class, meaning it didn't provide all the functionality itself, but instead relied on subclasses to complete the functionality. One such subclass was CocoaDocument. Although CocoaDocument was available only to macOS and had an ad hoc interface, it possessed many additional features like code animation and rich text.

In SuperCollider 3.6, Document changed a bit and now the "abstract class" descriptor is only partially true. The SuperCollider IDE provides its own version of the Document class. The Emacs editor still supplies link::Classes/ScelDocument:: (which links to link::Classes/EmacsDocument::) as a subclass of Document. As an unfortunate byproduct of the history of Document, there are inconsistencies in the APIs of SCIDE's Document and Emacs' ScelDocument. This help file describes that of SCIDE.

Future versions of SuperCollider will aim to fix these API inconsistencies and restore the functionality of CocoaDocument.

subsection:: Setting the Environment

By default code::envir:: it is set to the current link::Classes/Environment::. However, you can make it use its own link::Classes/Environment:: also. Thus, e.g., if you were to set the link::Classes/Environment:: variable code::~myVar = 12:: in the current link::Classes/Environment::, you can create a new Document window in which that link::Classes/Environment:: variable is not set.

classmethods::

private:: prGetLast, prSetSyntaxColorTheme, prnumberOfOpen, prBasicNew, prGetIndexOfListener, prDefaultUsesAutoInOutdent, initClass

method:: new
argument:: title
An instance of link::Classes/String:: or link::Classes/Symbol::.
argument:: string
An instance of link::Classes/String::. The contents of the document.
argument:: envir
An instance of link::Classes/Environment::. The link::Classes/Environment:: to be used by the interpreter of the document window. By default, it is set to the current link::Classes/Environment::.
discussion::
code::
Document.new("this is the title", "this is the text");
::

method:: open
Open a document from a path.
argument:: path
The file system path to the document. An instance of link::Classes/String::.
argument:: selectionStart
The beginning of the cursor selection of the file content.
argument:: selectionLength
The length of the cursor selection of the file content.
argument:: envir
An instance of link::Classes/Environment::. The Environment to be used by the interpreter of the document window. By default, it is set to the current link::Classes/Environment::.
discussion::
See also link::Classes/Document#save:: below.
code::
Document.open("README", 292,253); // notice the selected text in the open document
::

method:: openDocuments
Returns an Array of all open documents.
code::
d = Document.openDocuments.do{ |doc| doc.name.postln };
::

method:: hasEditedDocuments
Returns true if there are edited Documents.

method:: closeAll
warning::
Closes all open Documents, whether edited or not.
::
argument:: leavePostWindowOpen
An instance of link::Classes/Boolean::.

method:: closeAllUnedited
Closes all unedited Documents.
argument:: leavePostWindowOpen
An instance of link::Classes/Boolean::.

method:: current
Gets/sets the current Document.
argument:: value
A Document.
discussion::
code::
Document.current.name.postln; // Prints "Document.html"
::

method:: allDocuments
Returns all documents.

method:: globalKeyDownAction
Get/set A global action to be performed when a key is pressed.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: globalKeyUpAction
Get/set A global action to be performed when a key is released.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: initAction
Get/set A an action to be performed up opening or creating a Document.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: autoRun
If autoRun is set to true, documents beginning with the comment code::/*RUN*/:: will be executed immediately after being opened, and also when the class library is recompiled with the document already open in the IDE.
argument:: value
An instance of link::Classes/Boolean::. Default value is code::true::.

method:: implementationClass
The editor implementation specific class which will handle Documents.
argument:: value
A class for implementing Document.

subsection:: Path Utilities

Utilities and settings for dealing with documents such as SuperCollider code files. By default the document directory is SuperCollider's application directory.

method:: dir
Get/set the default document directory. The default is dependent on link::#*implementationClass::.
argument:: path
The file system path to the directory. An instance of link::Classes/String::.
discussion::
In Main-startUp you can set this to a more practical directory:
code::
Document.dir = "~/Documents/SuperCollider";
::

method:: standardizePath
argument:: p
The file system path to the directory. An instance of link::Classes/String::.
discussion::
If it is a relative path, expand it to an absolute path relative to your document directory. Expand tildes in path (your home directory), resolve symbolic links (but not aliases). Also converts from Mac OS 9 path format. See PathName for more complex needs.
code::
Document.standardizePath("~/"); // This will print your home directory

Document.standardizePath(":Patches:newfoots:fastRuckAndTuck");
// Returns: /Volumes/Macintosh HD/Users/cruxxial/Documents/SC3docs/Patches/newfoots/fastRuckAndTuck

Document.standardizePath("~/Documents/SC3docs/Patches/newfoots/fastRuckAndTuck");
// Returns: Patches/newfoots/fastRuckAndTuck

Document.standardizePath("Patches/newfoots/fastRuckAndTuck")
// Returns: Patches/newfoots/fastRuckAndTuck
::

method:: abrevPath
Returns a path relative to Document.dir, if the path is inside Document.dir.
argument:: path
The file system path to the directory. An instance of link::Classes/String::.




instancemethods::

private:: prGetBackgroundColor, prGetBounds, prIsEditable, propen, prGetTitle, prinitByString, prGetLastIndex, prSetBackgroundColor, prSetFileName, prUsesAutoInOutdent, prclose, prGetSelectedBackgroundColor, prGetFileName, prSetSelectedBackgroundColor, prSelectLine, prinitByIndex, prAdd, prSetBounds, prinsertText, prSetTitle, initFromPath, initByString

subsection:: General Document Properties

method:: path
Get / set the Document's path.
argument:: apath
An instance of link::Classes/String::. A files system path.
discussion::
code::
Document.current.path.postln;
::

method:: dir
Returns the directory of a Document.
discussion::
code::
Document.current.dir.postln;
::

method:: ==
A binary operator.
argument:: that
An instance of Document.
discussion::
code::
Document.current == Document.listener; // presumably returns false
::

method:: editable
Get / set the document is editable.
argument:: bool
An instance of link::Classes/Boolean::.

method:: name
Get / set the title (same as link::#-title::).
argument:: aname
An instance of link::Classes/String::.
discussion::
code::
Document.current.name.postln;
::

method:: title
Get / set the title (same as link::#-name::).
argument:: newTitle
An instance of link::Classes/String::.

method:: promptToSave
Get/set whether a document is prompts to save if it has been changed. Use this with caution.
argument:: bool
An instance of link::Classes/Boolean::.

method:: closed
Returns code::true:: if the document has been closed.

method:: isEdited
Returns code::true:: if the document has been edited.
code::
Document.current.isEdited.postln;
::

method:: isFront
Returns code::true:: if the document is in front.

method:: didBecomeKey
Saves the current link::Classes/Environment::, makes the document current, and performs its link::#-toFrontAction::.

method:: didResignKey
Performs the Document's link::#-endFrontAction:: and restores the current link::Classes/Environment::.



subsection:: Controlling Document

method:: close
Close a document.
code::
(
Task({
	var doc;
	doc = Document("background", "closing in 2 seconds");
	doc.stringColor_(Color.blue);
	1.wait;
	doc.background_(Color.blue(alpha:0.8));
	1.wait;
	doc.close;
}).play(AppClock);
)
::

method:: save
Save this Document.
argument:: path
An optional instance of link::Classes/String:: indicating the path to save the Document. If a path is not provided, the current path (if it has been previously saved or read) is used. After a successful save, this Document's path will be updated if needed. See also link::Classes/Document#*open:: above.
code::
d = Document.new("testSave", "foo");
d.save(Platform.defaultTempDir ++ "foo.scd"); // saved in the temp dir
d.string_("foobar", 0, 3);
d.save; // save at previous path
d.string_("save as now", 0, 6);
d.save(Platform.defaultTempDir ++ "savedAs.scd");
d.path;
::

method:: front
Bring a document to the front.
code::
Document.listener.front;
::

method:: onClose
Get/set the action to be performed on closing the document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: endFrontAction
Get/set the action to be performed when the document becomes no longer the front document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: toFrontAction
Get / set the action to be performed when the document become the front document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: mouseDownAction
Get/set the action to be performed on link::#-mouseDown::.

argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::document::, code::x::, code::y::, code::modifiers::, code::buttonNumber::, code::clickCount::.


method:: mouseUpAction
Get/set the action to be performed on link::#-mouseUp::.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::document::, code::x::, code::y::, code::modifiers::, code::buttonNumber::.
discussion::
code::
(

//add a mouse action to this document:
//example: easy button:
//when you click in front of a 17 a SinOsc will start up;
s.waitForBoot({
	Document.current.mouseUpAction_({arg doc;
		var char;
		char = doc.rangeText(doc.selectionStart, 2);
		if(char == "17",{
			{EnvGen.kr(Env.perc, doneAction: Done.freeSelf) * SinOsc.ar([600,720,300].choose, 0, 0.5)}.play;
		});
		if(char == "23",{
			{EnvGen.kr(Env.perc, doneAction: Done.freeSelf) * PinkNoise.ar(0.2)}.play;
		});
	})
});
)
::
Test here and click in front of the numbers: 17 and 23.
code::
Document.current.mouseUpAction = nil; // clear mouseUpAction
::


method:: keyDownAction
Get/set the action to be performed on link::#-keyDown::.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::document::, code::char::, code::modifiers::, code::unicode::, code::keycode::. See link::Classes/View#Key actions:: for details on these arguments.
discussion::
code::
Document.current.keyDownAction = { arg ...args; args.postln };
// now type some text
Document.current.keyDownAction = nil;
::

method:: keyUpAction
Get/set the action to be performed on link::#-keyUp::.
argument:: action
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::document::, code::char::, code::modifiers::, code::unicode::, code::keycode::. See link::Classes/View#Key actions:: for details on these arguments.
discussion::
code::
Document.current.keyUpAction = { arg ...args; args.postln };
// now type some text
Document.current.keyUpAction = nil;
::

subsection:: Accessing and Editing Content

method:: selectLine
Select a line of the document by number.
argument:: line
An link::Classes/Integer::.
discussion::
code::
Document.current.selectLine(390);
::

method:: selectRange
Select a text range in the string of the document.
argument:: start
The start index.
argument:: length
The length of the selection.
discussion::
code::
(
Document.current.selectRange(Document.current.selectedRangeLocation + 3, 150);
)
::

method:: selectionStart
Returns the start of a current selection.
code::
Document.current.selectionStart.postln;
::

method:: selectionSize
Returns the size of a current selection.
code::
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.selectionSize.postln;
)
::


method:: selectedString
Gets/sets the selected string.
argument:: txt
An instance of link::Classes/String::.
discussion::
code::
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.selectedString.postln;
)
::

method:: currentLine
Returns the current line as a link::Classes/String::.
code::
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.currentLine.postln;
)
::

method:: getSelectedLines
Returns all full lines from before code::rangestart:: to after code::rangestart + rangesize:: as a link::Classes/String::.
discussion::
code::
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.getSelectedLines(doc.selectionStart - 40, 130).postln;
)
::


method:: string
Gets or sets the string within a certain range.
argument:: string
A link::Classes/String::.
argument:: rangestart
An link::Classes/Integer::.
argument:: rangesize
An link::Classes/Integer::.
discussion::
code::
// Select the following code in parentheses and execute it
(
Document.current.string_(": test test test test test ",
	Document.current.selectedRangeLocation + 12,
	18);
)
// Watch me change content
::

method:: getText
Get a range of text from the document. Synchronous. The text is directly returned.
argument:: start
An link::Classes/Integer:: for the starting position to access.
argument:: range
An link::Classes/Integer:: for the number of characters to retrieve. -1 retrieves to the end of the document.

method:: getTextAsync
Get a range of text from the document. Asynchronous. The text is passed to the code::action:: function as an argument.

note:: Currently, in Windows, link::#-getText:: and link::#-string:: may be unreliable. Windows users are recommended to use link::#-getTextAsync:: for the time being.
::

argument:: action
A function to evaluate after the request is complete. It is passed one argument, a link::Classes/String::, for the retrieved contents.
argument:: start
An link::Classes/Integer:: for the starting position to access.
argument:: range
An link::Classes/Integer:: for the number of characters to retrieve. -1 retrieves to the end of the document.



subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.
code::
	*startup
	*numberOfOpen
	mouseUp (x, y, modifiers, buttonNumber, clickCount, clickPos)
	keyDown (character, modifiers, unicode, keycode)
	keyUp (character, modifiers, unicode, keycode)
	getIdentifierCoordFromEnd (endPos)
	dataptr

	Private. Used only internally:
	*newFromIndex (idx)
	*prnumberOfOpen
	*prGetLast
	*prGetIndexOfListener
	*prBasicNew
	prAdd
	prGetLastIndex
	setFont (font, rangeStart, rangeSize)
	setTextColor (color, rangeStart, rangeSize)
	propen (path, selectionStart, selectionLength)
	rangeText (rangestart, rangesize)
	insertTextRange (string, rangestart, rangesize)
	prinitByString (title, str, makeListener)
	prSetBackgroundColor (color)
	prGetBackgroundColor (color)
	prSelectLine (line)
	prIsEditable_ (editable)
	prSetTitle (argName)
	prGetTitle
	prGetFileName
	prSetFileName (apath)
	prGetBounds (argBounds)
	prSetBounds (argBounds)
	prclose
	prinsertText (dataPtr, txt)
	prinitByIndex (idx)
	envir
	envir_ (ev)
	text
	removeUndo
	selectedText
	selectUnderlinedText (clickPos)
	linkAtClickPos (clickPos)
	selectedRangeLocation
	selectedRangeSize
	restoreCurrentEnvironment
	saveCurrentEnvironment
	initByIndex (idx)
	initLast
	initFromPath (path, selectionStart, selectionLength)
	initByString (argTitle, str, makeListener)
::





examples::

code::
//unfocusedFront_
(
Document.allDocuments.at(0).unfocusedFront
)


(
var doc;
doc = Document("", "||");
doc.background_(Color.blue(alpha: 1.0.rand));

Task({
	1000.do({
		doc.setFont(rangeSize: [7, 8, 9, 24].choose);
		0.08.wait;
	})
}).play(AppClock);

Task({
	100.do({
		1.01.wait;
		doc.stringColor_([Color.red(alpha: 1.0.rand), Color.green(alpha: 1.0.rand)].choose);
	})
}).play(AppClock);

Task({
	100.do({
		1.01.wait;
		doc.selectedString_(["\"\n#", "||", "-", "--"].choose);
	})
}).play(AppClock);

Task({
	var co, mul;
	co = 0.1;
	mul = 1.02;
	100.do({
		0.16.wait;
		co = co * mul;
		if(co > 0.99, { co = 0.1 });
		doc.background_(Color.blue(alpha: co));
	});
	doc.close;
}).play(AppClock)
)
::

A simple implementation of TBT (time based text) http://tbt.dyne.org/?info=download
code::
// record: type some text
(
var time = Main.elapsedTime;
a = List.new;
r = Routine { |char|
loop {
	a = a.add([char, Main.elapsedTime - time]);
	char = 0.yield;
}
};

Document.new("type some text")
	.bounds_(Rect(100,SCWindow.screenBounds.height - 250, 400, 200))
	.keyDownAction = { |doc, key| r.value(key) ; time = Main.elapsedTime};
)

// play back text in time
(
d = Document.new("type some text")
	.bounds_(Rect(550,SCWindow.screenBounds.height-250,400,200));
fork({
	a.do { |pair|
		d.string = d.string ++ pair[0];
		pair[1].wait;
	}
}, AppClock)
)
::

Changing the default look of documents can be done with the help of the link::#*initAction:: method. Run the following example once. Afterwards all newly created documents will have a dark grey background. To make this change happen every time you start SuperCollider, put the code inside your startup.scd file (and optionally wrap it in a code::{}.defer(0.1):: ).
code::
(
Document.listener.background = Color.red;	//a special color for post document
Document.listener.bounds = Rect(1, 461, 620, 567);	//move and resize post document
Document.initAction = {|doc|			//function to run for every new document
	doc.background = Color.grey(0.1, 0.9);
	doc.bounds = Rect(0, 119, 1280, 659);
	doc.selectedBackground = Color(0.4, 0.05, 0.18);
	doc.stringColor = Color.grey(0.9);
};
)
::


title:: DoesNotUnderstandError
summary:: Error thrown when calling an unknown method name
categories::Core
related:: Classes/Error

description::

This error is typically generated when a method that doesn't exist on the receiver is called. Users typically do not
construct this object themselves. The object has a few getters to learn more about the call that caused the error.

This method reports a backtrace as well as a best-guess suggested replacement based on edit distance.

classmethods::

method:: new
Construct a new DoesNotUnderstandError, and choose a possible suggested replacement based on the class of the
receiver and contents of the selector.

argument:: receiver
The object on which the method was called.

argument:: selector
The method name that was not understood.

argument:: args
Arguments passed to the unknown method.

instancemethods::

method:: selector
returns:: The selector passed to new. Typically, the method name that was not understood.

method:: args
returns:: The args passed to new. Typically, an array of arguments passed to the unknown method.

method:: suggestedCorrection
returns:: If there is a method that the receiver would understand that looks similar to the unknown method name, the
the link::Classes/Method:: object that corresponds to it. Otherwise, code::nil::.

method:: errorString
returns:: Short-form representation of the error as a link::Classes/String::, with a suggested replacement if one was
found.

method:: reportError
Print a long-form explanation of the error including backtrace and suggested replacement if one was found.


class:: Done
summary:: Monitors another UGen to see when it is finished
related::  Classes/UGen, Classes/FreeSelfWhenDone, Classes/PauseSelfWhenDone
categories::  UGens>Synth control, Server>Nodes

Description::

Some UGens set a 'done' flag when they are finished playing. This UGen echoes that flag when it is set to track a particular UGen.

The UGens trackable by Done are:
list::
## link::Classes/PlayBuf::
## link::Classes/RecordBuf::
## link::Classes/Line::
## link::Classes/XLine::
## link::Classes/EnvGen::
## link::Classes/Linen::
## link::Classes/BufRd::
## link::Classes/BufWr::
## link::Classes/Dbufrd::
## link::Classes/Dbufwr::
## link::Classes/DiskIn::
## link::Classes/VDiskIn::
## link::Classes/Demand::
::

section:: Actions
A number of UGens implement doneActions. These allow one to optionally free or pause the enclosing synth and other related nodes when the UGen is finished. You can use the constants in this class to name doneActions, which can be clearer than using the number codes alone. The available doneActions are as follows:

table::
## name     || value || description
## none || 0 || do nothing when the UGen is finished
## pauseSelf || 1 || pause the enclosing synth, but do not free it
## freeSelf || 2 || free the enclosing synth
## freeSelfAndPrev || 3 || free both this synth and the preceding node
## freeSelfAndNext || 4 || free both this synth and the following node
## freeSelfAndFreeAllInPrev || 5 || free this synth; if the preceding node is a group then do g_freeAll on it, else free it
## freeSelfAndFreeAllInNext || 6 || free this synth; if the following node is a group then do g_freeAll on it, else free it
## freeSelfToHead || 7 || free this synth and all preceding nodes in this group
## freeSelfToTail || 8 || free this synth and all following nodes in this group
## freeSelfPausePrev || 9 || free this synth and pause the preceding node
## freeSelfPauseNext || 10 || free this synth and pause the following node
## freeSelfAndDeepFreePrev || 11 || free this synth and if the preceding node is a group then do g_deepFree on it, else free it
## freeSelfAndDeepFreeNext || 12 || free this synth and if the following node is a group then do g_deepFree on it, else free it
## freeAllInGroup || 13 || free this synth and all other nodes in this group (before and after)
## freeGroup || 14 || free the enclosing group and all nodes within it (including this synth)
## freeSelfResumeNext || 15 ||  free this synth and resume the following node

::

For information on code::freeAll:: and code::deepFree::, see link::Classes/Group:: and link::Reference/Server-Command-Reference::.

section:: Alternatives
Another way to free a synth when some UGen is done playing is to use link::Classes/FreeSelfWhenDone::, or link::Classes/FreeSelf:: in combination with link::Classes/Done::. For example, this can be used to delay the freeing to let reverb tails fade out, etc.

classmethods::
private:: categories

method::kr

argument::src

The UGen to monitor

examples::
The 'done' flag can be used to trigger other things in the same synth:
code::
(
SynthDef("Done-help", { arg out, t_trig;
	var line, a, b;

	line= Line.kr(1,0,1);

	a= SinOsc.ar(440,0,0.1*line); //sound fading out
	b= WhiteNoise.ar(Done.kr(line)*0.1); //noise starts at end of line

	Out.ar(out, Pan2.ar(a+b));
}).add;
)

Synth("Done-help"); //note that this synth doesn't have it's own doneAction, so you'll need to manually deallocate it
::
The 'done' flag can be used to trigger a delayed freeing of the current synth, which is not possible by using doneActions alone:
code::
play {
    var env = Line.kr(1,0,2);
    var sig = PinkNoise.ar(env);
    FreeSelf.kr(TDelay.kr(Done.kr(env),3));
    GVerb.ar(sig,70,7);
}
::


CLASS::DoubleArray
summary::an array of 64-bit double precision floating-point numbers
related::Classes/FloatArray, Classes/Signal
categories::Collections>Ordered

DESCRIPTION::
An array of 64-bit double precision floating point numbers.

Note that despite not having "Float" in its name, DoubleArray does in fact hold
a sequence of SuperCollider double precision link::Classes/Float##floats::.
For a raw array of 32-bit floats, use link::Classes/FloatArray::.

FloatArray and its subclass link::Classes/Signal:: are commonly used to hold
audio data in SuperCollider. Since almost all audio has 16-bit or 24-bit
precision, using double precision floats for this purpose would be a waste of
space. In other words, use FloatArray for audio, and DoubleArray for precise
math operations.

The complete list of RawArray types in SuperCollider is:

list::
## link::Classes/Int8Array:: - 8 bit integer
## link::Classes/Int16Array:: - 16 bit integer
## link::Classes/Int32Array:: - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## link::Classes/SymbolArray:: - symbols
::

INSTANCEMETHODS::

method::readFromStream


TITLE:: Download
summary:: Fetch a file from a remote URL
categories:: Files
related:: Classes/File

DESCRIPTION::
Download allows you to download a file from a specified URL


CLASSMETHODS::
private:: qtClass

METHOD:: new
Create and start a new Download.

ARGUMENT:: requestedURL
A link::Classes/String:: containing the URL of the file to download.

ARGUMENT:: localPath
A link::Classes/String:: containing the local path at which to save the downloaded file.

ARGUMENT:: finishedFunc
A link::Classes/Function:: to evaluate when the download is complete.

ARGUMENT:: errorFunc
A link::Classes/Function:: to evaluate if the download fails due to an error.

ARGUMENT:: progressFunc
A link::Classes/Function:: to process the download's progress. This Function will be passed two arguments, the bytes received, and the total bytes.

returns:: A new Download.

METHOD:: cancelAll
Cancel all active Downloads.


INSTANCEMETHODS::
private:: doProgress, doError, doFinished, doOnShutDown, cleanup, startDownload, init

METHOD:: cancel
Cancel the download.

METHOD:: errorFunc
Get or set the error link::Classes/Function::.

METHOD:: finishedFunc
Get or set the download finished link::Classes/Function::.

METHOD:: progressFunc
Get or set the download progress link::Classes/Function::.



EXAMPLES::

code::
Download("http://art-on-wires.org/wp-content/uploads/2011/03/nick_collins.png", "/tmp/nick.png", {\huzzah.postln;}, {\error.postln}, {|rec, tot| [rec, tot].postln}); // beautify your tmp directory

d = Download("http://scottwilson.ca/files/flame.mp3", "/tmp/flame.mp3", {\huzzah.postln;}, {\error.postln}, {|rec, tot| [rec, tot].postln});
d.cancel; // cancel this

::


class:: Dpoll
summary:: Print the current output value of a demand rate UGen
categories:: UGens>Demand, UGens>Info

description::
Print the current output value of a demand rate UGen.
WARNING:: Printing values from the Server in intensive for the CPU. Poll should be used for debugging purposes. ::

classmethods::
private:: new1

method:: new
argument:: in
ugen to poll values from
argument:: label
a label string
argument:: run
active if 1, inactive if 0. can be a demand ugen (default: 1)
argument:: trigid
discussion::
the print-out is in the form: code:: label: value block offset: offset. ::

structurally related: link::Classes/Poll::

examples::
code::

{ Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) * 2)); 0.0 }.play;

// posts only when cursor is in right half of the screen
{ Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) * 2, run: MouseX.kr > 0.5)); 0.0 }.play;

// label
{ LFPulse.ar(Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) % 10 + 1 * 30, "value"))) * 0.1 }.play;

// block offset:
{ Duty.ar(0.511, 0, Dpoll(Dseries(0, 1, inf) * 2)); 0.0 }.play;

// multichannel expansion:

(
	{
	var x = Duty.kr(0.5, 0,
		Dpoll([Dseries(0, 1, inf), Dgeom(1, 1.1, inf)], ["first", "second"])
	);
	LFPulse.ar(100 + (x * 100)) * 0.1
	}.play
)

{ Duty.kr(0.5, 0, Dpoll(( Dseries(0, 1, inf) + _ ).dup, ("value" + _).dup)); 0.0 }.play;


// the message dpoll(label, run, trigid) is a shorthand:

{ Duty.kr(0.5, 0, Dseries(0, 1, inf).dpoll); 0.0 }.play;
{ Duty.ar(0.5, 0, SinOsc.ar(0.1).dpoll); 0.0 }.play;
::



class:: DragBoth
summary:: A simple drag-and-drop source and receiver
categories:: GUI>Views
related:: Classes/DragSink, Classes/DragSource

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragBoth::, specifically, strong::accepts any:: dropped data and stores it into the strong::-object:: variable, as well as gives that variable as data strong::for dragging::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.



CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

METHOD:: defaultGetDrag
	RETURNS:: The link::Classes/StaticText#-object#-object::.

METHOD:: defaultCanReceiveDrag
	RETURNS:: Always True.

METHOD:: defaultReceiveDrag
	Sets the link::Classes/StaticText#-object#-object:: to the current drag data.



EXAMPLES::
code::
(
w = Window.new.front;
w.addFlowLayout;
// store various kinds of objects in the drag source

// a string source
a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.object = "drag us around";

a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.object="SUPERCOLLIDER";

8.do{
a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.receiveDragHandler = { arg obj; obj.object = View.currentDrag.scramble };
}
)
::


class:: DragSink
summary:: A simple drag-and-drop receiver.
categories:: GUI>Views
related:: Classes/DragBoth, Classes/DragSource

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragSink::, specifically, strong::accepts any:: dropped data and stores it into the strong::-object:: variable, but allows strong::no dragging::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.




CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

METHOD:: defaultCanReceiveDrag
	RETURNS:: Always True.

METHOD:: defaultReceiveDrag
	Sets the link::Classes/StaticText#-object#-object:: to the current drag data.



EXAMPLES::
code::
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anything
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "receive anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red) };
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
::


class:: DragSource
summary:: A simple drag-and-drop source.
categories:: GUI>Views
related:: Classes/DragSink, Classes/DragBoth

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragSource::, specifically, gives the strong::-object:: variable as the data strong::for dragging::, but strong::accepts no drop::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::

METHOD:: defaultGetDrag
	RETURNS:: The link::Classes/StaticText#-object#-object::.




EXAMPLES::
code::
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anything
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "receive anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red)};
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
::


class:: Drand
summary:: Demand rate random sequence generator.
related:: Classes/Demand, Classes/Dseq, Classes/Dser, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dxrand::  never plays the same value twice, whereas Drand
chooses any value in the list.


See link::Classes/Prand:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::

(
{
	var a, freq, trig;
	a = Drand([1, 3, 2, 7, 8], inf);
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



CLASS:: DrawGrid
summary:: Draws grid lines on a UserView for plotting
categories:: GUI>Accessories
related:: Reference/plot, Classes/AbstractGridLines, Classes/GridLines, Classes/Plotter, Classes/UserView

DESCRIPTION::
code::DrawGrid:: is used to draw link::Classes/GridLines:: and its labels on a link::Classes/UserView::. It is notably used by link::Classes/Plotter:: to draw the grid lines on a plot but can also be used to add grid lines to any code::UserView::, e.g. behind sliders or another GUI element.

See the example below for its link::#Basic use in a UserView#basic use in a UserView::.

Note that code::DrawGrid:: does not hold any reference to the code::UserView:: but is meant to have its code::-draw:: method called inside of the code::-drawFunc:: of the code::UserView::.  It only needs to know what bounds to draw the grid lines in and what the horizontal and vertical code::GridLines:: are.


CLASSMETHODS::

METHOD:: new

argument:: bounds
A link::Classes/Point:: or link::Classes/Rect:: describing the size and position of the grid within the parent view (not including any labels).

argument:: horzGrid
A grid lines object for the x-axis, instantiated via link::Classes/GridLines::, or link::Classes/ControlSpec#-grid:: method, or code::nil:: (resulting in no grid lines).

argument:: vertGrid
A grid lines object for the y-axis, see strong::horzGrid::.

returns:: A code::DrawGrid::.

discussion::
The warp behavior of the strong::horizGrid:: and strong::vertGrid:: is based on the warp behavior of the code::ControlSpec:: used by the grid lines object assigned to each axis.

Multiple code::DrawGrid:: may be used to draw grids on a single link::Classes/UserView::.

See link::#-preview:: if you'd like to preview modifications of this code::DrawGrid::. See link::#Testing and modifying#Examples:: below.


INSTANCEMETHODS::

METHOD:: draw
This draws to the currently active link::Classes/UserView::. This method is meant to be called from inside the link::Classes/UserView#-drawFunc#-drawFunc:: of a code::UserView::.

returns:: code::nil::

discussion::
See the example below for its link::#Basic use in a UserView#basic use in a UserView::, including how to manage its bounds when the enclosing view resizes.


METHOD:: horzGrid
Set the x-axis grid lines.

argument:: g
An link::Classes/AbstractGridLines:: subclass, instantiated via link::Classes/GridLines::, or link::Classes/ControlSpec#-grid:: method, or code::nil:: (resulting in no grid lines).

returns:: Self.


METHOD:: vertGrid
Set the y-axis grid lines.

argument:: g
An link::Classes/AbstractGridLines:: subclass, instantiated via link::Classes/GridLines::, or link::Classes/ControlSpec#-grid:: method, or code::nil:: (resulting in no grid lines).

returns:: Self.


METHOD:: bounds
Get/set bounds describing the extents of the grid (not including any labels).

argument:: b
A link::Classes/Rect::.

returns:: A link::Classes/Rect::.


METHOD:: font
Get/set the font used by the grid lines labels.

argument:: f
A link::Classes/Font::.

returns:: A link::Classes/Font::.

METHOD:: fontColor
Get/set the font color.

argument:: c
A link::Classes/Color::.

returns:: A link::Classes/Color::.

METHOD:: gridColors
Set the colors of the grid lines for each axis.

argument:: colors
An link::Classes/Array:: of two colors for the x and y grid lines, respectively.

returns:: Self.

METHOD:: opacity
Get/set opacity.

returns:: A code::Float::.

METHOD:: smoothing
A code::Boolean:: which turns on/off anti-aliasing. See link::Classes/Pen#*smoothing::.

returns:: A code::Boolean::.

METHOD:: linePattern
Set the line dash pattern. The strong::value:: should be a link::Classes/FloatArray:: of values that specify the lengths of the alternating dashes and spaces.
For example, code::FloatArray[10.0, 3.0, 5.0, 3.0]::, for dashes of lengths code::10.0:: and code::5.0:: pixels, separated by spaces of code::3.0:: pixels.
See link::Classes/Pen#*lineDash::.

returns:: Self.

METHOD:: x
A code::DrawGridX:: object that draws the x (horizontal) axis. In
general you shouldn't need to set this.

returns:: A code::DrawGridX::.

METHOD:: y
A code::DrawGridY:: object that draws the y (vertical) axis. In general
you shouldn't need to set this.

returns:: A code::DrawGridY::.


METHOD:: numTicks
Set the emphasis::approximate:: number of grid lines ("ticks") for each axis. If set, the number of ticks is fixed and code::numTicks:: takes precedence over link::#-tickSpacing::. If code::nil::, the number of grid lines change with the view size, constrained by the code::tickSpacing::.
Default: code::nil::.

See link::#Testing and modifying#Examples:: below.

argument:: x
emphasis::Approximate:: number of grid lines ("ticks") for the x-axis.

argument:: y
emphasis::Approximate:: number of grid lines for the y-axis.

discussion::
The resulting number of ticks is approximate because of the underlying algorithm in link::Classes/AbstractGridLines#-niceNum::, which tries to find suitable values for the grid lines based on the data range and your requested code::numTicks::. You can observe the behavior of code::GridLines:-niceNum:: with this snippet:
code::
(
g = GridLines([0, 200].asSpec);
"requested / returned".postln;
(0, 3 .. 21).do({ |ntck|
  "% / %\n".postf(ntck, g.niceNum(ntck, true))
})
)
::


METHOD:: tickSpacing
Set the emphasis::minimum:: spacing between grid lines ("ticks") for each axis. The number of grid lines will change with the view size, but won't be spaced less than this code::tickSpacing::, allowing you to control the density of grid lines. However if link::#-numTicks:: is not code::nil::, it takes precedence over code::tickSpacing::.

See link::#Testing and modifying#Examples:: below.

argument:: x
emphasis::Minimum:: spacing between grid lines ("ticks") on the x-axis (pixels, default: 64).

argument:: y
emphasis::Minimum:: spacing between grid lines on the y-axis (pixels, default: 64).


METHOD:: preview
Preview this code::DrawGrid:: object by creating a window with a view showing the code::DrawGrid:: in its current state.

code::
d = DrawGrid(nil, \freq.asSpec.grid, \amp.asSpec.grid);
d.linePattern_(FloatArray[10.0, 5.0, 2.0, 5.0]);
d.preview;
::
If the code::DrawGrid:: is modified, you can code::-refresh:: the returned code::UserView:: to see its updated state, or simply call code::-preview:: again to update the view (or create the preview again if the code::Window:: was closed). See link::#Testing and modifying#Examples:: below.

returns:: A link::Classes/UserView:: which draws this code::DrawGrid::.

METHOD:: copy
Safely make a copy of this object and its working members.

returns:: A new code::DrawGrid::.


PRIVATE:: clearCache, init

EXAMPLES::

SUBSECTION:: Basic use in a UserView

code::
(
w = Window.new.front;
u = UserView(w,w.bounds.size.asRect);

// The spec defines its preferred grid system
x = \lofreq.asSpec.grid; // x grid lines
y = \amp.asSpec.grid;    // y grid lines
i = 40;                  // grid inset

d = DrawGrid(u.bounds.size.asRect.insetBy(i), x, y);

u.drawFunc = { d.draw };
u.resize_(5);
u.onResize = { |u|
	d.bounds = u.bounds.size.asRect.insetBy(i)
};
)
::

SUBSECTION:: Testing and modifying

For previewing the look and feel of your code::GridLines::, you can render your code::DrawGrid:: using the link::#-preview:: method:
code::
(
x = [0, 10].asSpec.units_("sec");
y = [0, 1].asSpec.units_("amp");
d = DrawGrid((500@250).asRect, x.grid, y.grid);

// set its properties before testing
d.x.tickSpacing_(25);
d.linePattern_(FloatArray[10.0, 5.0, 2.0, 5.0]);

// generate a preview
~testView = d.preview;
)
::
Use code::DrawGrid::'s convenience methods to set the grids' properties, then refresh the view:
code::
d.tickSpacing_(50, 25).linePattern_(FloatArray[1.0]);
~testView.refresh;
::
Or just call code::.preview:: again and it will refresh the existing view:
code::
d.linePattern_(FloatArray[10.0, 5.0, 2.0, 5.0]).preview;
::
Proterties of the individual x- and y-grids can also be accessed and changed separately:
code::
// Modify the number of grid lines on each axis separately
d.x.tickSpacing_(18); // fixed (max) *density* of x ticks
d.y.numTicks_(8);     // fixed *number* of y ticks (approximate)
d.preview;            // refresh the test view

d.y.numTicks_(nil);   // numTicks = nil: auto, follows -tickSpacing
d.preview;
::


class:: Dreset
summary:: demand rate reset
categories:: UGens>Demand

description::
The reset of a demand ugen can be controlled "from the outside" by the reset input of the link::Classes/Demand:: or link::Classes/Duty:: UGen, which consumes the chain of demands. Dreset allows to reset a subset of the chain internally.

classmethods::
method:: new
argument:: in
a demand UGen, producing values which are passed through
argument:: reset
a demand or any other UGen. When crossing from nonpositive to positive, it resets the first argument.

examples::
code::
(
{
	var a, freq;
	a = Dreset(Dseries(0, 2, inf), Drand([0, 0, 0, 1], inf));
	freq = Duty.kr(1/MouseX.kr(1, 40, 1), 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1
}.play;
)

// reset when mouse button is pressed
(
{
	var a, freq;
	a = Dreset(Dseries(0, 2, inf), MouseButton.kr);
	freq = Duty.kr(1/MouseX.kr(1, 40, 1), 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1
}.play;
)

// audio rate
(
{
	var a, nmax = 90;
	a = { Dreset(Dseries(0, 1, inf), Drand(0 ! nmax ++ 1, inf)) } ! 2;
	Duty.ar(SampleDur.ir, 0, a) * (0.1 / nmax)
}.play;
)
::



class:: Dseq
summary:: Demand rate sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dser, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate sequence generator.


See link::Classes/Pseq:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of repeats.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dseq([1, 3, 2, 7, 8], 3);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// audio rate
(
{
	var a, freq, trig;
	a = Dseq({ 10.rand } ! 32, inf);
	trig = Impulse.ar(MouseX.kr(1, 10000, 1));
	freq = Demand.ar(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Dser
summary:: Demand rate sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dseq, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate sequence generator.

See link::Classes/Pser:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dser([1, 3, 2, 7, 8], 8);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Dseries
summary:: Demand rate arithmetic series UGen.
related:: Classes/Demand, Classes/Dgeom, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate arithmetic series UGen.

See link::Classes/Pseries:: for structurally related equivalent.


classmethods::

method::new

argument::start

Start value. Can be a number or any other UGen.


argument::step

Step value. Can be a number or any other UGen.


argument::length

Number of values to create.  Can be a number or any other UGen.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dseries(0, 1, 15);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dseries(0, 1, inf);
	trig = Dust.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) % 15 * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Dshuf
summary:: Demand rate random sequence generator
categories:: UGens>Demand, UGens>Random

classmethods::
method:: new
argument:: list
array of values or other ugens
argument:: repeats
number of repeats
discussion::
structurally related: link::Classes/Pshuf::

examples::
code::
(
{
	var a, freq, trig;
	a = Dseq([Dshuf([1, 3, 2, 7, 8.5], 3)], inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// audio rate
(
{
	var a, freq, trig;
	a = Dseq([Dshuf({ 10.rand } ! 81, 5)], inf).poll;
	trig = Impulse.ar(MouseX.kr(1, 10000, 1));
	freq = Demand.ar(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// embedded structures
(
{
	var a, freq, trig;
	a = Dseq([Dshuf([Drand([1, 2, 3], 1), 3, Drand([20, 23, 56], 1), 7, 8.5], 8)], inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
::



class:: Dstutter
summary:: Demand rate input replicator
categories:: UGens>Demand
related:: Classes/Ddup

note::It is recommended to use link::Classes/Ddup:: instead. This class is retained for backwards compatibility.::
warning::Dstutter will return link::Classes/Ddup::::

classmethods::
method:: new
argument:: n
number of repeats (can be a demand ugen)
argument:: in
input ugen
returns:: link::Classes/Ddup::

discussion::
structurally related: link::Classes/Pdup::

examples::
code::
(
{
	var freq, trig;
	var in = Dseq([1, 2, 3], inf);
	var rep = Dstutter(Diwhite(2, 8, inf), in);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, rep).poll(trig) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
::


class:: Dswitch
summary:: Demand rate generator for embedding different inputs
related:: Classes/Demand, Classes/Dswitch1
categories:: UGens>Demand

description::
Demand rate generator for embedding different inputs.
In difference to Dswitch1, Dswitch embeds all items of
an input demand ugen first before looking up the next index.

classmethods::
method:: new
argument:: list
array of values or other ugens
argument:: index
which of the inputs to return
discussion::
structurally related: link::Classes/Pswitch::

examples::
code::
(
	{
		var d, trig;
		d = Dswitch([
			Dwhite(3, 4, 2),
			Dwhite(0, 1, 2),
			Dseq([1, 1, 1, 0], 2)
		], Dseq([0, 1, 2, 1, 0], 2));

		trig = Impulse.kr(4);

		SinOsc.ar(
			Demand.kr(trig, 0, d).poll(trig)
			* 300 + 400
		)
		* 0.1 ! 2
	}.play;
);

// compare with Dswitch1:

(
	{
		var d, trig;
		d = Dswitch1([
			Dwhite(3, 4, 2),
			Dwhite(0, 1, 2),
			Dseq([1, 1, 1, 0], 2)
		], Dseq([0, 1, 2, 1, 0], 2));

		trig = Impulse.kr(4);

		SinOsc.ar(
			Demand.kr(trig, 0, d).poll(trig)
			* 300 + 400
		)
		* 0.1 ! 2
	}.play;
);
::



class:: Dswitch1
summary:: Demand rate generator for switching between inputs.
related:: Classes/Demand, Classes/Duty, Classes/TDuty, Classes/Dswitch
categories:: UGens>Demand

Description::

Demand rate generator for switching between inputs.

See link::Classes/Pswitch1:: for structurally related equivalent.


classmethods::

method::new

argument::list

Array of values or other UGens.


argument::index

Which of the inputs to return.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dswitch1([1, 3, MouseY.kr(1, 15), 2, Dwhite(0, 3, 2)], MouseX.kr(0, 4));
	trig = Impulse.kr(3);
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dswitch1({ |i| Dseq((0..i*3), inf) } ! 5, MouseX.kr(0, 4));
	trig = Impulse.kr(6);
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



TITLE:: Dunique
summary:: Return the same unique series of values for several demand streams
categories:: UGens>Demand
related:: Classes/Demand, Classes/Drand, Classes/Dser, Classes/Duty, Classes/Dxrand, Classes/TDuty

DESCRIPTION::
A demand UGen represents a single series of states. When used by more than one demand stream, it will output only every nth value for each. Wrapping a demand UGen in a Dunique will guarantee that that all streams receive the same value.

code::
// without any measures, a demand ugen's values will be distributed between several series:
{ var x = Dseq([0, 1, 2, 3, 4, 5], inf); { Demand.ar(Impulse.ar(1/rrand(0.001, 0.0015)), 0, x) } ! 3 }.plot;

// using a Dunique, each series iterates through the same values
{ var x = Dunique(Dseq([0, 1, 2, 3, 4, 5], inf)); { Demand.ar(Impulse.ar(1/rrand(0.001, 0.0015)), 0, x) } ! 3 }.plot;

// random values will also be identical
{ var x = Dunique(Drand([0, 1, 2, 3, 4, 5], inf)); { Demand.ar(Impulse.ar(1/rrand(0.001, 0.0015)), 0, x) } ! 3 }.plot;
::

CLASSMETHODS::

METHOD:: new
Return a new instance.

ARGUMENT:: source
The demand ugen that is to be reused in several others.

ARGUMENT:: maxBufferSize
Maximum size for the value buffer when protected is false. Values will loop after maxBufferSize has been exceeded.

ARGUMENT:: protected
There are limitations to this ugen: If one copy is called much faster than the slowest, the buffer can overrun. Trying to protect from such a buffer overrun, one has to rely on counting up to infinity. Using 32bit float, only 16777216 events can be correctly played back. When protected is true, these two limitations are caught by ending the series (default: true). Set this parameter to false (or zero) in order to ignore this (e.g. by adjusting buffer size appropriately).
code::
// to demonstrate, make the buffer deliberately small:
{ var x = Dunique(Drand([0, 1, 2, 3, 4, 5], inf), 20); { Duty.ar(0.5e-4 + 0.001.rand, 0, x, doneAction: Done.freeSelf) } ! 3}.plot;
::


class:: Dust
summary:: Random impulses.
related:: Classes/Dust2
categories::  UGens>Generators>Stochastic


Description::

Generates random impulses from 0 to +1.


classmethods::

method::ar, kr

argument::density
Average number of impulses per second.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-Dust", { arg out=0;
	Out.ar(out,
		Dust.ar(200, 0.5)
	)
}).play;
)

(
SynthDef("help-Dust", { arg out=0;
	Out.ar(out,
		Dust.ar(XLine.kr(20000, 2, 10), 0.5)
	)
}).play;
)

::



class:: Dust2
summary:: Random impulses.
related:: Classes/Dust
categories::  UGens>Generators>Stochastic


Description::

Generates random impulses from -1 to +1.


classmethods::

method::ar, kr

argument::density
Average number of impulses per second.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-Dust2", { arg out=0;
	Out.ar(out,
		Dust2.ar(200, 0.5)
	)
}).play;
)

(
SynthDef("help-Dust2", { arg out=0;
	Out.ar(out,
		Dust2.ar(XLine.kr(20000, 2, 10), 0.5)
	)
}).play;
)

::



class:: Duty
summary:: Demand results from demand rate UGens.
related:: Classes/Demand, Classes/TDuty
categories::  UGens>Demand


Description::

A value is demanded of each UGen in the list and output according to a
stream of duration values. The unit generators in the list should be
'demand' rate.


When there is a trigger at the reset input, the demand rate UGens in the
list and the duration are reset. The reset input may also be a demand
UGen, providing a stream of reset times.


classmethods::

method::ar, kr

argument::dur

Time values. Can be a demand UGen or any signal. The next level
is acquired after duration.


argument::reset

Trigger or reset time values. Resets the list of UGens and the
duration UGen when triggered. The reset input may also be a
demand UGen, providing a stream of reset times.


argument::level

Demand UGen providing the output values.


argument::doneAction

A doneAction that is evaluated when the duration stream ends. See

link::Classes/Done::  for more detail.


Examples::
code::
(
	{
		var freq;
		freq = Duty.kr(
				Drand([0.01, 0.2, 0.4], inf), // demand ugen as durations
				0,
				Dseq([204, 400, 201, 502, 300, 200], inf)
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

(
	{
		var freq;
		freq = Duty.kr(
				MouseX.kr(0.001, 2, 1), // control rate ugen as durations
				0,
				Dseq([204, 400, 201, 502, 300, 200], inf)
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)
::

Resetting the demand ugens:
code::
(
	{
		var freq;
		freq = Duty.kr(
				Dseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,
				Dust.kr(1), // control rate reset
				Dseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])
			) * 30 + 250;
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

(
	{
		var freq;
		freq = Duty.kr(
				Dseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,
				Dseq([1, 2, 4, 5], inf), // demand rate reset
				Dseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])
			) * 30 + 250;
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)
::

Demand ugen as audio oscillator:
code::
(
	{
		var a, n=5, m=64;
		a = {
			var x;
			x = { 0.2.rand2 } ! m;
			x = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);
			Dseq(x.scramble, inf)
		} ! n;
		Duty.ar(
				MouseX.kr(1, 125, 1) * SampleDur.ir * [1, 1.02],
				0,
				Dswitch1(a, MouseY.kr(0, n-1))
			)

	}.play;
)
::

single sample feedback: a lin cong algorithm:
code::
(
b = Buffer.alloc(s, 1);
{
var x, y, rate, a, c, m;
	rate = MouseX.kr(100, SampleRate.ir);
	a = 1.1;
	c = 0.13;
	m = 1.0;
	x = Dbufrd(b); // read from buffer
	x = x * a + c % m;
	y = Dbufwr(x, b); // write to buffer
	Duty.ar(1 / rate, 0, y) * 0.1;
}.play;
)
::



class:: Dwhite
summary:: Demand rate white noise random generator.
related:: Classes/Diwhite, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dwhite returns numbers in the continuous range between
code::lo::  and  code::hi:: .
link::Classes/Diwhite::  returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pwhite::,  link::Classes/WhiteNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::length

Number of values to create.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dwhite(0, 15, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: Dwrand
summary:: Demand rate weighted random sequence generator
categories:: UGens>Demand, UGens>Random
related:: Classes/Demand

classmethods::
method:: new
argument:: list
array of values or other ugens
argument:: weights
array of values (should sum up to 1.0)
argument:: repeats
number of values to return
discussion::
structurally related: link::Classes/Pwrand::, link::Classes/TWindex::, link::Classes/TWChoose::

examples::
code::
(
{
	var a, freq, trig;
	a = Dwrand([0, 1, 2, 7], [0.4, 0.4, 0.1, 0.1], inf).dpoll;
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
::



class:: Dxrand
summary:: Demand rate random sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dseq, Classes/Dser, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dxrand never plays the same value twice, whereas link::Classes/Drand:: chooses
any value in the list.


See link::Classes/Pxrand:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dxrand([1, 3, 2, 7, 8], inf);
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

::



class:: DynKlang
categories:: UGens>Generators>Deterministic
summary:: Dynamic sine oscillator bank
related:: Classes/Klang, Classes/DynKlank, Classes/Klank

description::
DynKlang is a bank of sine oscillators. It is less efficient than Klang, as it is basically a wrapper around SinOsc UGens in order to provide a similar interface to link::Classes/Klang::.

Unlike Klang, parameters in code::specificationsArrayRef:: can be changed after it has been started.

classmethods::
private:: categories

method:: ar, kr

argument:: specificationsArrayRef
a Ref to an Array of three Arrays:
definitionlist::
## frequencies || an Array of oscillator frequencies.
## amplitudes || an Array of oscillator amplitudes, or nil. If nil, then amplitudes default to 1.0
## phases || an Array of initial phases, or nil. If nil, then phases default to 0.0
::
argument:: freqscale
a scale factor multiplied by all frequencies at initialization time.
argument:: freqoffset
an offset added to all frequencies at initialization time.

examples::
code::
// frequency modulation
(
play {
	DynKlang.ar(`[
		[800, 1000, 1200] + SinOsc.kr([2, 3, 4.2], 0, [13, 24, 12]),
		[0.3, 0.3, 0.3],
		[pi,pi,pi]
	]
) * 0.1
};
)


// building new synths every 2 seconds
(
fork {
	loop {
		play {
			var mod = SinOsc.kr(Rand(0.1, 0.9), 0, Rand(5, 20));
			Pan2.ar(DynKlang.ar(`[ Array.rand(12, 200.0, 2000.0), 1, mod ]), 1.0.rand)
				* EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: Done.freeSelf)
		};
		2.wait;
	}
}
)


// resetting the frequencies and amplitudes after the synth has been created
(
SynthDef('help-dynKlang', { |out,
	freqs=#[220, 440, 880, 1760],
	amps=#[0.35, 0.23, 0.12, 0.05],
	phases=#[1, 1.5, 2, 2.5]|

	Out.ar(out, DynKlang.ar(`[freqs, amps, phases]))
}).add
)

a = Synth('help-dynKlang');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\amps, Array.rand(4, 0.01, 0.25));
::



class:: DynKlank
summary:: Bank of resonators.
related:: Classes/Klang, Classes/DynKlang, Classes/Klank
categories::  UGens>Generators>Deterministic, UGens>Filters>Linear


Description::

DynKlank is a bank of frequency resonators which can be used to simulate
the resonant modes of an object. Each mode is given a ring time, which is
the time for the mode to decay by 60 dB.


Unlike  link::Classes/Klank::, all parameters in DynKlank can be changed in real-time after it has been started.

Note::
The amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.
::


classmethods::

method::ar, kr

argument::specificationsArrayRef
A Ref to an Array of three Arrays: code::[frequencies, amplitudes, ringtimes]::

definitionlist::
## frequencies: || An Array of filter frequencies.
## amplitudes: || An Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.
## ring times: || An Array of 60 dB decay times for the filters.
::
All subarrays, if not nil, should have the same length.

argument::input
The excitation input to the resonant filter bank.

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

argument::decayscale
A scale factor multiplied by all ring times at initialization time.

Examples::

Four resonators each at maximum amplitude of 1.0 and ring times of 1 second, different exciters and no scaling:
Note:: Watch the ` before the opening bracket of the parameter array! Also see link::Guides/Multichannel-Expansion::::
code::

{ DynKlank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ DynKlank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([0.007, 0.007])) }.play;

::

Changing parameters in realtime:
code::
(
// change freqs and ringtimes with mouse
{	var freqs, ringtimes;
	freqs = [800, 1071, 1153, 1723] * MouseX.kr(0.5, 2, 1);
	ringtimes = [1, 1, 1, 1] * MouseY.kr(0.1, 10, 1);
	DynKlank.ar(`[freqs, nil, ringtimes ], Impulse.ar(2, 0, 0.1))
}.play;
)

(
// set them from outside later:
SynthDef('help-dynKlank', { |out|
	var freqs, ringtimes, signal;
	freqs = Control.names([\freqs]).kr([800, 1071, 1153, 1723]);
	ringtimes = Control.names([\ringtimes]).kr([1, 1, 1, 1]);
	signal = DynKlank.ar(`[freqs, nil, ringtimes ], Impulse.ar(2, 0, 0.1));
	Out.ar(out, signal);
}).add;
)

a = Synth('help-dynKlank');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\ringtimes, Array.rand(4, 0.2, 4) );
a.setn(\ringtimes, Array.rand(4, 0.02, 0.4) );

// create multichannel controls directly with literal arrays:
(
SynthDef('help-dynKlank', { |out,
	freqs (#[100, 200, 300, 400]),
	amps (#[1, 0.3, 0.2, 0.05]),
	rings (#[1, 1, 1, 2])|

	Out.ar(out, DynKlank.ar(`[freqs, amps, rings], WhiteNoise.ar * 0.001))
}).add
)

a = Synth('help-dynKlank');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\amps, Array.exprand(4, 0.01, 1));

{ Out.kr(102, MouseX.kr(1, 2) * Array.rand(4, 500, 2000)) }.play;
a.mapn(\freqs, 102, 4);
::




class:: EZGui
summary:: An abstract superclass for EZ widget wrappers
categories:: GUI>EZ-GUI
related:: Classes/EZListView, Classes/EZPopUpMenu, Classes/EZSlider, Classes/EZNumber, Classes/EZRanger, Classes/EZKnob

description::
Users will not normally directly create instances of EZGui, but only use it through its subclasses. It provides the basic mechanisms for various EZ widget wrappers. It also provides a standard for EZ GUI Classes, and new EZ Classes should subclass EZGUI to help keep a consistent user interface.


instancemethods::

subsection:: Accessing Instance Variables

method:: view
Returns the enclosing link::Classes/CompositeView::.

method:: bounds
Returns the bounds of the enclosing link::Classes/CompositeView::.

method:: label
Sets/gets it the label. Will add the label view if none was initially created.
argument:: string
An Instance of link::Classes/String::.

method:: window
Returns the window if you used the popUp window function.


subsection:: Accessing GUI options

method:: alwaysOnTop
Makes the popup window always on top, if there is one.
argument:: bool
An Instance of link::Classes/Boolean::. Default is false.

method:: visible
Sets/gets it the component views are visible.
argument:: bool
An Instance of link::Classes/Boolean::. Default is true.

method:: enabled
Sets/gets if the list is enabled.
argument:: bool
An Instance of link::Classes/Boolean::. Default is true.

method:: onClose
Sets/gets the onClose function of either code::view:: or code::window::, depending on whether the EZ view used a popup window.
argument:: func
An Instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: font
argument:: font
An instance of link::Classes/Font::.


subsection:: Subclassing

EZGui provides a standard and basic tools for most EZ classes. If you make a new EZ class, then subclass EZGui, and override the necessary methods. If your class only has a label and a widget, chances are, you need to override nothing, but only need to write the  new and init class methods. See existing subclasses of EZGui for examples of this. You may also want to override the following:

method:: widget
Returns the active widget. Subclasses will typically refer to it or ignore it, e.g.:
code::
MyEZClass{
	myOtherMethods{}
	....
	listView{ ^widget }
}
::

method:: action
Gets/sets the action of the EZ class instance.
argument:: func
An Instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: value
Gets/sets the value of the code::widget::. Does not perform the action.
argument:: val
An integer.

method:: valueAction
Gets/sets the value of the widget. Performs do action.
argument:: val
An integer.

method:: doAction
Performs code::this.action.value(this)::.


subsection:: Internal Utilities

method:: prSubViewBounds
This calculates the bounds of the subviews and the gaps. It returns an array of Rects, which depends on how many subview there are. Subclasses override this if they have more than one widget.

method:: prMakeView
Called by init. Returns code::[view, bounds]::. The container is either the enclosing Container, or a pop up window with a container.

method:: prSetViewParams
Only defined by some subclasses. Sets the code::resize::  and code::align:: of all the views, according to the state of code::layout::.

method:: prMakeMarginGap
Called in the init method of all subclasses. Sets the margin and gap of code::view::. By default, it tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting code::argGap:: overrides these.



class:: EZKnob
summary:: Wrapper class for label, knob, number box
categories:: GUI>EZ-GUI
related:: Classes/Knob, Classes/NumberBox, Classes/StaticText, Classes/CompositeView, Classes/EZGui

description::
EZKnob is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/Knob:: plus a link::Classes/NumberBox::. If the parent is nil, then EZKnob will create its own window. See link::Classes/EZGui:: more options.

subsection:: Some Important Issues Regarding NumberBox

warning::
EZKnob replaces the EZKnob Quark, which is now called EZKnobOld.  It is encouraged to update your code. The two classes have different creation methods and approaches, particularly concerning the strong::dimensions:: (now strong::bounds::). To make the conversion process easier,  EZKnobOld has an instance method called convert which will post the equivalent creation code for the new EZKnob.
::

note::
Bounds: Make certain to choose bounds that are large enough to encompass the knob, the number box, and the label (if you use one), otherwise you may get confusing results. See the examples below.
::

classmethods::

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZKnob will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.  Make certain to choose bounds that are large enough to encompass the knob, the number box, and the label (if you use one), otherwise you may get confusing results. See the examples below.

argument:: label
The label. Default value is nil. If nil, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.  If the code::minVal + maxVal:: of the spec is 0, then code::centered:: will be set to true automatically.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZKnob instance as its argument.

argument:: initVal
The value to initialize the knob and number box with. If nil, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. default is 60. This is only valid for the code::\horz:: layout.

argument:: knobSize
An instance of link::Classes/Point::.  It will adjust itself to maximize the space use of code::width/height::. By default, it uses the maximum available height, and adjusts the width accordingly.

argument:: unitWidth
Number of pixels width for the unit label. Default is 0. If 0, then no unitLabel is created.

argument:: labelHeight
Default is 20.

argument:: layout
code::\vert::, code::vert2::,  code::\line2::, or code::\horz::. default is code::\vert::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w=Window.new.front;
g = EZKnob( w,        // parent
            50@90,    // bounds
            " test ", // label
            \freq,    // controlSpec
            { |ez| (ez.value.asString ++" is the value of " ++ ez).postln } // action
);
g.setColors(Color.grey, Color.white)
);

// Simplest version, no parent view, so a window is created
(
	g = EZKnob(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::
The contained views can be accessed via the EZKnob instance variables: code::labelView::, code::knobView::, code::numberView::.


instancemethods::

subsection:: Accessing Instance Variables

method:: numberView
Returns:: the code::numberView::

method:: knobView
Returns:: the code::knobView::

method:: labelView
Set/get the code::labelView::

method:: action
A function to be evaluated when the value changes. Te first argument will be the EZKnob.
argument:: arg1
An instance of link::Classes/Function:: or link::Classes/FunctionList::. Default value is code::nil::.

method:: value
The value of the knob

method:: centered
Sets/gets whether the knob is in centered mode. See link::Classes/Knob::.

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of link::Classes/ControlSpec:: for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation. You can only set the label if it was not nil from the beginning.

method:: visible
Sets/gets if the component views are visible.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: numBackground
An instance of link::Classes/Color::. The code::numColor:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColors
An instance of link::Classes/Color::. The code::knobColors:: of the knob view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::

code::
(	// basic use
	w=Window.new.front;
	g=EZKnob(w, 50@90," test  ", \freq,{|a| a.value.postln});
	g.setColors(Color.grey,Color.white);
);


// lots of knobs on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

20.do{
	EZKnob(w, 180@24," Freq ", \freq,unitWidth:30,initVal:6000.rand,layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll  // use this to close all the windows

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts

(
m=nil;
m=2@2;		// comment this for no margin

/////////////////
/// Layout \line2

(		// all features, small font
		g=EZKnob(nil, 128@40," freq  ", \freq,unitWidth:20,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZKnob(nil, 118@40," freq  ", \freq,unitWidth:0,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -40);
);
(		// no label, so use window name as label
		g=EZKnob(nil, 118@30, nil, \freq,labelWidth:100, unitWidth:20,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -130);
		g.window.name="Freq";
);

/////////////////
/// Layout \horz


(		// all features
		g=EZKnob(nil, 200@28," freq  ", \freq,unitWidth:30,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0,50);
);

(		// no unitView
		g=EZKnob(nil, 160@28," freq  ", \freq,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0, -30);
);
(		// no label, so use window name as label
		g=EZKnob(nil, 120@28, nil, \freq ,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0, -110);
		g.window.name="Freq";
);



/////////////////
/// Layout \vert

(		// all features
		g=EZKnob(nil, 82@82," freq  ", \freq,unitWidth:18,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.font_(Font("Helvetica", 10));
		g.window.bounds = g.window.bounds.moveBy(220,50);
);

(		// no unitView, with label
		g=EZKnob(nil, 70@90," freq  ", \freq,unitWidth:0,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-90);
);

(		// no label
		g=EZKnob(nil, 120@60,nil, \freq, unitWidth:30,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-230);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZKnob(nil, 120@60,nil, \freq,unitWidth:0,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-340);
		g.window.name="Freq";
);


/////////////////
/// Layout \vert2

(		// all features
		g=EZKnob(nil, 82@82," freq  ", \freq,unitWidth:18,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.font_(Font("Helvetica", 10));
		g.window.bounds = g.window.bounds.moveBy(350,50);
);

(		// no unitView, with label
		g=EZKnob(nil, 70@90," freq  ", \freq,unitWidth:0,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-90);
);

(		// no label
		g=EZKnob(nil, 120@60,nil, \freq, unitWidth:30,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-230);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZKnob(nil, 120@60,nil, \freq,unitWidth:0,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-340);
		g.window.name="Freq";
);


)




///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


// Sound example
(
// start server
s.waitForBoot({

var w, startButton, noteControl, cutoffControl, resonControl;
var balanceControl, ampControl;
var node, cmdPeriodFunc;

// define a synth
SynthDef("window-test", { |out, note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1|
		var x;
		x = Mix.fill(4, {
			LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, doneAction: Done.freeSelf);
		Out.ar(out, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;




// make the window
w = Window("another control panel", Rect(20, 400, 230, 250));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		if (view.value == 1) {
			// start sound
			node = Synth( "window-test", [
				"note", noteControl.value,
				"fc", cutoffControl.value,
				"rq", resonControl.value,
				"bal", balanceControl.value,
				"amp", ampControl.value.dbamp ]);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
noteControl = EZKnob(w, 220 @ 32, "Note ", ControlSpec(24, 60, \lin, 1, 36, \note),
	{|ez| node.set( "note", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
cutoffControl = EZKnob(w, 220 @ 32, "Cutoff ", ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	{|ez| node.set( "fc", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
resonControl = EZKnob(w, 220 @ 32, "Reson ", ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	{|ez| node.set( "rq", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
balanceControl = EZKnob(w, 220 @ 32, "Balance ", \bipolar,
	{|ez| node.set( "bal", ez.value )},  unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
ampControl = EZKnob(w, 220 @ 32, "Amp ", \db,
	{|ez| node.set( "amp", ez.value.dbamp )}, -6, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);


// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};
});
)


//////////////////////////////
// more examples
// these mimick the original  EZKnob layout and colors

(
w = Window("EZKnob", Rect(380,400,300,180)).front;
w.view.decorator = FlowLayout(w.view.bounds);
k = EZKnob(w, 42 @ 74, "Knob", action: { arg knb; knb.value.postln; }, margin:2@2, labelHeight:16);
k.view.background_(Color.grey.alpha_(0.4));
)
k.centered_(true)
k.value=0.5;
k.visible_(false)
k.visible_(true)

k.enabled_(false)
k.value = 0.1
k.enabled
k.enabled_(true)
k.value = 0.25

(
w = Window("EZKnob", Rect(380,400,300,180)).front;
w.view.decorator = FlowLayout(w.view.bounds, gap: 1@1);
StaticText(w, (42 * 4 + 3) @ 16).string_("EZKnob Cluster").background_(Color.blue(0.1,0.1));
w.view.decorator.nextLine;
a = [
		EZKnob(w, 42 @ 74, "knob 1", margin:2@2, labelHeight:16),
		EZKnob(w, 42 @ 74, "knob 2", controlSpec: \freq, margin:2@2, labelHeight:16),
		EZKnob(w, 42 @ 74, "knob 3", controlSpec: \pan, margin:2@2, labelHeight:16).round_(0.001),
		EZKnob(w, 42 @ 74, "knob 4", controlSpec: \rq, margin:2@2, labelHeight:16)
	];
a.do{arg a;a.view.background_(Color.grey.alpha_(0.4))};
)
// a now holds the array of knobs
a
a[0].value
a[3].value_(0.5)
a.collect(_.value );
::


class:: EZListView
summary:: A wrapper class for a label plus a listView with per item actions
categories:: GUI>EZ-GUI
related:: Classes/ListView

description::
EZListView is wrapper class which creates an (optional) label and a listView. It includes per item actions as well as a global action which are both evaluated upon selection of an item. Convenience methods for inserting and deleting list items are also included . If the parent is nil, then EZListView will create its own window. See link::Classes/EZGui:: and link::Classes/EZLists:: for all of the options.

subsection:: Some Important Issues Regarding EZListView

The convenience methods for EZListView require that the items array is an array of associations of labels and functions, not like in ListView, where items is simply an array of strings. If code::label:: is nil, then no staticText is created.

classmethods::

subsection:: Creation / Class Methods

method:: new

argument:: parentView
The parent view or window. If the parent is nil, then EZListView will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@200::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: items
Default value is code::nil::. An link::Classes/Array:: of link::Classes/Association::s code:: ['label' -> { arg listObj; value }, ] ::. Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::).

argument:: globalAction
A global function to be performed in addition to the item functions code:: { arg listObj; value } ::.

argument:: initVal
Initial value of the List, i.e. the index selected. Default value is 0.

argument:: initAction
An instance of link::Classes/Boolean::. Performs the action at code::initVal:: on creation of the list, plus the code::globalAction::. Default value is code::false::.

argument:: labelWidth
Default value is 80. Not used if layout is code::\vert::.

argument:: labelHeight
Default value is 20. Not used if layout is code::\horz::.

argument:: layout
code::\vert:: or code::\horz::. default is code::\vert::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
Example:
code::
(
// default with vertical layout
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZListView.new(w,
	230@230,
	"An ListView:",
	[
		\item0 ->{ |a| ("this is item 0 of " ++ a).postln },
		\item1 ->{ |a| ("this is item 1 of " ++ a).postln },
		\item2 ->{ |a| ("this is item 2 of " ++ a).postln },
	],
	globalAction: { |a| ("this is a global action of "++a.asString ).postln },
	initVal: 2,
	initAction: true,
	labelWidth: 120,
	labelHeight: 16,
	layout: \vert,
	gap: 2@2
	);

)

// or a more simple syntax (uses decorator gap settings):
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZListView.new(w,200@230, " List:");
g.addItem(\item0, { |a| ("this is item 0 of " ++ a).postln });
g.addItem(\item1, { |a| ("this is item 1 of " ++ a).postln });
g.addItem(\item2, { |a| ("this is item 2 of " ++ a).postln });
g.setColors(Color.grey, Color.white);
)
::

instancemethods::

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: listBackground
An instance of link::Classes/Color::. The code::background:: of the list view.
argument:: listStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the list view.
argument:: selectedStringColor
An instance of link::Classes/Color::. The code::selectedStringColor:: of the listView.
argument:: hiliteColor
An instance of link::Classes/Color::. The code::hiliteColor:: of the list view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the list view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
Creates its own window if parent is nil:
code::
(
g = EZListView.new(label: " My PopUp List: ");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
)
::
Layout horizontal:
code::
(
g = EZListView.new(nil,205@180, "Choose One: ", layout:\horz);
10.do{|i| g.addItem("item"++i.asString, {("this is item" ++i.asString). postln})};
g.setColors(Color.grey,Color.white);
)
::
No labelView created, so set the window title:
code::
(
g = EZListView.new(bounds:200@230); // no label
12.do{|i| g.addItem("item"++i.asString, {("this is item" ++i.asString). postln})};
g.view.parent.findWindow.name=" choose item";
)
::
insert item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
)

g.insertItem(3, \item3, {"this is item 3". postln});
::
remove item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.insertItem(3, \item3, {"this is item 3". postln});
)

g.removeItemAt(1);
::
replace item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item3, {"this is item 3". postln});
)

g.replaceItemAt(2, \item2_replaced, {"this is item 2 replaced". postln});
::



class:: EZLists
summary:: An abstract superclass for EZListView and EZPopUpMenu
categories:: GUI>EZ-GUI
related:: Classes/EZListView, Classes/EZPopUpMenu

description::
Users will not normally directly create instances of EZLists, but only use it through its subclasses. It provides the basic mechanisms for link::Classes/EZListView:: and link::Classes/EZPopUpMenu::.

classmethods::

method:: new

instancemethods::

subsection:: Building and Changing the List

method:: globalAction
Set/get the global function to be performed in addition to the item functions: code:: { arg listObj; value } ::.

method:: items
Set/get an link::Classes/Array:: of Associations including the labels and the item functions: code:: ['label' -> { arg listObj; value }, ] ::.
discussion::
In menus, the macOS graphics system gives special meanings to some characters. See link::Classes/PopUpMenu:: ; Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::). link::Classes/Array::s of link::Classes/Symbol::s will get converted into and array of link::Classes/Association::s with and empty link::Classes/Function:: code:: ['label' -> {}, ] ::.

method:: item
Returns:: the item label of the current selection.

method:: itemFunc
Returns:: the item function of the current selection.

method:: addItem
Adds an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item.
argument:: action
An instance of link::Classes/Function::.

method:: insertItem
Inserts a list/menu item at index position.
argument:: index
An link::Classes/Integer::. The index where to insert an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item.
argument:: action
An instance of link::Classes/Function::.

method:: replaceItemAt
Replace a list/menu item at index position.
argument:: index
An link::Classes/Integer::. The index where to insert an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item. Default is the current item label.
argument:: action
An instance of link::Classes/Function::. Default is the current item action.

method:: removeItemAt
Removes a list/menu item at index position.
argument:: index
An link::Classes/Integer::. The index where to remove an item.

method:: remove
Removes both the view, label and the list/menu from the parent view.

subsection:: Accessing Values

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: initViews
Called by init and overridden by all subclasses. This is where the class specific views are built.


class:: EZNumber
summary:: Wrapper class for label and number box
categories:: GUI>EZ-GUI
related:: Classes/NumberBox

description::
EZNumber is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/NumberBox::.

subsection:: Some Important Issues Regarding NumberBox
If the parent is code::nil::, then EZNumber will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZNumber scrolls by default, using the step size of the link::Classes/ControlSpec::. If the controlSpec's step is set to 0, or is not set, then the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the EZNumber. By default, the shift-key modifier will allow you to step by 100 x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::. Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly you can customize the other modifiers to fit your needs. See link::Classes/NumberBox::.

classmethods::
method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZNumber will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZNumber instance as its argument.

argument:: initVal
The value to initialize the slider and number box with. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is code::false::.

argument:: labelWidth
Number of pixels width for the label. The  default is 60. In the code::\horz:: layout, if you specify the code::numberWidth::, then the code::labelWidth:: is ignored and is set to the code::bounds.width - unitWidth - numberWidth::.

argument:: numberWidth
Number of pixels width for the number box. The  default is 45. In \line2 layout, numberWidth defaults to the bounds.width minus the unitWidth.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0.  If code::unitWidth:: is 0, then no code::unitLabel:: is created. In the code::\line2:: layout, if you specify the code::numberWidth::, then the code::unitWidth:: is ignored and is set to the code::bounds.width - unitWidth - numberWidth::.

argument:: labelHeight
Default is 20;

argument:: layout
code::\line2::, or code::\horz::. The default is code::\horz::; code::\line2:: is a two line version.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZNumber(w,        // parent
             150@20,   // bounds
             " test ", // label
             \freq,    // controlSpec
             { |ez| (ez.value.asString ++" is the value of " ++ ez).postln }, // action
             330,      // initValue
             true      // initAction
);
g.setColors(Color.grey,Color.white);
);


// Simplest version, no parent view, so a window is created
(
	g = EZNumber(label:" test ", controlSpec: \amp.asSpec.step_(0.01) );
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::

The contained views can be accessed via the EZNumber instance variables: code::labelView::, code::numberView::.

instancemethods::

method:: numberView
Returns the numberView

method:: action
A function to be evaluated when the value changes. Te first argument will be the EZNumber.
argument:: arg1
An instance of link::Classes/Function:: or link::Classes/FunctionList::. Default value is nil.

method:: value
The value of the slider

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of link::Classes/ControlSpec:: for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation.

method:: enabled
Sets/gets if the list is enabled.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.


subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: numBackground
An instance of link::Classes/Color::. The code::background:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.


examples::
code::
// Simplest version
(		// basic use
		w=Window.new.front;
		g=EZNumber(w, 170@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
		g.setColors(Color.grey,Color.white);
);


// lots of numberviews on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

40.do{
		g=EZNumber(w, 170@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
		g.setColors(Color.grey,Color.white, Color.grey(0.8));
};
);


// click these parentheses to see all features and layouts
(

m=nil;
m=2@2;		//comment for no margin

/////////////////
/// Layout \horz

(		// all features
		g=EZNumber(nil, 170@20," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
);

(		// no unitView
		g=EZNumber(nil, 170@20," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
);

(		// no label, with unit. use window name as label
		g=EZNumber(nil, 120@20,nil, \freq,unitWidth:30, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);


(		// no units, no label; use window name as label;
		g=EZNumber(nil, 120@20, nil, \freq,unitWidth:0, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -160);
		g.window.name="Freq";
);

/////////////////
/// Layout \line2

(		// all features
		g=EZNumber(nil, 120@42," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,50);
);

(		// no unitView, with label
		g=EZNumber(nil, 170@42," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100, -50);
);
(		// no unitView, no label; use window name as label
		g=EZNumber(nil, 170@20,nil, \freq,unitWidth:0, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,-150);
		g.window.name="Freq";
);


)



// Sound example
(
// start server
s.waitForBoot({

	var w, startButton, noteControl, cutoffControl, resonControl;
	var balanceControl, ampControl;
	var node, cmdPeriodFunc;

	// define a synth
	SynthDef("window-test", { |out, note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1|
			var x;
			x = Mix.fill(4, {
				LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
			});
			x = RLPF.ar(x, fc, rq).softclip;
			x = RLPF.ar(x, fc, rq, amp).softclip;
			x = Balance2.ar(x[0], x[1], bal);
			x = x * EnvGen.kr(Env.cutoff, gate, doneAction: Done.freeSelf);
			Out.ar(out, x);
		}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
	).add;



	// make the window
	w = Window("another control panel", Rect(200, 400, 300, 180));
	w.front; // make window visible and front window.
	w.view.decorator = FlowLayout(w.view.bounds);

	w.view.background = Color.rand;

	// add a button to start and stop the sound.
	startButton = Button(w, 75 @ 20);
	startButton.states = [
		["Start", Color.black, Color.green],
		["Stop", Color.white, Color.red]
	];
	startButton.action = {|view|
			if (view.value == 1) {
				// start sound
				node = Synth( "window-test", [
					"note", noteControl.value,
					"fc", cutoffControl.value,
					"rq", resonControl.value,
					"bal", balanceControl.value,
					"amp", ampControl.value.dbamp ]);
			} {
				// set gate to zero to cause envelope to release
				node.release; node = nil;
			};
	};

	// create controls for all parameters
	w.view.decorator.nextLine;
	noteControl = EZNumber(w, 160 @ 20, "Note ", ControlSpec(24, 60, \lin, 1),
		{|ez| node.set( "note", ez.value )}, 36);

	w.view.decorator.nextLine;
	cutoffControl = EZNumber(w, 160 @ 20, "Cutoff ", ControlSpec(200, 5000, \exp),
		{|ez| node.set( "fc", ez.value )}, 1000);

	w.view.decorator.nextLine;
	resonControl = EZNumber(w, 160 @ 20, "Reson", ControlSpec(0.1, 0.7),
		{|ez| node.set( "rq", ez.value )}, 0.2);

	w.view.decorator.nextLine;
	balanceControl = EZNumber(w, 160 @ 20, "Balance ", \bipolar,
		{|ez| node.set( "bal", ez.value )}, 0);

	w.view.decorator.nextLine;
	ampControl = EZNumber(w, 160 @ 20, "Amp ", \db,
		{|ez| node.set( "amp", ez.value.dbamp )}, -6);


	// set start button to zero upon a cmd-period
	cmdPeriodFunc = { startButton.value = 0; };
	CmdPeriod.add(cmdPeriodFunc);

	// stop the sound when window closes and remove cmdPeriodFunc.
	w.onClose = {
		node.free; node = nil;
		CmdPeriod.remove(cmdPeriodFunc);
	};
});
)
::


class:: EZPopUpMenu
summary:: A wrapper class for a label plus a popUpMenu with per item actions
categories:: GUI>EZ-GUI
related:: Classes/PopUpMenu

description::
EZPopUpMenu is wrapper class which creates an (optional) label and a popUpMenu. It includes per item actions as well as a global action which are both evaluated upon selection of an item. Convenience methods for inserting and deleting menu items are also included . If the parent is nil, then EZPopUpMenu will create its own window.See link::Classes/EZGui:: and link::Classes/EZLists:: for all of the options.

subsection:: Some Important Issues Regarding EZPopUpMenu
The convenience methods for EZPopUpMenu require that the items array is an array of associations of labels and functions, not like in link::Classes/PopUpMenu::, where items is simply an array of strings. If code::label:: is code::nil::, then no staticText is created.

classmethods::
method:: new

argument:: parentView
The parent view or window. If the parent is nil, then EZPopUpMenu will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@22::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: items
Default value is code::nil::. An link::Classes/Array:: of link::Classes/Association::s code:: ['label' -> { arg menuObj; value }, ] ::. Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::).

argument:: globalAction
A global function to be performed in addition to the item functions code:: { arg menuObj; value } ::.

argument:: initVal
Initial value of the menu, i.e. the index selected. Default value is 0.

argument:: initAction
An instance of link::Classes/Boolean::. Performs the action at code::initVal:: on creation of the menu, plus the code::globalAction::. Default value is code::false::.

argument:: labelWidth
Default value is 80.

argument:: labelHeight
Default value is 20. Not used if layout is code::\horz::.

argument:: layout
code::\vert:: or code::\horz::. default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's code::gap::, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(
	w,
	230@22,
	"A PopUpMenu: ",
	[
		\item0 ->{|a| ("this is item 0 of " ++ a).postln},
		\item1 ->{|a| ("this is item 1 of " ++ a).postln},
		\item2 ->{|a| ("this is item 2 of " ++ a).postln},
	],
	globalAction: {|a| ("this is a global action of "++a.asString ).postln},
	initVal: 1,
	initAction: true,
	labelWidth: 120,
	labelHeight: 20,
	layout: \horz,
	gap: 2@2
);
)

// or a more simple syntax:
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(w, 200@22, "Menu: ");
g.addItem(\item0, { |a| ("this is item 0 of " ++ a).postln });
g.addItem(\item1, { |a| ("this is item 1 of " ++ a).postln });
g.addItem(\item2, { |a| ("this is item 2 of " ++ a).postln });
g.value = 0;
)
::

instancemethods::

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: menuBackground
An instance of link::Classes/Color::. The code::background:: of the menu.
argument:: menuStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the menu.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the list view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
// try several examples together
(

// many menus
// inherits the parent's decorator gap

(
w=Window.new("oscillators", Rect(200,500,200,160)).front;
w.view.decorator = FlowLayout(w.view.bounds).gap_(2@2);
5.do{|i|
	g = EZPopUpMenu.new(w,190@22, "Oscillator % : ".format(i+1));
	g.addItem(\off, {"off". postln});
	g.addItem(\sine, {"sine". postln});
	g.addItem(\saw, {"saw". postln});
	g.addItem(\pulse, {"pulse". postln});
	g.setColors(Color.grey,Color.white);
	g.value=0;
};
w.bounds=w.bounds.moveBy(300,60);
);


// Creates its own window if parentView is nil:
(
g = EZPopUpMenu.new(nil,250@22 ," Select : ");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
g.value=0;

);

// layout vertical:
(
g = EZPopUpMenu.new(nil,200@42, " Choose",layout:\vert);
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
g.window.bounds=g.window.bounds.moveBy(300,-200);
g.value=0;
);

// No labelView created, so set the window title;
(
g = EZPopUpMenu.new(bounds:180@22); // no label
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.value=0;
g.window.name=" choose item";
g.window.bounds=g.window.bounds.moveBy(0,-200);
);
)
// insertItem;

(
g = EZPopUpMenu.new(nil,200@22, "Menu:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.value=0;
);

g.insertItem(3, \item3, {"this is item 3". postln});


// remove Item ;

(
w=Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(w,200@22, "Menu:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.insertItem(3, \item3, {"this is item 3". postln});
g.value=0;
)

g. removeItemAt(0);



// replace item;
(
g = EZPopUpMenu.new(nil,200@22, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item3, {"this is item 3". postln});
)

g.replaceItemAt(2, \item2_replaced, {"this is item 2 replaced". postln});
::


class:: EZRanger
summary:: A wrapper class for a label, a rangeslider, and numberboxes
categories:: GUI>EZ-GUI
related:: Classes/EZGui, Classes/StaticText, Classes/RangeSlider, Classes/NumberBox

description::
EZRanger is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/RangeSlider:: plus a link::Classes/NumberBox::. If the parent is code::nil::, then EZRanger will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZRanger's number boxes scroll by default, using the step size of the link::Classes/ControlSpec::. If the ControlSpec's step is set to 0, or is not set, then the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the number boxes. By default, the shift-key modifier will allow you to step by 100x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::. Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly, you can customize the other modifier keys to fit your needs. This also affects the arrow keys for the slider.

classmethods::

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZRanger will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZRanger instance as its argument.

argument:: initVal
An instance of link::Classes/Array:: code::[lo, hi]::. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is code::false::.

argument:: labelWidth
Number of pixels width for the label. default is 60.

argument:: numberWidth
Number of pixels width for the number box. default is 45.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0. If 0, then no code::unitLabel:: is created.

argument:: labelHeight
The default is 20;

argument:: layout
code::\vert::, code::\line2::, or code::\horz::. The default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZRanger(w, 400@16," test  ", \freq, { |v| v.value.postln }, [50,2000], unitWidth:30)
)

// Simplest version, no parent view, so a window is created
(
EZRanger(nil, 400@16," test  ", \freq, { |v| v.value.postln }, [50,2000])
)
::
The contained views can be accessed via the EZRanger instance variables: code::rangeSlider::, code::hiBox::, code::loBox::, code::unitView::, code::labelView::.

instancemethods::

subsection:: Accessing Instance and Class Variables

method:: unitView
The units label. Only appears if code::unitWidth:: was set to > 0.

method:: controlSpec
An instance of ControlSpec for scaling the values.

method:: loBox
The code::lo:: value link::Classes/NumberBox::.

method:: action
Set/get a link::Classes/Function:: or link::Classes/FunctionList:: to be evaluated when the value changes. The first argument will be the EZRanger.

method:: rangeSlider
The link::Classes/RangeSlider:: link::Classes/View::

method:: lo
Set/get the low value.

method::hi
Set/get the high value

method:: hiBox
The hi value link::Classes/NumberBox::.

method:: round
Rounds the values in the number boxes.

subsection:: Doing Some Task (optional)

method:: doAction
Performs the action at the current index and the global action.

method:: value
Gets/sets the code::lo:: and code::hi:: values.
argument:: vals
An instance of link::Classes/Array:: code:: [lo, hi] ::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: vals
An instance of link::Classes/Array:: code:: [lo, hi] ::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: sliderColor
An instance of link::Classes/Color::. The slider code::background::.
argument:: numBackground
An instance of link::Classes/Color::. The code::background:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColor
An instance of link::Classes/Color::. The code::knobColor:: of the slider view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.


examples::
code::
(	// basic use
	w=Window.new.front;
	g=EZRanger(w, 400@16," test  ", \freq,{|v| v.value.postln},[50,2000],unitWidth:30);
	g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);
);

// lots of range sliders on a view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=1@1;

20.do{
	g=EZRanger(w, 400@16," test  ", \freq,{|v| v.value.postln},[50.rand,50+20000.rand],unitWidth:30)
	.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,Color.white, Color.white, Color.yellow)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts
(

m=nil;
m=2@2; // comment for no margin


/////////////////
/// Layout \horz

(		// all features, small font
		g=EZRanger(nil, 400@16," freq  ", \freq,
			initVal:[100.rand,200+2000.rand],unitWidth:30, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZRanger(nil, 400@16," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
		g.font_(Font("Helvetica",10));
);
(		// no label, so use window name as label
		g=EZRanger(nil, 400@16, nil, \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
		g.font_(Font("Helvetica",10));
);

/////////////////
/// Layout \line2

(		// all features
		g=EZRanger(nil, 300@42," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:30, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-160);
);

(		// no unitView, with label
		g=EZRanger(nil, 300@42," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-260);
);

(		// no label
		g=EZRanger(nil, 300@42,nil, \freq, initVal:[100.rand,200+2000.rand],
			unitWidth:30, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-360);
		g.window.name="Freq";
);

(		// no label, so use window name as label
		g=EZRanger(nil, 150@42,nil, \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-460);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features, small font
		g=EZRanger(nil, 45@300," Vol  ", \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:30, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(250,50);
		g.font_(Font("Helvetica",9));
);
(		// no label, small font
		g=EZRanger(nil, 45@300, nil, \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:30, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(310,50);
		g.font_(Font("Helvetica",9));
);
(		// no Units small font
		g=EZRanger(nil, 45@300, " Vol", \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:0, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(370,50);
		g.font_(Font("Helvetica",9));
);
(		// no unitView, no units small font
		g=EZRanger(nil, 45@300, nil, \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:0, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(430,50);
		g.font_(Font("Helvetica",9));
);

)

/////////////////

////Sound Example


(	// example to explore a synthesis idea:
p = ProxySpace.push(s.boot);

q = q ? ();
q.freqRange = [200, 2000];
q.ampRange = [0.1, 1];
q.ringRange = [0.1, 10];
q.numRange = [3, 30];

q.soundfunc = { |dens=5|
	Splay.ar(
		Array.fill(exprand(q.numRange[0], q.numRange[1]).asInteger, {
			Ringz.ar(
				Dust.ar(dens),
				exprand(q.freqRange[0], q.freqRange[1]),
				exprand(q.ringRange[0], q.ringRange[1]),
				exprand(q.ampRange[0], q.ampRange[1])
			)
		})
	).distort
};
)
~plong.play;

~plong.fadeTime = 3;
~plong = q[\soundfunc];

(
w = Window("cow herd").front;
w.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));

Spec.add(\ring, [0.03, 30, \exp]);
Spec.add(\num, [3, 30, \exp, 1]);

EZRanger(w, 390@20, "numRange", \num, { |sl| q.numRange = sl.value; }, labelWidth: 65)
	.round_(1);

EZRanger(w, 390@20, "freqRange", \freq, { |sl| q.freqRange = sl.value; }, q.freqRange, labelWidth: 65)
	.round_(0.1);
EZRanger(w, 390@20, "ringRange", \ring, { |sl| q.ringRange = sl.value; }, q.ringRange, labelWidth: 65)
	.round_(0.0001);
EZRanger(w, 390@20, "ampRange", \amp, { |sl| q.ampRange = sl.value; }, q.ampRange, labelWidth: 65)
	.round_(0.0001);
Button(w, 190@20).states_([[\newSound]]).action_({~plong = q[\soundfunc] });
)
::


class:: EZScroller
summary:: Show a subset of items on gui elements
categories:: GUI>EZ-GUI

description::
EZScroller is a vertical slider that allows displaying different subsets of a dynamically changing list of objects on a fixed number of views by scrolling.

EZScroller is used JITLib guis like link::Classes/NodeProxyEditor::, link::Classes/ProxyMixer::, link::Classes/TdefAllGui::, and link::Classes/PdefAllGui::.

examples::
code::
(
w = Window.new("EZScroller test", Rect(100, 400,200, 100)).front;
// 5 displays
v = { |i| DragBoth.new(w, Rect(0, i * 20, 100, 20)) }.dup(5);
// 12 items
a = (1..12);

e = EZScroller(w, Rect(100,0,14,100), v.size, a.size, { |sc|
	var startIndex = sc.value.asInteger.postcs;
	v.do { |drag, i| drag.object_( a[ (startIndex) + i] ? ""); };
	e.visible_(sc.numItems > sc.maxItems); // hide when not useful
});
e.doAction;
)
// change list a, update ezscroller
a = (1..4); e.numItems_(a.size); e.doAction;

a = (1..8); e.numItems_(a.size); e.doAction;
::


class:: EZSlider
summary:: Wrapper class for label, slider, number box
categories:: GUI>EZ-GUI
related:: Classes/Slider, Classes/NumberBox, Classes/StaticText, Classes/CompositeView, Classes/EZGui

description::
EZSlider is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/Slider:: plus a link::Classes/NumberBox::. If the parent is code::nil::, then EZSlider will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZSlider's number box scrolls by default, using the step size of the link::Classes/ControlSpec::. If the controlSpec's step is set to 0, or is not set, then the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the link::Classes/NumberBox::. By default, the shift-key modifier will allow you to step by 100x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::.  Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly you can customize the other modifiers to fit your needs. See link::Classes/NumberBox:: and link::Classes/Slider::. This also effects the arrow keys for the slider.

classmethods::

subsection:: Creation / Class Methods

method:: new
argument:: parent
The parent view or window. If the parent is code::nil::, then EZSlider will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZSlider instance as its argument.

argument:: initVal
The value to initialize the slider and number box with. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. The default is 60.

argument:: numberWidth
Number of pixels width for the number box. The default is 45.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0. If 0, then no unitLabel is created.

argument:: labelHeight
The default is 20;

argument:: layout
code::\vert::, code::\line2::, or code::\horz::. The default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZSlider( w,         // parent
              390@20,    // bounds
              " test ",  // label
              \freq,     // controlSpec
              { |ez| (ez.value.asString ++" is the value of " ++ ez).postln } // action
);
g.setColors(Color.grey,Color.white)
);

// Simplest version, no parent view, so a window is created
(
	g = EZSlider(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::
The contained views can be accessed via the EZSlider instance variables: code::labelView::, code::sliderView::, code::numberView::.

instancemethods::

subsection:: Accessing Instance and Class Variables

method:: numberView
Returns the numberView.

method:: action
A link::Classes/Function:: or link::Classes/FunctionList:: to be evaluated when the value changes. The first argument will be the EZSlider.

method:: value
The value of the slider.

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of ControlSpec for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation. You can only set the label if it was not nil from the beginning.

method:: visible
Sets/gets it the component views are visible.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: sliderBackground
An instance of link::Classes/Color::. The slider code::background::.
argument:: numBackground
An instance of link::Classes/Color::. The code::numColor:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColor
An instance of link::Classes/Color::. The code::knobColor:: of the knob view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
(	// basic use
	w=Window.new.front;
	g=EZSlider(w, 400@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
	g.setColors(Color.grey,Color.white);
);
g.view.enabled=false
// lots of sliders on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

20.do{
	EZSlider(w, 392@16," Freq ", \freq,unitWidth:30,initVal:6000.rand, numberWidth:60,layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll  // use this to close all the windows

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts

(

m=nil;
//m=2@2;		// uncomment this for margin

/////////////////
/// Layout \horz

(		// all features, small font
		g=EZSlider(nil, 400@14," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZSlider(nil, 400@16," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
);
(		// no label, so use window name as label
		g=EZSlider(nil, 400@16, nil, \freq,unitWidth:0, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);

/////////////////
/// Layout \line2

(		// all features
		g=EZSlider(nil, 300@42," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-160);
);

(		// no unitView, with label
		g=EZSlider(nil, 300@42," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-260);
);

(		// no label
		g=EZSlider(nil, 300@42,nil, \freq, unitWidth:30, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-360);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZSlider(nil, 150@42,nil, \freq,unitWidth:0, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-460);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features, small font
		g=EZSlider(nil, 45@300," Vol  ", \db.asSpec.step_(0.01),unitWidth:30, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(250,50);
		g.font_(Font("Helvetica",10));
);
(		// no label, small font
		g=EZSlider(nil, 45@300, nil, \db.asSpec.step_(0.01),unitWidth:30, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(310,50);
		g.font_(Font("Helvetica",10));
);
(		// no Units small font
		g=EZSlider(nil, 45@300, " Vol", \db.asSpec.step_(0.01),unitWidth:0, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(370,50);
		g.font_(Font("Helvetica",10));
);
(		// no unitView, no Units small font
		g=EZSlider(nil, 45@300, nil, \db.asSpec.step_(0.01),unitWidth:0, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(430,50);
		g.font_(Font("Helvetica",10));
);

)




///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


// Sound example
(
// start server
s.waitForBoot({

var w, startButton, noteControl, cutoffControl, resonControl;
var balanceControl, ampControl;
var node, cmdPeriodFunc;

// define a synth
SynthDef("window-test", { |out, note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1|
		var x;
		x = Mix.fill(4, {
			LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, doneAction: Done.freeSelf);
		Out.ar(out, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;




// make the window
w = Window("another control panel", Rect(20, 400, 440, 180));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		if (view.value == 1) {
			// start sound
			node = Synth( "window-test", [
				"note", noteControl.value,
				"fc", cutoffControl.value,
				"rq", resonControl.value,
				"bal", balanceControl.value,
				"amp", ampControl.value.dbamp ]);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
noteControl = EZSlider(w, 430 @ 20, "Note ", ControlSpec(24, 60, \lin, 1, 36, \note),
	{|ez| node.set( "note", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
cutoffControl = EZSlider(w, 430 @ 20, "Cutoff ", ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	{|ez| node.set( "fc", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
resonControl = EZSlider(w, 430 @ 20, "Reson ", ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	{|ez| node.set( "rq", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
balanceControl = EZSlider(w, 430 @ 20, "Balance ", \bipolar,
	{|ez| node.set( "bal", ez.value )},  unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
ampControl = EZSlider(w, 430 @ 20, "Amp ", \db,
	{|ez| node.set( "amp", ez.value.dbamp )}, -6, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);


// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};
});
)




// a variant of the above example so one can
// add new parameters and more views are created automatically

(
// start server
s.waitForBoot({

var w, startButton, sliders;
var node, cmdPeriodFunc;
var params, specs;

// define a synth
SynthDef("window-test", { |out, note = 36, fc = 1000, rq = 0.25, bal = 0, amp=0.4, width=0, gate = 1|
		var x;
		x = Mix.fill(4, {
			VarSaw.ar((note + {0.1.rand2}.dup).midicps, 0, width, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, 5, doneAction: Done.freeSelf);
		Out.ar(out, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;


params = ["note", "fc", "rq", "bal", "amp", "width"];
specs = [
	ControlSpec(24, 60, \lin, 1, 36, \note),
	ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	ControlSpec(-1, 1, \lin, 0, 0, \pan),
	ControlSpec(0.0001, 2, \exp, 0, 0.3, \vol), // db spec acts weird, so use self made one
	ControlSpec(0, 1, \lin, 0, 0.3, \width),
];

// make the window
w = Window("another control panel", Rect(20, 400, 440, 180));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;


// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		var args;
		if (view.value == 1) {
			// start sound
			params.do { |param, i|
				args = args.add(param);
				args = args.add(sliders[i].value)
			};
			node = Synth("window-test", args.postcs);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
sliders = params.collect { |param, i|
	EZSlider(w, 430 @ 20, param, specs[i], {|ez| node.set( param, ez.value )})
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);
};
// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};

})
)
::


class:: EZText
summary:: Wrapper class for a label, a text field and a value
categories:: GUI>EZ-GUI
related:: Classes/StaticText, Classes/TextField

description::
EZText is a wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/TextField::. The value is displayed as a compileString in the text field for editing.

subsection:: Some Important Issues Regarding EZText
If the parent is code::nil::, then EZText will create its own link::Classes/Window::. See link::Classes/EZGui:: for more options.

classmethods::

subsection:: Creation / Class Methods

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZText will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZText instance as its argument.

argument:: initVal
The value to initialize the EZText with.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. The default is 60. In the code::\horz:: layout, if you specify the code::textWidth::, then the code::labelWidth:: is ignored and is set to the code::bounds.width - textWidth::.

argument:: textWidth
Number of pixels width for the number box. The default is 45. In code::\vert:: layout, code::textWidth:: defaults to the code::bounds.width::.

argument:: labelHeight
Default is 20.

argument:: layout
code::\vert::, or code::\horz::. The default is code::\horz::; code::\vert:: is a two line version.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
Example:
code::
(
w = Window("EZText", Rect(300, 300, 260, 60)).front;
g = EZText( w,          // parent
            250@50,     // bounds
            "testing",  // label
            { |ez| (ez.value.asString ++" is the value of " ++ ez).postln }, // action
            [1, 2, 3],  // initValue
            true        // initAction
);
g.setColors(Color.grey,Color.white);
);

// Simplest version, no parent view, so a window is created
(
	g = EZText(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);

(
	g = EZText(bounds: Rect( 100, 200, 150, 50), label:" test ", layout: \vert);
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::
The contained views can be accessed via the EZText instance variables: code::labelView::, code::textField::.

instancemethods::

method:: textField
Returns the textField.

method:: action
A link::Classes/Function:: to be evaluated when the value changes. Typical use is to type in a new value, and interpret it by hitting the evaluation shortcut. The first argument to the function will be the EZText.

method:: value
Gets/sets the value of the ezText. Does not perform the action.
argument:: inval
Any object.

method:: valueAction
Sets the value and performs the action.
argument:: val
Any object.

method:: doAction
Performs the action.

method:: enabled
Sets/gets whether the textfield is enabled.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.


subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: textBackground
An instance of link::Classes/Color::. The code::background:: of the textField.
argument:: textStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the textField.
argument:: textNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the textField.
argument:: textTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the textField.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
// Simplest version
(		// basic use
		w=Window("ez", Rect(300, 300, 300, 50)).front;
		g=EZText(w, 290@40," test  ", textWidth: 220,layout:\horz);
		g.setColors(Color.grey,Color.white);
);


// lots of textFields on one window
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

40.do{
		g=EZText(w, 170@16," test  ", textWidth: 120,layout:\horz);
		g.setColors(Color.grey, Color.white, Color.grey(0.8));
};
);


// click these parentheses to see three variants
(

m=nil;
m=2@2;		//comment for no margin

/////////////////
/// Layout \horz

(		// with label
		g=EZText(nil, 170@20," freq  ", textWidth:120,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
);

(		// no label. use window name as label
		g=EZText(nil, 120@20, layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features
		g=EZText(nil, 120@60," freq  ", textWidth: 120,layout: \vert, margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,50);
);

)



// Simplest sound example
(
Tdef(\text).set(\note, [0, 2, 7], \dur, { [0.1, 0.2].choose });

w = Window("EZTexts", Rect(200, 400, 304, 120)).front;
w.addFlowLayout;

TdefGui(Tdef(\text), 0, w);
Tdef(\text).envir.keysValuesDo { |k, v|
	EZText(w, Rect(0,0,300,40), k, { |ez|
		Tdef(\text).envir.put(*[k, ez.value].postcs);
	}, v);
};

Tdef(\text, { |ev|
	var mydur;
	loop {
		mydur = ev.dur;
		(note: ev.note, dur: mydur).postln.play;
		mydur.wait;
	}
}).play;
)

// type these or similar functions into dur and note fields and evaluate:

{ [0.1, 0.2, 0.3].choose }
{ [ 0, 2, 7, 10 ].scramble.keep(rrand(0, 4)) }
::


TITLE:: EmacsDocument
summary:: Document subclass for Emacs editor
categories:: IDE
related:: Classes/Document

DESCRIPTION::
Is this already implemented?
Please fill in details...


class:: Env
summary:: Specification for a segmented envelope
related:: Classes/EnvGen, Classes/IEnvGen, Classes/Pseg
categories:: Control, Envelopes

description::
An Env is a specification for a segmented envelope. Envs can be used both server-side, by an link::Classes/EnvGen:: or an link::Classes/IEnvGen:: within a link::Classes/SynthDef::, and clientside, with methods such as link::#-at:: and link::#-asStream::, below.

An Env can have any number of segments which can stop at a particular value or loop several segments when sustaining. It can have several shapes for its segments.

The envelope is conceived as a sequence of emphasis::nodes:: (not to be confused with a synthesis-Node) : the first node gives the initial level of the envelope, and the following have three parameters: a target level, a time duration from the previous node, and a shape. The three parameters for each node are kept in separate arrays as explained below.

code::
Env.new(levels: [0, 1, 0.9, 0], times: [0.1, 0.5, 1], curve: [-5, 0, -5]).plot;
::

In this envelope, there are four emphasis::nodes:: :

list::
## the first emphasis::node:: is the initial level of the envelope : 0
## the second emphasis::node:: has level 1 and is reached in 0.1 second
## the third emphasis::nodes:: has level 0.9 and is reached in 0.5 second
## the fourth emphasis::nodes:: has level 0 and is reached in 1 second
::

Close attention must be paid when retriggering envelopes. Starting from their value at the moment of retrigger, envelopes will cycle through all of their nodes, with the exception of the first. The first node is an envelope's initial value and is only output prior to the initial trigger.

code::
(
{
	EnvGen.kr(
		Env(
			levels: [0, 0.1, 0.2, 0.3],
			times: [0.1, 0.1, 0.1],
			curve: 8
		),
		gate: Impulse.kr(3)
	);
}.plot(duration: 1);
)
::

In the above example, the initial level (0) is never repeated. When retriggered, the envelope moves from its current value (0.3), to the value of the second node (0.1), and so forth.

note::
In some situations we deal with control points or breakpoints. If these control points have associated x positions (say in an envelope GUI, see link::Classes/EnvelopeView::) they must be converted to time differences between points to be used as nodes in a Env object. The methods link::#*xyc:: and link::#*pairs:: can be used to specify an envelope in terms of points.
::

code::
// an envelope in a synth
(
{
	var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
	SinOsc.ar(470) * EnvGen.kr(env, doneAction: Done.freeSelf)
}.play
)
// an envelope to control a parameter in a pattern
(
Pbind(
	\note,  Env([0, 12, 6, 13, 0], [1, 5, 2, 10]),
	\dur, 0.1
).play
)
::

ClassMethods::

private::initClass

method::new
Create a new envelope specification.

argument::levels
an array of levels. The first value is the initial level of the envelope. When the envelope is used with an EnvGen, levels can be any UGen (new level values are updated only when the envelope has reached that point).
When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see link::#Multichannel expansion::)

argument::times
an array of durations of segments in seconds. There should be one fewer duration than there are levels, but if shorter, the array is extended by wrapping around the given values.

argument::curve
a link::Classes/Symbol::, link::Classes/Float::, or an link::Classes/Array:: of those. Determines the shape of the envelope segments.

The possible values are:
table::
## code::\step::  || || flat segments (immediately jumps to final value)
## code::\hold::  || || flat segments (holds initial value, jump to final value at the end of the segment)
## code::\linear:: || code::\lin:: || linear segments, the default
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segments.
## code::\welch:: || code::\wel:: || sinusoidal segments shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment
## code::\cubed:: || code::\cub:: || cubed segment
## a link::Classes/Float:: || || a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.
## an link::Classes/Array:: of symbols or floats || || curvature values for each segment.
::

argument::releaseNode
an link::Classes/Integer:: or nil. The envelope will sustain at the releaseNode until released.

code::
(
{
	EnvGen.kr(
		Env.new(
			levels: [0, 1, 0.5, 0],
			times: [0.01, 0.01, 0.01],
			releaseNode: 2 // sustains at level 0.5 until gate is closed
		),
		gate: Trig.kr(Impulse.kr(3), dur: 0.3)
	);
}.plot(duration: 1);
)
::

In the above example, the release node is set to the third node, which means it will sustain at the level of 0.5 until it is released. The envelope will then continue on until its last node is reached.

argument::loopNode
an link::Classes/Integer:: or nil. Creates a segment of looping nodes. You must specify a releaseNode in order for loopNode to have any effect. The loopNode is the initial node of the loop and is never repeated. Upon reaching the releaseNode, the envelope will move back to the node that immediately follows loopNode. The envelope will loop until its gate is closed. When released, a looping envelope will move from its current position to the node that immediately follows releaseNode and continue until the end.

code::
(
{
	EnvGen.kr(
		Env([0, 1, 0, 0.2, 0, 0.5, 0.8, 0], [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01], releaseNode: 5, loopNode: 1),
		gate: Trig.kr(1, 0.9)
	);
}.plot(duration: 1)
)
::

In this example :

list::
## the starting level of the envelope is 0
## the loop goes from nodes[5] (value : 0.5) to the nodes[1+1] (value : 0)
## at time = 0.9, the loop is released, so the envelope goes to nodes[5+1] (value : 0.8)
::

argument::offset
an offset to all time values (only applies in link::Classes/IEnvGen::).

discussion::
code::
(
{
	var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, doneAction: Done.freeSelf);
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);
::

method::newClear
Creates a new envelope specification with strong::numSegments:: and strong::numChannels:: for filling in later.
discussion::
This can be useful when passing Env parameters as args to a link::Classes/Synth::. Note that the maximum number of segments is fixed and cannot be changed once embedded in a link::Classes/SynthDef::. Trying to set an Env with more segments than this may result in other args being unexpectedly set.

code::
(
SynthDef(\help_Env_newClear, { |out = 0, gate = 1|
	var env, envctl;
	// make an empty 4 segment envelope
	env = Env.newClear(4);
	// create a control argument array
	envctl = \env.kr(env.asArray);
	Out.ar(out, SinOsc.ar(EnvGen.kr(envctl, gate), 0) * -12.dbamp);
}).add;
)

Synth(\help_Env_newClear, [\env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [ \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;
::

method::shapeNames
returns the dictionary containing the available shapes for the envelopes' curves

method::shapeNumber
returns the index in the dictionary of the given curve shape

argument::shapeName
name of the shape. e.g. \lin, \cub ...

subsection::Standard Shape Envelope Creation Methods
The following class methods create some frequently used envelope shapes based on supplied durations.

method::linen
Creates a new envelope specification which has a trapezoidal shape.

argument::attackTime
the duration of the attack portion.

argument::sustainTime
the duration of the sustain portion.

argument::releaseTime
the duration of the release portion.

argument::level
the level of the sustain portion.

argument::curve
the curvature of the envelope.

discussion::
code::

Env.linen(0.1, 0.2, 0.1, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6, \sine).test.plot;
Env.linen(1, 2, 3, 0.6, \welch).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, [[\sine, \welch, \lin, \exp]]).plot;
::

method::triangle
Creates a new envelope specification which has a triangle shape.

argument::dur
the duration of the envelope.

argument::level
the peak level of the envelope.

discussion::
code::
Env.triangle(1, 1).test.plot;
::

method::sine
Creates a new envelope specification which has a hanning window shape.

argument::dur
the duration of the envelope.

argument::level
the peak level of the envelope.

discussion::
code::
Env.sine(1, 1).test.plot;
::

method::perc
Creates a new envelope specification which (usually) has a percussive shape.

argument::attackTime
the duration of the attack portion.

argument::releaseTime
the duration of the release portion.

argument::level
the peak level of the envelope.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.perc(0.05, 1, 1, -4).test.plot;
Env.perc(0.001, 1, 1, -4).test.plot;	// sharper attack
Env.perc(0.001, 1, 1, -8).test.plot;	// change curvature
Env.perc(1, 0.01, 1, 4).test.plot;	// reverse envelope
::


method::pairs
Creates a new envelope specification from coordinates / control points

argument::pairs
an array of pairs [[time, level], ...]

if possible, pairs are sorted regarding their point in time


argument::curve
the curvature of the envelope.

discussion::
code::
Env.pairs([[0, 1], [2.1, 0.5],  [3, 1.4]], \exp).plot;
Env.pairs([[0, 1], [3, 1.4], [2.1, 0.5], [3, 4]], \exp).plot; // *if possible*, pairs are sorted according to time
Env.pairs({ { 1.0.rand } ! 2 } ! 16, \exp).plot;
::


method::xyc
Creates a new envelope specification from coordinates / control points with curvature.

argument::xyc
an array of triplets [[time, level, curve], ...]

if possible, pairs are sorted regarding their point in time

discussion::
code::
Env.xyc([[0, 1, \sin], [2.1, 0.5, \lin],  [3, 1.4, \lin]]).plot;
Env.xyc([[2.1, 0.5, \lin], [0, 1, \sin], [3, 1.4, \lin]]).plot; // *if possible*, pairs are sorted according to time
Env.xyc({ [1.0.rand, 10.0.rand, -4.rand2] } ! 16, \exp).plot;
Env.xyc([[0, 1], [2.1, 0.5],  [3, 1.4]]).plot; // if not specified, curve defaults to \lin
::


subsection::Sustained Envelope Creation Methods
The following methods create some frequently used envelope shapes which have a sustain segment. They are typically used in SynthDefs in situations where at the time of starting the synth it is not known when it will end. Typical cases are external interfaces, midi input, or quickly varying TempoClock.

code::
(
SynthDef(\env_help, { |out, gate = 1, amp = 0.1, release = 0.1|
	var env = Env.adsr(0.02, release, amp);
	var gen = EnvGen.kr(env, gate, doneAction: Done.freeSelf);
	Out.ar(out, PinkNoise.ar(1 ! 2) * gen)
}).add
);

a = Synth(\env_help);
b = Synth(\env_help, [\release, 2]);
a.set(\gate, 0); // alternatively, you can write a.release;
b.set(\gate, 0);
::

method::step
Creates a new envelope specification where all the segments are horizontal lines. Given n values of times only n levels need to be provided, corresponding to the fixed value of each segment.

argument::levels
an array of levels. Levels can be any UGen (new level values are updated only when the envelope has reached that point).
When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see link::#Multichannel expansion::)

argument::times
an array of durations of segments in seconds. It should be the same size as the levels array.

argument::releaseNode
an link::Classes/Integer:: or nil. The envelope will sustain at the release node until released.

argument::loopNode
an link::Classes/Integer:: or nil. If not nil the output will loop through those nodes starting at the loop node to the node immediately preceding the release node, before back to the loop node, and so on. Note that the envelope only transitions to the release node when released. Examples are below. The loop is escaped when a gate signal is sent, when the output transitions to the release node, as described below.

argument::offset
an offset to all time values (only applies in link::Classes/IEnvGen::).

discussion::
code::
(
{
	var env = Env.step([0, 3, 5, 2, 7, 3, 0, 3, 4, 0], [0.5, 0.1, 0.2, 1.0, 1.5, 2, 0.2, 0.1, 0.2, 0.1]);
	var envgen = EnvGen.kr(env);
	var freq = (envgen + 60).midicps;
	SinOsc.ar(freq) * 0.1
}.play
);
::

method::adsr
Creates a new envelope specification which is shaped like traditional analog attack-decay-sustain-release (adsr) envelopes.

argument::attackTime
the duration of the attack portion.

argument::decayTime
the duration of the decay portion.

argument::sustainLevel
the level of the sustain portion as a ratio of the peak level.

argument::releaseTime
the duration of the release portion.

argument::peakLevel
the peak level of the envelope.

argument::curve
the curvature of the envelope.

argument::bias
offset

discussion::
code::
Env.adsr(0.02, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(0.45).plot;	// release after 0.45 sec
::

method::dadsr
As link::#*adsr:: above, but with its onset delayed by strong::delayTime:: in seconds. The default delay is 0.1.

method::asr
Creates a new envelope specification which is shaped like traditional analog attack-sustain-release (asr) envelopes.

argument::attackTime
the duration of the attack portion.

argument::sustainLevel
the level of the sustain portion as a ratio of the peak level.

argument::releaseTime
the duration of the release portion.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.asr(0.02, 0.5, 1, -4).test(2).plot;
Env.asr(0.001, 0.5, 1, -4).test(2).plot; // sharper attack
Env.asr(0.02, 0.5, 1, 'linear').test(2).plot; // linear segments
::


method::cutoff
Creates a new envelope specification which has no attack segment. It simply sustains at the peak level until released. Useful if you only need a fadeout, and more versatile than link::Classes/Line::.

argument::releaseTime
the duration of the release portion.

argument::level
the peak level of the envelope.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.cutoff(1, 1).test(2).plot;
Env.cutoff(1, 1, 4).test(2).plot;
Env.cutoff(1, 1, \sine).test(2).plot;
::

method::circle
Creates a new envelope specification which cycles through its values. For making a given envelope cyclic, you can use the instance method link::#-circle::

argument::levels
The levels through which the envelope passes.

argument::times
The time between subsequent points in the envelope, which may be a single value (number), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the times array is the same as that of the levels, because it includes the loop time.

argument::curve
The curvature of the envelope, which may be a single value (number or symbol), or an array of them.  If too short, the array is extended. In difference to the *new method, the size of the curve array is the same as that of the levels, because it includes the loop time.


discussion::
code::
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0], [0.01, 0.5, 0.2])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, 2, 0, 1, 0], [0.01, 0.3])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, (2..4), 0, (1..3), 0], [0.01, 0.3])) * 440 + 200).sum * 0.2 }.play; // multichannel expanded levels
::

subsection::Multichannel expansion
If one of the values within either levels, times, or curves is itself an array, the envelope expands to multiple channels wherever appropriate. This means that when such an envelope is passed to an EnvGen, this EnvGen will expand, and when the envelope is queried via the methods link::#-at:: or link::#-asSignal::, it will return an array of values.

code::
(
{
	var env = Env([0.0, 0.5, 0.0, [1.0, 1.25, 1.5], 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, doneAction: Done.freeSelf);
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);

(
{
	var env = Env([1, [1, 2, 3], 0.5, 0.5, [3, 2, 1], 2], [1, 1, 0.5, 1], [[\exp, \sin]]);
	env.plot;
	Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


(
{
	var levels = (1..30);
	var env = Env([1, levels, 0.5, levels / 2.5, 2], [1, 0.15, 1, 0.25, 0.1], \exp);
	Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


// accessing the envelope by indexing

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);

e = Env([1, 1, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);


// multichannel levels

Env([0.1, 1, 0.1], [1, [1, 2, 3]], \exp).plot;
Env([0.1, 1, 0.1], [1, [1, 2, 3]], [\lin, [\lin, \exp, \sin]]).plot;

Env([1, 1, 0.5, 3, 2], [1, 0.5, 1, 0.25], \exp).plot;
Env([0, 1, 0, 2, 0] * [[1, 2, 3]], [1, 0.5, 1, 0.25], \lin).plot;


// multichannel curves

Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [[\lin, \sqr]]).plot;

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [[\lin, \cub, \sin, \cubed, \welch, \step, \exp]]).plot(bounds: Rect(30, 100, 500, 700));

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));
Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));


Env([[0, 0.01], 1, 0], [0.5, 0.5], [[\lin, \exp], \step]).plot;
Env([[0, 0.01], 1, [0, 0.01]], [0.5, 1], [[\lin, \exp]]).plot;

// multichannel times

Env([[2, 1], 0], [[1, 2]], \lin).plot;
Env([0, 1], [1/(1..5)], [(-4..4)]).plot(bounds: Rect(30, 100, 300, 700));
Env([0, 1], [1/(1..5)], \lin).plot(bounds: Rect(30, 100, 300, 700));


// mixed expansions

Env([1, [ 1, 2, 3, 4, 5 ], 0.5, [3, 2, 1], 2], [1, 0.5, 1, 0.25], [[\exp, \lin]]).plot;
Env([1, [ 1, 2, 3, 4, 5 ], 0.5, 4, 2], [1, 0.5, 1, 0.25], \exp).plot;


// expanding control point envelopes

Env.xyc([[2, 0.5, [\lin, \exp]], [0, 1, \lin], [3, 1.4, \lin]]).plot;
Env.xyc({ [1.0.rand, 1.0.rand, {[\lin, \exp, \step].choose} ! 3] } ! 8).plot

Env.xyc([[[2.0, 2.3], 0.5, \lin], [0, 1, \lin], [3, 1.4, \lin]]).plot; // multiple times


::

InstanceMethods::

private::prAsArray


method::ar, kr
Instead of using an link::Classes/EnvGen:: inside a UGen graph, this message does the same implicitly for convenience. Its argument order corresponds to the most common arguments.

argument::doneAction

An integer representing an action to be executed when the env is
finished playing. This can be used to free the enclosing synth,
etc. See link::Classes/Done::  for more detail.

argument::gate

This triggers the envelope and holds it open while > 0. If the
Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument
is used as a simple trigger. If it is an sustaining envelope
(e.g. Env.adsr, Env.asr), the envelope is held open until the
gate becomes 0, at which point is released.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::Classes/EnvGen#Forced release:: example.


argument::timeScale

The durations of the segments are multiplied by this value. This
value can be modulated, but is only sampled at the start of a new
envelope segment.

argument::levelScale

The levels of the breakpoints are multiplied by this value. This
value can be modulated, but is only sampled at the start of a new
envelope segment.

argument::levelBias

This value is added as an offset to the levels of the breakpoints.
This value can be modulated, but is only sampled at the start of a
new envelope segment.

discussion::
code::
{ Blip.ar(50, 200, Env.perc(1, 0.1, 0.2).kr(2)) }.play;
(
{
	Blip.ar(
		Env({ exprand(3, 2000.0) } ! 18, 0.2, \exp).kr,
		200,
		Env({ rrand(0.1, 0.2) } ! 18 ++ 0, 0.2).kr(2))
	}.play;
)
::

method::blend
Blend two envelopes. Returns a new Env. See link::#blend:: example below.

argument::argAnotherEnv
an Env.

argument::argBlendFrac
a number from zero to one.

method::delay
Returns a new Env based on the receiver in which the start value will be held for strong::delay:: number of seconds.

argument::delay
The amount of time to delay the start of the envelope.

discussion::
code::
a = Env.perc(0.05, 1, 1, -4);
b = a.delay(2);
a.test.plot;
b.test.plot;

a = Env([0.5, 1, 0], [1, 1]).plot;
a.delay(1).plot;
::

method::duration
Set the total duration of times, by stretching them.
discussion::
code::
e = Env([0, 1, 0], [1, 2]);
e.duration;
e.duration = 2;
e.duration;
::

method::totalDuration
Get the total duration of the envelope. In multi-channel envelopes, this is the duration of the longest one.
discussion::
code::
e = Env([0, 1, 0], [[1, 2], 2]);
e.duration;
e.totalDuration;
::

method::circle
circle from end to beginning over the time specified, with the curve specified. See also the class method link::#*circle::

discussion::
code::
(
{ SinOsc.ar(
	EnvGen.kr(
		Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle.postcs)
	) * 0.1
	+ Impulse.ar(1) }.play;
)

(
{ SinOsc.ar(
	EnvGen.kr(
		Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle(1).postcs,
		MouseX.kr > 0.5)
	) * 0.1
	+ Impulse.ar(1) }.play;
)
::

method::test
Test the envelope on the default link::Classes/Server:: with a link::Classes/SinOsc::.

argument::releaseTime
If this is a sustaining envelope, it will be released after this much time in seconds. The default is 3 seconds.

method::plot
Plot this envelope's shape in a window.

argument::size
The size of the plot. The default is 400.

argument::bounds
the size of the plot window.

argument::minval
the minimum value in the plot. Defaults to the lowest value in the data.

argument::maxval
the maximum value in the plot. Defaults to the highest value in the data.

argument::name
the plot window's label name. If nil, a name will be created for you.

method::asSignal
Returns a link::Classes/Signal:: of size strong::length:: created by sampling this Env at strong::length:: number of intervals. If the envelope has multiple channels (see link::#Multichannel expansion::), this method returns an array of signals.

method::asArray
Converts the Env to an link::Classes/Array:: in a specially ordered format. This allows for Env parameters to be settable arguments in a SynthDef. See example under link::#*newClear::.

method::asMultichannelArray
Converts the Env to an link::Classes/Array:: in a specially ordered format, like link::#-asArray::, however it always returns an array of these data sets, corresponding to the number of channels of the envelope.

method::isSustained
Returns true if this is a sustaining envelope, false otherwise.

method::range, exprange, curverange
Returns a copy of the Env whose levels have been mapped onto the given linear, exponential or curve range.
discussion::
code::
a = Env.adsr;
a.levels;
a.range(42, 45).levels;
a.exprange(42, 45).levels;
a.curverange(42, 45, -4).levels;

(
// Mapping an Env to an exponential frequency range:
{
	SinOsc.ar(EnvGen.ar(Env.perc(0.01, 0.7).exprange(40, 10000), doneAction: Done.freeSelf)) * 0.2;
}.play
)
::

subsection::Client-side Access and Stream Support
Sustain and loop settings have no effect in the methods below.

method::at
Returns the value of the Env at strong::time::. If the envelope has multiple channels, this method returns an array of levels.

argument::time
A number or an array of numbers to specify a cut in the envelope. If time is an array, it returns the corresponding levels of each time value, and if the envelope has multiple channels, it returns an array of values. A combination of both returns a two-dimensional array.

discussion::
code::
e = Env.triangle(1, 1);
e.at(0.5);
e.at([0.5, 0.7]);

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);
e.at([0.5, 1.2]);

e = Env([1, 100, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);
e.at([1, 2, 4]);


::

method::embedInStream
Embeds this Env within an enclosing link::Classes/Stream::. Timing is derived from code::thisThread.beats::.

method::asStream
Creates a Routine and embeds the Env in it. This allows the Env to function as a link::Classes/Stream::.
discussion::
code::
(
{
e = Env.sine.asStream;
5.do({
	e.next.postln;
	0.25.wait;
})}.fork
)
::

Examples::

code::
s.boot; 	//.test below will run a synthesis example
		// to demonstrate the envelope, so the Server must be on

// different shaped segments: .plot graphs the Env
Env.new([0,1, 0.3, 0.8, 0], [2, 3, 1, 4],'linear').test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001], [2, 3, 1, 4],'exponential').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\sine).test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001],[2,3,1,4],\welch).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],'step').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], -2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], 2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], [0, 3, -3, -1]).test.plot;
::

If a release node is given, and the gate input of the EnvGen is set to zero, it outputs the nodes after the release node:

code::
// release node is node 1; takes 0.5 seconds to go from 0 to 1,
// sustains at level of 1, then released after three seconds
// (test causes the release after three seconds, given the argument 3),
// taking 2 seconds to finish
Env.new([0,1,0],[0.5,2],'linear',1).test(3).plot

// more complex examples
// release node is node 2; releases after 5 sec
Env.new([0.001,1,0.3,0.8,0.001],[2,3,1,4] * 0.2, 2, 2).test(5).plot;
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(5).plot;

// early release: goes straight onto the release node after 0.1 seconds
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(0.1).plot;
::

If a loop node is given, the EnvGen outputs the nodes between the loop node and the release node (not including the release node itself) until it is released:

code::
// release node is node 2, loop node is node 0: so loops around nodes 0 (lvl 1, dur 0.5)
// and 1 (lvl 0.1, dur 0.5) 		//until released after 3.5 seconds
Env.new([0,1,0.1,0],[0.5,0.5,2], 'lin', 2, 0).test(3.5).plot;

// this just sustains at node 0, because there is no other node to loop around!
Env.new([0,1,0],[0.5,2], 'lin', 1, 0).test(3.5).plot;

// more complex example: release node is node 3, loop node is node 1
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.1, 'lin', 3, 1).test(3).plot;

// this is the resulting graph:
(
e = Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.001, 'lin', 3, 1);
e.plot;{ EnvGen.ar(e, Trig.ar(Impulse.ar(0), 10*0.001)) }.plot(0.02);
)

::

note::
The starting level for an envelope segment is always the level you are at right now. For example when the gate is released and you jump to the release segment, the level does not jump to the level at the beginning of the release segment, it changes from whatever the current level is to the goal level of the release segment over the specified duration of the release segment.

There is an extra level at the beginning of the envelope to set the initial level. After that each node is a goal level and a duration, so node zero has duration equal to times[0] and goal level equal to levels[1].

The loop jumps back to the loop node. The endpoint of that segment is the goal level for that segment and the duration of that segment will be the time over which the level changed from the current level to the goal level.
::

method::streamArg
Returns the same output as code::asStream::.


subsection::blend
code::
a = Env([0, 0.2, 1, 0.2, 0.2, 0], [0.5, 0.01, 0.01, 0.3, 0.2]);
a.test.plot;

b = Env([0, 0.4, 1, 0.2, 0.5, 0], [0.05, 0.4, [0.01, 0.1], 0.1, 0.4]);
b.test.plot;

(
Task({
	f = (0, 0.2 .. 1);
	f.do { |u|
		blend(a, b, u).test.plot;
		2.wait;
		Window.allWindows.pop.close; // close last opened window
	}
}).play(AppClock);
)

// blend in a SynthDef
(
SynthDef(\help_EnvBlend, { | out, factor = 0 |
	Out.ar(out, EnvGen.kr(blend(Env.perc, Env.sine, factor), 1.0, doneAction: Done.freeSelf)
		* SinOsc.ar(440,0,0.1)
	)
}).add
);

(
{
	var factors = (0, 0.1..1);
	factors.do {|f| Synth(\help_EnvBlend, [\factor, f.postln]); 1.wait };
}.fork
);
::


class:: EnvGate
summary:: singleton fade envelope
categories:: JITLib>NodeProxy
related:: Classes/EnvGen

description::
Convenience class for an envelope generator combining fadeTime and gate arguments.

ClassMethods::

method::new
Returns an link::Classes/EnvGen::.

argument::i_level
initial level of envelope (if set to 1, it starts open)

argument::gate
a gate input. if nil, EnvGate creates a link::Classes/NamedControl:: named 'gate'

argument::fadeTime
an input for both attack and decay time. if nil, EnvGate creates a link::Classes/NamedControl:: named 'fadeTime' (default time: 0.02)

argument::doneAction
doneAction of the link::Classes/EnvGen::

argument::curve
envelope curve

Examples::

code::
a = { LPF.ar(Saw.ar(200), 600) * EnvGate.new }.play;
a.set(\fadeTime, 2);
a.release;

// the same as:
a.set(\gate, 0);

// several env gates can coexist in one synth def.
(
a = {
	var sound1 = LPF.ar(Saw.ar(80), 600) * EnvGate.new;
	var sound2 = RLPF.ar(Saw.ar(200) * 0.5, 6000 * EnvGate.new + 60, 0.1) * EnvGate.new;
	sound1 + sound2
}.play;
)
a.set(\fadeTime, 5);
a.release;
::


class:: EnvGen
summary:: Envelope generator
related:: Classes/Linen, Classes/Env
categories::  UGens>Envelopes


Description::

Plays back break point envelopes. The envelopes are instances of the
link::Classes/Env:: class. The envelope and the arguments for  code::levelScale::,
code::levelBias::, and  code::timeScale:: are polled when the EnvGen is
triggered, and at the start of a new envelope segment. All values remain constant
for the duration of each segment.

code::
{ PinkNoise.ar(EnvGen.kr(Env.perc, doneAction: Done.freeSelf)) }.play
::

classmethods::

private::convertEnv

method::ar, kr

argument::envelope

An link::Classes/Env:: instance, or an Array of Controls.
(See link::Classes/Control::  and the example below for how to use
this.)

The envelope is polled when the EnvGen is triggered, and at the start of a new envelope segment. The Env inputs can be other UGens.


argument::gate

This triggers the envelope and holds it open while > 0. If the
Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument
is used as a simple trigger. If it is an sustaining envelope
(e.g. Env.adsr, Env.asr), the envelope is held open until the
gate becomes 0, at which point is released.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::#Forced release:: below.

argument::levelScale

The levels of the breakpoints are multiplied by this value. This
value can be modulated, but is only sampled at the start of a new
envelope segment.

argument::levelBias

This value is added as an offset to the levels of the breakpoints.
This value can be modulated, but is only sampled at the start of a
new envelope segment.

argument::timeScale

The durations of the segments are multiplied by this value. This
value can be modulated, but is only sampled at the start of a new
envelope segment.

argument::doneAction

An integer representing an action to be executed when the env is
finished playing. This can be used to free the enclosing synth,
etc. See link::Classes/Done::  for more detail.

discussion::
note::
The actual minimum duration of a segment is not zero, but one sample step for audio rate and one block for control rate. This may result in asynchronicity when in two envelopes of different number of levels, the envelope times add up to the same total duration. Similarly, when modulating times, the new time is only updated at the end of the current segment - this may lead to asynchronicity of two envelopes with modulated times.
::

code::

// as amplitude envelope
(
{
	var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
	SinOsc.ar(470) * EnvGen.kr(env, doneAction: Done.freeSelf)
}.play
)

// as amplitude and modulation envelope
(
{
	var env = Env([0, 1, 0.5, 0.8, 0, 1.2, 0], [0.01, 0.5, 0.02, 0.5, 0.2, 0.5]);
	var gate = Impulse.kr(MouseX.kr(0.2, 3), 0.5);
	var gen = EnvGen.kr(env, gate);
	SinOsc.ar(270, SinOsc.ar(gen * 473)) * gen * 0.2
}.play
)
// EnvGen multichannel expands when passed a multichannel envelope
(
{
	SinOsc.ar(
		EnvGen.kr(
			Env.circle([0, 1, 0, (2..4), 0, LFNoise1.kr(0.1 ! 5) * 10, 0], [0.01, 0.6])
		)
		* 240 + 300
	).sum * 0.2
}.play;
)
::

Examples::

code::
// retriggered envelope by Dust
(
{
	var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, Dust.ar(1));
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);

// two channels
(
{
	var env = Env([0.0, [-0.2, 0.5], 0.0, 1.0, [-0.4, 0.9], 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, Dust.ar([1, 1]));
	SinOsc.ar(
		envgen * 440 + 550
	) * envgen * 0.1
}.play
);

// an envelope in a SynthDef can be used to limit the synth's lifetime (doneAction: Done.freeSelf)

(
SynthDef(\env_help, { | out, gate = 0, freq = 440 |
    var z;
    z = EnvGen.kr(Env.perc, doneAction: Done.freeSelf) * SinOsc.ar(freq, 0, 0.1);
    Out.ar(out, z)
}).add;
)

(
fork {
	10.do {
		Synth(\env_help);
		0.2.rand.wait;
	}
}
)


// using a gated envelope to gate a sound:
(
SynthDef(\env_help, { | out, gate = 0, freq = 440, doneAction = 0 |
    var z = EnvGen.kr(Env.adsr, gate, doneAction: doneAction) * SinOsc.ar(freq, 0, 0.1);
    Out.ar(out, z)
}).add;
)

a = Synth(\env_help);


// turn on
a.set(\gate, 1);

// turn off
a.set(\gate, 0);

// it does not matter to what value the gate is set, as long as it is > 0
a.set(\gate, 2);

a.set(\doneAction, 2, \gate, 0); // set doneAction to two to let the synth free itself

a.free; // alternatively, free it directly.
::

subsection:: Specifying an envelope for each new synth
code::
(
SynthDef(\help_Env_newClear, { |out = 0|
	var env, envctl;
	// make an empty 4 segment envelope
	env = Env.newClear(4);
	// create a control argument array
	envctl = \env.kr(env.asArray);
	Out.ar(out,
		SinOsc.ar(EnvGen.kr(envctl, \gate.tr), 0, 0.3) // the gate control is a trigger
	);
}).add;
)

Synth(\help_Env_newClear, [\gate, 1, \env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [\gate, 1, \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, gate: 1, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;

::

subsection:: Forced release
If the gate of an EnvGen is set to -1 or below, then the envelope will cutoff immediately.
The time for it to cutoff is the amount less than -1, with -1 being as fast as possible, -1.5 being a cutoff in 0.5 seconds, etc.
The cutoff shape and final value are read from the Env's last node.
code::
(
SynthDef(\stealMe, { |out, gate = 1|
    Out.ar(out, {BrownNoise.ar}.dup * EnvGen.kr(Env.asr, gate, doneAction: Done.freeSelf))
}).add;
)

a = Synth(\stealMe);
a.release(3); //  // cutoff in 3 seconds

// this is how the OSC data looks like:
s.sendMsg(\s_new, \stealMe, 1001, 1, 0);
s.sendMsg(\n_set, 1001, \gate, -1.1); // cutoff in 0.1 seconds
::

If the synthDef has an arg named "gate", the convenience method of Node can be used: code::node.release(releaseTime)::
code::
d = { arg gate=1; {BrownNoise.ar}.dup * EnvGen.kr(Env.asr, gate, doneAction: Done.freeSelf) }.play;
d.release(3);
::

Forced release ignores multi-node release stages, always performing a one-node release,
reading curve and end value from the Env's last node, and overwriting its duration.

code::
(
// a Synth with a multi-node release stage
d = { arg gate=1;
	var env = Env([0,1,0,0.5,0],0.5,-4,releaseNode:1);
	{BrownNoise.ar}.dup * EnvGen.kr(env, gate, doneAction: Done.freeSelf)
}.play;
)
// forced release in 2 seconds:
// end value (0) and shape (-4) are read from the env's last node, nodes 2 and 3 are skipped
d.release(2);

// without releaseTime: normal release stage, as defined in env (3 nodes)
d.release();
::

subsection:: Fast triggering tests
code::
(
{
    EnvGen.kr(
        Env.new([ 0.001, 1, 0.5, 0 ], [ 0.01, 0.3, 1 ], -4, 2, nil),
        Impulse.kr(10)
    ) * SinOsc.ar(440, 0, 0.1)
}.play;
)

(
{
    EnvGen.kr(
        Env.perc( 0.1, 0.0, 0.5, 1, \welch ),
        Impulse.kr(100),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)
::

subsection:: Modulating the levelScale
code::
// no, it doesn't take a ugen in ...
(
{
    EnvGen.kr(
        Env.asr( 0.1, 1.0, 0.5, \welch ),
        1.0,
        FSinOsc.ar(1.0).range(0.0, 1.0),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)

// ...but an .ir rate input, a float or an ir rate ugen like Rand would work
(
{
    EnvGen.kr(
        Env.asr( 0.1, 1.0, 0.5, \welch ),
        1.0,
        Rand(0.1, 1.0),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)
::

subsection::More examples

For more information about the emphasis::control bus mapping:: used in the line code::a = Synth(\sine, [freq: f.asMap]);::, see link::Classes/Node#-map:: and link::Classes/Bus#-asMap::.

code::

// Changing an Env while playing
(
SynthDef(\env, { arg i_outbus=0;
	var env, envctl;

	// make a dummy 8 segment envelope
	env = Env.newClear(8);

	// create a control argument array
	envctl = \env.kr( env.asArray );

	ReplaceOut.kr(i_outbus, EnvGen.kr(envctl, doneAction: Done.freeSelf));
}).add;
)

(
SynthDef(\sine, { |out, freq = 440|
	Out.ar(out, SinOsc.ar(freq, 0, 0.2));
}).add;
)

f = Bus.control(s, 1);
f.set(800);

// use f's control bus value for frequency
// i.e. *map* the control to read from the bus
a = Synth(\sine, [freq: f.asMap]);

Synth(\env, [i_outbus: f, env: Env([700, 900, 900, 800], [1, 1, 1]*0.4, \exp)]);

Synth(\env, [i_outbus: f, env: Env([1000, 1000, 800, 1000, 900, 1000], [1, 1, 1, 1, 1]*0.3, \step)]);

a.free;
f.free;
::


class:: EnvelopeView
summary:: A configurable view with nodes and connections
categories:: GUI>Views
related:: Classes/MultiSliderView, Classes/SCEnvelopeEdit

DESCRIPTION::

A view which can graphically display nodes at x/y coordinates, connection lines, cross-connections, node markers, and labels. All of the values for these are stored in arrays. While this view is typically used to make editable envelopes interfaces, it can be used to draw very complex interconnection graphs as well.

You can make the view display an link::Classes/Env:: using link::#-setEnv::. Note however that the view will work on a copy of the data of the Env object, therefore moving the nodes through the view will have no effect on the Env.

You can also define nodes with arrays of x and y values using link::#-value::, and the connections using link::#-connect::.

SUBSECTION:: Appearance

The view supports two strong::display styles::: the default one draws nodes as small dots, with labels next to them, while another style draws nodes as rounded rectangles with labels drawn inside. See link::#-style::.

A strong::label:: for each of the nodes can be set using link::#-strings:: and link::#-setString::.

SUBSECTION:: Interaction

Nodes can be selected and moved using mouse. Shift-clicking a node will add it to the selection.

You can also move selected nodes and change selection using keyboard. Pressing the arrow keys will move selected nodes (as long as link::#-step:: is larger than 0). Pressing the left or right arrow keys while holding down Alt will select previous or next node, and holding down Shift will extend selection to the left or to the right. Other GUI kits may differ.

link::#-keepHorizontalOrder:: allows you to enforce the order of nodes in horizontal direction to match their index order. In that case, node movement to the left and to the right will be restricted by the positions of their immediate neighbours. This is especially useful when EnvelopeView is used to display an link::Classes/Env::.

link::#-elasticSelection:: determines whether moving multiple nodes will be blocked altogether if any of the nodes meet an obstacle (the view bounds or a neighbour node), or only those individual nodes will be blocked.

Node selection can also be changed programmatically using link::#-index::, link::#-selectIndex::, and link::#-deselectIndex::. The link::#-index#current:: node can be moved programmatically using link::#-x:: and link::#-y::.

INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: setEnv
	Sets an link::Classes/Env:: to be displayed by the view. The view will extract data from the Env object to display (times, values and curve types).

	Any nodes existent prior to calling this method will be removed.

	argument::
		An Env.


METHOD:: value
	code::value:: retrieves the node positions, returning an array in the format of the Argument below. code::value_(anArray):: Sets the positions of the nodes, creating them if not existent.

	If there were already existent nodes and their amount is different than the amount of x/y pairs in the argument, nodes will be added or removed (in order of creation reversed) until the amounts match, and then the new values will be applied.

	argument::
		An Array containing two other Arrays, of which one contains the horizontal and the other the vertical position of the new nodes. The values must be between 0 and 1. For example: code:: [[ x1, x2, x3, ... ], [ y1, y2, y3, ... ]] ::

METHOD:: valueAction
	Sets link::#-value:: to the argument and triggers the link::#-action::.

METHOD:: x
	The horizontal position of the emphasis::current:: node.

	argument::
		A Float between 0 and 1.

METHOD:: y
	The vertical position of the emphasis::current:: node.

	argument::
		A Float between 0 and 1.

METHOD:: currentvalue
	Synonym for link::#-y::.

METHOD:: curves
	The shapes of connections between nodes. See below for the valid objects that describe a shape.

	If a single shape is given, it will be applied to all the existing nodes. If an Array of shapes is given, each of its elements will be applied to an existing node, in order of index.

	A connection curve shape applied to a node will determine the shape of the connections originating at that node. If no connections have been created using link::#-connect::, the origin node of a connection is the one with lower index. If there are such connections however, their origin is the node that was passed as the first argument to link::#-connect::.

	argument::
		The valid objects to describe a shape are listed in link::Classes/Env#*new::. The argument can be either a single, or an Array of those values.

METHOD:: strings
	The labels of the nodes.

	note:: In order for the labels to be visible, you might need to ensure that the link::#-strokeColor:: contrasts the link::#-fillColor:: (depending on how the view draws the nodes and the labels).
	::

	argument::
		An Array of Strings.

METHOD:: setString
	Sets the label of the node at the given index.

	note:: In order for the label to be visible, you might need to ensure that the link::#-strokeColor:: contrasts the link::#-fillColor:: (depending on how the view draws the nodes and the labels).::

	argument::index
	the index of the node.

	argument::string
		A String.

METHOD:: setFillColor
	Sets the color used to draw the inside of the node at the given index.

	argument:: index
		An Integer.
	argument:: color
		A Color.

METHOD:: setThumbWidth
	Sets the width of the node at the given index.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument:: index
		An Integer.
	argument:: width
		An Integer.

METHOD:: setThumbHeight
	Sets the height of the node at the given index.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument:: index
		An Integer.
	argument:: height
		An Integer.

METHOD:: setThumbSize
	Sets both width and height of the node at the given index to code::size::.

	argument:: index
		An Integer.
	argument:: size
		An Integer.


METHOD:: connect
	Removes any connections created when the link::#-value:: was set, and then creates new ones from the node at index given in the first argument to each of the nodes at indexes given in the second argument.

	argument:: source
		An Integer - the index of the node to become one end of all the new connections.
	argument:: targets
		An Array of Integers - indexes of nodes, each to become the second end to a new connection created.

METHOD:: selection
	Returns an array of indexes of all selected nodes.


SUBSECTION:: Appearance

METHOD:: style


    One of the following drawing styles:

    list::

    ## strong::'dots':: - nodes are drawn as small dots within a larger circle indicating the area of mouse sensitivity. Labels are drawn next to the dots (see link::#-setString::). This style always draws nodes with emphasis::equal width and height::, and will use the smaller of the node's sizes, if different (it never draws ellipses).

    ## strong::'rects':: - nodes are drawn as rounded rectangles. Labels are drawn within the bounds of the rectangles.
    ::

    NOTE:: For compatibility with existing code, calling any of link::#-thumbWidth::, link::#-thumbHeight::, link::#-setThumbWidth::, or link::#-setThumbHeight:: will automatically switch style to strong::'rects'::. You can still set a different style afterwards.
    ::

    argument::
        One of the symbols: code::\dots:: or code::\rects::. Alternatively, an integer 0 or 1, for each style respectively.

    returns:: An integer 0 or 1.

METHOD:: drawLines
	Whether to draw the connections between the nodes.

	argument::
		A Boolean.

METHOD:: drawRects
	Whether to draw the nodes

	argument::
		A Boolean.


METHOD:: gridOn
	Whether to draw the grid.

	argument::
		A Boolean.

METHOD:: grid
	The resolution of the grid.

	argument::
		A Point of which x and y correspond to grid spacing on the horizontal and the vertical axis, respectively. If one of the two is 0, the grid on that axis will not be drawn.

METHOD:: thumbWidth
    Sets the width of all nodes.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument::
		An Integer.

METHOD:: thumbHeight
    Sets the height of all nodes.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument::
		An Integer.

METHOD:: thumbSize
	Sets both link::#-thumbWidth:: and link::#-thumbHeight:: to the argument.

METHOD:: strokeColor
	The color used to draw the connections and the node labels.

	argument::
		A Color.

METHOD:: fillColor
	The default color used to draw the nodes. If the color of a specific node has been set using link::#-setFillColor::, it will take precedence.

	argument::
		A Color.

METHOD:: selectionColor
	The color of a node when it is selected.

	argument::
		A Color.


METHOD:: gridColor
	The color of the grid.

	argument::
		A Color.

METHOD:: colors
	Sets the link::#-strokeColor:: and the link::#-fillColor:: to the arguments, respectively.



SUBSECTION:: Interaction

METHOD:: index
	The index of the emphasis::current:: node, i.e. the node affected by link::#-x:: and link::#-y:: methods.

    This is the selected node with lowest index, or -1 if no selection.

	argument::
		An Integer.

METHOD:: lastIndex
    The last node selected, regardless of the current state of selection, or -1 if no node has yet been selected.


METHOD:: selectIndex
	Selects the node at given index and makes it the current one, i.e. link::#-currentvalue:: will relate to that node. As a special case, if the argument is -1 all nodes will be deselected.

	argument::
		An Integer.

METHOD:: deselectIndex
	Deselects the node at given index.

	note:: Not available in strong:: Cocoa GUI ::. ::

	argument::
		An Integer.

METHOD:: editable
	Whether any node is editable.

	argument::
		A Boolean.

METHOD:: setEditable
	Sets whether the node at given index is editable. Regardless of this, no node will be editable unless link::#-editable:: is code::true::.

	argument:: index
		An Integer.

	argument:: flag
		A Boolean.

METHOD:: step
	Makes the nodes snap (i.e. quantized) to the nearest multiple of the argument. Unless this is larger than 0, nodes will not be movable using keyboard.

	argument::
		A Float.

METHOD:: keepHorizontalOrder

	Whether the position of nodes on the horizontal axis shall be restricted by their immediate neighbours (in order of their index).

	Setting this to code::true:: will immediately modify the positions of existing nodes to match the order.

	argument::
		A Boolean.

METHOD:: elasticSelection

	Whether the relative positions of nodes within the selection can change when the selection is moved using mouse or keyboard, in order to adapt to obstacles (the view bounds or, in case link::#-keepHorizontalOrder:: is code::true::, a neighbour node).

	If this is code::false::, movement of multiple nodes will be blocked altogether when an obstacles is met, otherwise only the individual nodes will be blocked at their obstacles.

	argument::
		A Boolean.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user moves a node.

METHOD:: metaAction
	The action object evaluated whenever the user moves a node while the Ctrl key is pressed.

METHOD:: defaultKeyDownAction

    Implements the default behavior on key presses.

    The default behavior is defined in the C++ implementation of the view instead of this method. See link::Classes/View#Key and mouse event processing:: for explanation of how to override the behavior.




SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True for any drag data, but the data should be in the same format as link::#-value::.

METHOD:: defaultReceiveDrag
	If the drag data is of the acceptable form (see link::#-defaultCanReceiveDrag:: above), sets link::#-value:: using that data.



EXAMPLES::

Use as envelope view
code::
(
// use shift-click to keep a node selected
w = Window("envelope", Rect(150 , Window.screenBounds.height - 250, 250, 100)).front;
w.view.decorator = FlowLayout(w.view.bounds);

b = EnvelopeView(w, Rect(0, 0, 230, 80))
	.drawLines_(true)
	.selectionColor_(Color.red)
	.drawRects_(true)
	.resize_(5)
	.step_(0.05)
	.action_({arg b; [b.index, b.value].postln})
	.thumbSize_(5)
	.value_([[0.0, 0.1, 0.5, 1.0],[0.1,1.0,0.8,0.0]]);
w.front;
)

// show grid
b.grid = Point(0.2, 0.2);
b.gridOn_(true);

// show Env
b.setEnv(Env.asr(0.5,1, 0.2));

// make the first point unmoveable
(
b.setEditable(0,false);
)
::

Use shift click to select/unselect the points
code::
(
w = Window("envelope", Rect(150 , Window.screenBounds.height - 250, 400, 150)).front;
w.view.decorator = FlowLayout(w.view.bounds);

b = EnvelopeView(w, Rect(0, 0, 350, 100))
	.thumbSize_(5)
	.drawLines_(true)
	.fillColor_(Color.green)
	.selectionColor_(Color.red)
	.drawRects_(true)
	.value_([(0.0, 0.1 .. 1.0), (0.0, 0.1 .. 1.0)])
	.setEditable(0,false);
)

(
r = Routine({
	var j = 0;
	20.do({ arg i;
		b.selectIndex((b.size - 1).rand.abs);
		0.1.wait;
		b.x_(1.0.rand.abs);
		b.y_(1.0.rand.abs);
	});
	b.selectIndex(-1);
});
AppClock.play(r);
)
::

Show boxes with a string in it:
code::
(
a = Window("text-boxes", Rect(200 , 450, 450, 450));
a.view.decorator = FlowLayout(a.view.bounds);

b = EnvelopeView(a, Rect(0, 0, 440, 440))
	.thumbWidth_(60.0)
	.thumbHeight_(15.0)
	.drawLines_(true)
	.drawRects_(true)
	.selectionColor_(Color.red)
	.value_([[0.1, 0.4, 0.5, 0.3], [0.1, 0.2, 0.9, 0.7]]);
4.do({arg i;
	b.setString(i, ["this", "is", "so much", "fun"].at(i));
	b.setFillColor(i,[Color.yellow, Color.white, Color.green].choose);
});
a.front;
)

(
b.connect(3, [2.0,0.0,1.0]); // the text objects can be connected
b.connect(0,[2.0,3.0,1.0]);
)
::


class:: EnvirGui
summary:: display the contents of an environment for editing
categories:: JITLib>GUI, Live Coding
related:: Classes/EZText, Classes/TdefGui, Classes/PdefGui

description::
EnvirGui displays all keys and values of an environment, so one can change them flexibly. Single number get displayed with an link::Classes/EZSlider::, pairs of numbers with an link::Classes/EZRanger::, and anything else is shown as an link::Classes/EZText:: (a text field).

ClassMethods::

subsection::Creation

method::new
create a new EnvirGui
NdefParamGui
code::
// simple example
g = EnvirGui.new(nil, 5);    // empty with 5 slots
g.parent.alwaysOnTop_(true);
g.object_((a: 1, b: \werty, freq: [500, 2000]));	// put some things in
g.envir.put(\karl1, \otto1);				// one more
g.envir.put(\caesar, \julius);				// one more

g.envir.putAll((b: -12, r: 1, s: 2, t: 3, u: 4, v: 5))

g.object_((x: 2));	// put another object in

g.envir.putAll((b: -12, r: 1, s: 2, t: 3, u: 4, v: 5))

g.envir.removeAt(\b)
g.envir.removeAt(\r)
g.envir.removeAt(\s)
g.envir.removeAt(\t)
g.envir.removeAt(\u)
g.envir.removeAt(\v)
g.close;
::

argument::object
the envir to display

argument::numItems
the number of items to display. If an envir is given, and no num, num is envir.size.

argument::parent
the parent view to display in; if none is given, a new window is created.

argument::bounds
the bounds within which to display; if none is given, bounds are calculated.

argument::makeSkip
flag whether to make a skipjack to manage updates of the envirgui.

argument::options
configuration options

InstanceMethods::

subsection::Instance Variables

method::numItems
how many envir items to display

method::envir
the envir displayed - actually an alias for object.

method::zone
the composite view the envirgui makes for itself


method::paramViews
the paramViews that display the values:
list::
## Single numbers appear in an link::Classes/EZSlider::,
## pairs of numbers will be shown in an link::Classes/EZRanger::,
## all other values are shown as compileStrings in an link::Classes/EZText::.
::
See link::Classes/ParamView:: for details.

method::specs
a local dictionary of the specs used for display ranges of numerical parameters by the paramViews of this envirgui. See the link::#-getSpec:: method for details.

method::editKeys
the keys of the currently displayed items in the dict.

method::keysRotation
if the size of envir exceeds numItems, the keys displayed can be rotated: e.g. with 10 keys displayed on 5 paramViews, keysRotation 0 means show keys (0..4), keysRotation 2 means show keys (2..6), etc.

strong::gui elements present if requested in options::
method:: docBut, knowBut, parentBut, protoBut

subsection::Some Methods

method::object
set the environment to show

argument::obj
can be nil, a dictionary, an environment, or an event.

code::
g = EnvirGui((freq: 120, \amp: 0.2, \pan: -0.5), 12, nil, bounds: Rect(20, 400, 220, 100));
g.object_((a: 1, b: [2, 3], c: \symbol, d: [4, 5, 6], f: { "boing".postln }))
::

method::envir
same as object_(obj)

method::name
if in its own window, set the window's name

code::
g.name_("Yoohoo");
::

method::getSpec
For editing, numerical parameters need control specs for the ranges on the gui. These can be set locally in the EnvirGui, or global specs will be looked up. If no local or global specs exist for that parameter name, getSpec makes a usable guess for them. (With JITLibExtensions, one can also look up specs attached to an object such as a proxy.)

code::
// inline example
g = EnvirGui.new; g.parent.alwaysOnTop_(true);
g.getSpec(\freq, 400);		// \freq exists as global spec, so use that
g.object_((freq: 150));

g.getSpec(\iFrek, 500);		// no global spec, so make a new one:
				// exponential from val * 0.05 to val * 20;
g.specs;			// and keep it here
g.envir.put(\iFrek, 500);
::

argument::key
the parameter name for which to find a spec

argument::value
the current value of that param, which is used when guessing specs.

method::putSpec
add a spec for a given key, or (if it is a global key) override a global spec with a local one:

code::
// set a desired range and warp:
g.putSpec(\iFrek, [10, 1000, \exp]);
g.putSpec(\freq, [10, 1000, \exp]);
g.specs;
g.putSpec(\freq, \freq);

// specs are remembered when object changes
g.putSpec(\freq, [10, 1000, \exp]);
g.object_((freq: 200, iFrek: 20));

// if needed, clear specs by hand when switching objects
g.specs.clear; g.object_((freq: 200, iFrek: 20));

g.close
::

strong:: Keys with technical names can be replaced in the display with clearer names:
method:: replaceKeys
the current list of keys to replace
method:: addReplaceKey
add a key to replace and its replacer key
method:: removeReplaceKey
remove a replacer key
method:: showKeyFor
show

code::
e = (longFreq: 123, amp: 0.25);
g = EnvirGui(e); g.parent.alwaysOnTop_(true);

g.editKeys;
g.addReplaceKey(\longFreq, \freq1, [50, 500, \exp]);
g.viewForParam(\longFreq).visible_(false);
g.viewForParam(\freq1).visible_(true);

e.put(\z, 345);
e.put(\a, 34);

g.replaceKeys
g.removeReplaceKey(\longFreq)
::

method::highlight
highlight the paramview at a given index, by color and optional prefix
code::
g.highlight(0);
g.highlight(0, ">>_");
g.highlight(0, ">>_", Color.green(1, 0.6));
::

method::unhighlight
remove highlighting at an index
g.unhighlight(0);


subsection::Some internal methods

method::setByKeys
update the widgets for the current keys


method::showFields
show (num) active fields, make others invisible.

method::useRanger
set and get whether arrays of 2 number values should be displayed with EZRangers.


strong::methods that make gui elements: ::
method:: makeViews
method:: makeOptionalViews
the method that makes all views specified in the options
method:: makeNameView, makeKnowBut, makeDocBut, makeClrBut, makeProtoBut, makeParentBut
the methods that make the individual elements as specified

strong::standard JITGui methods: ::
method::accepts, setDefaults, getState, checkUpdate, updateButtons

private:: clearFields, updateViewSpecs, viewForParam

Examples::

code::
	// Setting envir variables in a Tdef:
(
Tdef(\text).set(\note, [0, 2, 7], \dur, { [0.1, 0.2, 0.4].choose }, \pan, 0, \amp, 0.1);

w = Window("EZTexts", Rect(200, 400, 304, 120)).front;
w.addFlowLayout;

TdefGui(Tdef(\text), 0, parent: w);

e = EnvirGui(Tdef(\text).envir, 4, parent: w);

Tdef(\text, { |ev|
	var mydur;
	loop {
		mydur = ev.dur;
		(note: ev.note, dur: mydur, amp: ev.amp, pan: ev.pan).postln.play;
		mydur.wait;
	}
}).play;
)

	// or equivalently, use the built-in EnvirGui in TdefGui:
TdefGui(Tdef(\text), 8);

Tdef(\text).set(\yuhu, Prand([2, 3, 5, 8, 13], inf), \magic, [\abra, \cadabra]);

Tdef(\text).clear;
Tdef(\text).envir.clear;
::


CLASS::Environment
related::Classes/Event, Classes/IdentityDictionary
categories::Collections>Unordered
summary:: A dictionary which can serve as a 'name space' for functions

DESCRIPTION::
An Environment is an IdentityDictionary with additional features that allow it to serve as a 'name space' within which functions can be defined and/or evaluated.

CLASSMETHODS::
method::stack
Maintains a stack of Environments accessed by link::#*push:: and link::#*pop::.

method::make
Creates a new Environment and sends make message.

method::use
Creates a new Environment and sends use message.

method::push
Saves link::#currentEnvironment:: on the stack.

method::pop
Restores link::#currentEnvironment:: from the stack.

INSTANCEMETHODS::

method::make
Evaluates the function within the environment, returns the environment.

method::use
Evaluates the function within the environment, returns the return value of the function.

method::push
Saves the receiver on the stack.

method::pop
Restores link::#currentEnvironment:: from the stack.

method::linkDoc
Links the environment to the current document, so that it is the currentEnvironment only when one document is in focus. See: link::Classes/Document#-envir::
argument::doc
The document to link to, defaults to the current document (link::Classes/Document#*current::). If the document has focus or no document is given, the environment is pushed immediately.

method::unlinkDoc
Uninks the environment to the current document, so that it is the currentEnvironment only when one document is in focus. See: link::Classes/Document#-envir::
argument::doc
The document to unlink from, defaults to the current document (link::Classes/Document#*current::). If the document has focus or no document is given, the environment is popped immediately.


SECTION::PseudoVariables (global variables)
These are not methods, but global variables.

warning::In general, you should not manipulate these variables directly. Instead, use the link::#-use::, link::#-push:: and link::#*pop:: methods.::

method:: currentEnvironment
determines environment used by "~" syntax, link::#valueEnvir::, and link::#valueArrayEnvir::

method:: topEnvironment
initial value of link::#currentEnvironment::. code::~environmentVariables:: placed here can be used as "global variables," as long as the topEnvironment remains the currentEnvironment.

code::
~abc = 10;  // Environment variable (acting like a global var)

currentEnvironment;  // abc is there
topEnvironment;  // and here, because...

// they are the exact same environment
currentEnvironment === topEnvironment;

// a separate environment
e = Environment.make { ~def = 20 };

e.push;  // make 'e' the currentEnvironment

~abc  // is now nil, because...

currentEnvironment;  // this is 'e' and contains only ~def
topEnvironment;  // still has ~abc

e.pop;  // return to the previous currentEnvironment

~abc  // it's back!
::

Thus, ~abc is not truly a global variable because it is inaccessible if its environment is not current.

SECTION::Related Messages

method:: valueEnvir (arg1, arg2...)
evaluates a function, looking up unspecified arguments in link::#currentEnvironment::

method:: valueArrayEnvir (argArray)
same as link::#valueEnvir::, but with arguments in an array


SECTION::Overview

subsection::topEnvironment, currentEnvironment, make and use

When SuperCollider starts, it creates an Environment that it stores in the pseudovariables link::#topEnvironment:: and link::#currentEnvironment::. The link::#topEnvironment:: provides a universally accessible collection of named values similar to the link::Classes/Interpreter:: variables a, b, c, ....

The compiler provides a shortcut syntax where ~ is a placeholder for link::#currentEnvironment::.
This makes the expression code::~myvariable;:: equivalent to code::currentEnvironment.at(\myvariable);:: and the expression code::~myvariable = 888;:: equivalent to code::currentEnvironment.put(\myvariable, 888);::

The messages link::#*make::(function) and link::#*use::(function) replace link::#currentEnvironment:: with the receiver. The message link::#*make:: is intended to be used when initializing an Environment, so it returns the Environment. The message link::#*use:: is for evaluating a functions within an Environment, so it returns the return value of the function.

For example
code::
(
a = Environment.make({
	~a = 100;
	~b = 200;
	~c = 300;
});
a.postln;
)
::
creates an environment, while
code::
a.use({
	~a + ~b + ~c
}).postln;
::
evaluates the function within that environment.

subsection::valueEnvir and valueArrayEnvir

When Functions are evaluated with link::#valueEnvir:: and link::#valueArrayEnvir:: unspecified arguments are looked up in the current Environment.
If the argument is not found in the Environment its default value is used.
code::
(
var f;

// define a function
f = { arg x, y, z; [x, y, z].postln; };

Environment.use({
	~x = 7;
	~y = 8;
	~z = 9;

	f.valueEnvir(1, 2, 3);	// all values supplied
	f.valueEnvir(1, 2);	// z is looked up in the current Environment
	f.valueEnvir(1);	// y and z are looked up in the current Environment
	f.valueEnvir;		// all arguments are looked up in the current Environment
	f.valueEnvir(z: 1);	// x and y are looked up in the current Environment
});
)
::
Now here is how this can be used with an instrument function. Environments allow you to define instruments without having to worry about argument ordering conflicts. Even though the three functions below have the freq, amp and pan args declared in different orders it does not matter, because link::#valueEnvir:: looks them up in the environment.
code::
s.boot;

(
var orc;
orc = Environment.make {
	~a = { arg freq, amp, pan;
		Pan2.ar(SinOsc.ar(freq), pan, amp);
	};
	~b = { arg amp, pan, freq;
		Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);
	};
	~c = { arg pan, freq, amp;
		Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 2, 0.1), pan, amp * 2);
	};
	~orc = [~a, ~b, ~c];
};
// 'reverb'
{ var in; in = In.ar(0, 2); CombN.ar(in, 0.2, 0.2, 3, 1, in); }.play(addAction: \addToTail);

{ loop({
	orc.use({
			// set values in the environment
		~freq = exprand(80, 600);
		~amp = 0.1;
		~pan = 1.0.rand2;

			// call a randomly chosen instrument function
			// with values from the environment

		 x = { ~orc.choose.valueEnvir; }.play(fadeTime: 0.2, addAction: \addToHead);
		 0.2.wait;
		 x.release(0.2);
	});
}) }.fork;

)
::

subsection::Environments and asynchronous functions

Local variables declared in functions, and class and instance variables, use lexical scope. That is, the context in which they are understood depends on where the declaration is read during compilation. Asynchronous functions -- any function that will execute outside (later than) the current execution flow -- carry their lexically scoped variables with them.
code::
f = { var a = "got it"; { a.postln }.defer(0.5) };
f.value;
::
Asynchronous functions include any scheduled function, responder function associated with OSCFunc, MIDIFunc, HID or GUI action functions, or actions used in server messaging (such as Buffer.read, Buffer or Bus .get, and so on).

Environment variables have dynamic scope; they are read from whichever environment is current, whether or not it was the current environment when the function was declared. For instance, the following fails because e is no longer the current environment when the deferred function wakes up.
code::
e = (a: "got it", f: { { ~a.postln }.defer(0.5) });
e.use { e.f };
::
link::Classes/Function#-inEnvir#Function's inEnvir:: method attaches a function to a specific environment. If no environment is given, the current environment at the time of executing inEnvir is the default.
code::
e = (a: "got it", f: { { ~a.postln }.inEnvir.defer(0.5) });
e.use { e.f };
::

subsection::Using Environments as object prototypes

Environment's strong::know:: variable holds a link::Classes/Boolean:: value controlling whether the Environment may be used as an object prototype or not. If strong::know:: is true, any messages sent to the Environment that it does not already understand will be relayed into items in the Environment. (If false, not-understood messages will produce a standard "does not understand" error message.)

The default for know is false for Environment, and true for link::Classes/Event::.
code::
e = Environment[
	'someVariable' -> 5,
	'printMe' -> { |self, string| string.postln }
];

e.know = true;
::
More typically, Events are used to define such prototypes because the syntax is simpler.
code::
e = (someVariable: 5, printMe: { |self, string| string.postln });
::


An object prototype looks up the method selector in the Environment to decide what to do.

Most objects are simply returned -- the method call behaves like a getter for any other object.
code::
e.someVariable;
// same as
e.at('someVariable');
e['someVariable'];
::
If the selector is a setter, e.g. strong::someVariable_(value):: or strong::someVariable = value::, the new value is put into the Environment.
code::
e.someVariable = 10;
// same as
e.put('someVariable', 10);
::
If the Environment item is a function, it is evaluated as if it were a method definition. The first argument passed into the function is the Environment that holds the function; arguments to the method call follow as the second, third etc. arguments passed into the function.
code::
e.printMe("Oh hai wrldz");
// same as
e['printMe'].value(e, "Oh hai wrldz");
::
The function may access objects in the Environment using the first function argument.
code::
e.mul2 = { |z| z.someVariable * 2 };
e.mul2;
::
Environment variables inside a function will refer to the currently active environment -- not to the Environment being addressed. This is to allow the object prototype to interact with the link::#currentEnvironment::.
code::
e.mul2 = { |z| ~someVariable * 2 };
// this will throw an error because ~someVariable is nil in the currentEnvironment
e.mul2;
::
If you wish to access objects in the environment using environment variable syntax, 'use' the environment within the function.
code::
e.mul2 = { |z| z.use { ~someVariable * 2 } };
e.mul2;
::

note::
Be careful to avoid method names that are defined in any of the superclasses of environment (or event). Object prototyping works by trapping method selectors that are not already defined as class library methods. Using a generic method selector such as 'stop' or 'reset' will cause the corresponding class library method to respond, and the items in the environment will never be checked.

Assigning a value into an environment using a setter -- strong::name_():: or strong::.name = ...:: -- posts a warning message if the name is already defined in the class library.
code::
e.reset = { "My reset function".postln };

// prints:
WARNING:
'reset' exists a method name, so you can't use it as pseudo-method.

// this does NOT execute the reset function above
// because Object:reset responds
e.reset;
::
::


class:: EnvironmentRedirect
summary:: base class for environment redirects
categories:: JITLib>Environments, Collections>Unordered, Live Coding
related:: Classes/Environment

description::
Environment that redirects access (strong::put::) and assignment (strong::at::). It is used as a base class for redirecting Environments. For example uses, see link::Classes/LazyEnvir:: and link::Classes/ProxySpace::.

ClassMethods::

method::new
Create new environment redirect, if envir is given, it is used as a basis.

subsection:: replacing Environment class methods

EnvironmentRedirect implements some of the interface of link::Classes/Environment::

method::push, pop, make, use

InstanceMethods::

method::envir
return or replace the source environment
code::
e = LazyEnvir.new;
e.put(\x, 9);
e.envir; // look into the envir itself: for a LazyEnvir it contains Maybe as placeholders
::

subsection::redirecting objects

Overriding these methods, one can redirect where objects go when they are assigned to the space. This is done for example in link::Classes/LazyEnvir:: and link::Classes/ProxySpace::.

method::at, put, localPut, removeAt

method::dispatch
A function or object that is called when the environment is modified. The key and the changed object are passed as arguments.
code::
e = LazyEnvir.new;
e.dispatch = { |key, val| [key, val].postln };
e.put(\x, 9);
::

method::add
add an association

subsection:: replacing Environment instance methods

EnvironmentRedirect implements some of the interface of link::Classes/Environment::, which it can replace where needed.

method:: push, pop, clear, choose
method:: make, use
method:: do, keysValuesDo, sortedKeysValuesDo
method:: keysValuesArrayDo
method:: findKeyForValue
method:: know
method:: doesNotUnderstand


section::Networking

EnvironmentRedirect and its subclasses can be used to dispatch assignment over a network. To do this, a dispatch function can be supplied - see Public in strong::JITLibExtensions:: quark.


class::Error
categories::Core
summary::superclass of all Errors

description::
Error and its subclasses separate different types of error is that can occur in the SuperCollider program into distinct classes, so that they can be reported differently to the user.

Anywhere that an error must be reported to the user and execution must stop, an error object must be created and thrown.
code::
(
var file, path = "betcha-this-file-doesnt-exist.txt";
if((file = File(path, "r")).isOpen) {
	"File is % bytes long.\n".postf(file.length);
	file.close;
} {
	Error("File % could not be opened.".format(path)).throw;
};
)
::

For backward compatibility, code::.die():: creates the error for you.

code::
"Keyboard not found. Press F1 to Resume.".die;
::

Throwing an error object gives the caller the opportunity to catch, and possibly recover from, the error. See the Exception help file for more information about this.

subsection::Error hierarchy

The following error classes exist in the main library.

list::
## link::Classes/Error::
## link::Classes/DeprecatedError:: : this method is no longer supported.
## link::Classes/MethodError:: : generic error occurring within a method.
## link::Classes/DoesNotUnderstandError:: : the receiver does not understand the method name.
## link::Classes/BinaryOpFailureError:: : a binary operator cannot work with the operand classes.
## link::Classes/ImmutableError:: : attempted to modify an immutable object.
## link::Classes/MustBeBooleanError:: : a test (in if or while) returned a non-Boolean value.
## link::Classes/NotYetImplementedError:: : the method name exists, but isn't implemented yet.
## link::Classes/OutOfContextReturnError:: : a method return by ^ took place outside of a method.
## link::Classes/PrimitiveFailedError:: : an error occurred inside a primitive.
## link::Classes/ShouldNotImplementError:: : you called a method on a class that has no business implementing it.
## link::Classes/SubclassResponsibilityError:: : you called a method on an abstract class.
::

The exact inheritance tree looks like this:
classtree::Error



CLASS::Event
summary::an environment that represents an action
related::Classes/Pattern, Classes/Environment, Classes/IdentityDictionary
categories::Collections>Unordered, Streams-Patterns-Events>Events

DESCRIPTION::
An Event specifies an action to be taken in response to a link::#-play:: message. Its key/value pairs specify the parameters of that action. Event inherits most of its methods from its superclasses, especially from link::Classes/Dictionary::. For the usage and meaning of the code::parent:: and code::proto:: events, see link::Classes/IdentityDictionary::.

code::
a = (x: 6, y: 7, play: { (~x * ~y).postln });
a.play; // returns 6 * 7
::

The class Event provides a large library of default event instances and play functions, e.g. for pitch. By default, the play function, when an event is played, its link::#*addEventType#type:: is used to select a function and a parent event (by default, this is type code::\note::).

code::
(freq: 761).play // play a default synth sound with 761 Hz
::



CLASSMETHODS::

private::initClass

subsection::Class variables

method::parentEvents
An extendible IdentityDictionary of useful parent events.

method::partialEvents
An extendible IdentityDictionary of Events that define the default values and functions for different aspects of note generation (timing, volume, pitch, server to use, etc).

subsection::Creation methods

method::new
create an event with initial size strong::n::.
argument::n
Initial size.
argument::proto
May be provided as another event which is used to override keys in the event.
argument::parent
May be provided as another event which is used to provide default keys for the event without modifying it.
argument::know
If strong::know:: is set to link::Classes/True::, the event will respond to appropriate message calls. See link::Classes/Environment:: for more details.

method::default
Returns an empty event with link::#defaultParentEvent:: as parent.

method::silent
Returns an event that describes a pause of strong::dur:: duration.



method::addEventType
Event types define alternate play functions and parent events that are selected by the value of strong::~type::.


argument::type
A name (usually a symbol) for the event type, which can be used to select it

argument::func
A function which optionally takes the server as a first argument

argument::parentEvent
An event with default values which is used to override the parent event. If code::parentEvent:: in turn has no parent, its default parent event is set.

discussion::
code::
(
Event.addEventType(\happyEvent, {
	"I am so happy to be silent sometimes, says %.\n".postf(~who)
})
)
(type: \happyEvent, who: "Alice").play;

// using protoEvent
(
Event.addEventType(\happyEvent, {
	"I am so happy to be silent sometimes, says %.\n".postf(~who)
}, (who: "Alice"))
)

(type: \happyEvent).play; // use default
(type: \happyEvent, who: "Eve").play; // overrride default

// in a Pbind:
Pbind(\type, \happyEvent, \who, Prand(["Alice", "Bob", "Eve"], inf), \dur, Pwhite(0.1, 1.0, inf)).play;

// parent event type for indirect calls:
Event.addEventType(\test, { ("x was" + ~x.value).postln }, (x: { ~y + 1 }, y: 0));

(type: \test).play; // use defaults
(type: \test, \y: 7).play; // set the value that x refers to
(type: \test, \x: 10).play; // override x by a different one


// It is possible to reuse some of another event type's functionality:
(
Event.addEventType(\happyEvent, { |server|
	~octave = [5, 6, 7]; // always play three octaves
	~detune = 10.0.rand2; // always play a bit out of tune
	~type = \note; // now set type to a different one
	currentEnvironment.play;
});

Pbind(\type, \happyEvent, \degree, Pseq([0, 1, 2, 3, 4, 4, 5, 5, 5, 5, 4, 2, 3, 2, 3, 1], inf), \dur, Pwhite(0.1, 1.0, inf)).play;
);

::

The event types and parent events are stored in a dictionary of the Event class, namely in code::partialEvents.playerEvent:::

code::
// eventTypes
Event.partialEvents.playerEvent.eventTypes
// parentTypes
Event.partialEvents.playerEvent.parentTypes
::


method::addParentType
Define an alternative parent that is chosen on the basis of strong::~type::. It allows you to change the defaults of an existing event type function.

argument::type
A name (usually a symbol) for the event type, which can be used to select it

argument::parentEvent
An event with default values which is used to override the parent event. If code::parentEvent:: in turn has no parent, its default parent event is set.

discussion::
code::
Pbind(\type, \note, \degree, Pseq([0, 1, 2, 3, 4, 4, 5, 5, 5, 5, 4, 2, 3, 2, 3, 1], inf), \dur, 0.08).play;
Event.addParentType(\note, (mtranspose: 2, root:5)); // set different defaults

// note is the default type, this will also pick up the information:
Pbind(\degree, Pseq([0, 1, 2, 3, 4, 4, 5, 5, 5, 5, 4, 2, 3, 2, 3, 1], inf), \dur, 0.08).play;

::

method::removeEventType
Remove an event type function from the collection. If there is an associated event type parent, this will be removed also.

argument::type
A name (usually a symbol) for the event type.

method::removeParentType
Remove a parent event associated with an event type.

argument::type
A name (usually a symbol) for the event type.


method::makeDefaultSynthDef
This method is called in order to build the default SynthDef, which is stored under the key strong::\default::
code::
SynthDef(\default, { |out| Out.ar(out, Line.kr(0.3, 0, 0.5) * SinOsc.ar(Rand(300, 500.0)) ) }).add; // overwrite default
(freq: 600).play;
Event.makeDefaultSynthDef; // reset default
(freq: 600).play;
::

INSTANCEMETHODS::

method::play
Play the event. This evaluates the function at strong::\play::.
code::
(freq: 800).play;
(play: {  "I rather do something else: ".post; ~x.postln; }, x: 800.rand).play;
::

method::delta
Returns the inter onset time - the time delay until the next event in a sequence. This usually depends on strong::\dur:: and strong::\stretch::, but may be overridden by specifying strong::\delta:: directly.
code::
Pn((dur: 2, freq:8000)).play;
::

method::next
Combines an event given in the argument with the current event. This is used to enable events to be composed.
code::
(a: 6, b: 7).next((c: 100));
::

copymethod:: Dictionary -embedInStream

method::playAndDelta
Used by link::Classes/EventStreamPlayer:: to play Events and obtain a time increment.

method::isRest
Returns strong::true:: if the event will be played as a rest, and strong::false:: otherwise. See link::Classes/Rest:: for a more complete discussion of rests in event patterns.

method::asUGenInput
Calls link::#-asControlInput::.

method::asControlInput
Enables events to represent the server resources they created in an Event.

subsection::Methods that allow Events to provide user control for Synths on Groups

method::synth
Makes the event a control interface to the resultant link::Classes/Synth:: when played.

method::group
Makes the event a control interface to the resultant link::Classes/Group:: when played. This is experimental, does not work consistently yet.

method::stop
Free the link::Classes/Synth:: or link::Classes/Group::.

method::pause
Pause the link::Classes/Synth:: or link::Classes/Group::.

method::resume
Resume the link::Classes/Synth:: or link::Classes/Group::.

method::release
Release the link::Classes/Synth:: or link::Classes/Group::.

method::set
Set a control value in the link::Classes/Synth:: or link::Classes/Group::.
(key1, val1, ....)
code::
a = (note: 2).play;
a.set(\freq, 700);
a.release;
::


SECTION::Basic Usage

Events can be written as a series of key value pairs enclosed in parentheses. Empty parentheses will create an empty event. They may be also used for object prototyping - see link::Classes/Environment:: for more details.

subsection::Event as a name space for keeping objects

Because of this simple syntax, Events are often used as name space for keeping objects:
code::
// using an event to store values
q = (n: 10, x: [1, 2, 3]);
q[\y] = q[\x] * q[\n];	// similar to ~y = ~x * ~n, but in a separate name space
q.y = q.x * q.n;	// shorter way to do the same (pseudo-methods)
q.y;			// [ 100, 200, 300 ]
::

subsection::Event for specifying different things to happen

Event provides a link::#defaultParentEvent:: that defines a variety of different event types and provides a complete set of default key/value pairs for each type. The type is determined by the value of the key strong::\type:: which defaults to strong::\note::. Note events create synths on the server.
code::
( ).play;			// the default note
(freq: 500, pan: -1) .play;	// 500 Hz, panned left
(play: { ~what.postln }, what: "hello happening").play;	// something else
::
Per default, the play message derives its behaviour from the link::#defaultParentEvent::, which provides many default values, such as default instrument (\default), note (0), legato (0.8) and so on. Depending on the event type, these may differ completely and need not even represent a sound.

subsection::Events and SynthDefs

The key used to select what synthdef is to be played is strong::\instrument::. In order to use a link::Classes/SynthDef:: with an Event, send it an strong::add:: message. This creates a description of the SynthDef that the event can consult to determine its control names. The values of these names in the event are used when the event is played. (See link::Classes/SynthDesc:: for details.)
code::
(
SynthDef(\pm, { |out=0, freq=440, amp=0.1, pan=0, gate=1, ratio = 1, index = 1, ar = 0.1, dr = 0.1|
	var z;
	z = LPF.ar(
		PMOsc.ar(freq, freq * ratio, Linen.kr(gate, ar,index, dr), 0, 0.3),
		XLine.kr(Rand(4000, 5000), Rand(2500, 3200), 1)
	) * Linen.kr(gate, 0.01, 0.7, dr, 2);
	OffsetOut.ar(out, Pan2.ar(z, pan, amp));
}).add;
);

(instrument: \pm).play;

(instrument: \pm, ratio: 3.42, index: 12, freq: 150, ar: 8, dr: 3, sustain: 10).play;
::

note::
The use of link::Classes/OffsetOut:: in the SynthDef prevents irregularities that can result from the interaction of the timing of a sequence of notes and the control rate of the Server.
::

subsection::Multi-channel Expansion

If a key relevant to the action is assigned an link::Classes/Array::, the action is repeated on each element of the array:
code::
(degree: (0..12)).play;		// a diatonic cluster
::
If several keys are assigned arrays, the action is repeated for each element of the largest array.
Smaller arrays are rotated through repeatedly. Here are some examples:
code::
// every other note of the diatonic cluster: stacked thirds
(degree: (0..12), amp: [0, 0.1]).play;

// every other note of the semitone cluster: a wholetone cluster again
(note: (0..12), amp: [0, 0.1]).play;

// every third note of the semitone cluster: a diminished chord
(note: (0..12), amp: [0, 0, 0.1]).play;

// the same with different sustain times
(note: (0..12), amp: [0, 0, 0.1], sustain:[0.1, 0.3, 1.3, 2.5]).play;

// timingOffset gives a tempo-relative offset time to each synth
(instrument: \pm, ratio: [2.3, 4.5, 1.7], timingOffset: [0, 1.2, 3], sustain: [0.2, 2, 1]).play;
::

In the \note event, all keys multichannel expand apart from: \instrument, \dur, \delta, \strum.

subsection::Arrayed Arguments

It is possible to assign an array to one of a link::Classes/SynthDef::'s control names. For example:
code::
(
SynthDef(\test, {
	| out = 0, amp = 0.01, freq = #[300,400,400], pan, gate = 1 |
	var audio, env;
	audio = Mix.ar(Pulse.ar(freq, 0.5));	// this is a mixture of three oscillators
	env = Linen.kr(gate, susLevel: amp , doneAction: Done.freeSelf);
	audio = audio * env;
	OffsetOut.ar(out, audio);
}).add;
)
::
Within an event, arrayed arguments of this sort must be enclosed within an additional array to distinguish them from arguments intended for multi-channel expansion.
code::
// one synth, use enclosing array to prevent multi-channel expansion
(instrument: \test, note: [[0, 2, 4]]).play;

// two synths
(instrument: \test, note: [[0, 2, 4], [6, 8, 10]]).play;
::

subsection::Events and Patterns

Events are closely integrated with the Patterns library. Different patterns can be bound to different keys (or collections of keys) to specify the resultant music. See the help files link::Classes/Pattern:: and link::Classes/Pbind:: and the tutorials link::Tutorials/Streams-Patterns-Events4:: and link::Tutorials/Streams-Patterns-Events5:: for more details on Patterns.

Patterns that return events may be played on a clock: dur specifies the time between two subsequent events.
code::
// Pseq returns one item in the list after the other
(
Pseq([
	(note: 2, sustain: 1, dur: 1.5),
	(note: [5, 7], sustain: 0.5, dur: 0.8),
	(note: [2, 6], sustain: 1, dur: 0.8)
]).play;
)

// Pbind binds parameters to events:
(
Pbind(
	\note, Pseq([2, [5, 7], [2, 6]]),
	\sustain, Pseq([1, 0.5, 1]),
	\dur, Pseq([1.5, 0.8, 0.8])
).play;
)

// per-event timing may be specified:
(
Pbind(
	\note, Pseq([[0, 9], [5, 7], [2, 6]], inf),
	\sustain, Pseq([1, 0.5, 1], inf),
	\dur, Pseq([1.5, 0.8, 0.8], inf),
	\timingOffset, Pseq([[0, 0.3], [0, 0.01]], inf)
).play;
)
::

Here is an example that illustrates some more of the keys defined by the link::#defaultParentEvent::. Note that it is equivalent to write code::Pbind(\key, val, ...):: and code::Pbind(*[key: val, ...])::.
code::
(
Pbind(*[
	stepsPerOctave:	Pstep(Pseq((2..12).mirror, inf),12),	// 3 - 12 tone e.t. scales
	note:		Pseq((0..12).mirror, inf),		// play full notes up and down
	ctranspose:	Pwhite(-0.2, 0.2),			// detune up to +-20 cents
	detune:		Pwhite(-1.0, 1.0),			// detune up to 1 Hz
	sustain:	Prand([0.2, 0.2, 0.2, 4], inf), 	// notes last 0.2 or 4 seconds
				// 1 in 6 chance waits 0.8 seconds:
	dur:		Prand([0.2, 0.2, 0.2, 0.2, 0.2, 0.8], inf),
	db:		Pstep(Pseq([-15, -25, -20, -25], inf), 0.8)// 4 beat accent structure
]).play;
)
::

subsection::Event's play method

When an Event (or any other link::Classes/Environment::) receives a code::use(function):: message, it sets itself to be currentEnvironment, evaluates the function, and restores the original value of currentEnvironment. This allows the function to access and alter the contents of the event using the following shortcuts:
code::~keyName:: which is equivalent to	code::currentEnvironment.at(keyName):: and
code::~keyName = value:: which is equivalent to code::currentEnvironment.put(keyName, value)::.

We will write code::~keyName:: whenever referring to the value stored at the key keyName in the event.

Here is the definition of Event's play method:
code::
play {
	if (parent.isNil) { parent = defaultParentEvent };
	this.use { ~play.value };
}
::
Thus we can see that the link::#defaultParentEvent:: is used unless otherwise specified and the function stored in code::~play:: is executed in the context of the Event. It can be replaced in a given event for different behavior:
code::
(a: 6, b: 7, play: { (~a * ~b).postln }).play;
::

subsection::Timing control with Event's delta method

Events also specify timing within a link::Classes/Pattern::. Event's code::delta:: method returns the value of code::~delta:: or, if that is nil, code::~dur * ~stretch::.

Patterns are played by link::Classes/TempoClock::s, which have their own tempo controls. This tempo which can be controlled through code::~tempo:: in the event. Changes to the tempo affect everything else scheduled by the TempoClock, so code::tempo:: provides a global tempo control while code::stretch:: provides a control limited to the one pattern.

subsection::The structure of defaultParentEvent

method::defaultParentEvent
The default event used in most cases. This is a private class variable. See link::#*default::.

The default parent event provides the collection of default values and functions needed for the different uses of an Event. These defaults are defined in partialEvents that specify distinct aspects of default parent Event:
code::
playerEvent	// defines ~play, ~type and ~eventTypes
serverEvent	// server, group, addAction
durEvent	// duration, tempo and articulation
ampEvent	// volume, pan, MIDI velocity
pitchEvent	// pitch specified in many different ways
bufferEvent	// buffers on the server
midiEvent	// defines the sending of midi messages
::

subsection::Useful keys for notes

Using Events is largely a matter of overwriting keys. Here is a list of keys useful for defining notes with their default values, grouped by the partialEvent within which they are defined.


list::

## strong::serverEvent keys:::

The keys in serverEvent provide the values needed to identify the server to be used and where in the tree
of nodes to place the group.
code::
server:		nil,		// if nil, Server.default is used
instrument:	\default,	// this is the name of a SynthDef
group:		1,		// nodeID of group on the server
				// when adding before or after a node
				// this could be the nodeID of a synth instead of a group
addAction:	0,		// 0, 1, 2, 3 or \addToHead, \addToTail, \addBefore, \addAfter
out:		0,		// usually an output bus number, but depends on the SynthDef
::

## strong::ampEvent keys:::

The ampEvent determines volume. Notice that code::~amp:: is a function that determines its value from code::~db::. The user can choose to specify the amplitude directly by overwriting code::~amp:: or to use a decibel specification by overwriting code::~db::.
code::
amp:		#{ ~db.dbamp },	// the amplitude
db:		-20.0,		// the above described in decibel
pan:		0.0,		// pan position: -1 left 1 right
velocity:	64		// midi velocity
trig:		0.5		// trigger value
::



## strong::durEvent keys:::

The durEvent has keys that determine the timing of a note. Notice that code::~sustain:: is a function that uses code::~legato:: to determine the sustain. Like code::~amp:: this can be overwritten to set the sustain directly.
code::
tempo:			nil,	// changes tempo of a TempoClock
dur:			1.0,	// time until next note (inter-onset time)
stretch:		1.0,	// inverse of tempo control, specific to the Event's stream
legato:			0.8,	// ratio of sustain to duration
sustain:		#{ ~dur * ~legato * ~stretch },
lag:			0.0,	// delay (in seconds) relative to current time position of Stream
timingOffset:		0.0,	// delay (in beats) relative to current time position of Stream
strum:			0.0	// "breaks" a chord. May be negative, playing the chord backward
strumEndsTogether:	false	// if true, the strummed notes end together (with gated synths)
sendGate:		nil  // override: true == always send a gate-release message; false == never send
::



## strong::pitchEvent keys:::

The pitchEvent has the most complex system of functions that provide a variety of useful ways to determine pitch:
code::
freq (->440)		// determines the pitch directly as a frequency in Hertz
midinote (-> 60)	// determines pitch as a fractional MIDI note (69 -> 440)
note (-> 0)		// determines pitch as a scale degree in an ~stepsPerOctave equal tempered scale
degree: 0		// determines pitch as a scale degree within the scale ~scale
::
The event also provides a set of transposition keys:
code::
mtranspose:	0	// modal transposition of degree within a scale
root:		0.0	// transposes root of the scale
gtranspose:	0.0	// gamut transposition within the ~stepsPerOctave equal tempered scale
ctranspose:	0.0	// chromatic transposition within the 12 tone equal tempered scale
harmonic:	1.0	// multiplies the frequency determined by ~midinote, typically to an overtone
detune:		0.0	// directly offsets frequency by adding this value
midiToCps		// a function taking a MIDI note number and turning it into frequency
			// Normally this is _.midicps, but you can override it for non-ET tunings

mtranspose:	0,	// modal transposition of degree
gtranspose:	0.0	// gamut transposition of note within a ~stepsPerOctave e.t. scale
ctranspose:	0.0	// chromatic transposition of midinote within 12 tone e.t. scale

octave:		5.0	// octave offest of note
root:		0.0	// root of the scale
degree:		0	// degree in scale
scale:		#[0, 2, 4, 5, 7, 9, 11]	// diatonic major scale
stepsPerOctave:	12.0	//
detune:		0.0,	// detune in Hertz
harmonic:	1.0	// harmonic ratio
octaveRatio:	2.0	// size of the octave (can be used with the Scale class)
::
The event calculates with these keys to derive parameters needed for the synth:
code::
note: #{	// note is the note in halftone steps from the root
	(~degree + ~mtranspose).degreeToKey(~scale, ~stepsPerOctave);
}
midinote: #{	// midinote is the midinote (continuous intermediate values)
	((~note.value + ~gtranspose + ~root) / ~stepsPerOctave + ~octave) * 12.0;
}
freq: #{
	(~midinote.value + ~ctranspose).midicps * ~harmonic;
}
detunedFreq: #{	// finally sent as "freq" to the synth as a parameter, if given
	~freq.value + ~detune
}
::

IMAGE::Event-default-note.png::


::

subsection::Event types

An Event responds to a play message by evaluating code::~play:: in the event, which by default uses the event's type to define the action to be performed. See link::Overviews/Event_types::.


class:: EventPatternProxy
summary:: event stream reference
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdef

description::
Keeps a reference to a stream that can be replaced while in use.

ClassMethods::

method::new
create a new instance with a pattern (the source). The pattern should be an emphasis::event pattern:: (see link::Classes/Pdef::)

method::default
a default source, if none is given. the default is a Pbind with resting notes of 1.0 beat duration.

method::defaultQuant
set the default quantization value for the class.

InstanceMethods::

method::source
set the source (a pattern). If a quantization is given, schedule this change to the next beat ( strong::pattern_::(..) is equivalent)

method::clear
set the source to nil and stop playing

method::clock
get or set the instance's default clock, used by link::#-play:: if no other clock is specified. Defaults to TempoClock.default.

method::quant
get or set the quantization value. can be an array [quant, phase, offset, outset]

method::fadeTime
when the synthdefs that are used contain an code::\amp:: control, the patterns are replaced by crossfading the previous with the new over this time (in beats)

method::envir
provide a default event for the Pdef. It is used to filter the incoming stream before it is passed to the source pattern. This is similar to link::Classes/NodeProxy#-nodeMap::. When set for the first time, the pattern is rebuilt.

method::set
set arguments in the default event. If there is none, it is created and the pattern is rebuilt.

subsection::a) using as stream reference

method::embedInStream
Given a link::Classes/Stream:: like e.g. link::Classes/Routine::, yield all values from the pattern in the proxy before continuing. One pattern proxy can be used to produce values for any number of independent streams.

argument::inval
The inval is an link::Classes/Event:: and is passed into all substreams. It can be used to control how they behave from the outside.

argument::embed
See link::Classes/Object#-streamArg:: for explanation.

argument::default
Replacement for code::nil:: outputs of the source pattern. One use case is link::#-endless::.

code::
a = EventPatternProxy.new;
a.source = Pbind(\freq, Pgeom(100, Pwhite(1.01, 1.2), 4));
r = Routine { |inval| loop { a.embedInStream(inval) }; };
r.nextN(12, ()); // the next 12 values from r
a.source = Pbind(\freq, Pgeom([100, 200], Pwhite(1.01, 1.2), 4));// replace the source
r.nextN(12, ()); // the next 12 values from r
::

subsection::b) using as EventStreamPlayer

method::play
starts the EventPatternProxy and creates a player. if you want to play multiple instances, use link::#-fork::.

argument::argClock
play on a certain clock, e.g. a link::Classes/TempoClock::. If nil uses this instance's link::#-clock::, which in turn defaults to TempoClock.default.

argument::protoEvent
an event to be used as a first input to the chain

argument::quant
can be an array of [quant, phase, offset, outset], or an instance of link::Classes/Quant::.

argument::doReset
if set to true, play will restart the stream if already running (a link::Classes/Boolean::).

code::
// using a protoEvent
Pdef(\x, Pbind(\dur, 0.1));
Pdef(\x).trace.play(protoEvent: (freq: 1000));
::

code::
// using a different clock: here a Scheduler
Pdef(\x, Pbind(\dur, Pwhite(0.1, 0.2, inf), \count, Pseries()));
a = Scheduler(TempoClock.default);
Pdef(\x).trace.play(a);
a.advance(0.2);
::

method::stop
stops the player

method::player
the current player (if the Pdef is simply used in other streams this is code::nil::)

method::pause, resume, reset
perform player method

method::isPlaying
returns true if Pdef is running. if a Pdef is playing and its stream ends, it will schedule a stream for playing as soon as a new one is assigned to it.


Examples::

subsection::a) embedding EventPatternProxy in streams

code::
(
SynthDef("Pdefhelp", {
	arg out, freq, sustain=1, amp=0.1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction: Done.freeSelf);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));
}).add;
)
s.boot;

#a, b, c, m = { EventPatternProxy.new } ! 4;

m.play;
m.source = Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, 16, \legato, 0.1);

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3]));
b.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8]));
c.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2));

x = Pseq([a, b, c], inf).play;


c.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[4, 3, 1, 2]*3));


// infinite loops are scheduled (to ths clock's next beat by default) and released:

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pseq(#[0, 5, 4, 3, 2], inf));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5, 4, 3] + 1, 1));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3] - 1, 1));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5] - 1, 1));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pshuf(#[0, 5, 4, 3, 2], inf));

x.stop;
m.stop;

// EventPatternProxy can be used in multiple patterns

(
x = Ppar([
	Pbindf(Pn(a, inf),
		\gtranspose, Pdup(8, Pseq(#[0, 2, 0, 3],inf))
	),
	Pbindf(Pn(a, inf),
		\gtranspose, Pdup(8, Pseq(#[7, 4, 0, 3],inf)),
		\dur, 0.6
	),
	Pbindf(Pn(a, inf),
		\degree, Pseq(#[0, 5, 4, 3, 2, 3, 2], 1)
	)
]).play;
)

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1, 0, 1, 2], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1b, 1, 2b, 2, 3, 4b, 4, 5], inf));

a.set(\detune, -50); // set environment
a.set(\detune, 0);

x.stop;
::

subsection::b) playing EventPatternProxy

code::
s.boot;

(
// load a synthdef
SynthDef("gpdef", {
	arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
	var env;
	env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf) * amp;
	Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
}).add;
)

#x, y = {EventPatternProxy.new} ! 2;

x.play; // play them. A silent resting pattern is used.
y.play;

// assign various patterns to it:

x.source = Pbind(\dur, 0.25, \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6], inf), \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]+1, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-1, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b]-2, inf), \instrument, \gpdef);

// using fadeTime:

y.fadeTime = 8.0;
y.source = Pbind(\dur, 0.125, \degree, Pseq([3, 4, 5b, 6]+4.rand, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-2, inf), \instrument, \gpdef);

(
x.source = Pbind(
	\dur, 1 / 6,
	\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1) - 5, 6]+1, inf),
	\instrument, \gpdef
)
)

(
x.source = Pbind(
	\dur, 0.25,
	\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1), 6], inf),
	\instrument, \gpdef
)
)

x.stop;

// tempo change
TempoClock.default.tempo = 1.3;
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5, 6]+1, inf), \instrument, \gpdef);

// drop in ending patterns

x.play;
x.fadeTime = nil;

x.source = Pbind(\dur, 0.25, \degree, Pseq([3, [7,4], 5, 6]-2), \instrument, \gpdef);
x.source = Pbind(\dur, 0.125, \degree, Pseq([3, [7,4], 5, 4]-3), \instrument, \gpdef);
x.source = Pbind(\dur, 0.35, \degree, Pseq([3, [7,4], 5, 4, 3]-3), \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pshuf([3, [7,4], 5, 6]-2), \instrument, \gpdef);


TempoClock.default.tempo = 1.0;
x.stop;
y.stop;
::


TITLE:: EventStreamCleanup
summary:: Helper class that collects information about internal state of streams that needs to be released
categories::Streams-Patterns-Events

DESCRIPTION::
Event streams created by objects like link::Classes/Pmono:: or link::Classes/Pfx:: are special: when they start, they create some state (like a new synth) that is present over the whole period of the stream, or at least over several events. When such a stream ends, it releases this state. There are other streams, however, strong::that may stop their input stream at any time:: (e.g.  link::Classes/Pfindur:: or link::Classes/Pdef::). Them the state of any stream buried in the hierarchy of input streams must be released by them. EventStreamCleanup collects the cleanup functions and can run them when the stream is cut.

Note::So all event patterns that can end a subpattern (and streams respectively) have to use an EventStreamCleanup.::

Some examples of patterns that may stop an input stream and update an EventStreamCleanup:
list::
## link::Classes/Pbindf:: (stops its event stream if one of its parameter streams ends)
## link::Classes/Pfin:: (stops stream after a number of events)
## link::Classes/Pfindur:: (stops stream after a certain elapsed time)
## link::Classes/Pdef::  (stops stream when replaced by a new one)
## link::Classes/Pset::  (stops its event stream when its parameter streams ends)
## link::Classes/Pswitch1:: (stops all input streams after fixed number of items or when one of them ends. Not link::Classes/Pswitch::, which completely embeds every input stream)
::

Some examples of patterns that create state that lasts over several events. They also release the state via EventStreamCleanup:
list::
## link::Classes/Pmono:: (starts one synth that it controls over time)
## link::Classes/Pfx:: (starts an effect synth that it feeds through the signals of the substreams)
## link::Classes/Pproto:: (initializes resources and keeps them available)
## link::Classes/Pspawner:: (schedules streams and releases them after some time)
::

code::

// wrap a pattern in a stop condition
(
f = { |pat, condition|
	Prout { |inval|
		var stream = pat.asStream;
		var cleanup = EventStreamCleanup.new;
		var outval;
		while {
			outval = stream.next(inval);
			outval.notNil and: { condition.value(outval) }
		} {
			cleanup.update(outval);
			inval = outval.yield;
		};
		cleanup.exit(inval);
	}

};
p = Plazy { Pmono(\default, \note, Pgeom(rrand(1, 1.5), rrand(1.05, 2), inf), \harmonic, [0.78, 1, 1.2], \dur, 1/rrand(4, 7), \amp, 0.4) };
x = f.(p, { |outval| outval[\note] < 20 }); // always stop at 20
Pn(x).play; // loop it.
);
::


CLASSMETHODS::

METHOD:: new
Create a new instance.

INSTANCEMETHODS::

METHOD:: addFunction
Add a new cleanup function which will be called when the stream is made to end somewhere downstreams. This is called only in patterns that create resources that need to be released (e.g. link::Classes/Pmono:: or link::Classes/Pfx::).

ARGUMENT:: event
The outevent that is passed on downstreams and which communicates to any stream-ending pattern what needs to be done to release the resources. strong::It must be yielded after update!::

ARGUMENT:: function
The function that is called for cleanup. E.g. code::{ group.free }::.

RETURNS:: a link::Classes/CallOnce:: that executes the cleanup code::function:: at most once. Should it be necessary to execute the cleanup outside of the control of code::EventStreamCleanup::, the CallOnce returned should be used instead of the original code::function::, so that other referents are informed of the execution of the cleanup.

METHOD:: update
For every new event, the cleanup must be updated to receive information from any input stream further up. This method is called from all streams that may stop early (e.g. link::Classes/Pmono:: or link::Classes/Pfindur::).

ARGUMENT:: event
The outevent from the input stream. strong::It must be yielded after update!::

METHOD:: exit
Run all functions that have been collected over time, adding appropriate information to the event, in case it is passed on as an inevent.

ARGUMENT:: event
The inevent that is passed through to the outer stream

ARGUMENT:: freeNodes
Used internally.

returns:: An event. In embedInStream, this event must be returned (code:: ^cleanup.exit(inevent) ::)

METHOD:: functions
A collections of cleanup functions.

METHOD:: clear
Empty the cleanup functions, without evaluating them.

METHOD:: terminate
Run all functions that have been collected over time without adding information to an event.

ARGUMENT:: freeNodes
Used internally.




EXAMPLES::
code::
// some code from the class library

// here is a pattern that can end the stream externally after a number of steps
Pfin : FilterPattern {
	var <>count;
	*new { arg count, pattern;
		^super.new(pattern).count_(count)
	}
	storeArgs { ^[count,pattern] }

	embedInStream { arg event;
		var inevent;
		var stream = pattern.asStream;
		var cleanup = EventStreamCleanup.new;
		count.value(event).do({
			inevent = stream.next(event) ?? { ^event };
			cleanup.update(inevent);
			event = inevent.yield;
		});
		^cleanup.exit(event)
	}
}

// and here is a pattern that adds a resource: a bus in which the events play

Pbus : FilterPattern {
	var <>numChannels, <>rate, <>dur=2.0, <>fadeTime;

	*new { arg pattern, dur=2.0, fadeTime=0.02, numChannels=2, rate=\audio;
		^super.new(pattern).dur_(dur).numChannels_(numChannels).rate_(rate).fadeTime_(fadeTime)
	}

	storeArgs { ^[ pattern, dur, fadeTime, numChannels, rate ] }

	embedInStream { arg inevent;
		var server, groupID, linkID, bus, ingroup, cleanup;
		var patterns, event, freeBus, stream, cleanupEvent;

		cleanup = EventStreamCleanup.new;
		server = inevent[\server] ?? { Server.default };
		groupID = server.nextNodeID;
		linkID = server.nextNodeID;
		ingroup = inevent[\group];

		// could use a special event type for this:
		if(rate == \audio) {
			bus = server.audioBusAllocator.alloc(numChannels);
			freeBus = { server.audioBusAllocator.free(bus) };
		} {
			bus = server.controlBusAllocator.alloc(numChannels);
			freeBus = { server.controlBusAllocator.free(bus) };
		};

		CmdPeriod.doOnce(freeBus);

		event = inevent.copy;
		event[\addAction] = 0; // \addToHead
		event[\type] = \group;
		event[\delta] = 0;
		event[\id] = groupID;
		event[\group] = ingroup;
		event.yield;

		inevent = event = inevent.copy;

		event[\type] = \on;
		event[\group] = groupID;
		event[\addAction] = 3; // \addBefore
		event[\delta] = 0;
		event[\id] = linkID;
		event[\fadeTime] = fadeTime;
		event[\instrument] = format("system_link_%_%", rate, numChannels);
		event[\in] = bus;
		event[\msgFunc] = #{ |out, in, fadeTime, gate=1|
			[\out, out, \in, in, \fadeTime, fadeTime, \gate, gate, \doneAction, 3]
		};

		cleanupEvent = (type: \off, parent: event, fadeTime: fadeTime.abs, hasGate: true, gate: 0);

		cleanup.addFunction(event, { | flag |
			if(flag) { defer ( {cleanupEvent.play}, dur) };
		});

		cleanup.addFunction(event, { defer({ freeBus.value;}, fadeTime.abs + dur) });

		// doneAction = 3;
		// remove and deallocate both this synth and the preceding node
		// (which is the group).
		inevent = event.yield;

		// now embed the pattern
		stream = Pchain(pattern, (group: groupID, out: bus)).asStream;
		loop {
			event = stream.next(inevent) ?? { ^cleanup.exit(inevent) };
			cleanup.update(event);
			inevent = event.yield;
		}
	}
}

::



class:: EventStreamPlayer
summary:: two streams combined by a binary operator
related:: Classes/Event, Classes/Pbind
categories:: Streams-Patterns-Events

description::

An EventStreamPlayer is used by link::Classes/Event:: based Patterns.

The EventStreamPlayer holds a stream which returns a series of Events, and a protoEvent. At each call to next, it copies the protoEvent, passes that to the stream, and calls strong::play:: on the link::Classes/Event:: returned.

For more on EventStreamPlayer see link::Tutorials/Streams-Patterns-Events4::

EventStreamPlayer uses the same control methods and status notifications as link::Classes/Task::.

ClassMethods::

method::new
note::
You do not explicitly create an EventStreamPlayers, they are created for you when you call link::Classes/Pattern#-play::.
::

InstanceMethods::

private::prStop, prNext

method::play

argument::argClock
(optional) Override the clock assigned in Task.new.

argument::doReset
If true, the task will start over from the beginning. Default is false (task will resume where it was when it was last stopped).

argument::quant
See the link::Classes/Quant:: helpfile.

method::start
Restart the task from the beginning.

method::resume
Resume the task where it left off.

method::pause
Stop playing now.

method::stop
Stop playing now. (Pause and stop have the same implementation.)

method::reset
Set the stream to restart from the beginning the next time it's played.

method::reschedule

Switch the Task to a different clock, or a different time, without stopping. See link::Classes/Routine#-reschedule:: for complete documentation.

NOTE:: Rescheduling an EventStreamPlayer from within the pattern itself is currently not supported.
::


class::Exception
categories::Core
summary::root error class
keyword:: try protect catch

description::
The root of SuperCollider's error handling mechanism.

Exception is an abstract class, defining basic error behavior. This class is not directly used in SuperCollider. Users may create subclasses of Exception to identify specific types of failure conditions.

The built-in exception types are actually subclasses of link::Classes/Error:: -- see its help file for the hierarchy.

Note::
You should not return ^ from inside of the code::try:: or code::protect:: function itself, it cannot be caught. Returns in methods called by the receiver are OK.
::

subsection::Background: General exception handling

An exception is any event that disrupts the normal execution flow of a program. In practice there is not much distinction between an exception and an error; in SuperCollider, we tend to speak of errors where other object-oriented languages (Java, C++) would use exception consistently.

If a piece of code runs into an unexpected condition, it creates an exception object that holds information about the faulty condition, and then "throws" that object. From there, the interpreter unwinds backward through all the preceding stack frames looking for an exception handler that will "catch" the exception. The exception handler can take an alternate route to resolve the failure and continue normally; if this is not possible, it can re-throw the exception back to the previous stack frame. An exception that never gets caught causes execution to abort. In SuperCollider, this results in the standard error dump (see the Understanding-Errors help file for details); in C++ or Java, the effect is catastrophic, causing the whole program to crash.

subsection::Common syntax in other languages for exception handling is:

code::
try { ...code... }
catch { ...exception handler... }
::

Specific languages may have other variants. The SuperCollider compiler doesn't have room for the "catch" keyword, so the syntax is simpler:

code::
try { ...code... } { ...exception handler... };
::

With "try", "if" the error cannot be handled, you have to re-throw the error explicitly:

code::
try { ...code... } { |error|
	if( test: can I handle the error? ) {
		handle gracefully
	} { error.throw }
};
::

SuperCollider includes a variant, borrowed from Scheme, in which the exception is always fatal, but the preceding code might have allocated some resources that need to be released before reporting the error. For example, you might open a file and do some processing on it that might encounter an error. Good practice is to close the file before the error halt, which you can do this way:

code::
file = File(path, "r");
protect {
	work with the file here, which might cause an error
} {
	file.close;
};
::

With "protect" the second function will execute even if there is no error, and any error will be passed up the chain.

In Java, you can catch specific classes of exception. You can simulate this usage with the following construction:

code::
// Java-style

try {  }
catch { FileNotFoundException e } { console.printLine("File not found: " + e.path) }
catch { EmptyFileException e } { console.printLine("File is empty: " + e.path) };

// SuperCollider-style (hypothetical; these specific exceptions do not exist in the main library

try {  } { |error|
	switch(error.species.name)
		{ 'FileNotFoundException' } { postln("File not found:" + e.path) }
		{ 'EmptyFileException' } { postln("File is empty:" + e.path) }
			// default condition: unhandled exception, rethrow
		{ error.throw }
}
::
Following is an example that recovers from a failed attempt to write into an immutable array, by re-attempting the write on a copy of the array.

code::
(
~inPlaceSub = { |array, find, replace|
	array.do({ |item, i|
		if(item == find) { array[i] = replace };
	});
};

~trySub = { |array, find, replace|
	try {
		~inPlaceSub.(array, find, replace)
	} { |error|
		switch(error.species.name)
			{ 'PrimitiveFailedError' } {
				if(error.what.find("immutable").notNil) {
					"caught ImmutableError".postln;
					~inPlaceSub.(array.copy, find, replace)
				} { "unknown primitive exception".postln; error.throw; }
			}
				// default case: unhandled exception, should die so re-throw error
			{ "unknown exception".postln; error.throw; }
	};
};
)

// pass in a mutable array, OK
~trySub.((0..9), 9, 19);

// pass in a literal array, Immutable exception is caught and handled
~trySub.(#[0, 1, 2, 3, 4, 5], 5, 6);

// pass in a nonsense value, other exception is re-thrown
~trySub.(10, 5, 6);
::


class:: ExpRand
summary:: Exponential single random number generator.
related:: Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in an exponential distributions
from  code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::

(
SynthDef("help-ExpRand", { arg out=0;
	Out.ar(out,
		FSinOsc.ar(
			ExpRand(100.0, 8000.0),
			0, Line.kr(0.2, 0, 0.01, doneAction: Done.freeSelf))
	)
}).add;
)

(
Routine({
	inf.do({ arg i;
		Synth.new("help-ExpRand"); 0.05.wait;
	})
}).play;
)

::



CLASS:: ExponentialGridLines
summary:: Calculates the numerical values suitable for exponentially-spaced grid lines to be used for plotting or other UI elements.
categories:: GUI>Accessories
related:: Classes/GridLines, Classes/AbstractGridLines, Classes/LinearGridLines, Classes/DrawGrid, Classes/ControlSpec, Classes/Plotter, Reference/plot

DESCRIPTION::
code::ExponentialGridLines:: is a strategy object that finds suitable intervals for plotting grid lines and labels. The values span the range defined by a corresponding link::Classes/ControlSpec::. Most of the functionality of code::ExponentialGridLines:: is inherited from its superclass, link::Classes/AbstractGridLines::. The instance methods are used by link::Classes/DrawGrid:: (which is in turn used by link::Classes/Plotter::) which handles the drawing of the lines and labels.

code::ExponentialGridLines:: isn't usually instantiated directly, but rather by the link::Classes/GridLines:: factory class or the link::Classes/ControlSpec#-grid:: method which return the appropriate code::AbstractGridLines:: subclass for the given spec.

code::
(
// LinearGridLines
var linGrid = ControlSpec(0, 100, \lin, units: "Time").grid;
// ExponentialGridLines
var expGrid = \freq.asSpec.grid;

DrawGrid.test(linGrid, expGrid);
)
::

CLASSMETHODS::

COPYMETHOD:: AbstractGridLines *new

INSTANCEMETHODS::

COPYMETHOD:: AbstractGridLines -spec
COPYMETHOD:: AbstractGridLines -asGrid
COPYMETHOD:: AbstractGridLines -niceNum
COPYMETHOD:: AbstractGridLines -looseRange
COPYMETHOD:: AbstractGridLines -getParams
COPYMETHOD:: AbstractGridLines -formatLabel

private:: prCheckWarp, ideals


class:: FBSineC
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineN, Classes/FBSineL

description::
A cubic-interpolating sound generator based on the difference equations:

teletype::
	x(n+1) = sin(im * y(n) + fb * x(n))
	y(n+1) = (a * y(n) + c) % 2pi
::

This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

sclang code translation:

code::
(
var im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;
plot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ FBSineC.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineC.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineC.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineC.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineC.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::


class:: FBSineL
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineC, Classes/FBSineN

description::
A linear-interpolating sound generator based on the difference equations:

teletype::
        x(n+1) = sin(im * y(n) + fb * x(n))
        y(n+1) = (a * y(n) + c) % 2pi
::


This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

sclang code translation:

code::
(
var im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;
plot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ FBSineL.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineL.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineL.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineL.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineL.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::


class:: FBSineN
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineL, Classes/FBSineC

description::
A non-interpolating sound generator based on the difference equations:

teletype::
        x(n+1) = sin(im * y(n) + fb * x(n))
        y(n+1) = (a * y(n) + c) % 2pi
::


This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

sclang code translation:

code::
(
var im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;
plot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ FBSineN.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineN.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineN.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineN.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineN.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::


class:: FFT
summary:: Fast Fourier Transform
related:: Classes/IFFT, Guides/FFT-Overview
categories:: UGens>FFT

Description::

The fast fourier transform analyzes the frequency content of a signal, which can be useful for audio analysis or for frequency-domain sound processing (phase vocoder).

note::
FFT and link::Classes/IFFT:: UGens require a buffer to store the frequency-domain data. This buffer must have exactly one channel. emphasis::Multichannel buffers are never supported.::

To do FFT processing on a multichannel signal, provide an array of mono buffers, one for each channel. Then, FFT/IFFT will perform link::Guides/Multichannel-Expansion::, to process each channel separately.

code::
// NO: The buffer has two channels -- this will not work
fft = FFT(LocalBuf(2048, 2), aStereoSignal);

// YES: Use an array of two single-channel buffers
fft = FFT(Array.fill(2, { LocalBuf(2048, 1) }), aStereoSignal);

// Equivalent shortcut:
// LocalBuf multichannel-expands, causing FFT to expand as well
fft = FFT(LocalBuf(2048.dup(2), 1), aStereoSignal);
::

See also link::Guides/FFT-Overview#Multichannel Expansion with FFT UGens::.
::

classmethods::

method::new

argument::buffer
A buffer to store spectral data. The buffer's size must
correspond to a power of 2. LocalBuf is useful here, because processes should not share data between synths. (Note: most PV UGens operate on this data in place. Use PV_Copy for parallel processing.)

argument::in
The signal to be analyzed. The signal's rate determines the rate at which the input is read.

argument:: hop
The amount of offset from the beginning of one FFT analysis frame to the next, measured in multiples of the analysis frame size. This can range between 1.0 and values close to (but larger than) 0.0, and the default is 0.5 (meaning each frame has a 50% overlap with the preceding/following frames).

argument:: wintype
Defines how the data is windowed:
table::
## -1 || strong::rectangular:: windowing, simple but typically not recommended;
## 0 || (the default) strong::Sine:: windowing, typically recommended for phase-vocoder work;
## 1 || strong::Hann:: windowing, typically recommended for analysis work.
::

argument:: active
A simple control allowing FFT analysis to be active (>0) or inactive (<=0). This is mainly useful for signal analysis processes which are only intended to analyse at specific times rather than continuously

argument:: winsize
The windowed audio frames are usually the same size as the buffer. If you wish the FFT to be zero-padded then you can specify a window size smaller than the actual buffer size (e.g. window size 1024 with buffer size 2048). Both values must still be a power of two. Leave this at its default of zero for no zero-padding.

returns::
The FFT chain

discussion::
Only the first two arguments are required. The remaining arguments allow for custom FFT analyses for specialised situations.

FFT uses a local buffer for holding the buffered audio. The buffer size must be a multiple of the control block size as well as being a power of two.

Note that for phase-vocoder usage, changing the hop or wintype settings from their defaults will typically result in unnatural sound when used in combination with IFFT, due to windowing artifacts. (A hop of 0.25, with Hann windowing, can be a useful combination for phase-vocoder work.)


Examples::

code::
(
{
	var in, chain;
	in = WhiteNoise.ar(0.1);
	chain = FFT(LocalBuf(2048), in);
	IFFT(chain) // inverse FFT
}.play;
)

// inspecting it, we see that the chain is an FFT:
(
{
	var in, chain;
	in = WhiteNoise.ar(0.1);
	chain = FFT(LocalBuf(2048), in);
	chain.inspect; 
	IFFT(chain) // inverse FFT
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08,0,6,6.2).squared, 0, 100, 800));
	chain = FFT(LocalBuf(2048), in);
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08,0,6,6.2).squared, 0, 100,800));
	//in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, 310);
	0.5 * IFFT(chain);
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BrickWall(chain, SinOsc.kr(0.1));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.8);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_RectComb(chain, 8, LFTri.kr(0.097,0,0.4,0.5),
		LFTri.kr(0.24,0,-0.5,0.5));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr(5.2,250,400));
	chain = FFT(LocalBuf(2048), in);
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr(0.2) );
	0.5 * IFFT(chain);
}.play;
)


// stereo example:

(
{
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr([5.2, 3.3],250,400));
	chain = FFT({ LocalBuf(2048) } ! 2, in); // we need two buffers for stereo input.
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr([0.2, 0.3]) );
	0.5 * IFFT(chain);
}.play;
)

::



class:: FFTTrigger
summary:: Outputs the necessary signal for FFT chains, without doing an FFT on a signal
categories:: UGens>FFT

classmethods::
private:: categories

method:: new
argument:: buffer
a buffer to condition for FFT use
argument:: hop
the hop size for timing triggers (defaults to 0.5)
argument:: polar
a flag. If 0.0, the buffer will be prepared for complex data, if > 0.0, polar data is set up.

examples::
code::

// Reminder: This isn't the intended typical usage! It's OK to do this though.
(
x = {
	var mags, phases, chain, sig;
	// Create simple undulating magnitudes
	mags = { FSinOsc.kr(ExpRand(0.1, 1)).range(0, 1) }.dup(100);
	// Then give them a "rolloff" to make the sound less unpleasant
	mags = mags  * ((1, 0.99 .. 0.01).squared);
	// Let's turn the bins on and off at different rates, I'm *sure* that'll sound interesting
	mags = mags * { LFPulse.kr(2 ** IRand(-3, 5)).range(0, 1) }.dup(100);
	// Let's ignore phase for now
	phases = 0.dup(100);
	chain = FFTTrigger(LocalBuf(512), 0.5);
	// Now we can do the packing
	chain = PackFFT(chain, 512, [mags, phases].flop.flatten, 0, 99, 1);
	sig = IFFT(chain);
	sig.dup
}.play
)
x.free;
b.free;
::



class:: FOS
summary:: First order filter section.
related:: Classes/SOS
categories::  UGens>Filters>Linear


Description::

A standard first order filter section. Filter coefficients are given
directly rather than calculated for you. Formula is equivalent to:

code::
out(i) = (a0 * in(i)) + (a1 * in(i-1)) + (b1 * out(i-1))
::


classmethods::

method::ar, kr

argument::in
Signal input.

argument::a0
See formula above.

argument::a1
See formula above.

argument::b1
See formula above.

argument::mul

argument::add

Examples::

code::

(
// same as OnePole
{	var x;
	x = LFTri.ar(0.4, 0, 0.99);
	FOS.ar(LFSaw.ar(200, 0, 0.2), 1 - x.abs, 0.0, x)
}.play;
)

(
// same as OneZero
{	var x;
	x = LFTri.ar(0.4, 0, 0.99);
	FOS.ar(LFSaw.ar(200, 0, 0.2), 1 - x.abs, x, 0.0)
}.play;
)

(
// same as OnePole, kr
{	var x, ctl;
	x = LFTri.kr(0.2, 0, 0.99);
	ctl = FOS.kr(LFSaw.kr(8, 0, 0.2), 1 - x.abs, 0.0, x);
	LFTri.ar(ctl * 200 + 500);
}.play;
)

::



class:: FSinOsc
summary:: Fast sine oscillator.
related:: Classes/SinOsc, Classes/SinOscFB
categories::  UGens>Generators>Deterministic

Description::

Very fast sine wave generator (2 PowerPC instructions per output sample!)
implemented using a ringing filter. This generates a much cleaner sine
wave than a table lookup oscillator and is a lot faster. However, the
amplitude of the wave will vary with frequency. Generally the amplitude
will go down as you raise the frequency and go up as you lower the frequency.

warning::
In the current implementation, the amplitude can blow up if the
frequency is modulated by certain alternating signals.
::


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.
note:: While an audio-rate frequency input is accepted, frequency is
is currently only updated internally at only control-rate.::

argument::iphase
Initial phase offset.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.


Examples::

code::
{ FSinOsc.ar(800) * 0.2 }.play;

{ FSinOsc.ar(XLine.kr(200, 4000, 1)) * 0.2 }.play;

// loses amplitude towards the end
{ FSinOsc.ar(FSinOsc.ar(XLine.kr(4, 401, 8), 0.0, 200, 800)) * 0.2 }.play;

::



class::False
categories::Core
summary::false logical value

description::
see link::Classes/Boolean::


class:: Fdef
summary:: lazy function proxy
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdef, Classes/Tdef, Classes/Pdefn, Classes/Ndef

description::
Fdef is a placeholder for functions. Fdef allows dynamically replacing functions while they are being used.

See also: link::Classes/Maybe:: and the link::Overviews/JITLib:: overview.

ClassMethods::

private::initClass

method::new

argument::key
if no instance exists with this name, create a new one, otherwise return the existing one.

argument::val
If a link::Classes/Function:: is given, replace the old function with the new one.

Examples::

code::
Fdef(\x, { 8 + 9 });

Fdef(\y, Fdef(\x) - 3);

Fdef(\y).value;

Fdef(\x, 3);

Fdef(\y).value;

Fdef(\x, { |x=0| x });


Fdef(\x).value(8);

Fdef(\y).value(8);


z = Fdef(\x) * Fdef(\y) + { 1.0.rand };

z.value;
z.value(400);
::

code::
// sound example
(
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf) * amp;
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

// fork a thread that plays some sounds
(
Fdef(\freq, 440);
Fdef(\dur, 0.2);

fork {
	loop {
		s.sendMsg("/s_new", "gpdef", -1, 1,1, \freq, Fdef(\freq).value);
		Fdef(\dur).value.wait;
	}
};
)

// some modifications

Fdef(\freq, Fdef(\midinote, 60).midicps);
Fdef(\midinote, { [67, 64, 65].choose });
Fdef(\midinote, { [67, 64, 65].choose } + Fdef(\offset));
Fdef(\offset, { 4.rand });
Fdef(\dur, 0.23);
::


class:: File
summary:: A class for reading and writing files
related:: Classes/FileReader
categories:: Files

description::
A class for reading and writing files. Not sound files.

ClassMethods::

private::prGetcwd, prType, openDialog, openDialogs, saveDialog

method::new
Create a File instance and open the file. If the open fails, link::Classes/UnixFILE#-isOpen#isOpen:: will return false.

argument::pathName
A link::Classes/String:: containing the path name of the file to open.

argument::mode
a link::Classes/String:: indicating one of the following modes:
definitionList::
## "r" || Opens a file for reading. The file must exist.
## "w" || Creates an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
## "a" || Appends to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
## "rb", "wb", "ab" || same as above, but data is binary
## "r+" || Opens a file for update both reading and writing. The file must exist.
## "w+" || Creates an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
## "a+" || Opens a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition the internal pointer using the seek method to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.
## "rb+", "wb+", "ab+" || same as above, but data is binary
::

method::open
Same as link::#*new::, but a more intuitive name.

method::getcwd
POSIX standard 'get current working directory'.
code::
// example;
File.getcwd;
::

method::use
Open the file, evaluate the function with the file as argument, and close it again. If the process fails, close the file and throw an error.

method::readAllString
Open the file at the given path, call link::#-readAllString::, and return the string. Whether the process succeeds or fails, the file will always be closed.

code::
// write a file
File.use("~/test.txt".standardizePath, "w", { |f| f.write("The green fox fell into the blue lake") });

// read it again
File.readAllString("~/test.txt".standardizePath);
::

method::readAllSignal
Open the file at the given path, call link::#-readAllSignal::, and return the signal. Whether the process succeeds or fails, the file will always be closed.

method::readAllStringHTML
Open the file at the given path, call link::#-readAllStringHTML::, and return the string. Whether the process succeeds or fails, the file will always be closed.

method::readAllStringRTF
Open the file at the given path, call link::#-readAllStringRTF::, and return the string. Whether the process succeeds or fails, the file will always be closed.

subsection:: Filesystem utilities

method::exists
Answers if a file exists at that path.
note::
Some filesystems, like the one used by macOS, are case insensitive.
On such systems, this method will return true for "fOo" even if the file is actually named "Foo".
For a workaround, see link::#*existsCaseSensitive:: below.
::
returns:: a link::Classes/Boolean::

method::existsCaseSensitive
Like link::#*exists:: but ensure case sensitivity emphasis:: of the last path component :: on case insensitive filesystems. On case sensitive systems, it falls back to using code::exists::.

note::
This is slower than the normal code::exists:: method, so use it only when really needed.
::

method::systemIsCaseSensitive
Answers if the filesystem is case sensitive or not.

method::mkdir
Create directory at path, including any missing parent directories.

returns:: a link::Classes/Boolean::, as follows:
list::
## code::true:: -- A new directory was created at code::path::.
## code::false:: -- A directory already existed at code::path::; a new one was not created.
::

method::delete
Deletes the file at that path. Use only for good, never for evil.

returns:: a link::Classes/Boolean::, as follows:
list::
## code::true:: -- You can assume that the path no longer exists. (Either it existed and was deleted, or it didn't exist and it still doesn't exist.)
## code::false:: -- The file could not be deleted (probably a permissions error). Your code should assume that the path still exists.
::

method::deleteAll
Deletes the file and all children at that path. Use only for good, never for evil.

returns:: a link::Classes/Boolean::, as follows:
list::
## code::true:: -- At least one file was deleted.
## code::false:: -- No files were deleted.
::

If deletion fails, a PrimitiveFailedError object will be thrown.

method::realpath
Follow symbolic links (and aliases on macOS) and any parent directory references (like "..") and return the true absolute path.

returns:: a link::Classes/String:: or code::nil:: if path did not exist.

method::copy
Copy file, symlink or directory. this method will fail if pathNameTo already exists.

Symlinks are copied as symlinks (re-created).

method::type
Get file type as one of code::\error, \not_found, \regular, \directory, \symlink, \block, \character, \fifo, \socket, \unknown::
returns:: a link::Classes/Symbol::

method::fileSize
Get size of file in bytes.
returns:: an link::Classes/Integer::

method::mtime
Get last modification time in seconds since the Epoch.
returns:: an link::Classes/Integer::

subsection:: Error handling in filesystem utilities

If one of the above filesystem primitives fails, in most cases, a PrimitiveFailedError object will be thrown:

code::
File.mkdir("/usr/oh-no-you-cant");
::

teletype::
ERROR: Primitive '_FileMkDir' failed.
caught exception 'boost::filesystem::create_directory: Permission denied: "/usr/oh-no-you-cant"' in primitive in method Meta_File:mkdir
::

The methods link::Classes/Function#-try:: and link::Classes/Function#-protect:: can detect and handle these errors. See link::Guides/Understanding-Errors:: for details.

Currently, link::Classes/File#*copy::, link::Classes/File#*fileSize::, link::Classes/File#*mkdir::, link::Classes/File#*mtime::, and link::Classes/File#*type:: throw errors upon failure. (link::Classes/File#*delete:: does not throw an error, but instead returns a Boolean.)

InstanceMethods::

private::prOpen, prClose

method::open
Open the file. Files are automatically opened upon creation, so this call is only necessary if you are closing and opening the same file object repeatedly.
note::
it is possible when saving files with a standard file dialog to elect to "hide the extension" and save it as RTF. When opening the file you must specify the real filename: "filename.rtf", even though you can't see in file load dialogs or in the Finder.
::

method::close
Close the file.

method::readAllString
Reads the entire file as a link::Classes/String::.

method::readAllStringHTML
Reads the entire file as a link::Classes/String::, stripping HTML tags.

method::readAllStringRTF
Reads the entire file as a link::Classes/String::, stripping RTF formatting.

method::readAllSignal
Reads the entire file as a link::Classes/Signal::, where every chunk of four bytes is interpreted as a 32-bit floating point sample.

method::seek
Moves the read/write pointer to a given location in the file, where offset is location given in bytes, and origin is the reference of the offset:
definitionList::
## 0 || offset is from the beginning of the file
## 1 || offset is relative to the current position in the file
## 2 || offset is from the end of the file
::

method::pos
Sets or returns the current position in the file (in bytes).
when used as a setter, this method is a shortcut for seek(0, value). so setting the pos moves the current file position to a given location from the beginning of the file. the value is clipped so that it lies between 0 inclusively and the file length exclusively.

method::length
Returns the current file size in bytes.

Examples::

code::
// write some string to a file:
(
var f, g;
f = File("~/test.txt".standardizePath,"w");
f.write("Does this work?\n is this thing on ?\n");
f.close;
)

// read it again:
(
g = File("~/test.txt".standardizePath,"r");
g.readAllString.postln;
g.close;
)

// try the above with File.use:

File.use("~/test.txt".standardizePath, "w", { |f| f.write("Doesn't this work?\n is this thing really on ?\n"); });
File.use("~/test.txt".standardizePath, "r", { |f| f.readAllString.postln });


// more file writing/reading examples:
(
var h, k;
h = File("~/test.dat".standardizePath, "wb");
h.inspect;
h.write( FloatArray[1.1, 2.2, 3.3, pi, 3.sqrt] );
h.close;

k = File("~/test.dat".standardizePath, "rb");
(k.length div: 4).do({ k.getFloat.postln; });
k.close;
)


(
var f, g;
f = File("~/test.txt".standardizePath,"w");
100.do({ f.putChar([$a, $b, $c, $d, $e, $\n].choose); });
f.close;

g = File("~/test.txt".standardizePath,"r");
g.readAllString.postln;
g.close;

g = File("~/test.txt".standardizePath,"r");
g.getLine(1024).postln;
"*".postln;
g.getLine(1024).postln;
"**".postln;
g.getLine(1024).postln;
"***".postln;
g.getLine(1024).postln;
"****".postln;
g.close;
)

(
//var f, g;
f = File("~/test.dat".standardizePath,"wb");
f.inspect;
100.do({ f.putFloat(1.0.rand); });

f.inspect;
f.close;

g = File("~/test.dat".standardizePath,"rb");
100.do({
	g.getFloat.postln;
});
g.inspect;
g.close;
)

(
//var f, g;
f = File("~/test.dat".standardizePath,"r");
f.inspect;
f.close;
)
::


TITLE:: FileDialog
summary:: Operating system interface for Open file, save file, select directory dialogs
categories:: GUI>Accessories
related:: Classes/Dialog, Classes/File

DESCRIPTION::
This is the interface for your standard operating system modal file dialogs to open files, save files and select directories.

link::Classes/Dialog:: has functions built on top of FileDialog that may be more convenient to use.
However, selecting a directory is only possible with FileDialog.

CLASSMETHODS::

PRIVATE:: qtClass

METHOD:: new
Create and display a dialog.

ARGUMENT:: okFunc
Handler function evaluated when the user clicks "Open" or "Save".
This function receives different arguments depending on the value of code::stripResult::. By default
(code::stripResult: false::), code::okFunc:: is passed an array of selected paths. Otherwise, the
paths are passed as separate arguments, one for each path.

ARGUMENT:: cancelFunc
Handler function evaluated when the user clicks "Cancel". Receives no arguments.

ARGUMENT:: fileMode
An integer that determines the type of dialog.

These values correspond directly to values of QFileDialog\::FileMode in the Qt class.

list::
## 0 The name of a file, whether it exists or not.
## 1 The name of a single existing file.
## 2 The name of a directory. Both files and directories are displayed.
## 3 The names of zero or more existing files.
::

0 or 3 implies that the user can type in a new file name.

ARGUMENT:: acceptMode
An integer that determines whether the dialog is for opening or saving files. Note that this doesn't
actually open or save a file; you'll need to do that in your code::okFunc::. This only affects
appearance of the dialog.

These values correspond directly to values of QFileDialog\::AcceptMode in the Qt class.

list::
## 0 Opening
## 1 Saving
::

ARGUMENT:: stripResult
A boolean. If code::true::, selected paths are passed individually as arguments to code::okFunc::.
Otherwise, they are passed as an array in a single argument (the default).

list::
## false: okFunc(paths)
## true: okFunc(path1, path2, path3)
::

ARGUMENT:: path
A string. The dialog will initially display the contents of this path. The default is the current
user's home directory.

returns:: a FileDialog

EXAMPLES::

code::
// By default, the selected paths are passed to okFunc as an array.
(
FileDialog({ |paths|
	postln("Selected path:" + paths[0]);
	}, {
	postln("Dialog was cancelled. Try again.");
	});
)

// You can change this by passing `stripResult: true`
(
FileDialog({ |path|
	postln("Selected path:" + path);
	}, {
	postln("Dialog was cancelled. Try again.");
	}, stripResult: true);
)

// Passing `fileMode: 3` makes it possible to select multiple files.
(
FileDialog({ |paths|
	postln("Selected paths:");
	paths.do(_.postln);
	}, fileMode: 3);
)

// Passing `fileMode: 0` allows selecting any kind of file.
// You can start the dialog in a directory other than home by passing `path: "/some/path/"`
(
FileDialog({ |path|
	postln("Selected file:" + path);
	postln("File type is:" + File.type(path)); },
	fileMode: 0,
	stripResult: true,
	path: Platform.userAppSupportDir);
)
::


class:: FileReader
summary:: file reader for space-delimited text files
related:: Classes/File
categories:: Files

description::
FileReader reads space-delimited text files into 2D arrays line by line.

For tab delimited files use link::Classes/TabFileReader::. For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For comma-separated files use link::Classes/CSVFileReader::.

Examples::

code::
(
// write a test file:
f = File("FileReaderTest.sc", "w");
f.write(
"Some space delimited items in line 1

and then some more with several blanks     in line 3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = FileReader.read("FileReaderTest.sc").postcs;

	// can skip empty lines:
x = FileReader.read("FileReaderTest.sc", true).postcs;

	// can skip blank entries caused by multiple spaces:
x = FileReader.read("FileReaderTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("FileReaderTest.sc", "r"); f.isOpen;
t = FileReader(f, true, true);
t.read;
f.close;

	// take letter "a" as delimiter:
x = FileReader.read("FileReaderTest.sc", true, true, delimiter: $a).postcs;

(
// write a test file with numbers:
f = File("FileReadTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ " "); };
f.close;
)

x = FileReader.read("FileReadTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or do it immediately:
x = FileReader.readInterpret("FileReadTestNum.sc").postcs;

(
// write a test file with several lines of numbers:
f = File("FileReadTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, " ", Char.nl)); };
f.close;
)


x = FileReader.readInterpret("FileReadTestNum.sc", true, true).postln;
::


class:: Filter
summary:: Base class for filter UGens
categories:: UGens>Filters

description::

"Filter" is an abstract class - in other words, a class that you do not use directly. Instead, use one of its subclasses. Many common filters inherit from this abstract class, including LPF, HPF, MoogFF, Ringz, Integrator, Median, LeakDC... and many more.

The Filter class also provides a simple way to visualise the frequency-wise effect of applying a filter, see code::scopeResponse:: below.

classmethods::
private:: categories

method:: scopeResponse
Provides a simple way to visualise the frequency-wise effect of applying a filter
discussion::
code::
s.boot // boot the server 
MoogFF.scopeResponse
HPF.scopeResponse
BRF.scopeResponse
Median.scopeResponse
::

instancemethods::
private:: checkInputs



class:: FilterPattern
summary:: abstract class that holds a pattern to be modified
related:: Classes/ListPattern
categories:: Streams-Patterns-Events>Patterns>Filter

Examples::

code::
// post subclasses:

FilterPattern.dumpClassSubtree;
::


Class:: Float
summary:: 64-bit Floating point number
categories:: Math

description::
A 64-bit double precision floating point number. Float inherits most of its behaviour from its superclass.

code::
// generate 10 random floats between 0 and 1
{ 1.0.rand }.dup(10)

// Pythagorean comma
// expressed as a floating point number resulting from calculations with integers
(
var apotome = (3 ** 7) / (2 ** 11);
var limma =   (2 ** 8) / (3 ** 5);

apotome / limma
)
::

Note that despite its name, link::Classes/FloatArray:: only holds 32-bit (single precision) floats.
For a raw array of 64-bit floats, use link::Classes/DoubleArray::.

ClassMethods::

method:: from32Bits
returns:: a new Float from a 32-bit word.

method:: from64Bits
returns:: a new Float from a 64-bit word.

InstanceMethods::

method:: do
iterates a link::Classes/Function:: from code::0:: to code::this-1::. See also: link::Classes/Integer#-do::, link::Classes/Collection#-do::
argument:: function
The function to iterate.

method:: reverseDo
iterates function from this-1 to 0
argument:: function
The function to iterate.

method:: clip
Return this if lo <= this <= hi, otherwise return the nearest boundary: lo if this < lo, hi if this > hi.
argument:: lo
The low threshold of clipping.
argument:: hi
The high threshold of clipping.

method:: fold
Fold this to [lo, hi].
argument:: lo
The low threshold of folding.
argument:: hi
The high threshold of folding.

method:: wrap
Wrap this around [lo, hi) such that it falls in range. Equivalent to (this % (hi - lo)) + lo.
argument:: lo
The low threshold (inclusive) of wrapping.
argument:: hi
The high threshold (exclusive) of wrapping.

method:: coin
Let emphasis::x:: be the receiver clipped to the range [0, 1]. With probability emphasis::x::, return true. With probability 1 - emphasis::x::, return false.

returns:: a link::Classes/Boolean::
discussion::
code::
0.2.coin; // 20 % chance for true.
::
See also: link::Guides/Randomness::

method::xrand2
returns::a random float from this.neg to this, excluding the value exclude.

method:: isFloat
returns:: code::true:: since this is a Float.

method:: asFloat
returns:: code::this:: since this is a Float.

method:: as32Bits
returns:: an Integer which is the bit pattern of this as a 32bit single precision float

method:: high32Bits
returns:: an Integer which is the bit pattern of high 32-bits of the 64-bit double precision floating point value

method:: low32Bits
returns:: an Integer which is the bit pattern of high 32-bits of the 64-bit double precision floating point value

method:: asCompileString
returns:: a string that when interpreted matches the receiver, if the number is within the range given in code::storeOn::.

code::
a = 2.81882773638;
a.asCompileString.interpret == a;
::

method:: asStringPrec
Returns a string representation of the number, with the desired precision (i.e. number of significant figures).
discussion::
code::
// example:
pi
pi.asStringPrec(3)
pi.asStringPrec(6)
(pi * 0.0001).asStringPrec(3)
7.4.asStringPrec(5)
7.4.asStringPrec(50)
::

subsection::Using Floats as replacement for Integers

In SuperCollider, Floats are 64-bit wide. Because  an link::Classes/Integer::  is 32-bit, it can only capture integers in the range code::-2147483648 .. +2147483647::, or about code:: 2 x 10^9 ::.

Therefore, in some situations it can be useful to calculate with floats also when only whole numbers are needed. You can use 64-bit floats for integer calculations up to code::± 9007199254740992:: (code::2^53::, or about code::9 x 10^15::). Sometimes one can go even further (see example below).


code::
// compare factorial:
f = { |x| if(x < 2) { x } { x * f.(x - 1) } };
f.(14); // integer
f.(18) // integer overflow: -898433024
f.(18.0) // float is ok.
// check the ratio between adjacent factorials:
f.(18.0) / f.(17.0) == 18 // true
// 18 is already the largest possible factorial representable in 64-bit float (< 2^53)
{:x, x<-(1.0..40), f.(x) < (2 ** 53) }.all.last
::


Here is a classical example for an algorithm:

code::
// euclidean algorithm
(
g = { |a, b|
	if(b == 0) {
		a
	} {
		g.(b, mod(a, b))
	}
}
)

// check if a power of two

x = 2147483647 * 3;
g.(x, 3); // wrong, returns 1
x = 2147483647.0 * 3;
g.(x, 3); // correct, returns 3

x = 2007199254740992.0 * 3;
g.(x, 3); // correct, returns 3
x = 9007199254740992.0 * 3;
g.(x, 3); // still happens to be correct, but better not count on it …
::



Testing the limits of 64-bit float (2^53)

code::
a = 2 ** 53 - 1
b = a + 1;
c = a + 2;
b - a // correct (1)
c - a // incorrect (also 1)


// How high you can go depends on the calculation:
// here we divide two numbers that follow each other
// and it is correct up to f.(170), about 7.25e+306.
f = { |x| if(x < 2) { x } { x * f.(x - 1) } };
{:x, x<-(1.0..180), f.(x) / f.(x - 1) == x }.all.last

::


CLASS::FloatArray
summary::an array of 32-bit single precision floating point numbers
related::Classes/DoubleArray, Classes/Signal
categories::Collections>Ordered

DESCRIPTION::
An array of 32-bit single precision floating point numbers.

Note that despite the "Float" in its name, FloatArray does not hold a sequence
of SuperCollider double precision link::Classes/Float##floats::, but rather
32-bit (single precision) floats. For a raw array of 64-bit floats, use
link::Classes/DoubleArray::.

FloatArray and its subclass link::Classes/Signal:: are commonly used to hold
audio data in SuperCollider. Since almost all audio has 16-bit or 24-bit
precision, using double precision floats for this purpose would be a waste of
space. In other words, FloatArray is meant for storage of large amounts of
lower-precision data, but it is not meant for highly accurate math operations.

The complete list of RawArray types in SuperCollider is:

list::
## link::Classes/Int8Array:: - 8 bit integer
## link::Classes/Int16Array:: - 16 bit integer
## link::Classes/Int32Array:: - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## link::Classes/SymbolArray:: - symbols
::

INSTANCEMETHODS::

method::readFromStream


class:: FlowLayout
summary:: A view decorator which autowraps the view contents
categories:: GUI>Layout
related:: Classes/SCContainerView, Classes/CompositeView

description::
FlowLayout is a decorator which automatically arranges views inside a container view in a row, and starts a new row if there is not enough space left for the next view. link::Classes/Window:: and link::Classes/CompositeView:: both have code::addFlowLayout:: methods which assign FlowLayout to their view decorators and return the decorator.

classmethods::

method:: new
argument:: bounds
An instance of link::Classes/Rect::. Normally set to the code::parent.bounds::.
argument:: margin
An instance of link::Classes/Point::. The horizontal and vertical inner margins, within which the parent's subviews are placed.
argument:: gap
An instance of link::Classes/Point::. The horizontal and vertical layout gap between the subviews.

discussion::
Example:
code::
(
w = Window.new.front;
//change the gaps and margins to see how they work
w.view.decorator = FlowLayout( w.view.bounds, 10@10, 20@5 );
16.do{ Slider2D( w.view,80@80 ).background_( Color.rand ) };
)
::
You can also write:
code::
(
w = Window.new.front;
w.addFlowLayout( 10@10, 20@5 ); // a shortcut method, see SCContainerView
16.do{ Slider2D( w.view,80@80 ).background_( Color.rand ) };
)
::

instancemethods::

subsection:: Accessing Instance Variables

method:: nextLine
Forces the decorator to start a new line:
code::
(
w = Window.new;
q = w.addFlowLayout( 10@10, 20@5 );
Slider2D( w.view,140@140 ).background_( Color.rand );
q.nextLine;
Slider2D( w.view,140@140 ).background_( Color.rand );
w.front;
)
::

method:: indentedRemaining
Returns and instance of link::Classes/Rect::. This is a very useful method which tells you how much space is left in a row, before the next row starts. The height of code::indentedRemaining::, is the full height remaining in the FlowLayout.
code::
(
//normally you will only use the width of indentedRemaining
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider( w.view, d.indentedRemaining.width@150) //fits this view perfectly to the right innerBounds
	.background_( Color.rand );
w.front;
)
::
Compare this with:
code::
( //here the third view is fit to both the right and bottom innerBounds
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,140@140 ).background_( Color.rand );
Slider2D( w.view,140@140 ).background_( Color.rand );
d.nextLine;
Slider2D( w.view, d.indentedRemaining ).background_( Color.rand );
w.front;
)
::

method:: bounds
The outer bounds in which the decorator places the subviews in the parent view.
argument:: b
An instance of link::Classes/Rect::.

method:: innerBounds
Returns the bounds inset by margin.

method:: gap
The horizontal and vertical layout gap between the subviews.
argument:: arg1
An instance of link::Classes/Point::.

method:: margin
The horizontal and vertical inner margins, within which the parent's subviews are placed.
argument:: arg1
An instance of link::Classes/Point::.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: left
Get the current left indentation or manually set it.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
d.left_(220); //manually set the new indentation
Slider2D( w.view,150@150 ).background_( Color.rand );
w.front;
)
::

method:: top
Get the current top indentation or manually set it.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
d.top_(50); //manually set the new indentation
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
w.front;
)
::

method:: shift
Set the current left and top indentation (see above).

method:: maxHeight
Get/set maximium height of the subviews in the current position.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
"first row maxHeight: " ++ d.maxHeight.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
"second row maxHeight: " ++ d.maxHeight.postln;
w.front;
)
::

method:: maxRight
Get/set maximium right of the subviews in the current position.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
"first row maxRight: " ++ d.maxRight.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
"second row maxRight: " ++ d.maxRight.postln;
w.front;
)
::

method:: currentBounds
Gets a link::Classes/Rect:: with code::bounds.width:: and code::height = top + maxHeight::.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 10@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
d.currentBounds.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.currentBounds.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.currentBounds.postln;
w.front;
)
::

method:: used
Gets a link::Classes/Rect:: with the space actually used.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
d.used.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.used.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.used.postln;
w.front;
)
::

method:: reset
Resets the layout mechanism to 0,0.



TITLE:: FlowVar
summary:: A place holder, which when accessed pauses a thread until the place holder has a value
categories::Scheduling
related:: Classes/Ref, Classes/Thunk, Classes/Condition, Classes/Routine

DESCRIPTION::


code::
(
a = FlowVar.new;
fork {
	"I am waiting, please enter a value ...".postln;
	a.value.postln;
	"...... ok, done.".postln;
}
)

// later, set the value. Then we can continue ...
a.value = 2;
::


CLASSMETHODS::

METHOD:: new
Return a new instance,

ARGUMENT:: inVal
If a value is given here, the FlowVar will not block execution.


INSTANCEMETHODS::


METHOD:: value
Set the value bound to the FlowVar.

The getter returns the value bound to the FlowVar. If the value is not yet available, hold execution (this requires the method to be called from within a link::Classes/Routine:: or similar thread.).


ARGUMENT:: inVal
Any object.



CLASS:: FlowView
summary:: CompositeView with a FlowLayout as decorator
categories:: GUI>Views
related:: Classes/FlowLayout, Classes/CompositeView

DESCRIPTION::
In the simplest respect this is a lazy contraction of this:
code::
w = GUI.window.new;
w.view.decorator = FlowLayout.new(w.bounds);
w.front;
::

link::Classes/FlowView:: add some features to this setup.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

// the StartRow will be fixed at this point in the children array
f.startRow;

GUI.slider.new(f, Rect(0,0,100,100));
f.startRow;

GUI.slider.new(f, Rect(0,0,100,100));
)
::


CLASSMETHODS::

METHOD:: new

argument:: parent
Parent widget.

argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating width@height.

argument:: margin
...
argument:: gap
...
argument:: windowTitle
Title of the window.


INSTANCEMETHODS::

METHOD:: startRow
Start a new row.

METHOD:: indentedRemaining
The maximum space that is left, starting at the current cursor position.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)

(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.startRow; // new row

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)

(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)
::

METHOD:: used
The area used so far, rounded up to the nearest rectangle plus margin.
code::
(
w = GUI.window.new;
w.front;
f = FlowView.new(w);
f.background = Color.blue(alpha:0.1);

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.used.postln;

// overlaid
GUI.compositeView.new(w,f.used)
	.background = Color.red(alpha: 0.1);
)

(
w = GUI.window.new;
w.front;
f = FlowView.new(w);
f.background = Color.blue(alpha:0.1);

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.startRow; // new row

GUI.slider.new(f, Rect(0,0,100,100));

f.used.postln;

// overlaid
GUI.compositeView.new(w,f.used)
	.background = Color.red(alpha: 0.1);
)
::

METHOD:: flow
Insert a sub flow view into the current view.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));

// flow within a flow
g = f.flow({ arg g;
	ActionButton(g,"a");
	GUI.slider.new(g,Rect(0,0,100,100)).background_(Color.rand);
}).background_(Color.black); // shrinks to fit the contents afterwards
)
::

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

METHOD:: comp
Insert a sub composite view into the current view.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));

// SuperCollider composite view
g = f.comp({ arg g;
	GUI.slider.new(g, Rect(50,30,50,100)).background_(Color.rand);
	GUI.slider.new(g, Rect(120,30,50,100)).background_(Color.rand);
},Rect(0, 0, 200, 200)).background_(Color.black);

f.startRow;
"Back to flowing".gui(f);
)
::

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)


EXAMPLES::

code::
// note: some of the following examples use ActionButton from the crucialib

// tests
(
FlowView.new.flow({ arg f;
//	b = ActionButton(f,"hi",minWidth:140)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	b = ActionButton(f,"hi",minWidth:140);
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	b = GUI.slider.new(f,Rect(0,0,100,100));
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		//b = ActionButton(f,"hi",minWidth:140)
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = ActionButton(f,"hi",minWidth:140)
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		b = ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		b = ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = ActionButton(f,"hi",minWidth:140);
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
	}).background_(Color.white)
}).background_(Color.grey)
)

(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = GUI.slider.new(f,Rect(0,0,140,20));
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
		b = GUI.slider.new(f,Rect(0,0,140,20));
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
}).background_(Color.grey)
)


(
a = FlowView.new.flow({ arg f;
	g = f;
	w = f.flow({ arg f;
		b = f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)

)

b.remove(true);
w.resizeToFit(true,true);


// add something big back in
ActionButton(w,"i'm back",minWidth: 200);
w.resizeToFit(true,true);
// slightly wrong size at the bottom
::


class:: Fold
summary:: Fold a signal outside given thresholds.
related:: Classes/Clip, Classes/Wrap
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#fold2#fold2:: in that it
allows one to set low and high thresholds.


classmethods::

method::ar, kr

argument::in
Signal to be folded.

argument::lo
Low threshold of folding. Sample values < lo will be folded. must be less then hi.

argument::hi
High threshold of folding. Sample values > hi will be folded. must be greater then lo.


Examples::

code::
s.boot;

{ Fold.ar(SinOsc.ar(440, 0, 0.2), -0.1, 0.1) }.scope;
::



class:: FoldIndex
summary:: Index into a table with a signal.
related:: Classes/Index, Classes/Shaper
categories::  UGens>Buffer


Description::

The input signal value is truncated to an integer value and used as an
index into the table. Out-of-range index values are folded into
the valid range.


classmethods::

method::ar, kr

argument::bufnum

Index of the buffer.


argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// indexing into a table
(
{
	var buf = LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]);
	var freq = FoldIndex.kr(buf, MouseX.kr(0, BufFrames.ir(buf) * 3));
	SinOsc.ar(freq) * 0.1
}.play;
)

// the same using a global buffer
(
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_Index, { |out=0, bufnum=0|
	Out.ar(out,
		SinOsc.ar(
			FoldIndex.kr(
				bufnum,
				MouseX.kr(0, BufFrames.ir(bufnum) * 3)
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b.bufnum]);
)

::


class:: Font
summary:: A font object
categories:: GUI>Accessories

description::
This is the object you pass to other gui objects to set their font name or size.


classmethods::

private::key

method:: new


argument:: name
An instance of link::Classes/String::. Must coincide with the name of a font on the system. See link::#*availableFonts::.

argument:: size
An instance of link::Classes/Float::.

argument:: bold
A Boolean.

argument:: italic
A Boolean.

argument:: usePointSize
A Boolean. Whether to regard the strong::size:: argument as point-size - adapting to the screen resolution.

discussion::
Example:
code::
g = Font("Helvetica", 12);
::

method:: availableFonts
returns::
link::Classes/Array:: of the available fonts.

method:: antiAliasing
argument:: flag
An instance of link::Classes/Boolean::. Default value is code::false::.

method:: smoothing
argument:: flag
An instance of link::Classes/Boolean::. Default value is code::false::.

method:: defaultSansFace
returns::
The default sans serif face Font.

method:: defaultSerifFace
returns::
The default serif face Font.

method:: defaultMonoFace
returns::
The default monospace face Font.

method:: default
The global default Font.

Setting this property is equivalent to code::Font.setDefault(font)::. See link::#*setDefault:: for details.

method:: setDefault
Sets the global default font. Properties of the code::font:: argument will be combined with properties of the default system font, and those of individual views.

Optionally, a class can be given, so only views of that class will be affected.

Note that this will immediately affect any existing views.

argument:: font
An instance of Font.

argument:: class
A Class (either View or one of its subclasses), or code::nil::.

method:: sansSerif
Create a new sans serif face Font.

method:: monospace
Create a new monospace face Font.

method:: serif
Create a new serif face Font.

instancemethods::

method:: name
Gets/sets the name of the font.
argument:: value
An instance of link::Classes/String::.

method:: size
Gets/sets the size of the font.
Setting this variable is always considered as setting the link::#-pixelSize::, while getting it will return any size set. See link::#-hasPointSize:: for distinction.

argument:: pixelSize
A Float.

method:: hasPointSize
A Boolean variable indicating whether the link::#-size:: is regarded as pixel-size (precise amount of pixels), or point-size (adapting to screen resolution).
To change this, you need to set the size via link::#-pixelSize:: or link::#-pointSize::.

method:: pixelSize
Gets or sets the pixel-size of the font. When getting, returns nil if the font has point-size instead. See link::#-hasPointSize:: for distinction.
Argument::
	Any number, but note that floats will be rounded to integer values when setting pixel-size.


method:: pointSize
Gets or sets the point-size of the font. When getting, returns nil if the font has pixel-size instead. See link::#-hasPointSize:: for distinction.
Argument::
	A Float.

method:: setDefault
Makes this instance of Font the default.

This is equivalent to calling link::#*setDefault:: with this Font and the given class as arguments.


method:: storeArgs
(?)
Returns:: an link::Classes/Array::, code:: [ name, size ] ::.

method:: boldVariant

note:: On the Cocoa GUI it appends teletype::"-Bold":: to the name. This is only useful for fonts that have bold
variants.
::
returns::
Bold variant of the Font.


examples::

code::
(
w = Window.new.front;
t = StaticText(w, w.view.bounds).align_(\center);
t.string=" SUPERCOLLIDER";
)
t.font = Font("Monaco", 24);


(
var updateFont, w, m, y, t, a, b, c;
w = Window("Fonts", Rect(150, Window.screenBounds.height - 500, 400, 400)).front;
w.view.decorator = FlowLayout(w.view.bounds);
StaticText.new(w, Rect(5, 0, 30, 20)).string_("Font").align_(\right);
m = PopUpMenu(w, Rect(40, 0, 250, 20));
m.items = Font.availableFonts;

StaticText.new(w, Rect(290, 0, 28, 20)).string_("Size").align_(\right);
y = PopUpMenu(w, Rect(322, 0, 50, 20));
y.items = ["6","7","8","9","10","12","13","14","18","24","36","48","60","72","96"];

t = TextView(w, Rect(10, 40, 380, 150));
t.string = "\nThe quick drowned fox jumped over the lazy blog. \n\n 0 1 2 3 4 5 6 7 8 9 ";

a = StaticText(w, 200@20).string_("The quick drowned fox").background_(Color.rand).align_(\center);
b = Button(w, 200@20).states_([["The quick drowned fox"]]).background_(Color.rand);
c = PopUpMenu(w, 200@20).items_(["The quick drowned fox"]).background_(Color.rand);

y.action = {
	var font;
	font = Font(m.items[m.value],y.items[y.value].asInteger);
	a.font_(font).refresh;
	b.font_(font).refresh;
	c.font_(font).refresh;
	t.font_(font).refresh;
};

m.action = y.action;

m.valueAction = 3;
y.valueAction = 5;
)


(
var w, f;

w = Window("Fonts", Rect(128, 64, 340, 360));
w.view.decorator = f = FlowLayout(w.view.bounds,Point(4, 4),Point(4, 2));

[
"Helvetica-Bold",
"Helvetica",
"Monaco",
"Arial",
"Gadget",
"MarkerFelt-Thin"
].do({ arg name;
	var v, s, n, height = 16;

		v = StaticText(w, Rect(0, 0, 110, height + 20));
		v.font = Font(name, 13);
		v.string = name;

		s = Button(w, Rect(0, 0, 140, height + 20));
		s.font = Font(name, 13);
		s.states = [[name]];

		n = NumberBox(w, Rect(0, 0, 56, height + 20));
		n.font = Font(name, 13);
		n.object = pi;

	f.nextLine;
});

w.front;
)


(
var w, b, f, i = 0;

w = Window("Fonts", Rect(128, 64, 1024, 768));
b = ScrollView(w, w.view.bounds);

b.decorator = f = FlowLayout(b.bounds, Point(4,4), Point(4,2));

Font.availableFonts.do({ arg name;
	var v, s, n, height = 16, font;
	font = Font(name,13);

		v = StaticText(b, Rect(0, 0, 120, height + 20));
		v.font = font;
		v.string = name;

		s = Button(b, Rect(0, 0, 140, height + 20));
		s.font = font;
		s.states = [[name]];
		s.action = { font.asCompileString.postln; };

		n = NumberBox(b, Rect(0, 0, 56, height + 20));
		n.font = font;
		n.object = pi;
	if( (i = i + 1) % 3 == 0,{
		f.nextLine;
	});
});

w.front;
)
::


class:: Formant
summary:: Formant oscillator
categories::  UGens>Generators>Deterministic


Description::

Generates a set of harmonics around a formant frequency at a given
fundamental frequency.


classmethods::

method::ar

argument::fundfreq
Fundamental frequency in Hertz. (control rate)

argument::formfreq
Formant frequency in Hertz. (control rate)

argument::bwfreq
Pulse width frequency in Hertz. Controls the bandwidth of the
formant. (control rate)

Must be greater than or equal to code::fundfreq::.

argument::mul

argument::add

discussion::
The frequency inputs are read at control rate only, so if you use an audio rate UGen as an input, it will only be sampled at the start of each audio synthesis block.


Examples::

code::
// modulate fundamental frequency, formant freq stays constant
{ Formant.ar(XLine.kr(400,1000, 8), 2000, 800, 0.125) }.play

// modulate formant frequency, fundamental freq stays constant
{ Formant.ar(200, XLine.kr(400, 4000, 8), 200, 0.125) }.play

// modulate width frequency, other freqs stay constant
{ Formant.ar(400, 2000, XLine.kr(800, 8000, 8), 0.125) }.play
::


class:: Formlet
summary:: FOF-like filter.
related:: Classes/RHPF, Classes/RLPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

This is a resonant filter whose impulse response is like that of a sine
wave with a  link::Classes/Decay2::  envelope over it. It is possible to
control the attacktime and decaytime.

Formlet is equivalent to:
code::
Ringz(in, freq, decaytime) - Ringz(in, freq, attacktime)
::

The great advantage to this filter over FOF is that there is no limit to
the number of overlapping grains since the grain is just the impulse
response of the filter.

Note::
The amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.
::


classmethods::

method::ar, kr

argument::in
The input signal.

argument::freq
Resonant frequency in Hertz.

argument::attacktime
60 dB attack time in seconds.

argument::decaytime
60 dB decay time in seconds.

argument::mul

argument::add

discussion::
Note that if attacktime == decaytime then the signal cancels out and if
attacktime > decaytime then the impulse response is inverted.


Examples::

code::
{ Formlet.ar(Impulse.ar(20, 0.5), 1000, 0.01, 0.1) }.play;

{ Formlet.ar(Blip.ar(XLine.kr(10,400,8), 1000, 0.1), 1000, 0.01, 0.1) }.play;

(
// modulating formant frequency
{
	var in;
	in = Blip.ar(SinOsc.kr(5,0,20,300), 1000, 0.1);
	Formlet.ar(in, XLine.kr(1500,700,8), 0.005, 0.04);
}.play;
)

(
// mouse control of frequency and decay time.
{
	var in;
	in = Blip.ar(SinOsc.kr(5,0,20,300), 1000, 0.1);
	Formlet.ar(in,
		MouseY.kr(700,2000,1),
		0.005, MouseX.kr(0.01,0.2,1));
}.play;
)

(
// mouse control of frequency and decay time.
{
	var freq;
	freq = Formlet.kr(
		Dust.kr(10 ! 2),
		MouseY.kr(7,200,1),
		0.005, MouseX.kr(0.1,2,1)
	);
	SinOsc.ar(freq * 200 + [500, 600] - 100) * 0.2
}.play;
)
::



class::Frame
summary:: Stack Frame
categories:: Core>Kernel


description::
Frames are used to contain the arguments, variables and other information for active Functions.

There are no instance variables or methods.

Since Frames are often created on the stack, it is too dangerous to allow access to them. Dangling pointers could result.

Frame instances are inaccessible to the user.

For error handling routines, the relevant information from a Frame can be transferred into a DebugFrame object which can safely be inspected.

code::
	this.getBackTrace.inspect
::




class:: Free
summary:: When triggered, frees a node.
related:: Classes/Pause, Classes/FreeSelf
categories::  UGens>Synth control

Description::
When triggered, frees a node.

classmethods::

method::kr

argument::trig
Trigger input

argument::id
Node to be freed.


Examples::

code::
s.boot;

SynthDef("a", { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).add;

SynthDef("b", { arg t_t=0; Out.ar(1, PinkNoise.ar(0.3)); Free.kr(t_t, 1001); }).add;

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\s_new, \b, 1002, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);
::



class:: FreeSelf
summary:: When triggered, free enclosing synth.
related:: Classes/PauseSelf, Classes/Free
categories::  UGens>Synth control


Description::
Free enclosing synth when input signal crosses from non-positive to
positive.


classmethods::

method::kr

argument::in

The input signal.


Examples::

code::
(
SynthDef("freeSelf-help", { arg out, t_trig;
	FreeSelf.kr(t_trig);
	Out.ar(out, SinOsc.ar(400,0,0.2));
}).add;
)

s.sendMsg("/s_new", "freeSelf-help", 1731);
s.sendMsg("/n_set", 1731, \t_trig, 1);

// a single impulse SynthDef:

(
SynthDef("dirac", { arg out, amp=0.1;
	var u;
	u = Impulse.ar(1);
	FreeSelf.kr(u);
	Out.ar(out, u * amp);
		// multiply by amp after using for release, so amp = 0
		// doesn't cause synth buildup.
}).add;
)

(
Task {
	loop({
		fork {
			exprand(34, 156).do {|i|
				i = i + 1;
				s.sendMsg("/s_new", "dirac", -1,0,0, \amp, 1 / i);
				(0.006 * i).wait;
			};
		};
		1.wait;
	})
} .play;
)
::



class:: FreeSelfWhenDone
summary:: Free the enclosing synth when a UGen is finished
related:: Classes/Done, Classes/PauseSelfWhenDone, Classes/Done
categories::  UGens>Synth control

Description::

Some UGens set a 'done' flag when they are finished playing.
FreeSelfWhenDone will free the enclosing synth when this flag is set to true.

See link::Classes/Done:: for a complete list of these UGens.

Note that many of these UGens have doneActions, which are another way of accomplishing the same thing. See link::Classes/Done:: for more detail.

note:: One must be careful when using binary operations on UGens with done flags, as these will return a link::Classes/BinaryOpUGen::, and thus prevent the done flag from being accessible. See example below. ::

classmethods::
private:: categories

method::kr

argument::src

the UGen to check for done.

examples::
code::
s.boot;

// simple example
(
{ var env;
env = Line.kr(0, 1, 1);
FreeSelfWhenDone.kr(env); // free synth at end of line
SinOsc.ar(200, 0, 0.5) * env
}.play;
)

// the previous example works, because FreeSelfWhenDone operates on the Line
// this version won't work
(
{ var env, output;
env = Line.kr(0, 1, 1);
output = SinOsc.ar(200, 0, 0.5) * env;
output.postln; // output is a BinaryOpUGen, which has no 'done' flag
FreeSelfWhenDone.kr(output); // won't ever be done
output
}.play;
)

// record for four seconds
b = Buffer.alloc(s, 44100 * 4.0, 1);
(
SynthDef("help-RecordBuf",{ arg out=0,bufnum=0;
	var formant, recbuf;
	formant = Formant.ar(XLine.kr(400,1000, 4), 2000, 800, 0.125);
	recbuf = RecordBuf.ar(formant, bufnum, recLevel: Line.kr(1, 1), loop: 0);
	// The RecordBuf doesn't loop, so you can check it for 'done' status
	FreeSelfWhenDone.kr(recbuf);
}).play(s,[\out, 0, \bufnum, b]);
)

// play it back
(
SynthDef("help-RecordBuf play",{ arg out=0,bufnum=0;
	var playbuf;
	playbuf = PlayBuf.ar(1,bufnum);
	FreeSelfWhenDone.kr(playbuf); // frees the synth when the PlayBuf is finished
	Out.ar(out, playbuf);
}).play(s,[\out, 0, \bufnum, b]);
)
::



class:: FreeVerb
summary:: A reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb2, Classes/GVerb

description::
Coded from experiments with faust.

classmethods::

method:: ar
argument:: in
input signal.
argument:: mix
dry/wet balance. range 0..1.
argument:: room
room size. rage 0..1.
argument:: damp
Reverb HF damp. range 0..1.
argument:: mul
argument:: add

discussion::
Valid parameter range from 0 to 1. Values outside this range are clipped by the UGen.

examples::
code::
s.boot;

// FreeVerb - 1x1 ugen
(
z = SynthDef(\src, { |out, mix = 0.25, room = 0.15, damp = 0.5|
	Out.ar(out,
		FreeVerb.ar(
			Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)), // mono src
			mix, // mix 0-1
			room, // room 0-1
			damp // damp 0-1 duh
		) ! 2 // fan out...
	);
}).play
)
z.set(\room, 0.7)
z.set(\mix, 0.4)
z.set(\damp, 0.2)

z.free

// it expands as any ugen does
(
z = SynthDef(\src, {|out, mix = 0.25, room = 0.15, damp = 0.5|
	Out.ar(out,
		FreeVerb.ar(
			Pan2.ar(
				Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)),
				LFNoise1.ar(1).range(-1, 1)
			),
			mix,
			room,
			damp
		)
	);
}).play
)
z.set(\room, 0.7)
z.set(\mix, 0.4)
z.set(\damp, 0.2)

z.free
::


class:: FreeVerb2
summary:: A two-channel reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb, Classes/GVerb

description::
Coded from experiments with faust.

classmethods::

method:: ar
argument:: in
input signal channel 1.
argument:: in2
input signal channel 2.
argument:: mix
dry/wet balance. range 0..1.
argument:: room
room size. rage 0..1.
argument:: damp
Reverb HF damp. range 0..1.
argument::mul
argument::add

discussion::
Valid parameter range from 0 to 1. Values outside this range are clipped by the UGen.

examples::
code::
s.boot;

// FreeVerb2 - demo synthdef
(
SynthDef(\FreeVerb2x2, { |out, mix = 0.25, room = 0.15, damp = 0.5, amp = 1.0|
	var signal;

	signal = In.ar(out, 2);

	ReplaceOut.ar(out,
		FreeVerb2.ar( // FreeVerb2 - true stereo UGen
			signal[0], // Left channel
			signal[1], // Right Channel
			mix, room, damp, amp
		)
	); // same params as FreeVerb 1 chn version

}).add;
)

// 2ch source
(
a = SynthDef(\src2x2, { |out|
	Out.ar(out,
		Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)) ! 2
		+
		Pan2.ar(
			Decay.ar(Impulse.ar(1, pi), 0.1, WhiteNoise.ar(0.1)),
			LFNoise1.kr(0.5).range(-1, 1)
		)
	)
}).play
)

// kick it in
z = Synth(\FreeVerb2x2, [\outbus, 0], addAction:\addToTail)
// experiment with some settings
z.set(\room, 0.7)
z.set(\mix, 0.33)
z.set(\damp, 0.9)

// silence
[a, z].do(_.free)

::


class:: FreqScope
summary:: Frequency spectrum visualizer
categories:: GUI>Interfaces
related:: Classes/FreqScopeView

description::
FreqScope shows the frequency spectrum of the specified audio bus. The scope will remain active after a command-period. To turn it off you must either click off the 'Power' button or close the window.

Panel commands:
table::
## Power || Turns the scope on and off. This is useful for freezing the signal on the display or for saving CPU.
## BusIn || The audio bus to be analyzed.
## FrqScl || Determines the mapping of frequencies on the x-axis. Can be linear (lin) or logarithmic (log). Logarithmic is equal spacing per musical octave.
## dbCut || Determines the lowest decibel shown on the y-axis.
::

ClassMethods::

method:: new
argument:: width
Default value is 512.
argument:: height
Default value is 300.
argument:: busNum
The number of the audio link::Classes/Bus:: to be monitored.
argument:: scopeColor
An instance of link::Classes/Color::. The drawing color of the scope.
argument:: bgColor
An instance of link::Classes/Color::. The background color of the scope.
argument:: server
the server whose buses to show on scope.
discussion::
Example:
code::
s.boot;

// create a new analyzer
FreqScope.new(400, 200, 0, server: s);

// basic sine
{ SinOsc.ar(2000, 0, 0.25) }.play(s);

// random saw
{ RLPF.ar(Saw.ar(110, 0.2), LFNoise2.kr(1,1e4,1e4), LFNoise2.kr(1, 0.2, 0.22)) }.play(s);

// modulate phase
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(20, 8000, 10), 0, 2pi), 0.25) }.play(s);

// all harmonics
{ Blip.ar(200, Line.kr(1, 100, 10), 0.2) }.play(s);
::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: scopeOpen
Returns a link::Classes/Boolean::, whether the scope is open.

InstanceMethods::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method::window
Returns the window in which the link::Classes/FreqScopeView:: is placed.

method:: scope
Returns the link::Classes/FreqScopeView::.


class:: FreqScopeView
summary:: Frequency analysis view
categories:: GUI>Views
related:: Classes/FreqScope

description::
FreqScopeView shows the frequency spectrum of a specified audio bus.

note::

The scope will remain active after a command-period. To turn it off you must use the 'active' method.
Very important: You must run code::kill():: when the parent window is closed to avoid problems. It also frees the buffers that the scope allocated and stops the FFT analysis synth. So:
code::
(
w = Window("My Analyzer", Rect(0, 0, 511, 300));
f = FreqScopeView(w, w.view.bounds);
w.onClose_({ f.kill }); // YOU MUST HAVE THIS
w.front;
)
::

::

classmethods::

private::initClass

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
argument:: server
The server to be shown in scope.

discussion::
Example:
code::
// Start server
s.boot;

// Create analyzer in a window
(
w = Window("My Analyzer", Rect(0, 0, 511, 300)); // width should be 511
f = FreqScopeView(w, w.view.bounds);
f.active_(true); // turn it on the first time;

w.onClose_({ f.kill }); // you must have this
w.front;
{ SinOsc.ar([500, 1000], 0, 0.25).mean.dup }.play(s); // start two sine waves
)
::

method:: response
Create a scope in a special frequency-response mode. This uses FFT-based spectral division to estimate the frequency response of some effect, on the assumption that the signal to bus1 is transformed to the signal at bus2 by some linear time-invariant process.
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
argument:: bus1
The bus on which the "pre" signal is found.
argument:: bus2
The bus on which the "post" signal is found.
argument:: freqMode
Linear (0) or log(1) frequency mode. Defaults to 1.
discussion::
Example:
code::
s.boot

// basic usage. try these. Each one will open a new window
// move the mouse left and right to test response in different ranges
LPF.scopeResponse
HPF.scopeResponse
MoogFF.scopeResponse
BBandPass.scopeResponse
BLowShelf.scopeResponse // by default BLowShelf doesn't mangle much
Resonz.scopeResponse
BRF.scopeResponse
Integrator.scopeResponse
Median.scopeResponse // nonlinear, and therefore interesting

// customize the parameters for more informative scoping
{|in| MoogFF.ar(in, freq: MouseX.kr(10, 10000, 1),
gain:MouseY.kr(4, 0))}.scopeResponse
::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

instancemethods::

method:: kill
Very important. This must be run when the parent window is closed to avoid problems. It also frees the buffers that the scope allocated and stops the FFT analysis synth.

method:: active
Turn the scope on or off.
argument:: bool
An instance of link::Classes/Boolean::.

method:: freqMode
argument:: mode
0 = linear, 1 = logarithmic.

method:: inBus
The bus to listen on.
argument:: num
An audio link::Classes/Bus:: number.

method:: dbRange
Get/set the amplitude range.
argument:: db
A link::Classes/Number::.

method:: special
Put the scope into a special mode using a user-specified link::Classes/SynthDef::. Note that only very particular SynthDefs should be used, namely ones that are derived from the code::\freqScope0:: or code::\freqScope1:: SynthDefs. Most users will not need to use this method directly, but it can be used to provide a customised analysis shown in the scope.
argument:: defname
Name of the link::Classes/SynthDef:: you wish to use.
argument:: extraArgs
Extra arguments that you may wish to pass to the synth.

subsection:: instance variables
method:: server
the server that is freqscoped
method:: synth
the synth running the freqscope analysis
method:: scope
the scopeview that shows the running analysis
method:: scopebuf
the buffer used by the scope

subsection:: Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these in subclasses as needed.

method:: initFreqScope
initialize and show on parent view
method:: doesNotUnderstand
redirects methods to scope view variable

method:: start
method:: allocBuffers
method:: freeBuffers
method:: bufSize
method:: doOnServerQuit
method:: doOnServerTree
method:: shmScopeAvailable
method:: specialSynthArgs
method:: specialSynthDef

examples::

code::
// Start server
s.boot;

// Create analyzer in a window
(
w = Window("My Analyzer", Rect(0, 0, 511, 300)); // width should be 511
f = FreqScopeView(w, w.view.bounds);
f.active_(true); // turn it on the first time;

w.onClose_({ f.kill }); // you must have this
w.front;
{ SinOsc.ar([500, 1000], 0, 0.25).mean.dup }.play(s); // start two sine waves
)

f.freqMode_(1); // change to log scale so we can see them
f.inBus_(1); // look at bus 1
f.dbRange_(200); // expand amplitude range
f.active_(false); // turn scope off (watch CPU)
f.active_(true); // turn it back on

// Now press command-period. The scope is still running.

{ Mix.ar(SinOsc.ar([500, 1200, 3000, 9000, 12000], 0, [0.2, 0.1, 0.05, 0.03, 0.01])) }.play(s); // restart some sines

// Close window and scope is killed.
::


class:: FreqShift
summary:: Frequency Shifter.
related:: Classes/Hilbert, Classes/HilbertFIR
categories::  UGens>Filters>Nonlinear, UGens>Filters>Pitch


Description::

FreqShift implements single sideband amplitude modulation, also known as
frequency shifting, but not to be confused with pitch shifting. Frequency
shifting moves all the components of a signal by a fixed amount but does
not preserve the original harmonic relationships.


classmethods::

method::ar

argument::in
The input signal.

argument::freq
Amount of shift in cycles per second.

argument::phase
Phase of the frequency shift (0..2pi).

argument::mul

argument::add


Examples::

code::
// shifting a 100Hz tone by 1 Hz rising to 500Hz
{FreqShift.ar(SinOsc.ar(100),XLine.kr(1,500,5),0,[0.1,0.1])}.play(s);

// shifting a complex tone by 1 Hz rising to 500Hz
{FreqShift.ar(Klang.ar(`[[101,303,606,808]]),XLine.kr(1,500,10),0,[0.1,0.1])}.play(s);

// modulating shift and phase
{FreqShift.ar(SinOsc.ar(10),LFNoise2.ar(0.3,1500),SinOsc.ar(500).range(0,2pi),[0.1,0.1])}.play(s);

// the ubiquitous houston example
(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
{FreqShift.ar(PlayBuf.ar(1,b.bufnum,BufRateScale.kr(b.bufnum),loop:1),LFNoise0.kr(0.45,1000),0,[1,1])}.play(s);
)

// shifting bandpassed noise
{FreqShift.ar(BPF.ar(WhiteNoise.ar(0.2),1000,0.001),LFNoise0.kr(5.5,1000),0,[32,32])}.play(s);
::

subsection:: More Examples
send a SynthDef, run the routine then send a different SynthDef

code::
// simple detune & pitchmod via FreqShift
(
SynthDef(\frqShift1, { |out, freq, detune=1.5|
	var e1, left, right;
	e1 = EnvGen.ar(Env.new([0, 0.1, 0], [1, 2.3]),1, doneAction: Done.freeSelf);
	left = SinOsc.ar(freq, 0, e1); // original tone
	left = left + FreqShift.ar(left, freq * detune); // shift and add back to original
	right = FreqShift.ar(left, SinOsc.kr(3.23, 0, 5));
	Out.ar(out, [left,right] * 0.1);
}).add;
)

// the routine
(
r = Routine({
	var table,pitch;
	table = [0,2,4,5,7,9,11,12];
	inf.do {
		pitch = (48+(12*2.rand) + table.choose).midicps;
		Synth.grain(\frqShift1, [\freq, pitch]);
		3.wait;
	};
}).play;
)

// shift pulse wave in opposite directions
(
SynthDef(\frqShift1, { |out, freq, detune=0.15|
	var e1, snd, left, right;
	e1 = EnvGen.ar(Env.new([0, 1, 0],[0.02, 3.2]), 1, doneAction: Done.freeSelf);
	snd = Pulse.ar(freq, SinOsc.kr(2.3).range(0.2,0.8), e1); // original tone
	left = FreqShift.ar(snd,XLine.kr(-0.1,-200,2)); // shift and add back to original
	right = FreqShift.ar(snd,XLine.kr(0.1,200,2));
	Out.ar(out, [left, right] * 0.1);
}).add
)

// FreqShift >> feedback >>> FreqShiftc
(
SynthDef("frqShift1", { |out, freq|
	var e1,snd,snd2,in;
	in = FreqShift.ar(InFeedback.ar(0, 1) * 3.2, XLine.ar(0.01, freq * 1.5, 1)); // shift the feedback
	e1 = Env.new([0, 0.1, 0], [0.02, 2.98]);
	snd = SinOsc.ar(freq, 0, EnvGen.ar(e1, 1, doneAction: Done.freeSelf));
	snd2 = FreqShift.ar(snd+in, SinOsc.ar(4.24, 0.5, 3), 0, 0.5); // subtle modulating shift
	OffsetOut.ar(0, Limiter.ar(snd2 + snd * 0.5, 1, 0.005) ! 2);
}).add;
)


// ssllooww columbia tuned shift detune
(
r.stop; // stop old routine
Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", bufnum:99);

SynthDef(\frqShift1, { |out, freq, bufnum|
	var e1,snd,left,right;
	e1 = Env.new([0,1,0], [3,1], -4);
	snd = PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * 0.01, loop:1);
	// subtle shift of the output
	left = FreqShift.ar(snd, freq * 2, 0, EnvGen.ar(e1, 1, doneAction: Done.freeSelf));
	right = FreqShift.ar(snd, freq * 3, 0, EnvGen.ar(e1, 1, doneAction: Done.freeSelf));
	Out.ar(out, [left, right] * 3);
}).add;
)

// the routine
(
r = Routine({
	var table, pitch;
	table = [0,2,4,5,7,9,11,12];
	inf.do{
		pitch = (48+(12*2.rand) + table.choose).midicps;
		s.sendMsg(\s_new, \frqShift1, -1, 1, 1, \freq, pitch, \bufnum, 99);
		3.wait;
		};
	}).play
)
::



class:: FuncFilterPattern
summary:: Abstract class that filters a pattern using a function
related:: Classes/FilterPattern
categories:: Streams-Patterns-Events>Patterns>Filter

description::
This is an abstract class that filters a pattern using a function. See subclasses below:

classtree::FuncFilterPattern



TITLE:: FuncStream
summary:: Stream of a function
categories:: Streams-Patterns-Events
related:: Classes/Pfunc

DESCRIPTION::
FuncStream is one of the most basic ways to describe a stream: it has a function that is called for each next stream value.

code::
// make a stream that returns a random number
a = FuncStream({ 1.0.rand });
a.next;
::

It uses link::Classes/Function#-inEnvir:: to statically bind the function call to the environment in which the code::FuncStream:: was created.

code::
a = Environment.use { ~x = 100; FuncStream({ ~x + 8 }) };
~x = 0;
a.next; // returns 108, not 8.
::


CLASSMETHODS::

METHOD:: new
Return a new stream object.

code::
(
var func, reset, count = 0;
func = { count = count + 2.rand };
reset = { count = 0 };
a = FuncStream(func, reset);
)

a.next;
a.nextN(80).plot;
a.reset;
a.next; // starts again.

::

argument:: nextFunc
The function that is called on each next
argument:: resetFunc
The function that is called on reset


INSTANCEMETHODS::

PRIVATE::storeArgs

METHOD:: next
argument:: inval

Return the next value by calling the function. code::inval:: is passed
as an argument to the function.

METHOD:: reset

Call the reset function, if defined.

METHOD:: envir

Get or set the environment to which the function has been bound.

METHOD:: nextFunc

Get or set the function which is called on link::#-next::.

METHOD:: resetFunc

Get or set the function which is called on link::#-reset::.

EXAMPLES::

code::
(
// create 16 different series
a = {
	var diff = [2, 4, 5].choose * [1, -1].choose;
	var val = 0;
	var stream = FuncStream({
		// next function
		val = val + diff;
		if(abs(val) > 30) { stream.reset };
		val
	}, {
		// reset function
		val = 0
	});
	stream
}.dup(16);

// play them as parallel notes
fork {
	loop {
		(
			note: a.collect { |f| f.next.postln },
			sustain: 0.1
		).play;

		// reset a randomly chosen FuncStream
		a.choose.reset;
		0.16.wait;
	}
}
)
::



class::Function
summary::Implements a function
categories::Core>Kernel
related::Classes/FunctionDef

description::
A Function is a reference to a FunctionDef and its defining context Frame. When a FunctionDef is encountered in your code it is pushed on the stack as a Function. A Function can be evaluated by using the 'value' method. See the Functions help file for a basic introduction.

Because it inherits from AbstractFunction, Functions respond to math operations by creating a new Function.

code::
// example
(
var a, b, c;
a = { [100, 200, 300].choose };	// a Function
b = { 10.rand + 1 };	// another Function
c = a + b; 	// c is a Function.
c.value.postln;	// evaluate c and print the result
)
::

See link::Classes/AbstractFunction#Function Composition:: for function composition examples.

Because Functions are such an important concept, here some examples from related programming languages with functions as first class objects:

code::
// returning the first argument itself:
{ |x| x }.value(1) // SuperCollider
[:x | x ] value: 1 // Smalltalk
((lambda (x) x) 1) // Lisp
::

subsection:: Related Keywords

method:: thisFunction
The global pseudo-variable code::thisFunction:: always evaluates to the current
enclosing Function.

note::
Be aware of link::Reference/Control-Structures#Inline
optimization#inline optimizations:: which will be reflected in the value of
code::thisFunction::.
::

See also: link::Classes/FunctionDef#.thisFunctionDef#thisFunctionDef::


classMethods::

private::new

instancemethods::

subsection::Access

method::def

Get the definition ( FunctionDef ) of the Function.

method::isClosed

returns true if the function is closed, i.e. has no external references and can thus be converted to a compile string safely.

subsection::Evaluation

method::value

Evaluates the FunctionDef referred to by the Function. The Function is passed the args given.

code::
{ |a, b| (a * b).postln }.value(3, 10);
{ arg a, b; (a * b).postln }.value(3, 10); // different way of expressing the same
::

method::valueArray

Evaluates the FunctionDef referred to by the Function. If the last argument is an Array or List, then it is unpacked and appended to the other arguments (if any) to the Function. If the last argument is not an Array or List then this is the same as the 'value' method.

code::
{ |a, b, c| ((a * b) + c).postln }.valueArray([3, 10, 7]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray([1, 2, 3]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray(9, [1, 2, 3]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray(9, 10, [1, 2, 3]);
::

A common syntactic shortcut:

code::
{ |a, b, c| ((a * b) + c).postln }.value(*[3, 10, 7]);
::

method::valueEnvir

As value above. Unsupplied argument names are looked up in the current Environment.

code::
(
Environment.use({
~a = 3;
~b = 10;
{ |a, b| (a * b).postln }.valueEnvir;
});
)
::

method::valueArrayEnvir

Evaluates the FunctionDef referred to by the Function. If the last argument is an Array or List, then it is unpacked and appended to the other arguments (if any) to the Function. If the last argument is not an Array or List then this is the same as the 'value' method. Unsupplied argument names are looked up in the current Environment.


method::valueWithEnvir

Evaluate the function, using arguments from the supplied environment. This is slightly faster than valueEnvir and does not require replacing the currentEnvironment.

code::
(
e = Environment.make({ ~a = 3; ~b = 10 });
{ |a, b| (a * b) }.valueWithEnvir(e);
)
::

method::functionPerformList

For Function, this behaves the same as valueArray(arglist). It is used  where Functions and other objects should behave differently to value, such as in the object prototyping implementation of Environment.


method::performWithEnvir

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performWithEnvir(\value, (a: 1, c: 3, d: 4, b: 2));
::

argument::selector
A Symbol representing a method selector.
argument::envir
The remaining arguments derived from the environment and passed as arguments to the method named by the selector.

method::performKeyValuePairs

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performKeyValuePairs(\value, [\a, 1, \b, 2, \c, 3, \d, 4]);
::

argument::selector
A Symbol representing a method selector.
argument::pairs
Array or List with key-value pairs.


method::loop

Repeat this function. Useful with Task and Clocks.

code::
t = Task({ { "I'm loopy".postln; 1.wait;}.loop });
t.start;
t.stop;
::

method::defer

Delay the evaluation of this Function by code::delta:: in seconds on AppClock.

This is equivalent to code::AppClock.sched(0, function):: unless code::delta:: is code::nil::. In that case the function is only scheduled if current code is not running on AppClock, otherwise the function is evaluated immediately.

code::
{ "2 seconds have passed.".postln; }.defer(2);

(
{ "chicken".postln }.defer(0); // schedules on the AppClock
{ "egg".postln }.defer // evaluates immediately
)

(
fork { // schedules on a TempoClock
    { "chicken".postln }.defer // schedules on the AppClock
};
{ "egg".postln }.defer // evaluates immediately
)
::

method::dup

Return an Array consisting of the results of n evaluations of this Function.

code::
x = { 4.rand; }.dup(4);
x.postln;
::

method::!

equivalent to dup(n)

code::
x = { 4.rand } ! 4;
x.postln;
::

method::sum

return the sum of n values produced.

code::
{ 4.rand }.sum(8);
::

method::choose

evaluates the function. This makes it polymorphic to SequenceableCollection, Bag and Set.

code::
[{ 100.rand }, [20, 30, 40]].collect(_.choose);
::

method::bench

Returns the amount of time this function takes to evaluate. print is a boolean indicating whether the result is posted. The default is true.

code::
{ 1000000.do({ 1.0.rand }); }.bench;
::

method::fork

Returns a Routine using the receiver as it's function, and plays it in a TempoClock.

code::
{ 4.do({ "Threading...".postln; 1.wait;}) }.fork;
::

method::forkIfNeeded

If needed, creates a new Routine to evaluate the function in, if the message is called within a routine already, it simply evaluates it.

code::
f = { 4.do({ "Threading...".postln; 1.wait;}) };
f.forkIfNeeded;
{ "we are now in a routine".postln; 1.wait; f.forkIfNeeded }.fork;
::

method::block

Break from a loop. Calls the receiver with an argument which is a function that returns from the method block. To exit the loop, call .value on the function passed in. You can pass a value to this function and that value will be returned from the block method.

code::
block {|break|
	100.do {|i|
		i.postln;
		if (i == 7) { break.value(999) }
	};
}
::

method::thunk

Return a Thunk, which is an unevaluated value that can be used in calculations

code::
x = thunk { 4.rand };
x.value;
x.value;
::

method::flop

Return a function that, when evaluated with nested arguments, does multichannel expansion by evaluating the receiver function for each channel. A flopped function responds like the "map" function in languages like Lisp. The new function always returns an array.

code::
// multichannel expansion for if, here to protect from division by zero:
f = { |a, b| if(b != 0) { a / b } { 0 } }.flop;
f.value([1, 2, 3, 4], [0, 10, 1000]); //  -> [ 0, 0.2, 0.003, 0 ]
f.value(2, 4); // [ 0.5 ] (always returns an array)

// strings don't expand
f = { |a, b| a + b }.flop;
f.("hello", ["world", "algorithm"]); // -> [ hello world, hello algorithm ]
f.("hello", "world"); // -> [ hello world ]

::

method::flop1

Same as link::#flop::, return only an array if the arguments also contains an array. This can be used to implement link::Guides/Multichannel-Expansion::.

code::
// multichannel expansion for if, here to protect from division by zero:
f = { |a, b| if(b != 0) { a / b } { 0 } }.flop1;
f.value([1, 2, 3, 4], [0, 10, 1000]); //  -> [ 0, 0.2, 0.003, 0 ]
f.value([2], 4); // -> [0.5]
f.value(2, 4); // -> 0.5

// strings don't expand, like in flop
f = { |a, b| a + b }.flop1;
f.("hello", ["world", "algorithm"]); // -> [ hello world, hello algorithm ]
f.("hello", "world"); // -> hello world

::



method::envirFlop

This method is kept for backward compatibility. Use code::flop:: instead.


method::inEnvir

returns an "environment-safe" function. See Environment for more details.
Note that the function returned takes no keyword arguments.

code::
e = (a: "get it", b: "didn't");
f = { ~b + ~a + "..." }.inEnvir(e);
f.value;

f = { |how = "", end = "..."| how + ~b + ~a + end }.inEnvir(e); // doesn't work with keyword arguments
f.value(how: "really"); // WARNING: keyword arg 'how' not found in call to function (see inEnvirWithArgs).



// a use case: defer is usually called in the call environment
// prints nil because ~a is read from topEnvironment, not e
e = (a: "got it", f: { { ~a.postln }.defer(0.5) });
e.use { e.f };

// prints "got it" because { ~a.postln } is now bound to the e environment
e = (a: "got it", f: { { ~a.postln }.inEnvir.defer(0.5) });
e.use { e.f };
::


method::inEnvirWithArgs

Like link::#inEnvir::, but returns a function which takes keyword arguments.
Building this function makes a call to the interpreter and is less efficient than inEnvir

code::
e = (a: "get it", b: "didn't");
f = { |how = "", end = "..."| how + ~b + ~a + end }.inEnvirWithArgs(e);
f.value(how: "I really", end: "done!");
::


method::case

Function implements a case method which allows for conditional evaluation with multiple cases. Since the receiver represents the first case this can be simply written as pairs of test functions and corresponding functions to be evaluated if true. Unlike Object-switch, this is inlined and is therefore just as efficient as nested if statements.

code::
(
var i, x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
i = z.choose;
x = case
	{ i == 1 }   { \no }
	{ i == 1.1 } { \wrong }
	{ i == 1.3 } { \wrong }
	{ i == 1.5 } { \wrong }
	{ i == 2 }   { \wrong }
	{ i == 0 }   { \true };
x.postln;
)
::

method::matchItem

Interface shared with other classes that implements pattern matching. See also: matchItem.
Function.matchItem evaluates the function with the item as argument, expecting a Boolean as reply.

See also link::Reference/matchItem::.

code::
{ |x| x > 5 }.matchItem(6); // true
::


method::performDegreeToKey

use a function as a conversion from scale degree to note number. See also SequenceableCollection and Scale

code::
// a strange mapping
(
var f = {|degree, stepsPerOctave, acc|
	(1.8 ** (degree % stepsPerOctave) + acc).postln
};
Pbind(
	\scale, f,
	\degree, Pseq([0, 1, 2b, 3s, 4s, 6, 14, [0, 2, 4], [1, 3, 6]], inf)
).play
)
::

subsection::Exception Handling

For the following two methods a return ^ inside of the receiver itself cannot be caught. Returns in methods called by the receiver are OK.

See also link::#Exception Handling Examples:: and link::Classes/Exception:: for more information on how to handle exceptions.

method::try

Executes the receiver. If an exception is thrown the catch function handler is executed with the error as an argument. handler itself can rethrow the error if desired.

method::protect

Executes the receiver. The cleanup function handler is executed with an error as an argument, or nil if there was no error. The error continues to be in effect.

subsection:: Scheduling


method:: awake

This method is called by a link::Classes/Clock:: on which the function was
scheduled when its scheduling time is up. It calls link::#-value::, passing
on the scheduling time in beats as an argument.

argument:: beats
The scheduling time in beats. This is equal to the current logical time
(link::Classes/Thread#-beats::).

argument:: seconds
The scheduling time in seconds. This is equal to the current logical time
(link::Classes/Thread#-seconds::).

argument:: clock
The clock on which the object was scheduled.

returns::
The value returned by the function's link::#-value::. A caller clock uses
this value to reschedule the function.

code::
// Runs every 2 seconds
AppClock.play({ "And again".postln; 2 });
::

subsection::Audio

method::play

Play a Synth from UGens returned by the function. The function arguments become controls that can be set afterwards.

This works as follows: play wraps the UGens in a SynthDef and sends it to the target. When this asynchronous command is completed, it creates one synth from this definition.


argument::target
A Node, Server, or Nil. A Server will be converted to the default group of that server. Nil will be converted to the default group of the default Server.

argument::outbus
A bus number that determines the output channel. This is equivalent to code::Out.ar(outbus, signal)::. The default is 0.

argument::fadeTime
Crossfade time for attack and release of the synth. The default is 0.02 seconds, which is just enough to avoid a click.

argument::addAction
The add action for the synth.  For a list of valid addActions see link::Classes/Synth::

argument::args
An array of key value pairs of control names and control values which are used when starting the synth.

note::
Some UGens are added in this process.
list::
## an link::Classes/Out:: UGen for playing the audio to the first audio busses. If the function returns an Out UGen, this is omitted. ##an envelope with a code::\gate:: control for releasing and crossfading. If the function provides its own releasable envelope, this is omitted.
::
::




code::
x = { |freq = 440| SinOsc.ar(freq, 0, 0.3) }.play; // this returns a Synth object;
x.set(\freq, 880); // note you can set the freq argument
x.defName; // the name of the resulting SynthDef
x.release(4); // fadeout over 4 seconds
::

Many of the examples make use of the Function.play syntax.
Note that reusing such code in a SynthDef requires the addition of an Out ugen.

code::
// the following two lines produce equivalent results
{ SinOsc.ar(440, 0, 0.3) }.play(fadeTime: 0.0);
SynthDef(\help_FuncPlay, { Out.ar(0, SinOsc.ar(440, 0, 0.3))}).play;
::

Function.play is often more convenient than SynthDef.play, particularly for short examples and quick testing. The latter does have some additional options, such as lagtimes for controls, etc. Where reuse and maximum flexibility are of greater importance, SynthDef and its various methods are usually the better choice.


method::scope

As play above, and calls Server-scope to open a scope window in which to view the output.

code::
{ FSinOsc.ar(440, 0, 0.3) }.scope(1)
::

argument::numChannels
The number of channels to display in the scope window, starting from outbus. It automatically reflects the number of channels.
argument::outbus
The output bus to play the audio out on. This is equivalent to Out.ar(outbus, theoutput). The default is 0.
argument::fadeTime
A fadein time. The default is 0.05 seconds, which is just enough to avoid a click.
argument::bufsize
The size of the buffer for the ScopeView. The default is 4096.
argument::zoom
A zoom value for the scope's X axis. Larger values show more. The default is 1.

method::plot

note::See link::Reference/plot:: for a general reference on plotting::


Calculates duration in seconds worth of the output of this function asynchronously, and plots it in a GUI window. Unlike play and scope it will not work with explicit Out Ugens, so your function should return a UGen or an Array of them. The plot will be calculated in realtime.

code::
{ SinOsc.ar(440) }.plot(0.01, bounds: Window.screenBounds);

{ {|i| SinOsc.ar(1 + i)}.dup(7) }.plot(1);
::



argument::duration
The duration of the function to plot in seconds. The default is 0.01.
argument::target
The server, synth or group where the signal is picked up. See link::Reference/asTarget::.
code::
(
var synth = { Out.ar(99, SinOsc.ar([300, 700])) }.play;
{ In.ar(99, 2) }.plot(0.02, synth);
)
::

argument::bounds
An instance of Rect or Point indicating the bounds of the plot window.
argument::minval
the minimum value in the plot. If not specified, the signal's minimum is used.
argument::maxval
the maximum value in the plot. If not specified, the signal's maximum is used.
argument:: separately
If set to code::true::, for multichannel signals use separate value display ranges, unless minval or maxval is specified already.


method::asBuffer
Calculates duration in seconds worth of the output of this function asynchronously, and returns it in a link::Classes/Buffer:: of the number of channels. This method immediately returns a buffer, which takes code::duration:: seconds to become filled with data asynchronously. Then the action function is called.

argument::duration
The duration of the function to plot in seconds. The default is 0.01.

argument::target
The synth or group after which the synth runs (see link::Reference/asTarget::). The default is the default group of code::Server.default::.

argument::action
A function that is called when the buffer is filled. It is passed the buffer as argument.

argument::fadeTime
A fade in and out time in seconds. Only when greater than zero, an envelope is applied to the signal to avoid clicks (default: 0).

discussion::
code::
// record a buffer
b = { Blip.ar(XLine.kr(10000, 4, 3) * [1, 1.2], 20) * 0.1 }.asBuffer(3, fadeTime:0.1)
b.plot; // after 3 seconds, you can see it.
// play the soundfile back
{ PlayBuf.ar(b.numChannels, b, LFNoise2.kr(2 ! 8).exprange(0.15, 1), loop:1).sum }.play;
::


method:: loadToFloatArray
Write a UGen function to a file and then load it into a FloatArray.

argument:: duration
Amount of data to record in seconds

argument::target
A server, synth, or group where to place the synth that plays the function

argument::action
A function to call when writing is finished.

code::
// get some data from the synth audio
{ SinOsc.ar + GrayNoise.ar(0.1) }.loadToFloatArray(0.01, action: { arg array; a = array });
a.postln;
a.plot;

// place it after some other node:
z = { WhiteNoise.ar * 0.1 }.play; // play some noise
{ BPF.ar(In.ar(0), 7000, 0.01) * 10 }.loadToFloatArray(0.01, z, action: { arg array; a = array });
a.postln;
::

method:: getToFloatArray
Stream the function audio values to the client using a series of getn messages and put the results into a FloatArray.

argument:: duration
Amount of data to record in seconds

argument::target
A server, synth, or group where to place the synth that plays the function

argument::action
A function to call when writing is finished.

argument:: wait
The amount of time in seconds to wait between sending getn messages. Longer times are safer. The default is 0.01 seconds which seems reliable under normal circumstances. A setting of 0 is not recommended.

argument:: timeout
The amount of time in seconds after which to post a warning if all replies have not yet been received. the default is 3.

discussion::
For a discussion of the difference between getToFloatArray and loadToFloatArray, see link::Classes/Buffer#-getToFloatArray:: and link::Classes/Buffer#-loadToFloatArray::.


code::
// get some data from the synth audio

{ SinOsc.ar + GrayNoise.ar(0.1) }.getToFloatArray(0.01, action: { arg array; a = array });
a.postln;
a.plot;
::


subsection::Conversion

method::asSynthDef

Returns a SynthDef based on this Function, adding a Linen and an Out ugen if needed.

argument::rates
An Array of rates and lagtimes for the function's arguments (see SynthDef for more details).
argument::prependArgs
arguments
argument::outClass
The class of the output ugen as a symbol. The default is \Out.
argument::fadeTime
a fadein time. The default is 0.
argument::name
the name of the SynthDef

method::asDefName

Performs asSynthDef (see above), sends the resulting def to the local server and returns the SynthDefs name. This is asynchronous.

code::
x = { SinOsc.ar(440, 0, 0.3) }.asDefName; // this must complete first
y = Synth(x);
::

method::asRoutine

Returns a Routine using this as its func argument.

method::r

Returns a Routine using this as its func argument.

code::
a = r { 5.do { |i| i.rand.yield } };
a.nextN(8);
::

method::p

Returns a Prout using this as its func argument.

code::
a = p { 5.do { |i| i.rand.yield } };
x = a.asStream;
x.nextN(8);
::

This is useful for using ListComprehensions in Patterns:

code::
Pbind(\degree, p {:[x, y].postln, x<-(0..10), y<-(0..10), (x + y).isPrime }, \dur, 0.3).play;
::

subsection:: Bela

method:: belaScope
Like link::Classes/Function#-scope::, plays and scopes this Function, but using Bela's Oscilloscope (see link::Classes/BelaScope:: for required setup).
This Function's output bus is monitored right after the generated Synth.

argument:: scopeChannel
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument:: target
A Node, Server, or Nil. A Server will be converted to the default group of that server. Nil will be converted to the default group of the default Server.
note:: this Function's play target needs to be on a Server that supports BelaScope::

argument:: numChannels
Number of channels to scope, from this Function's output channels. Defaults to this Function's output channels.

argument:: outbus
argument:: fadeTime
argument:: addAction
argument:: args
See link::Classes/Function#-scope::

returns:: Like link::Classes/Function#-play::, a Synth playing this function. When that synth is freed, so will be its monitor.

examples::

subsection::Exception Handling Examples

code::
// no exception handler
value { 8.zorg; \didnt_continue.postln; }

try { 8.zorg } {|error| error.postln; \cleanup.postln; }; \continued.postln;

protect { 8.zorg } {|error| error.postln; }; \didnt_continue.postln;
::

code::
try { 123.postln; 456.throw; 789.postln } {|error| [\catch, error].postln };

try { 123.postln; 789.postln } {|error| [\catch, error].postln };

try { 123.postln; nil.throw; 789.postln } {|error| [\catch, error].postln };

protect { 123.postln; 456.throw; 789.postln } {|error| [\onExit, error].postln };

protect { 123.postln; 789.postln } {|error| [\onExit, error].postln };

(
try {
	protect { 123.postln; 456.throw; 789.postln } {|error| [\onExit, error].postln };
} {|error| [\catch, error].postln };
)

value { 123.postln; 456.throw; 789.postln }

value { 123.postln; Error("what happened?").throw; 789.postln }
::

code::
(
a = [\aaa, \bbb, \ccc, \ddd];
a[1].postln;
a[\x].postln;
a[2].postln;
)

(
try {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump }
)

(
try {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump; error.throw }
)

(
protect {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump }
)
::





class::FunctionDef
summary:: FunctionDefs contain code which can be executed from a Function.
categories::Core>Kernel
related::Classes/Function

description::

subsection:: Related Keywords

method:: thisFunctionDef
The global pseudo-variable code::thisFunctionDef:: always evaluates to the
current enclosing FunctionDef.

See also: link::Classes/Function#.thisFunction#thisFunction::

instanceMethods::

subsection::Accessing

Even though it is possible to change the values in the various arrays that define the FunctionDef,
you should not do it, unless you like to crash.

method::code

Get the byte code array.

code::
{ |a = 9, b = 10, c| a + b }.def.code;
::

method::sourceCode

Get the source code string.
code::
{ |a = 9, b = 10, c| a + b }.def.sourceCode.postcs;
::

method::context

Get the enclosing FunctionDef or Method.

method::findReferences

return a list of all references to a given symbol.

method::argNames

Get the Array of Symbols of the argument names.

code::
{ |a = 9, b = 10, c| a + b }.def.argNames;
::
method::prototypeFrame

Get the array of default values for argument and temporary variables.

code::
{ |a = 9, b = 10, c| a + b }.def.prototypeFrame;
::
method::varNames

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| var x = 9; a + b + x }.def.varNames;
::
method::argumentString

Return a string that contains all argument names and their default values for embedding in a string.
If there are no arguments, it returns nil.

code::
{ |a = 9, b = 10, c| a + b }.def.argumentString; // "a = 9, b = 10, c"
{ "nothing to see here" }.def.argumentString; // nil
::

argument::withDefaultValues
If set to false, no default values are appended

code::
 // "a, b, c"
{ |a = 9, b = 10, c| a + b }.def.argumentString(withDefaultValues: false);
::

argument::withEllipsis
If set to true, ellipsis characters (code::" ... "::) are appended

code::
// "a = 9, b = 10 ... c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(withEllipsis: true);
// "a = 9, b = 10, c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(withEllipsis: false);
::

argument::asArray
If set to true, return the string for an array that represents all arguments. The other arguments are set to false.

code::
// "[a, b] ++ c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(asArray: true);
::



method::makeEnvirFromArgs

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| a + b }.def.makeEnvirFromArgs;
::

subsection::Generating Strings

method::makeFuncModifierString

Return a string that can be interpreted as code for a new function which extracts the arguments from the receiver. This can be used to build a hygienic macro which returns a function with valid keyword arguments, instead of just anonymously forwarding the arguments, like in code::{ |...args| func.valueArray(args) }::.

For an implementation example link::Classes/Function#flop:: (as below).


argument::modifier
A function to which a string is passed that represents the array of all arguments. It should return a string that can be interpreted.

code::
// basic usage
f = { |x, y| x.squared + y.squared }; // a function
a = f.def.makeFuncModifierString({ |argString| "%.scramble".format(argString) });
a.interpret.value(4, 5)

// use as a macro: multichannel expansion like in flop
f = { |x, y = 1| if(x > 0) { 1 } { 0 } * y }; // some function
// generate the body of a function that has a free and yet undefined variable "func"
// -> "{ arg x, y = 1; ([x, y]).flop.collect { |x| func.valueArray(x) } }"
a = f.def.makeFuncModifierString({ |str| str ++ ".flop.collect { |x| func.valueArray(x) }" });
// wrap that body into a function that takes "func" as argument and returns the function above
// now we have a valid code for a function:
// -> "{ |func| { arg x, y = 1; [x, y].flop.collect { |x| func.valueArray(x) } } }"
b = "{ |func| % }".format(a);
// interpret the code to a function
g = b.interpret;
// pass the function f to g, which returns a function from a where "func" is bound to f
h = g.value(f);
// we can now use h in place of f, but all arguments are multichannel expanded:
f.([1, 0], [6, 7]); // does not work
h.([1, 0], [6, 7]); // [6, 0]
// and the new function supports the same keywords arguments:
h.(x:(-2..2), y:(-2..2));

// this functionality is implemented for function in the method "flop"
h = f.flop;
h.([1, 0], [6, 7]); // [6, 0]
::


subsection::Utilities

method::dumpByteCodes

"Disassemble" and post the FunctionDef's byte code instructions to the text window.


class::FunctionList
summary:: A function that composes multiple functions into one
categories::Core>Kernel

description::

A FunctionList is a function that composes multiple functions into one. This allows allow to deal transparently with several functions as if they were one and to append new functions at a later point. The functions are evaluated in the order they have in the FunctionList's array, which is by default the order in which they have been added to it.

See the link::Reference/Functions:: help file for a basic introduction.

code::
a = FunctionList.new;
fork { loop { 0.7.wait; a.value.postln } };
a.addFunc({ 800.rand });
a.addFunc({ "another".scramble });
::

classMethods::

method::new

create a new instance.
argument:: functions
An array of functions or objects

instanceMethods::

method::array

Set/get the FunctionList's array. New functions can be added to the array directly, e.g.
code::
x = FunctionList(...some functions);
x.array = x.array.insert(2, aFunction);
::

method::addFunc

This message is used to be able to add to an Object, to a Function, or to a FunctionList.
code::nil.addFunc:: returns a function, if only one function is passed in the argument.
code::function.addFunc:: then returns a FunctionList.

method::removeFunc

remove a function from the list.

returns:: the last function when only one function is left, or code::nil:: when the last function was removed.

discussion::
code::addFunc:: and code::removeFunc:: are implemented for link::Classes/Nil::, link::Classes/Object:: and link::Classes/FunctionList::

code::
nil.addFunc(f) // returns f
obj.addFunc(f) // returns FunctionList([obj, f])
nil.removeFunc(f) // returns nil
obj.removeFunc(f) // returns nil, if f === obj, else obj is returned
::

examples::

code::
// example

a = nil;
a = a.addFunc { |x="", y=""| "this % is an % example\n".postf(x, y); 1 };
a.postln;
a = a.addFunc { |x="", y=""| "there is no % that is %\n".postf(x, y); 2 };
a.value;
a.value("text", "extraordinary well written")
a.valueArray(["x", "y"]);
::

code::
// Function:do vs FunctionList:do (same)
a.do { |x| x.value };
{ 4 }.do { |x| x.value.postln }

(
().use {
	~x = "array";
	~y = "ominous";
	a.valueEnvir;
	a.valueEnvir("list");
}
)
::

code::
// removing a function
x = { "removal test".postln };
a.addFunc(x);
a.value;
a = a.removeFunc(x);
a.value;

// mathematics
a = nil;
a = a.addFunc({ 1.0.rand }).addFunc({ [0, 1].choose });
a = a.squared.linexp(0, 1, 1.0, 500);

a.value;
::

code::
// compatibility with function multichannel expansion
a = nil;
a = a.addFunc { |x=0| if(x > 0) { 7 } { 1000.rand } };
a = a.addFunc { |x=0| if(x < 0) { 17 } { -1000.rand } };
a.value

a = a.flop;
a.value
a.value([-1, 1])
::

code::
// typical usage in a Document action
// see also SCView: addAction example.

d = Document.current;
d.keyDownAction = { "You touched the keyboard.".postln };

d.keyDownAction = d.keyDownAction.addFunc {:x, x<-(1..), :: "already % times\n\n".postf(x) };


d.keyDownAction = nil;

// even if you don't know if there is already an action defined
// one can add one.

(
d.keyDownAction = nil;
d.keyDownAction = d.keyDownAction.addFunc {:x, x<-(1..), :: "already % times\n\n".postf(x) };

);

d.keyDownAction = nil;
::





class:: GUI
summary:: Factory abstraction for all GUI related core classes
categories:: GUI>Kits
related:: Overviews/GUI-Classes, Guides/GUI-Introduction


description::
SuperCollider currently supports three operating system platforms: macOS, UNIX (Linux and FreeBSD) and Windows (with some limitations).

Warning::The redirect system has been deprecated, please use the view classes directly. If you find old code that uses prefixes for the old GUI Kits (e.g. SCWindow for CocoaGUI), try dropping the prefixes to Window, Button etc. The Qt prefix Q, as e.g. in QWindow, is converted to Window automatically; still it is better style to simply write Window.::

Switching between GUI schemes is not needed anymore, as Qt runs well on all platforms.
Still, you can get the available schemes with:
code::
GUI.schemes;
::
For a complete list of historical gui classes and their redirects, see link::Overviews/GUI-Classes::.

classmethods::

method:: new

method:: makeGUI

method:: initClass
Sets the code::skin:: to default values on compile.
code::
fontSpecs: ["Helvetica", 10],
fontColor: Color.black,
background: Color(0.8, 0.85, 0.7, 0.5),
foreground: Color.grey(0.95),
onColor: Color(0.5, 1, 0.5),
offColor: Color.clear,
gap: 0@0,
margin: 2@2,
buttonHeight: 16
::

method:: add

method:: qt
Makes QtGUI the current scheme and returns it. Subsequent GUI object calls to GUI are delegated to Qt. Returns the current (Qt) scheme.

method:: fromID
Changes the current scheme and returns the new scheme.
argument:: id
A link::Classes/Symbol::. The identifier of the scheme to use.


method:: current

Returns the current scheme. This is useful for objects that, upon instantiation, wish to store the then-current scheme, so as to be able to consistently use the same scheme in future method calls.

Note:: the caller shouldn't make any assumptions about the nature (the class) of the returned object, so that the actual implementation (an Event) may change in the future. ::


method:: get
Returns the scheme for a given identifier. Does not switch the current scheme.
argument:: id
A link::Classes/Symbol::. The identifier of the scheme to retrieve, such as returned by calling code::aScheme.id::.

method:: set
Changes the current scheme.
argument:: aScheme
An instance of link::Classes/Symbol::. The scheme to use as current scheme.

method:: use
Executes a function body, temporarily setting the current GUI scheme. This is useful inside view's action functions in order to make this function use the GUI scheme that was originally used for the view of the action, even if the scheme has been switched meanwhile.
argument:: aScheme
The scheme to use during the function execution.
argument:: func
An Instance of link::Classes/Function::.

method:: useID
Same as code::use:: but using a scheme's id as first argument.
argument:: id
The id of the scheme to use during the function execution.
argument:: func
A body to execute.

method:: add
Registers a new scheme. This is typically called by external libraries in their startup procedure. If a scheme with the same identifier (code::scheme.id::) exists, it is overwritten.
argument:: aScheme
The scheme to add.

method:: doesNotUnderstand
All method calls are mapped to the current scheme, so that for example code::GUI.button:: can be used and is delegated to the button association of the current scheme.
argument:: selector
argument:: ... args

method:: setSkin
argument:: skinName

method:: scheme
A class variable. Returns the current scheme.

method:: schemes
A class variable. Returns an link::Classes/IdentityDictionary:: of registered schemes.

method:: skin
A class variable. Returns the current skin.

method:: skins
A class variable. Returns an link::Classes/IdentityDictionary:: of registered skins.


class:: GVerb
summary:: A two-channel reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb, Classes/FreeVerb2

description::
A two-channel reverb link::Classes/UGen::, based on the "GVerb" LADSPA effect by Juhana Sadeharju (kouhia at nic.funet.fi).

subsection:: Known issues
list::
## There is a large CPU spike when the synth is instantiated while all the delay lines are zeroed out.
## Quick changes in roomsize result in zipper noise.
## emphasis::Changing the roomsize does not work properly! Still trying to look for the bug... (-josh)::
::

classmethods::

method:: ar
argument:: in
mono input.
argument:: roomsize
in squared meters.
argument:: revtime
in seconds.
argument:: damping
0 to 1, high frequency rolloff, 0 damps the reverb signal completely, 1 not at all.
argument:: inputbw
0 to 1, same as damping control, but on the input signal.
argument:: spread
a control on the stereo spread and diffusion of the reverb signal.
argument:: drylevel
amount of dry signal.
argument:: earlyreflevel
amount of early reflection level.
argument:: taillevel
amount of tail level.
argument:: maxroomsize
to set the size of the delay lines. Defaults to roomsize + 1.
argument:: mul
argument:: add

examples::
code::
(
SynthDef(\test, { |out, roomsize, revtime, damping, inputbw, spread = 15, drylevel, earlylevel,
	taillevel|

	var a = Resonz.ar(
		Array.fill(4, { Dust.ar(2) }),
		1760 * [1, 2, 4, 8],
		0.01
	).sum * 10;

	//	var a = SoundIn.ar(0);
	//	var a = PlayBuf.ar(1, 0);

	Out.ar(out,
		GVerb.ar(
			a,
			roomsize,
			revtime,
			damping,
			inputbw,
			spread,
			drylevel.dbamp,
			earlylevel.dbamp,
			taillevel.dbamp,
			roomsize, 0.3)
		+ a
	)
}).add
)


s.scope(2);

// bathroom
a = Synth(\test, [\roomsize, 5, \revtime, 0.6, \damping, 0.62, \inputbw, 0.48, \drylevel -6, \earlylevel, -11, \taillevel, -13]);
a.free;

//living room
a = Synth(\test, [\roomsize, 16, \revtime, 1.24, \damping, 0.10, \inputbw, 0.95, \drylevel -3, \earlylevel, -15, \taillevel, -17]);
a.free;

//church
a = Synth(\test, [\roomsize, 80, \revtime, 4.85, \damping, 0.41, \inputbw, 0.19, \drylevel -3, \earlylevel, -9, \taillevel, -11]);
a.free;

// cathedral
a = Synth(\test, [\roomsize, 243, \revtime, 1, \damping, 0.1, \inputbw, 0.34, \drylevel -3, \earlylevel, -11, \taillevel, -9]);
a.free

// canyon
a = Synth(\test, [\roomsize, 300, \revtime, 103, \damping, 0.43, \inputbw, 0.51, \drylevel -5, \earlylevel, -26, \taillevel, -20]);
a.free;

s.quit;
::


class:: Gate
summary:: Gate or hold.
related:: Classes/Latch
categories::  UGens>Triggers


Description::

Allows input signal value to pass when gate is positive, otherwise holds last value.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::trig

Gate - can be any signal. The output is held fixed when this is non-positive.


Examples::

code::

s.boot;
// Control rate so as not to whack your speakers with DC
{ Gate.kr(WhiteNoise.kr(1, 0), LFPulse.kr(1.333, 0.5))}.scope(zoom: 20);

::



class:: GbmanL
summary:: Gingerbreadman map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/GbmanN

description::
A linear-interpolating sound generator based on the difference equations:

teletype::
	x(n+1) = 1 - y(n) + |x(n)|
	y(n+1) = x(n)
::

The behavior of the system is dependent only on its initial conditions and cannot be changed once it's started.

sclang code translation:

code::
(
var xi = 1.2, yi = 2.1, size = 64;
plot(size.collect { var x; xi = 1 - yi + abs(x = xi); yi = x; xi });
)
::

Reference: Devaney, R. L. "The Gingerbreadman." Algorithm 3, 15-16, Jan. 1992.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir)) * 0.1 }.play(s);

// different initial params
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir), -0.7, -2.7) * 0.1 }.play(s);

// wait for it...
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir), 1.2, 2.0002) * 0.1 }.play(s);

// as a frequency control
{ SinOsc.ar(GbmanL.ar(40)*400+500)*0.4 }.play(s);
::


class:: GbmanN
summary:: Gingerbreadman map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/GbmanL

description::
A non-interpolating sound generator based on the difference equations:

teletype::
        x(n+1) = 1 - y(n) + |x(n)|
        y(n+1) = x(n)
::


The behavior of the system is only dependent on its initial conditions.

sclang code translation:

code::
(
var xi = 1.2, yi = 2.1, size = 64;
plot(size.collect { var x; xi = 1 - yi + abs(x = xi); yi = x; xi });
)
::

Reference: emphasis:: Devaney, R. L. "The Gingerbreadman." Algorithm 3, 15-16, Jan. 1992. ::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir)) * 0.1 }.play(s);

// change initial params
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir), -0.7, -2.7) * 0.1 }.play(s);

// wait for it...
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir), 1.2, 2.0002) * 0.1 }.play(s);

// as a frequency control
{ SinOsc.ar(GbmanN.ar(40)*400+500)*0.4 }.play(s);
::


class:: Gendy1
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy2, Classes/Gendy3
categories::  UGens>Generators>Stochastic


Description::

An implementation of the dynamic stochastic synthesis generator conceived
by Iannis Xenakis and described in  emphasis::Formalized Music (1992, Stuyvesant, NY: Pendragon Press) chapter 9 (pp 246-254) and chapters 13 and 14 (pp 289-322)::.

The BASIC program in the book was written by Marie-Helene Serra so I
think it helpful to credit her too.

The program code has been adapted to avoid infinities in the probability
distribution functions.

The distributions are hard-coded in C but there is an option to have new
amplitude or time breakpoints sampled from a continuous controller input.

subsection:: Technical notes
X's plan as described in chapter 13 allows the 12 segments in the period to be successively modified with each new period.
Yet the period is allowed to vary as the sum of the segment durations, as figure 1 demonstrates.
We can setup some memory of n (conventionally 12) points, or even simply vary successively a single point's ordinate and
duration. There are thus various schemes available to us. In one, fix period T and only move the (ti, Ei) within the period. In another, have a memory of 12 segments but allow continuous modification of the inter point intervals and the amplitudes.
In yet another, just have one point and random walk its amplitude and duration based on the probability distribution.
In this implementation I allow the user to initialise a certain number of memory points which is up to them.
To restrict the period to be unchanging, you must set rate variation to zero (dscale=0).

SuperCollider implementation by Nick Collins.


classmethods::

method::ar, kr

argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):

table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.


argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.


argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).


argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::minfreq

Minimum allowed frequency of oscillation for the Gendy1
oscillator, so gives the largest period the duration is allowed
to take on.


argument::maxfreq

Maximum allowed frequency of oscillation for the Gendy1
oscillator, so gives the smallest period the duration is allowed
to take on.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.

argument::mul

argument::add

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.

Examples::

warning::
if you have lots of CPs and you have fast frequencies, the CPU cost goes up a lot because a new CP move happens every sample!
::

code::
// defaults
{Pan2.ar(Gendy1.ar)}.play

// wandering bass/ powerline
{ Pan2.ar(Gendy1.ar(1, 1, 1.0, 1.0, 30, 100, 0.3, 0.05, 5)) }.play

// play me
{ Pan2.ar(RLPF.ar(Gendy1.ar(2, 3, minfreq:20, maxfreq:MouseX.kr(100,1000), durscale:0.0, initCPs:40), 500, 0.3, 0.2), 0.0)}.play

// scream! - careful with your ears for this one!
(
{
    var mx, my;

    mx = MouseX.kr(220, 440);
    my = MouseY.kr(0.0, 1.0);

    Pan2.ar(Gendy1.ar(2,3,1,1,minfreq:mx, maxfreq:8*mx, ampscale:my, durscale:my, initCPs:7, mul:0.3), 0.0)
}.play
)


// 1 CP = random noise effect
{ Pan2.ar(Gendy1.ar(initCPs:1)) }.play

// 2 CPs = suudenly an oscillator (though a fast modulating one here)
{ Pan2.ar(Gendy1.ar(initCPs:2)) }.play


//used as an LFO
(
{
    Pan2.ar(
        SinOsc.ar(
            Gendy1.kr(2, 4,
                SinOsc.kr(0.1, 0, 0.49, 0.51),
                SinOsc.kr(0.13, 0, 0.49, 0.51),
                3.4, 3.5,
                SinOsc.kr(0.17, 0, 0.49, 0.51),
                SinOsc.kr(0.19, 0, 0.49, 0.51),
                10, 10, 50, 350),
        0, 0.3),
    0.0)
}.play
)

// wasp
{ Pan2.ar(Gendy1.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9), 1.0, 50, 1000, 1, 0.005, 12, 12, 0.2), 0.0)}.play


// modulate distributions
// change of pitch as distributions change the duration structure and spectrum
{ Pan2.ar(Gendy1.ar(MouseX.kr(0, 7), MouseY.kr(0, 7), mul:0.2), 0.0) }.play


// modulate num of CPs
{ Pan2.ar(Gendy1.ar(knum:MouseX.kr(1, 13), mul:0.2), 0.0) }.play

// Gendy into Gendy ... with cartoon side effects
	(
		{
			Pan2.ar(Gendy1.ar(
				maxfreq:Gendy1.kr(5, 4, 0.3, 0.7, 0.1, MouseY.kr(0.1, 10), 1.0, 1.0, 5, 5, 500, 600),
				knum:MouseX.kr(1, 13), mul:0.2), 0.0)
		}.play
	)

// use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{ Pan2.ar(Gendy1.ar(6, 6, LFPulse.kr(100, 0, 0.4, 1.0), SinOsc.kr(30, 0, 0.5), mul:0.2), 0.0) }.play


//try out near the corners especially
	(
		{ 
			Pan2.ar(Gendy1.ar(6,6,LFPulse.kr(MouseX.kr(0,200), 0, 0.4, 1.0),
			SinOsc.kr(MouseY.kr(0,200), 0, 0.5),mul:0.2), 0.0)
		}.play
	)

// texture
	(
		{
			Mix.fill(10, {
				var freq = rrand(130,160.3);
				Pan2.ar(SinOsc.ar(Gendy1.ar(6.rand, 6.rand, SinOsc.kr(0.1, 0, 0.49, 0.51),
					SinOsc.kr(0.13, 0, 0.49, 0.51), freq, freq, SinOsc.kr(0.17, 0, 0.49, 0.51),
					SinOsc.kr(0.19, 0, 0.49, 0.51), 12, 12, 200, 400), 0, 0.1), 1.0.rand2)
			})
		}.play
	)

// wahhhhhhhh- try durscale 10.0 and 0.0 too
	(
		{
			Pan2.ar(
				CombN.ar(
					Resonz.ar(
						Gendy1.ar(2, 3, minfreq:1, maxfreq: MouseX.kr(10, 700), durscale:0.1, initCPs:10),
						MouseY.kr(50, 1000), 0.1),
					0.1, 0.1, 5, 0.6
				),
				0.0)
		}.play
	)

// overkill
	(
		{
			var n = 10;
			Mix.fill(n, {
				var freq, numcps;

				freq = rrand(130, 160.3);
				numcps = rrand(2, 20);
				Pan2.ar(
					Gendy1.ar(
						6.rand, 6.rand, 1.0.rand, 1.0.rand, freq, freq, 1.0.rand, 1.0.rand, numcps,
						SinOsc.kr(exprand(0.02, 0.2), 0, numcps/2, numcps/2), 0.5 / (n.sqrt)
					),
					1.0.rand2
				)
			})
		}.play
	)

// another traffic moment
	(
		{
			var n;
			n =10;

			Resonz.ar(
				Mix.fill(n, {
					var freq, numcps;

					freq = rrand(50,560.3);
					numcps = rrand(2,20);
					Pan2.ar(Gendy1.ar(6.rand, 6.rand, 1.0.rand, 1.0.rand, freq, freq, 1.0.rand, 1.0.rand, numcps,
						SinOsc.kr(exprand(0.02, 0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
				}),
				MouseX.kr(100,2000),
				MouseY.kr(0.01,1.0)
			)
		}.play
	)

	(
		{
			var n = 15;


			Resonz.ar(
				Mix.fill(n,{
					var freq, numcps;

					freq = rrand(330, 460.3);
					numcps = rrand(2, 20);
					Pan2.ar(
						Gendy1.ar(
							6.rand, 6.rand, 1.0.rand, 1.0.rand, freq,
							MouseX.kr(freq, 2*freq), 1.0.rand, 1.0.rand, numcps,
							SinOsc.kr(exprand(0.02, 0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)
						),
						1.0.rand2
					)
				}),
				MouseX.kr(100, 2000), MouseY.kr(0.01, 1.0)
			)

		}.play;
	)
::



class:: Gendy2
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy1, Classes/Gendy3
categories::  UGens>Generators>Stochastic


Description::

See  link::Classes/Gendy1::  help file for background. This variant of
GENDYN is closer to that presented in emphasis::Hoffmann, Peter. (2000) The New GENDYN Program. Computer Music Journal 24:2, pp 31-38::.

note::
Random walk is of the amplitude and time delta, not the amp and time
directly. The amplitude step random walk uses a Lehmer style number
generator whose parameters are accessible.
::

SuperCollider implementation by Nick Collins

classmethods::

method::ar, kr


argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):
table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.

argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.

argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).

argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::minfreq

Minimum allowed frequency of oscillation for the Gendy1
oscillator, so gives the largest period the duration is allowed
to take on.


argument::maxfreq

Maximum allowed frequency of oscillation for the Gendy1
oscillator, so gives the smallest period the duration is allowed
to take on.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.


argument::a

Parameter for Lehmer random number generator perturbed by
Xenakis as in

code::
((old*a)+c)%1.0
::

argument::c

Parameter for Lehmer random number generator perturbed by
Xenakis.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.


Examples::
warning::
if you have lots of CPs and you have fast frequencies, the CPU cost goes up a lot because a new CP move happens every sample!
::

code::
//LOUD! defaults like a rougher Gendy1
{Pan2.ar(Gendy2.ar)}.play

//advantages of messing with the random number generation- causes periodicities
{Pan2.ar(Gendy2.ar(a:MouseX.kr(0.0,1.0),c:MouseY.kr(0.0,1.0)))}.play

(
{Pan2.ar(
Normalizer.ar(
RLPF.ar(
RLPF.ar(Gendy2.ar(a:SinOsc.kr(0.4,0,0.05,0.05),c:SinOsc.kr(0.3,0,0.1,0.5)),
MouseX.kr(10,10000,'exponential'),0.05),
MouseY.kr(10,10000,'exponential'),0.05)
,0.9)
,Lag.kr(LFNoise0.kr(1),0.5))}.play
)



{Pan2.ar(Gendy2.ar(3,5,1.0,1.0,50,1000,MouseX.kr(0.05,1),MouseY.kr(0.05,1),15, 0.05,0.51,mul:0.5))}.play


//play me
{Pan2.ar(RLPF.ar(Gendy2.ar(1,3,minfreq:20,maxfreq:MouseX.kr(100,1000),durscale:0.0,initCPs:4),500,0.3, 0.2),0.0)}.play


//1 CP = random noise effect
{Pan2.ar(Gendy2.ar(initCPs:1))}.play

//2 CPs = suddenly an oscillator (though a fast modulating one here)
{Pan2.ar(Gendy2.ar(initCPs:2))}.play


//used as an LFO
(
{Pan2.ar(SinOsc.ar(Gendy2.kr(2,1,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),
3.4,3.5, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),10,10,mul:50, add:350), 0, 0.3), 0.0)}.play
)

//very angry wasp
{Pan2.ar(Gendy2.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9),1.0, 50,1000, 1,0.005, 12, 12, 0.2,0.2,0.2), 0.0)}.play


//modulate distributions
//change of pitch as distributions change the duration structure and spectrum
{Pan2.ar(Gendy2.ar(MouseX.kr(0,7),MouseY.kr(0,7),mul:0.2), 0.0)}.play


//modulate num of CPs
{Pan2.ar(Gendy2.ar(knum:MouseX.kr(1,13),mul:0.2), 0.0)}.play


(//Gendy1 into Gendy2...with cartoon side effects
{Pan2.ar(Gendy2.ar(maxfreq:Gendy1.kr(5,4,0.3, 0.7, 0.1, MouseY.kr(0.1,10),
    1.0, 1.0, 5,5, 500, 600), knum:MouseX.kr(1,13),mul:0.2), 0.0)}.play
)

//use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{Pan2.ar(Gendy2.ar(6,6,LFPulse.kr(100, 0, 0.4, 1.0), SinOsc.kr(30, 0, 0.5),mul:0.2), 0.0)}.play


(//try out near the corners especially
{Pan2.ar(Gendy2.ar(6,6,LFPulse.kr(MouseX.kr(0,200), 0, 0.4, 1.0),
    SinOsc.kr(MouseY.kr(0,200), 0, 0.5),mul:0.2), 0.0)}.play
)

//texture- the howling wind?
(
{
    Mix.fill(10,{
    var freq;

    freq= rrand(130,160.3);
    Pan2.ar(SinOsc.ar(Gendy2.ar(6.rand,6.rand,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),
        freq ,freq, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),
        12, 12, 0.4.rand, 0.4.rand, 200, 400), 0, 0.1), 1.0.rand2)
    });
}.play
)

//CAREFUL! mouse to far right causes explosion of sound
(
{Pan2.ar(
CombN.ar(
Resonz.ar(
Gendy2.ar(2,3,minfreq:1, maxfreq:MouseX.kr(10,700), initCPs:100),
MouseY.kr(50,1000), 0.1)
,0.1,0.1,5, 0.16
)
, 0.0)}.play
)

//storm
(
{
    var n;
    n=15;

    0.5*Mix.fill(n,{
    var freq, numcps;

    freq= rrand(130,160.3);
    numcps= rrand(2,20);
    Pan2.ar(Gendy2.ar(6.rand,6.rand,10.0.rand,10.0.rand,freq,freq*exprand(1.0,2.0),
        10.0.rand, 10.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2),
        10.0.rand, 10.0.rand, 0.5/(n.sqrt)), 1.0.rand2)
    });
}.play
)

//another traffic moment
(
{
    var n;
    n=10;

    Resonz.ar(
    Mix.fill(n,{
    var freq, numcps;

    freq= rrand(50,560.3);
    numcps= rrand(2,20);
    Pan2.ar(Gendy2.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq ,freq,
        1.0.rand, 1.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0,
        numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
    })
    ,MouseX.kr(100,2000), MouseY.kr(0.01,1.0), 0.3)
    ;
    }.play
)
::



class:: Gendy3
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy1, Classes/Gendy2
categories::  UGens>Generators>Stochastic


Description::

See  link::Classes/Gendy1::  help file for background. This variant of
GENDYN normalises the durations in each period to force oscillation at
the desired pitch. The breakpoints still get perturbed as in
link::Classes/Gendy1:: .

There is some glitching in the oscillator caused by the stochastic
effects - control points as they vary cause big local jumps of amplitude.
Put  code::ampscale::  and  code::durscale::
low to minimise the rate of this.

SuperCollider implementation by Nick Collins

classmethods::

method::ar, kr

argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):

table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.


argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.


argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).


argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::freq

Oscillation frequency.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.

argument::mul

argument::add

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.


Examples::

code::

//LOUD! defaults like a rougher Gendy1
{Pan2.ar(Gendy3.ar(mul:0.5))}.play

{Pan2.ar(Gendy3.ar(freq:MouseX.kr(220,880,'exponential'), durscale:0.01, ampscale:0.02, mul:0.2))}.play

//stochastic waveform distortion- also play me at the same time as the previous example...
{Pan2.ar(Gendy3.ar(1,2,0.3,-0.7,MouseX.kr(55,110,'exponential'),0.03,0.1))}.play


(
{Pan2.ar(
Normalizer.ar(
RLPF.ar(
RLPF.ar(Mix.new(Gendy3.ar(freq:[230, 419, 546, 789])),
MouseX.kr(10,10000,'exponential'),0.05),
MouseY.kr(10,10000,'exponential'),0.05)
,0.9)
,Lag.kr(LFNoise0.kr(1),0.5))}.play
)


//concrete pH?
(
{Pan2.ar(
Mix.new(Gendy3.ar(freq:([1,1.2,1.3,1.76,2.3]*MouseX.kr(3,17,'exponential')),mul:0.2)))}.play
)

//glitch low, mountain high
(
{Pan2.ar(
Mix.new(Gendy3.ar(3,5,1.0,1.0,(Array.fill(5,{LFNoise0.kr(1.3.rand,1,2)})*MouseX.kr(100,378,'exponential')),MouseX.kr(0.01,0.05),MouseY.kr(0.001,0.016),5,mul:0.1)))}.play
)

//play me
{Pan2.ar(RLPF.ar(Gendy3.ar(1,3,freq:MouseX.kr(100,1000), durscale:0.0, ampscale:MouseY.kr(0.0,0.1), initCPs:7, knum: MouseY.kr(7,2)), 500,0.3, 0.2), 0.0)}.play



//used as an LFO
(
{Pan2.ar(SinOsc.ar(Gendy3.kr(2,5,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51), 0.34, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),10,10,mul:50, add:350), 0, 0.3), 0.0)}.play
)

//buzzpipes
{Pan2.ar(Mix.new(Gendy3.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9),1.0, [100,205,410], 0.011,0.005, 12, 12, 0.12)), 0.0)}.play


//modulate distributions
//change of pitch as distributions change the duration structure and spectrum
{Pan2.ar(Gendy3.ar(MouseX.kr(0,7),MouseY.kr(0,7),mul:0.2), 0.0)}.play


//modulate num of CPs
{Pan2.ar(Gendy3.ar(knum:MouseX.kr(2,13),mul:0.2), 0.0)}.play


//Gendy1 into Gendy2 into Gendy3...with cartoon side effects
(
{Pan2.ar(Gendy3.ar(1,2,freq:Gendy2.ar(maxfreq:Gendy1.kr(5,4,0.3, 0.7, 0.1, MouseY.kr(0.1,10), 1.0, 1.0, 5,5, 25,26),minfreq:24, knum:MouseX.kr(1,13),mul:150, add:200), durscale:0.01, ampscale:0.01, mul:0.1), 0.0)}.play
)

//use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{Pan2.ar(Gendy3.ar(6,6,LFPulse.kr(LFNoise0.kr(19.0,0.5,0.6), 0, 0.4, 0.5), Gendy1.kr(durscale:0.01,ampscale:0.01), MouseX.kr(10,100),mul:0.2), 0.0)}.play



//wolf tones
(
{
Mix.fill(10,{
var freq;

freq= exprand(130,1160.3);
Pan2.ar(SinOsc.ar(Gendy3.ar(6.rand,6.rand,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),freq, SinOsc.kr(0.17,0,0.0049,0.0051), SinOsc.kr(0.19,0,0.0049,0.0051), 12, 12, 200, 400), 0, 0.1), 1.0.rand2)
});
}.play
)

//CAREFUL! mouse to far right causes explosion of sound-
//notice how high frequency and num of CPs affects CPU cost
(
{Pan2.ar(
CombN.ar(
Resonz.ar(
Gendy3.ar(2,3,freq:MouseX.kr(10,700), initCPs:100),
MouseY.kr(50,1000), 0.1)
,0.1,0.1,5, 0.16
)
, 0.0)}.play
)


//storm
(
{
var n;
n=15;

0.5*Mix.fill(n,{
var freq, numcps;

freq= rrand(130,160.3);
numcps= rrand(2,20);
Pan2.ar(Gendy3.ar(6.rand,6.rand,10.0.rand,10.0.rand,freq*exprand(1.0,2.0), 10.0.rand, 10.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
});
}.play
)



//another glitchy moment
(
{
var n;
n=10;

Resonz.ar(
Mix.fill(n,{
var freq, numcps;

freq= rrand(50,560.3);
numcps= rrand(2,20);
Pan2.ar(Gendy3.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq, 1.0.rand, 1.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
})
,MouseX.kr(100,2000), MouseY.kr(0.01,1.0), 0.3)
;
}.play
)
::



TITLE:: Git
summary:: git interface
categories:: Frontends
related:: Classes/Quarks, Classes/Quark

DESCRIPTION::
An interface to the git toolchain. For more information on git, see link::http://git.io::.


CLASSMETHODS::



METHOD:: new
creates a new instance of code::Git::, pointing to an existing local git repository.
argument:: localPath
path to the git repository.


METHOD:: isGit
returns code::true::, if a local directory is a git repository.
argument:: localPath

METHOD:: checkForGit
returns code::true::, if the git toolchain is found on the system.


INSTANCEMETHODS::

subsection:: info

METHOD:: branch
returns:: current branch name.

METHOD:: remote, url
returns:: url of the first remote that it finds.

METHOD:: remoteAsHttpUrl
Detects if the remote URI starts with code::"git@":: or code::"git:":: and remodels it to a valid code::"https":: URI. Otherwise, it returns the unaltered remote.

code::
// git-style remote URI's are transformed to https
Git().url_("git@github.com:foo/bar.git").remoteAsHttpUrl;
Git().url_("https://github.com/foo/bar").remoteAsHttpUrl;
Git().url_("git@foo.net:foo/bar.git").remoteAsHttpUrl;

// http and https are left untouched
Git().url_("https://foo.org/bar").remoteAsHttpUrl;
Git().url_("http://foo.org/bar").remoteAsHttpUrl;

// unknown URI styles are left untouched
Git().url_("fooBar").remoteAsHttpUrl;
::

returns:: remote URI formatted for code::http:: respectively code::https:: requests.

METHOD:: remoteLatest
returns:: hash of latest commit on the remote

METHOD:: localPath
returns:: path to local repository

METHOD:: tag
returns:: currently checked out tag

METHOD:: tags
returns:: avaliable tags

METHOD:: sha
returns:: hash of the currently checked out version

METHOD:: shaForTag
argument:: tag
one of the tags returned by link::#-tags::
returns:: hash of the given tag


METHOD:: isDirty
returns:: code::true:: if there are local changes



subsection:: perform actions on remote

METHOD:: fetch
perform a fetch from remote


METHOD:: checkout
perform a checkout from remote with argument code::refspec::
argument:: refspec

METHOD:: pull
perform a pull from remote

METHOD:: clone
perform a clone from url into link::#-localPath::
argument:: url
the url of the remotes


PRIVATE:: git, refspec



EXAMPLES::

code::
// create a Git that points to a Quark directory
g = Git(Quarks.all.choose.localPath);

// alternatively, provide a pathname to a local git repository:
g = Git("/path/to/local/repo");

// get all available tags
g.tags;

// return local path
g.localPath;

// return url
g.url;
::


class:: Gradient
summary:: A linear color fade between two colors
categories:: GUI>Accessories
related:: Classes/Color, Classes/HiliteGradient

description::

note:: The use of Gradient is strong::not supported yet::. When Gradient is used in place of Color, the average gradient color will be used instead. ::

classmethods::

method:: new
argument:: color1
An instance of link::Classes/Color::.
argument:: color2
An instance of link::Classes/Color::.
argument:: direction
code::\h:: or code::\v:: for horizontal and vertical respectively. Default value is code::\h::.
argument:: steps
The resolution of the gradient. Default value is 64.

instancemethods::

method:: at
Retrieve the colour at position code::pos::, typically a value between zero and one. code::at(0):: is code::color1::, and code::at(1):: is code::color2::.
argument:: pos

examples::
code::
// basic usage
(
w = Window.new.front;
w.view.background = Gradient(Color.yellow,Color.white);
)

// change direction and resolution
(
w = Window.new.front;
w.view.background = Gradient(Color.red,Color.white,\v, 5);
)

// almost unnoticeable variations can be pleasant
(
w = Window.new.front;
v = CompositeView(w, Rect(50,50,300,300));
c = Color.rand;
d = c.vary(0.15);
v.background = Gradient(c, d, \v);
[c, d].postln
)

(
var w, k, c, d, e, c1, c2, f, g;
w = Window.new.front;
k = Slider2D(w, Rect(50,50,300,300));
f = {
	c = Color.rand;
	d = c.vary(0.5);
	e = d.vary(0.5);
};
g = {
	c1 = d.hueBlend(e, k.y).round(0.01);
	c2 = c.hueBlend(e, k.x).round(0.01);
	k.background = Gradient(c1, c2, \v)
};
f.value; g.value;
k.action = g;
k.mouseUpAction = { [c1, c2].postln };
k.keyDownAction = f; // hit any key for new color
)

// an example using gradient indirectly to update window colour
(
w=Window.new.front;
g = Gradient(Color.red,Color.green);
Task{
	(0, 0.01 .. 1).do{|pos|
		w.view.background = g.at(pos);
		0.01.wait;
	};
}.play(AppClock)
)
::


class:: GrainBuf
summary:: Granular synthesis with sound stored in a buffer
categories:: UGens>Buffer, UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainFM, Classes/GrainSin, Classes/TGrains

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: sndbuf
the buffer holding a mono audio signal. If using multi-channel files, use Buffer.readChannel.

argument:: rate
the playback rate of the sampled sound

argument:: pos
the playback position for the grain to start with (0 is beginning, 1 is end of file)

argument:: interp
the interpolation method used for pitchshifting grains:
list::
## 1 = no interpolation
## 2 = linear
## 4 = cubic interpolation (more computationally intensive)
::

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, panning is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

examples::
code::
s.boot;

(
var winenv;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\buf_grain_test, { |out, gate = 1, amp = 1, sndbuf, envbuf|
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: Done.freeSelf);
	Out.ar(out,
		GrainBuf.ar(2, Impulse.kr(10), 0.1, sndbuf, LFNoise1.kr.range(0.5, 2),
			LFNoise2.kr(0.1).range(0, 1), 2, pan, envbuf) * env)
}).add;
)

// use built-in env
x = Synth(\buf_grain_test, [\sndbuf, b, \envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::



class:: GrainFM
summary:: Granular synthesis with frequency modulated sine tones
categories:: UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainSin, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: carfreq
the carrier freq of the grain generators internal oscillator

argument:: modfreq
the modulating freq of the grain generators internal oscillator

argument:: index
the index of modulation

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

examples::
code::
s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\fm_grain_test, { |out, gate = 1, amp = 1, envbuf|
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	// use WhiteNoise and mouse y to control deviation from center pitch
	freqdev = WhiteNoise.kr(MouseY.kr(0, 400));
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: Done.freeSelf);
	Out.ar(out,
		GrainFM.ar(2, Impulse.kr(10), 0.1, 440 + freqdev, 200, LFNoise1.kr.range(1, 10),
			pan, envbuf) * env)
}).add;

)

// use built-in env
x = Synth(\fm_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::



class:: GrainIn
summary:: Granulate an input signal
categories:: UGens>Generators>Granular
related:: Classes/GrainSin, Classes/GrainFM, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: in
the input to granulate

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

Examples::
code::
s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\in_grain_test, { |out, gate = 1, amp = 1, envbuf|
	var pan, env;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: Done.freeSelf);
	Out.ar(out,
		GrainIn.ar(2, Impulse.kr(32), 1, PinkNoise.ar * 0.05, pan, envbuf) * env)
}).add;

)

// use built-in env
x = Synth(\in_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::



class:: GrainSin
summary:: Granular synthesis with sine tones
categories:: UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainFM, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: freq
the input to granulate

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.

instancemethods::
private:: init, argNamesInputsOffset

Examples::
code::

s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\sin_grain_test, { |out, gate = 1, amp = 1, envbuf|
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	// use WhiteNoise and mouse y to control deviation from center pitch
	freqdev = WhiteNoise.kr(MouseY.kr(0, 400));
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: Done.freeSelf
	);
	Out.ar(out,
		GrainSin.ar(2, Impulse.kr(10), 0.1, 440 + freqdev, pan, envbuf) * env)
}).add;
)

s.scope
// use built-in env
x = Synth(\sin_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::



class:: GrayNoise
summary:: Gray Noise.
related:: Classes/BrownNoise, Classes/ClipNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise which results from flipping random bits in a word.
This type of noise has a high RMS level relative to its peak to peak
level. The spectrum is emphasized towards lower frequencies.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-GrayNoise", { arg out=0;
	Out.ar(out,
		GrayNoise.ar(0.1)
	)
}).play;
)

::



CLASS:: GridLayout
summary:: A layout that organizes views in a grid
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/StackLayout, Guides/GUI-Layout-Management

DESCRIPTION::

GridLayout distributes its space into a strong::grid of rows and columns::, where each item can occupy strong::one or more cells::.

You can construct the layout in two ways using link::#*rows:: and link::#*columns::. In the former constructor you pass arrays of items by rows, and in the latter by columns. Items can also be added later using link::#-add:: and link::#-addSpanning::. To remove an item, simply use link::Classes/View#-remove:: for views, or link::Classes/QObject#-destroy:: for views or layouts.

It is possible to add more than one view into the same cell. The last added view will be the top-most. However, it is most probably more convenient to use a link::Classes/StackLayout:: for that purpose.

The layout manages the grid size automatically: you can add an item at any row and cell number. When items are added or removed, the grid will re-adjust according to the last occupied row and column.

subsection:: Fine tuning

Each item can be assigned an strong::alignment:: either at layout link::#*rows#construction:: or later using link::#-setAlignment::. An item will then get at most its default size, if available (see: link::Classes/View#-sizeHint::), and will be aligned within its cell according to the specified alignment.

Each row or column can be assigned a strong::stretch factor:: using link::#-setRowStretch:: and link::#-setColumnStretch::. Rows or columns that would otherwise get equal space are then distributed according to the relative proportions of their stretch factors.

Each row or column can also be assigned a strong::minimum:: size using link::#-setMinRowHeight:: and link::#-setMinColumnWidth::, to override the size constraints imposed by the contained views.

In addition to adjusting the spacing between cells using link::Classes/Layout#-spacing:: you can control the spacing between rows and between columns separately using link::#-hSpacing:: and link::#-vSpacing::.

subsection:: Leaving empty space

You can leave any cell empty by not placing any item into it, or at link::#*rows#construction:: using code::nil:: instead of a view or another layout. Note though that the empty cells will always be regarded as freely stretchable and will not impose any constraints on space distribution.



CLASSMETHODS::

PRIVATE:: key
PRIVATE:: qtClass

METHOD:: rows

    Creates a GridLayout and fills each row with an array of items given as arguments.

    argument:: ... rows

    Each argument is an Array of items to form a consecutive row. An item can be a strong::view::, another strong::layout::, or strong::nil:: for an empty cell.

    discussion::

    You can make an item span more than one cell by wrapping it into an Array, followed by pairs of (\rows, number) and/or (\columns, number). You can also assign an alignment to an item by following it with a pair of (\align, alignment). \rows, \columns, and \align can be abbreviated with \r, \c, and \a, respectively. For possible alignment values see link::Reference/gui_alignments::.

    The simplified syntax for placing key-value pairs into an array comes handy (see link::Reference/Syntax-Shortcuts#Creating Arrays with key-value pairs::, and the example below).

    Example:
Code::
(
w=Window().layout_( GridLayout.rows(
    [Slider2D(), Slider2D(), [Slider(), rows:2]],
    [Slider2D(), Slider2D()],
    [[Slider().orientation_(\horizontal), columns:2]]
)).front;
)
::

METHOD:: columns

    Creates a GridLayout and fills each column with an array of items given as arguments.

    argument:: ... cols

    Each argument is an Array of items to form a consecutive column. An item can be a strong::view::, another strong::layout::, or strong::nil:: for an empty cell.

    discussion::

    To make an item span several cells, or assign an alignment to it, the same instructions as for link::#*rows:: apply.



INSTANCEMETHODS::

METHOD:: add

    Adds an item into the cell at specified row and column.

    argument:: item
    The item can be a strong::view:: or another strong::layout::.

    argument:: row
    The row index.

    argument:: column
    The column index.

    argument:: align
    A symbol denoting the alignment, or nil. See link::Reference/gui_alignments:: for possible values.

METHOD:: addSpanning

    Adds an item into the grid so as to occupy several cells.

    argument:: item
    The item can be a strong::view:: or another strong::layout::.

    argument:: row
    The row index.

    argument:: column
    The column index.

    argument:: rowSpan
    The amount of cells to occupy in vertical direction.

    argument:: columnSpan
    The amount of cells to occupy in horizontal direction.

    argument:: align
    A symbol denoting the alignment, or nil. See link::Reference/gui_alignments:: for possible values.

METHOD:: hSpacing

    The spacing between columns, in Integer amount of pixels.

METHOD:: vSpacing

    The spacing between rows, in Integer amount of pixels.

METHOD:: setRowStretch

    Sets the stretch factor of a row. By default rows have a stretch factor of 0. If a larger factor is assigned to a row, rows will get their space redistributed according to the relative proportions of their factors.

    argument:: row
    The index of a row.

    argument:: factor
    An Integer.

METHOD:: setColumnStretch

    Sets the stretch factor of a column. By default columns have a stretch factor of 0. If a larger factor is assigned to a column, columns will get their space redistributed according to the relative proportions of their factors.

    argument:: column
    The index of a column.

    argument:: factor
    An Integer.

METHOD:: setAlignment

    Sets the alignment of an item managed by the layout.

    argument:: item
    A view or a layout managed by this layout, or a Point of which x denotes the column index and y the row index of an item.

    argument:: align
    A symbol denoting the alignment. See link::Reference/gui_alignments:: for possible values.

METHOD:: minRowHeight

    Gets the minimum height assigned to a row.

    argument:: row
    The index of a row.

METHOD:: setMinRowHeight

    Sets the minimum height of row.

    argument:: row
    The index of a row.

    argument:: height
    An Integer amount of pixels.

METHOD:: minColumnWidth

    Gets the minimum width assigned to a column.

    argument:: column
    The index of a column.

METHOD:: setMinColumnWidth

    Sets the minimum width of a column.

    argument:: column
    The index of a column.

    argument:: width
    An Integer amount of pixels.


CLASS:: GridLines
summary:: A factory class for AbstractGridLines
categories:: GUI>Accessories
related:: Classes/AbstractGridLines, Classes/LinearGridLines, Classes/ExponentialGridLines, Classes/DrawGrid, Classes/ControlSpec, Classes/Plotter, Reference/plot


DESCRIPTION::
code::GridLines:: is a factory class that returns the appropriate subclass of link::Classes/AbstractGridLines:: for a given code::ControlSpec::, e.g. a link::Classes/LinearGridLines:: or link::Classes/ExponentialGridLines:: for a linear or exponential spec, respectively. See those help files for examples and information on modifying their behavior.


CLASSMETHODS::

METHOD:: new

argument:: spec
A link::Classes/ControlSpec:: that defines the minimum and maximum values, warp and step.

returns:: A subclass of link::Classes/AbstractGridLines::, e.g. link::Classes/LinearGridLines:: or link::Classes/ExponentialGridLines::.


class:: Group
summary:: Client-side representation of a group node on the server
categories:: Server>Nodes, Server>Abstractions

description::
A Group is the client-side representation of a group node on the server, which is a collection of other nodes organized as a linked list.
The Nodes within a Group may be controlled together, and may be both link::Classes/Synth::s and other Groups.
Groups are thus useful for controlling a number of nodes at once, and when used as targets can be very helpful in controlling order of execution. (See link::Guides/Order-of-execution:: for more details on this topic).

For more on the crucial distinction between client objects and server nodes, see link::Guides/ClientVsServer::. For information on creating nodes without using objects, see link::Guides/NodeMessaging::.

N.B. Group is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file. Please refer to it for more information.

subsection:: RootNode and the default groups

When a Server is booted, there is a top level group with an ID of 0 that
defines the root of the tree. This is represented by a subclass of Group:
link::Classes/RootNode::.

sclang has the notion of a "default group," which is automatically created when
the server is booted. This group is the default enclosing group for all Nodes,
i.e. it's what you get if you don't specify. In general you should create new
Nodes within the default group of a Server rather than in its RootNode.
Multiclient setups may have different default groups for each client. See
link::Reference/default_group::, link::Classes/Server::, and
link::Classes/RootNode:: for more detail.

subsection:: Bundling

Some of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more detail.

classmethods::
private:: creationCmd

subsection:: Creation with Immediate Instantiation on the Server

method:: new
Create and return a Group.

argument:: target
A target for this Group. If target is not a Group or Synth, it will be converted as follows: If it is a Server, it will be converted to the default_group of that server. If it is nil, to the default_group of the default Server.
argument:: addAction
one of the following Symbols:
table::
## \addToHead || (the default) add at the head of the group specified by target
## \addToTail || add at the tail of the group specified by target
## \addAfter || add immediately after target in its server's node order
## \addBefore || add immediately before target in its server's node order
## \addReplace || replace target and take its place in its server's node order
::
Note: A Synth is not a valid target for \addToHead and \addToTail.
discussion::
code::
s.boot;
g = Group.new; // add a Group at the head of the default Server's default group
h = Group.new(g, \addAfter);
s.queryAllNodes; // note the Group within the default group (ID 1)
g.free; h.free;
::

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions above:

method:: after
Create and return a Group and add it immediately after aNode.

method:: before
Create and return a Group and add it immediately before aNode.

method:: head
Create and return a Group. If aGroup is a Group add it at the head of that group. If it is a Server, add it at the head of the default_group of that server. If it is nil, add it at the head of the default_group of the default Server.

method:: tail
Create and return a Group. If aGroup is a Group add it at the tail of that group. If it is a Server, add it at the tail of the default_group of that server. If it is nil, add it at the tail of the default_group of the default Server.

method:: replace
Create and return a Group and use it to replace nodeToReplace, taking its place in its server's node order.

subsection:: Creation without Instantiation on the Server

For use in message bundles it is also possible to create a Group object in the client app without immediately creating a group node on the server. Once done one can call methods which create messages to add to a bundle, which when sent to the server will instantiate the group or perform other operations. (See strong::Control::, below.)

method:: basicNew
Create and return a Group object without creating a group node on the server. (This method is inherited from Node and is documented here only for convenience.)
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.
discussion::
code::
s.boot;
g = Group.basicNew(s); // Create without sending
s.sendBundle(nil, g.newMsg;); // Now send a message; create at the head of s' default group
s.queryAllNodes;
g.free;
::

After creation, use instance methods code::newMsg, addToHeadMsg, addToTailMsg, addBeforeMsg, addAfterMsg, addReplaceMsg:: to instantiate this synth on the server. See link::#instancemethods#Instance Methods:: below.


instancemethods::

subsection:: Creation without Instantiation on the Server
Use class method code::basicNew:: to create a Synth without instantiating it on the server. Then use the following instance methods:

method:: newMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If target is nil, it will default to the default_group of the Server specified in *basicNew when this Group was created. The default addAction is \addToHead. (See *new above for details of addActions.

method:: addToHeadMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the head of that group. If it is nil, it will be added at the head of the default_group of this Group's server (as specified when *basicNew was called).

method:: addToTailMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the tail of that group. If it is nil, it will be added at the tail of the default_group of this Group's server (as specified when *basicNew was called).

method:: addBeforeMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately before aNode.

method:: addAfterMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately after aNode.

method:: addReplaceMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, replacing nodeToReplace in the server's node order.

subsection:: Control and Introspection

For further methods of controlling Groups (set, map, etc.), see the link::Classes/Node:: help file.

method:: moveNodeToHead, moveNodeToHeadMsg
Move aNode to the head of this group

method:: moveNodeToTail, moveNodeToTailMsg
Move aNode to the tail of this group

method:: freeAll, freeAllMsg
Free all the nodes in this group, but do not free this group itself.

method:: deepFree, deepFreeMsg
Free all Synths in the group, and all Synths in any enclosed groups, but do not free this group or any of its enclosed groups.

method:: dumpTree
Post a representation of this group's node subtree. (Sends a message of the type g_dumpTree.) If code::postControls:: is true, then the current Control (arg) values for any synths contained in this group will be posted as well. The default is false.

method:: queryTree
Queries the server for a message describing this group's node subtree. (Sends a message of the type g_queryTree.) This reply is passed to the action function as an argument. See g_queryTree in link::Reference/Server-Command-Reference:: or the example below for information on how the reply is structured.


Examples::
code::
s.boot;

(
SynthDef("help-Group-moto-rev", { arg out=0,freq=100,ffreq=120;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, freq), [0,0.1], 0.1),
		ffreq, 0.1).clip2(0.4);
	Out.ar(out, x);
}).add;


SynthDef("help-Group-wah", { arg out, rate = 1.5, cfreq = 1400, mfreq = 1200, rq=0.1;
	var zin, zout, q;

	zin = In.ar(out, 2);
	cfreq = Lag3.kr(cfreq, 0.1);
	mfreq = Lag3.kr(mfreq, 0.1);
	q   = Ramp.kr(rq, 0.1);
	zout = RLPF.ar(zin, LFNoise1.kr(rate, mfreq, cfreq), q, 10).distort
		* 0.15;

	// replace the incoming bus with the effected version
	ReplaceOut.ar( out , zout );

}).add;
)

g = Group.new;

(
l = Array.fill(3,{
	// random freq for each synth, added to g at the head
	Synth("help-Group-moto-rev",["out",0,"freq",rrand(10,120)],g,\addToHead);
});
)

// set all controls that match "ffreq" in all nodes in g to 90
g.set("ffreq",300);

g.set("freq",80);

// since we stored the Synths in an Array, we can also control them individually
(
r = Routine({
	inf.do({
		l.do({ arg node;
			node.set("freq",rrand(10,120));
			1.0.wait;
		});
	})
});

r.play;
)

// g is in a group too. Since we didn't specify it's the default group (ID 1) of the default Server
g.group.inspect;

// asking a wah to go order-of-execution after g, in the same group as g.
x = Synth.after(g,"help-Group-wah",["out",0]);

// now dump my tree to confirm
g.dumpTree;

x.free;

// free all nodes in g, but not g itself
g.freeAll;

// don't forget the Routine is still running...
r.stop;

// oh, and set l to nil so the Synths and Array can be garbage collected
l = nil;

// and i'm still on the server, its just my children that were freed
g.query;

// don't need the individual synth objects this time
(
3.do({
	// random freq for each synth, added to g at the head
	Synth("help-Group-moto-rev",["out",0,"freq",rrand(10,1200)],g,\addToHead);
});
)

// now query my tree and post a graph of it (duplicates dumpTree)
// msg format is ['/g_querytree.reply', node1-ID, numChildren, defName, child1-ID, numChildren, ...]
(
g.queryTree({|msg|
   var i = 1, tabs = 0, dumpFunc;
   ("NODE TREE Group" + msg[1]).postln;
   if(msg[2] > 0, {
       dumpFunc = {|numChildren|
           tabs = tabs + 1;
           numChildren.do({
               i = i + 3;
               tabs.do({ "   ".post });
               msg[i].post;
               (" " ++ msg[i + 2]).postln;
               if(msg[i + 1] > 0, { dumpFunc.value(msg[i + 1]) });
           });
           tabs = tabs - 1;
       };
       dumpFunc.value(msg[2]);
   });
});
)

// kill me and my children
g.free;

// see, I'm gone
g.query;
::



TITLE:: HID
summary:: This class provides access to human input devices, or in short HID, such as joysticks, gamepads, mice, keyboard, and so on.
categories:: External Control>HID
related:: Classes/HIDFunc, Guides/Working_with_HID, Classes/HIDElement, Classes/HIDCollection, Classes/HIDUsage, Classes/HIDInfo

DESCRIPTION::
Human input devices can be used as controllers for making music. This class provides you with access to them in a simple and transparent way.

The development of this SuperCollider implementation of HID access was funded by the SuperCollider community and BEK, Bergen Elektronisk Kunst, Bergen, Norway, http://www.bek.no

SUBSECTION:: Introduction
In general using an Human Input Device follows this scheme:

DEFINITIONLIST::
	## Find available devices:
	|| code:: HID.findAvailable; ::
	## Print a readable list of available devices:
	|| code:: HID.postAvailable; ::
	## Open a specific device:
	|| code:: ~myhid = HID.open( 1103, 53251 ); ::
	## Set actions for specific elements:
	|| code:: ~myhid.elements[1].action = { |...args| args.postln; };
::

See LINK::Guides/Working_with_HID:: for a full introduction.

::


CLASSMETHODS::

PRIVATE:: doPrAction, prInitHID, prCloseAll, prOpenDevice, prCloseDevice, prHIDDeviceClosed, prGetDeviceInfo, prGetNumberOfCollections, prGetCollectionInfo, prGetNumberOfElements, prGetElementInfo, prSetElementOutput, prSetElementRepeat, prbuildDeviceList, deviceClosed, prHIDElementData, prHIDDeviceData, basicNew, mergeUsageDict, removeUsageDict

SUBSECTION:: Finding devices

METHOD:: findAvailable
queries the operating system which HID devices are attached to the system and can be accessed. When using HID this is the first method you need to execute, before you can access any device.

returns:: an IdentityDictionary of available devices

METHOD:: available
A dictionary of available devices, or rather info about them in an instance of LINK::Classes/HIDInfo::, populated by the method findAvailable

returns:: an IdentityDictionary

METHOD:: postAvailable
posts a human readable list of available HID devices and their properties (see also LINK::Classes/HIDInfo::)


METHOD:: findBy
Find devices in the available device dictionary by specifying one or more characteristics of the device

ARGUMENT:: vendorID
The vendor ID of the device, this is a number encoded by the device itself, and the same across platforms.

ARGUMENT:: productID
The product ID of the device, this is a number encoded by the device itself, and the same across platforms.

ARGUMENT:: path
The path of the device, this is a path defined by the operating system, and thus not the same across platforms, but essential to distinguish devices with the same vendor and product ID from each other.

ARGUMENT:: serial
The serial number of the device. This is dependent on the operating system, e.g. on Linux it is not set.

ARGUMENT:: releaseNumber
The release number of the device, this is a number encoded by the device itself, and the same across platforms.

returns:: an IdentityDictionary of devices the match the search query, or nil if no arguments are given


METHOD:: availableUsages
A dictionary of available usages from all HIDs, populated automatically when devices are opened and closed.

returns:: an IdentityDictionary


METHOD:: postAvailableUsages
posts a human readable list of available HID usages and their properties (see also LINK::Classes/HIDElement:: and LINK::Classes/HIDUsage::)


SUBSECTION:: Opening devices

METHOD:: open
Open a device with a given vendorID, product ID and optionally a path.

ARGUMENT:: vendorID
The vendor ID of the device

ARGUMENT:: productID
The product ID of the device

ARGUMENT:: path
(optional) The path in the operating system, e.g. "/dev/hidraw0" on Linux.
If not specified, the method will look for a matching device in the device list, and open the first match it finds.

returns:: The HID device - an instance of HID.

METHOD:: new
Same as HID.open


METHOD:: openPath
Open a device using its path in the operating system

ARGUMENT:: path
The path in the operating system, e.g. "/dev/hidraw0" on Linux

returns:: The HID device - an instance of HID.

METHOD:: openAt
Open a device using its index in the dictionary of available devices

ARGUMENT:: index
The index into the dictionary of available devices

returns:: The HID device - an instance of HID.


METHOD:: openDevices
A dictionary of the opened devices

returns:: an IdentityDictionary


SUBSECTION:: Adding functions to HID events

Whenever data comes in from an opened HID device, there are two types of actions fired. An action for the incoming element data and an action for the device, indicating that there has been a change in one of the elements. In most cases you will want to use the first action; only in cases where the order of parsing the element data is important, you may want to use the second type - e.g. when dealing with very accurately timed button press combinations.

There are three levels where you can set actions:
LIST::
	## at the global level - called for any HID device, for any element
	## at the device level - called for the specific device, for any element
	## at the element level - called for the specific element of the specific device
::

Alternately, you can also use the LINK::Classes/HIDFunc:: interface.



METHOD:: debug
When set to true, the incoming data from any opened HID device will be printed to the post window.



METHOD:: action
Set or get the action to be performed upon receiving element data from the device. The function will be passed the following arguments: the value (mapped between 0 and 1), the raw value, element usage page, the element usage, the element id, the device id, the device (an instance of HID).

ARGUMENT:: function
The function to be performed upon receiving element data from the device


METHOD:: addRecvFunc
add a function to the internal FunctionList that will be evaluated whenever element data comes in from an open device. The arguments passed to the function are as defined above.
Use this method if you want to add actions to HID functions from classes you write, so that you still keep the option to add an action on the fly from user code.

ARGUMENT:: function
The function to be added to the list.


METHOD:: removeRecvFunc
remove a function to the internal FunctionList that will be evaluated whenever data comes in from a device.


ARGUMENT:: function
The function to remove from the list, this must be a reference to the Function that was originally added to the list


METHOD:: deviceAction
set an action or function to be performed whenever there is an update to any device's elements.

ARGUMENT:: function
The function to be performed upon receiving data from the device


METHOD:: addDevFunc
add a function to the internal FunctionList that will be evaluated whenever data comes in from a device.

ARGUMENT:: function
The function to be performed upon receiving data from the device


METHOD:: removeDevFunc
remove a function to the internal FunctionList that will be evaluated whenever data comes in from a device.


ARGUMENT:: function
The function to remove from the list, this must be a reference to the Function that was originally added to the list




SUBSECTION:: Managing the HID subsystem

The following methods are used internally to initialize and finalize the HID subsystem, but in rare cases you may wish to manage these methods manually.

METHOD:: initializeHID
Initialize the HID subsystem, this method is called automatically when calling the method findAvailable.


METHOD:: running
Indicates whether or not the HID subsystem is running.


METHOD:: closeAll
This method is called automatically upon Shutdown, if the HID subsystem was initialized. It can be stopped manually, in order to save system resources. This method will close all opened HID devices.


INSTANCEMETHODS::

PRIVATE::init, getInfo, getElements, getElementInfo, getCollections, getCollectionInfo, getUsages, id, valueAction, valueDeviceAction, info_, prDeviceClosed


METHOD:: elements
An IdentityDictionary holding all the elements, i.e. controls, of the device


METHOD:: findElementWithUsage
Find all elements with a certain usage and usagePage.

ARGUMENT:: elUsage
The usage index of the element

ARGUMENT:: elUsagePage
The usage page of the element

returns:: an Array with the found elements


METHOD:: getElementWithID
Get the element with the given index

ARGUMENT:: elid
The index of the element

returns:: the HIDElement

METHOD:: close
Close the HID device, closing a device is asynchronous. You can set a closeAction (see below), which will be performed when the device closes.

METHOD:: isOpen
Returns true if the device is open, false if the device was closed.

returns: a Boolean


METHOD:: collections
An IdentityDictionary holding all the collections, i.e. groups of controls, of the device



SUBSECTION:: Adding functionality to the device

METHOD:: debug
When set to true, the incoming data from this HID device will be printed to the post window.


METHOD:: closeAction
Function to be performed when device is closed.


METHOD:: action
Set or get the action to be performed upon receiving element data from the device. The function will be passed the following arguments: the value (mapped between 0 and 1), the raw value, element usage page, the element usage, the element id

ARGUMENT:: function
The function to be performed upon receiving element data from the device


METHOD:: deviceAction
set an action or function to be performed whenever there is an update to any of the device's elements.

ARGUMENT:: function
The function to be performed upon receiving data from the device



SUBSECTION:: Posting human readable information about the device

METHOD:: postInfo
Post the HIDInfo of this device in a human readable format

METHOD:: postCollections
Post information about all the collections of this device in a human readable format

METHOD:: postElements
Post information about all the elements of this device in a human readable format

METHOD:: postInputElements
Post information about all the input elements of this device in a human readable format

METHOD:: postOutputElements
Post information about all the output elements of this device in a human readable format

METHOD:: postFeatureElements
Post information about all the feature elements of this device in a human readable format


METHOD:: postUsages
Post information about all the usages of this device in a human readable format


SUBSECTION:: Properties of the device

METHOD:: info
Retrieve the HIDInfo of this device

returns:: an instance of HIDInfo


METHOD:: usage
Retrieve the usage index of a collection of this device, or the main usage of the device (if called without an argument).

ARGUMENT:: collectionID
The collection of which to retrieve the usage. Default is 0, which should define the primary usage of the device.

returns:: the usage index of this device

METHOD:: usageName
Retrieve the usage name of a collection of this device, or the main usage of the device (if called without an argument). The name is looked up from the standardized HID usage tables using the usage index.

ARGUMENT:: collectionID
The collection of which to retrieve the usage. Default is 0, which should define the primary usage of the device.

returns:: the usage name of this device


METHOD:: usagePage
Retrieve the usage page index of a collection of this device, or the main page of the device (if called without an argument). The name is looked up from the standardized HID usage tables using the usage page index.

ARGUMENT:: collectionID
The collection of which to retrieve the usage page. Default is 0, which should define the primary usage of the device.

returns:: the usage page index of this device


METHOD:: pageName

Retrieve the page name of a collection of this device, or the main page of the device (if called without an argument). The name is looked up from the standardized HID usage tables using the usage page index.

ARGUMENT:: collectionID
The collection of which to retrieve the usage page name. Default is 0, which should define the primary usage of the device.

returns:: the usage page name of this device


METHOD:: vendor
Retrieve the vendor id of this device

returns:: the vendor id


METHOD:: product
Retrieve the product id of this device

returns:: the product id


METHOD:: usages
Retrieve the usages of the elements of this device.

returns:: an IdentityDictionary with usages as keys and lists of elements as corresponding elements



EXAMPLES::

code::
HID.findAvailable; // check which devices are attached
~myhid = HID.open( 1103, 53251 ); // open the Run'N' Drive game controller

s.boot; // boot the server

Ndef( \sinewave, { |freq=500, amp=0.1| SinOsc.ar( freq, 0, amp * 0.2 ) } );
Ndef( \sinewave ).play;

~freqRange = [500, 5000, \exponential].asSpec; // create a frequency range

HIDdef.usage( \freq, { |value| Ndef( \sinewave ).set( \freq, ~freqRange.map( value ) ); }, \X );
HIDdef.usage( \amp, { |value| Ndef( \sinewave ).set( \amp, value ); }, \Y );
::


TITLE:: HIDCollection
summary:: A class describing a group of elements of an HID device
categories::  External Control>HID
related:: Classes/HID, Guides/Working_with_HID, Classes/HIDElement, Classes/HIDUsage

DESCRIPTION::
An HIDCollection defines a group of controls on a low level of the HID device, i.e. the device reports these groups. The main use to access it is to retrieve information about what kind of function the HID device performs, e.g. a GamePad, a Joystick or a Mouse.

This class is populated with information read from the device, and represents some of the internal information of the device.

CLASSMETHODS::

PRIVATE::new


INSTANCEMETHODS::
PRIVATE::printOn

METHOD:: postCollection
Post a human readable description of the collection to the post window.


METHOD:: usage
Retrieve the usage index of this collection.

returns:: a Number - the usage index of this collection


METHOD:: usagePage
Retrieve the usage page index of this collection.

returns:: a Number- the usage page index


METHOD:: usageName
Retrieve the usage name of this collection. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage name

METHOD:: pageName
Retrieve the page name of this collection. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage page name


METHOD:: type
The type of collection.

returns:: a number describing the type of collection.


METHOD:: device
Get the device to which this collection belongs.
NOTE:: do not set this as a user!::

returns:: an instance of HID


METHOD:: id
Index of this collection

returns:: a Number

METHOD:: parent
Index of the parent of this collection.

returns:: a Number

METHOD:: numElements
Number of elements in this collection

returns:: a Number

METHOD:: firstElement

The first element that is part of this collection.

returns:: a Number - an index indicating the first element



METHOD:: numCollections
Number of (child) collections in this collection

returns:: a Number

METHOD:: firstCollection
The first collection that is part of this collection.

returns:: a Number - an index indicating the first collection


TITLE:: HIDElement
summary:: A class describing an element of an HID device
categories::  External Control>HID
related:: Classes/HID, Guides/Working_with_HID, Classes/HIDCollection, Classes/HIDUsage

DESCRIPTION::
An HIDElement describes an element, or a control, of an HID device.
These are created for the device automatically when you open a device. The only interaction a user will have with elements are to query the properties of the element (with CODE::.postElement::), query the CODE::value:: or CODE::rawValue::, or set the value, set the CODE::repeat:: property or set an CODE::action:: to be performed when new data comes in.

CLASSMETHODS::

PRIVATE:: new


INSTANCEMETHODS::

PRIVATE:: setValueFromInput, mapValueFromRaw, initElementRepeat


METHOD:: action
Set or get the action to be performed upon receiving element data. The function will be passed the following arguments: the value (mapped between 0 and 1) and the raw value.


METHOD:: value
set or get the value of the element. Setting only makes sense for an output element.

ARGUMENT:: val
The raw value to send to the device


METHOD:: repeat
By default element's data from the device is not updated unless the data is changing. For certain elements however, you may want to receive updates even if the data is not changing, e.g. for scrollwheel of mice.

ARGUMENT:: rp
a Boolean to turn repeat on or off


METHOD:: rawValue
The raw value of the element.

METHOD:: logicalValue
The logical value of the element. In principal the same as value.

METHOD:: physicalValue
The physical value of the element. This can be calculated from the raw value and the device's specification for conversion: the physical minimum, the physical maximum, the unit and unit exponent. How the conversion works is described in the USB HID standard documentation. NOTE::The conversion is not yet implemented in the backend.::

METHOD:: arrayValue
The array value of the element. This value is only of importance for those elements which can represent multiple usages, such as from keyboards. In that case it indicates the key that is pressed, and by adding this number to the usage of the element you know which function the key has.

NOTE:: values from a keyboard are parsed in two ways: first as the element how they come in, second just with the usage and the value (on or off) as the data comes in. ::


SUBSECTION:: Properties of the element

METHOD:: postElement
Post a human readable description of the element to the post window.


METHOD:: id
The index of this element. This index may vary between operating systems.

METHOD:: device
Get the device to which this element belongs.
NOTE:: do not set this as a user!::

returns:: an instance of HID

METHOD:: collection
Get the collection index to which this element belongs.


METHOD:: usage
Retrieve the usage index of this collection.

returns:: a Number - the usage index of this element


METHOD:: usagePage
Retrieve the usage page index of this element.

returns:: a Number- the usage page index


METHOD:: usageName
Retrieve the usage name of this element. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage name

METHOD:: pageName
Retrieve the page name of this element. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage page name


METHOD:: type
A byte describing the type of element.

returns:: a number describing the type of element.

METHOD:: typeSpec
The type of element, decoded from the type byte.

returns:: an Array with Strings describing the type of element.

METHOD:: ioType
Type of the element, input (1), output (2) or feature (3)

returns:: a Number indicating the ioType

METHOD:: iotypeName
Type of the element, one of code::\input::, code::\output::, or code::\feature::

returns:: a Symbol indicating the type


METHOD:: logicalMin
Minimum value of the range that is to be expected. This is reported by the device. The element's raw value is mapped between the logical minimum and maximum to obtain the element's value.


METHOD:: logicalMax
Maximum value of the range that is to be expected. This is reported by the device. The element's raw value is mapped between the logical minimum and maximum to obtain the element's value.


METHOD:: physicalMin
Minimum value of the range that is to be expected in a physical sense. This is reported by the device. For example, for a hat switch the physical range may be the direction in degrees in which the hat switch is pointing.

METHOD:: physicalMax
Maximum value of the range that is to be expected in a physical sense. This is reported by the device. For example, for a hat switch the physical range may be the direction in degrees in which the hat switch is pointing.

METHOD:: unit
Index for the unit of the physical range.

METHOD:: unitExponent
The exponent for the physical range.


METHOD:: usageMin
Minimum value of the usage range that is to be expected. This is reported by the device. This is only relevant for elements that report array values.


METHOD:: usageMax
Maximum value of the usage range that is to be expected. This is reported by the device. This is only relevant for elements that report array values.

METHOD:: getUsages
This method is used to get a dictionary of all the usages that this element produces. In most cases an element has only one usage, but in the case of an array-element it will have several uses (for a keyboard, an element represents one keypress, but they can be various different keys).

METHOD:: reportID
The report ID with which this element receives the data. This is a low level device specific identifier


METHOD:: reportSize
The report size in bits with which this element receives the data. This is a low level device specific identifier

METHOD:: reportIndex
The report index with which this element receives the data. This is a low level device specific identifier


EXAMPLES::

code::
HID.findAvailable; // find available devices
HID.postAvailable; // post available devices
~myhid = HID.open( 1103, 53251 ); // open a device
~myhid.postElements; // post available elements
//Set actions for the second element:
~myhid.elements[1].action = { |...args| args.postln; };
::


TITLE:: HIDElementProto
summary:: Prototype HID element to match with HIDFunc
categories:: External Control>HID
related:: Classes/HIDFunc, Classes/HIDdef, Classes/HIDProto, Classes/HID, Classes/HIDElement, Classes/HIDInfo, Guides/Working_with_HID

DESCRIPTION::
Human input devices can be used as controllers for making music. This class can be used in conjunction with link::Classes/HIDFunc:: or link::Classes/HIDdef:: to match incoming messages with a particular link::Classes/HID:: device.

HIDElementProto has all the variables that specify an HID element. The more of these variables you specify, the more need to be matched when filtering the incoming HID data.


CLASSMETHODS::

METHOD:: new
Create a new instance of HIDElementProto.

METHOD:: newType
Create a new instance of HIDElementProto based on usage id and usage page id of the element.

ARGUMENT:: uName
Name of the usage ID to match

ARGUMENT:: pName
Name of the usage page to match

returns:: an HIDElementProto


METHOD:: newTypeID
Create a new instance of HIDElementProto based on usage id and usage page id of the element.

ARGUMENT:: uID
Usage ID to match

ARGUMENT:: pID
Usage page ID to match

returns:: an HIDElementProto

METHOD:: newFromDict
Create a new instance of HIDElementProto based on an IdentityDictionary with a set of parameters to match.


ARGUMENT:: dict
An IdentityDictionary with a set of parameters to match. The keys in the dictionary should be one of the instance variables of HIDElementProto.

returns:: an HIDElementProto



INSTANCEMETHODS::

SUBSECTION:: Instance variables that can be used to match a device

METHOD:: id
The element index that should be matched. This index may vary between operating systems (see also link::Classes/HIDElement::).


METHOD:: usageName
The usage name of the element to match (see also link::Classes/HIDElement::).

METHOD:: pageName
The usage page name of the element to match (see also link::Classes/HIDElement::).

METHOD:: usage
The usage index of the element to match (see also link::Classes/HIDElement::).

METHOD:: usagePage
The usage page index of the element to match (see also link::Classes/HIDElement::).


METHOD:: usageMin
The minimum usage index of the element to match (see also link::Classes/HIDElement::).


METHOD:: usageMax
The maximum usage index of the element to match (see also link::Classes/HIDElement::).



METHOD:: type
The type of the element to match (see also link::Classes/HIDElement::).


METHOD:: typeSpec
The typeSpec of the element to match (see also link::Classes/HIDElement::).


METHOD:: ioType
The IO type of the element to match - input (1), output (2) or feature (3) (see also link::Classes/HIDElement::).


METHOD:: iotypeName
The IO type of the element to match - code::\input::, code::\output:: or code::\feature:: (see also link::Classes/HIDElement::).


SUBSECTION:: Methods to match

METHOD:: matches
Match the argument with the template.


ARGUMENT:: ele
An instance of HIDElement

returns:: a Boolean indicating whether the incoming HID matches the template


METHOD:: shouldMatch
The variables that should be matched when filtering

returns:: a Set with variable names.


SUBSECTION:: Methods to add matching parameters

METHOD:: addTypeMatch
Add a match for usage name and usage page name of the element.

ARGUMENT:: uName
The usage name to match

ARGUMENT:: pName
The page name to match

METHOD:: addTypeIDMatch
Add a match for usage id and usage page id of the element.

ARGUMENT:: uID
The usage id to match

ARGUMENT:: pID
The usage page id to match


METHOD:: addDictionaryMatch
Add an IdentityDictionary with a set of parameters to match. The keys in the dictionary should be one of the instance variables of HIDElementProto.

ARGUMENT:: dict
An IdentityDictionary with a set of parameters to match.



EXAMPLES::

code::
// create an prototype element with usageName \X
c = HIDElementProto.new.usageName_( \X );
a = HIDFunc.proto( { |...args| args.postln; }, c );
a.free;
::


TITLE:: HIDFunc
summary:: Fast responder for incoming data from human input devices (HID)
categories:: External Control>HID
related:: Classes/HID, Classes/HIDdef, Classes/HIDProto, Classes/HIDElementProto, Classes/OSCFunc, Classes/MIDIFunc, Guides/Working_with_HID

DESCRIPTION::
Human input devices can be used as controllers for making music. This class provides you with access to them in a way similar to OSCFunc and MIDIFunc.

HIDFunc (and its subclass link::Classes/HIDdef::) registers one or more functions to respond to an incoming HID message. Many of its methods are inherited from its superclass link::Classes/AbstractResponderFunc::.

note:: HIDFuncs are removed on Cmd-. by default. This can be overridden using either of the fix or permanent methods.::


The development of this SuperCollider implementation of HID access was funded by the SuperCollider community and BEK, Bergen Elektronisk Kunst, Bergen, Norway, http://www.bek.no


CLASSMETHODS::

PRIVATE:: initClass, cmdPeriod

METHOD:: defaultDispatchers
Get or set an link::Classes/IdentityDictionary:: containing the default dispatcher objects for HIDFuncs of different types (these are what you get if you pass nil as the dispatcher argument to link::#*new::). These objects will decide if any of their registered HIDFuncs should respond to an incoming HID message. The dictionary should have the keys code::[\usage, \usageID, \device, \proto, \element]:: and values of an appropriate subclass of link::Classes/AbstractDispatcher:: for each message type. By default these will be instances of code::HIDUsageDispatcher::, code::HIDElementProtoDispatcher::, code::HIDDeviceDispatcher::, code::HIDElementProtoDispatcher:: and code::HIDElementDispatcher:: respectively.

returns:: The getter returns an link::Classes/IdentityDictionary::.


METHOD:: usage
A convenience method to filter an incoming HID value based on the name of its control usage. E.g. the name of an X-axis of a joystick or the horizontal movement of a mouse has the name code::\X::. These usage names are standardized by manufacturers and are looked up in usage tables based on the information coming from the device. If you have an open HID device, you can look up the available usages with: code::~hid.postUsages::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elUsageName
The name of the usage to look for. This can be one usage name, or an array of usage names. If nil, it will match any usage.

ARGUMENT:: devUsageName
The name of the device usage to look for, e.g. code::\GamePad:: or code::\Mouse::. If left blank, the code::HIDFunc:: will match any device.

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: or link::Classes/HIDProto:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDFunc:: is code::HIDUsageDispatcher::

returns:: A new instance of HIDFunc which responds to a specific element usage and device type.


METHOD:: device
A convenience method to filter an incoming HID value based on the name of the device. This type of HIDFunc differs from code::HIDFunc.usage:: in that it filter specifically by device name, rather than device usage, otherwise the arguments are the same.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elUsageName
The name of the usage to look for. This can be one usage name, or an array of usage names.

ARGUMENT:: deviceName
The name of the device to look for, note that this has to match the string as returned by the device exactly. You can look this string up in the device list: code::HID.postAvailable::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: or link::Classes/HIDProto:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDFunc:: is code::HIDDeviceDispatcher::

returns:: A new instance of HIDFunc which responds to a specific element usage for a specific device.


METHOD:: usageID
A convenience method to filter an incoming HID value based on the number of its control usage. If the device is using a non-standard usage number, then this method can be used to look for it. A controls usage is fully specified by the combination of its usage ID and its usage page.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...usage

ARGUMENT:: elUsageID
The id (an link::Classes/Integer::) of the usage to look for. This can be one usage id, or an array of usage ids. If nil, it will match any usage id.

ARGUMENT:: elPageID
The id (an link::Classes/Integer::) of the page of the usage to look for. This can be one page id, or an array of page ids.

ARGUMENT:: deviceName
Since this type of HIDFunc is meant for non-standardized controls, you can filter by a specific device name, rather than a general usage, similar to code::HIDFunc.device::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: or link::Classes/HIDProto:: with a more detailed filtering for a device.


ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDFunc:: is code::HIDElementProtoDispatcher::

returns:: A new instance of HIDFunc which responds to a specific element usage id for a specific device.

METHOD:: proto
A convenience method to filter an incoming HID value based on a matching template of an element (a link::Classes/HIDElementProto::). If you have number of conditions for the element that should be matched, then this method can be used to look for it.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...usage

ARGUMENT:: protoElement
The id (an link::Classes/Integer::) of the usage to look for. This can be one usage id, or an array of usage ids.

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: or link::Classes/HIDProto:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.


ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDFunc:: is code::HIDElementProtoDispatcher::

returns:: A new instance of HIDFunc which responds to a specific prototype element.


METHOD:: element
A convenience method to filter an incoming HID value based on the index of its element. If the device is using something non-standard, or you want to access keyboard elements directly, then this method can be used to look for it. Note that the element index is not necessarily the same across different operating systems (i.e. it may vary between Linux and macOS and Windows).

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elID
The id (an link::Classes/Integer::) of the element to look for. This can be one element id, or an array of element ids.

ARGUMENT:: deviceName
Since this type of HIDFunc is meant for non-standardized elements, you can filter by a specific device name, rather than a general usage, similar to code::HIDFunc.device::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: or link::Classes/HIDProto:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.


ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDFunc:: is code::HIDElementDispatcher::

returns:: A new instance of HIDFunc which responds to a specific element id for a specific device.

SUBSECTION:: Debugging

METHOD:: trace
A convenience method which dumps all incoming HID messages.

argument:: bool
A link::Classes/Boolean:: indicating whether dumping is on or off.


INSTANCEMETHODS::

PRIVATE:: initUsageID, initDevice, printOn, initElement, init, initUsage, initProtoElement

METHOD:: type
The type of HIDFunc.

returns:: a link::Classes/Symbol::, one of code::\usage::, code::\device::, code::\usageID::, code::\proto:: or code::\element::.

METHOD:: elUsage
The usage name, usage id, or element id of the element/control to match, depending on the type of HIDFunc

METHOD:: elementTemplate
An instance of HIDElementProto, describing the template for the element to match.

METHOD:: devUsage
The device usage or device name of the element/control to match, depending on the type of HIDFunc

METHOD:: deviceTemplate
An instance of HIDProto, describing the template for the device to match.


METHOD:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

METHOD:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

EXAMPLES::

For all the examples below here, you will need to have initialized an HID device (see also link::Guides/Working_with_HID::). The examples below should work with a standard USB mouse.


code::
HID.findAvailable; // check which devices are attached
HID.postAvailable; // post the available devices
~myhid = HID.open( 1103, 53251 ); // adapt this line for  the device that you want to open!
::

SUBSECTION:: Filtering based on usage

code::
// filter all events coming from the x-axis of a mouse
a = HIDFunc.usage( { |...args| args.postln; }, \X, \Mouse );
// disable the function again:
a.free;

// filter all events coming from a mouse
a = HIDFunc.usage( { |...args| args.postln; }, nil, \Mouse );
// disable the function again:
a.free;

// filter all events coming from an X-axis (could be from a mouse or a joystick or a gamepad)
a = HIDFunc.usage( { |...args| args.postln; }, \X );
// disable the function again:
a.free;

// filter all events coming from an X-axis or an Y-axis (could be from a mouse or a joystick or a gamepad)
a = HIDFunc.usage( { |...args| args.postln; }, [\X,\Y] );
// disable the function again:
a.free;


// usage of argTemplate: matching the rawValue (is the default behaviour)

// only react when the values are below zero:
a = HIDFunc.usage( { |...args| args.postln; }, [\X,\Y], argTemplate: { |val| val < 0 } );
a.free;

// only match when rawvalue == -1
a = HIDFunc.usage( { |...args| args.postln; }, [\X,\Y], argTemplate: -1 );
a.free;

// only match when rawvalue is one of [-3,-2,-1]
a = HIDFunc.usage( { |...args| args.postln; }, [\X,\Y], argTemplate: [-3,-2,-1] );
a.free;

// usage of argTemplate: matching the scaled value when smaller than 0.5
a = HIDFunc.usage( { |...args| args.postln; }, [\X,\Y], argTemplate: { |val| val < 0.5 }, argTemplateType: \value );
a.free;


// using deviceInfo rather than deviceUsage (you can add more device specifications to match)
a = HIDFunc.usage( { |...args| args.postln; }, \X, deviceInfo: ( usageName: \Mouse ) );
a.free;

a = HIDFunc.usage( { |...args| args.postln; }, nil, deviceInfo: ( usageName: \Mouse ) );
a.free;
::

SUBSECTION:: Filtering based on usage ID

code::
// filter by usage ID 48 on usage page 1
a = HIDFunc.usageID( { |...args| args.postln; }, 48, 1 );
a.free;

// filter by usage ID 48 or 49 on usage page 1
a = HIDFunc.usageID( { |...args| args.postln; }, [48,49], 1 );
a.free;

// filter by any usage ID on usage page 1
a = HIDFunc.usageID( { |...args| args.postln; }, nil, 1 );
a.free;

// filter by usage ID 48 on usage page 1, of a device with an empty string as a name (fill in the name of your mouse there).
a = HIDFunc.usageID( { |...args| args.postln; }, 48, 1, "" );
a.free;

// filter by usage ID 48 on usage page 1, of a device with path "/dev/hidraw2" (adapt this path to the device you want to match)
a = HIDFunc.usageID( { |...args| args.postln; }, 48, 1, deviceInfo: ( path: "/dev/hidraw2" )  );
a.free;
::

SUBSECTION:: Filtering based on a device

code::
// filter for device with name "", and element with usage \X.
a = HIDFunc.device( { |...args| args.postln; }, \X, "" );
a.free;
::

SUBSECTION:: Filtering based on a prototype element

code::
// create an prototype element with usageName \X
c = HIDElementProto.new.usageName_( \X );
a = HIDFunc.proto( { |...args| args.postln; }, c );
a.free;
::


SUBSECTION:: Filtering based on an element ID

code::
// filter for elements with element id 6:
a = HIDFunc.element( { |...args| args.postln; }, 6 );
a.free;
::


TITLE:: HIDInfo
summary:: This class contains the basic information about an HID device to access and open it.
categories:: External Control>HID
related:: Classes/HID, Guides/Working_with_HID

DESCRIPTION::
This class contains the basic information about an HID device to access and open it.
The class is mostly used internally and rarely accessed directly by the user.

This class is populated with information read from the device, and represents some of the internal information of the device.

CLASSMETHODS::

PRIVATE:: new

INSTANCEMETHODS::

PRIVATE::printOn, setUsageAndPage

METHOD:: open
Open the device that is described by this HIDInfo

returns:: an HID - the device

METHOD:: postInfo
post the HIDInfo in a human readable way


METHOD:: path
The path of the device, this is a path defined by the operating system, and thus not the same across platforms, but essential to distinguish devices with the same vendor and product ID from each other.

METHOD:: vendorID
The vendor ID of the device, this is a number encoded by the device itself, and the same across platforms.

METHOD:: productID
The product ID of the device, this is a number encoded by the device itself, and the same across platforms.

METHOD:: vendorName
The vendor name of the device, this is a string encoded by the device itself, and the same across platforms.

METHOD:: productName
The product name of the device, this is a string encoded by the device itself, and the same across platforms.

METHOD:: serialNumber
The serial number of the device. This is dependent on the operating system, e.g. on Linux it is not set.

METHOD:: releaseNumber
The release number of the device, this is a number encoded by the device itself, and the same across platforms.

METHOD:: interfaceNumber
Type of interface of the device, can be an index standing for USB, Bluetooth, etc.


METHOD:: usage
Retrieve the usage index of this collection.

returns:: a Number - the usage index of this collection

METHOD:: usagePage
Retrieve the usage page index of this collection.

returns:: a Number- the usage page index

METHOD:: usageName
Retrieve the usage name of this collection. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage name


METHOD:: pageName
Retrieve the page name of this collection. The name is looked up from the standardized HID usage tables using the usage page index.

returns:: a String - the usage page name


TITLE:: HIDProto
summary:: Prototype HID device to match with HIDFunc
categories:: External Control>HID
related::  Classes/HIDFunc, Classes/HIDdef, Classes/HIDElementProto, Classes/HID, Classes/HIDInfo, Guides/Working_with_HID

DESCRIPTION::
Human input devices can be used as controllers for making music. This class can be used in conjunction with link::Classes/HIDFunc:: or link::Classes/HIDdef:: to match incoming messages with a particular link::Classes/HID:: device.

HIDProto has all the variables that specify an HID device. The more of these variables you specify, the more need to be matched when filtering the incoming HID data.

CLASSMETHODS::

METHOD:: new
Create a new instance of HIDProto.


METHOD:: newType
Create a new instance of HIDProto based on usage and usagePage of the device.

ARGUMENT:: uName
Name of the usage id

ARGUMENT:: pName
Name of the usage page id

returns::  an HIDProto

METHOD:: newProduct
Create a new instance of HIDProto based on the product information.

ARGUMENT:: pName
The product name to match.

ARGUMENT:: vName
The vendor name to match.

returns:: an HIDProto


METHOD:: newFromDict
Create a new instance of HIDProto based on an IdentityDictionary with a set of parameters to match.

ARGUMENT:: dict
An IdentityDictionary with a set of parameters to match. The keys in the dictionary should be one of the instance variables of HIDProto.

returns:: an HIDProto


INSTANCEMETHODS::

PRIVATE:: init

SUBSECTION:: Instance variables that can be used to match a device

METHOD:: id
The device id that should be matched. This is dependent on the order of opening HID devices.

METHOD:: productName
The product name to match (see also link::Classes/HIDInfo::).

METHOD:: vendorName
The vendor name to match (see also link::Classes/HIDInfo::).

METHOD:: productID
The product id to match (see also link::Classes/HIDInfo::).

METHOD:: vendorID
The vendor id to match (see also link::Classes/HIDInfo::).

METHOD:: interfaceNumber
The interface number to match (see also link::Classes/HIDInfo::).

METHOD:: releaseNumber
The release number to match (see also link::Classes/HIDInfo::).


METHOD:: serialNumber
The serial number to match (see also link::Classes/HIDInfo::).

METHOD:: path
The path to match (see also link::Classes/HIDInfo::).



METHOD:: usage
The usage ID of the device to match (see also link::Classes/HIDInfo::).

METHOD:: usagePage
The usage page ID of the device to match (see also link::Classes/HIDInfo::).

METHOD:: usageName
The usage name of the device to match (see also link::Classes/HIDInfo::).

METHOD:: pageName
The page name of the device to match (see also link::Classes/HIDInfo::).


SUBSECTION:: Methods to match

METHOD:: matches
Match the argument with the template.

ARGUMENT:: hid
An instance of HID.

returns:: a Boolean indicating whether the incoming HID matches the template

METHOD:: shouldMatch
The variables that should be matched when filtering

returns:: a Set with variable names.

SUBSECTION:: Methods to add matching parameters


METHOD:: addTypeMatch
Add a match for usage name and usage page name of the device.

ARGUMENT:: uName
The usage name to match

ARGUMENT:: pName
The page name to match

METHOD:: addProductMatch
Add a match for product name and vendor name of the device.

ARGUMENT:: pName
The product name to match

ARGUMENT:: vName
The vendor name to match


METHOD:: addDictionaryMatch
Add an IdentityDictionary with a set of parameters to match. The keys in the dictionary should be one of the instance variables of HIDProto.


ARGUMENT:: dict
An IdentityDictionary with a set of parameters to match.


EXAMPLES::

code::
b = HIDProto.newFromDict( ( path: "/dev/hidraw2" ) );

a = HIDFunc.usage( { |...args| args.postln; }, \X, deviceInfo: b );
a.free

b = HIDProto.newType( \Mouse, \GenericDesktop );

a = HIDFunc.usage( { |...args| args.postln; }, \X, deviceInfo: b );
a.free;

b = HIDProto.newProduct( "USB Mouse", "Logitech" );

a = HIDFunc.usage( { |...args| args.postln; }, \X, deviceInfo: b );
a.free;
::


TITLE:: HIDUsage
summary:: Helper class to read usage information from HID usage tables
categories:: External Control>HID
related:: Classes/HID, Classes/HIDElement, Classes/HIDCollection, Guides/Working_with_HID

DESCRIPTION::
HID functionality is described by the USB HID standard usage tables. Each element and collection has a usage page and index, describing the type of control that it provides. This class allows to query the name of a usage and page based on the indices read from the device. This class is primarily used internally by other HID classes.


CLASSMETHODS::

PRIVATE:: initClass


METHOD:: getUsageDescription
Retrieve the standard usage name and pagename of an HID usage element or collection.

ARGUMENT:: usagePage
usage page number

ARGUMENT:: usage
usage index

returns:: an Array with the pageName and usageName



METHOD:: hutDirectory
Directory where the yaml files with the HID usage tables are stored.


METHOD:: readHUTFile
Reads and parses the HID usage table file. Called from getUsageDescription to read in the usage table.

ARGUMENT:: yamlfile
the filename of the yamlfile with a particular usage table, relative to the hutDirectory.

returns:: an IdentityDictionary representing the table

METHOD:: getUsageIds
Retrieve usage id and page id from the usageName.

ARGUMENT:: usageName
the usage name

returns:: an Array with the page id and the usage id


METHOD:: idsToName
Retrieve the standard usage name and pagename of an HID usage element or collection.

ARGUMENT:: page
the usage page id

ARGUMENT:: usage
the usage id

returns:: the usage name

METHOD:: usageIDsToName
MultiLevelIdentityDictionary containing a map of page ids, usage ids to usage names.

METHOD:: usageNameToIDs
IdentityDictionary containing a map of usageNames to page ids and usage ids.



EXAMPLES::

Get the usage description for a collection or element with usage page 1 and usage index 5

code::
HIDUsage.getUsageDescription( 1, 5 );
::


TITLE:: HIDdef
summary:: HID response reference definition
categories:: External Control>HID
related:: Classes/HID, Classes/HIDFunc, Classes/OSCdef, Classes/MIDIdef, Guides/Working_with_HID

DESCRIPTION::
HIDdef provides a global reference to the functionality of its superclass HIDFunc. Essentially it stores itself at a key within a global dictionary, allowing replacement at any time. Most methods are inherited from its superclass.

CLASSMETHODS::

PRIVATE:: initClass

METHOD:: all
Get the global dictionary of all HIDdefs.

returns:: An LINK::Classes/IdentityDictionary::


METHOD:: freeAll
Clears and deactivates all HIDdefs from the global collection.


METHOD:: new
Access an existing HIDdef. This is a shortcut to access an HIDdef created with one of the methods below, and allows to change its function, or call free on it.

ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...


METHOD:: usage
Create a new, enabled HIDdef. If an HIDdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

A convenience method to filter an incoming HID value based on the name of its control usage. E.g. the name of an X-axis of a joystick or the horizontal movement of a mouse has the name code::\X::. These usage names are standardized by manufacturers and are looked up in usage tables based on the information coming from the device. If you have an open HID device, you can look up the available usages with: code::~hid.postUsages::.


ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elUsageName
The name of the usage to look for. This can be one usage name, or an array of usage names.

ARGUMENT:: devUsageName
The name of the device usage to look for, e.g. code::\GamePad:: or code::\Mouse::. If left blank, the code::HIDdef:: will match any device.

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDdef:: is code::HIDUsageDispatcher::

returns:: A new instance of HIDdef which responds to a specific element usage and device type.


METHOD:: device
Create a new, enabled HIDdef. If an HIDdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

A convenience method to filter an incoming HID value based on the name of the device. This type of HIDdef differs from code::HIDdef.usage:: in that it filter specifically by device name, rather than device usage, otherwise the arguments are the same.

ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elUsageName
The name of the usage to look for. This can be one usage name, or an array of usage names.

ARGUMENT:: deviceName
The name of the device to look for, note that this has to match the string as returned by the device exactly. You can look this string up in the device list: code::HID.postAvailable::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDdef:: is code::HIDDeviceDispatcher::

returns:: A new instance of HIDdef which responds to a specific element usage for a specific device.


METHOD:: usageID
Create a new, enabled HIDdef. If an HIDdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

A convenience method to filter an incoming HID value based on the number of its control usage. If the device is using a non-standard usage number, then this method can be used to look for it. A controls usage is fully specified by the combination of its usage ID and its usage page.

ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...usage

ARGUMENT:: elUsageID
The id (an link::Classes/Integer::) of the usage to look for. This can be one usage id, or an array of usage ids.

ARGUMENT:: elPageID
The id (an link::Classes/Integer::) of the page of the usage to look for. This can be one page id, or an array of page ids.

ARGUMENT:: deviceName
Since this type of HIDdef is meant for non-standardized controls, you can filter by a specific device name, rather than a general usage, similar to code::HIDdef.device::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: with a more detailed filtering for a device.


ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.

ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDdef:: is code::HIDElementProtoDispatcher::

returns:: A new instance of HIDdef which responds to a specific element usage id for a specific device.




METHOD:: proto
Create a new, enabled HIDdef. If an HIDdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

A convenience method to filter an incoming HID value based on a matching template of an element (a link::Classes/HIDElementProto::). If you have number of conditions for the element that should be matched, then this method can be used to look for it.

ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...usage

ARGUMENT:: protoElement
The id (an link::Classes/Integer::) of the usage to look for. This can be one usage id, or an array of usage ids.

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.


ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDdef:: is code::HIDElementProtoDispatcher::

returns:: A new instance of HIDdef which responds to a specific prototype element.




METHOD:: element
Create a new, enabled HIDdef. If an HIDdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

A convenience method to filter an incoming HID value based on the index of its element. If the device is using something non-standard, or you want to access keyboard elements directly, then this method can be used to look for it. Note that the element index is not necessarily the same across different operating systems (i.e. it may vary between Linux and macOS and Windows).

ARGUMENT:: key
The key at which to store this HIDdef in the global collection. Generally this will be a link::Classes/Symbol::.

ARGUMENT:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. It will be passed...

ARGUMENT:: elID
The id (an link::Classes/Integer::) of the element to look for. This can be one element id, or an array of element ids.

ARGUMENT:: deviceName
Since this type of HIDdef is meant for non-standardized elements, you can filter by a specific device name, rather than a general usage, similar to code::HIDdef.device::

ARGUMENT:: deviceInfo
An link::Classes/IdentityDictionary:: with a more detailed filtering for a device.

ARGUMENT:: argTemplate
This should be an object that implements the method code::matchItem::. Depending on the code::argTemplateType::, it will be passed either the rawValue of the value of the element to be matched.

ARGUMENT:: argTemplateType
If the argTemplateType is code::\rawValue:: (the default) then the matching is done based on the incoming raw value of the element (not mapped according to the logical min and max). Otherwise the matching is done according to the mapped value.


ARGUMENT:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed. The default for this type of code::HIDdef:: is code::HIDElementDispatcher::

returns:: A new instance of HIDdef which responds to a specific element id for a specific device.


INSTANCEMETHODS::

PRIVATE::addToAll, printOn

METHOD:: key
Get this HIDdef's key.

returns:: Usually a link::Classes/Symbol::.


METHOD:: free
Clears this HIDdef from the global collection and deactivates it.


EXAMPLES::

For all the examples below here, you will need to have initialized an HID device (see also link::Guides/Working_with_HID::). The examples below should work with a standard USB mouse.


code::
HID.findAvailable; // check which devices are attached
HID.postAvailable; // post the available devices
~myhid = HID.open( 1103, 53251 ); // adapt this line for  the device that you want to open!
::

SUBSECTION:: Filtering based on usage

code::
// filter all events coming from the x-axis of a mouse
HIDdef.usage( \example, { |...args| args.postln; }, \X, \Mouse );

// filter all events coming from a mouse
HIDdef.usage( \example, { |...args| args.postln; }, nil, \Mouse );

// filter all events coming from an X-axis (could be from a mouse or a joystick or a gamepad)
HIDdef.usage( \example, { |...args| args.postln; }, \X );

// filter all events coming from an X-axis or an Y-axis (could be from a mouse or a joystick or a gamepad)
HIDdef.usage( \example, { |...args| args.postln; }, [\X,\Y] );

// usage of argTemplate: matching the rawValue (is the default behaviour)

// only react when the values are below zero:
HIDdef.usage( \example, { |...args| args.postln; }, [\X,\Y], argTemplate: { |val| val < 0 } );

// only match when rawvalue == -1
HIDdef.usage( \example, { |...args| args.postln; }, [\X,\Y], argTemplate: -1 );

// only match when rawvalue is one of [-3,-2,-1]
HIDdef.usage( \example, { |...args| args.postln; }, [\X,\Y], argTemplate: [-3,-2,-1] );

// usage of argTemplate: matching the scaled value when smaller than 0.5
HIDdef.usage( \example, { |...args| args.postln; }, [\X,\Y], argTemplate: { |val| val < 0.5 }, argTemplateType: \value );

// using deviceInfo rather than deviceUsage (you can add more device specifications to match)
HIDdef.usage( \example, { |...args| args.postln; }, \X, deviceInfo: ( usageName: \Mouse ) );

HIDdef.usage( \example, { |...args| args.postln; }, nil, deviceInfo: ( usageName: \Mouse ) );

HIDdef( \example ).free;
::

SUBSECTION:: Filtering based on usage ID

code::
// filter by usage ID 48 on usage page 1
HIDdef.usageID( \example2, { |...args| args.postln; }, 48, 1 );

// filter by usage ID 48 or 49 on usage page 1
HIDdef.usageID( \example2, { |...args| args.postln; }, [48,49], 1 );

// filter by any usage ID on usage page 1
HIDdef.usageID( \example2, { |...args| args.postln; }, nil, 1 );

// filter by usage ID 48 on usage page 1, of a device with an empty string as a name (fill in the name of your mouse there).
HIDdef.usageID( \example2, { |...args| args.postln; }, 48, 1, "" );

// filter by usage ID 48 on usage page 1, of a device with path "/dev/hidraw2" (adapt this path to the device you want to match)
HIDdef.usageID( \example2, { |...args| args.postln; }, 48, 1, deviceInfo: ( path: "/dev/hidraw2" )  );

HIDdef( \example2 ).free;
::

SUBSECTION:: Filtering based on a device

code::
// filter for device with name "", and element with usage \X.
HIDdef.device( \example3, { |...args| args.postln; }, \X, "" );
HIDdef( \example3 ).free;
::

SUBSECTION:: Filtering based on a prototype element

code::
// create an prototype element with usageName \X
c = HIDElementProto.new.usageName_( \X );
HIDdef.proto( \example4, { |...args| args.postln; }, c );
HIDdef( \example4 ).free;
::


SUBSECTION:: Filtering based on an element ID

code::
// filter for elements with element id 6:
HIDdef.element( \example5, { |...args| args.postln; }, 6 );
HIDdef( \example5 ).free;
::


CLASS:: HLayout
summary:: A layout that distributes views in a horizontal line
categories:: GUI>Layout
related:: Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

DESCRIPTION::
See documentation of superclass link::Classes/LineLayout:: for details.


EXAMPLES::
code::
(
w = Window().front;
a = { Button(w) } ! 10;
w.layout = HLayout(*a);
);

(
w = Window().front;
a = { { Button(w) } ! 10 } ! 10;
w.layout = HLayout(*a.collect { |x| VLayout(*x) });
)

(
w = Window().front;
a = { { PopUpMenu(w, Rect(0, 0, 50, 20)).items_({"abcdefghijklmno".scramble.keep(3)} ! 7) } ! 10 } ! 10;
w.layout = HLayout(*a.collect { |x| VLayout(*x) });
)

(
w = Window().front;
a = { HLayout(Slider(w, Rect(0, 0, 130, 20)), Button(w)) } ! 12;
b = { Slider2D(w) } ! 3;
w.layout = HLayout(VLayout(*a), VLayout(*b));
)

(
w = Window().front;
f = { SoundFileView(w).load(Platform.resourceDir +/+ "sounds/a11wlk01.wav", 1e5.rand, 1e4) };
a = { HLayout(VLayout(*{ Slider(w, Rect(0, 0, 230, 20)).minSize_(Size(130, 20)) } ! 3), f.value) } ! 4;
w.layout = HLayout(VLayout(*a));
)

::


CLASSMETHODS::

PRIVATE:: key
PRIVATE:: layoutClass

INSTANCEMETHODS::


class:: HLayoutView
summary:: A container view that arranges its children horizontally
categories:: GUI>Views
related:: Classes/VLayoutView, Classes/CompositeView

DESCRIPTION::

note::
In Qt GUI, this class has been rendered strong::obsolete:: by a special set of layout classes; they are easier to use and more flexible. See link::Classes/HLayout:: for an equivalent to this class, and link::Guides/GUI-Layout-Management:: for a general description of the Qt layout system.
::

HLayoutView can be a parent to other views, and it automatically arranges its child views in horizontal order, expanding their height to its own bounds. Only the width of the children is relevant.

When arranging its children, HLayoutView takes the values of their 'minWidth' and 'maxWidth' properties into account. This is useful when a child's link::Classes/View#-resize#resize:: mode is set to 2, 5, or 8. See link::#examples:: below.

HLayoutView inherits some useful formatting methods from its superclasses.

note::
HLayoutView is designed mainly for grouping and placing widgets. While you can set it to accept key presses, it does not accept mouse clicks or drags.
::

CLASSMETHODS::
PRIVATE:: key

EXAMPLES::

Child view height fills the HLayoutView automatically:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));

Array.fill(q,{ arg i;
    Slider(h,Rect(0,0,20,75)).value_(i / q)
});
h.background_(Color.rand);

w.front
)
::

Stretching the layout view; Slider height fills the View automatically:

code::
(
q = 8;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.background = Color.rand;
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75)).background_(Color.grey.alpha_(0.4));
    s.value = i / q;
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");
w.front
)
::

Stretching the layout view and the contents; if all the contents are elastic, the widths of the contents are perfectly divided up. In this example, the StaticText is not elastic in order to preserve its width:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic
h.background = Color.rand;

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.resize = 5; // elastic
    s.value = i / q;
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");

w.front
)
::

Setting minWidth on contents; beware that if the layout view width is smaller than the combined width of all the contents, things might disappear when you try to handle them with the mouse:

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.background = Color.rand;
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.value = i / 5;
    if(i < 2,{
        s.resize = 5; // some elastic
        s.setProperty(\minWidth,20);
    },{
        s.resize = 1; // some not elastic
    });
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");

w.front
)
::

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic
h.background = Color.rand;
Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.value = i / 5;
    s.resize = 5;
    s.setProperty(\minWidth,20);
    s.setProperty(\maxWidth,40);
    s
});

w.front
)
::

Text flows:

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s =     StaticText(h,120@20).string_("Some short text which wraps around");

    s.resize = 5;
    s.setProperty(\minWidth,10);
    s.setProperty(\maxWidth,120);

    // not working
    s.setProperty(\maxHeight,10);
    s.setProperty(\minHeight,10);

    s.background = Color.white;
    s
});

w.front
)
::

Spacing:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.setProperty(\spacing,0);

Array.fill(q,{
    Slider(h,Rect(0,0,20,75))
});

w.front
)
::


class:: HPF
summary:: 2nd order Butterworth highpass filter.
related:: Classes/BPF, Classes/BRF, Classes/LPF
categories::  UGens>Filters>Linear


Description::
A second order high pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
{ HPF.ar(Saw.ar(200, 0.1), FSinOsc.kr(XLine.kr(0.7, 300, 20), 0, 3600, 4000), 5) }.play;

(
{ 	var ctl = HPF.kr(LFSaw.kr(5), SinOsc.kr(XLine.kr(0.07, 30, 20), 0, 35, 40)) ;
	SinOsc.ar(ctl * 200 + 500);
}.play;
)

(
{ 	var ctl = HPF.kr(LFSaw.kr(5, 0.1), MouseX.kr(2, 200, 1));
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)
::



class:: HPZ1
summary:: Two point difference filter
related:: Classes/LPZ1, Classes/HPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.5 * (in(i) - in(i-1))
::

Which is a two point differentiator.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
// Compare:

{ WhiteNoise.ar(0.25) }.play;

{ HPZ1.ar(WhiteNoise.ar(0.25)) }.play;

// HPZ1 is useful to detect changes in a signal:
// see also HPZ2
(
{
	var changingSignal = LFNoise0.ar(1000);
	var hpz1 = HPZ1.ar(changingSignal);
	[hpz1, hpz1 > 0, hpz1.abs > 0]
}.plot
);
::



class:: HPZ2
summary:: Two zero fixed midcut.
related:: Classes/BPZ2, Classes/BRZ2, Classes/LPZ2, Classes/HPZ1
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.25 * (in(i) - (2 * in(i - 1)) + in(i - 2)).
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
// Compare:

{ WhiteNoise.ar(0.25) }.play;

{ HPZ2.ar(WhiteNoise.ar(0.25)) }.play;

// HPZ2 is useful to detect changes in a signal:
// see also HPZ1
(
{
	var changingSignal = LFNoise0.ar(1000);
	var hpz2 = HPZ2.ar(changingSignal);
	[hpz2, hpz2 > 0]
}.plot
);
::



CLASS::Harmonics
summary:: Convenient factory for filling buffers with harmonics on the server
categories:: Collections, Server, UGens>Buffer

DESCRIPTION::
Harmonics objects are convenient factories for creating Arrays that are used to fill buffers using the b_gen sine fill commands on the server.

CLASSMETHODS::

method::new
Create a new Harmonics array of size. Nothing is filled in for you, until instance methods are applied.
code::
a = Harmonics.new(16);	// just returns an instance of Harmonics with size
::

INSTANCEMETHODS::

method::ramp
code::
a.ramp(1.0, 1.0);	// returns a harmonic series

b = Buffer.alloc(s, 512, 1);
// harmonic series for freqs, ramp down for amps
b.sine2(a.ramp(1.0, 1.0).postln, a.ramp(0.5, -0.025).postln, true, true, true);
(
z = SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, 200, 0, 0.5)
	)
});
)
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::decay
Implements the formula: 1 / ((i+1) ** k)
code::
a.decay(1.0);

b.sine2(a.ramp(1.0, 1.0).postln, a.decay(1.0).postln, true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::geom
Implements the formula: 1 / (i ** k)
code::
a.geom(1.2);

b.sine2(a.ramp(1.0, 1.0).postln, a.geom(1.2).postln, true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::formant
Create a formant like structure.
code::
a.formant(6, 3);

b.sine2(a.formant(12, 3).postln, a.geom(1.2), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::teeth
code::
a.teeth(6, 3);

b.sine2(a.teeth(2, 3).postln, a.geom(1.2), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.teeth(4, 1).postln, a.geom(1.2), true, true, true);
b.sine2(a.teeth(1, 3).postln, a.geom(1.2), true, true, true);
b.sine2(a.teeth(2, 3).postln, a.geom(1.2), true, true, true);
y.free;
::

method::cutoff
Returns 1.0 to the nth place, fills the rest with 0.0
code::
a.cutoff(3);

b.sine2(a.ramp(1.0, 1.0), a.cutoff(3), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(3), true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(5), true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(1), true, true, true);
y.free;
::

method::shelf
code::
a.shelf(0, 6, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.shelf(0, 6, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.shelf(0, 11, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.shelf(2, 6, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.shelf(6, 8, 1, 0).postln , true, true, true);
y.free;
::

method::sine
code::
a.sine(8, 0, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.sine(8, 0, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.sine(4, 0, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.sine(2.2, 0.5pi, 0.4, 0.2).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.sine(pi, 0.25pi, 0.5, 0).postln , true, true, true);
y.free;
::

method::pulse
code::
a.pulse(8, 0, 2, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.pulse(8, 0, 2, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.pulse(8, 0, 2, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.pulse(4, 0, 2, 0.4, 0.2).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.pulse(7, 0.5pi, 3, 0.5, 0.1).postln , true, true, true);
y.free;
::

method:: rand, exprand, linrand
method:: rand2
method:: coin



class:: Hasher
summary:: Scrambled value with a hash function.
categories::  UGens>Filters>Nonlinear, UGens>Random

Description::

Returns a unique output value from -1 to +1 for each input value
according to a hash function. The same input value will always produce
the same output value. The input need not be in the range -1 to +1.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ Hasher.ar(Line.ar(0,1,1), 0.2) }.play;

// Even adding a small amount to the input can result in a very different output. Compare these two examples:
(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10).round(1), 300, 500)
	) * 0.1
}.play;
)

(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10).round(1) + 0.0001, 300, 500)
	) * 0.1
}.play;
)

// Output stays constant while not moving the mouse.
(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10), 300, 500)
	) * 0.1
}.play;
)
::


class:: HelpBrowser
categories:: HelpSystem, GUI>Interfaces
related:: Classes/SCDoc
summary:: Browse the SuperCollider help documentation

description::

HelpBrowser is a GUI help browser that lets you browse the documentation of SuperCollider. It is coupled with SCDoc to allow on-the-fly rendering of HTML help files.

There are two different help browsers in SuperCollider: the help browser built into SCIDE, and this HelpBrowser class implemented with sclang's GUI features. Both are implemented with the same underlying Qt WebEngine browser.

Since the Qt WebEngine dependency is hefty and difficult to install on some systems, it is possible for sclang to have been built without WebView support (using the CMake flag code:: -DSC_USE_QTWEBENGINE=OFF :: at compile). If so, attempting to invoke this class will throw an error.

classmethods::
private:: getOldWrapUrl, initClass

method:: instance
The singleton HelpBrowser instance.

method:: new
Create a new HelpBrowser instance with given home URL.

method:: defaultHomeUrl
Get or set the default home URL.

method:: openNewWindows
Get or set the default for "open in new windows" toggle.

method:: goTo
Go to url with singleton instance or a new window, depending on the code::openNewWindows:: setting.

method:: openHelpFor
Open the relevant help page for given text in the singleton HelpBrowser instance.

method:: openSearchPage
Open the help search page with given text in the singleton HelpBrowser instance.

method:: openBrowsePage
Open the category browser page in the singleton HelpBrowser instance.

argument:: category
An optional String to start at specified category, like "UGens>Filters"

method:: openHelpForMethod
Open help for specified method.
argument:: method
a link::Classes/Method::

instancemethods::
private:: init, openTextFile, startAnim, stopAnim

method:: homeUrl
Get or set the home URL.

method:: window
The GUI window for this HelpBrowser.
discussion::
Mainly useful for when you need to show the browser:
code::
HelpBrowser.instance.window.front;
::

method:: goTo
Go to specific URL. If the URL points to a file under link::Classes/SCDoc#*helpTargetDir:: it will be rendered on demand if needed.

method:: goHome
Go to the home URL.

method:: goBack
Go back.

method:: goForward
Go forward.



class:: HenonC
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonN, Classes/HenonL

description::
A cubic-interpolating sound generator based on the difference equation:

teletype::
	x(n+2) = 1 - a * x(n+1)^2 + b * x(n)
::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

for more information on chaos theory henon formulas:

"https://en.wikipedia.org/wiki/Chaos_theory"

"https://en.wikipedia.org/wiki/Hénon_map"

sclang code translation:

code::
(
var a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;
plot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x

examples::
code::
// default initial params
{ HenonC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 !2}.scope(s);

// mouse-control of params
{ HenonC.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 !2}.scope(s);

// randomly modulate params
({ HenonC.ar(SampleRate.ir/8, LFNoise2.kr(1, 0.2, 1.2), LFNoise2.kr(1, 0.15, 0.15)) ! 2 * 0.02 }).scope(s);

// as a frequency control
{ SinOsc.ar(HenonC.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900) * 0.04 ! 2 }.scope(s);
::


class:: HenonL
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonC, Classes/HenonN

description::
A linear-interpolating sound generator based on the difference equation:

teletype::
        x(n+2) = 1 - a * x(n+1)^2 + b * x(n)
::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

sclang code translation:

code::
(
var a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;
plot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x

examples::
code::
// default initial params
{ HenonL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);

// mouse-control of params
{ HenonL.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 }.play(s);

// randomly modulate params
(
{ HenonL.ar(
	SampleRate.ir/8,
	LFNoise2.kr(1, 0.2, 1.2),
	LFNoise2.kr(1, 0.15, 0.15)
) * 0.2 }.play(s);
)

// as a frequency control
{ SinOsc.ar(HenonL.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900)*0.4 }.play(s);
::


class:: HenonN
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonL, Classes/HenonC

description::
A non-interpolating sound generator based on the difference equation:

teletype::
        x(n+2) = 1 - a * x(n+1)^2 + b * x(n)
::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

sclang code translation:

code::
(
var a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;
plot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x
argument::mul
argument::add

examples::
code::
// default initial params
{ HenonN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);

// mouse-control of params
{ HenonN.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 }.play(s);

// randomly modulate params
(
{ HenonN.ar(
	SampleRate.ir/8,
	LFNoise2.kr(1, 0.2, 1.2),
	LFNoise2.kr(1, 0.15, 0.15)
) * 0.2 }.play(s);
)

// as a frequency control
{ SinOsc.ar(HenonN.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900)*0.4 }.play(s);
::


class:: Hilbert
summary:: Applies the Hilbert transform to an input signal.
related:: Classes/HilbertFIR, Classes/FreqShift
categories::  UGens>Filters>Nonlinear


Description::

Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). Hilbert outputs two channels containing the input signal and the transformed signal. Due to the method used, distortion occurs in the upper octave of the frequency spectrum (See HilbertFIR for an FFT implementation that avoids this, but introduces a significant delay).


classmethods::

method::ar

argument::in

The input signal to transform.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
s.boot;
s.scope;
a = {Hilbert.ar(SinOsc.ar(100)) * -20.dbamp}.play;
a.release;
::


class:: HilbertFIR
summary:: Applies the Hilbert transform to an input signal.
related:: Classes/Hilbert, Classes/FreqShift
categories::  UGens>Filters>Nonlinear


Description::

Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). HilbertFIR outputs two channels containing the input signal and the transformed signal. HilbertFIR uses FFTs and a 90 degree phase shift to transform the signal, and results in a delay equal to the size of the buffer used for the FFT divided by the sample rate. The Hilbert UGen has less delay, but distorts in the upper octave of the frequency spectrum.


classmethods::

method::ar

argument::in

The input signal to transform.


argument::buffer

A Buffer to be used for the inter FFT processing. Best results with a size of 1024 or 2048. 1024 gives an acceptable result (though a little choppy), 2048 is much smoother but creates more delay.


code::
s.boot;
s.scope;
a = { HilbertFIR.ar(SinOsc.ar(100) * -20.dbamp, LocalBuf(2048)) }.play;
a.release;
::


class:: HiliteGradient
summary:: A linear color fade between an outside and an inside color
categories:: GUI>Accessories
related:: Classes/Color, Classes/Gradient

description::
A linear color fade between an outside and an inside color.

note:: The use of HiliteGradient is strong::not supported yet in Qt GUI::. When HiliteGradient is used in place of Color, the average gradient color will be used instead. ::

classmethods::

method:: new
argument:: color1
An instance of Color.
argument:: color2
An instance of Color.
argument:: direction
code::\h:: or code::\v:: for horizontal and vertical respectively. Default value is code::\v::.
argument:: steps
The resolution of the gradient. Default value is 64.
argument:: frac
The center of the gradient. Default value is 0.33, i.e. off center toward the top on a vertical gradient.

examples::
code::
// basic usage
(
w = Window.new.front;
v = CompositeView(w, Rect(50, 50, 200, 50));
v.background = HiliteGradient(Color.gray, Color.white);
)

// change direction and resolution
(
w = Window.new.front;
w.view.background = HiliteGradient(Color.red, Color.white, \h, 12, 0.5);
)

// almost unnoticeable variations can be pleasant
(
w = Window.new.front;
v = CompositeView(w, Rect(50,50,300,300));
c = Color.rand;
d = c.vary(0.15);
v.background = HiliteGradient(c, d, \v);
[c, d].postln
)

(
var w, k, c, d, e, c1, c2, f, g;
w = Window.new.front;
k = Slider2D(w, Rect(50, 50, 300, 300));
f = {
	c = Color.rand;
	d = c.vary(0.5);
	e = d.vary(0.5);
};
g = {
	c1 = d.hueBlend(e, k.y).round(0.01);
	c2 = c.hueBlend(e, k.x).round(0.01);
	k.background = HiliteGradient(c1, c2, \v)
};
f.value; g.value;
k.action = g;
k.mouseUpAction = { [c1, c2].postln };
k.keyDownAction = f; // hit any key for new color
)
::


class:: History
summary:: keeps a history of interpreted lines of code
related:: Classes/Archive
categories:: Streams-Patterns-Events

description::

History stores all code strings as they are being evaluated, in order to reuse code written earlier, to forward code to other players, or to store, reproduce, edit and analyse live-coded performances. It records every evaluated code string into a singleton instance of History - code::History.current::.

First examples:
code::
History.clear.end;     // if needed, clear History first
History.start;         // starts recording, opens log file

// execute these lines one by one, as a little performance history
1 + 2;
p = ProxySpace.push(s.boot);
~a = {Dust.ar([1,1] * 30 ) * 0.3 };
~a.play;
~a.end(3);

History.started; // is it on now?

// stops recording history and ends logging.
History.end;
History.started;

History.document;      // creates a document with current history
History.showLogFolder; // opens the folder where logs are written.
History.showLogFile;   // opens the current log file as it was written.


// make a gui window, to access code history lines at will,
// e.g. for code reuse in performance, adaptation, sharing, etc:
g = History.makeWin;
// specify left-bottom position, and number of lines in textview
g = History.makeWin(0@20, 5);

// play back the recorded history line by line
History.play(0);


// history can even record and play back stops with CmdPeriod.
// run these lines one at a time:
History.clear.start;
1 + 2;
2 + 3;
s.boot;
(dur: inf).play;

CmdPeriod.run; // or hit the Stop key command, Cmd-., or ctrl-.
3 + 4; // continue recording into history
4 + 5;
History.end;

// Replays history, including a CmdPeriod, and keeps replaying history.
History.play;


::

ClassMethods::

Note::
Many class methods are redirected to the privileged instance of History, code:: History.current::. This is intended to provide a simple code user interface.
::

private::initClass, timeStamp, dateString, hasMovedOn, lineShorts
private:: addToLog, date, time0, saveFolder, logFolder, logFile, logPath, makeLogFolder, checkLogStarted, startLog, endLog, showLogFile.
private:: maxShortLength, getTimeFromString, asLines, cmdPeriod

method::start
start adding interpreted code to (current) history.

method::end
end adding interpreted code to (current) history.

method::started
boolean whether History is started.

method::document
post the history in a new document (as story). The document title is a string formatted as follows: code::"%Y-%m-%d-%Hh%M-History"::.

method::current
the current History instance

method::lines, lineShorts
the currently recorded lines in History.current.
lineShorts is a copy with shortened strings for display.

method::makeWin
make a HistoryGui for History.current.
argument: where
a point that sets left top of the HistoryGui window,
argument: numItems
the number of lines in the textview

subsection::Configuration

method::keepsLog
get and set flag whether to log History to a file.

method::verbose
get and set flag whether to post debug messages from History operations.

method::recordLocally
get and set flag to turn recording local code evaluation on and off

method::localOff, localOn
convenience to turn recording of local code evaluation on and off

method::forwardFunc
a function to run on incoming new lines, can be used to send code by network.
See the Utopia quark for examples of networking code history.

subsection::Save and load history logs

method::showLogFolder
open folder where logfiles are stored

method::showLogFile
open current log file

method::saveCS
store history as one compileString.

method::loadCS
load a history from (compilestring) file.

method::saveStory
store in a file, in historical order as individual code snippets.

method::loadStory
read history into current, from a file in story format.

method::rewrite
Write a properly formatted code file from a history.
argument::path
The filename is the original name with "_rewritten." appended.
argument::open
If open is true (default: true), open a text window with the string.

method::readFromDoc
read in a history from a code file created with .rewrite


subsection:: Editing history
method::clear
remove all items from (current) history.

method::enter
add an entry to (current) history by hand.

method::drop
drop the newest num lines from history. if n is negative, drop the oldest n lines.

method::keep
keep only the newest num lines from history. if n is negative, keep the oldest n lines.

method::removeAt
remove a specific line

method::removeLast
remove last line from history

subsection:: Repeating history
Repeating history can have different uses:
A. Reconstruction, e.g. redoing a history of coding steps as closely as possible,
or replaying a full performance as closely as possible; here, all errors are important and should be handled individually.
B. Experimental live performance, e.g. replaying snippets from a recorded networked live-coding show in nonlinear orders; here, errors will occur more often because the current state will not always fit with what a particular line would require. Thus, one will likely prefer the robustness to just keep going.

method:: ignoreErrors
global flag whether evaluating code lines via History will ignore errors or stop and throw them.

method::eval
evaluate codeString, and optionally, use ignoreError to override global ignoreErrors flag.

code::
History.ignoreErrors = true;
History.eval("2 + 1").postln; // correct code, so is just evaluated
History.eval("2 + qwe"); 123; // compile error, but keeps going and posts 123
History.eval("1.blonk"); 123; // runtime error, keeps going -> posts 123
History.eval("1.blonk", false); 123; // throws error and stops, code after it never happens.
::

method::evalLineAt
evaluate the line at index in History.current.lines

method::play
play back current history from start to end line, per default verbose.

method::stop
stop current history playback.


subsection:: Date, time, string functions
method::startTimeStamp
method::formatTime
method::unformatTime
method::shorten
method::prettyString

private:: checkPath

method::new
create a new instance containing the lines given.

InstanceMethods::

Note:: the instance methods code::[hasMovedOn_, hasMovedOn, play, stop, lines, lineShorts, removeAt, removeLast, keep, drop, clear, saveCS, loadCS, saveStory, evalLineAt, loadStory, makeWin, document]:: are also implemented as class methods, and documented above.
::

private:: hasMovedOn_, hasMovedOn, play, stop, lines, lineShorts, removeAt, removeLast, keep, drop, clear, saveCS, loadCS, saveStory, evalLineAt, loadStory, makeWin, document

method::isCurrent
flag whether this history is History.current

method::makeCurrent
make this history History.current

method::player
the player task for ths history

method::keys
all keys of code authors in this history

method::addLine
add a line to history with current time, id, and code string


method::indicesFor
find line indices created by keys and containing string. used for filtering.

private:: matchKeys, matchString, storyString

Examples::

code::
// same as first example:
History.clear.end;      // clear to start over
History.start;          // starts recording, opens log file

// execute these lines one by one
1 + 2;
p = ProxySpace.push(s.boot);
~a = {Dust.ar([1,1] * 30 ) * 0.3 };
~a.play;
~a.end;

History.end; // History.end ends logging as well.


History.document; // create a document with all the changes
History.showLogFile; // open the log file as it was written.

g = History.makeWin(0@20); // make a gui window, put it where you like
g = History.makeWin(0@20, 5); // number of lines in textview

History.play;                  // posts lines by default
History.play(verbose: false);  // just do it, no posting

// continue recording
History.start;

// enter 5 more lines
10 + 200;
p.push;
~b = { |freq=500| LFDNoise3.ar(freq.dup(2)) * 0.2 };
~b.play;
~b.set(\freq, 1000);
~b.end(2);

History.end;

// save current history to a file.
History.saveCS("~/Desktop/TestHist.scd");
h = History.new.loadCS("~/Desktop/TestHist.scd");
h.lines.printcsAll; "";

// Many History methods are redirected to History.current:

// History.current is where new codelines always go.
h = History.current;
h.lines.printcsAll; "";

// lineshorts are for gui display:
h.lineShorts.printcsAll; "";

// make a simple entry by hand.
History.enter("2 + 2");
h.lines.printcsAll; "";

// one can edit a history:
History.drop(-1); // drop the oldest memory
History.drop(1); // drop the newest memory

h.keep(9); h.lines.printAll; "";
h.drop(3); h.lines.printAll; "";
h.removeLast;       h.lines.printAll;"";
h.removeAt([3, 4]); h.lines.printAll;"";

// more examples
History.clear.start;

1 + 2; // code lines get stored

(nil + 2).postln; // error lines are ignored

// comment-only line is kept, empty lines not:
History.enter("// comment only");
History.enter(" ");


// save and load as text files

History.saveCS; // save as compilestring for reloading.

// save with name, in forward time order.
History.saveCS("~/Desktop/testHist.scd", forward: true);

// load back in from file
h = History.new.loadCS("~/Desktop/testHist.scd", forward: true);
h.lines.postcs; "";

// save as human-readable/hand-playable story
// write all to time-stamped file in historical order:
History.saveStory;

// ... with given filename.
History.saveStory("~/Desktop/myTestStory.scd");

// load from story format file
History.loadStory("~/Desktop/myTestStory.scd");

Document.open("~/Desktop/myTestStory.scd");	// the story file is human-readable.


// Various Internals
// make a new instance of History by hand:
h = History([
	[0, \me, "1+2"],
	[1.234, \me, "q = q ? ();"],
	[3, \me, "\"History\".postln"]]);
h.lines.printcsAll; "";
h.lineShorts.printcsAll; "";

h.play; // play it back
h.stop;


// string formatting utils
h.storyString;
History.formatTime(1234.56);
History.unformatTime("0:20:34.56");

(
History.prettyString("

/* removes line returns at start and end of code strings ... */

").postcs;
)

// convert a line to a short string of n characters for gui display
History.shorten(h.lines.first.postcs, 60).postcs;


// in networked setups, one may turn off local recording and rely on remote recording:
History.recordLocally
History.localOff
History.recordLocally
History.localOn
History.recordLocally


// by default, history always logs here (and makes the folder if not there yet):
History.logFolder;
History.showLogFolder;
History.logPath;
History.showLogFile; // current logfile...
// todo: optionally, one should be able to turn logging off?

// filtering lines, to get subsets of all lines by key and/or searchstring:

// get indices for specific keys
h = History([[0, \me, "a=1+2"], [1, \me, "3+5"], [1.234, \you, "q = q ? ();"], [3, \they, "\"The-story ==== \".postln"]]);
h.keys;
h.matchKeys(\me);
h.matchKeys(\you);
h.matchKeys(\they);
h.matchKeys;        // nil if no test
h.matchKeys(\all);  // all keys match
h.matchKeys([\me, \they])
h.matchKeys(\isidor) // empty array if no line found for this key

h.matchString("The-s");
h.matchString("q");
h.matchString("1+");
h.matchString("the-Story", false); // ignoreCase is false by default
h.matchString("the-Story", true); // ignoreCase

h.indicesFor([\me, \they], "=");	// indices for line written by \me or \her AND containing "=";

// searching is only an interface/access feature,
// so please read on at HistoryGui help ...
h.makeWin;

HistoryGui.help;
::


CLASS:: HistoryGui
summary:: A gui for History objects
categories:: GUI>Interfaces
related:: Classes/History

DESCRIPTION::

HistoryGui allows easy access to History as it happens: one can read recent lines, when they were written and by whom; one can search for text strings and by author names; and one can quickly grab lines of code for rewriting. Apart from documenting just in time programming sessions, all of this can be useful in live coding performances. See e.g. the system developed by powerbooks_unplugged, in the Quark called Republic.

The gui elements in detail:
DEFINITIONLIST::
## button start/end || starts and ends History emphasis::if:: code::gui.history:: is current.

## button all/filt || turns filtering on/off.
## popup all/... || selects which name key to search for (useful if networked)
## TextView || allows for typing in a search string.
## button top/keep || sets mode whether ListView stays on top line, or keeps sticking to the selected line.

## ListView || shows either all code::lineShorts::, or the filtered code::lineShorts::; selecting them in ListView makes them come appear in post-doc window.
::

first example:
code::
(
// create a short history
h = History([
	[0, \me, "1+2"],
	[1, \me, "3+5"], [1.234, \you, "q = q ? ();"],
	[3, \they, "\"The story\".speak"]
]);
// make a gui for it
g = h.makeWin(0@20);
// find or make a text window for code line display
// (called 'doc' because that was a Document in pre-Qt times)
g.findDoc;
// post line at index 2 in h.lines in doc window
g.postDoc(2);
)
::

ClassMethods::

method::docHeight
get and set the height of the text window opened by HistoryGui
method::docTitle
get and set the title of the text window opened by HistoryGui

method::new
create a new HistoryGui
argument:: object
the history
argument:: numItems
the number of lines in the TextView above
argument:: parent
a parent window or view in which to place new HistoryGui
argument:: bounds
bounds for new HistoryGui, constrained by its minSize.
argument:: makeSkip
flag whether to create a skipjack for the HistoryGui.
argument:: options
options to set for the HistoryGui (inherited from JITGui).


InstanceMethods::

private:: accepts, checkUpdate, getState, makeViews, setDefaults, postInlined
private:: updateBinVal, updateFunc, updateLines, updateVal, alignDoc
subsection:: views
method::textV
top: the TextView for the selected line
method::startBut, filtBut, keyPop, filTextV, topBut
the line of buttons, popup and TextView
method::listV
the ListView for the history lines
method::resetViews
reset all views

method::showLineAt
show the line at that index in History.lines in the TextView.

subsection:: 'doc'-related
method::doc
the external text window made by HistoryGui to show codelines on.
This is still called doc because it used to be a Document in pre-Qt times.

method::findDoc
find an open a re-usable text window, or make a new one

method:: docFlag
get or set the symbol for the doc strategy to use:
code::\sameDoc:: tries to re-use a single text window,
code::\newDoc:: always makes a new one (and keep track of old docs)

method::oldDocs
list of previous text windows (docs) opened

method::postDoc
find the codeline at index in History, and post it on the textwindow

method::setDocStr
set the string of the current textwindow

method::rip
create a new textwindow with currently selected line


subsection:: filtering
method::filtering
flag whether filtering is on
method::filterOn, filterOff
convenience on/off methods

method::filters
keys and string fragments to filter for.
e.g. [ 'all', "+" ] gets lines from all sources that contain the string "+".
method::filterLines
apply filtering to history lines

method::filteredIndices
the indices of the current filtered lines

method::filteredShorts
the current filtered short lines for gui display

method:.setKeyFilter
set the key(s) to filter for, and perform filtering

method::setStrFilter
set the string to filter for, and perform filtering

method::stickMode
stickMode 0 means top, i.e. select top when new lines come in;
stickMode 1 means keep, i.e. keep current line selected after new lines come in.

EXAMPLES::

code::
(
// create a short history
h = History([
	[0, \me, "1+2"],
	[1, \me, "3+5"], [1.234, \you, "q = q ? ();"],
	[3, \they, "\"The story\".speak"]
]);
// make a gui for it
g = h.makeWin(0@20);
// find or make a text window for code line display
// (called 'doc' because that was a Document in pre-Qt times)
g.findDoc;
// post line at index 2 in h.lines in doc window
g.postDoc(2);
)

h.document;

// show how filtering works:

g.filtering; // is filter on?
g.filterOff; // shorthand for off
g.filterOn;  // and on

// filtering looks for lines by author key(s)
// and strings in the code lines:
g.filters.postcs;

g.setKeyFilter(\all);
g.setKeyFilter(\me);
g.setStrFilter("");
g.setStrFilter("3");

g.filters.postcs;

// internal state cached in the HistoryGui:
g.filteredIndices;
g.filteredShorts;

::


class:: IEnvGen
summary:: Envelope generator for polling values from an Env
categories:: UGens>Envelopes
related:: Classes/Env

description::
Envelope generator for polling values from an envelope. IEnvGen plays back break point envelopes from the code::index:: point. The envelopes are instances of the link::Classes/Env:: class.

classmethods::
private:: categories, new1

method:: ar, kr

argument:: envelope
an instance of Env (this is static for the life of the UGen)
argument:: index
a point to access within the Env
argument:: mul
argument:: add

instancemethods::
private:: init, argNamesInputsOffset, convertEnv

examples::

code::
(
{
	var env =  Env([0, 0.6, 0.3, 1.0, 0], [0.1, 0.02, 0.4, 1.1], [\lin, \exp, -6, \sin]);
	var envgen = IEnvGen.kr(env, MouseX.kr(0, env.times.sum));
	env.plot;
	SinOsc.ar(envgen * 500 + 440)
}.play;
)

// index with an SinOsc ... mouse controls amplitude of SinOsc
// use offset so negative values of SinOsc will map into the Env
(
{
	var sin = SinOsc.ar(440, 0, MouseX.kr(0, 1));
	// use offset so negative values of SinOsc will map into the Env
	var env = Env([-1, -0.7, 0.7, 1], [ 0.8666, 0.2666, 0.8668 ], \lin, offset: -1.0);
	IEnvGen.ar(env, sin) * 0.1
}.play;
)

// index with Amplitude of input, control freq of SinOsc (uses SoundIn)
(
{
	var point = Amplitude.ar(SoundIn.ar(0), 0.01, 0.2);
	// use offset so negative values of SinOsc will map into the Env
	var env = Env.xyc([[0, 330, \exp], [0.5, 440, \exp], [1.0, 1760]]);
	SinOsc.ar(IEnvGen.kr(env, point)) * 0.2
}.play;
)

::



class:: IFFT
summary:: Inverse Fast Fourier Transform
related:: Classes/FFT, Guides/FFT-Overview
categories::  UGens>FFT


Description::
The inverse fast fourier transform converts from frequency content to a
signal.

The fast fourier transform analyzes the frequency content of a signal. The IFFT UGen converts this emphasis::frequency-domain:: information back into emphasis::time-domain:: audio data. Most often this is used as the end of a process which begins with link::Classes/FFT::, followed by frequency-domain processing using PV (phase-vocoder) UGens, followed by IFFT.

classmethods::

method::new, ar, kr
returns a time domain signal from converting the FFT frequency domain signal chain. The *new method is equivalent to the *ar message returns an audio rate signal.

argument::buffer

The FFT "chain" signal coming originally from an FFT UGen, perhaps via other PV UGens.

argument:: wintype
Defines how the data is windowed:
table::
## -1 || strong::rectangular:: windowing, simple but typically not recommended;
## 0 || (the default) strong::Sine:: windowing, typically recommended for phase-vocoder work;
## 1 || strong::Hann:: windowing, typically recommended for analysis work.
::

argument:: winsize
Can be used to account for zero-padding, in the same way as the link::Classes/FFT:: UGen.

returns::
The emphasis::time-domain:: audio signal.

discussion::
The IFFT UGen converts the FFT data in-place (in the original FFT buffer) and overlap-adds the result to produce a continuous signal at its output.

Examples::

code::

// without any modification, convert FFT chain (frequency domain signal) back to audio (time domain signal)
(
{   var in, chain;
    in = WhiteNoise.ar;
    chain = FFT(LocalBuf(2048), in);
    IFFT.ar(chain) * -20.dbamp // inverse FFT
}.play;
)

::



class:: IODesc
summary:: Description of SynthDesc input or output
categories:: Server>Nodes
related:: Classes/SynthDesc

description::
IODesc describes an input or output of a SynthDesc, as returned by link::Classes/SynthDesc#-outputs:: and link::Classes/SynthDesc#-inputs::

classmethods::
private:: new

instancemethods::
private:: printOn

method:: rate
A link::Classes/Symbol:: for the rate.

method:: numberOfChannels
The number of channels.

method:: startingChannel
This can either be a link::Classes/String::, a link::Classes/Float:: or an link::Classes/UGen::.
table::
## String || The name of the control that provides the bus index
## Float || A hard-coded bus index
## UGen || The UGen providing the bus index
::

method:: type
The class of the input/output ugen, like link::Classes/In::, link::Classes/Out::, link::Classes/ReplaceOut::, etc.



class:: IRand
summary:: Single integer random number generator.
related:: Classes/ExpRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random integer value in uniform distribution from
code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::
(
SynthDef("help-IRand", {
	Out.ar(
		IRand(0, 1), //play on random channel between 0 and 1
		FSinOsc.ar(500,
			0, Line.kr(0.2, 0, 0.1, doneAction: Done.freeSelf))
	)
}).add;
)

(
Routine({
	16.do({
		Synth.new("help-IRand"); 0.5.wait;
	})
}).play;
)
::



CLASS::IdentityBag
summary::A Bag according to identity
categories::Collections>Unordered

DESCRIPTION::
An IdentityBag is an unordered collection of objects. In some languages it is referred to as a counted set. A Bag keeps track of the number of times objects are inserted and requires that objects be removed the same number of times. There is only one instance of an object in a Bag even if the object has been added to the Bag multiple times (test is for strong::identity::).

The contents of a IdentityBag are unordered. You must not depend on the order of items in a set.

INSTANCEMETHODS::

private::setDictionary

subsection::Adding and Removing

method::add
Add anObject to the Bag. A Bag may contain multiple entries of the same object.
code::
IdentityBag[1, 2, 3].add(4);
IdentityBag[1, 2, 3].add(3);
IdentityBag["abc", "def", "ghi"].add("jkl");
IdentityBag["abc", "def", "ghi"].add("def");
::

method::remove
Remove anObject from the IdentityBag.
code::
IdentityBag[1, 2, 3].remove(3);
::

method::contents
Returns the dictionary that stores the objects in pairs (obj -> numberOfObjects)
code::
IdentityBag[\a, \b, \c, \c].contents;
::

subsection::Iteration

method::do
Evaluates function for each item in the IdentityBag.
The function is passed two arguments, the item and an integer index.
code::
IdentityBag[1, 2, 3, 300].do({ arg item, i; item.postln });
::

section::Difference between Bag and IdentityBag
code::
// the two strings are equal, but not identical
"something" == "something"; // true
"something" === "something" // false

a = Bag.new;
a.add("something");
a.add("something");
a.contents; // only one object in the bag really

a = IdentityBag.new;
a.add("something");
a.add("something");
a.contents; // two objects in the bag
::


CLASS::IdentityDictionary
summary::associative collection mapping keys to values
related::Classes/Environment, Classes/Event
categories::Collections>Unordered

DESCRIPTION::
An IdentityDictionary is an associative collection mapping keys to values. Keys and values can be arbitrary objects, but for keys, often a link::Classes/Symbol:: is used.

Often, the subclass link::Classes/Event:: is used as an IdentityDictionary, because there is a syntactical shortcut:
code::
a = (); // return a new Event.
a.put(\foo, 2.718);
a.at(\foo);
::

Note::
Keys match only if they are strong::identical objects::. (i.e. === returns true. In Dictionary, keys match if they are equal valued. This makes IdentityDictionary faster than link::Classes/Dictionary::)

The contents of a Dictionary are strong::unordered::. You must not depend on the order of items in a Dictionary.
::


IdentityDictionary is often used to assign names to instances of a particular class. For example, the proxy classes ( link::Classes/Pdef::, link::Classes/Pdefn::, link::Classes/Tdef::, link::Classes/Ndef:: ), and link::Classes/NodeWatcher:: all have class variables named all implemented as IdentityDictionaries.

Subsection:: 'parent' and 'proto' variables

IdentityDictionary has three levels of content: the dictionary itself, a code::proto::, and a code::parent::. code::proto:: and code::parent:: exist primarily for IdentityDictionary's subclass link::Classes/Event::, which uses the code::parent:: to store action functions that will be used when an event is played. Users may put additional default values into the code::proto::.

Looking up a key within a dictionary first checks the dictionary itself. If the key is not found at this level, it looks in the code::proto::, and if still not found, it looks in the parent.

These extra levels are meant for common, default values that should be the same across many dictionary instances.

list::
## code::proto:: and code::parent:: values are not shown when posting the dictionary.
## Copying an IdentityDictionary transfers a reference to the parent and proto into the copy. It is a reference, not a copy: changing the copy's parent also affects the parent of the original. This is for efficiency.
## Iteration operations (link::Classes/Dictionary#-do::, link::Classes/Dictionary#-keysValuesDo::) only touch the main-level values.
## link::Classes/Dictionary#-collect::, link::Classes/Dictionary#-select::, and link::Classes/Dictionary#-reject:: return new dictionaries. The parent and proto will be preserved emphasis::as is:: in the new result, but -- as with code::do:: -- they will not be processed in the iteration, and as with code::copy::, they are identical references.
::

code::
// 'b' is not posted
e = IdentityDictionary(8,
	parent: IdentityDictionary[\b -> 10]
).put(\a, 5);
-> IdentityDictionary[ (a -> 5) ]

// But 'b' is still there
e[\a] + e[\b]
-> 15

// Iteration touches 'a' only
e.keysValuesDo { |key, value| [key, value].postln };
-> [ a, 5 ]

// 'collect' is also an iteration, and doesn't touch the parent
g = e.collect { |x| x * 5 };
-> IdentityDictionary[ (a -> 25) ]
g[\b]
-> 10

// The parent goes into a copy as well
g = e.copy;
g[\b]

// But it's by reference: 'e' and 'g' have the same parent
g.parent[\b] = 20;
e[\b]
-> 20
::


CLASSMETHODS::

method::new
The link::#-parent:: and link::#-proto:: instance variables allow additional IdentityDictionary's to provide default values. The precedence order for determining the value of a key is the IdentityDictionary, its prototype, its parent.

When the instance variable link::#-know:: is link::Classes/True::, the IdentityDictionary responds to unknown messages by looking up the selector and evaluating the result with the dictionary as an argument. For example:
code::
a = IdentityDictionary(know: true);
a.put(\foo, { | x, y | "--".postln; ("x:" ++ x).postln;  ("y:" ++ y).postln; y.squared });
a.foo(-10.01);
::


warning::
Only keys that are not already instance methods of IdentityDictionary (or its superclasses) can be used in such a way. E.g. the key "free" will not work, because it is implemented in Object. This means that class extensions (see: link::Guides/WritingClasses::) can break code. It is advisable to use underscores in method names to make this improbable.
::

In the subclass link::Classes/Event::, "know" is true by default, so that it can be instantly used for prototype objects. The first argument passed to the functions is in such cases always the dictionary/event itself (here denoted by "self").

code::
a = (some_value: 7, fuzzy_plus: { |self, a, b| a + b * rrand(0.9, 1.1) });
a.some_value; // returns 7
a.some_value = 8; // sets it to 8
a.fuzzy_plus(7, 4);
::

INSTANCEMETHODS::


method::know
If set to true, the dictionary interprets method calls as look ups. This allows you to implement object prototypes (see above).

method::putGet
Sets key to newValue, returns the previous value of key.
code::
a = (z: 100);
x = a.putGet(\z, -1); // x is now 100
::

method::includesKey
Returns true if the key exists in the dictionary
code::
(j:8).includesKey(\j) // true
::

method::findKeyForValue
Returns the key for a given value (it'll return the first it finds, so this may be ambiguous).
code::
(j:8, k: 9).findKeyForValue(8); // returns \j
::
If such reverse lookup is needed a lot, for efficiency you may consider using a link::Classes/TwoWayIdentityDictionary:: instead.


method::proto, parent

The two instance variables proto and parent may hold dictionaries which are used to look up all those keys that have no value in the current dictionary.
First, proto is looked up, then parent. In other words: proto overrides parent. This allows you to construct systems with complex defaults or multiple inheritance.

code::
x = (freq: 30);
a = (amp: 1).parent_(x);
a.at(\freq); // returns 30
a.proto_((freq: 20));
a.at(\freq); // returns 20
y = (i: -1);
b.parent_(y);
a.at(\i); // returns -1
a.cs;

::

image::IdentityDictionary_02.png#Setting the parent of a dictionary.::

code::
x = (freq: 30);
a = (amp: 1).parent_(x);
y = (freq: 300);
b = (amp: 0.5).parent_(y);
a.parent_(b);
a.at(\freq); // returns 300
a.cs;

::

image::IdentityDictionary_01.png#Example schema: order of overriding in proto and parent.::


method::insertParent
Inserts a dictionary into the chain of parents of the receiver (rather than replacing the parent).
argument::newParent
The dictionary that is added to the parent chain
argument::insertionDepth
Level at which the new parent is inserted. Zero (default) means directly above, Inf means at the top of the parent chain.
argument::reverseInsertionDepth
If the new parent dictionary has parents itself, this parameter specifies where the original parents are placed in the new parent chain. Zero means directly above, Inf (default) means at the top of the chain.


image::IdentityDictionary_03.png#Compare a.insertParent(b, 0) and a.insertParent(b, 1)::

image::IdentityDictionary_04.png#Compare a.insertParent(b, 0, inf) and a.insertParent(b, 0, 0)::

subsection::Timing support (Quant)

method::nextTimeOnGrid, asQuant, timingOffset

Use a dictionary to represent timing information.

code::
(
SynthDef(\help_sinegrain,
    { arg out=0, freq=440, sustain=0.05;
        var env;
        env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
        Out.ar(out, SinOsc.ar(freq, 0.5pi, env))
    }).add;

a = Pbind(\instrument, \help_sinegrain, \note, Pseq([0, 7, 2, 9, 11, 10, 9, 8], inf), \dur, 1);
a.play(quant:(quant: 1, phase: 0));
a.play(quant:(quant: 1, phase: 1/3));
a.play(quant:(quant: 1, phase: 1.0.rand));
)
::

subsection::Garbage collection

method::freezeAsParent
For optimizing the garbage collector load, objects can be frozen and become immutable. This method creates a new dictionary with the frozen instance as a parent so that all contents can be overwritten without losing this optimization.



CLASS::IdentitySet
summary::a set according to identity
related::Classes/List, Classes/Dictionary
categories::Collections>Unordered

DESCRIPTION::
An IdentitySet is a collection of objects, no two of which are the same object (aka. "identical").
Most of its methods are inherited (see link::Classes/Collection:: and link::Classes/Set:: classes).
The contents of an IdentitySet are unordered. You must not depend on the order of items in an IdentitySet.
For an ordered set, see link::Classes/OrderedIdentitySet::.

IdentitySets are faster than Sets because testing for identity is much faster than testing for equality. Different classes may implement equality in different ways, but identity can be determined just by comparing the object addresses. This allows some methods of IdentitySet to be implemented
by fast primitives.

INSTANCEMETHODS::

subsection::Adding and Removing

method::add
Add anObject to the IdentitySet. An object which is equal to an object already in the IdentitySet will not be added.
code::
IdentitySet[1, 2, 3].add(4);
IdentitySet[1, 2, 3].add(3);
// the two strings are equal but not identical
IdentitySet["abc", "def", "ghi"].add("def");
// symbols are guaranteed to be identical if they are equal
IdentitySet['abc', 'def', 'ghi'].add('def');
IdentitySet['abc', 'def', 'ghi'].add('jkl');
::

method::remove
Remove anObject from the IdentitySet.
code::
IdentitySet[1, 2, 3].remove(3);
::

subsection::Iteration

method::do
Evaluates function for each item in the IdentitySet. You must not depend on the order of items. The function is passed two arguments, the item and an integer index.
code::
IdentitySet[1, 2, 3, 300].do { |item, i| item.postln };
::

subsection::Finding an element

method::findMatch
Returns item if it is in the collection, otherwise returns nil.
code::
a = IdentitySet[1, 2, 3, 300];
a.findMatch(1);
a.findMatch(1.5);
::

EXAMPLES::

code::
// scanFor is fairly efficient. compare the following benchmarks:

// comparison of array indexing and identity set lookup
(
f = { |n=4|
	var x, y, i;
	x = (0..n);
	y = x.as(IdentitySet);
	i = x.choose;
	bench { 100.do { x[i] } };
	bench { 100.do { y.scanFor(i) } };
}
);

f.(4)
f.(8)
f.(100)
f.(10000)
::

code::
// you can use IdentitySet to efficiently remove identical duplicates from an array:

(
var e, f, g, h;
e = "such"; f = "fallacy"; g = "is"; h = "common";
a = [e, e, f, g, e, h, e];
);
a.as(IdentitySet);	// convert to set
a.as(Set).as(Array);	// and convert back

// note that the following behaves differently:
a = [ "such", "such", "fallacy", "is", "such", "common", "such" ]
a.as(IdentitySet);	// convert to set. All elements are still here.
			// Different strings may look the same, but be different objects.

// To remove equals in stead of identicals, use Set:
a.as(Set);
::


class:: Image
summary:: image component
categories:: GUI>Views
related:: Classes/View

DESCRIPTION::

Image enables the drawing of images in the SuperCollider GUI.


CLASSMETHODS::

PRIVATE::initClass, prFromWindowRect, prFreeAll

METHOD::new
Creates a new Image instance. "multiple" here stands for multiple arguments.

ARGUMENT::multiple
Any of the following:
list::
## link::Classes/Number:: to create an strong::empty:: image of size multiple as width and height
code::
i = Image.new(400);		// Create a 400x400 pixel Image.
i.bounds;
i.free;

i = Image.new(400, 200);	// Create a 400x200 pixel Image.
i.bounds;
i.free;
::
## link::Classes/Point:: to create an strong::empty:: image of size multiple.x as width and multiple.y as height
code::
i = Image.new(400@200);	// Create a 400x200 pixel Image.
i.bounds;
i.free;
::
## link::Classes/String:: to create an image from a strong::local file::
code::
//	Path string
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png"); // add a path to your image
[i.width, i.height].postln;
i.bounds;
i.plot;
i.free;
::
::

ARGUMENT::height
If strong::multiple:: is a number, then this argument indicates the height of the new image.


METHOD::color
Creates a new Image instance filled with the specified color.
code::
i = Image.color(400, 200, Color.blue(0.9,0.1));
i.plot(freeOnClose:true);
::

ARGUMENT::... args
Multiple arguments. the last argument should be a valid link::Classes/Color::

METHOD::open
Creates a new Image instance from the local file at strong::path::.
code::
(
i = Image.open(SCDoc.helpSourceDir +/+ "images/Swamp.png");
i.plot(freeOnClose:true);
i.url.postln;
)
::

METHOD::openSVG
Creates a new Image instance from the local SVG file at strong::path::.
code::
(
i = Image.openSVG(SCDoc.helpSourceDir +/+ "images/plugin.svg", 200@200);
i.plot(freeOnClose:true);
i.url.postln;
)
::

ARGUMENT::path
A String containing the SVG file's path.

ARGUMENT::size
A link::Classes/Size::. SVG contents will be drawn into an image of this size. If not provided, suggested size provided by SVG will be used.


METHOD::openURL
NOTE::Not implemented yet.::
Creates a new Image instance from a valid image at the specified URL strong::path::.
code::
i = Image.openURL(SCDoc.helpSourceDir +/+ "images/Swamp.png");
i.url;
w = i.plot(freeOnClose:true);
::

METHOD::fromImage
Creates a new Image instance from another Image.
code::
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
j = Image.fromImage(i);
i.dump;
j.dump;
[i, j].do(_.plot);
[i, j].do(_.free);
::

METHOD::fromWindow
Creates a new Image from a portion of a Window. this can be used to capture either a window or a specific View.

code::
// WINDOW Example:
// First create a window and draw inside of it
(
	w = Window.new;
	w.front; // comment this to copy offscreen window
	w.view.background_(Color.white);
	w.drawHook = {
		Pen.translate(100, 100);
		10.do{
			// set the Color
			Pen.color = Color.blue(rrand(0.0, 1), rrand(0.0, 0.5));
			Pen.addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);
			Pen.perform([\stroke, \fill].choose);
		}
	};
	w.refresh;
)

// then grab the window
(
	i = Image.fromWindow(w);
	w.close;
	i.plot(freeOnClose:true);
)

// VIEW Capture Example:
// First create a window and add some views inside of it
(
	w = Window.new.front;
	b = [10, 80].asSpec;
	c = NumberBox(w, Rect(20, 20, 60, 40));
	a = Slider(w, Rect(20, 80, 100, 40))
		.focusColor_(Color.red(alpha:0.2))
		.action_({
			c.value_(b.map(a.value).round(0.01))
	// round the float so it will fit in the NumberBox
			});
)

// then grab the window
(
	i = Image.fromWindow(w, a.bounds);
	w.close;
	i.plot(freeOnClose:true);
)
::

ARGUMENT::window
the Window object.

ARGUMENT::rect
optional. the constrained rect to capture inside the Window. By default, it is the window size.

METHOD::closeAllPlotWindows
Close all the Image plot windows currently opened.

METHOD::colorToPixel
Convert a link::Classes/Color:: into a pixel datatype suitable for setting pixel data in the Image class.
RETURNS:: A 32bit packed Integer in the RGBA format.

METHOD::pixelToColor
Convert a 32bit packed Integer in the RGBA format into a link::Classes/Color::
RETURNS:: A link::Classes/Color::

PRIVATE::newEmpty, prFormats

SUBSECTION::Class variables and attributes

METHOD::formats
returns all the valid image formats as an link::Classes/Array::
code::
Image.formats;
::

METHOD::compositingOperations
returns all the valid compositing operations you can use when drawing an Image as an link::Classes/Array::
code::
Image.compositingOperations;
::

METHOD::interpolations
returns an link::Classes/Array:: of the different levels of interpolation you can specify when drawing an Image.
code::
Image.interpolations;
::

METHOD::resizeModes
returns an link::Classes/Array:: of the different resize modes you can specify when changing the size of an Image.
code::
Image.resizeModes;
::

METHOD::allPlotWindows
Returns an array of all the Image plot windows currently opened.
code::
Image.allPlotWindows
::


INSTANCEMETHODS::

PRIVATE::prLockFocus, prDrawAtPoint, prSync, prApplyFilters, prTileInRect, prUpdatePixelsInRect, prGetPixel, prInit, prSetInterpolation, prFree, prSetPixel, prLoadPixels, prSetBackground, prApplyKernel, prUpdatePixels, prWriteToFile, prUnlockFocus, prInitFromURL, prSetColor, prGetColor, prSetName, prGetInterpolation, prDrawInRect, prNewEmpty, prNewFromWindow, prNewPath, prNewSVG, prNewURL, prSetPainter, prSetSize, prTransferPixels, prUnsetPainter

SUBSECTION::commons / general attributes

METHOD::width
returns or set the width of the receiver

METHOD::height
returns or set the height of the receiver

METHOD::setSize
set the size of the receiver

METHOD::bounds
returns the bounds of the receiver.

METHOD::free
deallocate the receiver. this method is useful if you want to manage and reclaim yourself resources. otherwise you do not need to call this method since each object is automatically garbage collected.

METHOD::scalesWhenResized
flag to tell or set if the receiver should update its bitmap representation to scale when a resize operation is performed
code::
(
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
i.bounds.postln; // getting the dimensions
w =i.plot;
)

// changing the size of an image
(
i.scalesWhenResized_(true);
i.setSize(400, (400 / (i.width / i.height)).asInteger);
a =i.plot;
)

(
a.close; w.close; i.free;
)
::

METHOD::url
returns or set the url of the receiver. Returning only if any where supplied at creation, otherwise returns nil. Setting may be used for different purpose but try to supply a valid one since it is used for archiving the image as an object.
code::
i = Image.new("http://www.google.com/intl/en_ALL/images/logo.gif");
i.url;
i.plot;
i.free;
::

METHOD::interpolation
get or set the level of interpolation used when rendering the image - it has not effect when the Image is accelerated. see link::#*interpolations:: for a valid range of values.
code::
(
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
w = i.plot;
i.interpolation;			// get the image currrent interpolation mode
)

(
i.interpolation = 'fast';		// experiment with interpolation modes
w.refresh;
)

(
i.interpolation = 'smooth';
w.refresh;
)

i.free;
::

SUBSECTION::saving and archiving

METHOD::write
write the Image to a file.
code::
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
i.dump
i.write("~/Desktop/my_image.png".standardizePath);
i.free;

//	storeOn / asCompileString
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");

i.url;
i.asCompileString;
i.writeArchive("~/Desktop/my_image.scd".standardizePath);

i.free;
i = nil;

Document.open("~/Desktop/my_image.scd".standardizePath);

i = Object.readArchive("~/Desktop/my_image.scd".standardizePath);
i.plot;
i.free;
::

ARGUMENT::path
the location where to save it

ARGUMENT::format
(optional) format to use. see Image.formats for supported formats. If nil, it will get the format depending on the path extension.

ARGUMENT::quality
The quality factor must be in the range 0 to 100 or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 (the default) to use the default settings.

SUBSECTION::rendering

METHOD::plot
plots the image in a Window.
code::
i = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
w = i.plot;
w.close;

w = i.plot(showInfo:false);
w.close;
i.free;

// other option - image will be automatically freed when closed
Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png").plot("Hello", freeOnClose:true);
::

ARGUMENT::name
the title of the Window. may be nil.

ARGUMENT::bounds
the bounds of the Window. may be nil.

ARGUMENT::freeOnClose
flag to tell if the Window should free the Image when closed.

ARGUMENT::background
additional background to apply to the Window. may be useful for artifacts due to alpha / compositing...

ARGUMENT::showInfo
shows pixel coordinates while the mouse is over the image's plot window.

METHOD::draw
shortcut for drawing inside an image. equivalent to :
list::
## receiver.lockFocus
## aFunction
## receiver.unlockFocus
::
code::
(
	j = Image.new(400,300);
	j.draw({ arg image;

		Pen.translate(100, 100);
		1000.do {
			// set the Color
			Pen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
			Pen.addAnnularWedge(
				(100.rand)@(100.rand),
				rrand(10, 50),
				rrand(51, 100),
				2pi.rand,
				2pi.rand
			);
			Pen.perform([\stroke, \fill].choose);
		};
	}).plot(freeOnClose:true);
)

//	String drawing support on the image
//	drawStringAtPoint(string, point, font, color);
(
	j = Image.new(150,50);
	j.draw({ arg bounds;
		j.drawStringAtPoint("Hello, world!", 10@10, Font("Lucida Grande", 24), Color.black);
	});
)

j.plot;
j.write("~/Desktop/hello.png");
j.free;
::

METHOD::drawStringAtPoint
renders *correctly* a String inside an Image :) code::// to fix to have a compliant interface::
code::
(
	var width, height, tgHeight, ratio, str, font, color, strb, targetWidth=400, shadowColor, run = true;
	shadowColor = Color.black;

	color = Color.gray(0.8);
	str = "I Love Pixels";
	font = Font("Monaco", 10);
	strb = str.bounds(font);
	width = strb.width;
	height = strb.height;
	ratio = height / width;
	i = Image(width@(height));
	i.draw({|bb|
		Pen.smoothing_(false);
		i.drawStringAtPoint(str, 0@0, font, color);
	});
	i.interpolation_(\none);
	tgHeight = targetWidth * ratio;
	w = Window.new("", Rect(400,400, 450, 150)).drawHook_({
		Pen.setShadow(2@2, 0.4, color:Color.red);
		i.drawInRect(Rect(5,5,targetWidth, tgHeight));
	});

	w.view.background_(Color.white);
	w.onClose_({run = false; i.free;});
	w.front;
)
::

METHOD::drawAtPoint
render the image or a portion of it in the current graphic context.
code::
(
	var operation='sourceOver', fraction=1.0, i, w;

	i = Image.new(
	//	"http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	//	SCDoc.helpSourceDir +/+ "images/duck_alpha.png"
		SCDoc.helpSourceDir +/+ "images/Swamp.png"
	);

	w = Window.new("Image", Rect(120, 400, 360, 180)).front;

	Slider.new(w, Rect(10, 150, 150, 16))
		.value_(1.0)
		.action_({ arg sl;
			fraction = sl.value;
			w.refresh;
		});

	PopUpMenu.new(w, Rect(170, 150, 100, 16))
		.items_( Image.compositingOperations.collect({ arg i; i.asString }) )
		.value_(2)
		.action_({ arg pm;
			operation = Image.compositingOperations.at(pm.value);
			w.refresh;
		});

	w.onClose_({ i.free }); // free the image when the window is closed

	w.drawHook_({

		i.drawAtPoint(10@10, nil, operation, fraction);

	});
)
::

ARGUMENT::point
the link::Classes/Point:: where to draw it

ARGUMENT::fromRect
the portion of the Image to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::drawInRect
render the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
(
	i = Image.new(
		// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
		SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
	);

	w = Window.new("Image", Rect(120, 400, 360, 180)).front;
	w.onClose_({ i.free }); // free the image when the window is closed
	w.drawHook_({
		i.drawInRect(Rect(10,10,50,50), Rect(10,10,50,50), 2, 1.0); // only a section
	});
)
::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the Image to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::tileInRect
tile the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
(
i = Image.new(
	// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
);

w = Window.new("Image", Rect(120, 400, 360, 180)).front;
w.onClose_({ i.free }); // free the image when the window is closed
w.drawFunc_({
	i.tileInRect(w.view.bounds, nil, 2, 1.0); // all image contents
});
)
::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the Image to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.
NOTE::
Compositing operations are currently disabled for tileInRect
::

ARGUMENT::opacity
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

SUBSECTION::Instance Methods / accessing and setting pixels

METHOD::setPixel
fill a pixel located at x @ y.
code::
i = Image.color(60, 60, Color.blue(0.1,0.1));
w = i.plot;
i.setPixel(Image.colorToPixel(Color.new(1,0,0,1)), 0, 0); // setting red
w.refresh;
("pixel at 0 @ 0:"+Image.pixelToColor(i.getPixel(0,0)).asArray).postln;
i.free;
::

ARGUMENT::rgbaInteger
an 32 bit link::Classes/Integer:: containing color information packed as 8bit RGBA
ARGUMENT::x
the x position of the pixel in the image
ARGUMENT::y
the y position of the pixel in the image

METHOD::getPixel
retrieve the pixel value at x @ y as a RGBA integer
code::
// A simple example on how to manipulate pixels with Image
(
b = Int32Array[
	Image.colorToPixel(Color.new255(255,0,0,255)), // red
	Image.colorToPixel(Color.new255(0,255,0,255)), // green
	Image.colorToPixel(Color.new255(0,0,255,255)), // blue
	Image.colorToPixel(Color.new255(255,0,255,255)) // purple
];
)

Image.pixelToColor(b[0]).red; // 1.0 see Color -red
Image.pixelToColor(b[0]).green; // 0.0 see Color -green
Image.pixelToColor(b[0]).blue; // 0.0 see Color -blue
Image.pixelToColor(b[0]).alpha; // 1.0 see Color -alpha

a = Image.new(b.size@1).pixels_(b).interpolation_(\fast);
a.plot;


// Set + Get
a.setPixel(Image.colorToPixel(Color.new255(255, 0, 255, 128)) /* create an Integer from 0-255 integer rgba value */, 0, 0).plot;
p = a.getPixel(0,0);

Image.pixelToColor(p).red;// 1.0
Image.pixelToColor(p).green; // 0.0
Image.pixelToColor(p).blue; // 1.0
Image.pixelToColor(p).alpha; // ~0.5

// now another important example
a.setPixel(Image.colorToPixel(Color.new255(255, 0, 255, 0)), 1, 0).plot; // clear color -> alpha is 0
p = a.getPixel(1,0);

Image.pixelToColor(p).red; // you expect 1.0 but you get 0.0 ??? Why = because Image uses premultiplied color component value internally
// meaning all Red, Green, and Blue component are premultiplied by the alpha
// if alpha is 0 you get 0 back for all components.

Image.pixelToColor(p).green; // 0
Image.pixelToColor(p).blue; // 0
Image.pixelToColor(p).alpha; // 0

p = a.getColor(1,0); // more explicit - but same here
::

METHOD::setColor
fill the pixel located at x @ y with the specified strong::color::.

METHOD::getColor
retrieve the pixel value at x @ y as a link::Classes/Color::.

METHOD::pixels
retrieve or set all the pixels of the receiver.
NOTE::
Careful: the returned Array is a link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer. See link::#*colorToPixel:: and link::#*pixelToColor::.
::

ARGUMENT::array
an link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer

METHOD::loadPixels
load all the pixels of the receiver in an array. it is better and faster to call this function instead of link::#-pixels:: if you plan to retrieve frequently the pixel data (since it won't allocate a new array everytime !)
code::
// exec one line at a time
(
i = Image.new(
	// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
);
)

// first grab the pixels
p = i.pixels;

// do some mods - here invert
// i.invert; // not implemented yet

// reload directly in my array - do not need to call i.pixels again
i.loadPixels(p);
i.free;
p;
::

ARGUMENT::array
the array that will be filled. Should be an link::Classes/Int32Array:: of size receiver.width * receiver.height.

ARGUMENT::region
the targeted rectangular region. (nil by default, meaning full size)

ARGUMENT::start
the start index of the array.

METHOD::setPixels
set the pixels in a specific portion of the receiver.
code::

(
i = Image.new(20@20);
i.pixels_(
	Int32Array.fill(i.width * i.height, {
		Image.colorToPixel(Color.new255(255.rand,127.rand,255.rand,255))
	})
);
//i.interpolation_(\fast); // uncomment to see the difference
w = i.plot(freeOnClose:true);
i.pixels.postln;
)

(
i = Image.color(50@50, Color.white);
i.setPixels(
	Int32Array.fill(20*20,{Image.colorToPixel(Color.new255(255.rand,127.rand,255.rand,255))}),
	Rect(10,10,20,20)
);
i.interpolation_(\fast); // uncomment to see the difference
w = i.plot(freeOnClose:true);
i.pixels.postln;
)
::

ARGUMENT::array
an link::Classes/Int32Array:: of size strong::rect::.width * strong::rect::.height containing all pixel values as 32bit Integer

ARGUMENT::region
a rectangle defining the portion to update in the receiver. By default strong::rect:: is nil, meaning full image size.

ARGUMENT::start
the array start index.


METHOD::pixelRatio
Get/set pixel ratio of the image.

This does NOT affect the content of the image, only how it is interpreted when it is drawn onto a View or another Image.
For example, in a high DPI context, the pixel ratio of a View might be 2. When drawing an image with a pixelRatio of 1, each pixel of the image will fill a 2x2 area of the View. If both the Image and the View had a pixel ratio of 2, each pixel would be 1:1 with pixels in the View.

By default, the pixelRatio of all Images is 1 - emphasis::this ensures that an image will look the same when drawn on a normal or a high DPI view::. Setting a custom (!= 1) pixelRatio should generally only be done to draw specially rendered high DPI images to a View that is known to be high DPI.

Note that when drawing to an Image using link::Classes/Pen::, pixelRatio is accounted for - so, a line of width 1 will have a true width of 1px for an image where code::image.pixelRatio==1::, and a true width of 2px where code::image.pixelRatio==2::.


class:: Impulse
summary:: Impulse oscillator.
related:: Classes/Blip
categories::  UGens>Generators>Deterministic


Description::
Outputs non-bandlimited single sample impulses.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz. strong::freq:: may be negative.

argument::phase
Phase offset in cycles (0..1). Staying in this range offers a slight efficiency
advantage, though phase offsets outside this range are supported and wrapped
internally.

argument::mul
The output will be multiplied by this value.

argument::add
This value will be added to the output.

Discussion::
code::Impulse:: will output a code::1.0:: on the first sample (assuming no
phase offset).

If the initial code::freq = 0::, a single impulse is output on first sample,
followed by silence until the frequency changes.

Supported rate combinations for code::(freq, phase):: are
code::(a,a)::, code::(a,k)::, code::(a,i)::,
code::(k,k)::, code::(k,i)::,
code::(i,k)::, code::(i,i)::.

code::Impulse:: is based on a wrapping phasor: phase advances on
each frame and if the phase goes out of range and is wrapped in that frame,
an impulse is output.

Internally, the strong::phase:: offset value is applied
and wrapped into range emphasis::before:: applying the phase increment
(which is determined by the strong::freq::). After this phase increment,
the trigger condition is checked. Therefore, it is the phase increment (freq)
that triggers an impulse, emphasis::not:: the phase offset.

For example, if you wanted to create an impulse train by setting
code::freq: 0:: and modulating the strong::phase:: offset directly,
code::Impulse:: would not support that.
However, a you could generate an impulse train by phase modulation using the
strong::rate:: parameter of a link::Classes/Phasor::, like this:
code::
({
	var f = 1000;
	HPZ1.ar(HPZ1.ar(
		Phasor.ar(rate: f * SampleDur.ir)
	)) > 1e-5
}.plot(0.005))
::


Examples::

code::
{ Impulse.ar(800, 0.0, 0.5, 0) }.play

{ Impulse.ar(XLine.kr(800,100,5), 0.0,  0.5, 0) }.play
::

modulate phase:
code::
{ Impulse.ar(4, [0, MouseX.kr(0, 1)], 0.2) }.play;
::

an Impulse with frequency 0 returns a single impulse:
code::
SynthDef(\imp, { OffsetOut.ar(0, Impulse.ar(0)); FreeSelf.kr(Impulse.kr(0)); }).add;
fork { (1 / (1..60).scramble).do { |dt| Synth.grain(\imp);  dt.wait } };
::


class:: In
summary:: Read a signal from a bus.
related:: Classes/InFeedback, Classes/LagIn, Classes/SoundIn
categories::  UGens>InOut


Description::

In.ar and In.kr read signals from audio and control buses, respectively. (See the link::Tutorials/Getting-Started/11-Busses##Busses:: chapter of the link::Tutorials/Getting-Started/00-Getting-Started-With-SC##Getting Started:: tutorial series for details on buses.)

In.ar and In.kr behave slightly differently with respect to signals left on the bus in the previous calculation cycle.

In.ar can access audio signals that were generated in the current calculation cycle by Synth nodes located earlier in the node tree (see link::Guides/Order-of-execution::). It does not read signals left on an audio bus from the previous calculation cycle. If synth A reads from audio bus 0 and synth B writes to audio bus 0, and synth A is earlier than synth B, In.ar in synth A will read 0's (silence). This is to prevent accidental feedback. link::Classes/InFeedback:: supports audio signal feedback.

In.kr is for control buses. Control signals may be generated by Synth nodes within the server, or they may be set by the client and expected to hold steady. Therefore, In.kr does not distinguish between "new" and "old" data: it will always read the current value on the bus, whether it was generated earlier in this calculation cycle, left over from the last one, or set by the client.

Note that using the link::Classes/Bus:: class to allocate a multichannel bus simply
reserves a series of adjacent bus indices with the link::Classes/Server:: object's bus
allocators. code::abus.index:: simply returns the first of those indices.

When using a Bus with an In or  link::Classes/Out::  UGen there is nothing to
stop you from reading to or writing from a larger range, or from
hardcoding to a bus that has been allocated. You are responsible for
making sure that the number of channels match and that there are no
conflicts. See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more
information on buses and how they are used.


The hardware input busses begin just after the hardware output busses and
can be read from using In.ar (See link::Reference/Server-Architecture:: for more
details). The number of hardware input and output busses can vary
depending on your Server's options. For a convenient wrapper class which
deals with this issue see  link::Classes/SoundIn:: .


classmethods::

method::ar, kr

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.


Examples::

read from an audio bus:
code::
s.boot;

(
SynthDef("help-PinkNoise", { arg out=0;
	Out.ar(out, PinkNoise.ar(0.1))
}).add;

SynthDef("help-In", { arg out=0, in=0;
	var input;
		input = In.ar(in, 1);
		Out.ar(out, input);

}).add;
)

//play noise on the right channel
x = Synth("help-PinkNoise", [\out, 1]);

//read the input and play it out on the left channel
Synth.after(x, "help-In", [\out, 0, \in, 1]);
::

read from a  control bus:
code::
(
SynthDef("help-InKr",{ arg out=0, in=0;
	Out.ar(out,
		SinOsc.ar(In.kr(in, 1), 0, 0.1)
	)
}).add;
SynthDef("help-lfo", { arg out=0;
	Out.kr(out, LFNoise1.kr(0.3, 200, 800))
}).add;
)


b = Bus.control(s,1);
b.set(800);

Synth("help-InKr",[\in, b.index]);
b.set(400);
b.set(300);
Synth("help-lfo", [\out, b.index]);
::

read control data from a synth later in the node order:
code::
(
SynthDef("help-Infreq", { arg bus;
	Out.ar(0, FSinOsc.ar(In.kr(bus), 0, 0.5));
}).add;

SynthDef("help-Outfreq", { arg freq = 400, bus;
	Out.kr(bus, SinOsc.kr(1, 0, freq/40, freq));
}).add;

b = Bus.control(s,1);
)

// add the first control Synth at the tail of the default server; no audio yet
x = Synth.tail(s, "help-Outfreq", [\bus, b.index]);

// add the sound producing Synth BEFORE it; It receives x's data from the previous cycle
y = Synth.before(x, "help-Infreq", [\bus, b.index]);

// add another control Synth before y, at the head of the server
// It now overwrites x's cycle old data before y receives it
z = Synth.head(s, "help-Outfreq", [\bus, b.index, \freq, 800]);

// get another bus
c = Bus.control(s, 1);

// now y receives x's data even though z is still there
y.set(\bus, c.index); x.set(\bus, c.index);	// WARNING! gets loud!

x.free; y.free; z.free;
::



TITLE:: InBus
summary::Return a range of channels from a bus, irrespective of node order
categories::UGens>InOut
related:: Classes/In, Classes/XIn, Classes/InFeedback, Classes/XInFeedback

DESCRIPTION::InBus provides a simple interface to the signal on a bus, crossfading between adjacent values.
code::
(
b = Bus.control(s, 9); // nine channel control rate
b.setn([244, 737, 20, 271, 382, 172, 4, 2399, 251]);
{
	var index = MouseX.kr(0, 30);
	Blip.ar(InBus.ar(b, 2, index, \wrap)) * 0.1
}.play;
)
::



CLASSMETHODS::


METHOD:: ar, kr
Return a new instance with the respective rate. If the bus rate doesn't match the signal is converted. Multi channel arguments expand.

ARGUMENT:: bus
An instance of link::Classes/Bus::

ARGUMENT:: numChannels
Number of output channels

ARGUMENT:: offset
Offset to the starting index in the bus.

ARGUMENT:: clip
If clip is set to 'wrap', the indices into the bus will not be clipped to the last bus channel, but will wrap around.

returns:: A UGen output, usually an array of UGens or, if the arguments are arrays, an array of arrays.


INSTANCEMETHODS::


EXAMPLES::

code::
(
s.waitForBoot({
	b = Bus.control(s, 3);
	b.setn([1, 10, 100]);
})
)
{ InBus.kr(b, 1, 0).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 1, 1).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 1, 2).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 1, 3).poll(2, "val"); 0.0 }.play;


{ InBus.kr(b, 2, 0).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 3, 0).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 4, 0).poll(2, "val"); 0.0 }.play;

{ InBus.kr(b, 3, 5).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 3, 5, \wrap).poll(2, "val"); 0.0 }.play;

 InBus.kr(b, 2, [1, 3, 4]); // multi channel expansion

{ InBus.kr(b, 1, MouseX.kr(0, 10).round.poll(2, "index")).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 2, MouseX.kr(0, 10).round.poll(2, "index")).postln.poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 3, MouseX.kr(0, 10).round.poll(2, "index")).postln.poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 4, MouseX.kr(0, 10).round.poll(2, "index")).postln.poll(2, "val"); 0.0 }.play;

{ InBus.kr(b, 1, MouseX.kr(0, 10).round.poll(2, "index"), \wrap).poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 2, MouseX.kr(0, 10).round.poll(2, "index"), \wrap).postln.poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 3, MouseX.kr(0, 10).round.poll(2, "index"), \wrap).postln.poll(2, "val"); 0.0 }.play;
{ InBus.kr(b, 4, MouseX.kr(0, 10).round.poll(2, "index"), \wrap).postln.poll(2, "val"); 0.0 }.play;

::


class:: InFeedback
summary:: Read signal from a bus with a current or one cycle old timestamp.
related:: Classes/In, Classes/LagIn, Classes/LocalIn
categories::  UGens>InOut


Description::

When the various output UGens ( link::Classes/Out:: ,
link::Classes/OffsetOut:: ,  link::Classes/XOut:: ) write data to a bus,
they mix it with any data from the current cycle, but overwrite any data
from the previous cycle. ( link::Classes/ReplaceOut::  overwrites all
data regardless.) Thus depending on node order and what synths are
writing to the bus, the data on a given bus may be from the current cycle
or be one cycle old at the time of reading. In.ar checks the timestamp of
any data it reads in and zeros any data from the previous cycle (for use
within that node; the data remains on the bus). This is fine for audio
data, as it avoids feedback, but for control data it is useful to be able
to read data from any place in the node order. For this reason In.kr also
reads data that is older than the current cycle.


In some cases we might also want to read audio from a node later in the
current node order. This is the purpose of InFeedback. The delay
introduced by this is one block size, which equals about 0.0014 sec at
the default block size and sample rate. (See the resonator example below
to see the implications of this.)


The variably mixing and overwriting behaviour of the output UGens can
make order of execution crucial. (No pun intended.) For example with a
node order like the following the InFeedback UGen in Synth 2 will only
receive data from Synth 1 (→ = write out; ← = read in):
list::
## Synth1 → busA (this synth overwrites the output of Synth3 before it reaches Synth2)
## Synth2 (with InFeedback) ← busA
## Synth3 → busA
::

If Synth1 were moved after Synth2 then Synth2's InFeedback would receive
a mix of the output from Synth1 and Synth3. This would also be true if
Synth2 came after Synth1 and Synth3. In both cases data from Synth1 and
Synth3 would have the same time stamp (either current or from the
previous cycle), so nothing would be overwritten.


Because of this it is often useful to allocate a separate bus for
feedback. With the following arrangement Synth2 will receive data from
Synth3 regardless of Synth1's position in the node order:

list::
## Synth1 → busA
## Synth2 (with InFeedback) ← busB
## Synth3 → busB + busA
::
The second example below demonstrates this issue.


classmethods::

method::ar

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. The
default is 1. You cannot modulate this number by assigning it to
an argument in a SynthDef.


Examples::
audio feedback modulation:
code::
(
SynthDef("help-InFeedback", { arg out=0, in=0;
	var input, sound;
		input = InFeedback.ar(in, 1);
		sound = SinOsc.ar(input * 1300 + 300, 0, 0.4);
		Out.ar(out, sound);

}).play;
)
::
this shows how a node can read audio from a bus that is being written to by a synth following it:
code::
(
SynthDef("help-InFeedback", { arg out=0, in=0;
	Out.ar(out,
		InFeedback.ar(in, 1)
	);
}).add;
SynthDef("help-SinOsc", { arg out=0, freq=440;
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).add;
)

x = Bus.audio(s, 1);

// read from bus n play to bus 0 (silent)
a = Synth("help-InFeedback",[\in, x.index, \out, 0]);

// now play a synth after this one, playing to bus x
b = Synth.after(a, "help-SinOsc", [\out, x.index]);

// add another synth before a which also writes to bus x
// now you can't hear b, as its data is one cycle old, and is overwritten by c
c = Synth.before(a, "help-SinOsc", [\out, x.index, \freq, 800]);

// free c and you can hear b again
c.free;
x.free;

a.free; b.free;
::

The example below implements a resonator. Note that you must subtract the blockSize in order for the tuning to be correct. See link::Classes/LocalIn:: for an equivalent example.
code::
(
var play, imp, initial;
SynthDef("testRes", {

play = InFeedback.ar(10, 1); // 10 is feedback channel
imp = Impulse.ar(1);

// feedback
OffsetOut.ar(10, DelayC.ar(imp + (play * 0.995), 1,
	440.reciprocal - ControlRate.ir.reciprocal)); // subtract block size

OffsetOut.ar(0, play);

}).play(s);

// Compare with this for tuning
{ SinOsc.ar(440, 0, 0.2) }.play(s, 1);
)
::



class:: InRange
summary:: Tests if a signal is within a given range.
related:: Classes/InRect, Classes/Schmidt
categories::  UGens>Maths


Description::

If  code::in::  is ≥  code::lo::  and ≤
code::hi::  output 1.0, otherwise output 0.0. Output is
initially zero.


classmethods::

method::ar, kr, ir

argument::in

Signal to be tested.


argument::lo

Low threshold.


argument::hi

High threshold.


Examples::

code::

s.boot;

{ InRange.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15)}.scope; // see the trigger

{ InRange.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15) * BrownNoise.ar(0.1)}.scope; // trigger noise Burst

::



class:: InRect
summary:: Test if a point is within a given rectangle.
related:: Classes/InRange, Classes/Schmidt
categories::  UGens>Maths


Description::
A pair of signals x and y are treated as a point (x,y) in 2-D; if they fall within the bounds of the rectangle, then this UGen outputs a one; else it outputs zero.


classmethods::
method::ar, kr

argument::x
X component signal

argument::y
Y component signal

argument::rect
A link::Classes/Rect:: which defines the rectangular region to monitor; note that Rects are in screen co-ordinates, so the top is smaller than the bottom. The Rect is created once and cannot be modulated.

examples::
code::
//we'll hear the sawtooth wave when the two sine oscillators are both in the region x = 0.0 to 0.5, y = 0.5 to 1.0
{InRect.ar(SinOsc.ar(1),SinOsc.ar(1.3),Rect(0,0.5,0.5,0.5))*LFSaw.ar(44,0,0.1) }.play

//stereo effect
{(InRect.ar(LFNoise0.ar([140,141]),LFNoise0.ar(143),Rect(0,0,0.5,1)).lag(0.1))*LFSaw.ar(SinOsc.ar(10,0,5,400),0,0.1) }.play


//for the Rect, create as left, 'top', width, height;
r= Rect(0,0,1,1)

r.left
r.right
r.top
r.bottom
::



class:: InTrig
summary:: Generate a trigger anytime a bus is set.
categories::  UGens>InOut, UGens>Triggers


Description::

Any time the bus is "touched", ie. has its value set (using "/c_set"
etc.), a single impulse trigger will be generated. Its amplitude is the
value that the bus was set to.

If the bus is set link::Classes/Bus#Synchronous Control Bus Methods#synchronously:: no trigger will be generated.


classmethods::

method::kr

argument::bus
The index of the bus to read in from.

argument::numChannels
The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.


Examples::

code::
s = Server.local;
b = Bus.control(s,1);

SynthDef("help-InTrig",{arg out=0,busnum=0;
	var inTrig;
	inTrig = InTrig.kr( busnum );
	Out.ar(out,
		EnvGen.kr(Env.perc,gate: inTrig,levelScale: inTrig ) * SinOsc.ar
	)
}).play(s,[\out, 0, \busnum, b.index]);


b.set(1.0);

b.value = 1.0;

b.value = 0.2;

b.value = 0.1;
::

compare with link::Classes/In:: example.



class:: Index
summary:: Index into a table with a signal
related:: Classes/WrapIndex, Classes/Shaper
categories::  UGens>Buffer

Description::
Index into a table with a signal.
The input signal value is truncated to an integer value and used as an
index into the table. Out-of-range index values are clipped to the valid
range.

classmethods::

method::ar, kr

argument::bufnum
Index of the buffer.

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.


Examples::
code::
// indexing into a fixed table
(
{
	SinOsc.ar(
		Index.kr(
			LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]),
			LFSaw.kr(2.0).range(0, 7)
		),
		0,
		0.5
	)
}.play;
)

// with mouse control
(
{
	SinOsc.ar(
		Index.kr(
			LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]),
			MouseX.kr(0, 7)
		),
		0,
		0.5
	)
}.play;
)

(
// indexing into a changeable table
s = Server.local;
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_Index, { |out = 0, bufnum = 0|
	Out.ar(out,
		SinOsc.ar(
			Index.kr(
				bufnum,
				LFSaw.kr(2).range(0, 7)
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b]);
)

b.setn(*[200, 300, 400, 500, 600, 800].scramble.postln - 30);


(
SynthDef(\help_Index, { |out=0, bufnum=0|
	Out.ar(out,
		SinOsc.ar(
			Index.kr(
				bufnum,
				MouseX.kr(0, BufFrames.ir(i_bufnum))
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b]);
)

b.free;
::



class:: IndexInBetween
summary:: Finds the (lowest) point in the Buffer at which the input signal lies in-between the two values
categories:: UGens>Buffer
related:: Classes/Index, Classes/IndexL, Classes/SequenceableCollection#-indexInBetween

description::
Finds the (lowest) point in the link::Classes/Buffer:: at which the input signal lies in-between the two values, and returns the index. The fractional part of the index is suitable for linearly interpolating between the buffer slot values.

For example, if the Buffer contains [3, 21, 25, 26] and the input has the value 22, then the output will be 1.25, because the value 22 is in-between the values stored in indices 1 and 2 and in fact is one-quarter of the way along the interval between them.

IndexInBetween is the complement of link::Classes/IndexL::.

classmethods::

method:: ar, kr
argument:: bufnum
index of the buffer.
argument:: in
the input signal.

examples::
code::
(
// autotune.
{
	var index, in, autotuned, f0, fdiff;
	var scale = ([0, 1, 3, 4, 7, 11, 12] + 70).midicps;
	var buffer = scale.as(LocalBuf);
	in = Pulse.ar(MouseX.kr(scale.minItem, scale.maxItem)) * 0.1;
	f0 = Pitch.kr(in).at(0);
	index = IndexInBetween.kr(buffer, f0);
	fdiff = index.frac * (Index.kr(buffer, index + 1) - Index.kr(buffer, index));
	autotuned = PitchShift.ar(in, 0.1, 1 - (fdiff / f0), 0.01, 0.01);
	RLPF.ar(autotuned, [2000, 5000], 0.3)
}.play;
)

b.free;


// basic test.
(
{
	var index, f0, f1, f3;
	var buffer = [ 200, 210, 400, 430, 600, 800 ].as(LocalBuf);
	f0 = MouseX.kr(200, 900);
	index = IndexInBetween.kr(buffer, f0);
	f1 = IndexL.kr(buffer, index);
	SinOsc.ar([f0, f1]) * 0.1

}.play;
)



// One way to map across from an arbitrary piecewise curve, onto another:
// We use IndexInBetween to "unmap" your input into integer slots,
// and then use IndexL to do the reverse, to "map" onto your other distribution.
// This example maps a sort-of-exponential curve onto a sort-of-sinusoidal curve:

~from = [1, 2, 4, 8, 16];
~to = [0, 1, 0, -1, 0];
(
x = {
	IndexL.kr(~to.as(LocalBuf), IndexInBetween.kr(~from.as(LocalBuf),MouseX.kr(~from.first, ~from.last).poll).poll).poll
}.play
)
::


class:: IndexL
summary:: Index into a table with a signal, linear interpolated
categories:: UGens>Buffer
related:: Classes/Index, Classes/IndexInBetween

description::
The input signal value is used as an index into the table, with linear interpolation.
Out of range index values are clipped to the valid range.

classmethods::
method:: ar, kr
argument:: bufnum
index of the buffer.
argument:: in
the input signal.

examples::
code::
// indexing into a fixed table
(
{
	SinOsc.ar(
		IndexL.kr(
			LocalBuf.newFrom([200, 300, 400, 500, 600, 800].scramble),
			LFSaw.kr(2.0).range(0, 7)
		),
		0,
		0.5
	)
}.play;
)

// with mouse control
(
{
	SinOsc.ar(
		IndexL.kr(
			LocalBuf.newFrom([200, 300, 400, 500, 600, 800].scramble),
			MouseX.kr(0, 7)
		),
		0,
		0.5
	)
}.play;
)

(
// indexing into a changeable table
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_index, { |out = 0, bufnum = 0|
	Out.ar(out,
		SinOsc.ar(
			IndexL.kr(
				bufnum,
				LFSaw.kr(2).range(0, BufFrames.kr(bufnum))
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b]);
)

b.setn(*[ 200, 300, 400, 500, 600, 800 ].scramble.postln - 30);


(
SynthDef(\help_index, { |out = 0, bufnum = 0|
	Out.ar(out,
		SinOsc.ar(
			IndexL.kr(
				bufnum,
				MouseX.kr(0, BufFrames.ir(bufnum))
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b]);
)

b.free;
::


class:: InfoUGenBase
summary:: Base class for info ugens
categories:: UGens>Base

description::
This is the superclass for the various info ugens.



CLASS::Int16Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int8Array, Classes/Int32Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream


CLASS::Int32Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int8Array, Classes/Int16Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream


CLASS::Int8Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int16Array, Classes/Int32Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream


class:: Integer
summary:: Integer number
categories:: Math

description::
A 32 bit integer. Integer inherits most of its behaviour from its superclass.

note::
A 32 bit signed integer can represent values in the range -2147483648 to 2147483647. Adding up further returns in a wrapped result, so that and 2147483647+1= -2147483648. For a larger range, one can use link::Classes/Float::, which is 64 bit and supports many (but not all) numerical methods that int does.
::


instancemethods::

subsection:: Iteration

method:: do
Executes strong::function:: for all integers from zero to this minus one.
argument:: function
a link::Classes/Function:: which is passed two arguments, both of which are the same
integer from zero to this minus one. The reason two arguments are passed is for
symmetry with the implementations of do in link::Classes/Collection::.

method:: reverseDo
Executes strong::function:: for all integers from  this minus one to zero.

method:: for
Executes strong::function:: for all integers from this to strong::endval::, inclusive.
argument:: endval
an link::Classes/Integer::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an integer from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: forBy
Executes strong::function:: for all integers from this to strong::endval::, inclusive, stepping each time by strong::stepval::.
argument:: endval
an link::Classes/Integer::.
argument:: stepval
an link::Classes/Integer::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an integer from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: collect
Returns:: an link::Classes/Array:: of this size filled by objects generated from evaluating the strong::function::.

method:: collectAs
Returns:: a link::Classes/Collection:: of strong::class:: of this size filled by objects generated from evaluating the strong::function::.

method:: to
returns:: an link::Classes/Interval:: from this to strong::hi::.

method:: geom
returns:: an array with a geometric series of this size from start.

method:: fib
returns:: an array with a fibonacci series of this size beginning with strong::a:: and strong::b::.

method:: factors
returns:: the prime factors as array.


subsection:: Random Numbers
See also: link::Guides/Randomness::

method:: xrand
argument:: exclude
an link::Classes/Integer::.
returns:: a random value from zero to this, excluding the value exclude.

method:: xrand2
argument:: exclude
an link::Classes/Integer::.
returns:: a random value from this.neg to this, excluding the value exclude.

subsection:: Conversion

method:: asAscii
returns:: a link::Classes/Char:: which has the ASCII value of the receiver.

method:: asDigit
returns:: a link::Classes/Char:: which represents the receiver as an ASCII digit.
discussion:: For example code::5.asDigit:: returns code::$5::.

method:: asBinaryDigits
returns:: an array with the binary digits (integer 0 or 1).

method:: asDigits
returns:: an array with the n-ary digits.
discussion::
See also the complementary method link::Classes/SequenceableCollection#-convertDigits::.
code::
2007.asDigits;
2007.asDigits(2);
::

method:: asBinaryString
returns:: a string with the binary digits (0 or 1).

method:: asHexString
returns:: a string with the hexadecimal digits (integer 0 to F).

method:: asIPString
returns:: a string in IP format.

method:: asStringToBase
returns:: a string with code::width::-rightmost digits in base code::base::.
discussion::
code::
15.asStringToBase(3,5); // returns 00120
::

method:: asUnicode
returns:: the receiver.

method:: degreeToKey
Interpret this as index into a scale with a given number of steps per ocatve.
discussion::
code::
2.degreeToKey([0, 2, 5, 7, 11]);
::

method:: grayCode
Returns:: the gray code for the number.
discussion::
code::
2.grayCode
::

method:: hash
returns:: a hash value.

subsection:: Binary Representation

method:: setBit
set nth bit to zero (bool = false) or one (bool = true)

method::leadingZeroes
code:: { _CLZ } ::

method:: trailingZeroes
code:: { _CTZ } ::

method:: numBits
returns:: number of required bits


subsection:: Properties

method:: even
returns:: true if dividable by 2 with no rest

method:: odd
returns:: true if not dividable by 2 with no rest


subsection:: Powers Of Two

method:: nextPowerOfTwo
returns:: the next power of two greater than or equal to the receiver.
discussion::
code::
13.nextPowerOfTwo.postln;
64.nextPowerOfTwo.postln;
::

method:: isPowerOfTwo
returns:: the whether the receiver is a power of two.
discussion::
code::
13.isPowerOfTwo.postln;
64.isPowerOfTwo.postln;
::


subsection:: Prime Numbers

method:: nthPrime
returns:: the nth prime number. The receiver must be from 0 to 6541.
discussion::
code::
[0,1,2,3,4,5].collect({ arg i; i.nthPrime; }).postln;
::

method:: prevPrime
returns:: the next prime less than or equal to the receiver up to 65521.
discussion::
code::
25.prevPrime.postln;
::

method:: nextPrime
returns:: the next prime less than or equal to the receiver up to 65521.
discussion::
code::
25.nextPrime.postln;
::

method:: isPrime
returns:: whether the receiver is prime.
discussion::
code::
25.isPrime.postln;
13.isPrime.postln;
::

method:: indexOfPrime
returns:: the index of a prime number less than or equal to the receiver up to 65521.
If the receiver is not a prime, the answer is nil.
discussion::
code::
23.indexOfPrime;
25.indexOfPrime;
::


subsection:: Integer Math

method:: *
Multiplication.

method:: +
Addition.

method:: -
Subtraction.

method:: clip
returns::
LIST::
## the receiver if it is between code::lo:: and code::hi::
## code::lo:: if the receiver is less than code::lo::
## code::hi:: if the receiver is greater than code::hi::
::
The result is an Integer only if both code::lo:: and code::hi:: are Integers.
discussion::
code::
4.clip(2,5); // returns 4
0.clip(2,5); // returns 2
7.clip(2,5); // returns 5
::

method:: factorial
returns:: the factorial of the receiver as an integer. This will overflow for numbers code::> 12:: and throw an error. Floating point factorials can be used in such cases (see: link::Classes/SimpleNumber#-factorial::).

discussion::
code::
12.factorial
23.0.factorial // for larger factorials, use floats.
::

method:: fold
Folds in to a value between code::lo:: and code::hi::.
returns:: an Integer between code::lo:: and code::hi::.
discussion::
code::
(0..12).fold(0,3); // returns [ 0, 1, 2, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0 ]
::

method:: log2Ceil
returns:: next larger integer of the base 2 logarithm of the receiver.
discussion::
code::
17.log2; // returns 4.0874628412503
17.log2Ceil; // returns 5
17.log2.ceil.asInteger; // equivalent to the previous line
::

method:: wrap
Wraps in to a value between code::lo:: and code::hi::.
returns:: an Integer between code::lo:: and code::hi::.
discussion::
code::
(0..12).wrap(0,3); // returns [ 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0 ]
::

subsection:: Range Limiting

copymethod:: Float -clip
copymethod:: Float -fold

method:: wrap

Wrap this around [lo, hi] such that it falls in range. Equivalent to (this % (hi - lo + 1)) + lo. Note that this behavior is different from link::Classes/Float#-wrap::.
argument:: lo
The low threshold (inclusive) of wrapping.
argument:: hi
The high threshold (inclusive) of wrapping.

subsection:: Misc

method:: exit
returns:: exits the sclang program and returns the receiver as an exit code to the parent process (e.g. Unix shell).
discussion::
code::
7.exit; // this line stops the interpreter and returns 7 as exit code
::

method:: generate
returns:: calls code::function.value(receiver):: but returns the receiver.
discussion::
code::
f = { arg i; "foo".postln; i*2 }
3.generate(f) // returns 3 but the function f is executed
f.value(3) // returns 6
::

method:: isInteger
returns:: true (the receiver is an integer).

method:: isAlt, isCaps, isCmd, isCtrl, isFun, isHelp, isNumPad, isShift
returns:: a Boolean for whether or not the given key modifier is in effect. For a list of these, see link::Reference/Modifiers::.
discussion::
code::
v = TextView(nil, Rect(800, 100, 400, 300)).front;

v.keyDownAction = { |view, char, modifiers|
    case
    { modifiers.isAlt } { \alt }
	{ modifiers.isCaps } { \caps }
	{ modifiers.isCmd } { \cmd }
	{ modifiers.isCtrl } { \ctrl }
	{ modifiers.isFun } { \fun }
	{ modifiers.isHelp } { \help }
	{ modifiers.isNumPad } { \numpad }
    { modifiers.isShift } { \shift }
    .postln
};
::

method:: pidRunning
returns:: a Boolean for whether or not the specified pid is running.
discussion::
code::
p = "cat".unixCmd;
p.pidRunning; // cat will stay alive
("kill" + p).unixCmd
p.pidRunning;
::

private::archiveAsCompileString


class:: Integrator
summary:: A leaky integrator.
categories::  UGens>Filters>Linear, UGens>Maths


Description::

Integrates an input signal with a leak. The formula implemented is:

code::
out(0) = in(0) + (coef * out(-1))
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Leak coefficient.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ Integrator.ar(LFPulse.ar(300, 0.2, 0.1), MouseX.kr(0.001, 0.999, 1)) }.play

// used as an envelope
{ Integrator.ar(LFPulse.ar(3, 0.2, 0.0004), 0.999, FSinOsc.ar(700), 0) }.play


// scope

{ Integrator.ar(LFPulse.ar(1500 / 4, 0.2, 0.1), MouseX.kr(0.01, 0.999, 1)) }.scope

::


class:: InterplEnv
summary:: envelope specification
related:: Classes/IEnvGen, Classes/Env
categories:: Control, Envelopes

note::Env fully supports all functionality of InterplEnv, InterplXYC, InterplPairs and InterplChord. These are now deprecated and  will be removed in the future.::

description::
An InterplEnv is a specification for a segmented envelope. InterplEnvs can be used both server-side, by an link::Classes/IEnvGen:: within a SynthDef, and clientside, with methods such as at. An InterplEnv can have any number of segments. An InterplEnv can have several shapes for its segments.


subsection::Differences between InterplEnv and Env
InterplEnvs do not have release or loop nodes.  They are of a fixed duration. Mostly, it is meant to be used with IEnvGen, where 'times' are actually an strong::index into the envelope:: shape.

ClassMethods::

private::initClass, new

InstanceMethods::

private::prAsArray


class:: InterplPairs
summary:: envelope specification
related:: Classes/InterplEnv
categories:: Control, Envelopes

description::
Takes an array of [x, y] pairs and a curve value for all break points.
x values can be negative (for use in indexing with negative values or signals).
See link::Classes/InterplEnv:: Help for more info.

Examples::

code::
a = InterplPairs([[0, 1], [1, 2], [2, 0]], \sin);
a.plot;

a = InterplPairs([[-1, 1], [0, 2], [1, 0]], \sin);
a.plot;
a.at(-0.5);
a.at(0.2);
::


class:: InterplXYC
summary:: envelope specification
related:: Classes/InterplEnv
categories:: Control, Envelopes

description::
Takes sets of x, y and curve values and returns a new instance of InterplEnv.
x values can be negative (for use in indexing with negative values or signals).
See link::Classes/InterplEnv:: Help for more info.

Examples::

code::
a = InterplXYC([0, 0, \lin], [1, 2, \sin], [2, 0]);
a.plot;

a = InterplXYC([[-1, 1, \sin], [0, 2, \lin], [1, 0]]);
a.plot;
a.at(-0.5);
a.at(0.2);
::


class::Interpreter
summary:: The interpreter defines a context in which interactive commands are compiled and executed.
categories:: Core>Kernel
related::Guides/How-to-Use-the-Interpreter

description::
The interpreter is an object that handles the translation and execution of code at runtime. It is that what runs any program code and defines a context for it.

code::
(
a = 5 + 7;
this.cmdLine.postln;
)
::

classMethods::

private::new

instanceMethods::

subsection::Accessing

In the interpreter, code::this:: refers to the interpreter itself, e.g.: code::this.postln::

The interpreter defines global variables (code::a:: … code::z::), that can be used for interactive programming. Except these single letter variables ("interpreter variables"), all variables have to be defined by the keyword code::var:: (see: link::Reference/Assignment::, and link::Reference/Scope::).

code::
// typical usage
a = 4;
b = 3;
b = b + a;

// some sound
a = Synth(\default);
g = fork { loop { 0.1.wait; a.set(\freq, 200 + 20.0.rand2.postln) } };
g.stop; a.free;

// an overview of all the variables
this.inspect;
::

note::Use these variables with a bit of extra care – as they are global, they remain in memory and one piece of code may happen to interfere with another one. The variable code::s:: is by convention bound to the default server (link::Classes/Server::) and should not be changed.::



method::clearAll

set the values of the variables code::a:: through code::z:: to nil.

code::
x = 123;
x.postln;
this.clearAll;
x.postln;
::

subsection::Compile & Interpret

method::interpret

Compile and execute a link::Classes/String::.

code::
this.interpret("(123 + 4000).postln");
::

method::interpretPrint

Compile and execute a link::Classes/String::, printing the result.

code::
this.interpretPrint("123 + 4000");
::

method::compile

Compile a String and return a link::Classes/Function::.

code::
(
z = this.compile("(123 + 4000).postln");
z.postln;
z.value;
)
::

method::compileFile

Reads the file at pathName, compiles it and returns a Function.
The file must contain a valid SuperCollider expression, naturally.
This will not compile class definitions, only expressions.

method::executeFile

Reads the file at pathName, compiles it and executes it, returning the result.
The file must contain a valid SuperCollider expression, naturally.
This will not compile class definitions, only expressions.

method::cmdLine

Returns the previously interpreted code.

code::
1 + 2;
this.cmdLine
::

method::codeDump

this interpreter variable can be set to evaluate a function with any successfully compiled code.
see e.g. the class History.

code::
a = [ ]; // store all the code evaluated in a
this.codeDump = { |code| a = a.add(code) };
1 + 3;
f = { "hallo" };
a.postcs;
codeDump = nil; // reset to nil.
::

method::preProcessor

If this is set to a function, all interactively executed code is piped through it before parsing and
interpreting. This is mostly used for developing domain-specific live coding languages that piggyback
off the SuperCollider editing environment.

This function is called by link::Classes/Interpreter#-interpretPrintCmdLine:: with two arguments:
the code string and the interpreter itself.

code::
// silly but simple: understand a Saw for every SinOsc
this.preProcessor = { |code| code.replace("SinOsc", "Saw") };

{ SinOsc.ar(200) * 0.1 }.play;

preProcessor = nil; // reset to nil.
::

method::a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

Global variables ("interpreter variables") for interactive programming (see link::#Accessing::).

method::functionCompileContext

The compiler uses this method as a virtual context in which to compile code.


CLASS::Interval
summary::range of integers
categories:: Math

DESCRIPTION::
An Interval is a range of integers from a starting value to an ending value by some step value.

CLASSMETHODS::

method::new
Create a new Interval.
code::
Interval(10, 30, 4);
10 to: 30; // the message to creates an interval with step 1
::

INSTANCEMETHODS::

method::start
The starting value of the interval.

method::end
The ending value of the interval.

method::step
The step value of the interval.

method::size
Return the number of items in the interval.
code::
Interval(10, 30, 4).size.postln;
::

method::at
Return the indexed item in the interval.
code::
Interval(10, 30, 4).at(3).postln;
::

method::do
Evaluates function for each item in the interval. The function is passed two arguments, the item and an integer index.
code::
Interval(10, 30, 4).do({ arg item, i; item.postln });
::


class:: JITGui
summary:: a superclass for just in time interfaces
categories:: JITLib>GUI, Live Coding

description::
Proxies for synths, tasks and patterns as implemented in JITLib are extremely flexible. Having guis that represent their changeable states makes it easier to understand what is going on, especially when using multiple proxies together. JITGuis follow a special strategy described below.

subsection::See also

list::
## link::Classes/EnvirGui::,
## link::Classes/TdefGui::, link::Classes/TdefAllGui::, ( link::Classes/TaskProxyGui:: )	// TdefGui replaces obsolete TdefEditor
## link::Classes/PdefGui::, link::Classes/PdefAllGui::, ( link::Classes/TaskProxyAllGui:: )	// PdefGui replaces obsolete PdefEditor
## link::Classes/NdefGui::, link::Classes/MonitorGui::, link::Classes/NdefParamGui:: 	// replace NodeProxyEditor, ProxyMonitorGui
## link::Classes/ProxyMixer::
## link::Classes/NdefMixer::
::

ClassMethods::

private::initClass

subsection::Creation

method::new
Create a new JITGui that will be watching an object and displaying its state.

code::
g = JITGui.new(nil, 0);		// make a JITGui
g.object = 123;			    // its object gets shown asCompileString
g.object = (key: \otto); 	// if the object understands .key, key gets shown as name
g.object = Pseq([1, 2, 3], inf);
g.close;
::

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text display, or how many sliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. Can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
A flag whether to make a skipjack. (If the gui is on its own window,
it typically uses one, if the JITGui is part of a larger gui, that gui may take care of updating.)

argument::options
a list of additional information, such as flags about optional buttons. (This is used in some subclasses.)

InstanceMethods::

subsection::Accessing Instance Variables

code::
g.dump;
::

method::object
the object to watch

method::numItems
the number of display items to use, e.g. how many fields for text display, or how many sliders for single-number parameters.

method::parent
a parent view on which the gui is displayed.

method::bounds
the size and position of the JITGui

method::zone
a link::Classes/CompositeView:: inside the parent that holds the JITGui's views.

method::minSize
a JITGuis calculates its own minimum size based on numItems and options.

method::defPos
the default position where the JITGui is shown if it is in its own window.

method::skin
(Appearance)

the GUI skin to use. By default this is code::GUI.skins.jit:: .

method::font
(Appearance)

the font, also taken from JITGui.skin.

method::nameView
(specific in the JITGui class)

displays the object's key or name if available.

method::csView
(specific in the JITGui class)

displays the object's compileString.

method::prevState
(common to all JITGuis)

the last observed state which is kept around for comparison.

method::skipjack
(common to all JITGuis)

the skipjack that watches the object's state so it can be updated.

method::scroller
(common to all JITGuis)

an link::Classes/EZScroller:: used for scrolling which of a list of items is shown. see e.g. link::Classes/TdefGui:: for usage.

method::hasWindow
(common to all JITGuis)

a flag whether the JITGui has made its own window, and thus owns it.

subsection::Instance Methods

method::object
put an object in the gui - if the gui accepts it.

method::accepts
test whether obj is a valid object to show in a JITGui. In strong::JITGui:: itself, all objects are accepted, in the subclasses, strong::obj:: can either be nil or a specific class, such as link::Classes/Tdef::, link::Classes/Pdef::, link::Classes/Ndef::

method::name
set the text of the link::#-nameView:: and the window (if it link::#-hasWindow::)

method::getName
ask the object its name, or return code::'_anon_'::

method::winName
return a suitable name for a window: "JITGui_objname"

method::moveTo
if it has its own window, one can move it to some specific location.

method::close
close its window.

subsection::How JITGuis work

A JITGui watches the state of its object by calling its (the gui's) link::#-getState:: method at appropriate intervals (skipjack.dt). It compares the new state of the object with the previous state stored in link::#-prevState::. When something has changed, only the gui elements concerned are updated.

Compare this with model-view-controller (MVC):
list::
## MVC requires objects to make .changed calls in all the places where state may change, so its depandants will be informed; JITGui does not.
## MVC updates dependants instantly, while JITGui may take longer to update. For guis, very fast changes of settings (e.g. parameter automation) may produce some CPU load; with JITGuis, lazier display limits this worst-case load.
## Only the JITGui knows about its object, so there is no dependancy administration to take care of.
::

subsection::1 - Methods that subclasses should implement

You can write your own subclasses to JITGui very efficiently by implementing appropriate variants of the following methods in your class. For examples of these methods, see link::Classes/TdefGui::, link::Classes/EnvirGui::, link::Classes/NdefGui::.

method::setDefaults
used to calculate the required onscreen size for the jitGui's zone. Should determine zone size based on link::#-numItems:: and options. also, link::#-defPos:: (where to show your jitGui by default) can be set here, and possibly modifications to the skin used.

method::accepts
a test whether strong::obj:: can be shown in the particular kind of JITGui. Subclasses of JITGui are made for special objects, e.g. Pdefs, so they should test whether obj is the right kind.

method::makeViews
create all the views of the jitGui inside the zone.

subsection::2 - For updating the JITGui, overwrite these methods

method::getState
ask the object for all aspects of its current state that will be displayed.

method::checkUpdate
get the object's current state with link::#-prevState::, compare it with prevState, update all gui elements that need to be changed, and store the new state as prevState. This method is called in the skipJack.

subsection::3 - More methods you may want to overwrite if required

method::calcBounds
how to calculate the bounds for the zone in which to display

method::makeWindow
how to make a window when no parent is given

method::makeZone
how to initalize the zone within the parent window or view

method::getName
a method for generating a name for the object.

method::winName
a method for generating a name for the JITGui's window.

method::makeScroller
Some objects may have more elements to display than the gui has slots, e.g. a link::Classes/ProxySpace:: can have more proxies than the mixer has numItems. Then, only link::#-numItems:: elements are shown, and the others can be scrolled to with link::#-scroller:: - an link::Classes/EZScroller:: next to the slot elements. The makeScroller method should knows where in the zone to put the scroller.

Examples::

code::
    // typically, only subclasses of JITGui are used,
	// so here are just some basic usage and layout tests

	// make its own window - defPos, minSize is used
g = JITGui(Ndef(\a));

	// make its own window, specific size
g = JITGui(Ndef(\a), bounds: 390@20);

	// provide full bounds
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 390, 24));

	// extent is 0@0: minSize x, y is used
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 0, 0));
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 0, 50));
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 500, 0));


(	// put a JITGui in an existing window:
w = Window().front;
g = JITGui(Ndef(\a), 0, w, bounds: 300@48);
)

(	// 5 lines high
w = Window().front;
g = JITGui(Ndef(\a), 5, w);
)

(	// recommended: use a FlowLayout.
w = Window().front;
w.addFlowLayout;
EZSlider(w, 300@100, \test, []);
g = JITGui(Ndef(\a), 0, w, bounds: 300@40);
)

// test changing color schemes for JITguis
// this scheme is admittedly ugly but different

GUI.skins.put(\jit, (
	fontSpecs: 		["Inconsolata", 12],
	fontColor: 		Color.white,
	background: 	Color(0.2, 0.85, 0.7, 0.5),
	foreground:		Color.grey(0.1),
	onColor:		Color(0.5, 0, 0.5),
	onColor2:   	Color(0.0, 0.5, 0.5),
	offColor:		Color.grey(0.2, 0.5),
	hiliteColor:	Color.green(1.0, 0.5),
	gap:			0 @ 0,
	margin: 		2@2,
	buttonHeight:	18,
	headHeight: 	24)
);

// make some JITGuis to check
n = NdefGui(Ndef(\a));
Ndef(\a, { SinOsc.ar(\freq.kr(250)) });
Ndef(\a).clear;
n = NdefMixer(s);

TdefAllGui();
Tdef(\a).set(\amp, 0.25);
TdefGui(Tdef(\a), 5);

EnvirGui((a: 123));
::


class:: K2A
summary:: Control to audio rate converter.
related:: Classes/A2K
categories::  UGens>Conversion


Description::

To be able to play a control rate UGen into an audio rate UGen,
sometimes the rate must be converted. K2A converts via linear
interpolation.


classmethods::

method::ar

argument::in
The input signal.

Examples::

code::
{ K2A.ar(WhiteNoise.kr(0.3)) }.scope;


// compare:
(
{
	[
		K2A.ar(WhiteNoise.kr(0.3)),
		WhiteNoise.ar(0.3)
	]
}.scope;
)

(
{
	var freq, blockSize, sampleRate;
	blockSize = s.options.blockSize; // usually 64
	sampleRate = s.sampleRate;
	freq = MouseX.kr(0.1, 40, 1) / blockSize * sampleRate;
	[
		K2A.ar(LFNoise0.kr(freq)),
		LFNoise0.ar(freq)
	] * 0.3
}.scope;
)
::



class:: KeyState
summary:: Respond to the state of a key
related:: Classes/MouseButton, Classes/MouseX, Classes/MouseY
categories::  UGens>User interaction


Description::
Respond to the state of a key.

note::
Note that this UGen does not prevent normal typing. It therefore may be
helpful to select a GUI window rather than an SC document when using
KeyState, as the latter will be altered by any keystrokes.
::

classmethods::

method::kr

argument::keycode
The keycode value of the key to check. This corresponds to the
keycode values passed into the keyDownActions of SCViews. See the
example below.

argument::minval
The value to output when the key is not pressed.

argument::maxval
The value to output  when the key is pressed.

argument::lag
A lag factor.

instancemethods::
private:: signalRange

Examples::

code::
s.boot;

// execute the code below to find out a key's keycode
// the char and keycode of any key you press will be printed in the post window
(
w = Window.new("I catch keystrokes");
w.view.keyDownAction = { arg view, char, modifiers, unicode, keycode;  [char, keycode].postln; };
w.front;
)

// then execute this and then press the 'j' key
(
w.front; // something safe to type on
{ SinOsc.ar(800, 0, KeyState.kr(38, 0, 0.1)) }.play;
)
::



class:: KeyTrack
summary:: Key tracker
categories:: UGens>Analysis>Pitch
related:: Classes/BeatTrack, Classes/Loudness, Classes/MFCC, Classes/Onsets, Classes/Pitch

description::
A (12TET major/minor) key tracker based on a pitch class profile of energy across FFT bins and matching this to templates for major and minor scales in all transpositions. It assumes a 440 Hz concert A reference. Output is 0-11 C major to B major, 12-23 C minor to B minor.

classmethods::

method:: kr

argument:: chain
[fft] Audio input to track. This must have been pre-analysed by a 4096 size FFT. No other FFT sizes are valid except as noted below.

argument:: keydecay
[sk] Number of seconds for the influence of a window on the final key decision to decay by 40dB (to 0.01 its original value).

argument:: chromaleak
[sk] Each frame, the chroma values are set to the previous value multiplied by the chromadecay. 0.0 will start each frame afresh with no memory.

examples::

code::
// The following files are test materials on my machine; you will subsitute your own filenames here
// A major
d = Buffer.read(s,"/Volumes/data/stevebeattrack/samples/100.wav");
// F major; hard to track!
d = Buffer.read(s,"/Volumes/data/stevebeattrack/samples/115.wav");

// straight forward since no transients; training set from MIREX2006
// 01 = A major
// 57 = b minor
// 78 e minor
// 08 Bb major

d = Buffer.read(s, "/Users/nickcollins/Desktop/ML/training_wav/78.wav")

(
{
	var in, fft, resample;
	var key, transientdetection;

	in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

	// With standard hop of half FFT size = 2048 samples
	fft = FFT(LocalBuf(4096), in);  // for sampling rates 44100 and 48000
	fft = FFT(LocalBuf(8192), in);   // for sampling rates 88200 and 96000

	key = KeyTrack.kr(fft, 2.0, 0.5);

	key.poll;

	Pan2.ar(in)
}.play
)
::



code::
// alternating major and minor chords as a test
(
{
	var in, fft, resample;
	var key, transientdetection;

	in = Mix(SinOsc.ar((60 + [0, MouseX.kr(3, 4).round(1), 7]).midicps, 0, 0.1));

	// major dom 7 and minor 7; major keys preferred here
	//in = Mix(SinOsc.ar((60 + (MouseY.kr(0, 11).round(1.0)) + [0, MouseX.kr(3, 4).round(1), 7, 10]).midicps, 0, 0.1));

	fft = FFT(LocalBuf(4096), in);  // for sampling rates 44100 and 48000

	key = KeyTrack.kr(fft);

	key.poll;

	Pan2.ar(in)
}.play
)
::



code::
// Nice to hear what KeyTrack thinks:

d = Buffer.read(s, "/Users/nickcollins/Desktop/ML/training_wav/78.wav")

(
{
	var in, fft, resample, chord, rootnote, sympath;
	var key, transientdetection;

	in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

	fft = FFT(LocalBuf(4096), in);  // for sampling rates 44100 and 48000

	key = KeyTrack.kr(fft, 2.0, 0.5);
	key.poll;
	key = Median.kr(101, key); // Remove outlier wibbles

	chord = if(key < 12, #[0, 4, 7], #[0, 3, 7]);
	rootnote = if(key < 12, key, key-12) + 60;

	sympath = SinOsc.ar((rootnote + chord).midicps, 0, 0.4).mean;

	Pan2.ar(in, -0.5) + Pan2.ar(sympath, 0.5)
}.play
)
::



code::

/*
Research Notes:
See the MIREX2006 audio key tracking competition and Emilia Gomez's PhD thesis, Tonal Description of Music Audio Signals

The following code was used to create the datasets for the UGen, and would be the basis of extensions

Need one set of bin data for 44100 and one for 48000

KeyTrack calculations, need to make arrays of FFT bins and weights for each chromatic tone.
greater resolution, 4096 FFT, avoid lower octaves, too messy there

60*6*2 output arrays
*/

(
var fftN, fftBins, binsize;
var midinotes;
var sr;
var wtlist, binlist;

sr = 48000; //44100;

fftN = 4096;
fftBins = fftN.div(2);
binsize = sr / fftN;

midinotes = (33..92); // 60 notes, 55 Hz up to 1661.2187903198 Hz

wtlist = List[];
binlist = List[];

// for each note have six harmonic locations
midinotes.do{ |note|
	var freq, whichbin, lowerbin, prop;

	freq = note.midicps;

	6.do{|j|
		var partialfreq, partialamp;

		partialamp = 1.0 / (j + 1);
		partialfreq = freq * (j + 1);

		whichbin = partialfreq / binsize;
		lowerbin = whichbin.asInteger;
		prop = 1.0 - (whichbin - lowerbin);

		binlist.add(lowerbin).add(lowerbin + 1);
		wtlist.add(prop * partialamp).add((1.0 - prop) * partialamp);

	};

};


Post << (binlist) << nl<< nl;

Post << (wtlist) << nl<< nl;

binlist.size.postln;
wtlist.size.postln;
)
::


class:: Klang
summary:: Sine oscillator bank
related:: Classes/Klank, Classes/DynKlang
categories:: UGens>Generators>Deterministic

Description::
Klang is a bank of fixed frequency sine oscillators. Klang is more
efficient than creating individual oscillators but offers less
flexibility.


classmethods::

method::ar

argument::specificationsArrayRef
A link::Classes/Ref:: to an link::Classes/Array:: of three Arrays:

definitionlist::
## frequencies: || An Array of oscillator frequencies.
## amplitudes: || an Array of oscillator amplitudes, or nil. If nil, then amplitudes default to 1.0.
## phases: || an Array of initial phases, or nil. If nil, then phases default to 0.0.
::

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

discussion::
The parameters in code::specificationsArrayRef:: can't be changed after it has been started.
For a modulatable but less efficient version, see link::Classes/DynKlang::.


Examples::

code::
play({ Klang.ar(`[ [800, 1000, 1200], [0.3, 0.3, 0.3], [pi, pi, pi]], 1, 0) * 0.4});

play({ Klang.ar(`[ [800, 1000, 1200], nil, nil], 1, 0) * 0.25});

play({ Klang.ar(`[ Array.rand(12, 600.0, 1000.0), nil, nil ], 1, 0) * 0.05 });



(
{
loop({
	play({
		Pan2.ar(Klang.ar(`[ Array.rand(12, 200.0, 2000.0), nil, nil ], 1, 0), 1.0.rand)
			 * EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: Done.freeSelf);
	});
	2.wait;
})
}.fork;
)

// Multichannel expansion:

(
{
loop({
	play({
		var nPartials = 12, nChans = 5, n = nPartials * nChans;
		Splay.ar(Klang.ar(`[ { { rrand(200.0, 2000.0) } ! nPartials } ! nChans, nil, nil ], 1, 0))
			 * EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: Done.freeSelf);
	});
	2.wait;
})
}.fork;
)
::





class:: Klank
summary:: Bank of resonators
related:: Classes/DynKlank, Classes/Klang
categories:: UGens>Generators>Deterministic, UGens>Filters>Linear


Description::

Klank is a bank of fixed frequency resonators which can be used to
simulate the resonant modes of an object. Each mode is given a ring time,
which is the time for the mode to decay by 60 dB.
Note::for dynamic changes of parameters refer to link::Classes/DynKlank:: ::

Note::
The amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.
::

Klank is a bank of Ringz filters. link::Classes/Formlet:: is equivalent to code::Ringz.ar(... decay...) - Ring.ar(... attack...)::. Therefore, a more efficient way to make a bank of fixed-parameter Formlet filters is code::Klank(`decaySpecs, ...) - Klank.ar(`attackSpecs, ...):: or code::Klank.ar(`specs, ..., decayscale: decay) - Klank.ar(`specs, ..., decayscale: attack)::.

classmethods::

method::ar

argument::specificationsArrayRef
A link::Classes/Ref:: to an link::Classes/Array:: of three Arrays:

definitionlist::
## frequencies: || An Array of filter frequencies.
## amplitudes: || an Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.
## ring times: || an Array of 60 dB decay times in seconds for the filters.
::
All subarrays, if not nil, should have the same length.

argument::input
The excitation input to the resonant filter bank.

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

argument::decayscale
A scale factor multiplied by all ring times at initialization time.

discussion::
The parameters in code::specificationsArrayRef:: can't be changed after it has been started.
For a modulatable but less efficient version, see link::Classes/DynKlank::.


Examples::

Four resonators each at maximum amplitude of 1.0 and ring times of 1 second, different exciters and no scaling:
Note:: Watch the ` before the opening bracket of the parameter array! Also see link::Guides/Multichannel-Expansion::::
code::
{ Klank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ Klank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ Klank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([0.007, 0.007])) }.play;

::

Three resonators at maximum amplitude of 1.0, random frequency and ring times.
Excited by two pulses at 2 and 2.5 Hz:
code::
(
play({
	Klank.ar(`[
		Array.rand(12, 800.0, 4000.0), 		// frequencies
		nil, 							// amplitudes (default to 1.0)
		Array.rand(12, 0.1, 2)				// ring times
		], Decay.ar(Impulse.ar(4), 0.03, ClipNoise.ar(0.01)))
})
)
::

link::Guides/Multichannel-Expansion:: via an array of specs
(note the ` before the opening bracket of the parameter array!):
code::
(
{
Klank.ar([ // the multichannel-expansion
	`[[500, 1078, 1201.5, 1723], nil, [1, 1, 0.5, 0.3]], // left channel
	`[[700, 1071, 1053, 1723], nil, [1, 1, 1, 1]] // right channel
	], Impulse.ar([1.5, 1.875], 0, 0.1))
}.play
);

// expanding specs within the parameter array
{ Klank.ar(`[[[800, 6000], 1071, [1153, 8000], 1723], nil, [1, 1, 1, 1]], Impulse.ar([2, 3], 0, 0.1)) }.play;

::

A SynthDef that generates 4 partials used in different configurations:
code::
(
SynthDef(\help_Klank, { arg out=0, i_freq;
	var klank, n, harm, amp, ring;

	// harmonics
	harm = \harm.ir(Array.series(4, 1, 1).postln);
	// amplitudes
	amp = \amp.ir(Array.fill(4, 0.05));
	// ring times
	ring = \ring.ir(Array.fill(4, 1));

	klank = Klank.ar(`[harm, amp, ring], {ClipNoise.ar(0.003)}.dup, i_freq);

	Out.ar(out, klank);
}).add;
)

// nothing special yet, just using the default set of harmonics.
a = Synth(\help_Klank, [\i_freq, 300]);
b = Synth(\help_Klank, [\i_freq, 400]);
c = Synth(\help_Klank, [\i_freq, 533.33]);
d = Synth(\help_Klank, [\i_freq, 711.11]);

a.free;
b.free;
c.free;
d.free;

a = Synth(\help_Klank, [\i_freq, 500, \harm, [4, 1, 3, 5, 7]]);
a.free;

// set geometric series harmonics
a = Synth(\help_Klank, [\i_freq, 500, \harm,Array.geom(4, 1, 1.61)]);
a.free;

// set harmonics, ring times and amplitudes
(
a = Synth(\help_Klank, [
	\i_freq, 500,
	\harm, [4, 1, 3, 5, 7],
	\ring, Array.fill(4, 0.1), // set shorter ring time
	\amp, Array.fill(4, 0.2) // set louder amps
])
);

::

Advanced examples:
code::

// -- overlap texture
(
SynthDef("help-KlankOverlapTexture",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], atk = 5, sus = 8, rel = 5, pan = 0|
	var e = EnvGen.kr(Env.linen(atk, sus, rel, 1, 4), doneAction: Done.freeSelf);
	var i = Decay.ar(Impulse.ar(Rand(0.8, 2.2)), 0.03, ClipNoise.ar(0.01));
	var z = Klank.ar(
		`[freqs, nil, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 8, transition = 3, overlap = 4;
	var period = transition * 2 + sustain / overlap;
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do{
		Synth("help-KlankOverlapTexture", [
			\atk, transition,
			\sus, sustain,
			\rel, transition,
			\pan, 1.0.rand2,
			\freqs, {200.0.rrand(4000)}.dup(12),
			\rings, {0.1.rrand(2)}.dup(12)
		]);
		period.wait;
	}
};
r.play;
)

r.stop;	// stop spawning new synths



// -- frequency and decay scaling
(
SynthDef("help-KlankScaling", {|out = 0, freq = 0, rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], pan = 0|
	var e = EnvGen.kr(Env(#[1, 1, 0], #[0.4, 0.01]), doneAction: Done.freeSelf);
	var i = Decay.ar(Impulse.ar(0), 0.03, ClipNoise.ar(0.01));
	var z = Klank.ar(
		`[(1..12), nil, rings], 				// specs (partials, amplitudes, ringtimes)
		i, 							// input
		freq, 							// scale to this frequency
		0, 							// frequency offset
		MouseX.kr(0.2, 3)				// scale decay times
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 8, transition = 3;
	var mode = #[0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24];
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do{|i|
		Synth("help-KlankScaling", [
			\freq, (72 + (mode @@ i)).midicps,
			\rings, {0.1.rrand(2)}.dup(12)
		]);
		0.2.wait;
	}
};
r.play;
)

r.stop;


// -- overlap texture 2
(
SynthDef("help-KlankOverlapTexture2",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], atk = 5, sus = 8, rel = 5, pan = 0|
	var e = EnvGen.kr(Env.linen(atk, sus, rel, 1, 4), doneAction: Done.freeSelf);
	var i = BrownNoise.ar(0.0012);
	var z = Klank.ar(
		`[freqs, nil, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 6, transition = 4, overlap = 5;
	var period = transition*2+sustain/overlap;
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do {
		Synth("help-KlankOverlapTexture2", [
			\atk, transition,
			\sus, sustain,
			\rel, transition,
			\pan, 1.0.rand2,
			\freqs, {6000.0.linrand+80}.dup(12),
			\rings, {0.1.rrand(3)}.dup(12)
		]);
		period.wait;
	}
};
r.play;
)

r.stop;


// -- overlap texture 3
(
SynthDef("help-KlankOverlapTexture3",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], pan = 0|
	var e = EnvGen.kr(Env(#[1, 1, 0], #[18, 3]), doneAction: Done.freeSelf);
	var i = Decay.ar(Impulse.ar(Rand(0.2, 0.6)), 0.8, ClipNoise.ar(0.001));
	var z = Klank.ar(
		`[freqs, 2, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do {
		Synth("help-KlankOverlapTexture3", [
			\pan, 1.0.rand2,
			\freqs, {12000.0.linrand+80}.dup(12),
			\rings, {3.rrand(10)}.dup(12)
		]);
		3.wait;
	}
};
r.play;
)

r.stop;
::





class:: Knob
summary:: A rotary controller view
categories:: GUI>Views
related:: Classes/Slider, Classes/Slider2D

DESCRIPTION::

Knob displays a value from 0.0 to 1.0 in rotary fashion, and allows to control it with either circular or linear mouse motion.

It also displays the deviation of the value from either 0.0 or 0.5, which you can choose using link::#-centered::.

To switch between the mouse interaction modes, use link::#-mode::.

The amount by which the value changes at interaction can be fine-tuned using link::#-step::, link::#-keystep::, link::#-shift_scale::, link::#-ctrl_scale::, and link::#-alt_scale::

CLASSMETHODS::

PRIVATE:: key

METHOD:: defaultMode

    The default link::#-mode:: for newly created Knobs.


INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: value

    The displayed value.

    argument::
        A Number in the range of 0.0 to 1.0.

METHOD:: valueAction

    Sets the value and triggers link::#-action::.

METHOD:: increment
    Increments the value by link::#-keystep:: multiplied by the argument.

    argument::
        A Number.

METHOD:: decrement
    Decrements the value by link::#-keystep:: multiplied by the argument.

    argument:: zoom
        A Number.


SUBSECTION:: Interaction

METHOD:: mode

    The way value is controlled with respect to mouse movement after clicking on the view:
    list::
    ## code::\round:: - value follows circular movement
    ## code::\horiz:: - value follows linear movement in horizontal direction
    ## code::\vert:: - value follows linear movement in vertical direction
    ::

    Defaults to code::\round::.

    Argument::
        One of the symbols listed above.

METHOD:: keystep

    The amount by which the value is incremented/decremented when pressing a relevant key.

    Defaults to 0.01;

    Argument::
        A Number.

METHOD:: step

    The amount by which the value is incremented/decremented using the mouse in 'horizontal' and 'vertical' link::#-mode#modes::.

    Argument::
        A Number.

METHOD:: shift_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Shift key is pressed.

    argument::
        A Float.

METHOD:: ctrl_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Ctrl key is pressed.

    argument::
        A Float.

METHOD:: alt_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Alt key is pressed.

    argument::
        A Float.



SUBSECTION:: Appearance

METHOD:: centered

    Whether the deviation of value will be displayed in relation to 0.0 or 0.5 (e.g. as in a panning controller);

    Argument::
        A Boolean.

METHOD:: color

    The colors used by the Knob to draw the following elements:

    list::
    ## the main Knob color
    ## the value indicator
    ## the deviation indicator
    ## the background of the deviation indicator
    ::

    Argument::
        An Array of four Colors in the order listed above.


SUBSECTION:: Actions

METHOD:: action
    The action object evaluated whenever the user interacts with the Knob using the mouse or the keyboard.

METHOD:: defaultKeyDownAction

    Implements the default effects of key presses as follows:

    table::
    ## strong::Key::   || strong::Effect::
    ## r               || valueAction_(1.0.rand)
    ## n               || valueAction_(0)
    ## x               || valueAction_(1)
    ## c               || valueAction_(0.5)
    ## ]               || increment
    ## [               || decrement
    ## up arrow        || increment
    ## down arrow      || decrement
    ## right arrow     || increment
    ## left arrow      || decrement
    ::

    See also: link::#-keystep::, link::#-shift_scale::, link::#-ctrl_scale::, link::#-alt_scale::.

SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
    returns::
        The link::#-value::.

METHOD:: defaultCanReceiveDrag
    returns::
        True if the current drag data is a Number.

METHOD:: defaultReceiveDrag
    Sets link::#-valueAction:: to the current drag data.


EXAMPLES::

subsection:: Basic Example

code::
(
var window, size = 32; // try different sizes - from 15 to 200 or more!
window = Window.new("Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20, 10, size, size));
k.action_({|v,x,y,m| postf("action func called: %\n", v.value); });
//k.color[1] = Color.gray(alpha:0);
)

k.value
k.value = 0.25
k.valueAction = 0.125

// modes
k.mode = \vert;
k.mode = \horiz;
k.mode = \round; // default

k.visible
k.visible = false
k.visible = true
k.enabled = false
k.enabled_(true)
k.canFocus = false
k.canFocus = true
::

subsection:: Compare Mouse Modes

code::
(
var view = View().layout_(
    HLayout(
        VLayout(Knob().mode_(\round), StaticText().string_("round")),
        VLayout(Knob().mode_(\vert), StaticText().string_("vert")),
        VLayout(Knob().mode_(\horiz), StaticText().string_("horiz"))
    )
);
view.front;
)
::

subsection:: Centered Mode

Center mode is useful for pan or eq gain control etc.

code::
(
var window;
window = Window.new("Pan Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20,10,36,36));
k.action_({|v,x,y,m| \pan.asSpec.map(v.value).postln; })
//  .mode_(\horiz)
    .centered_(false)
    .value_(\pan.asSpec.unmap(0)); // 0.5
//k.color[1] = Color.gray(alpha:0);
)
k.centered
k.centered = true
k.centered = false
::


subsection:: step

link::#-step:: only affects the 'horiz' and 'vert' modes:

code::
(
var window, midispec;
midispec = [0,127,'linear',1].asSpec;
window = Window.new("step Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20,10,32,32));
k.action_({|v,x,y,m| midispec.map(v.value).postln; })
       .value_(midispec.unmap(0));

k.mode = \vert;

)
k.step
k.step = 10/127 // step by 10

k.mode = \horiz;
k.mode = \round;
::


subsection:: mouseOverAction

code::
(
var size = 28;
w = Window.new("Knobs", Rect(250,500,270,70));
w.acceptsMouseOver=true; // must be true in parent window!
w.view.decorator = FlowLayout(w.view.bounds);
h = StaticText(w, 150 @ 10);
w.view.decorator.nextLine;
k = Array(8);
8.do({|item, i|
    var knob;
    knob = Knob.new(w, size @ size)
        .action_({|v,x,y,m| h.string = "val: " ++ v.value.asString; })
        .mouseOverAction_({|v,x,y| h.string = "val: " ++ v.value.asString; });

    k = k.add(knob);
});
w.front
)
k[4].value
::


subsection:: Drag and Drop

code::
(
var w, txt, size = 36;
w = Window.new("Knobs", Rect(400,400,250,100)).front;
w.acceptsMouseOver=true;
w.view.decorator = FlowLayout(w.view.bounds).gap_(10 @ 10).margin_(10 @10);
txt = StaticText(w, 200 @ 14);
w.view.decorator.nextLine;

k = Knob(w, size @ size);
k.action = {arg v,x,y;  v.value.postln; txt.string_("value: " ++ v.value); };
k.mouseOverAction = {|v| txt.string_("value: " ++ v.value); };

j = Knob(w, size @ size);
j.action = {arg v,x,y;  j.value.postln; txt.string_("value: " ++ v.value); };
j.mouseOverAction = { txt.string_("value: " ++ j.value); };

n = NumberBox(w, 100 @ 20);
//n.setProperty(\boxColor,Color.grey(alpha:0.0));
n.value = 0.0;
)

// customize drag and drop methods
k.canReceiveDragHandler
k.canReceiveDragHandler = false; // don't accept drops

k.canReceiveDragHandler = { View.currentDrag.isFloat }; // accept only if drag is float

k.receiveDragHandler = { ("value dropped in: " ++ View.currentDrag).postln }

k.receiveDragHandler = { k.valueAction = View.currentDrag.clip(0.0, 1.0); }

k.beginDragAction = { ("drag out -> " ++ k.value).postln; }

k.beginDragAction = { k.value.asFloat; }
::


class:: LFClipNoise
summary:: Clipped noise
related:: Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Randomly generates the values -1 or +1 at a rate given by the nearest
integer division of the sample rate by the  code::freq:: argument. It is probably pretty hard on your speakers!


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		LFClipNoise.ar(1000, 0.25)
	)
}).play;
)

//modulate frequency
(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		LFClipNoise.ar(XLine.kr(1000, 10000, 10), 0.25)
	)
}).play;
)

//use as frequency control
(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		SinOsc.ar(
			LFClipNoise.ar(4, 200, 600),
			0, 0.2
		)
	)
}).play;
)

::



class:: LFCub
summary:: A sine like shape made of two cubic pieces
related:: Classes/LFPar, Classes/LFPulse, Classes/LFSaw, Classes/LFTri
categories::  UGens>Generators>Deterministic


Description::

A sine like shape made of two cubic pieces. Smoother than
link::Classes/LFPar:: .


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset. For efficiency reasons this is a value ranging from 0 to 2.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFCub.ar(800,0,0.1) }.play
{ LFCub.ar(XLine.kr(100,8000,30),0,0.1) }.play

//compare:

{ LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFPar.ar(800,0,0.1) }.play
{ LFPar.ar(XLine.kr(100,8000,30),0,0.1) }.play


{ SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.play
{ SinOsc.ar(800,0,0.1) }.play
{ SinOsc.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFTri.ar(800,0,0.1) }.play
{ LFTri.ar(XLine.kr(100,8000,30),0,0.1) }.play
::



class:: LFDClipNoise
summary:: Dynamic clipped noise
related:: Classes/LFClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like link::Classes/LFClipNoise::, it generates the values -1 or +1 at a rate given
by the  code::freq::  argument, with two differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFClipNoise:: , as well as  link::Classes/LFNoise0:: ,
link::Classes/LFNoise1::  and  link::Classes/LFNoise2::  quantize to the
nearest integer division of the samplerate, and they poll the
code::freq::  argument only when scheduled; thus they often
seem to hang when freqs get very low.
::
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFClipNoise::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling the mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{ LFClipNoise.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

{ LFDClipNoise.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

// silent for 2 secs before going up in freq

{ LFClipNoise.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;

{ LFDClipNoise.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFClipNoise.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFDClipNoise.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;
::



class:: LFDNoise0
summary:: Dynamic step noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like link::Classes/LFNoise0::, it generates random values at a rate
given by the  code::freq::  argument, with two differences:

list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
::


If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise0::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{ LFNoise0.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

{ LFDNoise0.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

// silent for 2 secs before going up in freq

{ LFNoise0.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;

{ LFDNoise0.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise0.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFDNoise0.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFNoise2.ar(1000, 0.25) }.play;
::



class:: LFDNoise1
summary:: Dynamic ramp noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like link::Classes/LFNoise1::, it generates linearly interpolated random
values at a rate given by the code::freq:: argument, with two differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise1::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{  SinOsc.ar(LFNoise1.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play

{  SinOsc.ar(LFDNoise1.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise1.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

{ LFDNoise1.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;
::



class:: LFDNoise3
summary:: Dynamic cubic noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Similar to  link::Classes/LFNoise2:: , it generates polynomially
interpolated random values at a rate given by the
code::freq::  argument, with 3 differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
## cubic instead of quadratic interpolation
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise2::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly:
// LFNoise2 overshoots when going from high to low freqs, LFDNoise changes smoothly.

{  SinOsc.ar(LFNoise2.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play

{  SinOsc.ar(LFDNoise3.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise2.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

{ LFDNoise3.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

// use as frequency control
(
{
		SinOsc.ar(
			LFDNoise3.ar(4, 400, 450),
			0, 0.2
		)
}.play;
)
::



class:: LFGauss
summary:: Gaussian function oscillator
categories:: UGens>Generators>Deterministic

description::
A non-band-limited gaussian function oscillator.

teletype::LFGauss:: implements the formula:
teletype::
f(x) = exp((x - iphase)^2 / (-2.0 * width^2))
::
where teletype::x:: in this context is the phase, which cycles in a range teletype::-1:: to teletype::1:: over the period strong::duration::.
The Gaussian function in this form is a bell-shaped link::https://mathworld.wolfram.com/ApodizationFunction.html##apodization function::, making it convenient for use as an envelope.

Its minimum value occurs when the phase teletype::x = -1:: and teletype::x = 1::, and its maximum occurs when teletype::x = 0::.

classmethods::
method:: ar, kr

argument:: duration
Duration of one cycle, in seconds. (Hint: strong::duration:: teletype::= 1/frequency::). Default: teletype::1::
argument:: width
The width of the bell curve (its standard deviation).

Practically speaking, a strong::width:: teletype::<= 0.25:: will give minimum values near, but not equal to, zero.

The bell curve becomes broader with increasing strong::width::. Beyond roughly teletype::>= 0.25:: the function has the appearance of being truncated, or, when strong::loop:: teletype::= 1::, the cycles begin to "overlap".
Default: teletype::0.1::
argument:: iphase
Initial offset phase offset in the range teletype::[-1, 1]::. Default: 0
argument:: loop
If strong::loop:: teletype::> 0::, the function repeats. Otherwise, it calls strong::doneAction:: after one cycle. Default: 1
argument:: doneAction
A teletype::doneAction:: value, which is evaluated at the end of a cycle (if strong::loop:: teletype::= 0::). teletype::2:: frees the synth. Default: teletype::0:: (continues running).
See link::Classes/Done#Actions:: for more options.

discussion::
By default, the maximum value of teletype::LFGauss:: is teletype::1::.
The minimum value will depend on the strong::width::, and can by inspected with link::#-minval::.

The function can be mapped to a specified range with link::#-range::, which can be useful when using teletype::LFGauss:: as an envelope that may need to span a range of, e.g., teletype::[0, 1]::.

See the examples below for understanding and manipulating the link::#Min and max values, curve width::.

instancemethods::

method::minval

Returns the function's lowest value for the given strong::width:: parameter, which is teletype::exp(1.0 / (-2.0 * width^2))::.

method::range

Scales the output to the given range. This can be convenient when using teletype::LFGauss:: as an envelope (see link::#examples:: below).

code::
// high width, curve minimum around is 0.25
{ LFGauss.ar(0.01, 0.6) }.plot;
// use .range to map the same function to a specified range
{ LFGauss.ar(0.01, 0.6).range(0, 2) }.plot;
::

examples::

subsection:: Example plots

code::
s.boot;

// a 0.1 second grain
{ LFGauss.ar(0.1, 0.12) }.plot(0.1);

// shift a half-cycle left
{ LFGauss.ar(0.1, 0.12, -1, loop: 0) }.plot(0.1);

// moving further away from the center
{ LFGauss.ar(0.1, 0.12, 2) }.plot(0.2);

// several grains
{ LFGauss.ar(0.065, 0.12, 0, loop: 1) }.plot(0.3);
::

subsection:: Min and max values, curve width

link::#-minval:: for a given strong::width:: (assuming strong::iphase:: teletype::= 0::) is:

teletype::minval = exp(-1.0 / (2.0 * squared(width)))::

strong::width:: for a given link::#-minval:: is:

teletype::width = sqrt(-1.0 / log(minval))::

strong::width:: at half of the maximum value(teletype::0.5::) is:

teletype::(2 * sqrt(2 * log(2)) * width) = ca. 2.355 * width::

code::
// minval for a width of 0.1:
(exp(1 / (-2.0 * squared(0.1)))) // 2e-22

// maximum width for a beginning at -60dB:
// we want the beginning small enough to avoid clicks
sqrt(-1 / ( 2 * log(-60.dbamp))) // 0.269

// minval for width of 0.25
(exp(1 / (-2.0 * squared(0.25)))).ampdb // -70dB

// maximum is always 1:
{ LFGauss.ar(0.1, XLine.kr(1, 0.03, 1), 0, loop: 1) }.plot(1);

// a gaussian curve in sclang:
(0..1000).normalize(-1, 1).collect(_.gaussCurve(1, 0, 0.1)).plot;

// rescale the function to the range 0..1
(
{
	var width = XLine.kr(0.04, 1.0, 1);
	var min = (exp(1.0 / (-2.0 * squared(width))));
	var gauss = LFGauss.ar(0.1, width, loop: 1);
	gauss.linlin(min, 1, 0, 1);
}.plot(1)
);

// range does the same implicitly
(
{
	var width = XLine.kr(0.04, 1.0, 1);
	LFGauss.ar(0.1, width, loop: 1).range(0, 1);
}.plot(1)
);
::

subsection:: Sound examples
code::
// modulating duration
{ LFGauss.ar(XLine.kr(0.1, 0.001, 10), 0.03) * 0.2 }.play;

// modulating width, freq 60 Hz
{ LFGauss.ar(1/60, XLine.kr(0.1, 0.001, 10)) * 0.2 }.play;

// modulating both: x position is frequency, y is width factor.
// note the artefacts due to aliasing at high frequencies
{ LFGauss.ar(MouseX.kr(1/8000, 0.1, 1), MouseY.kr(0.001, 0.1, 1)) * 0.1 }.play;

// LFGauss as amplitude modulator
{ LFGauss.ar(MouseX.kr(1, 0.001, 1), 0.1) * SinOsc.ar(1000) * 0.1 }.play;

// modulate iphase
{ LFGauss.ar(0.001, 0.2, [0, MouseX.kr(-1, 1)]).sum * 0.2 }.scope;

// for very small width we are "approaching" a dirac function
{ LFGauss.ar(0.01, SampleDur.ir * MouseX.kr(10, 3000, 1)) * 0.2 }.play;

( // dur and width can be modulated at audio rate
{
	var dur = SinOsc.ar(MouseX.kr(2, 1000, 1) * [1, 1.1]).range(0.0006, 0.01);
	var width = SinOsc.ar(0.5 * [1, 1.1]).range(0.01, 0.3);
	LFGauss.ar(dur, width) * 0.2
}.play
)

( // several frequencies and widths combined
{
	var mod = LFGauss.ar(MouseX.kr(1, 0.07, 1), 1 * (MouseY.kr(1, 3) ** (-1..-6)));
	var carr = SinOsc.ar(200 * (1.3 ** (0..5)));
	(carr * mod).sum * 0.1
}.play
)

( // test spectrum
{
	var son = LeakDC.ar(LFGauss.ar(0.005, 0.2));
	BPF.ar(son * 3, MouseX.kr(60, 2000, 1), 0.05)
}.play
)
::

subsection:: Gabor Grain

note::
The gaussian function doesn't start with teletype::0:: – it asymptotically approaches it at teletype::-inf:: and teletype::inf::. When using it as an envelope, it has to start at some smaller value, and it has an offset for this value. You can remove this offset by explicitly setting the link::#-range::, e.g. to teletype::[0, 1]:: (this is the default).
::



code::
// first, visualize LFGauss as a granular envelope on a sine oscillator
(
var freq = 1000;
var ncycles = 10;
var width = 0.25;
var dur = ncycles / freq;
{
	var env = LFGauss.ar(dur, width, loop: 0, doneAction: Done.freeSelf).range;
	var son = FSinOsc.ar(freq, 0.5pi, env);
	son
}.plot(dur);
)

// ... now as a SynthDef
(
SynthDef(\gabor, { |out, i_freq = 440, i_sustain = 1, i_pan = 1, i_amp = 0.1, i_width = 0.25 |
	var env = LFGauss.ar(i_sustain, i_width, loop: 0, doneAction: Done.freeSelf).range;
	var son = FSinOsc.ar(i_freq, 0.5pi, env);
	OffsetOut.ar(out, Pan2.ar(son, i_pan, i_amp));
}).add;
)

// modulating various parameters
(
Pdef(\x,
	Pbind(
		\instrument, \gabor,
		\freq, Pbrown(step:0.01).linexp(0, 1, 100, 14000),
		\dur, Pbrown().linexp(0, 1, 0.004, 0.02),
		\legato, Pbrown(1, 3, 0.1, inf),
		\pan, Pwhite() * Pbrown()
	)
).play
)

// modulating width only
(
Pdef(\x,
	Pbind(
		\instrument, \gabor,
		\freq, 1000,
		\dur, 0.01,
		\width, Pseg(Pseq([0.25, 0.002], inf), 10, \exp),
		\legato, 2
	)
).play
)

// compare with sine grain:
// evaluate this SynthDef and re-run the above Pdefs
(
SynthDef(\gabor, { |out, i_freq = 440, i_sustain = 1, i_pan = 1, i_amp = 0.1, i_width=0.25 |
	var env = EnvGen.ar(Env.sine(i_sustain * i_width), doneAction: Done.freeSelf);
	var son = FSinOsc.ar(i_freq, 0.5pi, env);
	OffsetOut.ar(out, Pan2.ar(son, i_pan, i_amp));
}).add;
)
::


class:: LFNoise0
summary:: Step noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Generates random values at a rate given by the nearest integer division
of the sample rate by the  code::freq::  argument.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise0.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise0.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise0.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of starting points
{ var freq = 1000; [LFNoise0.ar(freq), Impulse.ar(freq)] }.plot
::



class:: LFNoise1
summary:: Ramp noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Generates linearly interpolated random values at a rate given by the
nearest integer division of the sample rate by the
code::freq::  argument.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise1.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise1.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise1.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of starting points
{ var freq = 1000; [LFNoise1.ar(freq), Impulse.ar(freq)] }.plot
::



class:: LFNoise2
summary:: Quadratic noise.
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1
categories::  UGens>Generators>Stochastic


Description::

Generates quadratically interpolated random values at a rate given by
the nearest integer division of the sample rate by the
code::freq::  argument.

note::
quadratic interpolation means that the noise values can occasionally extend beyond the normal range of +-1, if the freq varies in certain ways. If this is undesirable then you might like to clip2 the values, or use a linearly-interpolating unit instead.
::

classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise2.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise2.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise2.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of interpolation points
{ var freq = 1000; [LFNoise2.ar(freq), Impulse.ar(freq)] }.plot
::



class:: LFPar
summary:: Parabolic oscillator
related:: Classes/LFCub, Classes/LFPulse, Classes/LFSaw, Classes/LFTri
categories::  UGens>Generators>Deterministic


Description::

A sine-like shape made of two parabolas and the integral of a triangular wave.  It has audible odd harmonics and is non-band-limited.
Output ranges from -1 to +1.

classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset. For efficiency reasons this is a value ranging from 0 to 4.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// a plot
{ LFPar.ar(Line.kr(100, 800, 0.1)) }.plot(0.1);

// 440 Hz wave
{ LFPar.ar(440) * 0.1 }.play;

// modulating frequency:
{ LFPar.ar(XLine.kr(100, 2000, 10)) * 0.1 }.play;

// amplitude modulation:
{ LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1 }.play;

// used as both Oscillator and LFO:
{ LFPar.ar(LFPar.kr(3, 0.3, 200, 400)) * 0.1 }.play;

// used as phase modulator (behaves like a triangular modulator in FM):
// Compare:
{SinOsc.ar(440, LFPar.ar(1, 2, mul: 8pi))}.play
{SinOsc.ar(440 + LFTri.ar(1, mul: 8pi))}.play


// more examples:

{ LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10), 0, 400,800),0,0.1) }.play
{ LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFPar.ar(800,0,0.1) }.play
{ LFPar.ar(XLine.kr(100,8000,30),0,0.1) }.play


// compare:

{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFCub.ar(800,0,0.1) }.play
{ LFCub.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.play
{ SinOsc.ar(800,0,0.1) }.play
{ SinOsc.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFTri.ar(800,0,0.1) }.play
{ LFTri.ar(XLine.kr(100,8000,30),0,0.1) }.play
::



class::LFPulse
summary::pulse oscillator
categories::UGens>Generators>Deterministic
related::Classes/LFSaw

description::
A non-band-limited pulse oscillator. Outputs a high value of one and a low value of zero.

classmethods::

method::ar, kr

argument::freq
frequency in Hertz

argument::iphase
initial phase offset in cycles ( 0..1 )

argument::width
pulse width duty cycle from zero to one.

argument::mul

argument::add

instancemethods::
private::signalRange

examples::

a plot:
code::
{ LFPulse.ar(Line.kr(100, 800, 0.1)) }.plot(0.1);
::

50 Hz wave:
code::
{ LFPulse.ar(50) * 0.1 }.play;
::

modulating frequency:
code::
{ LFPulse.ar(XLine.kr(1, 200, 10), 0, 0.2, 0.1) }.play;
::

amplitude modulation:
code::
{ LFPulse.kr(XLine.kr(1, 200, 10), 0, 0.2) * SinOsc.ar(440) * 0.1 }.play;
::

used as both Oscillator and LFO:
code::
{ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) }.play;
::

scope:
code::
{ LFPulse.ar(500, 0, MouseX.kr, 0.5) }.scope;
::

compare with band limited Pulse UGen:
code::
(
{
    [
        Pulse.ar(100, 0.3, 0.5),
        LFPulse.ar(100, 0, 0.3, 0.5)
    ] * 0.2
}.scope(bufsize: 44100, zoom: 5)
)
::



class:: LFSaw
summary:: Sawtooth oscillator
related:: Classes/LFCub, Classes/LFPar, Classes/LFPulse, Classes/LFTri, Classes/Saw
categories::  UGens>Generators>Deterministic


Description::

A non-band-limited sawtooth oscillator. Output ranges from -1 to +1.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset. For efficiency reasons this is a value
ranging from 0 to 2.
Note:: enter "1" for an initial phase of 0 radians.
A value of 0 would start the cycle at pi radians. See the example below.::

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFSaw.ar(500, 1, 0.1) }.play

// used as both Oscillator and LFO:
{ LFSaw.ar(LFSaw.kr(4, 0, 200, 400), 0, 0.1) }.play

::

Display the special behaviour of the initial phase parameter:

code::
 // three channels, three phases
{ LFSaw.ar(20, [0, 1, 2]) }.plot(0.1)
::


class:: LFTri
summary:: Triangle oscillator
related:: Classes/LFCub, Classes/LFPar, Classes/LFPulse, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

A non-band-limited triangle oscillator. Output ranges from -1 to +1.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz. For efficiency reasons, only positive values result in correct behavior.

argument::iphase

Initial phase offset. For efficiency reasons this is a value
ranging from 0 to 4.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// plot:
{ LFTri.ar(40) }.plot(0.1);
{ LFTri.ar(XLine.kr(1, 800, 0.1)) }.plot(0.1);

{ LFTri.ar(500, 0, 0.1) }.play

// used as both Oscillator and LFO:
{ LFTri.ar(LFTri.kr(4, 0, 200, 400), 0, 0.1) }.play

// phase. compare
{ LFTri.ar(LFTri.kr(0.1, iphase: 0) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 1) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 2) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 3) * 200 + 400, 0, 0.1) }.play

// together
{ LFTri.ar(LFTri.kr(0.05, iphase: (0..3)) * 200 + 400, 0, 0.1).sum }.play
::



class:: LID
summary:: Linux Input Device
categories:: Platform>Linux, External Control>HID
related:: Classes/HID, Classes/LIDInfo, Classes/LIDSlot, Classes/LIDGui

description::
This class provides a way to access devices in the Linux input layer, which supports many input devices (mouse, keyboard, joystick, gamepad, tablet) and busses (serial, PS/2, USB).

NOTE::For external HID devices it is recommended to use the link::Classes/HID:: interface, as described in link::Guides/Working_with_HID::, as it will ensure that your code is cross platform compatible. Only in cases where the raw HID interface does not provide access because the device needs a special driver (and this driver is provided in Linux kernel), or in case you want to access internal devices, you should use this class.
::

NOTE: if you have trouble opening a device, e.g. when you get the message code::ERROR: LID: Could not open device::, please check the link::Guides/LID_permissions::

subsection:: First example:

code::

LID.findAvailable;
LID.postAvailable; // pick one that you want to open, and fill in the vendor and product id in the next line:
d = LID.open( 2, 10 ); // trackpoint

d.postInfo;
d.postSlots;

d.debug_( true ); // wiggle a little and see the data coming in

d.debug_( false );

// create a GUI:
d.makeGui;

// close the device (don't do this yet, if you want to excecute the further examples in this class)
d.close;
::


CLASSMETHODS::

private:: prStartEventLoop, prStopEventLoop

SUBSECTION:: Finding devices

An example of finding a device:

code::
LID.findAvailable;

LID.available;

LID.postAvailable;

// look for the one you want and find it:

LID.findBy( 2, 10 ) // by vendor and product
::

METHOD:: findAvailable
queries the operating system which LID devices are attached to the system and can be accessed. When using LID this is the first method you need to execute, before you can access any device.

ARGUMENT:: name
The basic path to look for, by default this is code::"event"::. See also code::deviceRoot::.

returns:: an IdentityDictionary of available devices

METHOD:: deviceRoot

This is the base path where to look for devices. By default this is: code::"/dev/input"::. With code::findAvailable:: this is extended with the code::name:: that is passed in, which has as a default code::"event"::. Hence, by default we look for devices that match the path: code::"/dev/input/event*"::.

See below for some link::#Opening devices with alternative deviceRoot::

METHOD:: available
A dictionary of available devices, or rather info about them in an instance of LINK::Classes/LIDInfo::, populated by the method findAvailable

returns:: an IdentityDictionary

METHOD:: postAvailable
posts a human readable list of available LID devices and their properties (see also LINK::Classes/LIDInfo::)


METHOD:: findBy
Find devices in the available device dictionary by specifying one or more characteristics of the device

ARGUMENT:: vendorID
The vendor ID of the device, this is a number encoded by the device itself.

ARGUMENT:: productID
The product ID of the device, this is a number encoded by the device itself.

ARGUMENT:: path
The path of the device, this is a path defined by the operating system.

ARGUMENT:: version
The version of the device.

ARGUMENT:: physical
The physical location of the device, this is a path defined by the operating system.

ARGUMENT:: unique
A unique identifier for the device, defined by the operating system.

returns:: an IdentityDictionary of devices the match the search query, or nil if no arguments are given

code::
LID.findBy( 2 ); // by vendorID
LID.findBy( 2, 10 ) // by vendor and product
LID.findBy( productID: 10 );
LID.findBy( path: "/dev/input/event4" );
LID.findBy( version: 0 );
LID.findBy( physical: 'synaptics-pt/serio0/input0' )
LID.findBy( physical: "synaptics-pt/serio0/input0" ) // argument is converted to symbol for check
LID.findBy( unique: '' )
LID.findBy( unique: "" ) // argument is converted to symbol for check

// using all possible arguments:
LID.findBy( 2, 10, "/dev/input/event4", 0x0000, 'synaptics-pt/serio0/input0' )
::

SUBSECTION:: Opening devices

METHOD:: open
Open a device with a given vendorID and product ID. For arguments description see link::#*findBy::.
The method will call the method code::findBy:: and use the first available result as the device to open.

returns:: The LID device - an instance of code::LID::.


METHOD:: new
Same as code::LID.openPath::.


METHOD:: openPath
Open a device using its path in the operating system.

ARGUMENT:: path
The path in the operating system, e.g. code::"/dev/input/event4"::

returns:: The LID device - an instance of code::LID::.

METHOD:: openAt
Open a device using its index in the dictionary of available devices

ARGUMENT:: index
The index into the dictionary of available devices

returns:: The LID device - an instance of code::LID::.


METHOD:: openDevices
A dictionary of the opened devices

returns:: an IdentityDictionary



SUBSECTION:: Adding functions to LID events

Whenever data comes in from an opened LID device, there are two types of actions fired. An action for the incoming element data and an action for the device, indicating that there has been a change in one of the elements. In most cases you will want to use the first action; only in cases where the order of parsing the element data is important, you may want to use the second type - e.g. when dealing with very accurately timed button press combinations.

There are three levels where you can set actions:
LIST::
	## at the global level - called for any LID device, for any slot
	## at the device level - called for the specific device, for any slot
	## at the slot level - called for the specific element of the specific device
::


METHOD:: debug
When set to true, the incoming data from any opened LID device will be printed to the post window.

METHOD:: action
Set or get the action to be performed upon receiving element data from any device. The function will be passed the following arguments: the value (mapped between 0 and 1), the raw value, element usage page, the element usage, the element id, the device id, the device (an instance of LID).

ARGUMENT:: function
The function to be performed upon receiving element data from the device

METHOD:: addRecvFunc
add a function to the internal FunctionList that will be evaluated whenever element data comes in from an open device. The arguments passed to the function are as defined above.
Use this method if you want to add actions to LID functions from classes you write, so that you still keep the option to add an action on the fly from user code.

ARGUMENT:: function
The function to be added to the list.


METHOD:: removeRecvFunc
remove a function to the internal FunctionList that will be evaluated whenever data comes in from a device.


ARGUMENT:: function
The function to remove from the list, this must be a reference to the Function that was originally added to the list


SUBSECTION:: Managing the LID subsystem

The following methods are used internally to initialize and finalize the LID subsystem, but in rare cases you may wish to manage these methods manually.

METHOD:: initializeLID
Initialize the LID subsystem, this method is called automatically when calling the method findAvailable.


METHOD:: running
Indicates whether or not the LID subsystem is running.


METHOD:: closeAll
This method is called automatically upon Shutdown, if the LID subsystem was initialized. It can be stopped manually, in order to save system resources. This method will close all opened LID devices.


SUBSECTION:: Creating specs for devices

Device specs are mappings between event codes and symbolic control names. New specs can be added to LID.specs via LID>>*register.


code::
// Add a mouse device spec for a Logitech trackball
LID.register('Logitech Trackball', LID.mouseDeviceSpec);

// Add a custom device spec for a Logitech gamepad
(
LID.register('Logitech WingMan RumblePad', (
	// key
	rumble: #[0x0001, 0x0102],	// rumble (toggles ff)
	mode: #[0x0001, 0x0103],	// mode (switches h and l)
	a: #[0x0001, 0x0120],		// button a
	b: #[0x0001, 0x0121],		// button b
	c: #[0x0001, 0x0122],		// button c
	x: #[0x0001, 0x0123],		// button x
	y: #[0x0001, 0x0124],		// button y
	z: #[0x0001, 0x0125],		// button z
	l: #[0x0001, 0x0126],		// left front button
	r: #[0x0001, 0x0127],		// right front button
	s: #[0x0001, 0x0128],		// button s
	// abs
	lx: #[0x0003, 0x0000],		// left joystick x
	ly: #[0x0003, 0x0001],		// left joystick y
	rx: #[0x0003, 0x0005],		// right joystick x
	ry: #[0x0003, 0x0006],		// right joystick y
	hx: #[0x0003, 0x0010],		// hat x
	hy: #[0x0003, 0x0011],		// hat y
	slider: #[0x0003, 0x0002]	// slider
));
)
::


METHOD:: register
This will register the spec for the specified device. If the device was opened and did not use the spec before, it will use this spec. See also link::Classes/LID#*specs::.

ARGUMENT:: name
The name of the device to register it for.

ARGUMENT:: spec
The spec to be added. This should be an IdentityDictionary.


METHOD:: specs
This returns the specs that have been registered.


METHOD:: mouseDeviceSpec
This returns a default spec for a mouse device; any mouse, trackball, trackpad or trackpoint should be able to use this spec.

METHOD:: keyboardDeviceSpec
This returns a default spec for a keyboard device; any keyboard or numpad should be able to use this spec.



INSTANCEMETHODS::

private:: prClose, prEventCodeSupported, prEventTypeSupported, prGetAbsInfo, prGetInfo, prGetKeyState, prGrab, prHandleEvent, prInit, prOpen, prReadError, prSetLedState, prSetMscState, getAbsInfo, getKeyState, getLEDState, setLEDState, setMSCState


METHOD:: close
Close the LID device, closing a device is asynchronous. You can set a closeAction (see below), which will be performed when the device closes.

METHOD:: isOpen
Returns true if the device is open, false if the device was closed.

CODE::
d.isOpen;
d.close;
d.isOpen;
::



SUBSECTION:: Posting human readable information about the device

METHOD:: postInfo
Post the LIDInfo of this device in a human readable format. See also link::Classes/LIDInfo::.

METHOD:: postSlots
Post information about all the slots of this device in a human readable format

METHOD:: dumpCaps
Post the list of available capabilities in a human readable format

METHOD:: makeGui
Create a link::Classes/LIDGui:: for the device.

subsection:: Accessing slots

Device capabilities are reported as event type and event code mappings. Event type and event code constants can be found in code::/usr/include/linux/input.h::

METHOD::slot
Access a slot by its evtType and evtCode. See also link::Classes/LIDSlot::

ARGUMENT:: evtType
The eventType to access the slot.

ARGUMENT:: evtCode
The eventCode to access the slot.


METHOD::at
If a code::spec:: is defined for this device, then you can use a controlName to look up a slot.


METHOD:: spec
The IdentityDictionary that maps labels for slots to slot indices.

ARGUMENT:: forceLookup
If set to true, this will force the dictionary to be reinitialised with the registered spec for this device.


subsection:: Adding functionality to the device

METHOD:: debug
When set to true, the incoming data from this LID device will be printed to the post window.


CODE::
d.debug_( true );
d.debug_( false );
::


METHOD:: closeAction
Function to be performed when device is closed.

CODE::
d.closeAction_( { "hey, I got closed!".postln; } );
d.close;
::

METHOD:: action
Set or get the action to be performed upon receiving data from the device. The function will be passed in the evtType, the evtCode, the value (mapped according to the slot's spec), and the raw value.

CODE::
d.action_( { arg ...args; ("my action" + args ).postln; } );
d.action_( nil );
::

SUBSECTION:: Properties of the device

METHOD::slots
An IdentityDictionary holding all the slots, i.e. controls, of the device

METHOD::path
Retrieve the path of this device

CODE::
d.path;
::

METHOD:: info
Retrieve the LIDInfo of this device

CODE::
d.info;
::

METHOD:: vendor
Retrieve the vendor id of this device

CODE::
d.vendor;
::

METHOD:: product
Retrieve the product id of this device

CODE::
d.product;
::

METHOD:: caps
The list of available capabilities.

subsection:: Grabbing devices

Given proper permissions, devices can be grabbed to prevent use in other applications (including X). Be careful when grabbing mouse or keyboard, as you will not be able to use them for normal interaction (like typing code or moving the mouse pointer) anymore!

code::
d[\b].action = { d.ungrab };
d.grab;

d.isGrabbed;
::

METHOD::grab
Grab the device to use exclusively for SC.

METHOD::ungrab
Release the device to use it no longer exclusively for SC.

METHOD::isGrabbed
Check whether the device is grabbed.


examples::

subsection:: Finding and opening the device

code::

LID.findAvailable;
LID.postAvailable; // pick one that you want to open, and fill in the vendor and product id in the next line:
d = LID.open( 2, 10 ); // trackpoint

d.postInfo;
d.postSlots;

d.debug_( true ); // wiggle a little and see the data coming in
d.debug_( false );
::

subsection:: Event actions (raw events)
The device's 'action' instance variable can be used for event notifications. it is passed the event type, code and current value.
code::
(
d.action = { | evtType, evtCode, evtValue |
	[evtType.asHexString(4), evtCode.asHexString(4), evtValue].postln
}
)

d.action = nil;
::
If a device is detached LID will detect this, and close the device. It will execute a closeAction, which can be defined by the user:
code::
d.closeAction = { "device was detached".postln; };
::

subsection:: Event actions (raw slot events)

When 'action' is nil, actions can be bound to specific events.
code::
(
d.slot(0x0002, 0x0001).action = { | slot |
	[slot.type.asHexString(4), slot.code.asHexString(4), slot.value].postln;
}
)
::
Relative slots can have deltaActions:
code::
(
d.slot(0x0002, 0x0001).deltaAction = { | slot |
	[slot.type.asHexString(4), slot.code.asHexString(4), slot.delta].postln;
}
)
::


subsection:: Event actions (symbolic slot events)

When a device spec was registered for a given device name, slot
actions can be assigned by using the symbolic control name.
code::
	d[\x].action = { | slot | [\x, slot.value].postln };
::


subsection:: LED's
some devices have LEDs which can be turned on and off. These show up with d.caps as events of type 0x0011

code::
d = LID("/dev/input/event0");
// LED's can be turned on:
d.setLEDState( 0x0, 1 )
// (LED 0x0 should be available on any keyboard)
// and off:
d.setLEDState( 0x0, 0 )
d.close;

// setLEDState( evtCode, evtValue ): value should be 1 or 0
::


subsection:: Closing devices
code::
d.close;
LID.closeAll;
::


subsection:: Opening devices with alternative deviceRoot

Input devices are accessed through device nodes, typically code::/dev/input/event[0-9]::. When using a userspace daemon like udev, meaningful names can be assigned to devices.

raw device name:
code::
d = LID("/dev/input/event4");
::

symbolic device name
code::
d = LID("/dev/input/trackball");
::

device name relative to LID.deviceRoot
code::
d = LID("gamepad");
::

build a list of the available devices:
code::
LID.findAvailable;
::
buildDeviceList builds a table of the devices found in LID.deviceRoot+"/event", trying to open all that it finds, looking up its name and closing them again. The result is returned and can later be accessed by LID.deviceList.
You can query another name than "/event" by passing an argument. (the search will be: LID.deviceRoot++"/"++name++"*")
code::
LID.findAvailable( "mouse" );
::
Note:: this is likely to give the info that the devices could not be opened, as "mouse" uses another interface (you can of course access mice via the "event" interface) ::

Note:: if you cannot open the devices at all, please look in the helpfile for: link::Guides/LID_permissions:: ::


TITLE:: LIDGui
summary:: A GUI for an LID
categories:: Platform>Linux, External Control>HID
related:: Classes/LID

DESCRIPTION::
This class creates a simple GUI for an LID device.


CLASSMETHODS::

METHOD:: new
Create a new GUI.

ARGUMENT:: device
An instance of LID, for which to create the GUI.



INSTANCEMETHODS::
private:: init, bkeys, rkeys, akeys, updater;


METHOD:: win
The window that the LIDGui is in.


METHOD:: device
The device for which this GUI is.


EXAMPLES::

code::
LID.findAvailable;
LID.postAvailable; // pick one that you want to open, and fill in the vendor and product id in the next line:
d = LID.open( 2, 10 ); // trackpoint

g = LIDGui.new( d );

// or the shortcut method:
g = d.makeGui;
::


TITLE:: LIDInfo
summary:: Helper class for LID to hold the information about an LID device.
categories:: Platform>Linux, External Control>HID
related:: Classes/LID

DESCRIPTION::
This class contains the basic information about an LID device to access and open it.
The class is mostly used internally and rarely accessed directly by the user.

This class is populated with information read from the device, and represents some of the internal information of the device.


INSTANCEMETHODS::

METHOD:: open
Open the device that is described by this LIDInfo

returns:: an LID - the device

METHOD:: postInfo
post the LIDInfo in a human readable way

METHOD:: findArgs
An Array of the arguments that can be passed into code::LID.findBy:: to find this device.

METHOD:: name
The name of the device, as reported by the device itself.

METHOD:: vendorID
The vendor ID of the device, this is a number encoded by the device itself.

METHOD:: productID
The product ID of the device, this is a number encoded by the device itself.

METHOD:: path
The path of the device, this is a path defined by the operating system, essential to distinguish devices with the same vendor and product ID from each other.

METHOD:: version
The version number of the device.

METHOD:: physical
The physical location of the device, as defined by the operating system.

METHOD:: unique
The unique identifier of the device, as defined by the operating system.

METHOD:: bustype
The bustype of this device


TITLE:: LIDSlot
summary:: Handles incoming LID data.
categories:: Platform>Linux, External Control>HID
related:: Classes/LID

DESCRIPTION::


CLASSMETHODS::

private:: new, initClass

METHOD:: slotTypeStrings
An IdentityDictionary mapping the evtTypes to descriptive strings.


INSTANCEMETHODS::

private:: initSpec, init


METHOD:: postInfo
Post the slots properties in a nice, human readable way.

METHOD:: debug
Turn on or off the debug posting for this slot.


METHOD:: action
Set the action for this slot.


METHOD:: value
Get the current value of this slot, mapped according to its spec.

METHOD:: spec
The ControlSpec to map this slots value.


METHOD:: rawValue
Get the rawValue; the setter of this method is called from the primitive code::LID.prHandleEvent:: and should not be called by the user.



METHOD:: next
Convenience method to use a LIDSlot in a pattern; this will call the value of the slot.



METHOD:: createBus
Create a bus on the server. The slot's value will automatically be set to this bus on the server.

ARGUMENT:: server
The server on which to create the bus and forward the value to. By default this is code::Server.default::


METHOD:: bus
The bus on the server that this slot's value is mapped to.


METHOD:: freeBus
Free the bus on the server and remove the action to forward the value.

METHOD:: kr
JITLib support to access the bus in NodeProxy's. This will create the bus if it does not already exist.


METHOD:: device
The device to which this slot belongs.

METHOD:: type
The type of slot that this is.

METHOD:: code
The eventCode for this slot.

METHOD:: key
The key by which this slot is known in the spec of the device.


EXAMPLES::

code::
LID.findAvailable;
LID.postAvailable; // pick one that you want to open, and fill in the vendor and product id in the next line:
d = LID.open( 2, 10 ); // trackpoint

s.boot;

d.slot(2,1).createBus;

Ndef( \checkbus, { d.slot(2,1).kr.poll } );

d.slot(2,1).freeBus;

Ndef( \checkbus ).clear;

::


class:: LPF
summary:: 2nd order Butterworth lowpass filter
related:: Classes/BPF, Classes/BRF, Classes/HPF
categories::  UGens>Filters>Linear


Description::

A second order low pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
{ LPF.ar(Saw.ar(200,0.1), SinOsc.kr(XLine.kr(0.7,300,20),0,3600,4000)) }.play;

// kr:
(
{ var ctl = LPF.kr(LFPulse.kr(8), SinOsc.kr(XLine.kr(1, 30, 5)) + 2);
	SinOsc.ar(ctl * 200 + 400)
}.play;
)

(
{ var ctl = LPF.kr(LFPulse.kr(8), MouseX.kr(2, 50, 1));
	SinOsc.ar(ctl * 200 + 400)
}.play;
)
::



class:: LPZ1
summary:: Two point average filter
related:: Classes/HPZ1
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:
code::
out(i) = 0.5 * (in(i) + in(i-1))
::
which is a two point averager.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ LPZ1.ar(WhiteNoise.ar(0.25)) }.play;
::



class:: LPZ2
summary:: Two zero fixed lowpass
related:: Classes/BPZ2, Classes/BRZ2, Classes/HPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:
code::
out(i) = 0.25 * (in(i) + (2 * in(i - 1)) + in(i - 2)).
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ LPZ2.ar(WhiteNoise.ar(0.25)) }.play;
::



class:: Lag
summary:: Exponential lag
related:: Classes/Lag2, Classes/Lag3, Classes/VarLag, Classes/LagUD
categories::  UGens>Filters>Linear


Description::
This is essentially the same as  link::Classes/OnePole::  except that
instead of supplying the coefficient directly, it is calculated from a 60
dB lag time. This is the time required for the filter to converge to
within 0.01% of a value. This is useful for smoothing out control
signals.

For linear and other alternatives, see link::Classes/VarLag::.

classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
    SinOsc.ar(                              // sine wave
        Lag.kr(                             // lag the modulator
            LFPulse.kr(4, 0, 0.5, 50, 400), // frequency modulator
            Line.kr(0, 1, 15)               // modulate lag time
        ),
        0,                                  // phase
        0.3                                 // sine amplitude
    )
}.play
)
::



class:: Lag2
summary:: Exponential lag
related:: Classes/Lag, Classes/Lag3, Classes/Ramp, Classes/Lag2UD
categories::  UGens>Filters>Linear


Description::

Lag2 is equivalent to code:: Lag.kr(Lag.kr(in, time), time) ::, thus resulting in a
smoother transition. This saves on CPU as you only have to calculate the
decay factor once instead of twice. See  link::Classes/Lag::  for more
details.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Lag2.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.play
)
::



class:: Lag2UD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/LagUD, Classes/Lag3UD

description::
Lag2 is equivalent to Lag.kr(Lag.kr(in, time), time), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of twice. See link::Classes/Lag:: for more details.

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.

examples::
code::
// used to lag pitch
(
SynthDef( \lag2ud_help, { |out, freq=300, lagup=1, lagdown=5|
	Out.ar(out,
		SinOsc.ar( // sine wave
			Lag2UD.kr( // lag the frequency
				freq,
				lagup,
				lagdown
			),
			0, // phase
			0.2 // sine amplitude
		)
	);
}).add;
)

x = Synth(\lag2ud_help); // create the synth

x.set(\freq, 500); // set the frequency to a higher value (takes 1 second)
x.set(\freq, 100); // set the frequency to a lower value (takes 5 seconds)
x.free;
::


class:: Lag3
summary:: Exponential lag
related:: Classes/Lag, Classes/Lag2, Classes/Ramp, Classes/Lag3UD
categories::  UGens>Filters>Linear


Description::

Lag3 is equivalent to code:: Lag.kr(Lag.kr(Lag.kr(in, time), time), time) ::, thus
resulting in a smoother transition. This saves on CPU as you only have to
calculate the decay factor once instead of three times. See
link::Classes/Lag::  for more details.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Lag3.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.play
)
::



class:: Lag3UD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/LagUD, Classes/Lag2UD

description::
Lag3UD is equivalent to LagUD.kr(LagUD.kr(LagUD.kr(in, timeU, timeD), timeU, timeD), timeU, timeD), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of three times. See link::Classes/LagUD:: for more details.

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.

examples::
code::
// used to lag pitch
(
SynthDef( \lag3ud_help, { |out, freq=300, lagup=1, lagdown=5|
	Out.ar(out,
		SinOsc.ar( // sine wave
			Lag3UD.kr( // lag the frequency
				freq,
				lagup,
				lagdown
			),
			0, // phase
			0.2 // sine amplitude
		)
	)
}).add;
)

x = Synth(\lag3ud_help); // create the synth

x.set(\freq, 500); // set the frequency to a higher value (takes 1 second)
x.set(\freq, 100); // set the frequency to a lower value (takes 5 seconds)
x.free;
::


class:: LagControl
summary:: Lagged control input
related:: Classes/Control, Classes/TrigControl
categories::  UGens>Synth control


Description::

code::Control:: ugen with fixed-time lags.

classmethods::

private::ir

method::kr

argument::values

Initial value (code::Float:: or code::Array:: of Floats).

argument::lags

Lag times (code::Float:: or code::Array:: of Floats).




class:: LagIn
summary:: Read a control signal from a bus with a lag
related:: Classes/In, Classes/InFeedback
categories::  UGens>InOut


Description::

Read a control signal from a bus with a lag.


classmethods::

method::kr

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number.


argument::lag

Lag factor.




class:: LagUD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/Lag2UD, Classes/Lag3UD

description::
This is essentially the same as link::Classes/Lag:: except that you can supply a different 60 dB time for when the signal goes up, from when the signal goes down. This is useful for smoothing out control signals, where "fade in" should be different from "fade out".

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.
argument:: mul
argument:: add

examples::
code::
// used to lag pitch
(
SynthDef(\lagud_help, { |out, freq=300, lagup=1, lagdown=5|
	Out.ar(out,
		SinOsc.ar( // sine wave
			LagUD.kr( // lag the frequency
				freq,
				lagup,
				lagdown
			),
			0, // phase
			0.2 // sine amplitude
		)
	);
}).add;
)

x = Synth(\lagud_help); // create the synth
x.set(\freq, 500); // set the frequency to a higher value (takes 1 second)
x.set(\freq, 100); // set the frequency to a lower value (takes 5 seconds)
x.free;
::


CLASS:: LanguageConfig
summary:: Access and modify interpreter configuration
categories:: Language

DESCRIPTION::
The LanguageConfig class provides access to the interpreter configuration.


section:: Configuration File Format
The configuration file is stored in YAML format, which contains one dictionary. The semantics of the dictionary is listed in
the following table:

definitionList::
## teletype::includePaths:: || List of class library paths.
## teletype::excludePaths:: || List of paths to exclude from the class library files (overrides teletype::includePaths::).
## teletype::postInlineWarnings:: || Boolean flag to post warnings about missing inline opportunities.
::

CLASSMETHODS::

METHOD:: store
Store the current configuration to file. Throws an error if the config file cannot be opened or if
writing fails.

argument:: file
Path to the configuration file to store. If the value is code::nil:: it defaults to currently used configuration file, as specified in the IDE preferences, or by the code::sclang -l "/path/to/sclang_conf.yaml":: argument. By default this is code::Platform.userConfigDir +/+ "sclang_conf.yaml"::

subsection:: Library Path Handling

The language configuration mechanism provides a way to add or exclude specific paths for the class library.

note::Changes to the class library paths won't have any effect before the configuration file is stored and the class library is recompiled.::

METHOD:: includePaths
Return the class library include paths.

METHOD:: addIncludePath
Add new class library include path.

METHOD:: removeIncludePath
Remove path from class library include paths.

METHOD:: excludePaths
Return the class library exclude paths.

METHOD:: addExcludePath
Add new class library exclude path.

METHOD:: removeExcludePath
Remove path from class library exclude paths.

METHOD:: currentPath
Return the current config file path.

METHOD:: excludeDefaultPaths
Get or set whether default class library paths are included.

note::
If sclang is started with -a the class library paths are excluded and this value is ignored. The default class library paths are Platform.classLibraryDir, and the system and user extensions directories.
::

subsection:: Compiler Warnings

METHOD:: postInlineWarnings
Get or set the compiler flag, whether warnings should be posted if a FunctionDef cannot be inlined.

code::
LanguageConfig.postInlineWarnings_(true) // warn
if(0.5.coin) { var x; x = 10.rand; x + 1 } { 10 };
LanguageConfig.postInlineWarnings_(false) // ignore it.
if(0.5.coin) { var x; x = 10.rand; x + 1 } { 10 };
::


class:: LastValue
summary:: Output the last value before the input changed
related:: Classes/LeastChange, Classes/MostChange
categories::  UGens>Triggers


Description::

Output the last value before the input changed more than a threshold.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::diff

Difference threshold.


Examples::

code::
d = { arg freq=440; SinOsc.ar(LastValue.ar(freq, 20), 0, 0.2) }.play;

d.set(\freq, 400);
d.set(\freq, 200);
d.set(\freq, 670);
d.set(\freq, 680);
d.set(\freq, 695);
d.free;
::

Return the difference between current and the last changed:
code::
(
d = { arg out=0, val=1;
	SinOsc.ar(
			abs(val - LastValue.kr(val)) * 400 + 200,
			0, 0.2
	)
}.play;
)

d.set(\val, 3);
d.set(\val, 2);
d.set(\val, 0.2);
d.set(\val, 1);
d.set(\val, 2);
d.free;
::



class:: Latch
summary:: Sample and hold
related:: Classes/Gate
categories::  UGens>Triggers

Description::
Holds input signal value when triggered. Latch will output 0 until it receives its first trigger.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


Examples::

code::
{ Blip.ar(Latch.ar(WhiteNoise.ar, Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
::

The above is just meant as example. LFNoise0 is a faster way to generate random steps:
code::
{ Blip.ar(LFNoise0.kr(9, 400 ,500), 4, 0.2) }.play;
::



class:: LatoocarfianC
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianN, Classes/LatoocarfianL

description::
A cubic-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

teletype::
	x(n+1) = sin(b * y(n)) + c * sin(b * x(n))
	y(n+1) = sin(a * x(n)) + d * sin(a * y(n))
::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

sclang code translation:

code::
(
var a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;
plot(size.collect { var x = xi;
xi = sin(b * yi) + (c * sin(b * xi));
yi = sin(a * x) + (d * sin(a * yi));
xi
});
)
::

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ LatoocarfianC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianC.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::


class:: LatoocarfianL
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianC, Classes/LatoocarfianN

description::
A linear-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

teletype::
		x(n+1) = sin(b * y(n)) + c * sin(b * x(n))
		y(n+1) = sin(a * x(n)) + d * sin(a * y(n))
::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

sclang code translation:

code::
(
var a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;
plot(size.collect { var x = xi;
xi = sin(b * yi) + (c * sin(b * xi));
yi = sin(a * x) + (d * sin(a * yi));
xi
});
)
::

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ LatoocarfianL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianL.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::

code::
(
{ LatoocarfianL.ar(
	SampleRate.ir/4,
	[LFDNoise0,LFClipNoise,LFDNoise1,LFDNoise3,
		LFNoise0,LFNoise1,LFNoise2].choose.kr(rrand(2,20),rrand(2,20)*0.1,rrand(2,20)*0.2),
		[LFDNoise0,LFClipNoise,LFDNoise1,LFDNoise3,
		LFNoise0,LFNoise1,LFNoise2].choose.kr(rrand(2,20),rrand(2,20)*0.1,rrand(2,20)*0.2),
		[LFDNoise0,LFClipNoise,LFDNoise1,LFDNoise3,
		LFNoise0,LFNoise1,LFNoise2].choose.kr(rrand(2,20),rrand(2,20)*0.1,rrand(2,20)*0.2),
		[LFDNoise0,LFClipNoise,LFDNoise1,LFDNoise3,
		LFNoise0,LFNoise1,LFNoise2].choose.kr(rrand(2,20),rrand(2,20)*0.1,rrand(2,20)*0.2)
) * 0.2 !2}.play;
)
::


class:: LatoocarfianN
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianL, Classes/LatoocarfianC

description::
A non-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

teletype::
        x(n+1) = sin(b * y(n)) + c * sin(b * x(n))
        y(n+1) = sin(a * x(n)) + d * sin(a * y(n))
::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

sclang code translation:

code::
(
var a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;
plot(size.collect { var x = xi;
xi = sin(b * yi) + (c * sin(b * xi));
yi = sin(a * x) + (d * sin(a * yi));
xi
});
)
::

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ LatoocarfianN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianN.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::


Class:: Layout
summary:: Superclass of all GUI layouts
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

description::
Layout is the abstract superclass of all layouts. Any layout can be installed on a view with the view's link::Classes/View#-layout#'layout':: setter method. See link::Guides/GUI-Layout-Management:: for details of operation common to all layouts.


InstanceMethods::

Method:: spacing
The amount of empty pixels left between the managed views.

argument:: spacing
An integer representing the spacing in pixels.


Method:: margins
The amount of empty pixels left between the edges of the parent view and the managed children.

argument:: margins
An array of four integers defining margins in the following order: left margin, top margin, right margin, bottom margin; or an array of two integers applied to left/right margin and top/bottom margin respectively; or a single integer applied to all margins.



Examples::

code::
w = Window.new;
w.layout = HLayout( TextView().string_("One"), TextView().string_("Two") );
w.layout.spacing = 20;
w.layout.margins = [10, 30, 10, 30];
w.front;
::


class:: LazyEnvir
summary:: lazy environment
categories:: JITLib>Environments, Live Coding, Collections>Unordered
related:: Classes/Maybe, Classes/Fdef, Classes/Environment, Classes/ProxySpace, Overviews/JITLib

description::
Environment with deferred evaluation and default values.

Consequently, calculations can be done with nonexisting objects which can then be assigned later.
Per default, a LazyEnvir returns instances of link::Classes/Maybe::. See also link::Classes/Fdef::.

note::While the method put is treated as transparent and implicitly creates a placeholder, all other methods, like at, collect, do, etc. pass the placeholder. In order to retrieve the object itself, use .source - in order to reduce it to a value, use: value::

code::
e = LazyEnvir.new;
e.use { ~x = ~y + ~z };
e.at(\x);
e.at(\x).source; // the source is a binary operation (addition on the placeholders)
e.use { ~y = 5; ~z = 7 };
e.at(\x).value; // the value is 12
::

InstanceMethods::

method::put
Sets the value of the reference at key.

method::at
Returns a reference to the object at key.

code::
l = LazyEnvir.push;

// default objects are created on access
~a;
~a.value; // defaults to nil

// operations on placeholders
(
~c = ~a + ~b;

~c.value; // doesn't fail, instead returns nil
)

// variables can be assigned later
(
~a = 800;
~b = { 1.0.rand };

~c.value;
)

// variables can be exchanged later
(
~b = { 1000.rand };
~c.value;
)
::

method::copy
Copies the environment into a new one, with each placeholder being copied as well.

method::localPut
Sets the value of the key directly. This method is mainly used internally.

method::proxyClass
Specify what placeholder object the environment uses by supplying a class name (link::Classes/Symbol::). The default is a link::Classes/Maybe::. Any object that responds to the methods source, source_ and clear can be a placeholder.

code::

// making a pattern space using LazyEnvir

a = LazyEnvir.new;
a.proxyClass=\PatternProxy;

a.push;

~x = Pseq([1, 2, 30], 1);
~y = Pseq([~x], inf);

z = ~y.asStream;

z.next;
z.next;
z.next;
~x = Pseq([100, 2, 300], 1);
z.next;
z.next;
z.next;

a.pop;
::

method::removeAt
Removes the placeholder from the environment and clears it.

method::makeProxy
Returns a new placeholder object. This is used internally and can be overridden to implement other lazy environments.


class:: LeakDC
summary:: Remove DC
related:: Classes/DC
categories::  UGens>Filters>Linear


Description::

This is a linear filter that removes DC bias from a signal. Specifically, this is a one-pole highpass filter implementing the formula code:: y[n] = x[n] - x[n-1] + coef * y[n-1] ::. The frequency response of this filter is dependent on the sample rate of the server and the calculation rate of the UGen.

classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Leak coefficient.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
{
	var a;
	a = LFPulse.ar(800, 0.5, 0.5, 0.5);
	[a, LeakDC.ar(a, 0.995)]
}.scope(bufsize: 22050)
)
::



class:: LeastChange
summary:: Output least changed
related:: Classes/MostChange, Classes/LastValue
categories::  UGens>Maths


Description::

Given two inputs code::a:: and code::b::, let code::da[t] = abs(a[t] - a[t - 1]):: and code::db[t] = abs(b[t] - b[t - 1])::. Output code::a[t]:: if code::da[t]:: is smaller, and output code::b[t]:: if code::db[t]:: is smaller. If code::da[t] == db[t]::, use whichever input was used last (assume code::a:: for the first sample of output).


classmethods::

method::ar, kr

argument::a

Input signal A.


argument::b

Input signal B.

examples::

code::
(
d = { arg amp=1.0;
	var in1, in2;
	in1 = LFNoise0.ar(800, amp);
	in2 = SinOsc.ar(800);
	LeastChange.ar(in1, in2) * 0.1;
}.play;
)

d.set(\amp, 0.1);
d.set(\amp, 0);
d.set(\amp, 3);
d.free;
::

the control that changed least is used as output:

code::
(
d = { arg freq=440;
	var internalFreq;
	internalFreq = LFNoise0.ar(0.3, 300, 800);
	SinOsc.ar(
		LeastChange.kr(freq, internalFreq) // two sources of change: one external, one internal
	) * 0.1
}.play
);

d.set(\freq, 800);
d.set(\freq, 900);
d.free;
::



CLASS:: LevelIndicator
summary:: a level indicator GUI widget
categories:: GUI>Views
related:: Classes/RangeSlider

DESCRIPTION::
A level indicator view, suitable for use as a level or peak meter, etc.


CLASSMETHODS::
private::key

INSTANCEMETHODS::
private::valueAction

METHOD:: value
Get or set the current level of the view.

argument:: val
A link::Classes/Float:: between 0 and 1.

returns:: A link::Classes/Float::

METHOD:: warning
METHOD:: critical
Set the warning and critical thresholds. If meter value is above either threshold, link::#-warningColor:: or link::#-criticalColor:: will be shown, respectively (by default, yellow and red).
If link::#-drawsPeak:: is true warning color will be displayed based on link::#-peakLevel:: rather than value.

argument:: val
A link::Classes/Float::.

code::
a = LevelIndicator(bounds:Rect(10, 10, 20, 160)).front;
a.value = 0.5;
a.warning = 0.6; a.critical = 0.9;
a.value = 0.7;
a.value = 0.9;
::

METHOD:: style
Sets the style of the view.

argument:: val
An link::Classes/QLevelIndicatorStyle:: \continuous or \led (see link::#-stepWidth::)

code::
(
w = Window().front.layout_(
	HLayout(
		LevelIndicator().style_(\continuous).value_(1/3),
		LevelIndicator().style_(\led).value_(2/3),
)
)
)
::

METHOD:: stepWidth
The width of each led light, for \led.

argument:: val
An positive link::Classes/Integer::.

code::
(
w = Window().front.layout_(HLayout(
	LevelIndicator().style_(\led).value_(0.8).stepWidth_(1),
	LevelIndicator().style_(\led).value_(0.8).stepWidth_(3),
	LevelIndicator().style_(\led).value_(0.8).stepWidth_(10),
	LevelIndicator().style_(\led).value_(0.8).stepWidth_(50),
));
)
::

METHOD:: numSteps
The number of steps used in \led style.

argument:: val
An positive link::Classes/Integer::.

code::
(
a = LevelIndicator(bounds:Rect(10, 10, 80, 400)).front();
a.value = 1;
a.style = \led;
a.numSteps = 4;
)
::

METHOD:: image
note:: Not yet implemented in Qt GUI ::

argument:: image
An link::Classes/Image::. The default image is the SC cube.

METHOD:: numTicks
The number of ticks to display in the view's scale.

argument:: number
An link::Classes/Integer:: >= 0.

code::
(
w = Window(bounds:100@400).front().background_(Color.black);
w.layout_(HLayout(
	LevelIndicator()
		.numTicks_(16)
		.value_(0.75)
))
)
::

METHOD:: numMajorTicks
The number of ticks in the view's scale which will be large sized.

argument:: number
An link::Classes/Integer:: >= 0.

code::
(
w = Window(bounds:100@400).front().background_(Color.black);
w.layout_(HLayout(
	LevelIndicator()
		.numMajorTicks_(16)
		.numTicks_(16)
		.value_(0.75)
))
)
::

METHOD:: drawsPeak
Determines whether the view draws a separate peak display. This can be useful for displaying both peak and RMS values. If drawsPeak is true link::#-warning:: and link::#-critical:: will be displayed based on link::#-peakLevel:: rather than value.

argument:: bool
A link::Classes/Boolean::. By default the peak is not drawn.

code::
(
w = Window().front().layout_(HLayout(
	LevelIndicator().style_(\continuous).value_(0.75).drawsPeak_(true).peakLevel_(0.9),
	LevelIndicator().style_(\led).value_(0.75).drawsPeak_(true).peakLevel_(0.9)
))
)
::

METHOD:: peakLevel
Sets the level of the peak display. (See link::#-drawsPeak::.)

argument:: val
A link::Classes/Float::.

code::
(
w = Window().front().layout_(HLayout(
	LevelIndicator().style_(\continuous).value_(0.1).drawsPeak_(true).peakLevel_(0.3),
	LevelIndicator().style_(\continuous).value_(0.1).drawsPeak_(true).peakLevel_(0.5),
	LevelIndicator().style_(\continuous).value_(0.1).drawsPeak_(true).peakLevel_(0.7),
	LevelIndicator().style_(\continuous).value_(0.1).drawsPeak_(true).peakLevel_(0.9),
))
)
::

METHOD:: meterColor
METHOD:: warningColor
METHOD:: criticalColor
Sets the color of the meter, as well as the warning and critical colors.

argument:: color
A link::Classes/Color::.

code::
(
l = LevelIndicator(bounds:Rect(100, 100, 100, 400)).front().value_(1).style_(\led);
l.meterColor = Color.blue(0.9);
l.warningColor = Color.blue(0.7);
l.criticalColor = Color.blue(0.5);
)
::
code::
(
// inverse
l.background = Color.blue;
l.meterColor = Color.black.alpha_(1);
l.warningColor = Color.black.alpha_(1);
l.criticalColor = Color.black.alpha_(0.3);
)
::


EXAMPLES::

code::
(
// something to meter
s.waitForBoot({
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

	x = {
		var colum, noise, imp, delimp, mul = 1;
	imp = Impulse.kr(10);
	delimp = Delay1.kr(imp);
	colum = PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * mul;
	// measure rms and Peak
	SendReply.kr(imp, '/levels', [Amplitude.kr(colum), K2A.ar(Peak.ar(colum, delimp).lag(0, 3))]);
	colum;
}.play;

	a = LevelIndicator(bounds:Rect(100, 100, 100, 400)).front;
	a.onClose_({ x.free; o.free; });
o = OSCFunc({arg msg;
	{
		a.value = msg[3].ampdb.linlin(-40, 0, 0, 1);
		a.peakLevel = msg[4].ampdb.linlin(-40, 0, 0, 1);
	}.defer;
}, '/levels', s.addr);
})
)

(
a.warning = -6.dbamp;
a.critical = -3.dbamp;
)
// optionally show peak level
a.drawsPeak = true;

(
a.style = \led;
a.stepWidth = 3;
)

// different colors
(
a.meterColor = Color.blue(0.9);
a.warningColor = Color.blue(0.8);
a.criticalColor = Color.blue(0.6);
)
// all styles can have ticks
(
a.background = Color.clear;
a.numTicks = 11; // includes 0;
)

// Single blinking square level indicator
(
a.style = \led;
a.numTicks = 0;
a.drawsPeak = false;
a.bounds = a.bounds.resizeTo(90, 90);
a.numSteps = 1;
)


::


CLASS::Library
summary::keeping objects in a central place
related::Classes/Archive, Classes/LibraryBase
categories:: Collections

DESCRIPTION::
Library is a global MultiLevelIdentityDictionary.
The Library can be used as a place to store data that you want globally accessible. It is an alternative to using class variables. It is a nice place to store menus, annotations, and commonly reusable functions.

CLASSMETHODS::

private::initClass

method::postTree
Post a formatted description of the entire library.
code::
Library.postTree;
::

method::put
The last argument to put is the object being inserted:
code::
Library.put(\multi, \level, \addressing, \system, "i'm the thing you are putting in here");
Library.at(\multi, \level, \addressing, \system).postln;
Library.atList([\multi, \level, \addressing, \system]).postln;
::



CLASS::LibraryBase
summary::Abstract global storage class
categories:: Collections

DESCRIPTION::
Base class for link::Classes/Library:: and link::Classes/Archive::

There is only one global instance: Archive.global, or Library.global, which is initialized automatically in the subclasses.

CLASSMETHODS::

method::global
Subclass responsibility

method::clear
Clear the dictionary

method::at
Access the dictionary at a path with keys. The keys may be any object, but are usually link::Classes/Symbol::s.

method::put
Store an object in the dictionary at a path, given as a list of keys and the object to be stored as last argument. The keys may be any object, but are usually link::Classes/Symbol::s.

method::atList
Access the dictionary at a path, given as a list of keys. The keys may be any object, but are usually link::Classes/Symbol::s.

method::putList
Store an object in the dictionary at a path, given as a list of keys and the object to be stored as last argument. The keys may be any object, but are usually link::Classes/Symbol::s.

EXAMPLES::

code::
// an example from the subclass Library:

Library.put(\multi, \level, \addressing, \system, "i'm the thing you are putting in here");
Library.at(\multi, \level, \addressing, \system).postln;
Library.atList([\multi, \level, \addressing, \system]).postln;
::


class:: Limiter
summary:: Peak limiter
related:: Classes/Amplitude, Classes/Compander, Classes/CompanderD, Classes/Normalizer
categories:: UGens>Dynamics


Description::

Limits the input amplitude to the given level. Limiter will not overshoot
like  link::Classes/Compander::  will, but it needs to look ahead in the
audio. Thus there is a delay equal to twice the value of the
code::dur::  parameter.

Limiter, unlike Compander, is completely transparent for an in range signal.

classmethods::

method::ar

argument::in
The signal to be processed.

argument::level
The peak output amplitude level to which to normalize the input.

argument::dur
aka lookAheadTime.
The buffer delay time. Shorter times will produce smaller delays
and quicker transient response times, but may introduce amplitude
modulation artifacts.


Examples::

code::
(
// example signal to process
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
}, 0.8)
)

(
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
	[z, Limiter.ar(z, 0.4, 0.01)]
}, 0.5)
)
::



class:: LinCongC
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongN, Classes/LinCongL

description::
A cubic-interpolating sound generator based on the difference equation:

teletype::
	x(n+1) = (a * x(n) + c) % m
::

The output signal is automatically scaled to a range of [-1, 1].

sclang code translation:

code::
(
var a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;
plot(size.collect { xi = (a * xi + c) % m });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x

examples::
code::
// default initial params
{ LinCongC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongC.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongC.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::


class:: LinCongL
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongC, Classes/LinCongN

description::
A linear-interpolating sound generator based on the difference equation:

teletype::
        x(n+1) = (a * x(n) + c) % m
::

The output signal is automatically scaled to a range of [-1, 1].

sclang code translation:

code::
(
var a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;
plot(size.collect { xi = (a * xi + c) % m });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x

examples::
code::
// default initial params
{ LinCongL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongL.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongL.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::


class:: LinCongN
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongL, Classes/LinCongC

description::
A non-interpolating sound generator based on the difference equation:

teletype::
        x(n+1) = (a * x(n) + c) % m
::

The output signal is automatically scaled to a range of [-1, 1].

sclang code translation:

code::
(
var a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;
plot(size.collect { xi = (a * xi + c) % m });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x
argument:: mul
argument:: add

examples::
code::
// default initial params
{ LinCongN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongN.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongN.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::


class:: LinExp
summary:: Map a linear range to an exponential range
related:: Classes/LinLin
categories::  UGens>Maths


Description::

Converts a linear range of values to an exponential range of values.

classmethods::

method::ar, kr

argument::in

The input signal to convert.


argument::srclo

Lower limit of input range.


argument::srchi

Upper limit of input range.


argument::dstlo

Lower limit of output range.


argument::dsthi

Upper limit of output range.

discussion::
The code::dstlo::  and  code::dsthi::  arguments
must be nonzero and have the same sign.


Examples::

code::
// compare:
(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(mod * 400 + 500) * 0.1
}.play;
)

(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(LinExp.kr(mod, -1,1, 100, 900)) * 0.1
}.play;
)

// modulating destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(LinExp.ar(mod, -1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)
::

code::linexp:: and code::exprange:: can be used to create a LinExp implicitly from a ugen, mapping its output values from linear range to an exponential one. The rate is derived from the ugen.

code::
// linexp
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(mod.linexp(-1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// exprange
(
{
	var mod = LFNoise2.ar(80).exprange(MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1));
	SinOsc.ar(mod) * 0.1
}.play;
)
::



class:: LinLin
summary:: Map a linear range to another linear range
related:: Classes/LinExp
categories::  UGens>Maths


Description::

Maps a linear range of values to another linear range of values.


classmethods::

method::ar, kr

argument::in

The input signal to convert.


argument::srclo

Lower limit of input range.


argument::srchi

Upper limit of input range.


argument::dstlo

Lower limit of output range.


argument::dsthi

Upper limit of output range.


Examples::

code::
// examples:

(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(LinLin.kr(mod, -1,1, 100, 900)) * 0.1
}.play;
)

// modulating destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(LinLin.ar(mod, -1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// modulating source and destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(
		LinLin.ar(mod,
			SinOsc.kr(0.2), SinOsc.kr(0.2543),
			MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1)
		)
	) * 0.1
}.play;
)
::

linlin and range can be used to create a LinLin implicitly from a ugen, mapping its output values from linear range to an exponential one. The rate is derived from the ugen.

code::
// linlin
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(mod.linlin(-1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// range
(
{
	var mod = LFNoise2.ar(80).range(MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1));
	SinOsc.ar(mod) * 0.1
}.play;
)
::



class:: LinPan2
summary:: Two channel linear pan.
related:: Classes/Balance2, Classes/Pan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::
Two channel linear panner. The signal is lowered as it pans from left (or right) to center using a straight line from 1 (left or right) to 0.5 (center) for a 6dB reduction in the middle. A problem inherent to linear panning is that the perceived volume of the signal drops in the middle. Pan2 solves this by taking the square root of the linear scaling factor going from 1 (left or right) to 0.5.sqrt (~=0.707) in the center, which is about 3dB reduction. This is equal power panning.
LinPan2 sounds more like the Rhodes tremolo than Pan2.

classmethods::

method::ar, kr

argument::in

The input signal.


argument::pos

Pan position, -1 is left, +1 is right.


argument::level

A control rate level input.


Examples::

code::
// hear the difference, LinPan having a slight drop in the middle (yeah, it's subtle)...
{ LinPan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play;

// ... whereas Pan2 is more smooth
{ Pan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play;

// other examples
{ LinPan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2)) }.play;

{ LinPan2.ar(FSinOsc.ar(800, 0, 0.1), FSinOsc.kr(3)) }.play;
::



class:: LinRand
summary:: Skewed random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in linear distribution from
code::lo::  to  code::hi:: , skewed towards
code::lo::  if  code::minmax::  < 0, otherwise
skewed towards  code::hi:: .


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::minmax
The output is skewed towards code::lo:: if code::minmax:: < 0, otherwise skewed towards code::hi::.

Examples::

code::

(
SynthDef("help-LinRand", { arg out=0, minmax=1;
	Out.ar(out,
		FSinOsc.ar(
			LinRand(200.0, 10000.0, minmax),
			0, Line.kr(0.2, 0, 0.01, doneAction: Done.freeSelf))
	)
}).add;
)

//towards hi
(
Routine({
	loop({
		Synth.new("help-LinRand"); 0.04.wait;
	})
}).play;
)

//towards lo (doesn't work like that yet)
(
Routine({
	loop({
		Synth.new("help-LinRand", [\minmax, -1]); 0.04.wait;
	})
}).play;
)

::



class:: LinSelectX
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectX, Classes/SelectXFocus

description::
The output is mixed from an array of inputs, linearly interpolating from two adjacent channels.

classmethods::
method:: ar, kr

argument:: which
argument:: array
argument:: wrap

examples::
code::
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar(300),
			Pulse.ar(230)
		];

	LinSelectX.ar(MouseX.kr(0, 1) * a.size, a) * 0.2
}.play;
)

(
{
	var a;
	a = [
			SinOsc.kr(0.25),
			LFSaw.kr(10),
			LFPulse.kr(0.3)
		];

	SinOsc.ar(LinSelectX.kr(MouseX.kr(0, 1) * a.size, a) * 300 + 400) * 0.2
}.play;
)
::

note::
all the ugens are continuously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

wrap does not work yet.

(by adc)


class:: LinXFade2
summary:: Two channel linear crossfade.
related:: Classes/XFade2
categories::  UGens>Multichannel>Select


Description::

Two channel linear crossfader.


classmethods::

method::ar, kr

argument::inA

Input signal A.


argument::inB

Input signal B.


argument::pan

Cross fade position from -1 to +1.


argument::level

A control rate level input.


Examples::

code::

play({ LinXFade2.ar(FSinOsc.ar(800, 0, 0.2), PinkNoise.ar(0.2), FSinOsc.kr(1)) });

::



class:: Line
summary:: Line generator.
related:: Classes/XLine
categories::  UGens>Envelopes


Description::

Generates a line from the start value to the end value.


classmethods::

method::ar, kr

argument::start

Starting value.


argument::end

Ending value.


argument::dur

Duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


argument::doneAction

A doneAction to be evaluated when the Line is completed. See

link::Classes/Done::  for more detail.


Examples::

code::

// XLine is usually better than Line for frequency
play({ SinOsc.ar(Line.kr(200,17000,10),0,0.1) });

::



CLASS:: LineLayout
summary:: Superclass of layouts that distribute views in a line
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

DESCRIPTION::
This is an abstract superclass of link::Classes/HLayout:: and link::Classes/VLayout:: which distribute views in a horizontal or vertical line, respectively.

subsection:: Fine tuning

Each item can be assigned a strong::stretch factor:: and an strong::alignment:: flag to fine tune how its size and position are managed. This can be done at layout link::#*new#construction::, when an item is link::#-add#added:: or link::#-insert#inserted:: or for an already present item with link::#-setStretch:: and link::#-setAlignment:: methods.

The strong::stretch factor:: only affects distribution in the direction of the layout (vertical or horizontal). All items have a stretch factor of 0 by default, so only their own preferences will determine space distribution. As soon as an item is assigned a stretch factor higher than 0, the space will be redistributed according to proportions of stretch factors.

subsection:: Leaving empty space

An empty space with an arbitrary stretch factor may be inserted using nil in place of an item in combination with the stretch factor. Similarly, an empty space of fixed size may be inserted using an integer in place of an item. See link::#*new#constructor:: and link::#-add:: for details.


CLASSMETHODS::

PRIVATE:: layoutClass
PRIVATE:: parse

METHOD:: new

Create a link::Classes/HLayout:: or a link::Classes/VLayout:: and immediately fill it with items given as arguments. (Note that LineLayout is an abstract class and can not be instantiated, but HLayout and VLayout inherit this constructor).

argument:: ... items
Each item can be a strong::view::, a strong::layout::, strong::nil:: (for stretchable empty space) or an strong::Integer:: (for fixed-size empty space).

discussion::

You can assign a strong::stretch factor:: and/or strong::alignment:: to an item by wrapping it into an array, followed by pairs of ('stretch', factor) and/or ('align', alignment). 'stretch' and 'align' may be abbreviated with 's' and 'a'. Simplified syntax for placing key-value pairs into an array comes handy (see link::Reference/Syntax-Shortcuts#Creating arrays with key-value pairs::, and the example below). For possible alignment values see link::Reference/gui_alignments::.

If the item is a stretchable empty space (nil) alignment will have no effect; if the item is a fixed-size empty space (an Integer), it is unaffected by both the stretch factor and alignment.

Example:
code::
w = Window.new;
w.layout = VLayout(
	[Button().states_([["Foo"]]), stretch:1, align:\bottomLeft],
	20,
	[TextView().string_("Bar\nBar\nBar\n"), s:3],
	[nil, s:1]
);
w.front;
::


INSTANCEMETHODS::

METHOD:: add
Add an item to the right or the bottom end of the line, for HLayout and VLayout respectively.

argument:: item
The item can be a strong::view::, a strong::layout::, an strong::Integer:: (specifying amount in pixels of empty space) or strong::nil:: (for stretchable empty space).

argument:: stretch
An integer stretch factor.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.

discussion::
If the item is a stretchable empty space (nil) the align argument will have no effect; if the item is a fixed-size empty space (an Integer) both stretch and align arguments will have no effect.


METHOD:: insert
Insert an item at a specific position.

argument:: item
The item can be a strong::view::, a strong::layout::, an strong::Integer:: (specifying amount in pixels of empty space) or strong::nil:: (for stretchable empty space).

argument:: index
The integer position among current items at which to insert the new item. If index is smaller than 0 or larger than the current amount of items, the new item will always be added to the end of the line.

argument:: stretch
An integer stretch factor.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.

discussion::
If the item is a stretchable empty space (nil) the align argument will have no effect; if the item is a fixed-size empty space (an Integer) both stretch and align arguments will have no effect.



METHOD:: setStretch
Set stretch factor of an item contained in the layout.

argument:: item
A view or layout managed by this layout, or an Integer index of an item.

argument:: stretch
An integer stretch factor.



METHOD:: setAlignment
Set alignment of an item contained in the layout.

argument:: item
A view or a layout managed by this layout, or an Integer index of an item.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.


EXAMPLES::

Try resizing the window created by the following code.

code::
w = Window.new;
w.layout = VLayout(
	TextView().string_("Foo\nBar\nFoo\nBar\nFoo"),
	HLayout(
		Button().states_([["Foo"]]),
		[TextField().string_("Bar"), stretch:1],
		[TextField().string_("BarBarBar"), stretch:4]
	)
);
w.front;
::


CLASS:: LinearGridLines
summary:: Calculates the numerical values suitable for linearly-spaced grid lines to be used for plotting or other UI elements.
categories:: GUI>Accessories
related:: Classes/GridLines, Classes/AbstractGridLines, Classes/ExponentialGridLines, Classes/DrawGrid, Classes/ControlSpec, Classes/Plotter, Reference/plot

DESCRIPTION::
code::LinearGridLines:: is a strategy object that finds suitable intervals for plotting grid lines and labels. The values span the range defined by a corresponding link::Classes/ControlSpec::. Most of the functionality of code::LinearGridLines:: is inherited from its superclass, link::Classes/AbstractGridLines::. The instance methods are used by link::Classes/DrawGrid:: (which is in turn used by link::Classes/Plotter::) which handles the drawing of the lines and labels.

code::LinearGridLines:: isn't usually instantiated directly, but rather by the link::Classes/GridLines:: factory class or the link::Classes/ControlSpec#-grid:: method which return the appropriate code::AbstractGridLines:: subclassfor the given spec.

code::
(
// LinearGridLines
var linGrid = ControlSpec(0, 100, \lin, units: "Time").grid;
// ExponentialGridLines
var expGrid = \freq.asSpec.grid;

DrawGrid.test(linGrid, expGrid);
)
::

CLASSMETHODS::

COPYMETHOD:: AbstractGridLines *new

INSTANCEMETHODS::

COPYMETHOD:: AbstractGridLines -spec
COPYMETHOD:: AbstractGridLines -asGrid
COPYMETHOD:: AbstractGridLines -niceNum
COPYMETHOD:: AbstractGridLines -looseRange
COPYMETHOD:: AbstractGridLines -getParams
COPYMETHOD:: AbstractGridLines -formatLabel

private:: prCheckWarp, ideals


class:: Linen
summary:: Simple linear envelope generator.
categories::  UGens>Envelopes
related:: Classes/EnvGen

Description::

Simple linear envelope generator.


classmethods::

method::kr

argument::gate

This triggers the envelope and holds it open while > 0.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::Classes/EnvGen#Forced release::.

argument::attackTime

The duration of the attack portion.


argument::susLevel

The level of the sustain portion.


argument::releaseTime

The duration of the release portion.


argument::doneAction

An integer representing an action to be executed when the
envelope is finished. See
link::Classes/Done::  for
more detail.


Examples::

code::

// trigged
(
SynthDef("help-Linen",{ arg out = 0;
	Out.ar(out,
		Linen.kr(Impulse.kr(2), 0.01, 0.6, 1.0, doneAction: Done.none) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

// play once and end the synth
(
SynthDef("help-Linen",{ arg out=0;
	Out.ar(out,
		Linen.kr(Impulse.kr(0), 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

// play once and sustain
(
x = SynthDef("help-Linen",{ arg gate = 1, out = 0; // use gate arg for release
	Out.ar(out,
		Linen.kr(gate, 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)
x.release(4); // change the release time

// longer gate, can pass in duration
(
SynthDef("help-Linen",{ arg out = 0, dur = 0.1;
	var gate;
	gate = Trig.kr(1.0, dur);
	Out.ar(out,
		Linen.kr(gate, 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)
	)
}).play(nil, [\out, 0, \dur, 2.0]);
)



// used below in a Routine varying the releaseTime
(
SynthDef("help-Linen",{ arg out=0,freq=440,attackTime=0.01,susLevel=0.6,releaseTime=0.1;
	Out.ar(out,
		Linen.kr(Impulse.kr(0), attackTime, susLevel, releaseTime, doneAction: Done.freeSelf)
			* SinOsc.ar(freq, 0, 0.1)
	)
}).add;
)

(
// debussey sleeping through math class
x = Pbrown(0.01, 2.0, 0.2, inf).asStream;
Routine({
	loop({
		Synth.grain("help-Linen",[\freq, (rrand(20, 50) * 2).midicps, \releaseTime, x.next]);
		0.25.wait;
	})
}).play(TempoClock.default)
)





(
SynthDef("help-Linen",{ arg out = 0;
	Out.ar(out,

		Linen.kr(Impulse.kr(2),
			0.01,
			// sustain level is polled at time of trigger
			FSinOsc.kr(0.1).range(0, 1),
			1.0,
			doneAction: Done.none)

			* SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

::


class::LinkClock
categories::Scheduling>Clocks
summary::Scheduler synchronized with Ableton Link
related::Classes/TempoClock

Description::

LinkClock is a link::Classes/TempoClock:: based on link::https://www.ableton.com/en/link/##Ableton Link::, a protocol
that synchronizes phase (beat-within-bar) and tempo over a local network.

Subsection:: Link behavior

Link attempts, as much as possible, to allow applications to move in their own time while synchronizing:

list::
## Tempo: Any application can change the tempo at any time.
## Beat: Integer beats should sound at the same time in all applications.
## Phase (analogous to SuperCollider's link::Classes/TempoClock#-beatInBar::): A downbeat in one peer should correspond to a downbeat in other peers.
::

Link does not synchronize exact beat numbers. Two SuperCollider peers joining the same Link session, in 4/4 time, may be respectively at beats 4 and 16 (which are both barlines), but they should not be at beats 4.0 and 19.0.

Many Link-enabled applications (DAWs) can start and stop the entire timeline. SuperCollider clocks do not stop. A DAW, when starting to play, should lock into SuperCollider's phase within the bar. You can register functions to respond to other peers starting or stopping. (SuperCollider does not know which other peer started or stopped.)

Subsection:: Latency

Link coordinates the emphasis::sounding time:: of given beats.

All audio applications must prepare events, and audio processing, in advance, so that the signal hits the audio interface at the right time. SuperCollider uses OSC timestamps for this purpose, calculating timestamps from the current time in seconds + a teletype::latency:: offset.

To coordinate with other applications, then, the code::LinkClock:: must run earlier than the desired sounding time, by the same fixed offset. That is, it should have the same (positive) latency offset as the server:

code::
t = LinkClock.new.latency_(Server.default.latency);
::

Server messages should then be sent with the same amount of latency. Events generated by patterns automatically apply the server object's latency. For other messages, use link::Classes/Server#-makeBundle::.

With a positive latency, if you examine code::t.beats::, it will appear to be later than the beats shown in other applications. This is normal. The clock in SuperCollider must run early for the events to sound on time.

(Because the clock and server have separate latency settings, it is possible to adjust timing relative to other applications. If you find, for instance, that SuperCollider is sounding slightly late, you can increase the LinkClock's latency slightly, moving the clock earlier, without affecting messaging latency. Ideally, this should not be necessary, but inter-application coordination can be fiddly.)

This does have an impact on tempo changes. SuperCollider receives tempo changes from other peers only after they are sent, which is probably slightly late for our clock. In practice, it means that events falling within the latency gap may be slightly out of sync, but sync should recover very quickly. (So, Link is not ideal for music involving frequent tempo or meter changes.)

Subsection:: beatsPerBar and quantum

For every moment in time, Ableton Link knows the beat, time in seconds, and emphasis::phase::. Phase is measured relative to a emphasis::quantum::. Link peers sharing the same quantum will synchronize barlines.

For instance, assume quantum = 4. Peer A is currently at beat 33. Peer B joins the network. Peer A's last barline was beat 32, so phase = 1. Peer B's beat counter should arrange to have the same phase: in practice, it will start with -3.

table::
## strong::Phase:: || strong::Peer A beats:: || strong::Peer B beats:: || Notes
## 0 || 32 || -- ||
## 1 || 33 || -3 || Link calculates -3 for B
## 2 || 34 || -2 ||
## 3 || 35 || -1 ||
## 0 || 36 || 0 || Barline (synced)
::

If you change the quantum, Link does not guarantee that beats will keep the same duration. Beats may be shorter or longer, to try to preserve phase sync.

Therefore, you should emphasis::not:: change the quantum in the middle of a performance. Ableton recommends to set the quantum just before beginning. Then, you can change SuperCollider's code::beatsPerBar:: as needed, without changing the quantum, so that Link's phase reference remains consistent.

SuperCollider peers may optionally synchronize barlines and all meter changes by using link::Classes/LinkClock#-enableMeterSync::. This is independent of Link's quantum, and is safe to use mid-performance. See link::Classes/MeterSync::.

Subsection:: Notifications

A LinkClock's state may be changed by other connected Link peers. LinkClock uses dependant notifications to relay the new state to other interested objects.

table::
## strong::Notification:: || strong::Event::
## code::\tempo:: || Tempo changed
## code::\meter:: || The clock's code::beatsPerBar:: changed
## code::\linkStart:: || An external peer started playback
## code::\linkStop:: || An external peer stopped playback
## code::\numPeers:: || The number of connected peers changed
## code::\resynced:: || After link::#-enableMeterSync::, a code::\resynced:: notification is sent whenever a link::Classes/MeterSync#-resyncMeter:: call finishes successfully. One Boolean argument is passed: code::true:: if other SuperCollider peers were found, code::false:: if not.
::

(Note that Link does not synchronize meter across peers; this notification is inherited from TempoClock. link::Classes/LinkClock#-isSyncingMeter:: is a SuperCollider-specific way to synchronize meter; it is not part of the Link protocol.)

The most convenient way to register to receive a notification is link::Classes/SimpleController::. See the examples below.

Classmethods::

method::new
Creates a new instance of LinkClock.

argument:: tempo
The initial link::#-tempo#tempo::. Defaults to code::1::.

argument:: beats
The time in beats, corresponding to the reference time. Default to code::0::.

argument:: seconds
The reference time in seconds. See link::Classes/TempoClock#*new::.

argument:: queueSize
The storage size of the scheduling queue. See link::Classes/TempoClock#*new::.

discussion::
If an existing Link session is found on the local network, the object connects
to it and use its properties: the code::tempo:: argument is discarded in favor
of the session tempo, and the code::beat:: argument will be adjusted to ensure
proper beat and phase synchronization across all peers.
If SuperCollider is the first to join, a new Link session is locally
created and initialized with the constructor arguments.

method::newFromTempoClock
Creates a new instance of LinkClock derived from a link::Classes/TempoClock::.

argument::clock
The link::Classes/TempoClock:: used to create the LinkClock.

discussion::
The LinkClock link::#-tempo#tempo::, link::#-beats#beats::,
link::#-seconds#seconds:: and link::#-beatsPerBar#beatsPerBar:: values are
set to those of the TempoClock. The TempoClock is then stopped and all of its
tasks are rescheduled by the newly created LinkClock, so that they are now
synchronized with the Link session.

Instancemethods::

private:: prInitFromTempoClock, prSetQuantum, prStart, prTempoChanged, prStartStopSync, prNumPeersChanged, setMeterAtBeat, setTempoAtBeat, setTempoAtSec

method:: latency
Gets or sets the number of seconds of OSC messaging latency for which the code::LinkClock:: should account. In general, this should be set to match the server object's latency.

argument:: lat
A Float.

method:: tempo
Sets or gets the current session tempo at the current logical
time. Note that the tempo may be changed at any time by another peer;
the LinkClock broadcasts a code::\tempo:: notification in this case
(see link::Classes/LinkClock#Notifications::).

method:: beats
Sets or gets the current logical time in beats. If you are trying to set
the beats, Link may adjust your given value to maintain sync with other peers.

method:: numPeers
Gets the number of peers connected to the current Link session. When
peers join or leave the session, the LinkClock broadcasts a
code::\numPeers:: notification (see
link::Classes/LinkClock#Notifications::).

method:: quantum
Gets or sets Link's internal quantum (see above, link::#beatsPerBar and quantum::). Normally this should be done at the beginning of a performance, or not at all. It is risky to change quantum during a performance. Changing meter locally is the same as in TempoClock: link::Classes/TempoClock#-beatsPerBar::.

argument:: quantum
An Integer or Float.

method:: enableMeterSync
Activates SuperCollider-barline sync by creating a link::Classes/MeterSync:: object internally. (If already enabled, no new object will be created.)

argument:: id
Optional: An integer ID, uniquely identifying this instance. If not provided, one will be chosen randomly.

argument:: ports
Optional: An array of port numbers, to which barline-sync messages will be sent.

returns:: The LinkClock instance (to support chaining configuration methods, e.g. code::l = LinkClock.new.latency_(s.latency).enableMeterSync::, in which case you want code::l:: to be the clock object). To get access to the MeterSync object, use link::#-getMeterSync::.

method:: disableMeterSync
Remove all barline-sync objects.

method:: isSyncingMeter
returns:: A Boolean, code::true:: if barline sync is active, code::false:: if not. (If you create the barline sync object independently, this answer is likely to be incorrect.)

method:: getMeterSync
returns:: The MeterSync object previously created by link::#-enableMeterSync::.

note:: It is possible, though redundant and not recommended, to create multiple barline-sync objects by doing code::clock.enableMeterSync:: and code::m = SCClockMeterSync(clock)::. code::getMeterSync:: has access emphasis::only:: to the object created by code::clock.enableMeterSync::. Therefore, it is recommended to use code::clock.enableMeterSync:: in all cases. ::

Examples::

code::
(
s.waitForBoot({
	SynthDef(\click, { |freq=400, amp=0.2|
		var sig = SinOsc.ar(freq, 0.5pi) *
			Env.perc(0.001,0.06).ar(Done.freeSelf, levelScale: amp);
		OffsetOut.ar(0, sig.dup)
	}).add;
});
)

// create a synchronized clock
l = LinkClock(1).latency_(Server.default.latency);

// GUI to watch status
(
var win = Window("LinkClock", Rect(200, 200, 500, 100)).front,
peersBox, tempoBox, barsBox, beatsBox,
font = Font.default.copy.size_(32),
boldFont = font.boldVariant,
controller, task;

win.layout = HLayout(
	StaticText().font_(font).string_("Peers:"),
	peersBox = NumberBox().font_(boldFont).align_(\center).fixedWidth_(80),
	StaticText().font_(font).string_("Tempo:"),
	tempoBox = NumberBox().font_(boldFont).align_(\center).fixedWidth_(120),
	StaticText().font_(font).string_("Now:"),
	barsBox = NumberBox().font_(boldFont).align_(\center).fixedWidth_(80),
	beatsBox = NumberBox().font_(boldFont).align_(\center).fixedWidth_(80)
);

[peersBox, barsBox, beatsBox].do { |view| view.enabled_(false) };

tempoBox.action = { |view| l.tempo = view.value / 60 };
tempoBox.value = l.tempo * 60;
peersBox.value = l.numPeers;

task = Routine {
	var bars, beats;
	loop {
		bars = l.bar;
		beats = l.beatInBar;
		{
			barsBox.value = bars;
			beatsBox.value = beats;
		}.defer(l.latency);
		1.0.wait;
	}
}.play(l, quant: 1);

controller = SimpleController(l)
.put(\tempo, {
	defer { tempoBox.value = l.tempo * 60 }
})
.put(\numPeers, {
	defer { peersBox.value = l.numPeers }
})
.put(\stop, { defer { win.close } });

win.onClose = { task.stop; controller.remove };
)

// now launch a program using Ableton Link to test synchronization

// patterns automatically apply server latency,
// so this should be in sync
p = Pbind(\instrument, \click, \freq, Pseq([900, Pn(400,3)], inf)).play(l, quant:4);

// In Tasks, you should handle latency yourself:
(
r = Task {
	loop {
		s.makeBundle(s.latency, {
			Synth(\click, [freq: exprand(500, 1200)])
		});
		1.wait;
	}
}.play(l, quant: 4);
)

// changing the tempo in another application should affect tempo in SC
// changing the tempo in SC should affect every connected application
l.tempo = 90/60;

// start/stop notifications
// the remote peer should enable start/stop sync
(
q = nil;
c = SimpleController(l)
.put(\linkStart, {
	if(q.isNil) {
		q = Pbind(
			\degree, Pn(Pseries(0, 1, 8), inf),
			\dur, 0.25
		).play(l, quant: -1);
	}
})
.put(\linkStop, {
	q.stop;
	q = nil;
})
.put(\stop, { c.remove });  // clean up if clock stops
)

p.stop;
r.stop;
l.stop;
::


CLASS::LinkedList
summary::doubly linked list
categories:: Collections>Ordered

DESCRIPTION::
LinkedList implements a doubly linked list.

Most methods are inherited from the superclasses.

INSTANCEMETHODS::

method::addFirst
Add an item to the head of the list.

method::add
Add an item to the tail of the list.

method::remove
Remove an item from the list.

method::pop
Remove and return the last item in the list.

method::popFirst
Remove and return the first item in the list.

method::first
Return the first item in the list.

method::last
Return the last item in the list.

method::at
Return the item at the given index in the list.
This requires a scan of the list and so is O(n).

method::put
Put the item at the given index in the list.
This requires a scan of the list and so is O(n).

method::removeAt
Remove and return the item at the given index in the list.
This requires a scan of the list and so is O(n).


CLASS::LinkedListNode
summary:: Internally used class for LinkedList nodes
categories:: Collections

DESCRIPTION::
LinkedListNode is used to implement the internal nodes of the link::Classes/LinkedList:: class.
You should not need to deal with a LinkedListNode directly.


class:: LinuxPlatform
summary:: Linux platform-specific methods
categories:: Platform

description::
This class is available only on Linux, and implements Linux platform-specific methods.

subsection:: Environment variables for Jack
Among other things, this class makes it possible to set some environment variables in your Linux operating system to automate connecting the Jack Audio Server on startup.

See link::Reference/AudioDeviceSelection#Linux:: for more information on this.

classmethods::

subsection:: Setting or finding a terminal emulator
method:: runInTerminalCmd
get or set the preferred command to invoke a terminal emulator when performing link::Classes/String#-runInTerminal::.

If code::nil:: (which is the default), sclang will search for a supported terminal emulator installed on the system, the first time code::runInTerminal:: is called (see link::#*getTerminalEmulatorCmd::).
note:: this setting doesn't persist across sessions ::
argument:: value
a string, which has to necessarily include strong::two:: code::%::. For example:
code::
LinuxPlatform.runInTerminalCmd = "xterm -T % -e %"
::
The first code::"%":: is a placeholder for the window title, and the second is a placeholder for the actual command to be executed. Refer to your terminal emulator's documentation to find appropriate command line flags.

method:: getTerminalEmulatorCmd
scans the system for a supported terminal emulator. This method runs synchronously, and could block other scheduled operations while searching. If you rely on link::Classes/String#-runInTerminal::, it is recommended to run this method before you start scheduling Patterns or Routines, or to set link::#*runInTerminalCmd:: manually.
returns:: command to invoke a terminal emulator, to be used as link::Classes/LinuxPlatform#*runInTerminalCmd::

KEYWORD:: jack,linux


CLASS::List
summary::list of items of variable size
related::Classes/Array
categories::Collections>Ordered

DESCRIPTION::
List is a subclass of SequenceableCollection with unlimited growth in size. Although not a subclass of link::Classes/Array:: or its superclass link::Classes/ArrayedCollection:: it uses an Array in its implementation and is in many cases interchangeable with one. (List implements many of the same methods as Array.)

Arrays have a fixed maximum size. If you add beyond that size a new Array is created and returned, but you must use an assignment statement or the new array will be lost. (See the link::Classes/Array:: helpfile.) List has no size limitation and is thus more flexible, but has slightly more overhead.
code::
(
x = Array.new(3);
y = List.new(3);
5.do({ arg i; z = x.add(i); y.add(i); });
x.postln; z.postln; y.postln;
)
::

Many of List's methods are inherited from link::Classes/SequenceableCollection:: or link::Classes/Collection:: and are documented in those helpfiles.

CLASSMETHODS::

method::new
Creates a List with the initial capacity given by strong::size::.

method::newClear
Creates a List with the initial capacity given by strong::size:: and slots filled with nil.

method::copyInstance
Creates a List by copying strong::aList::'s array variable.

method::newUsing
Creates a List using strong::anArray::.

INSTANCEMETHODS::

method::asArray
Returns a new link::Classes/Array:: based upon this List.

method::array
Returns the List's Array, allowing it to be manipulated directly. This should only be necessary for exotic manipulations not implemented in List or its superclasses.
code::
(
x = List[1, 2, 3];
x.array.add("foo");
x.postln;
)
::

method::array
Sets the List's Array.

method::at
Return the item at strong::index::.
code::
List[ 1, 2, 3 ].at(0).postln;
::

method::clipAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be clipped to the last index.
code::
y = List[ 1, 2, 3 ];
y.clipAt(13).postln;
::

method::wrapAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be wrapped around to 0.
code::
y = List[ 1, 2, 3 ];
y.wrapAt(3).postln; // this returns the value at index 0
y.wrapAt(4).postln; // this returns the value at index 1
::

method::foldAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be folded back.
code::
y = List[ 1, 2, 3 ];
y.foldAt(3).postln; // this returns the value at index 1
y.foldAt(4).postln; // this returns the value at index 0
y.foldAt(5).postln; // this returns the value at index 1
::

method::put
Put strong::item:: at strong::index::, replacing what is there.

method::clipPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be clipped to the last index.

method::wrapPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be wrapped around to 0.

method::foldPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be folded back.

method::add
Adds an strong::item:: to the end of the List.

method::addFirst
Inserts the strong::item:: at the beginning of the List.

method::insert
Inserts the strong::item:: into the contents of the List at the indicated strong::index::.

method::pop
Remove and return the last element of the List.

method::grow
Increase the size of the List by strong::sizeIncrease:: number of slots.

method::removeAt
Remove and return the element at strong::index::, shrinking the size of the List.
code::
y = List[ 1, 2, 3 ];
y.removeAt(1);
y.postln;
::

method::fill
Inserts the item into the contents of the receiver, possibly returning a new collection. note::the difference between this and link::Classes/Collection#*fill#Collection's *fill::.::
code::
(
var z;
z = List[1, 2, 3, 4];
z.fill(4).postln;
z.fill([1,2,3,4]).postln;
)
::

method::do
Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
List['a', 'b', 'c'].do({ arg item, i; [i, item].postln; });
::

method::reverseDo
Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
List['a', 'b', 'c'].reverseDo({ arg item, i; [i, item].postln; });
::

method::pairsDo
Calls function for each subsequent pair of elements in the List. The function is passed the two elements and an index.
code::
List[1, 2, 3, 4, 5, 6].pairsDo({ arg a, b; [a, b].postln; });
::

method::copyRange
Return a new List which is a copy of the indexed slots of the receiver from start to end.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5];
y = z.copyRange(1,3);
z.postln;
y.postln;
)
::

method::copySeries
Return a new List consisting of the values starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5, 6];
y = z.copySeries(0, 2, 5);
y.postln;
)
::

method::putSeries
Put strong::value:: at every index starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5, 6];
y = z.putSeries(0, 2, 5, "foo");
y.postln;
)
::

method::reverse
Return a new List whose elements are reversed.
code::
(
var y, z;
z = List[1, 2, 3, 4];
y = z.reverse;
z.postln;
y.postln;
)
::

method::scramble
Returns a new List whose elements have been scrambled. The receiver is unchanged.
code::
List[1, 2, 3, 4, 5, 6].scramble.postln;
::

method::mirror
Return a new List which is the receiver made into a palindrome. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror.postln;
::

method::mirror1
Return a new List which is the receiver made into a palindrome with the last element removed. This is useful if the list will be repeated cyclically, the first element will not get played twice. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror1.postln;
::

method::mirror2
Return a new List which is the receiver concatenated with a reversal of itself. The center element is duplicated. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror2.postln;
::

method::stutter
Return a new List whose elements are repeated strong::n:: times. The receiver is unchanged.
note::It is recommended to use code::dupEach:: instead. This method is retained for backwards compatibility.::
code::
List[1, 2, 3].stutter(2).postln;
::

method::dupEach
Return a new List whose elements are repeated strong::n:: times. The receiver is unchanged.
code::
List[1, 2, 3].dupEach(2).postln;
::

method::rotate
Return a new List whose elements are in rotated order. Negative strong::n:: values rotate left, positive strong::n:: values rotate right. The receiver is unchanged.
code::
List[1, 2, 3, 4, 5].rotate(1).postln;
List[1, 2, 3, 4, 5].rotate(-1).postln;
List[1, 2, 3, 4, 5].rotate(3).postln;
::

method::pyramid
Return a new List whose elements have been reordered via one of 10 "counting" algorithms. The algorithms are numbered 1 through 10. Run the examples to see the algorithms.
code::
List[1, 2, 3, 4].pyramid(1).postln;

(
10.do({ arg i;
	List[1, 2, 3, 4].pyramid(i + 1).postcs;
});
)
::

method::lace
Returns a new List whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size strong::length::. The receiver is unchanged.
code::
(
x = List[ [1, 2, 3], 6, List["foo", 'bar']];
y = x.lace(12);
x.postln;
y.postln;
)
::

method::permute
Returns a new List whose elements are the strong::nthPermutation:: of the elements of the receiver. The receiver is unchanged.
code::
(
x = List[ 1, 2, 3];
6.do({|i| x.permute(i).postln;});
)
::

method::wrapExtend
Returns a new List whose elements are repeated sequences of the receiver, up to size strong::length::. The receiver is unchanged.
code::
(
x = List[ 1, 2, 3, "foo", 'bar' ];
y = x.wrapExtend(9);
x.postln;
y.postln;
)
::

method::foldExtend
Same as link::#-wrapExtend:: but the sequences fold back on the list elements.
code::
(
x = List[ 1, 2, "foo"];
y = x.foldExtend(9);
x.postln;
y.postln;
)
::

method::slide
Return a new List whose elements are repeated subsequences from the receiver. Easier to demonstrate than explain.
code::
List[1, 2, 3, 4, 5, 6].slide(3, 1).postcs;
List[1, 2, 3, 4, 5, 6].slide(3, 2).postcs;
List[1, 2, 3, 4, 5, 6].slide(4, 1).postcs;
::

method::dump
Dump the List's Array.

method::clear
Replace the List's Array with a new empty one.


class:: ListPattern
summary:: abstract class that holds a list
related:: Classes/FilterPattern
categories:: Streams-Patterns-Events>Patterns>List

Examples::

code::
// post subclasses:

ListPattern.dumpClassSubtree;
::


CLASS:: ListView
summary:: A view displaying a list of text items.
categories:: GUI>Views

DESCRIPTION::

A view that displays a list of text items and allows one or more of them to be selected, depending on link::#-selectionMode::.

In default selection mode (single item selection), clicking on an item will select it, and pressing the up or down arrow keys will move selection to previous or next item, respectively. Other selection modes allow more complex interaction.

There is a difference between the concepts of link::#-value#current:: item, end link::#-selection#selected:: items. In default selection mode they will always be the same, but not so in other modes.


CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::



SUBSECTION:: Data

METHOD:: items
	The list of items displayed by the view.

	argument::
		An Array of Strings, each String defining the text to represent an item.

METHOD:: clear
    Removes all items.

METHOD:: value
	The index of the current item, or nil when there is no current item. Note that this may be different than link::#-selection:: when link::#-selectionMode:: allows multiple items to be selected.

	argument::
		An Integer or nil.

METHOD:: valueAction
	Sets link::#-value:: and triggers the link::#-action::.

METHOD:: selection
	An array of all selected indexes. When setting selection, either an array or a single integer may be used.

	Note that this may be different than link::#-value:: when link::#-selectionMode:: allows multiple items to be selected. When setting selection in single-item selection mode, only the last index will remain selected.


SUBSECTION:: Appearance

METHOD:: colors
	The background colors of the items.

	argument::
		An Array of Colors, one Color for each item.

METHOD:: stringColor
	The color used to display all the text of all unselected items.

	argument::
		A Color.

METHOD:: selectedStringColor
	The color used to display the selected item's text.

	argument::
		A Color.

METHOD:: hiliteColor
	The color used to indicate the selected item (aside from the color of its text).

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: selectionMode

	The allowed mode of item selection, according to the following table:

	table::
	## strong::Value::  || strong::Meaning::
	## \none            || No item can be selected.
	## \single          || Only a single item can be selected at once.
	## \multi           || Multiple items can be selected. An item's selection is toggled when clicked.
	## \extended        || Multiple items can be selected, individually by holding the Ctrl key, and in a batch by holding the Shift key.
	## \contiguous      || Multiple neighbouring items can be selected by holding the Shift key.
	::

	argument::
		One of the Symbols listed in the table above.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the emphasis::current:: item, i.e. when link::#-value:: changes as a result of GUI interaction.

METHOD:: selectionAction

The action object evaluated whenever link::#-selection:: changes.

METHOD:: enterKeyAction
	The action object evaluated whenever the user presses the Enter (Return) key.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## space           || select next item and trigger action
	## r               || trigger enterKeyAction
	## n               || trigger enterKeyAction
	## a number        || trigger enterKeyAction
	## up arrow        || select previous item and trigger action
	## down arrow      || select next item and trigger action
	## left arrow      || select previous item and trigger action
	## right arrow     || select next item and trigger action
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.


EXAMPLES::

subsection:: Basic Example

code::
(
w = Window.new.front;

v = ListView(w,Rect(10,10,120,70))
    .items_([ "SinOsc", "Saw", "LFSaw", "WhiteNoise", "PinkNoise", "BrownNoise", "Osc" ])
    .background_(Color.clear)
    .hiliteColor_(Color.green(alpha:0.6))
    .action_({ arg sbs;
        [sbs.value, v.items[sbs.value]].postln; // .value returns the integer
    });
)
::


subsection:: Sound Example

Use ListView to switch filters:
code::
(
s.waitForBoot({
    var f, freq, ww;
    n={r=LFSaw.ar([220, 530],0,0.3)*LFPulse.ar(12,0,0.3,0.4); [r[0],Delay2.ar(r[1])]}.play;
    freq={SinOsc.kr(0.5,0,4000,4200)}.play;
    w=Window("Filters").front;
    v = ListView(w,Rect(10,10,180,120))
        .items_([ "No Filter","RLPF", "RHPF", "BPF", "Resonz", "MoogFF" ])
        .background_(Color.clear)
        .hiliteColor_(Color.green(alpha:0.6))
        .action_({arg v;
            v.value.switch(
            0,{try{f.free};"test".postln},
            1,{try{f.free};f={ReplaceOut.ar(0,RLPF.ar(In.ar(0,2),In.kr(0,1),0.2,0.3))}.play(addAction:\addToTail)},
            2,{try{f.free};f={ReplaceOut.ar(0,RHPF.ar(In.ar(0,2),In.kr(0,1),0.2,0.3))}.play(addAction:\addToTail)},
            3,{try{f.free};f={ReplaceOut.ar(0,BPF.ar(In.ar(0,2),In.kr(0,1),0.2,1.5))}.play(addAction:\addToTail)},
            4,{try{f.free};f={ReplaceOut.ar(0,Resonz.ar(In.ar(0,2),In.kr(0,1),0.2,2))}.play(addAction:\addToTail)},
            5,{try{f.free};f={ReplaceOut.ar(0,MoogFF.ar(In.ar(0,2),In.kr(0,1),1.5))}.play(addAction:\addToTail)}
            );
        });

    ww=FreqScope.new(400, 200, 0);
    w.bounds=Rect(50,Window.screenBounds.height-300,200,200);
    ww.window.bounds=ww.window.bounds.moveTo(255,Window.screenBounds.height-328);
    CmdPeriod.doOnce({{ww.window.close}.defer(0.5);w.close;});
            //defer or crash, because FreqScopeWindow Class contains its own routine for cleaning up on CmdPeriod
    w.onClose_({n.free;f.free;freq.free});
});
)
::


class:: LocalBuf
summary:: Allocate a buffer local to the synth
categories:: UGens>Buffer
related:: Classes/Buffer, Classes/SetBuf, Classes/ClearBuf

classmethods::
private:: categories, new1

method:: new
Allocate a local buffer
argument:: numFrames
number of frames (default: 1)
argument:: numChannels
number of channels for multiple channel buffers (default: 1)
returns:: a new buffer – the ugen outputs its buffer number and can thus be used in any other ugen that requires a buffer number input.

method:: newFrom
Allocates a new buffer from a given list of values
argument:: list
The list may be two-dimensional for numChannels > 1.
It is then reshaped into the buffer's current format by flattening.
returns:: a new buffer
discussion::
Since newFrom is called by the as message, one may thus convert an array to a LocalBuf:
code::
[1, 2, 3].as(LocalBuf)
::

instancemethods::
method:: set
set the buffer slots with a list of values.
discussion::
If list is smaller than numFrames, it will only set
part of the buffer. The list may be two-dimensional for numChannels > 1.
offset is the starting index (default: 0)
warning::
SynthDef permits a maximum of 65536 (2**16) unique constant values in one definition. A very large array of distinct values can corrupt the SynthDef's binary format. If you need a large buffer to be pre-initialized with signal data, it is strongly recommended to use link::Classes/Buffer:: instead.
::

If the buffer is large but holds a smaller number of unique values, e.g. code::Array.fill(88200, { #[0, 0.25, 0.5, 0.75, 1.0].choose })::, this is no problem. SynthDef compacts the large array for the list of constants.

code::
SynthDef(\bigLocalBuf, {
	LocalBuf(88200).set(Array.fill(88200, { #[0, 0.25, 0.5, 0.75, 1.0].choose }))
}).add;

SynthDescLib.at(\bigLocalBuf).constants;
// prints: FloatArray[ 1, 88200, 0, 0.75, 0.5, 0.25 ]
::

method:: clear
set the buffer slot to zero.
discussion::
This is important when randomly accessing buffer slots
(e.g. with a BufRd) or not overwriting them. Clear is not an efficient real time operation
for larger buffers, so it should be only used when really needed - but then it is essential:
a LocalBuf is "created" in each new synth, and it may reuse old space. So if an older
synth has already ended, this part of memory may be the same as the new synth's.

examples::
code::
// example: FFT

(
{
var in, chain;
	in = WhiteNoise.ar(0.1.dup);
	chain = FFT({LocalBuf(2048, 1)}.dup, in);
	chain = PV_BrickWall(chain, SinOsc.kr([0.1, 0.11]));
	IFFT(chain) // inverse FFT
}.play;
)

// spawn some FFT based synths:
(
SynthDef(\fftgrain, { |out, sustain = 1, rate = 0.2|
	var in, chain;
	in = WhiteNoise.ar(0.1).dup;
	chain = FFT({LocalBuf(128, 1)}.dup, in);
	chain = PV_BrickWall(chain,
		SinOsc.kr(rate * XLine.kr(1, 15 * [1, 1.6], sustain), Rand(0, pi))
	);
	Out.ar(out, IFFT(chain) * XLine.kr(1, 0.001, sustain, doneAction: Done.freeSelf)) // inverse FFT
}).add;
)

(
Pbind(
	\instrument, \fftgrain,
	\rate, Pwhite().linexp(0, 1, 0.01, 300),
	\legato, Pwhite(1, 3.0, inf),
	\dur, Prand([0.2, 1, 1.2], inf)
).play
)

// IndexL
(
{
	var buf = LocalBuf.newFrom((0..5).scramble);
	var freq = IndexL.kr(buf, MouseX.kr(0, BufFrames.kr(buf))).poll * 100 + 40;
	Saw.ar(freq * [1, 1.1]) * 0.1
}.play;
)

// DetectIndex
(
{
	var buf1 = LocalBuf.newFrom((0..5).scramble);
	var buf2 = LocalBuf.newFrom((0..5).scramble - 1);
	var buf3 = LocalBuf.newFrom((0..5).scramble + 1);
	var index = DetectIndex.kr([buf1, buf2], SinOsc.kr([0.85, 0.8], 0, 6).trunc).poll;
	var freq = IndexL.kr([buf2, buf3], index).poll * 40 + 40;
	Saw.ar(freq) * 0.1
}.play;
)


// DegreeToKey
// modal space
// mouse x controls discrete pitch in dorian mode
(
play({
	var mix;

	mix =

	// lead tone
	SinOsc.ar(
		(
			DegreeToKey.kr(
				[0, 2, 3.2, 5, 7, 9, 10].as(LocalBuf),
				MouseX.kr(0, 15),		// mouse indexes into scale
				12,					// 12 notes per octave
				1,					// mul = 1
				72					// offset by 72 notes
			).poll
			+ LFNoise1.kr([3,3], 0.04)	// add some low freq stereo detuning
		).midicps,						// convert midi notes to hertz
		0,
		0.1)

	// drone 5ths
	+ RLPF.ar(LFPulse.ar([48,55].midicps, 0.15),
		SinOsc.kr(0.1, 0, 10, 72).midicps, 0.1, 0.1);

	// add some 70's euro-space-rock echo
	CombN.ar(mix, 0.31, 0.31, 2, 1, mix)
})
)

// Osc
(
{
	var buf;
	var list = Wavetable.sineFill(512, 1.0 / [1, 10, 3, 10, 5, 6, 10]);
	// list.plot;
	buf = LocalBuf.newFrom(list);
	Osc.ar(buf,
		XLine.kr(2000, 200 + {30.0.rand}.dup, 10) + SinOsc.ar(Line.kr(2, 300, 10),
		0, 100)
	) * 0.1;
}.play;
)

// see how not clearing the buffer accesses old data:
// slowly overwrite data with noise
(
{
	var buf = LocalBuf(2048, 2);
	BufWr.ar(WhiteNoise.ar(1.dup), buf, LFNoise0.ar(530).range(0, BufFrames.kr(buf)));
	PlayBuf.ar(2, buf, MouseX.kr(1, 2), loop: 1) * 0.1
}.play
)

// avoid this (unless you like the glitch) by clearing buffer first:
(
{
	var buf = LocalBuf(2048, 2).clear;
	BufWr.ar(WhiteNoise.ar(1.dup), buf, LFNoise0.ar(530).range(0, BufFrames.kr(buf)));
	PlayBuf.ar(2, buf, MouseX.kr(1, 2), loop: 1) * 0.1
}.play
)


// BufCombC stereo (needs no clearing, because delay is filled by ugen)
(
{
var z = Decay.ar(Dust.ar(1.dup, 0.1), 0.3, WhiteNoise.ar);
BufCombC.ar(LocalBuf(SampleRate.ir, 2), z, XLine.kr(0.0001, 0.01, 20), 0.2);
}.play
)

// multichannel test
(
{
var in, chain, n = 4;
	in = WhiteNoise.ar(0.1.dup(n));
	chain = FFT({LocalBuf(2048, 1)}.dup(n), in);
	chain = PV_BrickWall(chain, LFNoise2.kr(2.dup(n)));
	Splay.ar(IFFT(chain)) // inverse FFT
}.play;
)
::



class:: LocalIn
summary:: Define and read from buses local to a synth.
related:: Classes/LocalOut
categories::  UGens>InOut

Description::

LocalIn defines buses that are local to the enclosing synth. These are
like the global buses, but are more convenient if you want to implement a
self contained effect that uses a feedback processing loop.

There can only be one audio rate and one control rate LocalIn per
SynthDef. The audio can be written to the bus using
link::Classes/LocalOut:: .

warning::
Audio written to a  link::Classes/LocalOut::  will not be read by a
corresponding LocalIn until the next cycle, i.e. one block size of
samples later. Because of this it is important to take this additional
delay into account when using LocalIn to create feedback delays with
delay times shorter than the threshold of pitch (i. e. < 0.05
seconds or > 20Hz), or where sample accurate alignment is required.
See the resonator example below.
::

classmethods::

method::ar, kr

argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.

argument::default

The initial value written to the bus once, so that it can be used before overwriting it with LocalOut. An array can be passed in to specify different values for each channel.


Examples::

code::
(
{
	var source, local;

	source = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);
	local = LocalIn.ar(2) + [source, 0]; // read feedback, add to source
	local = DelayN.ar(local, 0.2, 0.2); // delay sound

	// reverse channels to give ping pong effect, apply decay factor
	LocalOut.ar(local.reverse * 0.8);

	local
}.play;
)

(
{
	var local, in;

	in = Mix.fill(12, {
		Pan2.ar(
			Decay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)
				* FSinOsc.ar(IRand(36,84).midicps).cubed.max(0),
			Rand(-1,1))
	});
	in = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);

	4.do { in = AllpassN.ar(in, 0.03, {Rand(0.005,0.02)}.dup, 1); };

	local = LocalIn.ar(2) * 0.98;
	local = OnePole.ar(local, 0.5);

	local = Rotate2.ar(local[0], local[1], 0.23);
	local = AllpassN.ar(local, 0.05, {Rand(0.01,0.05)}.dup, 2);

	local = DelayN.ar(local, 0.3, [0.19,0.26]);
	local = AllpassN.ar(local, 0.05, {Rand(0.03,0.15)}.dup, 2);

	local = LeakDC.ar(local);
	local = local + in;

	LocalOut.ar(local);

	local

}.play;
)

(
{
	var local, in, amp;

	in = SoundIn.ar([0, 1]);

	amp = Amplitude.kr(Mix.ar(in));
	in = in * (amp > 0.02); // noise gate

	local = LocalIn.ar(2);
	local = OnePole.ar(local, 0.4);
	local = OnePole.ar(local, -0.08);

	local = Rotate2.ar(local[0], local[1], 0.2);

	local = DelayN.ar(local, 0.25, 0.25);

	local = LeakDC.ar(local);
	local = ((local + in) * 1.25).softclip;

	LocalOut.ar(local);
	local * 0.1;
}.play;
)

// Resonator, must subtract blockSize for correct tuning
(
{
	var in, imp, sound;

	in = LocalIn.ar(1);
	imp = Impulse.ar(1);
	sound = DelayC.ar(imp + (in * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal);
	LocalOut.ar(sound); // for feedback
	in
}.play;

// compare pitch
{
	SinOsc.ar(440, 0, 0.2)
}.play(s, 1);
)
::



class:: LocalOut
summary:: Write to buses local to a synth.
related:: Classes/LocalIn
categories::  UGens>InOut


Description::

LocalOut writes to buses that are local to the enclosing synth. The buses
should have been defined by a  link::Classes/LocalIn::  ugen. The
code::channelsArray::  must be the same number of channels
as were declared in the  link::Classes/LocalIn:: . These are like the
global buses, but are more convenient if you want to implement a self
contained effect that uses a feedback processing loop.


warning::

Audio written to a LocalOut will not be read by a corresponding
link::Classes/LocalIn::  until the next cycle, i.e. one block size of
samples later. Because of this it is important to take this additional
delay into account when using  link::Classes/LocalIn::  to create
feedback delays with delay times shorter than the threshold of pitch
(i. e. < 0.05 seconds or > 20Hz), or where sample accurate
alignment is required. See the resonator example below.

::

classmethods::

method::ar, kr

argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
{
	var source, local;

	source = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);
	local = LocalIn.ar(2) + [source, 0]; // read feedback, add to source
	local = DelayN.ar(local, 0.2, 0.2); // delay sound

	// reverse channels to give ping pong effect, apply decay factor
	LocalOut.ar(local.reverse * 0.8);

	local
}.play;
)



(
z = SynthDef("tank", { |out|
	var local, in;

	in = Mix.fill(12, {
		Pan2.ar(
			Decay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)
				* FSinOsc.ar(IRand(36,84).midicps).cubed.max(0),
			Rand(-1,1))
	});
	in = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);

	4.do { in = AllpassN.ar(in, 0.03, {Rand(0.005,0.02)}.dup, 1); };

	local = LocalIn.ar(2) * 0.98;
	local = OnePole.ar(local, 0.5);

	local = Rotate2.ar(local[0], local[1], 0.23);
	local = AllpassN.ar(local, 0.05, {Rand(0.01,0.05)}.dup, 2);

	local = DelayN.ar(local, 0.3, [0.19,0.26]);
	local = AllpassN.ar(local, 0.05, {Rand(0.03,0.15)}.dup, 2);

	local = LeakDC.ar(local);
	local = local + in;

	LocalOut.ar(local);

	Out.ar(out, local);
}).play;
)



(
z = SynthDef("tape", { |out|
	var local, in, amp;

	in = SoundIn.ar([0, 1]);

	amp = Amplitude.kr(Mix.ar(in));
	in = in * (amp > 0.02); // noise gate

	local = LocalIn.ar(2);
	local = OnePole.ar(local, 0.4);
	local = OnePole.ar(local, -0.08);

	local = Rotate2.ar(local[0], local[1], 0.2);

	local = DelayN.ar(local, 0.25, 0.25);

	local = LeakDC.ar(local);
	local = ((local + in) * 1.25).softclip;

	LocalOut.ar(local);

	Out.ar(out, local * 0.1);
}).play;
)

// Resonator, must subtract blockSize for correct tuning
(

{
	var imp, local;
	local = LocalIn.ar(1);
	imp = Impulse.ar(1);

	// for feedback
	LocalOut.ar(DelayC.ar(imp + (local * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal));

	local

}.play;

{ SinOsc.ar(440, 0, 0.2) }.play; // compare pitch
)

::



class:: Logistic
summary:: Chaotic noise function
related:: Classes/Crackle, Classes/LatoocarfianN
categories::  UGens>Generators>Chaotic


Description::

A noise generator based on the logistic map:
code::
y = chaosParam * y * (1.0 - y)
::

classmethods::
private:: categories

method::ar, kr

argument::chaosParam
a parameter of the chaotic function with useful values from 0.0 to 4.0. Chaos occurs from 3.57 up. Don't use values outside this range if you don't want the UGen to blow up.

argument::freq
Frequency of calculation; if over the sampling rate, this is clamped to the sampling rate

argument:: init
Initial value of y in the equation above

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
y will stay in the range of 0.0 to 1.0 for normal values of the chaosParam. This leads to a DC offset, and may cause a pop when you stop the Synth. For output you might want to combine this UGen with a LeakDC or rescale around 0.0 via mul and add: see example below.

examples::
code::
// default values
{ Logistic.ar }.play

// onset of chaos
{ Logistic.ar(Line.kr(3.55, 3.6, 5), 1000) }.play

// explore via Mouse
{ Logistic.ar(MouseX.kr(3, 3.99), MouseY.kr(10, 10000, 'exponential'), 0.25, 0.5) }.play
::



class:: LorenzL
summary:: Lorenz chaotic generator
categories:: UGens>Generators>Chaotic

description::
A strange attractor discovered by Edward N. Lorenz while studying mathematical models of the atmosphere. The system is composed of three ordinary differential equations:

teletype::
	x' = s * (y - x)
	y' = x * (r - z) - y
	z' = x * y - b * z
::

The time step amount code::h:: determines the rate at which the ODE is evaluated. Higher values will increase the rate, but cause more instability. A safe choice is the default amount of 0.05.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: s
Equation variable
argument:: r
Equation variable
argument:: b
Equation variable
argument:: h
Integration time step
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: zi
Initial value of z
argument:: mul
argument:: add

examples::
code::
// vary frequency
{ LorenzL.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
::

code::
// randomly modulate params
(
{ LorenzL.ar(
	SampleRate.ir,
	LFNoise0.kr(1, 2, 10),
	LFNoise0.kr(1, 20, 38),
	LFNoise0.kr(1, 1.5, 2)
) * 0.2 }.play(s);
)
::

code::
// as a frequency control
{ SinOsc.ar(Lag.ar(LorenzL.ar(MouseX.kr(1, 200)),3e-3)*800+900)*0.4 }.play(s);
::


class:: Loudness
summary:: Extraction of instantaneous loudness in sones
categories:: UGens>Analysis>Amplitude
related:: Classes/BeatTrack, Classes/MFCC, Classes/Onsets, Classes/Pitch, Classes/KeyTrack

description::
A perceptual loudness function which outputs loudness in sones; this is a variant of an MP3 perceptual model, summing excitation in ERB bands. It models simple spectral and temporal masking, with equal loudness contour correction in ERB bands to obtain phons (relative dB), then a phon to sone transform. The final output is typically in the range of 0 to 64 sones, though higher values can occur with specific synthesised stimuli.

note::Research note: This UGen is an informal juxtaposition of perceptual coding, and a Zwicker and Glasberg/Moore/Stone loudness model.::

classmethods::
method:: kr

argument:: chain
[fft] Audio input to track, which has been pre-analysed by the link::Classes/FFT:: link::Classes/UGen::; see examples below for the expected FFT size.

argument:: smask
[sk] Spectral masking param: lower bins mask higher bin power within ERB bands, with a power falloff (leaky integration multiplier) of smask per bin.

argument:: tmask
[sk] Temporal masking param: the phon level let through in an ERB band is the maximum of the new measurement, and the previous minus tmask phons.

examples::
code::
// assumes hop of half fftsize, fine

d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// analyse loudness and poll result
(
{
	var in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);
	var chain = FFT(LocalBuf(1024).clear, in);  // for sampling rates 44100 and 48000
	//var chain = FFT(LocalBuf(2048).clear, in);  // for sampling rates 88200 and 96000
	var loudness = Loudness.kr(chain).poll(50);
	Pan2.ar(in)
}.play
)


// TESTS
// sones = 2 ** ((phon - 40) / 10)
// sine of 40 dB = 40 phon at 1000 kHz = 1 sone
// full amp = 100 dB
// -60.dbamp = 0.001 = 1 sone
// -40.dbamp = 0.01 = 4 sone
// -20.dbamp= 0.1 = 16 sone
// 0.dbamp= 1 = 64 sone
(
{
	var in, chain, loudness;

	in = SinOsc.ar(1000, 0, 0.001); //should be 1 sone
	//in = SinOsc.ar(1000, 0, 0.01); //should be 4 sone
	//in = SinOsc.ar(1000, 0, 0.1); //should be 16 sone
	//in = SinOsc.ar(1000, 0, 1); //should be 64 sone
	//in = Saw.ar * SinOsc.ar(4);
	//in = WhiteNoise.ar;
	//in = Silent.ar; // should be small, around 2 ** ((0 - 40) / 10) = 2 ** (-4) = 0.0625
	//in = DC.ar(1);
	//in = SinOsc.ar(22050, pi * 0.5, 1);
	// fade ins
	//in = SinOsc.ar(1000, 0, Line.kr(0, 1, 2));
	//in = SinOsc.ar(1000, 0, Line.kr(0, 1, 2) ** 2);
	//in = WhiteNoise.ar(Line.kr(0, 1, 2));
	//in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

	chain = FFT(LocalBuf(1024).clear, in);  // for sampling rates 44100 and 48000
	//chain = FFT(LocalBuf(2048).clear, in);  // for sampling rates 88200 and 96000

	loudness = Loudness.kr(chain, 0.25, 6).poll(50);

	K2A.ar(loudness * 0.016)
}.plot(2.0)
)
::




class:: MFCC
summary:: Mel frequency cepstral coefficients
categories:: UGens>Analysis
related:: Classes/BeatTrack, Classes/Loudness, Classes/Onsets, Classes/Pitch, Classes/KeyTrack

description::
Generates a set of MFCCs; these are obtained from a band-based frequency representation (using the Mel scale by default), and then a discrete cosine transform (DCT). The DCT is an efficient approximation for principal components analysis, so that it allows a compression, or reduction of dimensionality, of the data, in this case reducing 42 band readings to a smaller set of MFCCs. A small number of features (the coefficients) end up describing the spectrum. The MFCCs are commonly used as timbral descriptors.

Output values are somewhat normalised for the range 0.0 to 1.0, but there are no guarantees on exact conformance to this. Commonly, the first coefficient will be the highest value.


note::Drafts of an MFCC UGen were prepared by both Dan Stowell and Nick Collins; their various ideas are combined here in a cross platform compatible UGen. Mel scale spacing with triangular crossfade overlap is used by default for the bands, approximately tracking the human critical band spacing and bandwidth. Variants such as BFCC (Bark) and EFCC (ERB) given similar results in practice; the Mel scale as used here is the standard as adapted from the speech recognition literature and now applied in music information retrieval.::

classmethods::
method:: kr

argument:: chain
[fft] Audio input to track, which has been pre-analysed by the FFT UGen; see examples below for the expected FFT size.
argument:: numcoeff
[s] Number of coefficients, defaults to 13, maximum of 42; more efficient to use less of course!

returns:: code::#coeff1, coeff2, ...::

examples::
code::
// Technical note: The 0th coefficient is not generated as it consists of multiplying all bands by 1 and summing


// assumes hop of half fftsize, fine

d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
x = {
	var in, fft, array;

	//in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

	in = SoundIn.ar(0);
	fft = FFT(LocalBuf(1024), in);  // for sampling rates 44100 and 48000
	//fft = FFT(LocalBuf(2048), in);  // for sampling rates 88200 and 96000

	array = MFCC.kr(fft);

	array.size.postln;

	Out.kr(0, array); // control bus out
	Out.ar(0, Pan2.ar(in)); // audio bus out
}.play
)


c = Bus(\control, 0, 13);

// poll coefficients
c.getn(13, { |val| { val.plot }.defer });


// Continuous graphical display of MFCC values; free routine before closing window

(
var ms;

w = Window.new("Thirteen MFCC coefficients", Rect(200, 400, 300, 300));

ms = MultiSliderView.new(w, Rect(10, 10, 260, 280));

ms.value_(Array.fill(13, 0.0));
ms.valueThumbSize_(20.0);
ms.indexThumbSize_(20.0);
ms.gap_(0);

w.front;

r = {

	inf.do {

		c.getn(13, { |val| { ms.value_(val * 0.9) }.defer });
		0.04.wait; // 25 frames per second
	}

}.fork

)


// tidy up
(
r.stop;
b.free;
c.free;
x.free;
w.close;
)
::



code::
// Calculating Mel Scale Bands; allow up to 42 coefficients, so up to 42 bands
// first part of this code adapted from Dan Stowell and Jamie Bullock Mel scale implementation
// could later add Bark and ERB options, and possibility of buffer of data to be passed to the UGen for alternative freq warpings
(
var mel_freq_max, mel_freq_min, freq_bw_mel, freq_bands, freq_max, freq_min;
var mel_peak, lin_peak, fft_peak;
var freqperbin;
var fftbinstart, fftbinend, fftbinmult, fftbincumul;
var pos, tmp;
var sr, fftsize, halffftsize;
var whichbandscale, lintoscale, scaletolin;

freq_max = 18000;
freq_min = 80;
sr = 48000; //44100;
fftsize = 1024;
halffftsize = fftsize.div(2);
freq_bands = 42;

//whichbandscale = 0; // 0 = mel; 1 = bark (CB) 2 = ERB
//
//lintoscale = { |freq|
//switch(whichbandscale, 0, { 1127 * log(1 + (freq / 700))}, 1, { }, 2, { }).value
//};
//scaletolin = { |scalepos|
//switch(whichbandscale, 0, {700 * (exp(scalepos / 1127.0) -1) }, 1, { }, 2, { }).value
//};

lintoscale = { |freq|
	1127 * log(1 + (freq / 700))
};
scaletolin = { |scalepos|
	700 * (exp(scalepos / 1127.0) -1)
};

mel_freq_max = lintoscale.value(freq_max); // 1127 * log(1 + (freq_max / 700));
mel_freq_min = lintoscale.value(freq_min); //1127 * log(1 + (freq_min / 700));
freq_bw_mel = (mel_freq_max - mel_freq_min) / freq_bands;

[mel_freq_max, mel_freq_min, freq_bw_mel].postln;

mel_peak = Array.fill(freq_bands + 2, { 0.0 });
lin_peak = Array.fill(freq_bands + 2, { 0.0 });
fft_peak = Array.fill(freq_bands + 2, { 0.0 });

freqperbin = sr / fftsize; // SR/N

mel_peak[0] = mel_freq_min;
lin_peak[0] = freq_min; // === 700 * (exp(mel_peak[0] / 1127) - 1);
fft_peak[0] = (lin_peak[0] / freqperbin).asInteger;

for(1, freq_bands + 1, { |n|

	mel_peak[n] = mel_peak[n - 1] + freq_bw_mel;
	lin_peak[n] = scaletolin.value(mel_peak[n]); // 700 * (exp(mel_peak[n] / 1127.0) -1);
	fft_peak[n] = ((lin_peak[n] / freqperbin).asInteger).min(halffftsize); // fft size //rounds down here

});

//Post << mel_peak << nl;
//Post << lin_peak << nl;
//Post << fft_peak << nl;

//  [2 / (lin_peak[freq_bands + 1] - lin_peak[freq_bands-1]), 1.0 / (2 / (lin_peak[2] - lin_peak[0]))].postln;

fftbinstart = Array.fill(freq_bands, { 0 });
fftbinend = Array.fill(freq_bands, { 0 });
fftbincumul = Array.fill(freq_bands + 1, { 0 });
fftbinmult = [];

pos = 0;

freq_bands.do {|i|

	//var normmult = 1.0; // preserve power, don't modify band power by area
	var startbin, endbin, numbins, averager;

	if(i == 0) {
		startbin = 0;
		endbin = fft_peak[i + 1] - 1;
	} {
		startbin = fft_peak[i - 1] + 1;
		endbin = fft_peak[i + 1] - 1;
	};

	numbins = endbin - startbin + 1;
	averager = 1.0 / numbins;

	// linear crossfade (intended in power) between consecutive band centres

	tmp = fft_peak[i] - startbin;

	// could divide by averager but I'm not convinced by the perceptual necessity for this?
	// ie fftbinmult = fftbinmult ++ (Array.series(tmp + 1, 1.0 / (tmp + 1), 1.0 / (tmp + 1)) * averager);

	fftbinmult = fftbinmult ++ (Array.series(tmp + 1, 1.0 / (tmp + 1), 1.0 / (tmp + 1)));

	tmp = endbin - fft_peak[i];

	fftbinmult = fftbinmult ++ (Array.series(tmp, 1.0 + ((-1.0) / (tmp + 1)), (-1.0) / (tmp + 1)));

	fftbinstart[i] = startbin;
	fftbinend[i] = endbin;
	fftbincumul[i] = pos;

	pos = pos + (endbin - startbin + 1);
};

fftbincumul[freq_bands] = pos - 1;

Post << fftbinstart << nl;
Post << fftbinend << nl;
Post << fftbincumul << nl;
Post << fftbinmult << nl;

)


// future work: see http://www.ling.su.se/STAFF/hartmut/bark.htm

// Barks
a = (26.81 / (1 + (1960 / ((100, 200..22000))))) - 0.53;
a.plot;

// ERBs (rough calculation, only really valid under 6000Hz, real scale goes up to 42 rather than 37 in 22000 Hz)
(
a = Array.fill(220, {|i| 
	var f = i * 100; 
	11.17 * log((f + 312) / (f + 14675)) + 43.0 
})
)
a.plot

// generating DCT coefficients
// don't generate i=0 coefficient since it
a = Array.fill(42, {|i| cos(pi / 42.0 * ((0..41) + 0.5) * (i + 1)) });
Post << a.flatten << nl;
::


TITLE:: MIDIClient
summary:: Basic access to MIDI on your computer
categories:: External Control>MIDI
related:: Classes/MIDIIn, Classes/MIDIOut, Classes/MIDIFunc, Classes/MIDIdef, Guides/MIDI, Guides/UsingMIDI, Classes/MIDIEndPoint

DESCRIPTION::
MIDIClient is the core class that provides access to the MIDI subsystem on your computer.

See the link::Guides/UsingMIDI:: helpfile for practical considerations and techniques for using MIDI in SC.

CLASSMETHODS::

private:: prInit, prDisposeClient, prInitClient, prList


METHOD:: init
Initializes the MIDIClient, checks which available MIDI sources and destinations there are, and opens as many connections as desired.

ARGUMENT:: inports
the number of MIDI input connections to open; if code::nil:: then opens as many inports as there are MIDI sources.

ARGUMENT:: outports
the number of MIDI output connections to open; if code::nil:: then opens as many outports as there are MIDI destinations.

ARGUMENT:: verbose
A flag whether or not to post the MIDI sources and destinations that were found. Default is true.


METHOD:: initialized
A flag that tells whether of not the MIDIClient has been initialized.



METHOD:: disposeClient
Cleans up the MIDIClient. After using this method, you will have to reinitialize the MIDIClient before you can use MIDI again.



METHOD:: list
Refresh the list of available sources and destinations.
If you have connected a MIDI device after MIDIClient initialization, you won't see it until this method is run.

METHOD:: sources
The list of available MIDI sources, including SuperCollider's own sources.

returns:: A code::List:: of code::MIDIEndPoints::

METHOD:: externalSources
The list of available MIDI sources, excluding SuperCollider's own sources. Only on Linux the list of code::sources:: and code::externalSources:: differs.

returns:: A code::List:: of code::MIDIEndPoints::

METHOD:: destinations
The list of available MIDI destinations, including SuperCollider's own destinations.

returns:: A code::List:: of code::MIDIEndPoints::

METHOD:: externalDestinations
The list of available MIDI destinations, excluding SuperCollider's own destinations. Only on Linux the list of code::destinations:: and code::externalDestinations:: differs.

returns:: A code::List:: of code::MIDIEndPoints::

METHOD:: restart
Restart the MIDIClient.


METHOD:: myinports
The number of input ports that SuperCollider created. This is mainly useful to know on the Linux platform.


METHOD:: myoutports
The number of output ports that SuperCollider created. This is mainly useful to know on the Linux platform.

METHOD:: getClientID
Linux only. This gets the client ID by which the MIDIClient is defined in the ALSA subsystem. It can be used to identify whether a port is belonging to this client or another one.

On non-linux systems, it posts a warning and returns nil.

EXAMPLES::

This is Linux specific code.
The function takes care of initializing MIDIClient, detects a MIDI device named SE25 and connects it to port 0 of SuperCollider.

code::
(
~connect_midi_devices = { arg device, name;
	// init or refresh MIDIClient end points
	if(MIDIClient.initialized == false) {
		MIDIClient.init;
	} {
		MIDIClient.list;
	};

	MIDIClient.sources.do({ arg endPoint;
		if(device.notNil and: { name.notNil} and: {endPoint.device == device} and: { endPoint.name == name }) {
			// catch exception thrown when already connected
			try {
				// connect SuperCollider out port 0 to MIDI device
				MIDIOut.connect(0, endPoint.uid);
			};
			try {
				// connect MIDI device to SuperCollider in port 0
				MIDIIn.connect(0, endPoint.uid);
			}
		}
	})

}
)

~connect_midi_devices.("SE25", "SE25 MIDI 1"); // test it now
::




CLASS:: MIDIFunc
summary:: Fast Responder for incoming MIDI Messages
categories:: External Control>MIDI
related:: Guides/MIDI, Classes/MIDIdef

DESCRIPTION::
MIDIFunc (and its subclass link::Classes/MIDIdef::) registers one or more functions to respond to an incoming MIDI message. Many of its methods are inherited from its superclass link::Classes/AbstractResponderFunc::.

subsection:: Important note on persistence

MIDIFunc (and its subclass link::Classes/MIDIdef:: like all other
AbstractResponderFuncs) are removed on pressing Cmd/ctrl-. To override this
behavior, use the link::Classes/AbstractResponderFunc#-permanent:: method.

CLASSMETHODS::
private:: initClass, cmdPeriod

METHOD:: defaultDispatchers
Get or set an link::Classes/IdentityDictionary:: containing the default dispatcher objects for MIDIFuncs of different types (these are what you get if you pass nil as the dispatcher argument to link::#*new::). These objects will decide if any of their registered MIDIFuncs should respond to an incoming MIDI message. The dictionary should have the keys code::[\noteOn, \noteOff, \control, \polytouch, \touch, \program, \bend]:: and values of an appropriate subclass of link::Classes/AbstractDispatcher:: for each message type. By default these will be instances of link::Classes/MIDIMessageDispatcher:: for the first four message types, and instances of link::Classes/MIDIMessageDispatcherNV:: for the last three.

returns:: The getter returns an link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled MIDIFunc. Normally one would use one of the message type specific convenience methods below, rather than use this method directly.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated for noteOn, noteOff, control, and polytouch messages it will be passed the arguments val, num, chan, and src, corresponding to the message value (e.g. velocity, control value, etc.), message number (e.g. note number), MIDI channel, and MIDI source uid. For touch, program change and bend messages it will be passed only val, chan, and src. For information on the args passed for the other sorts of code::msgType:: see the convenience methods below.

argument:: msgNum
An link::Classes/Integer:: indicating the MIDI message number (note number, control number, or program number) for this MIDIFunc. This can be an array. If nil, the MIDIFunc will respond to messages of all possible message numbers.

argument:: chan
An link::Classes/Integer:: indicating the MIDI channel number for this MIDIFunc. This can be an array. If nil, the MIDIFunc will respond to messages received on all channels.

argument:: msgType
A link::Classes/Symbol:: indicating which kind of MIDI message this MIDIFunc should respond to. One of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, code::\program::, code::\sysex::, code::\mtcQF::, code::\smpte::, code::\songPosition::, code::\songSelect::, code::\tuneRequest::, code::\midiClock::, code::\sysrt::, code::\tick::, code::\start::, code::\continue::, code::\stop::, code::\activeSense::, or code::\reset::.

argument:: srcID
An link::Classes/Integer:: corresponding to the uid of the MIDI input. (See link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::.) If nil, the MIDIFunc will respond to messages received from all sources.

argument:: argTemplate
An optional link::Classes/Integer:: or link::Classes/Function:: (or object which responds to the method link::Overviews/Methods#matchItem::) used to match the value of an incoming MIDI message. (e.g. velocity, control value, program number, etc.). If a Function, it will be evaluated with the message value as an argument, and should return a link::Classes/Boolean:: indicating whether the message matches and this MIDIFunc should respond.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: A new instance of MIDIFunc.

METHOD:: cc
A convenience method to create a new MIDIFunc which responds to MIDI control messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI control messages.

METHOD:: noteOn
A convenience method to create a new MIDIFunc which responds to MIDI note on messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI note on messages.

METHOD:: noteOff
A convenience method to create a new MIDIFunc which responds to MIDI note off messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI note off messages.

METHOD:: polytouch
A convenience method to create a new MIDIFunc which responds to MIDI polytouch messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI polytouch messages.

METHOD:: touch
A convenience method to create a new MIDIFunc which responds to MIDI touch messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI touch messages.

METHOD:: bend
A convenience method to create a new MIDIFunc which responds to MIDI bend messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI bend messages.

METHOD:: program
A convenience method to create a new MIDIFunc which responds to MIDI program change messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI program change messages.

METHOD:: sysex
A convenience method to create a new MIDIFunc which responds to MIDI system exclusive messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data (an link::Classes/Int8Array::) and srcID.

returns:: A new instance of MIDIFunc which responds to MIDI system exclusive messages.

SUBSECTION:: System Common

N.B. Because of SC's underlying low level MIDI implementation, there is no generic code::msgType:: and convenience method for System Common messages. Instead these are grouped with System Realtime under link::#*sysrt:: below.

METHOD:: smpte
A convenience method to create a new MIDIFunc which responds to MIDI smpte messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments seconds, framerate, dropframe, and srcID. (dropframe is a link::Classes/Boolean::).

returns:: A new instance of MIDIFunc which responds to MIDI smpte messages.

METHOD:: mtcQuarterFrame
A convenience method to create a new MIDIFunc which responds to MIDI Time Code Quarter Frame messages. Note that the link::#*smpte:: method above automatically assembles quarter frames into time code. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data, srcID, and pieceNumber. You will need to manually assemble each 8 messages into smpte.

returns:: A new instance of MIDIFunc which responds to MIDI Time Code Quarter Frame messages.

METHOD:: songPosition
A convenience method to create a new MIDIFunc which responds to MIDI song position messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments position and srcID.

returns:: A new instance of MIDIFunc which responds to MIDI song position messages.

METHOD:: songSelect
A convenience method to create a new MIDIFunc which responds to MIDI song select messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments song and srcID.

returns:: A new instance of MIDIFunc which responds to MIDI song select messages.

METHOD:: tuneRequest
A convenience method to create a new MIDIFunc which responds to MIDI tune request messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI tune request messages.

METHOD:: midiClock
A convenience method to create a new MIDIFunc which responds to MIDI clock messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI clock messages.

SUBSECTION:: System Realtime

METHOD:: sysrt
A convenience method to create a new MIDIFunc which responds generically to MIDI System Realtime and System Common messages. Note that the message specific methods above and below are probably more convenient in most cases. Note that this does not include MIDI Time Code Quarter Frame messages (sysrt index 1). For those see link::#*mtcQuarterFrame:: and link::#*smpte::. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data (may be nil), srcID, and index. Index indicates the message type as follows:
table::
## MIDI Time Code Quarter Frames || 1
## Song Position || 2
## Song Select || 3
## Tune Request || 6
## MIDI Clock || 8
## Tick || 9
## Start || 10
## Continue || 11
## Stop || 12
## Active Sense || 14
## Reset || 15
::

returns:: A new instance of MIDIFunc which responds to MIDI System Realtime messages.

METHOD:: tick
A convenience method to create a new MIDIFunc which responds to MIDI tick messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI tick messages.

METHOD:: start
A convenience method to create a new MIDIFunc which responds to MIDI start messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI start messages.

METHOD:: stop
A convenience method to create a new MIDIFunc which responds to MIDI stop messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI stop messages.

METHOD:: continue
A convenience method to create a new MIDIFunc which responds to MIDI continue messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI continue messages.

METHOD:: reset
A convenience method to create a new MIDIFunc which responds to MIDI reset messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI reset messages.

METHOD:: activeSense
A convenience method to create a new MIDIFunc which responds to MIDI active sense messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIFunc which responds to MIDI active sense messages.

SUBSECTION:: Debugging

METHOD:: trace
A convenience method which dumps all incoming MIDI messages.

argument:: bool
A link::Classes/Boolean:: indicating whether dumping is on or off.

INSTANCEMETHODS::
private:: init, printOn

METHOD:: chan
Get this MIDIFunc's MIDI channel number.

returns:: An link::Classes/Integer::.

METHOD:: msgNum
Get this MIDIFunc's MIDI message number.

returns:: An link::Classes/Integer::.

METHOD:: msgType
Get this MIDIFunc's message type.

returns:: A link::Classes/Symbol::; one of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, code::\program::, code::\sysex::, code::\mtcQF::, code::\smpte::, code::\songPosition::, code::\songSelect::, code::\tuneRequest::, code::\midiClock::, code::\sysrt::, code::\tick::, code::\start::, code::\continue::, code::\stop::, code::\activeSense::, or code::\reset::.

METHOD:: argTemplate
Get this MIDIFunc's argTemplate.
returns:: A link::Classes/Integer:: or link::Classes/Function:: (or object which responds to the method link::Overviews/Methods#matchItem::) used to match the value of an incoming MIDI message. (e.g. velocity, control value, program number, etc.).

METHOD:: learn
Train this MIDIFunc to respond to the next message of its type. Arguments passed at creation (e.g. chan, srcID, msgNum, etc.) will filter the training to the next matching message received.

argument:: learnVal
A link::Classes/Boolean:: indicating whether the responder should learn the specific value. For example, if used with a control change MIDIFunc, the object would learn to match the next specific control change value. If used with a note on MIDIFunc, it would match only a specific velocity. The default is false.

EXAMPLES::

code::
MIDIIn.connectAll

a = MIDIFunc.cc({arg ...args; args.postln}, 1); // match cc 1
a.free; // cleanup

b = MIDIFunc.cc({arg ...args; args.postln}, 1, 1); // match cc1, chan 1
b.free; // cleanup

c = MIDIFunc.cc({arg ...args; args.postln}, (1..10)); // match cc 1-10
c.free; // cleanup

n = MIDIFunc.noteOn({arg ...args; args.postln}); // match any noteOn
n.free; // cleanup

MIDIIn.doNoteOnAction(1, 1, 64, 64); // spoof a note on
MIDIIn.doControlAction(1, 1, 1, 64); // spoof a cc
MIDIIn.doControlAction(1, 1, 9, 64);
MIDIIn.doControlAction(1, 10, 1, 64);
::


CLASS:: MIDIFuncBothCAMessageMatcher
summary:: Matches incoming MIDI messages to responder funcs based on message channel and source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source and MIDI channel (when the MIDIFunc specifies an array of channels). This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chanArray
(describe argument here)

argument:: srcID
The UID of the MIDI source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncBothCAMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.


CLASS:: MIDIFuncBothMessageMatcher
summary:: Matches incoming MIDI messages to responder funcs based on message channel and source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source and MIDI channel. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chan
(describe argument here)

argument:: srcID
The UID of the MIDI source source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncBothMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.


CLASS:: MIDIFuncChanArrayMessageMatcher
summary:: Matches incoming MIDI messages to responder funcs based on message channel
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using MIDI channel (when the MIDIFunc specifies an array of channels). This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chanArray
(describe argument here)

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncChanArrayMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: srcID
The UID of the source of the MIDI message as an link::Classes/Integer::.


CLASS:: MIDIFuncChanMessageMatcher
summary:: Matches incoming MIDI messages to responder funcs based on message channel
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using MIDI channel. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chan
(describe argument here)

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncChanMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: srcID
The UID of the source of the MIDI message as an link::Classes/Integer::.


CLASS:: MIDIFuncSrcMessageMatcher
summary:: Matches incoming MIDI messages to responder funcs based on message source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: srcID
The UID of the MIDI source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncSrcMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.


CLASS:: MIDIFuncSrcMessageMatcherNV
summary:: Matches incoming MIDI messages to responder funcs based on message source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcherNV:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.


class:: MIDIIn
summary:: receive MIDI messages
related:: Classes/MIDIClient, Classes/MIDIOut, Classes/MIDIFunc, Classes/MIDIdef, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
This document explains technical details of the MIDI hardware interface class, MIDIIn.

MIDIIn is a simple and direct interface. When MIDI events come into SuperCollider, MIDIIn evaluates simple handler functions.

note::
For general programming, strong::users should not use the MIDIIn class directly::. See the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes for higher level event matching and more flexible handling of event handlers.
::

Certain MIDI messages are supported only through MIDIIn. These are: sysex, sysrt, smpte.

See the link::Guides/UsingMIDI:: helpfile for practical considerations and techniques for using MIDI in SC.

subsection::The MIDIIn class

MIDIIn links MIDI input received from the operating system to a set of user defined functions. Only one set of MIDI input handling functions can be active at a time, they are stored in the following class variables:

	noteOff, noteOn, polytouch, control, program, touch, bend, sysex, sysrt, smpte

The first argument these functions receive is an unique identifier that specifies the source of the data.


ClassMethods::

private::prDispatchEvent, connectByUID, disconnectByUID

method::findPort
searches for a connected link::Classes/MIDIEndPoint:: by name.
code::
//list connected ins:
MIDIClient.init;
MIDIClient.sources;
::

method::addFuncTo
Add a link::Classes/Function:: or similar object to be evaluated whenever a particular MIDI message is received. This method is preferable to the setters below, since it will not overwrite any existing functions.

argument::what
A link::Classes/Symbol:: indicating the message type to wait for, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
A link::Classes/Function:: or similar object to be evaluated when a message of the specified type is received. See the setters below for the arguments which will be passed at evaluation time.

method::removeFuncFrom
Remove a link::Classes/Function:: or similar object from the list of those to be evaluated whenever a particular MIDI message is received. This method is preferable to the setters below, since it will leave any existing functions in place.

argument::what
A link::Classes/Symbol:: indicating the message type, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
The link::Classes/Function:: or similar object to be removed.

method::replaceFuncTo
Replace a link::Classes/Function:: or similar object in the list to be evaluated whenever a particular MIDI message is received with another one. This method is preferable to the setters below, since it will not overwrite any existing functions.

argument::what
A link::Classes/Symbol:: indicating the message type to wait for, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
The link::Classes/Function:: or similar object to be replaced.

argument::newFunc
A link::Classes/Function:: or similar object to be evaluated when a message of the specified type is received. See the setters below for the arguments which will be passed at evaluation time.


method::noteOnZeroAsNoteOff

By default this flag is code::true:: and SuperCollider interprets incoming MIDI noteOn message with velocity 0 as noteOff messages. In case you do not want this automatic translation, you can set this flag to code::false::


method::connectAll

Connect to all possible MIDI inputs.

argument::verbose

If set to true (default) it will print out the ports found in MIDIClient.init.

method::disconnectAll

Disconnect from all MIDI inputs.


subsection:: Getter/Setters for Specific Message Types

The methods below allow you to register a function to respond to a particular message type.

note::It is preferable to use the link::#*addFuncTo::, link::#*removeFuncFrom:: and link::#*replaceFuncTo:: methods above instead of these methods, as they will not overwrite any functions added by system objects.::

method::noteOn
argument::value
a link::Classes/Function:: evaluated whenever a MIDI noteOn message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## velocity || 0 - 127
::

method::noteOff
argument::value
a link::Classes/Function:: evaluated whenever a MIDI noteOff message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## velocity || 0 - 127 (typically 64 unless noteOff velocity is supported)
::

method::polytouch
argument::value
a link::Classes/Function:: evaluated whenever a MIDI polytouch message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## pressure || 0 - 127
::

method::control
argument::value
a link::Classes/Function:: evaluated whenever a MIDI control change message (CC) is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## controllerNumber || 0 - 127
## value || 0 - 127
::

method::program
argument::value
a link::Classes/Function:: evaluated whenever a MIDI program change message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## programNumber || 0 - 127
::

method::touch
argument::value
a link::Classes/Function:: evaluated whenever a MIDI after-touch message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## pressure || 0 - 127
::

method::bend
argument::value
a link::Classes/Function:: evaluated whenever a MIDI pitch wheel change message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## bend || 0 - 16383 (14bits, the midpoint is 8192)
::

method::sysex
note::
The current implementation assembles a complete system exclusive packet before evaluating the function.
::
argument::value
a link::Classes/Function:: evaluated whenever a MIDI System Exclusive message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## data || an link::Classes/Int8Array:: (includes f0 and f7). See manufacturer references for details.
::

method::sysrt
table::
## strong::index:: || strong::data:: || strong::message::
## 2 || 14bits || song pointer
## 3 || 7bits || song select
## 8 || || midiclock
## 10 || || start
## 11 || || continue
## 12 || || stop
::
argument::value
a link::Classes/Function:: evaluated whenever a MIDI System Real-Time message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## index || ranges from 0 to 15
## data ||
::

method::smpte
Over MIDI, SMPTE is transmitted at 1/4 frame intervals four times faster than the frame rate.
table::
## strong::index:: || strong::data::
## 0 || frames low nibble
## 1 || frames hi nibble
## 2 || seconds low nibble
## 3 || seconds hi nibble
## 4 || minutes low nibble
## 5 || minutes hi nibble
## 6 || hours low nibble
## 7 || hours hi emphasis::bit:: OR'ed with frameRate
list::
## 0 -> 24 fps
## 2 -> 25 fps
## 4 -> 30 fps drop frame
## 6 -> 30 fps
::
::
Nibbles are sent in ascending order.
argument::value
a link::Classes/Function:: evaluated whenever a MIDI smpte message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## index || ranges from 0 to 7
## data || 0 - 15 (4bits)
::

Examples::

subsection::Quick start for 1 port
code::
(
MIDIIn.connect;	// init for one port midi interface
// register functions:
~noteOff = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~noteOn = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~polytouch = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~control = { arg src, chan, num, val;	[chan,num,val].postln; };
~program = { arg src, chan, prog;		[chan,prog].postln; };
~touch = { arg src, chan, pressure;	[chan,pressure].postln; };
~bend = { arg src, chan, bend;		[chan,bend - 8192].postln; };
~sysex = { arg src, sysex;		sysex.postln; };
~sysrt = { arg src, chan, val;		[chan,val].postln; };
~smpte = { arg src, chan, val;		[chan,val].postln; };
MIDIIn.addFuncTo(\noteOn, ~noteOn);
MIDIIn.addFuncTo(\noteOff, ~noteOff);
MIDIIn.addFuncTo(\polytouch, ~polytouch);
MIDIIn.addFuncTo(\control, ~control);
MIDIIn.addFuncTo(\program, ~program);
MIDIIn.addFuncTo(\touch, ~touch);
MIDIIn.addFuncTo(\bend, ~bend);
MIDIIn.addFuncTo(\sysex, ~sysex);
MIDIIn.addFuncTo(\sysrt, ~sysrt);
MIDIIn.addFuncTo(\smpte, ~smpte);
)

//cleanup
(
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\noteOff, ~noteOff);
MIDIIn.removeFuncFrom(\polytouch, ~polytouch);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\program, ~program);
MIDIIn.removeFuncFrom(\touch, ~touch);
MIDIIn.removeFuncFrom(\bend, ~bend);
MIDIIn.removeFuncFrom(\sysex, ~sysex);
MIDIIn.removeFuncFrom(\sysrt, ~sysrt);
MIDIIn.removeFuncFrom(\smpte, ~smpte);
)
::

subsection::Quick start for 2 or more ports
code::
(
	var inPorts = 2;
	var outPorts = 2;
	MIDIClient.init(inPorts,outPorts);	// explicitly intialize the client
	inPorts.do({ arg i;
		MIDIIn.connect(i, MIDIClient.sources.at(i));
	});
)
::

subsection::example with sound
code::
MIDIIn.connect;
s.boot;

(
SynthDef("sik-goo", { |out, freq = 440, formfreq = 100, gate = 0.0, bwfreq = 800|
	var x;
	x = Formant.ar(
		SinOsc.kr(0.02, 0, 10, freq),
		formfreq,
		bwfreq
	);
	x = EnvGen.kr(Env.adsr, gate, Latch.kr(gate, gate)) * x;
	Out.ar(out, x);
}).add;
)

x = Synth("sik-goo");

//set the action:
(
~noteOn = {arg src, chan, num, vel;
	x.set(\freq, num.midicps / 4.0);
	x.set(\gate, vel / 200 );
	x.set(\formfreq, vel / 127 * 1000);
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~noteOff = { arg src,chan,num,vel;
	x.set(\gate, 0.0);
};
MIDIIn.addFuncTo(\noteOff, ~noteOff);

~bend = { arg src,chan,val;
	//(val * 0.048828125).postln;
	x.set(\bwfreq, val * 0.048828125 );
};
MIDIIn.addFuncTo(\bend, ~bend);
)

//cleanup
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\noteOff, ~noteOff);
MIDIIn.removeFuncFrom(\bend, ~bend);
::

subsection::writing to the bus rather than directly to the synth
code::
//i used this and got acceptable latency for triggering synths live.
//The latency might actually be less than sc2, but i haven't used it enough
//to tell for sure yet.
//Powerbook G4, 512mb ram.
//- matrix6k@somahq.com

s.boot;

(
SynthDef("moto-rev", { |out, ffreq = 100|
	var x;
	x = RLPF.ar(
		LFPulse.ar(
			SinOsc.kr(0.2, 0, 10, 21),
			[0, 0.1],
			0.1
		),
		ffreq, 0.1
	).clip2(0.4);
	Out.ar(out, x);
}).add;
)

b = Bus.control(s);

x = Synth("moto-rev");

// map the synth's first input (ffreq) to read
// from the bus' output index
x.map(0, b);


MIDIIn.connect;
//set the action:
(
~noteOn = {arg src, chan, num, vel;
	b.value = num.midicps.postln;
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~control = {arg src, chan, num, val;
	[chan,num,val].postln;
};
MIDIIn.addFuncTo(\control, ~control);

~bend = {arg src, chan, val;
	val.postln;
};
MIDIIn.addFuncTo(\bend, ~bend);
)

// cleanup
x.free;
b.free;
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\bend, ~bend);
::

subsection::Keyboard Split for two voices
code::
//pbend to cutoff, mod to rez, 7 to amp
//- matrix6k@somahq.com

s.boot;
(
SynthDef("funk",{ | out, freq = 700, amp = 0.2, gate = 1, cutoff = 20000, rez = 1, lfospeed = 0 |
	var e, x, env, range, filterfreq;
	e = Env.new([0, 0.1, 0.1, 0], [0, 0.1, 0.1], 'linear', 2);
	env = Env.adsr(0.3,1,1,1);
	range = cutoff -1;
	filterfreq = SinOsc.kr(lfospeed,0, range, cutoff).abs;
	x = RLPF.ar(Mix.ar([
			Mix.arFill(2, {Saw.ar(freq *2 + 0.2.rand2, amp)}),
			Mix.arFill(2, {Saw.ar(freq *4+ 0.2.rand2, amp)})
		]),
		EnvGen.kr(env,gate)*filterfreq,
		rez);
	Out.ar(out, x * EnvGen.kr(e, gate, doneAction: Done.freeSelf))
}).add;

SynthDef("strings", { |out, freq = 700, amp = 0.2, gate = 1|
	var x, enve;
	enve = Env.new([0, 0.1, 0.1, 0], [2, 0.1, 1], 'linear', 2);
	x = RLPF.ar(Mix.ar([
			Mix.arFill(2, {Saw.ar(freq +2.rand2,0.6)}),
			Mix.arFill(2, {Saw.ar(freq *0.5 + 2.rand2,0.6)})
		]),
		6000,1);
	Out.ar(out, x * EnvGen.kr(enve, gate, doneAction: Done.freeSelf))
}).add;
)

(
var keys, cutspec, cutbus, rezspec, rezbus, lfospec, lfobus;
keys = Array.newClear(128);

MIDIClient.init;
MIDIIn.connect(0, MIDIClient.sources.at(0));

g = Group.new;

cutspec = ControlSpec(100,10000,\linear,0.001);
cutbus = Bus.new(\control,1,1,s);
cutbus.value = 10000;

rezspec = ControlSpec(1,0,\linear,0.001);
rezbus = Bus.new(\control,2,1,s);
rezbus.value = 1.0;

lfospec = ControlSpec(0,50,\linear,0.001);
lfobus = Bus.new(\control,3,1,s);

~control = {arg src, chan, num, val;
	if(num == 1,{
		rezbus.value = rezspec.map(val/127.0);
	});
	if(num == 7,{
		lfobus.value = lfospec.map(val/127.0).postln;
	});
};
MIDIIn.addFuncTo(\control, ~control);

~bend = {arg src, chan, val;
	cutbus.value = cutspec.map(val/16383.0);
};
MIDIIn.addFuncTo(\bend, ~bend);

~noteOn = {arg src, chan, num, vel;
	var node;
	if(num < 60, {
		node = Synth.tail(g, "funk", [\freq, num.midicps, \amp, vel/255]);
		node.map("cutoff",1,"rez",2,"lfospeed",3);
//		node = Synth.basicNew("funk",s);
//		s.sendBundle(nil,
//			node.addToTailMsg(g,[\freq, num.midicps, \amp, vel/255]),
//			node.mapMsg("cutoff",1,"rez",2,"lfospeed",3)
//		);
		keys.put(num, node)
	},{
		node = Synth.tail(g, "strings", [\freq, num.midicps, \amp, vel/255]);
		keys.put(num, node)
	});
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~noteOff = {arg src, chan, num, vel;
	var node;
	node = keys.at(num);
	if (node.notNil, {
		keys.put(num, nil);
		s.sendMsg("/n_set", node.nodeID, "gate", 0);
		// or node.release
		// then free it ... or get the NodeWatcher to do it
	});
};
MIDIIn.addFuncTo(\noteOff, ~noteOff);
)

//cleanup
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\bend, ~bend);

::


CLASS:: MIDIMessageDispatcher
summary:: The default dispatcher for MIDIFunc's and MIDIdef's set to respond to noteOn, noteOff, control, and polytouch messages.
categories:: External Control>MIDI>Dispatchers
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/MIDIMessageDispatcherNV, Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher, Guides/MIDI

DESCRIPTION::
MIDIMessageDispatcher is used to dispatch incoming MIDI noteOn, noteOff, control, and polytouch messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::

METHOD:: new
Create a new instance.

argument:: messageType
A link::Classes/Symbol:: indicating the message type, one of code::\noteOn::, code::\noteOff::, code::\control::, or code::\polytouch::.

returns:: A new MIDIMessageDispatcher.


INSTANCEMETHODS::

METHOD:: messageType
Get this dispatcher's message type, one of code::\noteOn::, code::\noteOff::, code::\control::, or code::\polytouch::.

returns:: A link::Classes/Symbol::.

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be MIDI message numbers.

argument:: funcProxy
The link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's message number as an link::Classes/Integer::.

METHOD:: value
Attempt to match an incoming MIDI message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: src
The UID of the source of the MIDI message as an link::Classes/Integer::.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: val
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

METHOD:: register
Adds this dispatcher to the appropriate receive hook in link::Classes/MIDIIn::.

METHOD:: unregister
Removes this dispatcher from the appropriate receive hook in link::Classes/MIDIIn::.

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose function(s) are to be wrapped.

METHOD:: typeKey
Gets a key indicating the type of message this dispatcher responds to, in the form: code::('MIDI ' ++ messageType).asSymbol::.

returns:: A link::Classes/Symbol::.



CLASS:: MIDIMessageDispatcherNV
summary:: The default dispatcher for MIDIFunc's and MIDIdef's set to respond to touch, program, and bend messages.
categories:: External Control>MIDI>Dispatchers
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/MIDIMessageDispatcher, Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher, Guides/MIDI

DESCRIPTION::
MIDIMessageDispatcherNV is used to dispatch incoming MIDI touch, program, and bend messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be MIDI channels.

argument:: funcProxy
The link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's channel number as an link::Classes/Integer::.

METHOD:: value
Attempt to match an incoming MIDI message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: src
The UID of the source of the MIDI message as an link::Classes/Integer::.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: val
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose function(s) are to be wrapped.



class:: MIDIOut
summary:: send MIDI messages
related:: Classes/MIDIClient, Classes/MIDIIn, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
a MIDIOut is bound to a specific link::Classes/MIDIEndPoint:: as defined by the operating system.

Linux users, or any users who require cross-platform compatibility with Linux, should read link::#Linux specific: Connecting and disconnecting ports:: carefully.

ClassMethods::

private::connectByUID, disconnectByUID

method::new

Create a new MIDIOut instance. Note that this method is not safe for cross-platform usage with Linux, because the meaning of the teletype::port:: argument is different. See link::#Linux specific: Connecting and disconnecting ports:: for details.

argument::port
definitionList::
## macOS, Windows || The index of the MIDIEndPoint in the code::MIDIClient.destinations:: array.
## Linux || The output port number. teletype::MIDIEndPoint("SuperCollider", "out0"):: is port 0; teletype::"out1":: is port 1. In Linux, this argument has no connection at all to code::MIDIClient.destinations::.
::

argument::uid
definitionList::
## macOS / Windows || uid is optional; if specified, it should be the uid of that port ie. MIDIClient.destinations[port].uid. If you don't provide a uid, the correct uid will be filled in for you (easier).
## Linux || using the uid is optional as described below.
::

method::newByName
Searches for the MIDI output device, by a name found in the code::MIDIClient.destinations:: array. This is safer then depending on the index which will change if your studio setup changes. It is also Linux compatible.
code::
//list connected out ports with names:
MIDIClient.init;
MIDIClient.destinations;
::

method::findPort
Searches for a connected MIDIEndPoint by name.
code::
//list connected out ports with names:
MIDIClient.init;
MIDIClient.destinations;
::

method::connect, disconnect
Linux only. MacOS does not need to connect. On Linux it is an optional feature (see below).

InstanceMethods::
method::sysex
Sends a sysex command represented as an link::Classes/Int8Array:: to the device.

note::
The method call should contain a full sysex message. In other words,
it should start with 0xF0 (240 or -16) and end with 0xF7 (247 or -9).
::

argument:: packet
An Int8Array of data bytes to be sent.

code::
m = MIDIOut(0);

m.sysex(Int8Array[0xF0, 1, 2, 3, 0xF7]);  // OK!

m.sysex(Int8Array[1, 2, 3]);  // not OK
::

private::send, prSysex

method::latency
This sets the latency with which a midi event is sent out. Per default, this is set to 0.2, in order to be equal to the Server.latency.
note::
On Linux, there seems to be an ALSA or kernel bug if the latency is larger than 0, for some Linux kernels. If MIDIOut does not seem to work, set the latency to 0.
::

Examples::

code::
MIDIClient.init;

m = MIDIOut(0);  // Linux users: MIDIOut(0, MIDIClient.destinations[0].uid)
m.noteOn(16, 60, 60);
m.noteOn(16, 61, 60);
m.noteOff(16, 61, 60);
m.allNotesOff(16);


MIDIIn.connect; // 1 port midi interface
MIDIIn.sysex = { arg uid, packet; [uid,packet].postln };
MIDIIn.sysrt = { arg src, chan, val;  [src, chan, val].postln; };
MIDIIn.smpte = { arg src, chan, val;  [src, chan, val].postln; };

m.sysex(Int8Array[0xF0, 0, 0, 27, 11, 0, 0xF7])

m.smpte(24, 16)
m.midiClock
m.start
m.continue
m.stop
::

subsection::Using patterns for sending MIDI events

code::
MIDIClient.init;
m = MIDIOut(0);  // Linux users: MIDIOut(0, MIDIClient.destinations[0].uid)

a = Pbind(\degree, Prand([1, 2, 3, [0, 5]], inf), \bend, Pwhite(0, 76, inf));


// chain a midi event into the pattern and play it (see Pchain)

(a <> (type: \midi, midiout: m)).play;
::

See link::Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters#MIDI output:: for a list of midi commands supported by the 'midi' event type.

subsection::Linux specific: Connecting and disconnecting ports

In Linux, the MIDIOut architecture is different from other operating systems.

In macOS and Windows, a MIDIOut instance is bound to a specific destination MIDI device.

SuperCollider in Linux uses the ALSA MIDI layer. ALSA MIDI applications send messages out through a "virtual output port," which is one of the members of code::MIDIClient.sources::.

code::
MIDIClient.init;
::

teletype::
MIDI Sources:
	MIDIEndPoint("System", "Timer")
	MIDIEndPoint("System", "Announce")
	MIDIEndPoint("Midi Through", "Midi Through Port-0")
	MIDIEndPoint("SuperCollider", "out0")
	MIDIEndPoint("SuperCollider", "out1")
::

At this point, creating code::MIDIOut(0):: tells SuperCollider that this MIDIOut object should direct messages to teletype::MIDIEndPoint("SuperCollider", "out0")::. (It seems strange, if you think of SuperCollider sending messages to this MIDI emphasis::source::. It is more accurate to think of SuperCollider sending messages emphasis::through:: this port. The port is, then, a source for the rest of the system.)

A code::MIDIOut(0):: object, then, will not reach any destinations by default. The user needs to connect destination devices to the virtual source port, using either a graphical tool such as Qjackctl, or by MIDIOut's teletype::connect:: method.

code::
m = MIDIOut(0);  // use virtual source port "out0"
m.connect(1);  // connect to MIDIClient.destinations[1]
::

WARNING:: The teletype::port:: argument to link::Classes/MIDIOut#*new:: has an entirely different meaning in Linux, compared to macOS and Windows. If user code calls this method emphasis::and:: cross-platform compatibility is needed, it is the user's responsibility to handle Linux separately. User code can check the platform using code::thisProcess.platform.name:: (which returns one of code::\osx::, code::\linux:: or code::\windows::). Or, for compatibility, use link::#*newByName:: instead.::

link::Classes/MIDIOut#*new:: optionally takes a second argument, for the uid of the MIDI destination device. If the uid is non-zero, then: 1/ all connections in the ALSA MIDI patchbay are ignored, and 2/ individual messages will be sent directly to the specified device.

link::Classes/MIDIOut#*newByName:: locates a device by name and populates the uid in the new MIDIOut object. After successful completion, a MIDIOut object created using this method will have a non-zero uid.

note::
A non-zero uid (whether specified in teletype::MIDIOut.new::, found by teletype::MIDIOut.newByName::, or set manually later) does not create or use any ALSA MIDI connections. It is not a "connection" at all; rather, it is a parameter that causes outgoing MIDI messages to bypass ALSA MIDI connections and go directly to one specific device. Because it is not a connection, there is nothing to show in MIDI patchbay interfaces; users should not expect to see connections for these MIDIOut objects.

Also, because a uid bypasses patchbay connections, it is meaningless to specify a uid and use teletype::.connect:: at the same time. A single MIDIOut object should not do both at once. (It does not break anything, but the patchbay connections are ignored.)
::

strong::Compatibility::
list::
## code::MIDIOut.newByName("device", "port"):: -- Should be compatible on all systems.
## code::MIDIOut(index):: -- macOS, Windows (teletype::index:: is the device's index in code::MIDIClient.destinations::). Note that this usage is emphasis::not:: compatible with Linux! macOS and Windows users should not expect Linux users to be able to run this style of connection.
## code::MIDIOut(0, MIDIClient.destinations[index].uid):: -- Linux only (teletype::index:: is the device's index in code::MIDIClient.destinations::).
::


subsection::macOS specific: Sending MIDI to other applications

Open the Audio MIDI Setup application. Double-click on IAC Driver and check "device is online".

reinitialize:

MIDIClient.init(numIns,numOuts)

The IAC Bus will now appear in MIDIClient.destinations. It will appear first, which means that any code that you have written that addresses the first physical bus as 0 will now have to be changed.

For this reason, it is always safer to find the port by name :
code::
MIDIOut.newByName("RemoteSL IN","Port 1");
::
The IAC Bus will now also appear to other applications.


MIDIMonitor (freeware) can be very useful for troubleshooting:

http://www.snoize.com/MIDIMonitor/

subsection::Sysex example

a machinedrum manual say sysex commands should be formatted like this...
code::
$f0,$00,$20,$3c,$02,$00,command,...,$f7
::

and to set the tempo the machinedrum expects this command...
code::
$61 | Set tempo ID
%0aaaaaaa | Upper bits
%0bbbbbbb | Lower bits
$f7 | SYSEX end
Note: Tempo = %aaaaaaabbbbbbb / 24, max 300 BPM, min 30 BPM
::

so to create and send a valid set tempo sysex command from SuperCollider to this machinedrum do...
code::
MIDIClient.init;
m = MIDIOut(0);  // Linux users: MIDIOut(0, MIDIClient.destinations[0].uid)
m.sysex(Int8Array[0xf0, 0x00, 0x20, 0x3c, 0x02, 0x00, 0x61, 21, 54, 0xf7]);
::

This will set the tempo to 114.23 bpm. One can calculate the upper and lower 7bit values like this...
code::
(
var bpm, val, upper, lower;
bpm = 114.23;
val = (bpm*24).round.asInteger;
upper = val&2r11111110000000>>7;
lower = val&2r00000001111111;
[upper, lower].postln;
)
::
where the resulting 21 and 54 are the same as 2r0010101 and 2r0110110 in binary notation.


class:: MIDIResponder
summary:: Register multiple functions to be evaluated when MIDI events occur
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIIn, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::

MIDIResponder is an emphasis::abstract:: class. Its subclasses allow functions to be registered to respond to midi events.

Read the general help file here and then see the individual help files.

definitionList::
## link::Classes/CCResponder:: || Respond to control messages
## link::Classes/NoteOnResponder:: || Respond to note-on messages
## link::Classes/NoteOffResponder:: || Respond to note-off messages
## link::Classes/BendResponder:: || Respond to pitch bend messages
## link::Classes/TouchResponder:: || Respond to aftertouch messages
## link::Classes/ProgramChangeResponder:: || Respond to programchange messages
::

subsection::Creation and initialization

list::
## CCResponder(function, src, chan, num, value, install = true, swallowEvent = false)
## NoteOnResponder(function, src, chan, num, veloc, install = true, swallowEvent = false)
## NoteOffResponder(function, src, chan, num, veloc, install = true, swallowEvent = false)
## BendResponder(function, src, chan, value, install = true, swallowEvent = false)
## TouchResponder(function, src, chan, value, install = true, swallowEvent = false)
## ProgramChangeResponder(function, src, chan, value, install = true)
::

definitionList::

## function || The function to execute when the incoming MIDI event matches the responder. The function takes the arguments src, chan, A, B (or for Bend, ProgramChange and Touch: src, chan, value).

## src || If a number is given, the responder will fire only for messages coming in from this port. The number may be the system UID (obtained from MIDIClient.sources[index].uid) or the index itself. If nil, the responder will match any port.

## chan || The MIDI channel(s) to match.

## num || The control or note number(s) to match.

## value || The value(s) to match.

## veloc || The velocities to match.

## install || If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

## swallowEvent || If true, then if the midi event is matched, cease testing any further responders. eg. if a CCResponder matches port, chan and num, and swallowEvent is set to true, then no further CCResponders will be offered the chance to respond to the event. The event is "swallowed". By default this is false. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

::

Any of the matching values may be one of the following:

definitionList::
## Nil || Match anything. eg. if chan is nil, then respond to any MIDI channel.
## Integer || Match only this specific number.
## Array || Match any item in the array. Any kind of link::Classes/Collection:: will work here.
## Function || Evaluate the function with the incoming value as the argument. The function should return true or false.
::

For instance, the following example would respond to note on messages from any port, channels 2 and 7 only, even numbered note numbers only, and only velocity values greater than 50.
code::
NoteOnResponder({ |src, chan, num, vel| [src, chan, num, vel].postln },
	nil,	// any port
	[2, 7],	// midi channels 2 or 7 only
	(0, 2..126),	// this is an array of even numbers. could also be specified as { |num| num.even } or _.even
	{ |vel| vel > 50 });	// velocities greater than 50
::

MIDIResponders automatically initialize the MIDIClient with 1 standard device. This means the first time you install any MIDIResponder, it will make sure that MIDI has been initialized. If you have more devices or a specific setup, simply initialize the MIDIClient yourself before using any MIDIResponders.

subsection::Removal

Just call .remove on the responder.
code::
c = CCResponder({ ... }, num: 1);	// respond to any modwheel

c.remove;		// stop this responder
::

Or remove all of a specific class:
code::
CCResponder.removeAll
NoteOnResponder.removeAll
NoteOffResponder.removeAll
BendResponder.removeAll
TouchResponder.removeAll
ProgramChange.removeAll
::

or remove all midi responders in all classes:
code::
MIDIResponder.removeAll
::


CLASS:: MIDIdef
summary:: MIDI response reference definition
categories:: External Control>MIDI
related:: Guides/MIDI, Classes/MIDIFunc

DESCRIPTION::
MIDIdef provides a global reference to the functionality of its superclass link::Classes/MIDIFunc::. Essentially it stores itself at a key within a global dictionary, allowing replacement at any time. Most methods are inherited from its superclass.

subsection:: Important note on persistence

MIDIFunc (and its subclass link::Classes/MIDIdef:: like all other
AbstractResponderFuncs) are removed on pressing Cmd/ctrl-. To override this
behavior, use the link::Classes/AbstractResponderFunc#-permanent:: method.

CLASSMETHODS::
private:: initClass

METHOD:: all
Get the global dictionary of all MIDIdefs.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled MIDIdef. If a MIDIdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values). Normally one would use one of the message type specific convenience methods below, rather than use this method directly.

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated for noteOn, noteOff, control, and polytouch messages it will be passed the arguments val, num, chan, and src, corresponding to the message value (e.g. velocity, control value, etc.), message number (e.g. note number), MIDI channel, and MIDI source uid. For touch, program change and bend messages it will be passed only val, chan, and src. For information on the args passed for the other sorts of code::msgType:: see the convenience methods below.

argument:: msgNum
An link::Classes/Integer:: indicating the MIDI message number (note number, control number, or program number) for this MIDIdef. This can be an array. If nil, the MIDIdef will respond to messages of all possible message numbers.

argument:: chan
An link::Classes/Integer:: indicating the MIDI channel number for this MIDIdef. This can be an array. If nil, the MIDIdef will respond to messages received on all channels.

argument:: msgType
A link::Classes/Symbol:: indicating which kind of MIDI message this MIDIdef should respond to. One of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, code::\program::, code::\sysex::, code::\mtcQF::, code::\smpte::, code::\songPosition::, code::\songSelect::, code::\tuneRequest::, code::\midiClock::, code::\sysrt::, code::\tick::, code::\start::, code::\continue::, code::\stop::, code::\activeSense::, or code::\reset::.

argument:: srcID
An link::Classes/Integer:: corresponding to the uid of the MIDI input. (See link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::.) If nil, the MIDIdef will respond to messages received from all sources.

argument:: argTemplate
An optional link::Classes/Integer:: or link::Classes/Function:: (or object which responds to the method link::Overviews/Methods#matchItem::) used to match the value of an incoming MIDI message. (e.g. velocity, control value, program number, etc.). If a Function, it will be evaluated with the message value as an argument, and should return a link::Classes/Boolean:: indicating whether the message matches and this MIDIdef should respond.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: An instance of MIDIdef.

METHOD:: freeAll
Clears and deactivates all MIDIdefs from the global collection.

METHOD:: cc
A convenience method to create a new MIDIdef which responds to MIDI control messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI control messages.

METHOD:: noteOn
A convenience method to create a new MIDIdef which responds to MIDI note on messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI note on messages.

METHOD:: noteOff
A convenience method to create a new MIDIdef which responds to MIDI note off messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI note off messages.

METHOD:: polytouch
A convenience method to create a new MIDIdef which responds to MIDI polytouch messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI polytouch messages.

METHOD:: touch
A convenience method to create a new MIDIdef which responds to MIDI touch messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI touch messages.

METHOD:: bend
A convenience method to create a new MIDIdef which responds to MIDI bend messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI bend messages.

METHOD:: program
A convenience method to create a new MIDIdef which responds to MIDI program change messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI program change messages.

METHOD:: sysex
A convenience method to create a new MIDIdef which responds to MIDI system exclusive messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data (an link::Classes/Int8Array::) and srcID.

returns:: A new instance of MIDIdef which responds to MIDI system exclusive messages.

SUBSECTION:: System Common

N.B. Because of SC's underlying low level MIDI implementation, there is no generic code::msgType:: and convenience method for System Common messages. Instead these are grouped with System Realtime under link::#*sysrt:: below.

METHOD:: smpte
A convenience method to create a new MIDIdef which responds to MIDI smpte messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments seconds, framerate, dropframe, and srcID. (dropframe is a link::Classes/Boolean::).

returns:: A new instance of MIDIdef which responds to MIDI smpte messages.

METHOD:: mtcQuarterFrame
A convenience method to create a new MIDIdef which responds to MIDI Time Code Quarter Frame messages. Note that the link::#*smpte:: method above automatically assembles quarter frames into time code. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data, srcID, and pieceNumber. You will need to manually assemble each 8 messages into smpte.

returns:: A new instance of MIDIdef which responds to MIDI Time Code Quarter Frame messages.

METHOD:: songPosition
A convenience method to create a new MIDIdef which responds to MIDI song position messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments position and srcID.

returns:: A new instance of MIDIdef which responds to MIDI song position messages.

METHOD:: songSelect
A convenience method to create a new MIDIdef which responds to MIDI song select messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments song and srcID.

returns:: A new instance of MIDIdef which responds to MIDI song select messages.

METHOD:: tuneRequest
A convenience method to create a new MIDIdef which responds to MIDI tune request messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI tune request messages.

METHOD:: midiClock
A convenience method to create a new MIDIdef which responds to MIDI clock messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI clock messages.

SUBSECTION:: System Realtime

METHOD:: sysrt
A convenience method to create a new MIDIdef which responds generically to MIDI System Realtime and System Common messages. Note that the message specific methods above and below are probably more convenient in most cases. Note that this does not include MIDI Time Code Quarter Frame messages (sysrt index 1). For those see link::#*mtcQuarterFrame:: and link::#*smpte::. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the arguments data (may be nil), srcID, and index. Index indicates the message type as follows:
table::
## MIDI Time Code Quarter Frames || 1
## Song Position || 2
## Song Select || 3
## Tune Request || 6
## MIDI Clock || 8
## Tick || 9
## Start || 10
## Continue || 11
## Stop || 12
## Active Sense || 14
## Reset || 15
::

returns:: A new instance of MIDIdef which responds to MIDI System Realtime messages.

METHOD:: tick
A convenience method to create a new MIDIdef which responds to MIDI tick messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI tick messages.

METHOD:: start
A convenience method to create a new MIDIdef which responds to MIDI start messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI start messages.

METHOD:: stop
A convenience method to create a new MIDIdef which responds to MIDI stop messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI stop messages.

METHOD:: continue
A convenience method to create a new MIDIdef which responds to MIDI continue messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI continue messages.

METHOD:: reset
A convenience method to create a new MIDIdef which responds to MIDI reset messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI reset messages.

METHOD:: activeSense
A convenience method to create a new MIDIdef which responds to MIDI active sense messages. See link::#*new:: for argument descriptions. The responding code::func:: will be passed the argument srcID.

returns:: A new instance of MIDIdef which responds to MIDI active sense messages.

INSTANCEMETHODS::
private:: addToAll, printOn

METHOD:: key
Get this MIDIdef's key.

returns:: Usually a link::Classes/Symbol::.

METHOD:: free
Clears this MIDIdef from the global collection and deactivates it.

EXAMPLES::

code::
MIDIIn.connectAll
MIDIdef.cc(\test1, {arg ...args; args.postln}, 1); // match cc 1
MIDIdef.cc(\test2, {arg ...args; args.postln}, 1, 1); // match cc1, chan 1
MIDIdef.cc(\test3, {arg ...args; args.postln}, (1..10)); // match cc 1-10
MIDIdef.noteOn(\test4, {arg ...args; args.postln}); // match any noteOn

MIDIIn.doNoteOnAction(1, 1, 64, 64); // spoof a note on
MIDIIn.doControlAction(1, 1, 1, 64); // spoof a cc
MIDIIn.doControlAction(1, 1, 9, 64);
MIDIIn.doControlAction(1, 10, 1, 64);

MIDIdef(\test1).free; // free one def
MIDIdef.freeAll;      // free all registered MIDIdefs
::


class:: Magnitude
summary:: Comparable value in a linear continuum
categories:: Math

description::
Magnitudes represent values along a linear continuum which can be compared against each other.

instancemethods::
method:: <
returns:: a link::Classes/Boolean:: whether the receiver is less than strong::aMagnitude::.

method:: <=
returns:: a link::Classes/Boolean:: whether the receiver is less than or equal to strong::aMagnitude::.

method:: >
returns:: a link::Classes/Boolean:: whether the receiver is greater than strong::aMagnitude::.

method:: >=
returns:: a link::Classes/Boolean:: whether the receiver is greater than or equal to strong::aMagnitude::.

method:: min
returns:: the minimum of the receiver and aMagnitude.

method:: max
returns:: the maximum of the receiver and aMagnitude.

method:: clip
If the receiver is less than minVal then answer minVal, else if the receiver is greater than maxVal then answer maxVal, else answer the receiver.

method:: inclusivelyBetween
returns:: whether the receiver is greater than or equal to minVal and less than or equal to maxVal.

method:: exclusivelyBetween
returns:: whether the receiver is greater than minVal and less than maxVal.



class::Main
categories::Core>Kernel
summary:: The concrete instance of Process
related:: Classes/StartUp

description::

Main is the concrete instance of link::Classes/Process:: (the runtime environment for the virtual machine and interpreter).
Main overrides some methods of Process. There are two methods of interest. One is named startup and is
called after the class library has been compiled. The other is called shutdown which gets called when the library gets re-compiled.

method:: thisProcess
The singleton instance of Main is available through the special keyword thisProcess.
For example, to find out what platform you're on:

code::
thisProcess.platform;	// --> e.g. "an OSXPlatform", "a LinuxPlatform", ...
::

classMethods::

subsection:: SuperCollider version
These class methods tell you which version of SuperCollider you are running and whether that version complies to your required minimum / maximum settings:

method::version

returns:: the current version as a human readable string

method::versionAtLeast

Returns code::true:: if we are running version maj.min.patch or newer, false otherwise. If code::min:: and/or
code::patch:: are code::nil::, they will be treated as wildcards. The tweak part of the version is completely ignored.

argument::maj
Major version number as Integer.

argument::min
Minor version number as Integer, or code::nil::.

argument::patch
Patch version number as Integer, or code::nil::.

code::
Main.versionAtLeast(3, 10, 4);
::

method::versionAtMost

Returns code::true:: if we are running version maj.min.patch or older, false otherwise. If code::min:: and/or
code::patch:: are code::nil::, they will be treated as wildcards. The tweak part of the version is completely ignored.

argument::maj
Major version number as Integer.

argument::min
Minor version number as Integer, or code::nil::.

argument::patch
Patch version number as Integer, or code::nil::.

code::
Main.versionAtMost(3, 13, 9);
::

method::scVersionMajor

returns:: major version number as Integer

method::scVersionMinor

returns:: minor version number as Integer

method::scVersionPatch

returns:: patch version number as Integer

method::scVersionTweak

The "tweak" version is typically only used to distinguish pre-release versions of SC from proper releases. It may be
empty.

returns:: tweak version as a String

method::scVersionPostfix

Deprecated. Use code::scVersionPatch:: and code::scVersionTweak:: instead.

instanceMethods::

private::prArgv, prOpenUDPPort

method::startup

Called after the class library has been compiled.

discussion::
This calls the superclass' startup, which among other things initializes the link::Classes/AppClock:: and the top-level link::Classes/Environment::.

Main's startup then stores Server.default in the interpreter variable s, sets the platform default's link::Classes/GUI:: kit, calls a link::Classes/Platform:: specific startup method (for example, OSXPlatform's startup opens the server windows), and finally invokes StartUp.run.

To add your own startup functionalities, you could either edit the special startup-file (discussed in link::Reference/StartupFile::), or use StartUp.add as discussed in the link::Classes/StartUp:: help file.

method::shutdown

Called after SuperCollider is quit or the class library is about to be re-compiled.

discussion::
This will quit all audio link::Classes/Server:: instances, perform a platform specific shutdown (e.g. the HID subsystem is released), finally Process' shutdown method is called, resulting in successive calls to UI.shutdown, NetAddr.disconnectAll, File.closeAll, and Archive.write. To register your own shutdown code, use a call like this:

code::
ShutDown.add({ "Good bye!!".postln });
::

method::run

Override this to do whatever you want, e. g. add a class extension file like this to the class library:

code::
+ Main {
	run { "myPatch.rtf".load }
}
::

argument::newFunc
A link::Classes/Function:: or similar object to be set. When evaluated, this function will be passed the arguments time, replyAddr, and message, corresponding to the time the message was sent, the link::Classes/NetAddr:: of the sender, and the message itself as an link::Classes/Array::.

method::addOSCRecvFunc

Register a link::Classes/Function:: to be evaluated whenever SuperCollider language (the client) receives an OSC message. This will not overwrite any previously registered functions.

argument::func
A link::Classes/Function:: or similar object to be added. When evaluated, this function will be passed the arguments msg, time, replyAddr, and recvPort, corresponding to the message itself as an link::Classes/Array::, the time the message was sent, the link::Classes/NetAddr:: of the sender, and the port on which the message was received. Note that this order differs from that used by the deprecated method link::#-recvOSCfunc::.

code::
// post all incoming traffic except the server status messages
// basically the same as OSCFunc.trace
(
f = { |msg, time, replyAddr, recvPort|
	if(msg[0] != '/status.reply') {
		"At time %s received message % from % on port%\n".postf( time, msg, replyAddr, recvPort )
	}
};
thisProcess.addOSCRecvFunc(f);
);

// stop posting.
thisProcess.removeOSCRecvFunc(f);
::

method::removeOSCRecvFunc

Remove a link::Classes/Function:: from the list of those evaluated whenever SuperCollider language (the client) receives an OSC message. This will leave any other registered functions in place.

argument::func
A link::Classes/Function:: or similar object to be removed.

method::replaceOSCRecvFunc

Replace a link::Classes/Function:: in the list of those evaluated whenever SuperCollider language (the client) receives an OSC message with a different one. This will leave any other registered functions in place.

argument::func
The link::Classes/Function:: or similar object to be replaced.

argument::newFunc
A link::Classes/Function:: or similar object to be replace the one being removed. When evaluated, this function will be passed the arguments time, replyAddr, recvPort, and message, corresponding to the time the message was sent, the link::Classes/NetAddr:: of the sender, the port on which the message was received, and the message itself as an link::Classes/Array::.

method::openUDPPort
Attempt to open a new UDP port for receiving OSC traffic. If another application has already bound to the requested port this will fail. Once opened, ports remain bound until SC is recompiled.

If the port was already opened by SC it will return true directly without trying to open the port again.

argument::portNum
An link::Classes/Integer:: indicating the port to attempt to bind.

argument::type
An link::Classes/Symbol:: \osc or \raw, indicating which type of messages to expect. \osc will receive callbacks at code::Main:recvOSCmessage::, \raw will receive callbacks at code::Main:recvRawMessage::.

returns::A link::Classes/Boolean:: indicating whether the attempt was successful.

code::
thisProcess.openUDPPort(3000); // will return true or false.
thisProcess.openPorts; // returns all open ports
::

method::openPorts
Get a collection of all active UDP ports, including the main sclang port code::NetAddr.langPort::.

returns::A link::Classes/Set::.

method::pid

Returns:: The operating system's pid (process ID) for the process.

method::recompile

Recompiles the class library.

method::platform
Get the current link::Classes/Platform::

method::argv
Get the command-line arguments passed to sclang.



TITLE:: MainMenu
summary:: A manager for sclang's application-level menu
categories:: GUI
related:: Classes/MenuAction, Classes/ToolBar, Classes/MainMenu

DESCRIPTION::
This class allows control over items displayed in the sclang application-level menu. Application-level menus may not exist depending on platform — in particular, macOS and some Linux window managers have it, but Windows does not. On platforms without this feature, the methods in this class simply don't do anything.

note:: This is the menu for the sclang application, not the IDE. ::

warning:: The behavior of this class changed in version 3.10.2. Menu items for controlling the process and servers will not be added and updated by default, as in versions 3.10.0 and 3.10.1.  Those items can still be created by calling code::initBuiltInMenus::. This behavior may change again in a future version.::

CODE::
(
~testTone = MenuAction("Test Tone", {
	{ SinOsc.ar(400) * 0.1 }.play;
});

MainMenu.register(~testTone, "Tests");
)

MainMenu.unregister(~testTone); // to remove
::

CLASSMETHODS::

private:: prGetMenu, prGetMenuGroup, prUpdateServersMenu, prBuildAppMenus, prUpdate, prSetAppMenus

METHOD:: initBuiltInMenus
	Initialize menu items under the main "SuperCollider" menu that enable process and server monitoring and control:
		LIST::
			## Stop - same as Cmd/Ctrl-Period
			## Servers - a submenu listing available servers, with items for controlling each. The
default server will be noted, and selecting the name of a server in this menu will set it as the
default.
			## Quit - quit sclang process
		::

METHOD:: register
	Register a MenuAction to a main application menu. This menu item will exist for the duration of the app, or until .unregister is called for the action.

	ARGUMENT:: action
		A link::Classes/MenuAction::.
	ARGUMENT:: menu
		A String, representing the name of the top-level menu to contain the action.
	ARGUMENT:: group
		An optional string. Action will be placed in a section of the menu with other members of the same group, with a separator between items of other groups.

	DISCUSSION::
		MainMenu.register provides an easy way to register global menu items, in a way that helps avoid disrupting menus registered by other SuperCollider components.

		If you want to register menus for personal use, add the registration calls to your startup.scd file. This will ensure the menus are created automatically on launch.

		If you're registering menu actions for a Quark or other component intended for distribution, be sure to be polite and thoughtful about where you're registering actions.

		Avoid creating new top-level menus if possible - instead, try to use one of the following canonical menus to register your actions. Add your actions to a group to ensure you don't collide with actions from another component:
		LIST::
			## File
			## Edit
			## Server
			## Quarks
			## Help
		::

		If registering menu items for a Quark, consider registering as a sub-menu of the Quarks menu. This can easily be done using the link::#*registerQuarkMenu:: method.

METHOD:: registerQuarkMenu
	Convenience method for registering a menu of functionality related to a Quark.
	It will appear as a sub-menu under the main Quarks menu.

	ARGUMENT:: quarkName
		A String, the name of the quark
	ARGUMENT:: menu
		A link::Classes/Menu::, a menu.

METHOD:: unregister
	Remove a MenuAction that has been registered previously.
	NOTE::
		It is usually disruptive and confusing to add and remove menu items dynamically.
		If you're registering a menu item that should only sometimes be available, consider disabling it using code::menuAction.enabled = false;:: rather than removing it.
	::

	ARGUMENT::
		A MenuAction.

METHOD:: otherMenus
	A list of menus to append to the set of main application menus.

	WARNING::This is intended for standalone SuperCollider applications, and should not be used to register menus during normal SC usage.::

METHOD:: add
	Adds a menu to code::otherMenus::.

	ARGUMENT:: menu
		A link::Classes/Menu::.

METHOD:: remove
	Removes a menu to code::otherMenus::.

	ARGUMENT:: menu
		A link::Classes/Menu::.

METHOD:: insert
	Inserts a menu in code::otherMenus:: at the given index.

	ARGUMENT:: index
		Index. An link::Classes/Integer::.

	ARGUMENT:: menu
		A link::Classes/Menu::.

METHOD:: clear
	Clears code::otherMenus::. The main application menus are unaffected.

	ARGUMENT:: menu
		A link::Classes/Menu::.

METHOD:: applicationMenu
	The main SuperCollider application menu.

	WARNING::This is intended for standalone SuperCollider applications, and should not be used to register menus during normal SC usage.::

EXAMPLES::

code::
(
~show = MenuAction("Show Window", {
	~window ?? {
		~window = TextView().string_("Here it goes!").minSize_(300@200);
		~window.onClose = { ~window = nil };
		~window.front;
	}
});
~hide = MenuAction("Hide Window", {
	~window !? {
		~window.close();
		~window = nil;
	}
});

MainMenu.register(Menu(~show, ~hide).title_("My Quark"), "Quarks", "My Quark")
)
::


class:: MantissaMask
summary:: Reduce precision.
categories::  UGens>Filters>Nonlinear


Description::

Masks off bits in the mantissa of the floating point sample value.
This introduces a quantization noise, but is less severe than linearly
quantizing the signal.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::bits

The number of mantissa bits to preserve. A number from 0 to 23.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// preserve only 3 bits of mantissa.
{ MantissaMask.ar(SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4), 3) }.play

// the original
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4) }.play

// the difference.
(
{
	var in;
	in = SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4);
	in - MantissaMask.ar(in, 3)
}.play
)


// preserve 7 bits of mantissa.
// This makes the lower 16 bits of the floating point number become zero.
{ MantissaMask.ar(SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4), 7) }.play

// the original
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4) }.play

// the difference.
(
{
	var in;
	in = SinOsc.ar(SinOsc.kr(0.2, 0, 400, 500), 0, 0.4);
	in - MantissaMask.ar(in, 7)
}.play
)

::


class:: MaxLocalBufs
summary:: Set the maximum number of local buffers in a synth
categories:: UGens>InOut

description::
This class is used internally by LocalBuf, sets the maximum number of local buffers in a synth.



class:: Maybe
summary:: referentially transparent proxy object
categories:: JITLib>Environments, Live Coding
related:: Classes/Fdef, Overviews/JITLib

description::
A Maybe object can contain either nil or some other object, and allows to construct calculations without knowing this other object yet. If the calculation fails, due to a loop or a not yet defined object, Maybe returns nil.

The name strong::Maybe:: stems from the programming language Haskell, where it represents a somewhat similar entity. See also: link::Classes/Fdef::

note::
A Maybe object lazily constructs an operation as an object instead of
performing it immediately. Its implementation remains incomplete
necessarily, in the current form: it is limited to the arithmetic operations that AbstractFunction implements and the following collection methods: code::put, addAll, add, putAll, atAll::.

You can extend Maybe as you need for your purpose, by the following schema:

code::
// replace "myMethod" with your method name
+ Maybe {
	myMethod { |...args|
		^this.composeNAryOp(\myMethod, args)
	}
}
::
::

ClassMethods::

method::new
create a new instance

argument::thing
an object or nil.
code::
a = Maybe.new;
b = Maybe(a + 6);
b.value; // => nil
a.value = 1;
b.value; // => 7
::

InstanceMethods::

method::source
return or set the contained object

method::value
set the contained object or return the source, or the value of the contained object, if it is a Maybe. If there is a recursion, return nil.

method::apply
return the value, or the value of the contained object, if it is a Maybe. This method allows recursion, so that recursive calculations can be made.

method::doesNotUnderstand
(called by any message that Maybe doesn't understand.)

returns a composition function that, when evaluated, returns the value.
code::
a = Maybe.new;
a.respondsTo(\flop) // false: Maybe constructs a placeholder instead
b = Maybe(a.flop);
b.value; // => nil
a.value = [1, 2, [2, 3]];
b.value;	// => [ [ 1, 2, 2 ], [ 1, 2, 3 ] ]
::

Examples::

code::
// the following examples use a LazyEnvir with a Maybe as a proxy class.
// instead of writing a = Maybe.new; a.value = something;
// one can simply write ~a = something.
// the Maybe is implicitly created for you.

(
	p.pop.clear;
	p = LazyEnvir.new;
	p.proxyClass = Maybe;
	p.linkDoc; // here: connect to current doc only.
);


// sets
~a = Set[0, 4, 5, 7];
~b = Set[4, 5];
~c = ~a union: ~b; // union of the two sets (note that the shortcut | does not work here.).
~d = ~a sect: ~b; // intersection of a and b
~c.postcs;""; // post the whole construction
~d.postcs;"";
~c.value; // Set[ 4, 0, 5, 7 ]
~d.value; // Set[ 4, 5 ]
~b = Set[4, 5, 13, 0];
~c.value;
~d.value; // Set[ 4, 0, 5 ]
~b.source.add(~w); // add another placeholder
~c.value; // it is part of the union.
~d.value; // but not part of the intersection


// envirs
~a = (note: [1, 2]);
~b = (dur: 1);
~c = ~a.putAll(~b) // provisionally put everything into the placholder
~c.value;
~a = (note: [1, 2, 4]);
~c.value;
~d = ~a.at(\note);
~d.value;
~a = (note: [7.5]);
~d.value; // [7.5]

// patterns
~a = Pseq([1, 2, 3]);
~b = Pseq([5, ~a, ~a + 10], inf);
~b.value.asStream.nextN(10);


~a = Prand([100, 200]);
~b.value.asStream.nextN(10);


// to do : flop!

//////////////// deep recursion

// with normal functions:
f = { |x| if(x <= 1) { 1 } { x * f.(x - 1) } };
f.(12)


~faculty = { |x| if(x == 1) { 1 } { x * ~faculty.(x - 1) } };
~faculty.(12) // doesn't work (=> nil). here we _do_ want recursion ...

// for explicit recursion use "apply"
~faculty = { |x| if(x == 1) { 1 } { x * ~faculty.apply(x - 1) } };
~faculty.(12)

/*// safety (not yet implemented)
Maybe.maxDepth = 1e2; // higher depth is risky..
~faculty = { |x| x * ~faculty.apply(x - 1) }; // infinite recursion
~faculty.(12)

Maybe.maxDepth = nil; // unsafe again.*/


//////////////// recursion prevention tests

~b = ~a;
~a = ~b;
~a.value; // => nil


~a = ~b;
~b = ~c;
~c = ~a;
~a.value; // => nil

~a = ~b + ~c;
~c = ~a;
~a.value; // => nil


~a = ~b;
~b = 19;
~a.value; // => 19
~b.value; // => 19

// function evaluation and argument passing

~a = { |x| x + 2 };
~a.value; // => nil

~a.value(~c); // => nil
~b = 2000;
~a.value(~b); // => 2002
~x = [600, 1000];

(~a + 1).value(~b); // 2003
(~a + 1).value(~x); // [ 603, 1003 ]
(~a + 1).value({ 8 }); // binary op func.
(~a + 1).value({ 5 + 3 }).value // 11

~a = { |x| x + 2 + ~b };
~a.value(8); // 2010

~c = nil;
~a = { |x| x + 2 + ~c }; // ~c is undefined.
~a.value(8); // => nil

~c = 100; // define ~c

~a.value(8); // now returns a value.

~c = ~b; // now recursion?
~b = ~a;
~a.value(8); // caught recursion => nil

~c = { 100.rand }; // ~c is a function

~a.value(8);
~a.value(8);

~c = { ~a + ~b };
~a.value(8);	// ~c is a recursion with ~a => nil


// function composition
~a = {|x| x + 1 };
~v = ~a <> ~a <> ~a; // same as: { ~a.(~a.(~a)) }
~v.value(0); // => 3

~a = {|x| x + 2 };
~v.value(0); // transparent. => 6

// {|x| x }.valueEnvir // doesn't work with current implementation of Function:valueEnvir


// calculations with functions:
~c = 0;
~a = { |ff| { ff = ff + 1; ~c + ff + 2 + ~c } };
~x = ~a.value(8);
~x.value; // return 11, 12, 13...
~x.value;
~x.value;
~c = 100;
~x.value; // return 214, 215 ...
~x.value;

// binary op functions:
~c = 0;
~a = { |ff| { [600, 800] } + { ff + 2 + ~c } };

~x = ~a.value(8);
~x.value; // return [ 610, 810 ]

~c = { [10, -10].rand };
~x.value; // return random between [ 610..620, 800..810 ]
::


class:: Median
summary:: Median filter.
categories::  UGens>Filters>Nonlinear


Description::

Returns the median of the last length input points. This non-linear
filter is good at reducing impulse noise from a signal.


classmethods::

method::ar, kr

argument::length

Number of input points in which to find the median. Must be an
odd number from 1 to 31. If
code::length::  is 1
then Median has no effect.


argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.play;

// after applying median filter
{ Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.play;

// The median length can be increased for longer duration noise.

// a signal with longer impulse noise.
{ Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9)) }.play;

// length 3 doesn't help here because the impulses are 2 samples long.
{ Median.ar(3, Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9))) }.play;

// length 5 does better
{ Median.ar(5, Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9))) }.play;

// long Median filters begin chopping off the peaks of the waveform
(
{
	x = SinOsc.ar(1000, 0, 0.2);
	[x, Median.ar(31, x)]
}.play;
)

// another noise reduction application:

Synth.play({ WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1) });

// use Median filter for high frequency noise
Synth.play({ Median.ar(31, WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1)) });

(
// use LeakDC for low frequency noise
Synth.play({
	LeakDC.ar(Median.ar(31, WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1)), 0.9)
});
)

::


TITLE:: Menu
summary:: Context and application-level menus
categories:: GUI
related:: Classes/MenuAction, Classes/CustomViewAction, Classes/ToolBar, Classes/MainMenu

DESCRIPTION::
The Menu class allows the creation and control of context menus and application-level menus.

CODE::
(
~menu = Menu(
	MenuAction("A", { "A selected".postln }),
	MenuAction("B", { "B selected".postln }),
	MenuAction("C", { "C selected".postln }),
).front;
)
::

CLASSMETHODS::

METHOD:: new
	Create a new menu. A menu is populated with link::Classes/MenuAction::s

	ARGUMENT::
		One or more link::Classes/MenuAction##MenuActions:: or Menus to be displayed in the menu. Menu arguments will create sub-menus.

	DISCUSSION::
		CODE::
(
	Menu(
		MenuAction("main"),
		MenuAction("menu"),
		Menu(
			MenuAction("sub"),
			MenuAction("menu"),
		).title_("submenu")
	).front;
)
::

INSTANCEMETHODS::

SUBSECTION:: Control

METHOD:: front
	Show the menu if it is not already shown. Note that unlike most Views, Menus are not destroyed when they are closed - front can be used to re-generate a single menu again and again.

	ARGUMENT:: point
		A link::Classes/Point:: at which to show the menu. Default to the current mouse cursor position.
	ARGUMENT:: action
		The action that should appear at the specified point coordinates. Should be an action contained in the menu.

METHOD:: title
	The title of the menu.

	ARGUMENT:: title
		A link::Classes/String::.

METHOD:: tearOff
	ARGUMENT::
		If true, menu is / will be torn off from its parent and become a free-floating menu.

METHOD:: copy
	Create an identical copy of the menu. The new menu will not be shown until code::.front:: is called.

SUBSECTION:: Events
	Menus broadcast several kinds of events that can be registered for with the standard link::Classes/Object#-addDependant:: calls.
	Events broadcast by menu:

	LIST::
		## code::\aboutToShow::
		## code::\aboutToHide::
		## code::\triggered:: (with the MenuAction that was triggered)
		## code::\hovered:: (with action that was hovered over)
	::

	STRONG:: Events example ::
	CODE::
(
m = Menu(MenuAction("Option A"), MenuAction("Option B")).title_("Event Example");

f = {
	|menu, what, value|
	"Menu '%' sent event %, value = %".format(menu.title, "\\" ++ what, value).postln;
	if (what == \hovered) { "Hovering over: %".format(value).postln };
	if (what == \triggered) { "Action triggered: %".format(value).postln; menu.destroy };
};

m.addDependant(f);
m.onClose_({ m.removeDependant(f) }).front;
)
	::

SUBSECTION:: Context Menus
	One or more MenuActions can be attached to any View object. The shortcut key combinations for these actions will become available, and the actions will appear in the context menu for that view.

	See link::Classes/View#-setContextMenuActions::, link::Classes/View#-addMenuAction::, link::Classes/View#-removeMenuAction:: for more information.

	CODE::
(
~view = View().layout_(HLayout(
	~button = Button().states_([["Button"]]),
	~number = NumberBox().minWidth_(100).value_(100)
)).front;

~button.setContextMenuActions(
	MenuAction("Red", { ~button.states = [["Red", Color.red]] }),
	MenuAction("Green", { ~button.states = [["Green", Color.green]] }),
	MenuAction("Blue", { ~button.states = [["Blue", Color.blue]] })
);

~number.setContextMenuActions(
	MenuAction("100", { ~number.value = 100 }),
	MenuAction("200", { ~number.value = 200 }),
	MenuAction("300", { ~number.value = 300 })
);

)
	::

EXAMPLES::

	STRONG:: A more complex menu. ::
	CODE::
(
~image = Image(64, 64).draw({
	Pen.fillColor = Color.blue;
	Pen.fillOval(Rect(0, 0, 64, 64));
});

~menu = Menu(
	MenuAction("checked", { "checked".postln })
		.checked_(true),

	MenuAction("disabled", { "disabled".postln })
		.enabled_(false),

	MenuAction("keyboard short", { "keyboard short".postln })
		.shortcut_("Ctrl+Shift+N"),

	MenuAction("icon", { "icon".postln })
		.icon_(~image),

	MenuAction("font", { "font".postln })
		.font_(Font("Helvetica", 20, italic:true)),

	MenuAction.separator.string_("other stuff"),

	CustomViewAction(Slider().orientation_(\horizontal)).action_({ |v| v.value.postln }),

	Menu(
		"string.toAction",
		{ "function.toAction".postln }
	).title_("submenu")
).front;
)
	::


TITLE:: MenuAction
summary:: An individual menu or toolbar item, that performs an action when clicked.
categories:: GUI
related:: Classes/Menu, Classes/ToolBar, Classes/MainMenu

DESCRIPTION::
A MenuAction represents a single action that can occupy multiple link::Classes/Menu::s or a link::Classes/ToolBar::s, and will evaluate a function when activated.
When added to a menu, these are displayed as menu items. When added to a toolbar, they appear as buttons.


CLASSMETHODS::

METHOD:: new
	Create a new Action. Note that one action may occupy multiple menus and toolbars.

	ARGUMENT:: string
		The name of the action. This will be its display name if added to a menu.

	ARGUMENT:: function
		A function to perform when the action is activated.

METHOD:: separator
	An action that represents a menu or toolbar separator. These are not selectable or clickable.

	ARGUMENT:: string
		A label for the separator. These are not always visible, depending on your OS and context.



INSTANCEMETHODS::

METHOD:: string
	A string representing the name of the action. This is used as text when it is placed in menus, and on toolbars if it does not have an icon.
	ARGUMENT::
		A String

METHOD:: menu
	A Menu. If present, this action acts as a submenu, or a pop-up menu when placed on a toolbar.
	ARGUMENT::
		A link::Classes/Menu::

METHOD:: shortcut
	A string representing the keyboard shortcut to trigger this action. Keyboard shortcuts are available when an action is attached to a link::Classes/ToolBar::, or when it's part of the context menu for a View (see link::Classes/View#-setContextMenuActions::)
	Shortcut strings are of the form e.g. "Ctrl+M", "Shift+Alt+space" etc. See https://doc.qt.io/qt-5/qkeysequence.html#details for more info.
	ARGUMENT::
		A String

METHOD:: checked
	Indicates whether the action is checked or unchecked.
	ARGUMENT::
		A boolean.

METHOD:: toolTip
	A string to display when hovering over the menu item / button.
	ARGUMENT::
		A String

METHOD:: separator
	Indicates whether the action is a separator.
	ARGUMENT::
		A Boolean.

METHOD:: iconVisible
	Indicates whether the icon for this action will be visible.
	ARGUMENT::
		A Boolean.

METHOD:: checkable
	Indicates that the action shows a checkbox and is checkable.
	ARGUMENT::
		A Boolean

METHOD:: enabled
	Indicates that the action is enabled; otherwise it will be greyed out and uninteractive.
	ARGUMENT::
		A Boolean

METHOD:: icon
	An link::Classes/Image:: associated with the action - to be shown next to the name of the action in both menus and toolbars.
	ARGUMENT::
		An link::Classes/Image::

METHOD:: font
	The font used to display the action's name. Note that special fonts may or may not be displayed depending on OS and context (e.g. system menu, context menu, toolbar). For example, OSX application menus will honor italicized fonts, but not the font family itself.
ARGUMENT::
	A link::Classes/Font::

SUBSECTION:: Events
	Menu actions broadcast several kinds of events that can be registered for with the standard link::Classes/Object#-addDependant:: calls.
	Events broadcast by menu:

	LIST::
		## code::\changed:: (issued when one of the actions properties changes)
		## code::\triggered:: (issued when the action is clicked / activated - value is a boolean representing whether the action is checked)
		## code::\hovered::
		## code::\toggled::
	::

	STRONG:: Events example ::
	CODE::
(
m = Menu(
	a = MenuAction("Option A"),
	b = MenuAction("Option B")
).title_("Event Example");
f = {
	|action, what, value|
	"MenuAction '%' sent event %, value = %".format(action.string, "\\" ++ what, value).postln;
	if (what == \hovered) { "Hovering over: %".format(action).postln };
	if (what == \triggered) { "Action triggered: %".format(value).postln; m.destroy };
};
a.addDependant(f);
b.addDependant(f);
m.onClose_({ a.removeDependant(f); b.removeDependant(f) }).front;
)
	::

EXAMPLES::

STRONG:: Simple checkable menu item ::
code::
(
~view = View().layout_(HLayout(
	Button()
		.states_([["Options..."]])
		.action_({ ~menu.front })
));
~menu = Menu(
	MenuAction("enabled")
		.checkable_(true)
		.action_({
			|a, enabled|
			if (enabled) {
				"Enabled".postln;
				~view.background = Color.green(1, 0.5);
			} {
				"Disabled".postln;
				~view.background = Color.clear;
			}
		})
);
~view.front;
)
::

STRONG:: Action help strings ::
code::
(
~view = View(bounds:300@100).layout_(VLayout(
	Button()
		.states_([["Options..."]])
		.action_({ ~menu.front }),
	~text = TextView()
));

~menu = Menu (
	MenuAction("Option A").toolTip_("I like option A..."),
	MenuAction("Option B").toolTip_("But option B is better..."),
	MenuAction("Option C").toolTip_("No one really likes C."),
);

~actionFunc = {
	|obj, what, action|
	if (what == \hovered) {
		~text.string = action.toolTip
	};
	if (what == \aboutToHide) {
		~text.string = ""
	}
};
~menu.addDependant(~actionFunc);
~view.onClose_({ ~menu.removeDependant(~actionFunc) }).front;

)
::


STRONG:: A more complex example ::
code::
(
s.waitForBoot {
	~startIcon = Image(40).draw({
		Pen.fillColor = Color.green;
		Pen.moveTo(5@5);
		Pen.lineTo(35@20);
		Pen.lineTo(5@35);
		Pen.lineTo(5@5);
		Pen.fill;
	});
	~stopIcon = Image(40).draw({
		Pen.fillColor = Color.red;
		Pen.fillRect(Rect(10, 10, 20, 20));
	});

	~startAction = MenuAction("start")
					.action_({ ~playSynth.() })
					.icon_(~startIcon)
					.toolTip_("Start playing synth.")
					.shortcut_("space")
					.font_(Font(bold:true, size:18));
	~stopAction = MenuAction("stop")
					.action_({ ~stopSynth.() })
					.icon_(~stopIcon)
					.toolTip_("Stop the synth.")
					.enabled_(false)
					.shortcut_(".")
					.font_(Font(bold:true, size:18));
	~playing = MenuAction("playing")
					.enabled_(false)
					.checkable_(true)
					.checked_(false);

	~view = View(bounds:300@200).layout_(VLayout(
		ToolBar(~startAction, ~stopAction, MenuAction.separator, ~playing).focus,
		nil,
		Button().states_([["Options..."]]).action_({
			Menu(~startAction, ~stopAction, MenuAction.separator, ~playing).front;
		})
	));
	~view.onClose_({ ~stopSynth.() });

	~synth = nil;
	~playSynth = {
		if (~synth.isNil) {
			~synth = { SinOsc.ar(440) * 0.1 }.play;

			~startAction.enabled = false;
			~stopAction.enabled = true;
			~playing.checked = true;

			~synth.onFree({
				~synth = nil;
				{
					~playing.checked = false;
					~startAction.enabled = true;
					~stopAction.enabled = false;
				}.defer
			})
		}
	};

	~stopSynth = {
		~synth !? { ~synth.free };
	};

	~view.front;

}
)
::


TITLE:: Message
summary:: A message to an object
categories:: Language
related:: Classes/MethodQuote

DESCRIPTION::
A message to an object, to be evaluated later.

CLASSMETHODS::

METHOD:: new
argument:: receiver
the receiver of the message
argument:: selector
the method to be called
argument:: args
arguments to the call

INSTANCEMETHODS::

METHOD:: receiver
the object to which the message is relayed

METHOD:: selector
the method to be called

METHOD:: args
the arguments to the call

METHOD:: value
send the message to the receiver and call the selector with the arguments
argument::  ... moreArgs

private:: storeArgs

EXAMPLES::

code::
// an object
a = 36


// a message to the object
m = Message(a, \sqrt)

// deliver the message
m.value
// -> 6

// a message that lacks an argument
m = Message(a, '+')

// evaluate with the argument
m.value(6)
// -> 42

m.value(-13)
// -> 23
::


TITLE:: MeterSync
summary:: Synchronize barlines of SuperCollider LinkClock peers
categories:: Scheduling>Clocks
related:: Classes/LinkClock

DESCRIPTION::

This class implements additional network messaging, beyond the Ableton Link protocol, to ensure that SuperCollider link::Classes/LinkClock:: peers follow the same meter (beatsPerBar) and barlines as other LinkClock peers.

This class, or the associated methods link::Classes/LinkClock#-enableMeterSync:: and link::Classes/LinkClock#-disableMeterSync::, should be used for performances where all linked machines should follow the same meter emphasis::and:: the meter will change during the performance.

If the meter will not change (typical use case being 4/4 time throughout), then it is necessary only to set code::myLinkClock.quantum = beatsPerBar:: on all peers. (See link::Classes/LinkClock#-quantum::.)

In theory, MeterSync may be used with any SuperCollider clock that answers the methods code::beatsPerBar::, code::beatInBar:: and code::baseBarBeats::. It is currently tested only with link::Classes/LinkClock::. It is not meaningful to use with link::Classes/TempoClock::, because TempoClock does nothing to synchronize its beats with any other machines.

note:: This class considers only the barline positions of SuperCollider LinkClock peers! Other Link-capable applications do not implement this protocol. ::


Subsection:: Background

SuperCollider defines emphasis::meter:: using two numbers:

definitionlist::
## link::Classes/TempoClock#-beatsPerBar:: || How many beats comprise one bar (4 = 4/4 time, 3 = 3/4 time).
## link::Classes/TempoClock#-baseBarBeat:: || The beat value at which the meter last changed.
::

For example, if a clock runs four bars of 4/4 time, and then switches to 3/4 time, the barlines are emphasis::not:: multiples of 3. The meter changed at beat 16, so the new barlines will be code::16 + (3 * n):: (code::n:: is an integer). At this point, then, beatsPerBar = 3 and baseBarBeat = 16.

Ableton Link maintains a emphasis::quantum::, which is analogous to link::Classes/TempoClock#-beatsPerBar::. If all peers are following the same meter and have the same quantum, then Link itself will synchronize the barlines. (Thus, in the normal use case of a consistent meter throughout, it is not necessary to use code::MeterSync:: at all.)

However, when changing the Link quantum, Link does not guarantee that beat values will increment consistently. Setting the quantum is meant to be done before the performance begins, not during.

SuperCollider can change its code::beatsPerBar:: independently of the Link quantum. But, in that case, barlines across peers may not be synchronized.

code::MeterSync:: resolves this by querying other SuperCollider Link peers for their current metrical position. If the local machine differs from the other peers, then the local machine adjusts its code::baseBarBeat:: to be in metrical sync with the others. (Beats proceed as normal; only the barline position is adjusted.)


CLASSMETHODS::

METHOD:: new
Returns a new instance, associated with a specific clock object.

ARGUMENT:: clock
The clock which this instance controls.

ARGUMENT:: id
Optional. An integer, uniquely identifying this instance. If not provided, a random integer will be chosen.

ARGUMENT:: ports
Optional. An array of port numbers to which sync messages will be sent. (sclang instances normally use port 57120, but if that port is in use, they will try 57121 and so on, successively. The default here is to try all of 57120-57127.)


INSTANCEMETHODS::

METHOD:: free
Release this instance, disabling metric sync for the associated clock.


METHOD:: resyncMeter
Adjust the clock's barline position to match other SuperCollider peers on the network.

ARGUMENT:: round
Optional. Force a specific subdivision: round = 1 assumes quarter-notes as the metric base; round = 0.5 assumes eighth-notes (e.g. 5/8 time). If not provided, it will be calculated based on the incoming beatsPerBar values from other peers.

ARGUMENT:: verbose
Boolean. If false, suppress information messages.

returns:: The instance.


METHOD:: queryMeter
Query metrical information from other peers, and collect the results. Normally, you should not need to call this method. It is provided in case you want to verify sync, or implement a custom behavior.

ARGUMENT:: action
A function to evaluate, after the results have been obtained. Results are passed to this function as an argument: a List of Events containing:

list::
## id: The remote peer's ID (integer).
## beats: The remote clock's beats, at the time of answering.
## beatsPerBar: The remote clock's meter.
## baseBarBeat: The remote clock's metrical base.
## beatInBar: The remote clock's metrical position within the bar.
## queriedAtBeat: The emphasis::querying:: clock's query time, in beats.
## syncMeter: Boolean. If true, the remote clock is syncing barlines. If false, the remote clock has an answering MeterSync object, but it is disabled.
::

ARGUMENT:: timeout
Float. A number of seconds to wait for replies. (It will always wait for the entire timeout period. LinkClock knows its link::Classes/LinkClock#-numPeers::, but only SuperCollider peers will answer queries, and there is no way to know how many of the peers are SuperCollider.)

returns:: The instance. Replies are asynchronous; use the code::action:: function to respond.

METHOD:: id
Get the integer ID uniquely identifying this instance. The ID is set at initialization time (link::Classes/LinkClock#-enableMeterSync:: or link::#*new::). To change it, free the current instance and create a new one.

METHOD:: ports
Get the array of ports to which sync messages will be sent. The ports are set at initialization time (link::Classes/LinkClock#-enableMeterSync:: or link::#*new::). To change them, free the current instance and create a new one.

returns:: An array of integer port numbers.

METHOD:: adjustMeterBase
A convenience method to adjust the clock's baseBarBeat, given the local metrical position and the remote metrical position. Normally, you do not need to call this method. It is provided in case you do your own analysis of link::Classes/MeterSync#-queryMeter:: results and you want to adjust barlines in your own way.

ARGUMENT:: localBeats
The local clock's beats. Usually this should be derived from code::result[index][\queriedAtBeat]:: (where code::result:: comes from link::Classes/MeterSync#-queryMeter::). Strongly recommended to use this instead of code::clock.beats::, because the query time does not add the timeout.

ARGUMENT:: remoteBeats
The local clock's beats. Usually this should be derived from code::result[index][\beats]::.

ARGUMENT:: round
Optional. Force a specific subdivision: round = 1 (the default) assumes quarter-notes as the metric base; round = 0.5 assumes eighth-notes (e.g. 5/8 time).

returns:: The instance.

code::
// You *may* do something like this optionally,
// if something went wrong.
// Normally you should just call 'resyncMeter'
// and it's all done for you.

l = LinkClock.new.latency_(s.latency);
m = MeterSync(l);

(
m.queryMeter({ |result|
	result.postln;
	m.adjustMeterBase(result[0][\queriedAtBeat], result[0][\beatInBar]);
});
)

l.stop;  // cleans up 'm' automatically
::

METHOD:: enabled
Enable or disable meter sync. If disabled, this instance will no longer respond to meter changes from peers. It will still answer queryMeter, with code::'syncMeter': false:: in the reply (so you can filter the queryMeter results accordingly).

ARGUMENT:: bool
True = enabled, false = disabled.

returns:: Boolean.

METHOD:: clock
Answers with the clock being controlled by this instance.

note:: You cannot change the associated clock object. You should instead link::Classes/MeterSync#-free:: this instance, and create a new instance for the other clock. ::


METHOD:: repeats
Get or set the number of repeats for OSC messaging.

UDP does not detect failure to deliver messages; therefore, messages may be lost. If that happens, LinkClock peers may fail to synchronize properly and link::#-resyncMeter:: may be unable to recover. To prevent this, sync messages are sent 'repeats' times. The default is 4.

METHOD:: delta
Get or set the number of seconds between OSC messaging repeats.

private:: prBroadcast, update, init, prSetMeterAtBeat, prGetMeter

EXAMPLES::

code::
l = LinkClock.new.latency_(s.latency).enableMeterSync;

// If meter gets off, try to resync:
l.getMeterSync.resyncMeter;

// What are other clocks' timebases?
l.getMeterSync.queryMeter({ |result|
	result.do { |row| row.postln };
});

// I want a different ID and/or ports: free, then recreate
l.disableMeterSync;
l.enableMeterSync(1000, (57120..57135));
::


class::Method
categories::Core>Kernel
summary:: Code that implements an operation upon instances of a Class.
related:: Classes/Class

description::
A Method is code that is a part of the set of operations upon instances of a link::Classes/Class::.

subsection:: Related Keywords

method:: thisMethod

The global pseudo-variable code::thisMethod:: always evaluates to the enclosing Method in a class definition, much like code::thisFunction::.
When executed outside that context, it returns link::Classes/Interpreter#-functionCompileContext::, the method within which all interpreted code executes.

code::
// if the following code were compiled as part of the class library:
SomeClass {
	methodThatPostsItself {
		thisMethod.postln;
	}
}

// then running this would post
// "SomeClass:methodThatPostsItself"
a = SomeClass.new;
a.methodThatPostsItself;
::

code::thisMethod:: is frequently used to pass information to error-throwing methods. For example, the implementation of code::Nil.new:: is:

code::
*new { ^this.shouldNotImplement(thisMethod) }
::

See also: link::Classes/Function#.thisFunction#thisFunction::.

instanceMethods::

method::ownerClass
returns::
The link::Classes/Class:: for which the method is part of the implementation.

method::name
returns::
A link::Classes/Symbol:: which is the name of the Method.

method::primitiveName
returns::
A link::Classes/Symbol:: which contains the name of the primitive function that implements the Method, if there is one.

method:: filenameSymbol
returns::
A link::Classes/Symbol:: which is the full path of the source file that this method is defined in.



class:: MidEQ
summary:: Parametric filter.
categories::  UGens>Filters>Linear


Description::

Attenuates or boosts a frequency band.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Center frequency of the band in Hertz.


argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::db

Amount of boost (db > 0) or attenuation (db < 0) of the
frequency band.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// mixer parametric eq as wahwah
{ MidEQ.ar(Saw.ar(200,0.2), FSinOsc.kr(1, 0, 24, 84).midicps, 0.3, 12) }.play


// notch filter
(
{ var in;
  in = PinkNoise.ar(0.2) + SinOsc.ar(600, 0, 0.1);
  MidEQ.ar(in, SinOsc.kr(0.2, 0.5pi) * 2 + 600, 0.01, -24)
}.play
)

/////
// first start the synth
(
x = {| freq=400, db=0, rq=0.1 |
	 var in;
	 in =  SinOsc.ar([ 400, 420 ], 0, 0.4);
	 MidEQ.ar(in, freq, Lag.kr(rq, 0.3), db)
	}.play
)

// now play with its parameters to hear how the filter affects two frequencies
// that are very close to each other

x.set(\db, -12)
x.set(\rq, 0.1)
x.set(\rq, 0.03)
x.set(\freq, 410)
x.set(\freq, 420)
x.set(\freq, 400)
x.set(\freq, 500)

::


class:: Mix
summary:: Sum an array of channels.
categories::  UGens>Multichannel


Description::

Mix will mix an array of channels down to a single channel or an array
of arrays of channels down to a single array of channels.
More information can be found under link::Guides/Multichannel-Expansion::.


note::

Note that  code::Mix.ar::  and  code::Mix.kr::  in
SC2 are equivalent to  code::Mix.new::  in SC3,
and that  code::Mix.arFill::  and  code::Mix.krFill::  are
equivalent to  code::Mix.fill::.

::

classmethods::

method::new

argument::array
The array of channels or arrays.

method::fill

argument::n
The size of array to create.

argument::function
The array filling function.

returns:: Returns:
A newly created
link::Classes/UGen:: .

Examples::

code::

s.boot;

{ Mix.new([ PinkNoise.ar(0.1), FSinOsc.ar(801, 0.1), LFSaw.ar(40, 0.1)]) }.play

(
play({
	Mix.new( Array.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05) }) );
}))

(
play({
	Mix.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05) });
}))

::



class:: ModDif
summary:: Minimum difference of two values in modulo arithmetics
related:: Classes/Clip, Classes/Wrap
categories::  UGens>Maths


Description::
Returns the minimum difference of two values in modulo arithmetics. On a circle, there are two distances between two points. This UGen returns the smaller value of the two.

code::
{ var a = Line.ar(0, 4, 0.01), d = ModDif.ar(a); [a, d] }.plot;
{ var a = Line.ar(0, 4, 0.01); ModDif.ar(a, 0, (1..4)) }.plot;
{ var a = Line.ar(0, 4, 0.01); ModDif.ar(a, (0, 0.25 .. 1), 1) }.plot;

::


classmethods::

method::ar, kr, ir

argument::x
First input value

argument::y
Second input value

argument::mod
Modulo (maximum value, double of the maximal difference).

code::

// different moduli
(
{
	var sig = LFSaw.ar(10);
	var dist = ModDif.kr(sig, 0, (0..8) * MouseX.kr(0, 1/5));
	Splay.ar(SinOsc.ar(dist * 4000 + 400)) * 0.1
}.play;
)

// wrapping amplitude crossfade
(
{
	var numChan = 12;
	var x = SinOsc.ar({ rrand(300.0, 800.0) } ! numChan);
	var dist = ModDif.kr(MouseX.kr(0, numChan * 2), (0..numChan-1), numChan);
	x = x * max(0, 1 - dist);
	Splay.ar(x) * 0.1
}.play;
)
::




class:: Monitor
summary:: link between busses
categories:: JITLib>NodeProxy, Live Coding
related:: Reference/playN, Classes/NodeProxy, Classes/Bus

description::
A general purpose class for monitoring or crosslinking between busses. It supports multichannel expansion and crossfading between settings. It provides optimizations for playing contiguous channels to other contiguous busses (link::#-play::) and for more complex routings, such as splitting, spreading etc to multiple channels (link::#-playN::). Monitor uses the existing set of link::Classes/SystemSynthDefs:: to do this.

code::
{ Out.ar(87, SinOsc.ar(MouseX.kr(240, 1000, 1) * [1, 2, 3], 0, 0.2)) }.play; // play three sine tone on channels 87, 88, and 89
x = Monitor.new; // create a new monitor
x.play(fromIndex: 87, fromNumChannels: 3, toIndex:0, toNumChannels:2); // play them back to the stereo hardware channels
::

ClassMethods::

private::warnPlayN


InstanceMethods::

method::play
Plays from a bus index with a number of channels to another index with a number of channels, within a target group, or a server.

argument::fromIndex
bus index from which to read

argument::fromNumChannels
number of channels to read from.

argument::toIndex
bus index to which to write.

argument::toNumChannels
number of channels to write. If this number is larger or smaller than fromNumChannels, wrap around. If nothing is given, uses fromNumChannels.

argument::target
where to send the synths to (default: server default group)

argument::multi
keep old links and add new one: this allows you to add layer after layer, otherwise free the previous mapping (false by default).

argument::volume
volume at which to monitor

argument::fadeTime
specifies the fade in and fade out time

argument::addAction
where, relative to the target to place the monitor group.

code::
s.boot;
s.scope(16);

{ Out.ar(87, SinOsc.ar(MouseX.kr(40, 10000, 1) * [1, 2, 3], 0, 0.2)) }.play;
x = Monitor.new;
x.play(87, 3, 1, 2);
x.out = 0;
x.stop(3.0);
x.play(87, 1, 0, 1); // in > out : now mixes down (wrapping)
x.play(89, 1, 0, 2); // in < out : now distributes to 2 channels
x.stop;

// multiple play
x.play(87, 1, 0, 2, multi:true);
x.play(88, 1, 0, 2, multi:true);
x.play(89, 1, 0, 2, multi:true);
x.stop;
::



method::playN
Plays from an array of bus indices to another array of bus indices with an array of amplitudes, within a target group, or a server.

note::
The arguments strong::out::, strong::amp:: and strong::in:: can be nested arrays. see also link::Reference/playN::

The three arguments out, amp, and in will wrap if they do not have the same size, like this:
code::  [[0, 1], [0.1], [3, 4, 5]].flop ::
::

argument::out
array of destination channels.

argument::amp
array of amplitudes for each channel

argument::in
array of source channels

argument::vol
global scaling value for amplitudes

argument::fadeTime
specifies the fade in and fade out time

argument::target
where to play (default: server default group)

argument::addAction
where, relative to the target to place the monitor group.

argument::multi
keep old links and add new one: this allows you to add layer after layer, otherwise free ther previous mapping (false by default).

code::
// examples: args are // outs, amps, ins, vol, fadeTime

{ Out.ar(87, SinOsc.ar(MouseX.kr(40, 10000, 1) * [1, 2, 3], 0, 0.2)) }.play;
x = Monitor.new;

(
x.playN(
	[0, 1, 4], 			// to these outs
	[0.1, 0.4, 0.3], 	// with these volumes
	[87, 88, 89]		// from these ins
);
)
(
x.playN(
	[0, [1, 3, 2], 4], 		// outs can be nested: 87 -> 0, 88 -> [1, 3, 2], 89 -> 4
	[0.1, [0.4, 0.2, 0.1], 0.3],	// with nested volumes 0.1, [0.4, 0.2, 0.1], and 0.3
	[87, 88, 89]); 			// reading from these ins
)
// can also set global volume and fadetime
x.playN(vol: 0.0, fadeTime:4);
::


method::stop
Stops within the fadeTime.
note::this keeps all the settings, so when using code::play:: next time, it will play in the same configuration, overriding only values provided.::
code::
{ Out.ar(87, SinOsc.ar(MouseX.kr(340, 1000, 1) * [1, 2, 3], 0, 0.2)) }.play;
x = Monitor.new.play(87, 3, 0, fadeTime: 3);
x.stop;
x.play;
::

argument::argFadeTime
The time for fading out all routing synths.

method::clear
Stops within the fadeTime.
note::unlike code::stop::, this removes all the settings.::


method::vol
Set the volume.
code::
{ Out.ar(87, SinOsc.ar(MouseX.kr(340, 1000, 1) * [1, 2, 3], 0, 0.2)) }.play;
x = Monitor.new.play(87, 3, 0, fadeTime: 3);
x.vol = 0.3;
x.stop;
::


method::out
Set or get the first output index.

method::outs
Set or get the array of output bus indices.

method::ins
Set or get the array of input bus indices.

method::amps
Set the array of amplitudes.

method::fadeTimes
Set or get the array of fadeTimes.

method::fadeTime
Set one single fadeTime for the next transition (may be a stop or a new play).

method::isPlaying
Returns true if the group is still playing.

method::group
Return the group in which all mapping synths are running.

method::numChannels
Return the number of input channels.

method::copy
Return a copy of the receiver, with the same channel setting, but not running. You can run it with the settings by sending it the link::#-play:: message, and pass in any modifications you want to make.


method::playToBundle
Adds all playing osc messages to a bundle, passed as an argument. The bundle object should implement the method strong::.add::

private::hasSeriesOuts, newGroupToBundle, playNBusToBundle, playNToBundle, stopToBundle, updateDefault, usedPlayN


class:: MonitorGui
summary:: display and control a Monitor
categories:: JITLib>GUI, Live Coding
related:: Classes/NodeProxy, Classes/Ndef, Classes/JITGui, Classes/NdefGui

description::

MonitorGui displays the state of a link::Classes/NodeProxy::'s link::Classes/Monitor::. It is used in link::Classes/NdefGui::, link::Classes/ProxyMixer::, and link::Classes/NdefMixer::.

subsection::First examples

code::
s.boot;
Ndef(\a).ar;
Ndef(\k).kr;

	// make a MonitorGui with all bells and whistles
m = MonitorGui.new(bounds: 500@40, options: [\name, \level, \fade]);

	// when it has a kr proxy, it is visible, but disabled
m.object_(Ndef(\k));
	// with an ar proxy, it is enabled
m.object_(Ndef(\a));


	// show its play state
Ndef(\a).play
	// and volume
Ndef(\a).vol_(0.25);

	// NOTE: shift-clicking the play button opens a playN dialog!

Ndef(\a).stop;
Ndef(\a).play(0);
::

ClassMethods::

private::initClass

subsection::Creation

method::new

code::
g = MonitorGui(Ndef(\a));	// barebones
(
w = Window.new.front;
w.addFlowLayout;
g = MonitorGui(Ndef(\a), w, 300@40);
)

	// bounds
MonitorGui.new(Ndef(\a), bounds: Rect(100, 100, 400, 30))
MonitorGui.new(Ndef(\a), bounds: 400@24)

	// level name and numerical value
MonitorGui.new(Ndef(\a), options: [\level])

	// a nameView and a fadeTime setter box
MonitorGui.new(Ndef(\a), options: [\name, \fade])

	// all of 'em
MonitorGui.new(Ndef(\a), options: [\level, \name, \fade])
::

argument::object
the nodeproxy whose monitor state will be shown, or nil.

argument::parent
a parent view where MonitorGui is to be shown. If nil, a window is made.

argument::bounds
bounds where the view (or window) will be shown.

argument::makeSkip
a flag whether to create and start a link::Classes/SkipJack:: for auto-updating.

argument::options
an array of symbols for options of what to display.

subsection::Class Variables

method::lastOutBus
the highest outbus number to allow. Default is 99.

InstanceMethods::

subsection::Instance Variables

method::config
some information on what to display

method::ampSl
an link::Classes/EZSlider:: for link::Classes/Monitor:: volume

method::playBut
a play button. Shift-click opens a dialog window for playN output routing by code

method::setOutBox
a numberbox to set output routing

method::fadeBox
a numberbox for setting monitor fadeTime.

subsection::Some Methods

strong::Making various gui elements: ::

method::makeViews
method::makeVol
method::makeNameView
method::makePlayOut
method::makeFade

strong::Standard JITGui methods: ::

method::setDefaults
create default layout sizes

method::accepts
accepts nil or NodeProxy

method::getState
get the object's current state

method::checkUpdate
compare previous state with current state, and update gui elements.



class:: MoogFF
summary:: Moog VCF implementation, designed by Federico Fontana
categories:: UGens>Filters
related:: Classes/RLPF, Classes/LPF

description::
A digital implementation of the Moog VCF (filter). footnote::
The design of this filter is described in the conference paper Fontana, F. (2007) emphasis::Preserving the Digital Structure of the Moog VCF::. In Proc. ICMC07, Copenhagen, 25-31 August 2007.
::
footnote::
Original Java code created by F. Fontana - August 2007 - federico.fontana@univr.it
Ported to C++ for SuperCollider by Dan Stowell
::

classmethods::
method:: ar, kr

argument:: in
the input signal.
argument:: freq
the cutoff frequency.
argument:: gain
the filter resonance gain, between zero and 4.
argument:: reset
when greater than zero, this will reset the state of the digital filters at the beginning of a computational block.
argument:: mul
argument:: add

examples::
code::
s.boot;
// Play it with the mouse...
x = { MoogFF.ar(WhiteNoise.ar(01.1), MouseY.kr(100, 10000, 1), MouseX.kr(0, 4)) }.play(s);
x.free;

// Mmmm, throbby
(
x = {
    MoogFF.ar(
        Pulse.ar([40,121], [0.3,0.7]),
        SinOsc.kr(LFNoise0.kr(0.42).range(0.001, 2.2)).range(30, 4200),
        0.83 * 4)}.play(s);
)
x.free;
::



class:: MostChange
summary:: Output most changed.
related:: Classes/LeastChange, Classes/LastValue
categories::  UGens>Maths


Description::

Given two inputs code::a:: and code::b::, let code::da[t] = abs(a[t] - a[t - 1]):: and code::db[t] = abs(b[t] - b[t - 1])::. Output code::a[t]:: if code::da[t]:: is larger, and output code::b[t]:: if code::db[t]:: is larger. If code::da[t] == db[t]::, use whichever input was used last (assume code::a:: for the first sample of output).


classmethods::

method::ar, kr

argument::a

Input signal A.


argument::b

Input signal B.


Examples::

code::

(
d = SynthDef("help-MostChange", { |out, amp = 1.0|
	var sound, in1, in2;
	in1 = LFNoise1.ar(800, amp);
	in2 = SinOsc.ar(800);
	sound = MostChange.ar(in1, in2) * 0.1;
	Out.ar(out, sound)
}).play;
)

d.set(\amp, 0.1);
d.set(\amp, 0);
d.set(\amp, 3);
d.free;

// the control that changed most is used for output:

(
d = SynthDef("help-MostChange", { |out, freq = 440|
	var sound, internalFreq;
	internalFreq = LFNoise0.ar(0.3, 300, 800);
	sound = SinOsc.ar(
			MostChange.kr(freq, internalFreq)
	);
	Out.ar(out, sound * 0.1)
}).play;
)

d.set(\freq, 800);
d.set(\freq, 800); //nothing changed
d.set(\freq, 900);
d.free;

::



class:: MouseButton
summary:: Mouse button UGen.
related:: Classes/KeyState, Classes/MouseX, Classes/MouseY
categories::  UGens>User interaction


Description::

Mouse button UGen.


classmethods::

method::kr

argument::minval

Value when the button is not pressed.


argument::maxval

Value when the button is pressed.


argument::lag

Lag factor.


Examples::

code::

{ SinOsc.ar(MouseButton.kr(400, 440, 0.1), 0, 0.1) }.play;
{ SinOsc.ar(MouseButton.kr(400, 740, 2), 0, 0.1) }.play;

(
SynthDef( \mousexyb, { |out=0|
	var mousex, mousey, mousebutton;
	mousex = MouseX.kr( 500, 1000 ); // this will determine the frequency of the sound (minimum value, maximum value, warp, lag)
	mousey = MouseY.kr( 0, 0.3 ); // this will determine the amplitude of the sound
	mousebutton = MouseButton.kr( 0, 1, 2 ); // this will turn the sound on or off (minimum value, maximum value, lag)
	Out.ar( out, SinOsc.ar( mousex, 0, mousey ) * mousebutton );
}).add
)

x = Synth.new( \mousexyb );
x.free;
::



class:: MouseX
summary:: Cursor tracking UGen.
related:: Classes/KeyState, Classes/MouseButton, Classes/MouseY
categories::  UGens>User interaction


Description::

Cursor tracking UGen.


classmethods::

method::kr

argument::minval

Value corresponding to the left edge of the screen.


argument::maxval

Value corresponding to the right edge of the screen.


argument::warp

Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or
times). Alternatively you can specify: 'linear' or 'exponential'.


argument::lag

Lag factor to dezipper cursor movement.


Examples::

code::

{ SinOsc.ar(MouseX.kr(40, 10000, 1), 0, 0.1) }.play;
{ SinOsc.ar(MouseX.kr(500, 10000, 1).poll, 0, 0.1) }.play;

::



class:: MouseY
summary:: Cursor tracking UGen.
related:: Classes/KeyState, Classes/MouseButton, Classes/MouseX
categories::  UGens>User interaction


Description::

Cursor tracking UGen.


classmethods::

method::kr

argument::minval

Value corresponding to the bottom edge of the screen.


argument::maxval

Value corresponding to the top edge of the screen.


argument::warp

Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or
times). Alternatively you can specify: 'linear' or 'exponential'.


argument::lag

Lag factor to dezipper cursor movement.


Examples::

code::

{ SinOsc.ar(MouseY.kr(40, 10000, 1), 0, 0.1) }.play;

::



class:: MulAdd
categories:: UGens>Maths
summary:: Multiply and add to a signal

description::
Multiplies the signal by mul and adds add. This UGen is very efficient (it performs various optimisation checks, for example). It is used very heavily throughout SuperCollider to perform multiply and add operations on the server; in fact it is  what "really" performs the mul and add arguments found in many UGens.

See also the discussion of mul and add arguments in the link::Classes/UGen:: help file.

classmethods::
private:: new1

method:: new
argument:: in
input signal
argument:: mul
multiply with this value
argument:: add
add this value

discussion::
Same as:
code::
in.madd(mul, add)
::

instancemethods::
private:: init

Examples::
code::
s.boot;

// The mul and add arguments of SinOsc themselves use MulAdd!
// These two examples will create precisely the same synth graph:
x = { SinOsc.ar(440, 0, 0.1, 0.05) }.play(s);
x.trace; // You should see a "MulAdd" in the trace
x.free;

x = { MulAdd(SinOsc.ar(440, 0), 0.1, 0.05) }.play(s);
x.trace;
x.free;

// In fact this will produce the same graph too - the separate multiply and add are optimised into one MulAdd
x = { SinOsc.ar(440, 0) * 0.1 + 0.05 }.play(s);
x.trace;
x.free;
::
(Note: the "trace" message is described in the helpfile for link::Classes/Node::.)


CLASS::MultiLevelIdentityDictionary
summary::tree of dictionaries
related:: Classes/IdentityDictionary
categories:: Collections>Unordered

DESCRIPTION::
A tree of IdentityDictionaries. Addresses within the tree are specified with a series of keys. link::Classes/Library:: is its most useful subclass.

INSTANCEMETHODS::

private::add, remove, removeFail, prChooseFrom, prPutTree, leaves, prNestedValuesFromDict, prRemoveAtPathRecursive, storeOn, printOn

method::at
Retrieves a leaf node or nil if not found.

method::put
Puts the item as a leaf node, internally creating new branches as needed to accommodate the list of keys.

method::choose
Choose a branch at each level, descend the tree until a leaf is chosen.
By using arguments strong::key1, key2 ... keyN::, one can start at an address within the tree, descend the tree until a leaf is chosen.

method::putTree
A way to insert objects into the tree with a syntax similar to the organization of the tree itself.
code::
//pseudo code:
putTree(key1,[
	key2a, item1-2a,
	key2b, item1-2b,
	[
		key3, item1-3
	] // etc...
]);
::

method::removeAt
Remove only the item located by the path.

method::removeEmptyAt
Remove the item located by the path. This might make the item's parent dictionary empty. In that case, it will remove the parent and continue up the chain, removing empty dictionaries as it goes. This is slower but cleaner.

EXAMPLES::

code::
// Example of the difference between removeAt and removeEmptyAt

m = MultiLevelIdentityDictionary.new;
m.put(\a, \b, \c, 1);

m.removeAt(\a, \b, \c);
m	// note, \a and \b dictionaries remain

m.put(\a, \b, \c, 2);
m.removeEmptyAt(\a, \b, \c);
m	// now the entire MultiLevelIdentityDictionary is empty
::


class:: MultiOutUGen
summary:: Superclass for all UGens with multiple outputs
categories:: UGens>Base
related:: Classes/OutputProxy

Description::
This is a superclass for all UGens with multiple outputs.
MultiOutUGen creates the link::Classes/OutputProxy:: ugens needed for the multiple outputs.

classmethods::
private:: categories

instancemethods::

method:: initOutputs
Create an array of OutputProxies for the outputs.



CLASS:: MultiSliderView
summary:: A view displaying an array of sliders
categories:: GUI>Views

DESCRIPTION::

MultiSliderView displays a collection of values, each represented by the position of one of the sliders placed side by side.

When clicking into the view, the value of the slider under the mouse pointer will be set. Whenever the mouse is moved with a mouse button pressed, the slider currently under the mouse pointer will be adjusted.

The last slider modified is considered to be the strong::current:: one, i.e. the link::#-index:: method will return its index, and link::#-currentValue:: relates to its value.

The current slider is also considered to be the strong::selected:: one. Selection can be extended to more than one slider by modifying link::#-selectionSize::. Whenever a different slider becomes the current one, the selection size shrinks back to 1. Note that the selection will only be visually indicated if link::#-showIndex:: is code::true::.


CLASSMETHODS::

PRIVATE:: key

METHOD:: new


	A new MultiSliderView is created empty, without any columns. link::#-size:: or link::#-value:: has to be set in order to create some columns.

	So if you want a specific number of sliders, then it is best to specify the link::#-size:: and set link::#-elasticMode:: to 1. Then you will get a MultiSliderView which distributes link::#-size:: amount of sliders over code::bounds.width::, where the slider widths are at maximum link::#-indexThumbSize:: (default 12) and the link::#-gap:: is adjusted accordingly.



INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: size
	The amount of sliders.

	When setting -size, if the new amount is larger then the current, new sliders will be added with the value of 0. In the opposite case, the value of sliders up to the new amount will be preserved, and the rest of the sliders will be removed.

	note:: strong:: In Cocoa GUI: ::

	Changing -size after the view has been drawn or after the link::#-value:: array has been set will lead to unexpected results. Instead, you should change the link::#-value::, if you need to change the contents of the view.

	::

	argument::
		An Integer.

METHOD:: value

	Sets the values of the sliders to those of the elements of the argument.

	note::
	If the amount of elements in the argument does not match link::#-size::, then makes link::#-size:: match before applying the new values.
	::

	argument::
		An array of Floats.

METHOD:: valueAction

	Sets link::#-value:: and triggers link::#-action::.

METHOD:: reference

	The reference values in relation to which the values will be visually represented. The default for each slider is 0.

	argument::
		An array of Floats.

METHOD:: index

	The index of the current slider, i.e. the first one in the selection.

	argument::
		An Integer.

METHOD:: selectionSize

	The amount of sliders in the selection (starting at link::#-index::).

METHOD:: currentvalue

	The value of the slider at link::#-index::

	argument::
		A Float.



SUBSECTION:: Display

METHOD:: indexIsHorizontal

	The orientation of the view: if true, the sliders are displayed in a horizontal order, otherwise in a vertical order.

	argument::
		A Boolean.

METHOD:: elasticMode

	If enabled (set to 1), the sliders from link::#-startIndex:: to the last one will be distributed so as to occupy the whole area of the view. The link::#-gap:: variable will be ignored. The size of each slider in the direction of index will be maximally link::#-indexThumbSize::, or smaller in order for all the sliders to fit into the view.

	argument::
		0 (disabled) or 1 (enabled).

METHOD:: gap

	The gap between the sliders in pixels when link::#-elasticMode:: is disabled.

	argument::
		An Integer.

METHOD:: indexThumbSize

	The size of the sliders in the direction of index in pixels . If link::#-elasticMode:: is enabled, this will be the maximum size, but the actual size might be smaller in order for all the sliders to fit into the view.

	argument::
		An Integer.

METHOD:: valueThumbSize

	The size of the slider handles in the direction of value in pixels (if drawn).

	argument::
		An Integer.

METHOD:: thumbSize

	Sets both link::#-indexThumbSize:: and link::#-valueThumbSize:: to the argument.

METHOD:: startIndex

	The index of the slider displayed at the left or top edge of the view (depending on whether link::#-indexIsHorizontal:: is true or false, respectively). Sliders with lower index than this will not be visible.

	argument::
		An Integer.


SUBSECTION:: Appearance

METHOD:: showIndex

	Whether the slider selection is visually indicated.

	argument::
		A Boolean.

METHOD:: drawRects

	Whether to draw the sliders.

	argument::
		A Boolean.

METHOD:: drawLines

	Whether to draw a line connecting the points that represent the link::#-value#values:: of the sliders, and a line connecting the points that represent the link::#-reference#references::.

	argument::
		A Boolean.

METHOD:: isFilled

	If true, the sliders will have their area between the link::#-reference:: and the link::#-value:: colored, and the area bounded by the lines connecting the reference and the value points will be colored as well.

	argument::
		A Boolean.

METHOD:: strokeColor

	The color used to draw the lines described in link::#-drawLines::.

	argument::
		A Color.

METHOD:: fillColor

	The color used to visualize the areas described in link::#-isFilled::.

	argument::
		A Color.

METHOD:: colors

	Sets link::#-strokeColor:: and link::#-fillColor:: to the two arguments, respectively.



SUBSECTION:: Interaction

METHOD:: editable

	Whether the values can be edited using mouse or keyboard.

	argument::
		A Boolean.

METHOD:: readOnly

	The opposite if link::#-editable::.

	argument::
		A Boolean.

METHOD:: step

	If the argument is larger than 0, makes the MultiSliderView keep the values quantized to the nearest multiple of the argument.



SUBSECTION:: Actions


METHOD:: action
	The action object evaluated whenever the user changes the value of a slider.

METHOD:: metaAction
	The action object evaluated whenever the user changes the value of a slider while the Ctrl key is pressed.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## up arrow        || increment -currentValue by -step
	## down arrow      || decrement -currentValue by -step
	## right arrow     || increment -index by 1
	## left arrow      || decrement -index by 1
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		a) If link::#-selectionSize:: is 0, returns link::#-value::.

		b) If link::#-selectionSize:: > 1, returns an Array with the values at the indexes in the selection.

		If link::#-reference:: is not nil, returns an Array containing (a) or (b), and an Array of the corresponding reference values: code:: [[values], [references]] ::.

METHOD:: defaultCanReceiveDrag
	returns::
		True for any drag data, but the data should either be an Array of values ( code:: [values] :: ), or an Array containg an Array of values and an Array of corresponding reference values ( code:: [[values], [references]] :: ).

METHOD:: defaultReceiveDrag
	If the drag data is in one of the acceptable forms (see link::#-defaultCanReceiveDrag:: above), sets link::#-value:: (and link::#-reference::) using that data.



EXAMPLES::

subsection:: Basic Examples

code::
(
n=20;
w = Window.new.front;
m = MultiSliderView(w,Rect(10,10,n*13+2,100)); //default thumbWidth is 13
m.value=Array.fill(n, {|v| v*0.05}); // size is set automatically when you set the value
m.action = { arg q;
    q.value.postln;
};
)
::

Looks like a candlestick graph:

code::
(
var size;
size = 350 / 6;
w = Window.new;
w.view.decorator = FlowLayout(w.view.bounds);
m = MultiSliderView(w, Rect(0, 0, 350, 100));
m.value_(Array.fill(size, {0.01}));
m.isFilled_(true); // width in pixels of each stick
m.indexThumbSize_(2.0); // spacing on the value axis
m.gap_(4);
w.front;
)

// rotate the above graph
(
m.bounds_(Rect(0, 0, 100, 350));
m.indexIsHorizontal_(false);
)
::


subsection:: Interactive Example

A walk through all the graphic options:

code::
(
n=40;

w = Window("MultiSlider Options", Rect(200, Window.screenBounds.height-550, 600, 450));
f={
    w.view.decorator = FlowLayout( w.view.bounds, 10@10, 10@2 );
    m = MultiSliderView(w,Rect(0,0,580,200)); // default thumbWidth is 13
    m.value=Array.fill(n, {|v| 0.5+((0.3*v).sin*0.25)});
    m.action = { arg q;q.value.postln; };

    StaticText(w,380@18).string_("indexThumbSize or thumbSize");
    Slider(w,580@10).action_({arg sl; m.indexThumbSize=sl.value*24}).value_(0.5);
    StaticText(w,380@18).string_("valueThumbSize");
    Slider(w,580@10).action_({arg sl; m.valueThumbSize=sl.value*24}).value_(0.5);
    StaticText(w,580@18).string_("xOffset or gap");
    Slider(w,580@10).action_({arg sl; m.xOffset=sl.value*50});
    StaticText(w,580@18).string_("startIndex");
    Slider(w,580@10).action_({arg sl; m.startIndex = sl.value *m.size};);

    CompositeView(w,580@10);//spacer
    Button(w,100@20).states_([["RESET",Color.red]])
        .action_({ w.view.removeAll; f.value; });
    h=StaticText(w,450@18).string_("").stringColor_(Color.yellow);
    Button(w,100@20).states_([["elasticMode = 0"],["elasticMode = 1",Color.white]])
        .action_({|b| m.elasticMode = b.value});
    Button(w,160@20).states_([["indexIsHorizontal = false"],["indexIsHorizontal = true",Color.white]])
        .action_({|b| m.indexIsHorizontal = b.value.booleanValue}).value_(1);
    Button(w,120@20).states_([["isFilled = false"],["isFilled = true",Color.white]])
        .action_({|b| m.isFilled = b.value.booleanValue});
    Button(w,120@20).states_([["drawRects = false"],["drawRects = true",Color.white]])
        .action_({|b| m.drawRects = b.value.booleanValue}).valueAction_(1);
    Button(w,100@20).states_([["drawLines = false"],["drawLines = true",Color.white]])
        .action_({|b| m.drawLines = b.value.booleanValue});
    Button(w,160@20).states_([["readOnly = false"],["readOnly = true",Color.white]])
        .action_({|b| m.readOnly = b.value.booleanValue});
    Button(w,120@20).states_([["showIndex = false"],["showIndex = true",Color.white]])
        .action_({|b| m.showIndex = b.value.booleanValue});
    Button(w,120@20).states_([["reference = nil"],["reference filled",Color.white],["reference random",Color.yellow]])
        .action_({|b| b.value.booleanValue.if({
            (b.value>1).if(
                {m.reference=Array.fill(n, {1.0.rand})},
                {m.reference=Array.fill(m.size, {0.5})});
                },{ q=m.value;m.reference=[]; h.string="reference can't be returned to nil presently. please hit RESET."}
            )
        });
    Button(w,180@20).states_([["fillColor = Color.rand"]]).action_({m.fillColor=Color.rand});
    Button(w,180@20).states_([["strokeColor = Color.rand"]]).action_({m.strokeColor=Color.rand});
    Button(w,180@20).states_([["background = Color.rand"]]).action_({m.background=Color.rand});

};
f.value;
w.front;

)
::


subsection:: Display a Sound File

code::
(
// press shift to extend the selection
// use as waveView: scrubbing over the view returns index
// if showIndex(false) the view is not refreshed (faster);
// otherwise you can make a selection with shift - drag.
var size, file, maxval, minval;
size = 640;
a = Window("test", Rect(200 , 140, 650, 150));
a.view.decorator = FlowLayout(a.view.bounds);
b = MultiSliderView(a, Rect(0, 0, size, 50));
b.readOnly_(true);
a.view.decorator.nextLine;

d = Array.new;
c = FloatArray.newClear(65493);

r = Slider( a, Rect(0, 0, size, 12));
r.action = {arg ex; b.gap = (ex.value * 4) + 1};

file = SoundFile.new;
file.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
file.numFrames.postln;
file.readData(c);
// file.inspect;
file.close;
minval = 0;
maxval = 0;
f = Array.new;
d = Array.new;
c.do({arg fi, i;
    if(fi < minval, {minval = fi});
    if(fi > maxval, {maxval = fi});

    //f.postln;
    if(i % 256 == 0,{
        d = d.add((1 + maxval ) * 0.5 );
        f = f.add((1 + minval ) * 0.5 );

        minval = 0;
        maxval = 0;
    });
});

b.reference_(d); // this is used to draw the upper part of the table
b.value_(f);

r = Slider( a, Rect(0, 0, size, 12));
r.action = {arg ex; b.startIndex = ex.value *f.size};

// b.enabled_(false);
b.action = {arg xb; ("index: " ++ xb.index).postln};
b.drawLines_(true);
b.drawRects_(false);
b.isFilled_(true);
b.selectionSize_(10);
b.index_(10);
b.thumbSize_(1);
b.gap_(0);
b.colors_(Color.black, Color.blue(1.0,1.0));
b.showIndex_(true);
a.front;

)
::


subsection:: Use as a Sequencer

code::
(
var size;
size = 12;
s.waitForBoot({
    n={arg freq=330; SinOsc.ar(freq,0,0.2)}.play;

    w = Window("test", Rect(200 , 450, 10 + (size * 17), 10 + (size * 17)));
    w.view.decorator = FlowLayout(w.view.bounds);
    b = MultiSliderView(w, Rect(0, 0, size * 17, size * 17));
    b.value_( Array.fill(size,{|i| i/size}) );
    b.background_(Color.rand);
    b.action = {arg xb;
        n.set(\freq, 330+(1100*xb.value.at(xb.index)));
        ("index: " ++ xb.index ++" value: " ++ xb.value.at(xb.index)).postln};
    b.elasticMode_(1); // makes the squares fit evenly
    b.showIndex = true; // cursor mode
    b.readOnly=true;
    w.front;

    r = Routine({
        0.1.wait;
        30.do({ arg i;
            b.index_(i%size);

            b.doAction;
            0.1.wait;
        });

        20.do({ arg i;
            b.index_(b.size.rand);
            b.doAction;
            [0.1,0.2].choose.wait;
        });
        1.wait;
        n.free;
        {w.close}.defer;
    });
    AppClock.play(r);
});
)
::


class:: MultiTap
summary:: Multiple tap delay.
related:: Classes/Tap
categories::  UGens>Buffer, UGens>Delays>Buffer


Description::

This is a wrapper which creates a multiple tap delay line using
link::Classes/RecordBuf::  and  link::Classes/PlayBuf:: .

note:: code::RecordBuf.ar:: and code::PlayBuf.ar:: operate block by block. If a delay time is greater than the buffer
size minus the server's block size, the write and read heads might interfere in unintended ways. Use a slightly larger
buffer if this happens. ::

classmethods::

method::ar

argument::timesArray
A Ref to an Array of delay times in seconds.

argument::levelsArray
A Ref to an Array of amplitudes.

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

argument::bufnum

The number of the buffer to use for the delay. This must be at
least as long as the longest tap time.


Examples::

code::

s.boot;
b = Buffer.alloc(s, s.sampleRate);
(
{
	MultiTap.ar(`[0.1, 0.2, 0.3, 0.4], `[0.1, 0.2, 0.4, 0.8],
		Decay.ar(Dust.ar(2), 0.1, PinkNoise.ar), bufnum: b.bufnum)
}.play
)

::



class:: MultiplexAnalogIn
summary:: Read data from an analog input of the Bela board
related:: Classes/AnalogIn, Classes/AnalogOut, Classes/DigitalIn, Classes/DigitalOut, Classes/DigitalIO
categories::  UGens>Bela


Description::

Reads analog data from a multiplexed analog input of the Bela board, with the additional Multiplexer board.

note::
This UGen only works on Bela
::

classmethods::

method::ar

argument::analogPin

Analog pin number to read. Pin numbers begin at 0. This value can be modulated at audiorate.

argument::muxChannel

Multiplex channel to read. Pin numbers begin at 0. This value can be modulated at audiorate.

argument::mul

argument::add

method::kr

argument::analogPin

Analog pin number to read. Pin numbers begin at 0.

argument::muxChannel

Multiplex channel to read. Pin numbers begin at 0.

argument::mul

argument::add

Examples::

code::
// modulate frequency of a sine oscillator

(
SynthDef("help-MultiplexAnalogIn",{ arg out=0;
	Out.ar(out,
	  SinOsc.ar( MultiplexAnalogIn.ar( 0, 1 ).exprange( 200, 5000 ), 0, 0.1 )
	)
}).play;
)
::



class::NAryOpFunction
summary::represent a n-ary operation on a function
categories::Core
related::Classes/BinaryOpFunction, Classes/UnaryOpFunction, Classes/NAryOpStream, Classes/Pnaryop, Overviews/Operators

description::
Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

examples::
code::
// example
a = 0.8.linexp(0, 1, 40, 20000); // map (0..1) to exponentially to human frequency hearing range
a = { b }.linexp(0, 1, 40, 20000); // result is  a NAryOpFunction
b = 0.1;
a.value; // now it is evaluated, and the result is calculated
b = 0.5;
a.value; // again, with a different value.
::

code::
// sound example
(
var a = { 1.0.rand };
var b = a.linexp(0, 1, 40, 20000);
fork {
	15.do {
		(instrument: \default, freq: b.value).play;
		0.3.wait;
	}
}
)
::


class:: NAryOpStream
summary:: several streams combined by an n-ary operator
related:: Classes/UnaryOpStream, Classes/BinaryOpStream
categories:: Streams-Patterns-Events

description::

A NAryOpStream is created as a result of a n-ary math operation on a Stream. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from the stream. It responds to strong::reset:: by resetting the Stream.

Examples::

code::
x = Routine { 6.do { arg i; i.yield; } }.wrap(0, 3);
x.dump;
::

code::
(
x = Routine { 6.do { arg i; i.yield; } }.wrap(0, 3);
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
::


class:: NRand
summary:: Sum of uniform distributions.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in a sum of
code::n::  uniform distributions from
code::lo::  to  code::hi:: .


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::n

table::

## n = 1: || Uniform distribution - same as link::Classes/Rand::.

## n = 2: || Triangular distribution.

## n = 3: || Smooth hump.

::

As
code::n::  increases, distribution converges
towards gaussian.


Examples::

code::

(
SynthDef("help-NRand", { arg out=0, n=0;
	Out.ar(out,
		FSinOsc.ar(
			NRand(1200.0, 4000.0, n),
			0, Line.kr(0.2, 0, 0.01, doneAction: Done.freeSelf))
	)
}).add;
)

(
n = 0;
Routine({
	inf.do({ arg i;
		Synth.new("help-NRand", [\n, n]); 0.05.wait;
	})
}).play;
)

n = 1;
n = 2;
n = 4;

::



class:: NamedControl
categories:: UGens>Synth control
summary:: Named reference to a control
related:: Classes/ControlName, Classes/Control

description::

A NamedControl directly combines a ControlName and a Control UGen conveniently. Also this makes it safe even if several identical controls exist (see example below).

There are syntax shortcuts that generate NamedControls from the name:
code::
\name.ar(values, lags, spec)
\name.kr(values, lags, fixedLag, spec)
\name.ir(values, lags, spec)
\name.tr(values, lags, spec)
::

ClassMethods::
method:: ar
add a new instance of link::Classes/AudioControl:: with given name and default values.
If lags are given, apply a Lag UGen to it.
discussion::
code::\symbol.ar(values, lags, spec):: is a synonym.

method:: kr
add a new instance of link::Classes/Control:: (kr) with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it. If fixedLag is set to true, create a link::Classes/LagControl:: (lags cannot be modulated then, but fewer UGens are required).
discussion::
code::\symbol.kr(values, lags, fixedLag, spec):: is a synonym.

method:: ir
add a new instance of link::Classes/Control:: (ir) with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it.
discussion::
code::\symbol.ir(values, lags, spec):: is a synonym.

method:: tr
add a new instance of link::Classes/TrigControl:: with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it.
discussion::
code::\symbol.tr(values, lags, spec):: is a synonym.

method:: new
add a new instance with the given rate, name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it. If fixedLag is set to true, create a link::Classes/LagControl:: (lags cannot be modulated then, but fewer UGens are required).

Examples::
code::
// use NamedControl to create a number of multichannel controls:

a = { SinOsc.ar(NamedControl.kr(\freq, [300, 330, 370], [1, 0.3, 0.02])).sum * 0.1 }.play;
a.setn(\freq, [700, 705, 890]);
a.setn(\freq, [0, 2, 5].midiratio * 400);

// synonymous:
a = { SinOsc.ar(\freq.kr([300, 330, 370], [1, 0.3, 0.02])).sum * 0.1 }.play;
::

subsection:: Multiple usage of the same name

Identical controls can not make use of different defaults and lag values. They can be saved to a variable to avoid duplicate code.
code::
// multiple usage of the same name:
a = { SinOsc.ar(\freq.kr(440, 1.0)) + Saw.ar(\freq.kr(440, 1.0) * 0.5) * 0.1 }.play;

a.set(\freq, 1220);
a.set(\freq, 120);

// with different lag values:
a = { SinOsc.ar(\freq.kr(440).lag(3.5)) + Saw.ar(\freq.kr(440).lag(0.05) * 0.5) * 0.1 }.play;

a.set(\freq, 1220);
a.set(\freq, 120);

// control saved to a variable:
(
a = {
	var freq = \freq.kr(440);
	SinOsc.ar(freq.lag(3.5)) + Saw.ar(freq.lag(0.05) * 0.5) * 0.1;
}.play;
)

a.set(\freq, 1220);
a.set(\freq, 120);
::

subsection:: Comparison with direct use of Controls

In the situation when functions are used to combine UGens to more complex SynthDefs, it may not be known which ControlNames are already taken by others. NamedControl allows to reuse existing control names.
code::
// compare this:
(
a = {
    var x, y;
    x = NamedControl.kr(\freq, 440).lag(3.5);
    y = NamedControl.kr(\freq, 440).lag(1);
    SinOsc.ar([x, y] * [2, 1.2]) * 0.1
}.play;
)

a.set(\freq, 1220);
a.set(\freq, 120);

// to this:
(
a = {
    var x, y;
    x = Control.names([\freq]).kr(440).lag(3.5);
    y = Control.names([\freq]).kr(440).lag(1); // this hangs when set
    SinOsc.ar([x, y] * [2, 1.2]) * 0.1
}.play;
)

a.set(\freq, 1220);
a.set(\freq, 120);
::

subsection:: Using dictionary with functions to build SynthDefs
Here is a basic example using a dictionary with functions that can be combined to build SynthDefs.
code::
(
q = ();
q.makeEnv = { |q, env, doneAction = 0| EnvGen.kr(env, NamedControl.kr(\gate, 1), doneAction: doneAction) };
q.chooseNoise = { [ {PinkNoise.ar}, {WhiteNoise.ar}, {LFNoise2.ar(Rand(100, 1000))}].choose.value};
q.filterInput = { |q, in| [
	{ BPF.ar(in * 15, NamedControl.kr(\freq, 800), 0.2) },
	{ RHPF.ar(in, NamedControl.kr(\freq, 800, 0.2), 0.2) }
	].choose.value
};
)

// test the envelope:
a = { SinOsc.ar(440) * q.makeEnv(Env.asr, 2) * 0.1 }.play;
a.set(\gate, -3); // release in 3 seconds

// single channel:
a = { q.chooseNoise * q.makeEnv(Env.asr, 2) }.play;
a.set(\gate, -3); // release in 3 seconds

a = { q.filterInput(q.chooseNoise) * q.makeEnv(Env.asr, 2) }.play;
a.set(\freq, 1000); // set filter frequency
a.set(\gate, -3); // release in 3 seconds

(
a = {
	var channels = Array.fill(8, {
		q.filterInput(q.chooseNoise) * q.makeEnv(Env.asr, 2)
	});
	Splay.ar(channels);

}.play;
)
a.set(\freq, 6000); // set filter frequency
a.set(\gate, -3); // release in 3 seconds
::



class:: Ndef
summary:: node proxy definition
categories:: JITLib>NodeProxy, Live Coding
related:: Classes/ProxySpace, Classes/Tdef

description::
Ndef registers synths by key. All accesses to the registered synths go through the Ndef class via that key. Registered synths can be replaced with other synths while playing. A synth and its replacement can automatically crossfade and the replacement time can be quantized.

Ndef is a reference to a proxy, forms an alternative to link::Classes/ProxySpace::. All methods are inherited from link::Classes/NodeProxy::.

code::
Ndef(key)	//returns the instance
Ndef(key, obj)	//stores the object and returns the instance, like Tdef and Pdef.
::

Graphical editor overviewing all current Ndefs: link::Classes/NdefMixer::. A general overview: link::Overviews/JITLib::.

subsection::First Example

code::
s.boot;

Ndef(\a).play; // play to hardware output.
Ndef(\a).fadeTime = 2; // fadeTime specifies crossfade
// set the source
Ndef(\a, { SinOsc.ar([350, 351.3], 0, 0.2) });
Ndef(\a, { Pulse.ar([350, 351.3] / 4, 0.4, 0.2) });
Ndef(\a, Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350)));

Ndef(\a, { Ringz.ar(Ndef.ar(\b), [350, 351.3] * 2, 0.4) });
Ndef(\b, { Impulse.ar([5, 7]/2, [0, 0.5], 0.15) });

Ndef.clear(3); // clear all after 3 seconds
::


ClassMethods::

private::initClass

subsection::Creation

method::new
Return a new node proxy and store it in a global ProxySpace under the key. If there is already an Ndef there, replace its object with the new one. The object can be any supported class, see link::Classes/NodeProxy#Supported sources:: help.

argument::key
the name of the proxy (usually a symbol). If only the key is given and no object, it returns the proxy object:
code::
Ndef(\x) // get the proxy
::

If key is an association, it is interpreted as strong::key -> server name::. (order changed in SC3.3 !). If no name is given, it uses the default server that was default when Ndef was first called. (to change it, see link::#*defaultServer::).

argument::object
an object

code::
Ndef(\x, { Dust.ar }); // returns the proxy and set the source object.
::

method::ar
equivalent to code::*new(key).ar(numChannels, offset):: (see link::Classes/BusPlug#-ar::)

method::kr
equivalent to code::*new(key).kr(numChannels, offset):: (see link::Classes/BusPlug#-kr::)

method::clear
clear all proxies

method::defaultServer
set the default server (default: code::Server.default::)

method::all
Return the dictionary of all servers, pointing to proxyspaces with Ndefs for each.

code::
Ndef.all;
::

method::dictFor
Return the proxyspace for a given server.

code::
Ndef.dictFor(s);
::

subsection::Setting default parameters
Behind every Ndef there is one single instance of link::Classes/ProxySpace:: per server used (usually just the one for the default server). This ProxySpace keeps default values for the proxies that can be set. This can be done by:

code::
// set default quant
Ndef(\x).proxyspace.quant = 1.0;
::
The other values that can be set in such a way are: code::clock, fadeTime, quant, reshaping, awake::.


Examples::

code::
s.boot;

Ndef(\sound).play;
Ndef(\sound).fadeTime = 1;
Ndef(\sound, { SinOsc.ar([600, 635], 0, SinOsc.kr(2).max(0) * 0.2) });
Ndef(\sound, { SinOsc.ar([600, 635] * 3, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\sound, { SinOsc.ar([600, 635] * 2, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\sound, Pbind(\dur, 0.17, \freq, Pfunc({ rrand(300, 700) })) );

Ndef(\lfo, { LFNoise1.kr(3, 400, 800) });
Ndef(\sound).map(\freq, Ndef(\lfo));
Ndef(\sound, { arg freq; SinOsc.ar([600, 635] + freq, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\lfo, { LFNoise1.kr(300, 400, 800) });

Ndef.clear; //clear all Ndefs
::

subsection::using Ndef inside other Ndefs

code::
Ndef(\lfo2, { LFNoise1.kr(LFNoise1.kr(0.1).exprange(1, 300) ! 2, 400, 800) });
Ndef(\sound, { Blip.ar(Ndef.kr(\lfo2), 30) * 0.2 }).play;

Ndef(\lfo2, { [MouseX.kr(10, 300, 1), MouseY.kr(10, 300, 1)] });
::

subsection::setting and mapping parameters

code::
Ndef(\sound, { |freq = 56, numHarm = 10| Blip.ar(freq, numHarm, 30) * 0.2 }).play;
Ndef(\sound).set(\freq, 15);
Ndef(\sound).set(\freq, 15, \numHarm, 100);

Ndef(\lfo, { LFNoise2.kr(2).exprange(10, 200) });
Ndef(\sound).map(\numHarm, Ndef(\lfo));
Ndef(\sound).set(\numHarm, nil); // unmap.
Ndef(\sound).stop;
::


subsection::Reserved parameters
Three parameters are automatically specified if they don't exist in a given UGen function. You can override their use: code::[\out, \gate, \fadeTime]::

subsection::Specifying your own envelope

If a UGen function that is passed to the proxy has its own envelope, and if this envelope can free the synth, the node proxy uses this envelope instead of making its own. If you provide a code::fadeTime:: argument, the proxy's fadeTime will be used.

code::
Ndef(\sound).fadeTime = 3;
(
Ndef(\sound, { |fadeTime = 1, gate = 1|
	var e = Env.adsr(fadeTime, 0.01, 0.4, fadeTime).ar(2, gate);
	SinOsc.ar(100 + (e * 700), SinOsc.ar(208) * (1 - e) * 6) * e * 0.1
}).play
)
::



subsection::Simple audio routing with the <<> operator

code::
(
Ndef(\sound, {
	RHPF.ar(
		\in1.ar([0, 0]) * \in2.ar([0, 0]),
		\freq.kr(6000, 2),
		\rq.kr(0.2)
	) * 7
}).play;
Ndef(\sound).fadeTime = 0.2;	// avoid harsh clicks
)

Ndef(\a, { SinOsc.ar(MouseX.kr(300, 1000, 1) * [1, 1.2], \phase.ar([0, 0]) * 0.2) });
Ndef(\b, { LFDNoise3.ar(MouseY.kr(3, 1000, 1) * [1, 1.2]) });
Ndef(\c, { LFTri.ar(MouseY.kr(3, 10, 1) * [1, 1.2]).max(0) });
Ndef(\a).fadeTime = 0.2;	// avoid harsh clicks again

Ndef(\sound) <<>.in1 Ndef(\a);
Ndef(\sound) <<>.in2 Ndef(\b);
Ndef(\sound) <<>.in2 Ndef(\c);
Ndef(\a) <<>.phase Ndef(\sound);
Ndef(\a) <<>.phase nil;	// unmap
Ndef.clear(3);		// fade out and clear all Ndefs
::

subsection::Embedding multi-channel Patterns, playing Streams in parallel

Controlling multi-channeled sequenced streams and having independent control over filtering and node ordering is a difficult topic in SuperCollider. However, using Ndefs (or their superclass link::Classes/NodeProxy:: or a link::Classes/ProxySpace::) may provide a convenient solution.

code::
// a SynthDef, creating single-channel grain when instantiated
(
SynthDef(\grain, { |out=0, freq=300, amp=0.3|
	OffsetOut.ar(out, Pulse.ar(freq) * EnvGen.kr(Env.perc, doneAction: Done.freeSelf) * amp)
}).add;
)

// number of channels
~numChans = 5;

// values in a Pattern may be set in various ways
// here we use control buses, except for \dur which
// doesn't accept a control bus in parallel playing streams
// therefore we use PatternProxies
~durs = ~numChans.collect({ |i| PatternProxy(0.5 + (i/10)) });

// other parameters could as well be controlled in PatternProxies,
// yet, control buses are convenient either
~freqs = Bus.control(s, ~numChans);
~freqs.setn(Array.geom(~numChans, 300, 1.1));
~amps = Bus.control(s, ~numChans);
~amps.setn(0.2!~numChans);

// the Pattern: a Ppar holding one Pbind for each channel,
// all wrapped in a Pdef
(
Pdef(\ppar,
    Ppar({ |i|
        Pbind(
            \instrument, \grain,
            // we only set a single channel
            \dur, ~durs[i],
            \freq, ~freqs.subBus(i).asMap,
            \amp, ~amps.subBus(i).asMap,
            // the Pattern will play to a yet unknown private bus
            // we only want to make sure the offset is right
            \channelOffset, i,
        )
    }!~numChans)
)
)

// initialize an Ndef that will hold the Pdef as its source
// make sure the Ndef gets initialized to the right number of channels by calling 'mold'
Ndef(\ppar).mold(~numChans, \audio, \elastic);
Ndef(\ppar)[0] = Pdef(\ppar);

// mix the 5 channel audio coming from Ndef(\ppar) down to stereo
// Splay will spread the channels over the stereo panorama
// possibly use headphones to clearly identify the effect
Ndef(\stereo, { Splay.ar(\in.ar(0!~numChans)) });

// concatenate the Ndefs, so Ndef(\ppar)'s out will feed into Ndef(\stereo)'s in
Ndef(\stereo) <<> Ndef(\ppar);
Ndef(\stereo).play;

// change durations
~durs.do({ |pp, i| pp.source = Pseq(Array.fib(5, i/10 + 0.1, i+1/5), inf) });
~durs.do({ |pp, i| pp.source = 0.5 + (i/10) });
~durs.do({ |pp| pp.source.postcs });

// frequencies
~freqs.setn(Array.geom(~numChans, 250, 1.6));
~freqs.setn(Array.geom(~numChans, 300, 1.1));

// add a filter Ndef
(
Ndef(\filter, {
	HPF.ar(
		\in.ar(0!~numChans),
		SinOsc.ar({|i| 2 + i}!~numChans) + 1 * \multFreq.kr(Array.geom(~numChans, 400, 2))
	)
}).mold(~numChans, \audio, \elastic);
)

// set a fadeTime for smooth transitions and add the filter to the chain
#[ppar, stereo, filter].do({ |k| Ndef(k).fadeTime_(3) });
Ndef(\stereo) <<> Ndef(\filter) <<> Ndef(\ppar);

// set filter param, considering fadeTime
Ndef(\filter).xset(\multFreq, Array.rand(~numChans, 20, 10000));

Ndef.clear;
Pdef.clear;
::

subsection::Making Copies

method::copy
Because an Ndef is a unique instance for a given key, it can be copied only by supplying a new key.
See also: link::Classes/NodeProxy#-copy::.

code::
Ndef(\x, { SinOsc.ar(Rand(500, 900)) * 0.1 }).play;
Ndef(\x).copy(\y);
Ndef(\y).play;
::

argument::newKey
A valid new key, usually a link::Classes/Symbol::

subsection::Recursion

Ndefs can be used recursively. A structure like the following works:

code::
Ndef(\sound, { SinOsc.ar([600, 635], Ndef.ar(\sound), LFNoise1.kr(2).max(0) * 0.2) });
Ndef(\sound).play;
Ndef.clear;
::

This is because there is a feedback delay (the server's strong::block size::), usually 64 samples, so that calculation can reiterate over its own outputs. For single sample feedback, see:

code::
(Platform.resourceDir +/+ "examples/demonstrations/single_sample_feedback.scd").openDocument;
::

subsection::Using different servers

code::
// create a new server
a = Server(\foo, NetAddr("127.0.0.1", 57123)).boot.makeWindow;
Ndef(\sound, { SinOsc.ar([600, 635]) * SinOsc.kr(2).max(0) * 0.2 }).play; // play on default
Ndef(\sound -> \foo, { SinOsc.ar([700, 745]) * SinOsc.kr(2).max(0) * 0.2 }).play;// play on foo

// clear definitions
Ndef(\sound -> \foo).clear(3);
Ndef(\sound).clear(3);

a.dump;	// display settings of new server
a.quit;	// terminate new server
::
subsection::GUI

code::
// create a window for a given Ndef
Ndef(\sound).edit
(
Ndef(\sound, { |freq = 440, rate = 2|
	SinOsc.ar(freq * [1, 1.625]) * SinOsc.kr(rate).max(0) * 0.2
}).play;
)

// set lags for controls:
Ndef(\sound).lag(\freq, 0.2, \rate, 0.5);
Ndef(\sound).clear(1);

// create a mixer for all Ndefs:
NdefMixer(s);
::

subsection::Using Associations

For a complete list, see link::Classes/NodeProxy::, and link::Reference/NodeProxy_roles::

code::
// setsrc
(
Ndef(\x,
	\setsrc -> Pbind(\source,
		Pseq([
			{ LFTri.ar(280 * Line.kr(1.1, 0.4, rrand(2, 3)) + [0,1]) * 0.1 },
			{ Pulse.ar(40 + [0,1]) * 0.1 },
			{ LFTri.ar(LFTri.kr(1).round(1.0.rand) + 1 * 180 + [0,1], 0.04) * 0.3 },
		], inf),
		\dur, Prand([3, 2, 4], inf)
	)
).play;
)
::


class:: NdefGui
summary:: a gui for a NodeProxy or Ndef
categories:: JITLib>GUI, Live Coding
related:: Classes/JITGui, Classes/MonitorGui, Classes/NdefParamGui, Classes/NdefMixer, Classes/ProxyMixer

description::

NdefGui provides controls for handling and editing a link::Classes/NodeProxy:: or link::Classes/Ndef::, and its monitors. NdefGui replaces link::Classes/NodeProxyEditor::. It provides:

list::
## sliders for numerical settings
## mapping of kr proxies to parameters
## optional controls for playing / monitoring
::

Both link::Classes/NodeProxy:: and link::Classes/Ndef:: implement a strong::.gui:: message, which returns a NdefGui for that NodeProxy. Overview: link::Overviews/JITLib::.

code::
(
s.boot;
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
}).gui;
)
::

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::object
the nodeproxy to be shown and edited, or nil.

argument::numItems
How many sliders or textviews for parameters to provide. Default value is 0.

argument::parent
a parent view where NdefGui is to be shown. If nil, a window is made.

argument::bounds
bounds where the view (or window) will be shown.

argument::makeSkip
a flag whether to create and start a link::Classes/SkipJack:: for auto-updating.

argument::options
an array of symbols for options of what to display. See list below.

subsection:: Preset options lists which can be used in *new:

method::big
two lines of controls for a big NdefGui, usually in its own window

method::full
two lines of controls for a very big NdefGui

method::audio
for ar proxies, used in ProxyMixer left hand side

method::audioSm
for ar proxies, used in ProxyMixer.small on left hand side

method::control
for kr proxies, used in ProxyMixer mid section


subsection::Class Variables

method::buttonSizes
a dict for the sizes of the different gui elements.

method::buttonFuncs
a lookup dict for making the different buttons.

method::makeButFuncs
not a class var, but the method that inits buttonFuncs.



InstanceMethods::

subsection::Variables

See link::Classes/JITGui:: for more instance methods.

Various views the NdefGui has if they were present in the options:

method::nameView, typeView, monitorGui, paramGui, fadeBox, pauseBut, sendBut, edBut, wakeBut

subsection::Basic Methods

method::edits
the paramGui's widgets (usually, EZSliders)
method::editKeys
the currently used param names

method::highlight, unhighlight
highlight and unhighlight a single slider by index

method::highlightName, unhighlightName
highlight and unhighlight the nameView

method::highlightParams
highlight a contiguous group of sliders;
used for showing assigned MIDI faderboxes etc.

method::addReplaceKey, removeReplaceKey
editKeys with technical names can be replaced with
more user-friendly ones.

method::proxy
an alias to method object, object_


subsection::Standard JITGui Methods

method:: setDefaults
method:: accepts
method:: getState, checkUpdate

subsection::GUI Element Creation

method:: makeViews
creates all the views given in the options list. Internally this calls the following methods:

method:: makeNameView, makeTypeView, makeClrBut, makeWakeBut, makeResetBut, makeScopeBut, makeDocBut, makeEndBut, makeFadeBox, makePauseBut, makeSendBut, makeEdBut, makeRipBut, makePollBut
method:: makeMonitor


Examples::

code::
	// some preparation - make an ar and a kr nodeproxy.
s.boot;
(
Ndef(\lfo, { |lofreq| SinOsc.kr(lofreq) });
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
});
)

    // make an NdefGui. By default, this has a lot of the options on.
n = NdefGui.new;
n.object_(Ndef(\lfo));
Ndef(\lfo).set(\lofreq, 12);

n.object_(Ndef(\a));
Ndef(\a).set(\freq, 120);
::

subsection::Some configuration options

code::
	// some preparation - make an ar and a kr nodeproxy.
s.boot;
(
Ndef(\lfo, { |lofreq| SinOsc.kr(lofreq) });
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
});
)

    // make an NdefGui. By default, this has a lot of the options on.
n = NdefGui.new;
n.object_(Ndef(\lfo));
Ndef(\lfo).set(\lofreq, 12);

n.object_(Ndef(\a));
Ndef(\a).set(\freq, 120);
::

subsection::Some configuration options

code::
	// numItems - sliders for setting parameters
n = NdefGui(Ndef(\a), 8);

	// 4 sets of configurations are provided:
n = NdefGui(Ndef(\a), 0, options: NdefGui.control);
n = NdefGui(Ndef(\a), 0, options: NdefGui.audio);
n = NdefGui(Ndef(\a), 0, options: NdefGui.big);
n = NdefGui(Ndef(\a), 0, options: NdefGui.full);


NdefGui.control;	// used for control proxies in ProxyMixer/NdefMixer
->	[ \name, \pausR, \sendR, \poll, \ed ]

NdefGui.audio;		// used for audio proxies in ProxyMixer/NdefMixer
->	[ \monitor, \playN, \name, \pausR, \sendR, \ed ]

NdefGui.big;		// used for the big NdefGui in ProxyMixer/NdefMixer
->	[ \name, \type, \CLR, \reset, \scope, \doc, \end, \fade,
		\monitor, \playN, \pausR, \sendR, \poll ]

			// all of 'em
NdefGui.full;
->	[ 	name, \type, \CLR, \reset, \scope, \doc, \end, \fade, \rip,
		monitor, \playN, \pausR, \sendR, \poll, \ed ]
/*
	// the choice of elements is:
	\name		a dragboth for the proxy's name
	\type		a view for the proxy's type (ir, ar + numChans, kr + numChans)
	\CLR 		button to clear proxy
	\reset		button to reset proxy nodemap
	\scope		button to scope proxy
	\doc			button to document proxy as code
	\end			button to end proxy
	\fade		EZNumber for setting proxy fadetime

	\monitor		MonitorGui for audio proxies
	\playN		a button for editing playN settings (within the MonitorGui)

	\rip		(^)	button to open a new editor on the proxy (used in ProxyMixer/NdefMixer)

	\pausR		a button to toggle proxy pause/resume
	\sendR		a button to re-send; alt-click tells the proxy to rebuild
	\poll		poll the proxy

    * preset storage in JITLibExtensions, see ProxyPreset / NdefPreset

*/

// 	add your own functions to add your own elements, such as:
NdefGui.buttonSizes.put(\zoink, 60);
NdefGui.buttonFuncs.put(\zoink, { |ndgui| Button(ndgui.zone, 60@20).states_([["zoink"]]).action_({ ndgui.object.zoink }) });

n = NdefGui(Ndef(\a), 4, options: NdefGui.big ++ [\zoink]);


	// make one and watch how the elements change
n = NdefGui(Ndef(\a), 4, options: NdefGui.big);

Ndef(\a).stop;
Ndef(\a).play;
Ndef(\a).vol_(0.3);
Ndef(\a).stop;

Ndef(\a).playN([2, 5]);   // does not display fully on outNumberBox
Ndef(\a).playN([2, 5], vol: 0.34);


	// as in ProxyMixer, left side
n = NdefGui(Ndef(\a), options: NdefGui.audio);

// as in ProxyMixer control zone
n = NdefGui(Ndef(\a), 4, options: NdefGui.control);

    // NdefGui default
n = NdefGui(options: NdefGui.big);

    // and a few more
n = NdefGui(bounds: 400@20, options: NdefGui.full);

	// put in a window - then no margin is added
(
w = Window().front;
w.addFlowLayout;
n = NdefGui(Ndef(\a), 4, w, options: NdefGui.big);
)


Ndef(\a, { |freq = 10| Blip.ar(freq) }).set(\freq, 200)
Ndef(\a, { |freq = 10, amp = 0.1| Blip.ar(freq) * amp })
Ndef(\a).set(\freq, 220)
Ndef(\a).set(\harm, 20)
Ndef(\a, { |freq = 10, amp = 0.1, harm = 20| Blip.ar(freq, harm) * amp })
::

subsection::Test - drag and drop proxies between NdefGuis

This seems broken in 3.7.0 - drags are sticky and can't be dropped.

code::
(
	p = ProxySpace.push(s.boot);

l = NdefGui(nil, 3).moveTo(10, 120);
m = NdefGui(nil, 3).moveTo(10, 240);
n = NdefGui(nil, 3).moveTo(10, 360);
o = NdefGui(nil, 3).moveTo(10, 480);

Spec.add(\dens, [0.1, 300, \exp]);

	// make 3 kinds of proxies: using tilde/proxyspace, Ndef, and unnamed.
~spacy = {|dens=5| Formlet.ar(Dust.ar(dens ! 2), LFDNoise0.kr(20 ! 2).lag(0.1).linexp(-1, 1, 300, 5000), 0.003, 0.03) };
Ndef(\ndeffy, { GrayNoise.ar( 0.1 ! 2) });
c = NodeProxy.audio.source_({ PinkNoise.ar(0.1 ! 2) });

	// put one in each editor
l.object_(~spacy);
m.object_(Ndef(\ndeffy));
n.object_(c);
)
	// One should also be able to drag and drop text into the drag,
    // but this is also not working yet.
(	Ndef(\a)	)
::

subsection::Test - replacing keys

This is used in ProxyChain (JITLibExtensions).

code::
(
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
});
n = NdefGui(Ndef(\a));
)
n.addReplaceKey(\freq, \myFreak);
	// ATM needs an extra update:
x = n.object; n.object_(nil); n.object_(x);
::


class:: NdefMixer
summary:: mix control for an Ndef proxyspace
categories:: JITLib>GUI, Live Coding
related:: Classes/ProxyMixer, Classes/JITGui, Classes/NdefGui

description::

NdefMixer is nearly identical to link::Classes/ProxyMixer::, except that it looks at the proxyspaces for each server that code::Ndef.all:: contains.

Examples::

code::
n = NdefMixer(s);
n.parent.alwaysOnTop_(true); // show mixer in front of IDE

s.boot;
// if you have JITLibExtensions installed, try ProxyMeter to see the proxy levels:
if (\ProxyMeter.asClass.notNil) { ProxyMeter.addMixer(n); };


"bcdefghijk".do { |k| Ndef(k.asSymbol).ar };

"lmnopqrtuvw".do { |k| Ndef(k.asSymbol).kr };

"abcdefghijk".do { |k| Ndef(k.asSymbol).playN };
(
Ndef(\aaaaaa, { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
	var env = EnvGen.kr(
		Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
		timeScale: timescale);
	var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
	Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
}).play(vol: 0.25);
)

n.switchSize(2);
n.switchSize(1);
n.switchSize(0);

n.switchSize(2);
n.editGui.object_(Ndef(\aaaaaa));

NdefMixer(Server.internal, 24);
::


class:: NdefMixerOld
summary:: mix control for all Ndefs on a given server
categories:: JITLib>GUI
related:: Classes/NdefMixer

description::

For more details see: link::Classes/ProxyMixer::

ClassMethods::

subsection::Creation

method::new
Return a new window for a given server.

code::
// ndef mxers for other servers
n = NdefMixer(\internal);
n = NdefMixer(\localhost);
n = NdefMixer(\trala);		// fails, no such server
::

argument::server
Server object ( link::Classes/Server:: ) or server name ( link::Classes/Symbol:: )

argument::nProxies
an Integer.

argument::title
a String.

argument::bounds
a Rect.

InstanceMethods::

method::proxyspace
Return the proxyspace.


Examples::

code::
n = NdefMixer(s);		// for the default server
// make a new proxy
(
Ndef(\a, {
	Pan2.ar(
		Ringz.ar(
			Impulse.ar(exprand(0.5, 4)),
			exprand(300, 3000),
			0.02
		),
	1.0.rand2,
	0.2)
})
);



n.proxyspace;

Ndef(\duster, { Dust.kr(4) });

Ndef(\a).ar;
Ndef(\a).fadeTime = 2;
Ndef(\a).end;
::


class:: NdefParamGui
summary:: display the settings of a nodeproxy
categories:: JITLib>GUI, Live Coding
related:: Classes/EZText, Classes/NdefGui, Classes/EnvirGui

description::

NdefParamGui displays all settings and mappings of a nodeproxy, so one can change them flexibly. Single number get displayed with an link::Classes/EZSlider::, and anything else is shown as an link::Classes/EZText:: (a text field). Its main use is within link::Classes/NdefGui::.

It inherits some useful methods from link::Classes/EnvirGui::.

ClassMethods::

subsection::Creation

method::new
create a new NdefParamGui

code::
// simple example - see also NdefGui!

g = NdefParamGui.new(nil, 5);	// empty with 5 slots
g.parent.alwaysOnTop_(true);
g.object_(Ndef(\a));		// put in a nodeproxy
Ndef(\a, { |freq = 300, amp = 0.2| SinOsc.ar(freq) * amp ! 2 }).play;
Ndef(\a).set(\freq, 200);	// add a setting
Ndef(\a);
g.object_(nil);			// put in nothing

g.object_(Ndef(\a)); 		// put in a nodeproxy
Ndef(\a).set(\amp, 0.125);	// add a setting
Ndef(\a, { |freq = 300, amp = 0.2| SinOsc.ar(freq) * amp });
Ndef(\a).set(\freq, 234);	// add a setting

Ndef(\a).play
Ndef(\lfo, { LFNoise0.kr([12, 8], 200).sum + 500 });
Ndef(\a).map(\freq, Ndef(\lfo));// mapped proxies are shown

g.useRanger = false;

//Multichannel controls are shown in EZText
g.putSpec(\freqs, \freq);
Ndef(\a, { |freqs = #[300, 303], pan, amp = 0.2| SinOsc.ar(freqs).sum * amp });
Ndef(\a).play
Ndef(\a).setn(\freqs, [300, 350])
Ndef(\a).setn(\freqs, [330, 350])
Ndef(\a).set(\harm, 123)

Ndef(\a).nodeMap.clear

Ndef(\lfos, { LFNoise0.kr([12, 8], 200) + 500 });
Ndef(\a).map(\freqs, Ndef(\lfos))

g.parent.close
::

argument::object
the nodeproxy whose settings are to be displayed.

argument::numItems
the number of items to display. If an envir is given, and no num, num is envir.size.

argument::parent
the parent view to display in; if none is given, a new window is created.

argument::bounds
the bounds within which to display; if none is given, bounds are calculated.

argument::makeSkip
flag whether to make a skipjack to manage updates of the envirgui. default is true.

argument::options
a list of additional information, e.g. flags about optional buttons.

InstanceMethods::

method::name
if in its own window, set the window's name

code::
g.name = "Yoohoo";
::

Examples::

code::
	// put an NdefParamGui in an existing window - margin becomes 0@0
(
w = Window().front;
w.addFlowLayout;
g = NdefParamGui(Ndef(\a), 3, w);
NdefParamGui(Ndef(\c), 15, w);
)
	// even
Ndef(\c).set(\otto, 123, \mops, [1,2,3], \kotzt, [0, 6, 0, 6]);
Ndef(\c).nodeMap.clear;
::


class:: NetAddr
summary:: network address
related:: Classes/OSCFunc
categories:: Control, External Control>OSC

ClassMethods::

private::initClass

method::new
create new net address.
note::To send messages internally, loopback IP is used: "127.0.0.1"::

argument::hostname
a link::Classes/String::, either an IP number (e.g. "192.168.34.56") or a hostname such as "otherHost.local".

argument::port
a port number, like 57110.

method::fromIP
create new net address using an integer IP number.

method::langPort
Get the port sclang is currently listening on (may change after a recompile).

method::localAddr
Get a NetAddr which corresponds to localhost and the port sclang is listening on.

method::disconnectAll
close all TCP connections.

method::broadcastFlag
Get or set the broadcast flag (whether or not broadcast messages can be sent).

method::matchLangIP
Test an IP address to see if it matches that of one of the NICs on this computer.

argument::ipstring
A link::Classes/String:: to test containing an IP number in dot decimal notation (e.g. "192.168.34.56").

returns::A link::Classes/Boolean:: indicating whether a match was found.

method::connections

returns::A copy of the link::Classes/IdentityDictionary:: with all open TCP connections.

InstanceMethods::

private::prConnect, prDisconnect, prConnectionClosed, recover

method::sendMsg
Convert the argument list to an OSC message and send it to the NetAddr without a timestamp. The first argument is the OSC address, and the remaining arguments are the arguments in the OSC message. If you leave off the initial "/" in the OSC address, one will be prepended. The technical details of how sclang objects are converted to OSC messages is given in the link::Guides/OSC_communication:: helpfile.

code::
n = NetAddr("localhost", 12345);
n = s.addr;

// Example sending symbols, integers, and a float
n.sendMsg('/s_new', \default, 2000, 0, s.defaultGroup.nodeID, \freq, 60.midicps);

// The initial forward slash can be omitted
n.sendMsg(\n_set, 2000, \gate, 0);

// Using the performList syntax, you can use an array to store an OSC message
~msg = [\n_set, 2000, \gate, 0];
n.sendMsg(*~msg);
::

method::sendBundle
send a bundle with timestamp to the addr.

method::sendRaw
send a raw message without timestamp to the addr.

method::connect
open TCP connection.

argument::disconnectHandler
called when the connection is closed (either by the client or by the server).

method::disconnect
close TCP connection.

method::ip
returns the ip number (as a link::Classes/String::).
code::
n = NetAddr("localhost", 57110);
n.ip;
::

method::isLocal
Test if this NetAddr ip number matches that of one of this hosts NICs, or the loopback address.
returns::A link::Classes/Boolean::.

Examples::

code::
n = NetAddr("127.0.0.1", 57120); // 57120 is sclang default port
r = OSCFunc({ arg msg, time; [time, msg].postln }, '/good/news', n);

n.sendMsg("/good/news", "you", "not you");
n.sendMsg("/good/news", 1, 1.3, 77);


n.sendBundle(0.2, ["/good/news", 1, 1.3, 77]);

r.free;
n.disconnect;

// note that different NetAddr objects with the same port and ip are independent.

r = OSCFunc({ "message arrived".postln }, '/x');

n = NetAddr("127.0.0.1", 57120);
n.sendMsg("/x")


u = NetAddr("127.0.0.1", 57120);
u.sendMsg("/x");

n.disconnect

u.sendMsg("/x");

r.free;
u.disconnect;
::




class::Nil
categories::Core
summary::Represents uninitialized data

description::

Nil has a single instance named nil and is used to represent uninitialized data,
bad values, or terminal values such as end-of-stream.

note::
Take note that Nil is a class and not the special value code::nil::. Comparing Nil and code::nil:: will return false.
In normal use you should not need to use this class directly: use code::nil::

code::
Nil.isNil; // false
Nil == nil; // false
Nil === nil; // false
::
::

instancemethods::

private::do, reverseDo, pairsDo, collect, select, reject, detect, collectAs, selectAs, rejectAs, pop, source, source_, changed, 	addDependant, removeDependant, release, update, swapThisGroup, performMsg, remove, seconds_, throw, superclassesDo, !?, play, printOn, storeOn, archiveAsCompileString, set, addDependant


method::isNil
Answers true because this is nil. In class link::Classes/Object:: this message is defined to answer false.
code::
[1, 2, nil, 3].collect(_.isNil);
::

method::notNil
Answer false. In class link::Classes/Object:: this message answers true.
code::
[1, 2, nil, 3].collect(_.notNil);
::

method::?
return first non-nil argument. Since this IS nil then return anObject.
In class link::Classes/Object::, ? is defined to answer the receiver.
code::
[1, 2, nil, 3].collect { |x| x ? -1 }; // replace nil by -1
::

method::??
If the receiver is nil, evaluate the function and return the result.  Since this IS nil, then evaluate the function and return the result. In class link::Classes/Object::, ?? is defined to answer the receiver.

code::
[nil, 2, nil, 3].collect { |x| x ?? { 100.rand } }; // replace nil by a random number
::

method::booleanValue
Returns false.
code::
[1, 2, nil, 3].collect(_.booleanValue);
// compare:
[true, false, false, true].collect(_.binaryValue);
::

method::rate
Returns nil.

method::numChannels
Returns nil.

method::isPlaying
Returns false.

method::dependants
Returns an empty IdentitySet.

method::awake
Returns nil.

method::nextTimeOnGrid
Returns clock.nextTimeOnGrid.

method::asQuant
Returns Quant.default.

method::matchItem
Returns true.

See also link::Reference/matchItem::.


code::
[3, 2, 1].select(nil.matchItem(_))); // returns all
// compare:
[3, 2, 1].select([1, -1, 2].matchItem(_))); // returns only those in the key collection
::


method::asCollection
Returns empty array.

method::get
Returns prevVal.


method::asSpec
Returns the default ControlSpec

method::handleError
Either report error or inspect error and halt execution.

method::push
Executes function.

method::appendStream
Returns stream.

subsection::Dependancy

All the messages for the Dependancy protocol (See class link::Classes/Object::) are defined in class Nil
to do nothing. This eliminates the need to check for nil when sending dependancy messages.

subsection::Other Methods

Many other messages are defined in class Nil to do nothing. This eliminates the need to check for nil.

subsection::Generic Collectors

There are a number of methods that can be applied to nil so that variables do not need to be initialized. Nil is just the "ground" (default case) from which the rest is bootstrapped.

method::add
Returns an array with the value. This makes it unnecessary to initialize when adding to a variable.
code::
x = nil;
x = x.add(8);  // returns an array
x = x.add(7); // appends to the array
::

method::addAll
Returns an array with all the values. This makes it unnecessary to initialize when adding to a variable.
code::
x = nil;
x = x.addAll([0, 2, 1, 2]);  // returns an array
x = x.addAll(7); // single objects are converted
::

method::remove
For nil, it just returns nil. This makes it unnecessary to initialize when removing from a variable and adding to it again.
code::
x = nil;
x.remove(1); // stays nil, returns nil
x = x.addAll([0, 2, 1, 2]);  // returns an array
x.remove(1); // returns 1
x;
::

method::++
Returns an array with all the values. This makes it unnecessary to initialize when adding to a variable.
code::
x = nil;
x = x ++ [7, 8, 9]; // returns the receiver
x = x ++ [3, 0, 1, 2]; // adds to the array
::

method::addFunc
Returns a function or a FunctionList.
This method is used to add multiple functions to already existing ones.
code::
f = nil;
f = f.addFunc { "----------****".scramble };
f = f.addFunc { 1.0.rand };
f.value;
::

method::removeFunc
This method is used to remove multiple functions from already existing ones. For Nil, it just returns itself.

code::
f = { 1.0.rand };
g = { "you have produced a random value".postln };
f = f.addFunc(g);
f.value;
f.removeFunc(g);
f.value;
::


method::transformEvent
This method is used to operate on events which are passed through the system as an argument.

code::
// for Nil: return the argument unmodified (an event).
nil.transformEvent((x: 8));
// for Dictionary (and thus for Event): add to the argument.
(y: 100, z: 1).transformEvent((x: 8));
// for Association: add the association to the event
(\a -> \x).transformEvent((x: 8));
// for Function: use the function receive the event as argument.
{ |event| event.use { ~x = ~x + 1 }; event }.transformEvent((x: 8));
::


class:: Node
summary:: Abstract superclass of Synth and Group
related:: Reference/Server-Architecture, Classes/Synth, Classes/Group, Classes/RootNode
categories:: Server>Nodes, Server>Abstractions

Description::
This class is the abstract super class of Synth and Group, which represent synth and group nodes on the server.  Node objects are not made explicitly, but Synth and Group are subclasses, and inherit the methods  documented below.

subsection:: Freed Nodes and Node Status

Nodes which you explicitly free using the methods free or release will have their group instance variable set to nil. However Nodes which are automatically freed after a certain time (for instance by an link::Classes/EnvGen:: with a doneAction of 2) will not.
This keeps the implementation of the classes simple and lightweight.

To have the current state of a Node tracked you can register it with an instance of link::Classes/NodeWatcher::, either by calling register on the Node instance or on the NodeWatcher singleton. This will enable two variables, isPlaying and isRunning, which you can use for checking purposes.

subsection:: Bundling

Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

classmethods::
private:: initClass

method:: addActions
Returns:: the list of addActions as an event.
discussion::
Useful for converting addAction symbols to their corresponding integer codes.
code::
(
Node.addActions.at(\addToTail)
);
// returns 1
::

instancemethods::

subsection:: Instance Variables

The following getter methods also have corresponding setters, but they should be used with extreme care and only if you are sure you know what you're doing.

method:: nodeID
Returns:: the Node's node ID number.
discussion::
Normally you should not need to access this since instances of Node can be passed directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

method:: group
Returns:: an instance of Group or RootNode corresponding to this Node's group on the server.

method:: server
Returns:: an instance of Server corresponding to this Node's server app.

method:: isPlaying
Returns:: a boolean indicating if this node is currently on the server, providing this Node has been registered with a link::Classes/NodeWatcher::.
discussion::
N.B. If this Node has not been registered this will likely be false in any case.

method:: isRunning
Returns:: a boolean indicating if this node is currently on the server, providing this Node has been registered with a link::Classes/NodeWatcher::.
discussion::
N.B. If this Node has not been registered this will likely be false in any case.

subsection:: Node Commands

See the Node Commands section in link::Reference/Server-Command-Reference:: for the OSC equivalents of the methods outlined below.

method:: free, freeMsg
Stop this Node and free it from its parent group on the server. Once a Node has been freed, you cannot restart it.
argument:: sendFlag
a boolean indicating whether the free message should be sent. If false an n_free message will not be sent to this Node's server, but its isPlaying and isRunning variables will be set to false. The default for sendFlag is true.
discussion::
If this Node is a link::Classes/Group:: this will free all Nodes within the Group.
code::
s.boot;
x = Synth("default");
x.free;
::

method:: run, runMsg
Set the running state of this Node according to a boolean. False will pause the node without freeing it. The default is true.
discussion::
If this Node is a Group this will set the running state of all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-set", { |freq = 440, out = 0|
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).play
)
x.run(false);
x.run; // default is true
x.free;
::

method:: set, setMsg
Set controls in this Node to values.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in pairs with values. If this Node is a Group this will set all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-set", { |freq = 440, out = 0|
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).play
)
x.set(\freq, 880, \out, 1); // two pairs
x.set(0, 660, 1, 0); // freq is the first argument, so it's index is 0. out is index 1.
x.free;
::
Values that are arrays are sent using the OSC array type-tags ($[ and $]).  These values will be assigned to subsequent controls in the manner of setn.
code::
s.boot;
(
x = SynthDef("help-node-set", { |freq = #[440, 450, 460], out = 0|
	Out.ar(out, Mix(SinOsc.ar(freq, 0, 0.1)))
}).play
)
x.set(\freq, [1,2,3] * 400 + [1, 2, 3], \out, 1); // two pairs
x.set(\freq, [3] * 400 + [1, 2, 3], \out, 1); // two pairs
x.set(0, [660, 680, 720], 1, 0); // freq is the first argument, so it's index is 0. out is index 1.
x.free;
::

method:: setn, setnMsg
Set sequential ranges of controls in this Node to values.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in pairs with arrays of values. If this Node is a Group this will setn all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-setn", {
	arg out, freq1 = 440, freq2 = 440, freq3 = 440, amp1 = 0.05, amp2 = 0.05, amp3 = 0.05;
	Out.ar(out, Mix(SinOsc.ar([freq1, freq2, freq3], 0, [amp1, amp2, amp3])))
}).play;
)
// set 3 controls starting from \freq1, and 3 controls starting from \amp1
x.setn(\freq1, [440, 880, 441], \amp1, [0.3, 0.1, 0.3]);
x.free;
::

method:: fill, fillMsg
Set sequential ranges of controls in this Node to a single value.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in groups of three along with an integer indicating the number of controls to set, and the value to set them to. If this Node is a Group this will fill all Nodes within the Group.

method:: map, mapMsg
Map controls in this Node to read from control or audio rate link::Classes/Bus::es.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control:: or its subclasses. They are specified here using symbols, strings, or indices, and are listed in pairs with Bus objects. The number of sequential controls mapped corresponds to the Bus' number of channels.

If this Node is a Group this will map all Nodes within the Group.

Note that with mapMsg if you mix audio and control rate busses you will get an Array of two messages rather than a single message. Integer bus indices are assumed to refer to control buses. To map a control to an audio bus, you must use a Bus object.
code::
s.boot;
(
b = Bus.control(s, 1); b.set(880);
c = Bus.control(s, 1);	c.set(884);
x = SynthDef("help-Node-map", { |out, freq1 = 440, freq2 = 440|
	Out.ar(out, SinOsc.ar([freq1, freq2], 0, 0.1));
}).play
)
x.map(\freq1, b, \freq2, c);
x.free; b.free; c.free;

// same as above with a multichannel Bus and Control
(
b = Bus.control(s, 2);
b.set(880, 884);
x = SynthDef("help-Node-map2", { |out, freqs = #[440, 440]|
	Out.ar(out, SinOsc.ar(freqs, 0, 0.1));
}).play
)

x.map(\freqs, b);
x.free; b.free;
::

method:: mapn, mapnMsg
Map sequential ranges of controls in this Node to read from control rate Buses.
discussion::
This is similar to map above, but you specify the number of sequential Controls to map. If this Node is a Group this will mapn all Nodes within the Group.

method:: release, releaseMsg
This method causes the receiver to be freed after the specified amount of time. This is a convenience method which assumes that the synth contains an envelope generator (an EnvGen, Linen, or similar UGen) running a sustaining envelope (see link::Classes/Env#Sustained Envelope Creation Methods::) and that this envelope's gate argument is set to a control called code::\gate::.
argument:: releaseTime
The amount of time in seconds during which the node will release. If set to a value code::<= 0::, the synth will release immediately. A code::nil:: value will cause the synth to release using its envelope's normal release stage(s).

note::
Providing a releaseTime != nil doesn't trigger a normal release, but a different behavior called forced release. This difference is particularly important for envelopes with a multi-node release stage, i.e. whose releaseNode is not their last node. See link::Classes/EnvGen#Forced release#::.
::

discussion::
If the receiver is a Group, all nodes within the group will be released.
code::
x = { arg gate=1; BrownNoise.ar(0.5) * EnvGen.kr(Env.cutoff(1), gate, doneAction: Done.freeSelf) }.play;
x.release(5); // override the Env's specified 1 second release time
::
method:: query
Sends an n_query message to the server, which will reply with a message containing information about this node and its place in the server's node tree.
argument:: action
An optional Function to be called. If the node is a code::Synth::, the function will take the arguments code::serverCmd, nodeID, parent, prev, next, isGroup::. If the node is a code::Group::, the function will take the arguments code::serverCmd, nodeID, parent, prev, next, isGroup, head, tail::. Providing a function here will bypass code::query::'s normal behaviour, i.e., the usual node information will not be posted.
discussion::
This information will be printed to the post window. (See also the queryAllNodes method of Server.) "parent" indicates the Node's enclosing group. If "prev" or "next" are equal to -1 that indicates that there are no other nodes in the enclosing group before or after this one, respectively.
code::
g = Group.new;
x = Synth.head(g, "default");
x.query;
g.query;
s.queryAllNodes; // Note the RootNode (ID 0) and the default Group (ID 1)
x.free; g.free;
::

method:: trace
Causes a synth to print out the values of the inputs and outputs of its unit generators for one control period to the post window. Causes a group to print the node IDs and names of each node in the group for one control period.
code::
g = Group.new;
x = Synth.head(g, \default);
x.trace;
g.trace;
x.free; g.free;
::

method:: register
Registers the node at the link::Classes/NodeWatcher:: object.
discussion::
This will enable two variables, isPlaying and isRunning, which you can use for checking purposes.
code::
(
b = s.makeBundle(false, {
	a = Group.new(s); //create a node object
	a.register // register before creating on the server
})
)

a.isPlaying;
s.listSendBundle(nil, b); //start the node on the server
a.isPlaying;
a.isRunning;
a.run(false);
a.isRunning;
s.freeAll; //free all nodes
a.isPlaying;
a.isRunning;
::

subsection:: Changing the order of execution

The following methods can be used to change the Node's place in the order of execution. See the link::Guides/Order-of-execution:: help file for more information on this important topic. See link::Reference/Server-Command-Reference:: for the OSC equivalents of these methods.

method:: moveAfter, moveAfterMsg
Move this Node to be directly after aNode. N.B. n_after, the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a NodeWatcher.

method:: moveBefore, moveBeforeMsg
Move this Node to be directly before aNode. N.B. n_before, the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a NodeWatcher.

method:: moveToHead, moveToHeadMsg
If aGroup is a Group then this method will move this Node to the head of that Group. If it is nil this will move this Node to the head of the default_group of this Node's Server.

method:: moveToTail, moveToTailMsg
If aGroup is a Group then this method will move this Node to the tail of that Group. If it is nil this will move this Node to the tail of the default_group of this Node's Server.

subsection:: Other Methods

method:: asTarget
Returns:: this Node. See the link::Reference/asTarget:: help file for more details.

method:: printOn
Prints this Node's link::Classes/Class:: (link::Classes/Synth:: or link::Classes/Group::) and nodeID on stream.

method:: hash
Returns:: server.hash bitXor: nodeID.hash

method:: ==
Returns:: true if this Node and aNode have the same nodeID and the same Server object, otherwise returns false.
discussion::
Under certain circumstances this Node and aNode might not be the same object, even though this returns true.
code::
g = Group.basicNew(s, 1); // the default group of s
h = Group.basicNew(s, 1); // and again
g == h; 	// true
g === h;	// false
::

method:: onFree
Evaluate function when this Node is freed.
discussion::
code::
{PinkNoise.ar(1) * Line.kr(1,0,2,doneAction: Done.freeSelf)}.play.onFree {"done".postln};
::

method:: waitForFree
Wait until this Node is freed. Should be used inside a Routine or similar.
discussion::
code::
(
fork {
    { SinOsc.ar(440 ! 2) * Line.kr(0, 1, 5, doneAction: Done.freeSelf) }.play.waitForFree;
    { PinkNoise.ar(1) * Line.kr(1, 0, 2, doneAction: Done.freeSelf) }.play.onFree {"done".postln};
}
)
::

code::
(
SynthDef(\help, { |out|
	var mod = LFNoise2.kr(Rand(1, 6)) * 0.2;
	var snd = mod * Blip.ar(Rand(200, 800) * (mod + 1));
	Out.ar(out, snd);
	FreeSelf.kr(mod < 0);
}).add;
)

(
fork {
	10.do {
		"started a synth".postln;
		Synth(\help).waitForFree;
		"This one ended. Wait a second, I will start the next one.".postln;
		1.wait;
	};
	"This is it.".postln;
}
);
::


class:: NodeControl
summary:: Encapsulates in an object a node and an index.
categories:: Server>Nodes

description::
This object can be held by a client and have its value set without otherwise having to store the details about where the node's input is.

classmethods::
method:: new
argument:: node
The node to encapsulate
argument:: index
The index to encapsulate

instancemethods::
method:: value
set the value


examples::
code::
d = SynthDef("help-NodeControl",{ arg out=0,freq=400;
	Out.ar(out,
		 SinOsc.ar(freq, 0, 0.5)
	)
});
y = d.play; // the synth

c = NodeControl(y,1);

c.value = 500;

c.value = 300;
::



class:: NodeMap
summary:: store control values and bus mappings
categories:: JITLib>NodeProxy, Server>Nodes, Server>Abstractions
related:: Classes/Bus

description::
Object to store control values and bus mappings independently of a specific node.

code::
a = NodeMap.new;
a.set(\freq, [446, 662], \amp, 0.2, \out, Bus.audio(s));
a.asOSCArgArray;
::

InstanceMethods::

method::set
set arguments of a node

method::unset
remove settings

method::unmap
remove mappings

method::at
return setting at that key.

method::sendToNode
apply a setting to a node by sending a bundle

method::send
apply a setting to a node by sending a bundle

method::addToBundle
add all my messages to the bundle

method::addToEvent
add all my values to the event

method::asOSCArgArray
returns the arguments for an OSC message.

method::unmapArgsToBundle
returns the arguments for an OSC message to unmap any mapped controls.

method::setMsg
returns the OSC message for setting a synth
argument:: target
a group, synth, or server to use as a nodeID to set.

method::get
Kept for backward compatibility.

method::clear
Remove all settings and clear cache


private::updateArgs, upToDate

Examples::

code::

s.boot;

(
SynthDef("modsine",
	{ | out, freq=320, amp=0.2 |
		Out.ar(out, SinOsc.ar(freq, 0, amp));
	}).add;
SynthDef("lfo",
	{ | out, rate=2 |
		Out.kr(out, LFPulse.kr(rate, 0, 0.1, 0.2))
	}).add;
)

// start nodes
(
b = Bus.control(s,1);
x = Synth("modsine");
y = Synth.before(x, "lfo", [\out, b]);
)

// create some node maps
(
h = NodeMap.new;
h.set(\freq, 800);
h.map(\amp, b);

k = NodeMap.new;
k.set(\freq, 400);
k.unmap(\amp);
)

//apply the maps

h.sendToNode(x); // the first time a new bundle is made
k.sendToNode(x);

h.sendToNode(x); // the second time the cache is used
k.sendToNode(x);

h.set(\freq, 600);

h.sendToNode(x); // when a value was changed, a new bundle is made

//free all
x.free; b.free; y.free;
::


class:: NodeProxy
summary:: a reference on a server
categories:: JITLib>NodeProxy, Live Coding
related:: Classes/ProxySpace

description::
Generally a strong::proxy:: is a placeholder for something. A node proxy is a placeholder strong::for something playing on a server:: and writes to a limited number of busses (usually a synth, but also an event stream that makes synths). NodeProxy objects can be replaced and recombined while they play. Also they can be used to build a larger structure which is used and modified later on. Overview: link::Overviews/JITLib::.

NodeProxy is used internally in link::Classes/ProxySpace:: and it is a superclass of link::Classes/Ndef::, allowing to easily access and combine a large number of placeholders.

Graphical editor for a node proxy: link::Classes/NdefGui::.

note::
NodeProxy plays on a emphasis::private bus::. If you want to strong::hear:: the output, use link::#-play:: and link::#-stop::. To free inner players and stop listen: link::#-end::. Entirely removing all inner settings: link::#-clear::
::

subsection::Further reading

list::
## link::Tutorials/JITLib/the_lazy_proxy::
## link::Tutorials/JITLib/jitlib_efficiency::
## link::Tutorials/JITLib/jitlib_fading::
## link::Tutorials/JITLib/jitlib_asCompileString::
## link::Reference/NodeProxy_roles::
::

subsection::First Example

code::
s.boot;

a = NodeProxy.new.play; // play to hardware output.
a.fadeTime = 2; // fadeTime specifies crossfade
// set the source
a.source = { SinOsc.ar([350, 351.3], 0, 0.2) };
a.source = { Pulse.ar([350, 351.3] / 4, 0.4) * 0.2 };
a.source = Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350));

b = NodeProxy.new;
a.source = { Ringz.ar(b.ar, [350, 351.3] * 8, 0.2) * 4 };
b.source = { Impulse.ar([5, 7]/2, [0, 0.5]) };

a.clear(3); // clear after 3 seconds
b.clear(3);
::

ClassMethods::

subsection::Creation

method::new
Return a new instance of NodeProxy.

code::
// new node proxy
a = NodeProxy(s, \audio, 4);
a.numChannels;
a.clear; // remove bus.
a.numChannels; // nil.
::

argument::server
The server on which to run and where the bus is allocated (default: code::Server.default::)

argument::rate
If given, proxy is initialized to this rate

argument::numChannels
If given, proxy is initialized to this number of channels

argument::inputs
If given, proxy is initialized with the given inputs as objects on subsequent slots.

copymethod:: BusPlug *audio
copymethod:: BusPlug *control
copymethod:: BusPlug *for

subsection::Accessing Class Variables

copymethod:: BusPlug *defaultNumAudio
copymethod:: BusPlug *defaultNumControl

method::defaultFadeTime
The overlap time between successive source replacements which all instances have by default. Each instance has its own value which can be set via code::fadeTime_::.

private::buildProxy, buildProxyControl, addChild, addNodeMapControlNames, asCode, cleanNodeMap, getBundle, getFamily, getStructure, internalKeys, loadToBundle, moveBeforeMsg, prepareOtherObjects, prepareToBundle, putNewObject, reallocBusIfNeeded, rebuildDeepToBundle, rebuildToBundle, removeToBundle, sendAllToBundle, sendEachToBundle, sendObjectToBundle, serverQuit, shouldAddObject, stopAllToBundle, supplementNodeMap, typeStr, unsetToBundle, wakeUpParentsToBundle, wakeUpToBundle

InstanceMethods::

private::prFadeTime, linkNodeMap, generateUniqueName, prepareOutput, addToChild

subsection::Listening to the output

copymethod:: BusPlug -play

copymethod:: BusPlug -playN

copymethod:: BusPlug -stop

method::end
releases the synths and stops playback.

argument::fadeTime
cross fade time for this action.

argument::reset
if set to true, reset all monitor state. Otherwise, the previous play arguments are kept.


subsection::Embedding and Combining the proxy

copymethod:: BusPlug -ar, kr


method::<--
Usage: strong::proxyA <-- proxyB::.  Set proxyA source to proxyB and play proxyA. If proxyB was playing, fade it out. This is convenient in the following situation:

code::
b = NodeProxy.new.play;
b.source = { PinkNoise.ar(0.2.dup) };
// now I want to filter b through a new proxy.
a = NodeProxy.new;
a <-- b; a.source = { HPF.ar(b.ar, 7000) };
a.source = { HPF.ar(b.ar, 3000) };// changing the source
a.clear; b.clear;
::

method::<<>
Chaining. Usage: strong::proxyA <<> proxyB	<<> proxyC <<> ...:: . Map proxyC source to proxyB code::\in:: argument, and proxyB to proxyA's in argument.

code::
a = NodeProxy.new.play;
a.source = { RLPF.ar(\in.ar(0!2), [4600, 7000], 0.1) };
b = NodeProxy.new.source_ { Impulse.ar([5, 7] / 2) };
a <<> b;
::

method::<>>
Inverse of the above. Usage: strong::proxyA <>> proxyB	<>> proxyC <>> ...:: .


subsection::Setting the source

NodeProxy keeps a number of slots which can be sources and are mixed on the same bus.. The default source is the slot 0. All objects can be exchanged while running, and also before and after. Normally, the source is active immediately. If sources are to be exchanged "quietly", set the node proxy to sleep (awake = false), or use the message prime().

See the list under section link::#Supported sources::

method::source
Play a new synth through proxy and release/remove any old ones.
code::
a = NodeProxy(s);
a.play;
a.source = { Pulse.ar(130, Saw.kr(0.3)) * 0.1 }; // change this line while running
::

argument::obj
can be one of the supported inputs (see link::#Supported sources::)

note::
When reshaping is set, e.g. to \elastic, setting the source can change the number of channels of the proxy. This means that its bus changes, and that child proxies, which read signals from it, may also change. See the example in link::#Routing::.
::

subsection::Routing
Signals can be routed between any number of node proxies.

See also: link::Classes/BusPlug#-ar::, link::Classes/BusPlug#-value::, link::#Reshaping::.

Here is a simple example, using Ndef (NodeProxy works similarly):

code::
Ndef(\maus, { MouseX.kr });
Ndef(\haus, { Pan2.ar(Blip.ar(Ndef.kr(\maus, 1) * 70), SinOsc.kr(Ndef.ar(\maus, 1) * 5)) }).play;
::

note::
If you don't specify the number of channels, an expression like code::Ndef.kr(\maus):: will return an Array. Subsequently, e.g. by a code::Pan2:: UGen, you may get the message:

code::WARNING: Synth output should be a flat array.::

If you intend the output to be really mono, make it explicit by writing: code::Ndef.kr(\maus, 1)::
::

With elastic reshaping, you can use the parent to expand the child, if you omit the number of channels in the routing:

code::
Ndef(\maus, { MouseX.kr });
Ndef(\haus, { Blip.ar(Ndef.kr(\maus) * 70) }).play;
Ndef(\haus).reshaping = \elastic;
Ndef(\maus).reshaping = \elastic;
Ndef(\maus, { LFNoise0.kr(1 ! 8) + 1 }); // now 8 parallel channels of audio are audible.
::



subsection::Reserved parameters
Three parameters are automatically specified if they don't exist in a given UGen function. You can override their use: code::[\out, \gate, \fadeTime]::

subsection::Specifying your own envelope

If a UGen function that is passed to the proxy has its own envelope, and if this envelope can free the synth, the node proxy uses this envelope instead of making its own. If you provide a code::fadeTime:: argument, the proxy's fadeTime will be used.

code::
Ndef(\sound).fadeTime = 3;
(
Ndef(\sound, { |fadeTime = 1, gate = 1|
	var e = Env.adsr(fadeTime, 0.01, 0.4, fadeTime).ar(2, gate);
	SinOsc.ar(100 + (e * 700), SinOsc.ar(208) * (1 - e) * 6) * e * 0.1
}).play
)
::


subsection::Making copies

method::copy
copies the hidden internal state to make the new proxy independent of the old, but will keep the reference to the source object. The rendered SynthDef is cached, which makes this method more efficient than simply assigning the same function to a new proxy. By design, the monitor is copied, but is not running (use play to start it in the same configuration).

code::
a = NodeProxy(s);
a.source = { |freq = 444| Blip.ar(freq * [1, 1.03], 200) * 0.1 };
a.play;
a.set(\freq, 555);
b = a.copy;
b.play;
b.set(\freq, 222);
::

note::
If needed, you can also copy parts of a proxy, such as the link::Classes/Monitor:: (which usually routes the output back onto hardware busses) and the link::Classes/NodeMap::, which keeps a mapping and setting scope.
::

code::
s.scope(4);
a = NodeProxy(s);
a.source = { |freq = 234| Blip.ar(freq * [1, 1.03], 20) * 0.5 };
a.playN([0, 1, 3], [0.04, 0.3, 0.1], vol: 1); // some complicated routing
a.set(\freq, 123);

b = NodeProxy(s);
b.source = { |freq = 1000| SinOsc.ar(freq * 3 * {{ rrand(0.9, 1.1) }.dup(8) }.dup(2)).mean * 0.5 };
b.monitor = a.monitor.copy;
b.nodeMap = a.nodeMap.copy;
b.play;
a.stop;
::


method::copyState
Copy the internal settings of one proxy into another. Old state is cleared.

argument::proxy
The proxy whose internal state is copied.



subsection::Reshaping

method::reshaping
Determines how to behave when a new source is added.
Current options:

table::
## nil || Once initialized, keep the same bus - this is the default
## \elastic || On a change, shrink and grow according to need, replace bus. The monitor and child proxies are adjusted.
## \expanding || On a change, only grow according to need, replace bus. The monitor and child proxies are adjusted.
::

code::
a = NodeProxy(s);
a.reshaping = \elastic;
a.play(0, 2); // play stereo
a.source = { BPF.ar(Dust.ar(8 ! 8), (0..5).nthPrime * 300, 0.01) * 20 };
a.numChannels; // 8
::

method::mold
Adjust the proxy to a given rate / numChannels. If there are any child proxies that have elastic link::#-reshaping::, they are adjusted accordingly.

code::
a = NodeProxy(s);
a.play;
a.source = { BPF.ar(Impulse.ar({ rrand(1.0, 2.0) } ! a.numChannels), (0..5).nthPrime * 300, 0.01) * 20 };
a.numChannels; // 2
a.mold(8);
a.numChannels; // 8
::

subsection::Other ways to set or change the sources

method::prime
Set source without starting the synth. To start it, link::#-send:: can be used later. Running synths are released and proxy is initialized if still neutral.

method::add
Add a new source to the present ones

method::removeAt
Remove the object at index i and its synths, if they exist. If no index is supplied, remove them all.

method::removeLast
Remove the last object and its synths, if they exist.


method::put
Set the source by index. Objects can be inserted at any index, only the order of indices is relevant. Internally, NodeProxy uses an link::Classes/Order:: to access the sources.

argument::index
where the object should be placed in the internal order. if code::-1::, all objects are freed

argument::obj
A valid source (see link::#Supported sources::).

argument::channelOffset
using a multichannel setup it can be useful to set this, when the objects numChannels is smaller than the proxy

argument::extraArgs
Arguments that can be sent with the object directly (not cached)

argument::now
if set to false, only prepare the source and do not start the object (see link::#-prime::)

code::
// put can be used with the array indexing syntax:
a = NodeProxy.new.play;
a[0] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a[2] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a.sources.do(_.postcs);
// using multiple index expands into multiple objects
a[0..5] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a.sources.do(_.postcs);
a.send; // exchange synths, using the sources as definitions
a.clear;
::

subsection::Controlling the running processes

method::pause
Pause all objects and set proxy to paused

method::resume
If paused, start all objects

method::rebuild
Rebuild all SynthDefs from sources.

method::orderNodes
Arrange the order of groups from this to the last. This can be important when external input is filtered in order to strong::minimize latency::. Note that if a link::#-parentGroup:: was provided, the nodes must be in the same parentGroup.


subsection::Release and cleaning up

method::free
Release all running synths and the group. If patterns are playing, stop them.

argument::fadeTime
decay time for this action

argument::freeGroup
a boolean

method::release
release running synths. If patterns are playing, stop them.

argument::fadeTime
decay time for this action

method::clear
reset everything to nil, neutralizes rate/numChannels

argument::fadeTime
if a fadeTime is given, first fade out, then clear.

method::schedAfterFade

Calls a function after the fadeTime and server latency have passed. If the proxy specifies a code::quant:: value, the function is evaluated code::fadeTime + latency:: seconds after the next timepoint on the quant grid; otherwise, the fade delay begins immediately.

argument::func
a function to be called at the appropriate time


subsection::Accessing Instance Variables

method::sources
Returns an array of all sources

method::source
Returns the first source.

method::server
The node proxy's server (a link::Classes/Server::).

method::bus
The node proxy's private bus (a link::Classes/Bus::). Because it has a private bus, it is not audible directly - monitoring it by (.play or playN) routes it to the hardware output channels.

method::rate
The bus rate (default: nil) The rate and number of channels is determined either when the instance is created (.control/.audio) or by lazy initialisation from the first source (see link::Tutorials/JITLib/the_lazy_proxy::)

method::numChannels
The bus numChannels (default: nil)

method::isNeutral
true if the proxy has no initialized bus.

method::group
The node proxy's group (a link::Classes/Group::). This is maintained by the proxy and serves as a context in which all synths are placed.

method::parentGroup
Access the parentGroup (default: nil), which can be set to run the proxy's group in another group. This group has to be maintained (kept playing etc.) externally.

method::clock
A clock, which can be set to account for different timing schemes, such as beat accurate replacement of sources.

method::quant
A quant value, to specify quantizes replacement of sources. Compatible with the general use of quant in SuperCollider.

method::quantize
Synchronize the proxies by resending and adjusting to quant.

method::monitor
Access the link::Classes/Monitor:: object, which plays back the output of the proxy's private bus.

method::loaded
Returns true if the object has been initialized on the server, e.g. a synthDef has been stored.

method::paused
Returns true if the processes are paused.

method::awake
If set to false (default: true), a change of the source does not start a new synth immediately. This is useful when synths are triggered by link::#-spawn::, and a change of sound should not duplicate sends.

method::fadeTime
set the crossfade time. See: link::Tutorials/JITLib/jitlib_fading:: .

subsection::Setting synth controls

method::set, map, setn
NodeProxy behaves like its link::Classes/NodeMap:: and very similar to a link::Classes/Synth::.

note::Now the methods map, setn, mapn, and xmap are there just for backward compatibility reasons. Everything is done by set.::

code::
a = NodeProxy(s); a.play;
a.source = { Splay.ar(Blip.ar(\freq.kr(18 ! 4))) * 0.2 };
a.set(\freq, [1, 3, 56, 13]);
a.source = { Splay.ar(SinOsc.ar(LFSaw.ar(\freq.kr(18 ! 4)) * 250 + 400)) * 0.2 };
b = NodeProxy(s); b.source = { MouseX.kr(0, 3) *  [1, 3, 56, 13] };
a.set(\freq, b);
a.clear; b.clear;
::

argument::... args

An array of pairs: strong::key, value, key, value, ...::

The unique key (a link::Classes/Symbol::) specifies the control name to be set.

For value anything can be specified that responds to "asControlInput", in particular:
definitionList::
## number || set the control to that number
## array of numbers || set the subsequent control channels to the corresponding value
## node proxy || map subsequent control channels to the corresponding proxy output channel
::

method:: seti
Set part of an arrayed control, analog to link::Classes/Synth#-seti::.
argument:: ... args
A sequence of strong:: name, index, value :: triplets.

definitionlist::
## name || The name of the arrayed control
## index || The index into the array
## value || The new value to set, can be an array to set a range of elements.
::

Discussion::
code::
// 5 channel NodeProxy, for convenience initialized in an Ndef
(
Ndef(\sin).mold(5, \audio, \elastic);
Ndef(\sin)[0] = {
	SinOsc.ar(
		\freq.kr([200, 201, 202, 204, 205]),
		SinOsc.kr(\phase.kr([0, 0, 0, 0, 0])).range(0, 2pi)
	)
}
)

// out mixer: mix down to 2 channels and spread channels across panorama
(
Ndef(\out).mold(2, \audio, \elastic);
Ndef(\out)[0] = {
	// 5 channel input
	Splay.ar(\in.ar(0!5), level: \amp.kr(0.3))
}
)

// route Ndef(\sin) through Ndef(\out)
(
Ndef(\out) <<> Ndef(\sin);
Ndef(\out).play;
)

// change frequency and phase in 4th channel
Ndef(\sin).seti(\freq, 3, 137, \phase, 1, 11)

// 1st channel 310hz, 3rd 207hz
Ndef(\sin).seti(\freq, [0, 2], [310, 207])

// exceeding indices, argument arrays of different length
// 34 % 5 => 4, 12 % 5 => 2, 56 % 5 => 1
Ndef(\sin).seti(\freq, [34, 12, 56], [376, 199])
Ndef(\sin).getKeysValues // -> [ [ freq, [ 310, 376, 199, 137, 376 ] ] ]

Ndef.clear(10)
::

method::unset, unmap
Remove specified settings and unmap or unset the synths.

method::xset
set/map with a crossfade into the new setting. The crossfade time is the NodeProxy link::#-fadeTime::.

method::lag
set the lag values of these args (identical to link::#-setRates::). To remove these settings, use: code::lag(\key1, nil, key2, nil, ...)::

method::setRates
set the default rate (\tr, \ir, numerical) for synthDef arg. A rate of nil removes setting.

method::controlNames
Returns the link::Classes/ControlName:: objects of all slots, strong::except:: the names of this list (default: code::[\out, \i_out, \gate, \fadeTime]:: , which are used internally). When the node proxy received a code::set:: for a given key, the code::defaultValue:: of the corresponding code::ControlName:: contains the object that was passed, which might be any object whatsoever.

method::controlKeys
Returns the keys (symbols) of all control names objects of all slots, strong::except:: the names of this list. (default: none).

argument::except
list of names

argument::noInternalKeys
If noInternalKeys is true (default: true), it ignores the keys code::[\out, \i_out, \gate, \fadeTime]:: .

method::getKeysValues
Get all key value pairs from both link::Classes/NodeMap:: (the settings) and default arguments.

method::controlKeysValues
Get all key value pairs from default arguments.

method::findControlName
Search the source objects for a given control name symbol and return the link::Classes/ControlName::.

method::specs
Get the specs array from SynthDef metadata. Note that, for a NodeProxy with multiple sources, result will be a dictionary containing specs of ALL source SynthDefs.
code::
~p = NodeProxy.audio(Server.default, 2);
~p.put(0, { SinOsc.ar(\freq.kr(100, spec:[50, 400])) });
~p.put(1, { WhiteNoise.ar(\noiseAmp.kr(0.1, spec:[0, 1])) });
~p.specs.postln;
::

subsection::Sending synths to server explicitly

Normally, processes (usually synths) are started when their respective source is added to the proxy. The processes can also be restarted, however, or the proxy can be used while asleep and the processes can then be started explicitly.

method::send
Send a new synth without releasing the old one. If the source is a stream or a pattern, it starts a new one.

argument::extraArgs
Arguments used to set the synth. The argument list is applied to the synth only. Arguments specified here override settings in the node map, but leave them untouched.

argument::index
What slot to send a new synth with. If nil, uses all. (default: nil)

argument::freeLast
if to free the last synth at that index or not (default: true)

method::sendAll
Send all synths, or restart all objects.

argument::extraArgs
Arguments used to set the synth. the argument list is applied to the synth only.

argument::freeLast
if to free the last synth at that index or not (default: true)

method::sendEach
Like send, just iterating separately over the objects.

method::wakeUp
Until the proxy is not used by any output ( either .play or .ar/.kr ) it is not running on the server. you can wake it up to force it playing. Normally this is not needed.

subsection::Storing as code
method::asCode
stores the proxy as executable code.
see also link::Tutorials/JITLib/jitlib_asCompileString:: for more examples.

code::
// Ndef
Ndef(\a, { Saw.ar(12) }).asCode;

// in a pushed proxy space
p = ProxySpace.push(s.boot);
~x = { Saw.ar(123, 0.1) };
~x.play;
~x.asCode;

p.end.pop;

// anonymous nodeproxy also posts instructions:
x = NodeProxy.new.source = { DC.ar };
x.asCode;

x.free;
::

subsection::GUI

method::edit
Returns a new instance of link::Classes/NodeProxyEditor:: for this proxy.

code::
a = NodeProxy.new;
a.edit;

(
a.source = { |freq = 440, rate = 2|
	SinOsc.ar(freq * [1, 1.625]) * SinOsc.kr(rate).max(0) * 0.2
}
);
::

section::Supported sources

definitionList::
## link::Classes/NodeProxy:: || played by reading from the other NodeProxy bus.
## link::Classes/Function:: || interpreted as ugen function, and plays a link::Classes/Synth::, similar to Function.play.
## link::Classes/SimpleNumber:: || write this value to the bus continuously, overwriting previous bus value.
## link::Classes/Array:: of numbers || write the values to the bus continuously overwriting previous bus value.
## link::Classes/Bus:: || read the signal on the bus.
## link::Classes/SynthDef:: || plays a link::Classes/Synth:: using the SynthDef.
## link::Classes/Symbol:: || plays a link::Classes/Synth:: from the SynthDef with this name.
## link::Classes/Pattern:: || played as event pattern (using link::Classes/Pbind:: or other event patterns).
## link::Classes/Stream:: || played as event stream (a stream returning events).
## nil || link::Classes/Nil:: removes all objects.
## link::Classes/Pdef::, link::Classes/EventPatternProxy:: || played like a stream.
## link::Classes/Task:: || played, no output is assigned.
## link::Classes/Tdef:: || played like Task
## link::Classes/Event:: || played like in a pattern.

## Associations (link::Reference/NodeProxy_roles::): ||
definitionList::
## (\filter -> func) || filter previous input (with post control)
## (\filterIn -> func) || filter previous input (with pre control)
## (\set -> event pattern) || set controls with the event keys of the pattern
## (\setbus -> event pattern) || set bus with an event pattern. Bus value is the \value key of each event.
## (\setsrc -> event pattern) || set the source with an event pattern. source is the \source key of event.
## (\control -> array or number) || prepare an efficient way to set values by index
## (\mix -> func) || mix audio
::

## crucial library: ||
definitionList::
## AbstractPlayer || started in a separate bus, mapped to this bus
## Instr || converted to player and started
::
::

Definitions for other sources can be added - see: link::Reference/NodeProxy_roles::

Examples::

For more, see link::Classes/ProxySpace::

code::
///////////////////// using node proxy with ugen functions /////////////////////

s.boot;

a = NodeProxy.audio(s, 2);
a.play; // play to hardware output, return a group with synths

// setting the source
a.source = { SinOsc.ar([350, 351.3], 0, 0.2) };

// the proxy has two channels now:
a.numChannels.postln;
a.source = { SinOsc.ar([390, 286] * 1.2, 0, 0.2) };

// exceeding channels wrap:
a.source = { SinOsc.ar([390, 286, 400, 420, 300] * 1.2, 0, 0.2) };

// other inputs
a.source = { WhiteNoise.ar([0.01,0.01]) };
a.source = 0;
a.source = \default; // synthDef on server
a.source = SynthDef("w", { arg out=0; Out.ar(out,SinOsc.ar([Rand(430, 600), 600], 0, 0.2)) });
a.source = nil; // removes any object

// feedback
a.source = { SinOsc.ar(a.ar * 7000 * LFNoise1.kr(1, 0.3, 0.6) + 200, 0, 0.1) };
a.source = { SinOsc.ar(a.ar * 6000 * MouseX.kr(0, 2) + [100, 104], 0, 0.1) };

// fadeTime
a.fadeTime = 2.0;
a.source = { SinOsc.ar([390, 286] * ExpRand(1, 3), 0, 0.2) };


// adding nodes
a.add({ SinOsc.ar([50, 390]*1.25, 0, 0.1) });
a.add({ BrownNoise.ar([0.02,0.02]) });

// setting nodes at indices:
a[0] = { SinOsc.ar( 700 * LFNoise1.kr(1, 0.3, 0.6) + 200, 0, 0.1) };
a[1] = { LFPulse.kr(3, 0.3) * SinOsc.ar(500, 0, 0.1) };
a[2] = { LFPulse.kr(3.5, 0.3) * SinOsc.ar(600, 0, 0.1) };
a[3] = { SinOsc.ar([1,1.25] * 840, 0, 0.1) };

// filtering: the first argument is the previous bus content. more args can be used as usual.
a[3] = \filter -> { arg in; in * SinOsc.ar(Rand(100,1000)) };
a[2] = \filter -> { arg in; in * MouseY.kr(0,1) };
a[8] = \filter -> { arg in; in * MouseX.kr(0,1) };
a[4] = \filter -> { arg in; in * SinOsc.ar(ExpRand(1,5)).max(0) };



// setting controls
a.fadeTime = 2.0;
a.source = { arg f=400; SinOsc.ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) };
a.set(\f, rrand(900, 300));
a.set(\f, rrand(1500, 700));
a.xset(\f, rrand(1500, 700)); // crossfaded setting
a.source = { arg f=400; RLPF.ar(Pulse.ar(f * [1,1.02] * 0.05, 0.5, 0.2), f * 0.58, 0.2) };

// control lags
a.lag(\f, 0.5); // the objects are built again internally and sent to the server.
a.set(\f, rrand(1500, 700));
a.lag(\f, nil);
a.set(\f, rrand(1500, 700));

a.fadeTime = 1.0;

// mapping controls to other node proxies

c = NodeProxy.control(s, 2);
c.source = { SinOsc.kr([10,20] * 0.1, 0, 150, 1300) };
a.map(\f, c);
a[0] = { arg f=400; RHPF.ar(Pulse.ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) };
c.source = { SinOsc.kr([10,16] * 0.02, 0, 50, 700) };
c.source = { Line.kr(300, 1500, 10) + SinOsc.kr(20 * [1,2], 0, 100) };
a[1] = { arg f; LFPar.ar(f % MouseX.kr(1, 40, 1) * 4 + 360, 0, 0.2) };

// map multiple channels of one proxy to multiple controls of another
// recently changed behaviour!

a.source = { arg f=#[400, 400]; LPF.ar(Pulse.ar(f[0] * [0.4,1], 0.2, 0.2), f[1] * 3) };
a.map(\f, c); // multichannel proxy c is mapped to multichannel control of a
a.source = { arg f=#[400, 400]; LPF.ar(Pulse.ar(f, 0.2, 0.2), f[1]) };
a.source = { arg f=#[400, 400]; Formant.ar(140, f * 1.5, 100, 0.1) };
c.source = { SinOsc.kr([Line.kr(1, 30, 10), 1], 0, [100, 700], [300, 700]) };
c.source = 400;


c.fadeTime = 5.5;
c.source = { LFNoise0.kr([2.3, 1.0], [100, 700], [300, 1700]) };
c.source = { SinOsc.kr([2.3, 1.0], 0, [100, 700], [300, 1700]) };
c.source = 400;


// behave like a sc2 plug
c.gate(1400, 0.1);
c.gate(1000, 0.1);
c.line(1000, 1);

// direct access
a.lineAt(\f, 300, 2);
a.xlineAt(\f, 600, 0.3);
a.gateAt(\f, 1600, 0.3);


// changing nodeMaps
a.unmap(\f);
n = a.nodeMap.copy;
n.set(\f, 700);
a.fadeToMap(n);
n = a.nodeMap.copy;
n.set(\f, 400);
a.fadeTime = 1.0;
a.fadeToMap(n, [\f]); // linear interpolation to new map: experimental
a.map(\f, c); // restore mapping


// sending envelopes (up to 8 levels)
w = Env.new(Array.rand(3, 400, 1000),Array.rand(2, 0.3, 0.001), -4);
c.env(w);
c.env(w);
w = Env.new(Array.rand(8, 400, 1000),Array.rand(7, 0.03, 0.1));
c.env(w);
c.env(w);

// stop synthesis, then wake up proxies:

a.stop; // stop the monitor
a.play; // start the monitor
a.end;	// release the synths and stop the monitor
c.free;	// free the control proxy c
::

code::

///////////////////// channel offset/object index /////////////////////


a = NodeProxy.audio(s,2);
a.play;
a[0] = { Ringz.ar(Impulse.ar(5, 0, 0.1), 1260) };
a.put(1, { Ringz.ar(Impulse.ar(5.3, 0, 0.1), 420) }, 1);
a.put(0, { Ringz.ar(Dust.ar([1,1]*15.3, 0.1), 720) }, 1);
a.put(1, { Ringz.ar(Impulse.ar(5.3, 0, 0.1), 420) }, 1);
a.end;
::

code::

///////////////////// beat accurate playing /////////////////////




a = NodeProxy.audio(s,2);
a.play;

a.quant = 2.0; // quantize changes to the next 2.0-beat multiple
a.source = { Ringz.ar(Impulse.ar(0.5, 0, 0.3), 3000, 0.01) };
a[1] = { Ringz.ar(Impulse.ar([0.5, 1], 0, 0.3), 1000, 0.01) };
a[2] = { Ringz.ar(Impulse.ar([3, 5]/2, 0, 0.3), 8000, 0.01) };
a[3] = { Ringz.ar(Impulse.ar([3, 5]*16, 0, 0.3), 5000, 0.01) * LFPulse.kr(0.5, 0, 0.05) };

a.removeLast;
a.removeAt(2);

a.clear;
::

code::

///////////////////// using patterns - event streams /////////////////////


(
// must have 'out' or 'i_out' argument to work properly
SynthDef("who", { arg freq, gate=1, out=0, ffreq=800, amp=0.1;
	var env;
	env = Env.asr(0.01, amp, 0.5);
	Out.ar(out, Pan2.ar(
		Formant.ar(freq, ffreq, 300, EnvGen.kr(env, gate, doneAction: Done.freeSelf)), Rand(-1.0, 1.0))
	)
}).add;

)


(
s.boot;
a = NodeProxy.audio(s, 2);
a.fadeTime = 2;
b = NodeProxy.audio(s,2);
b.fadeTime = 3;
)

a.play; // monitor output

// play the pattern silently in b
b.source = Pbind(\instrument, \who, \freq, 500, \ffreq, 700, \legato, 0.02);

// play b out through a:
a.source = b;

// filter b with ring modulation:
a.source = { b.ar * SinOsc.ar(SinOsc.kr(0.2, 300, 330)) }; // filter the input of the pattern
a.source = { b.ar * LFCub.ar([2, 8], add: -0.5) }; // filter the input of the pattern

a.source = b;

// map b to another proxy
c = NodeProxy.control(s, 1).fadeTime_(1);
c.source = { SinOsc.kr(2, 0, 400, 700) };


// now one can simply embed a control node proxy into an event pattern.
// (this works not for \degree, \midinote, etc.)
// embedding in other patterns it will still return itself.


b.source = Pbind(\instrument, \who, \freq, 500, \ffreq, c, \legato, 0.02);

c.source = { SinOsc.kr(SinOsc.kr(0.2, 0, 10, 10), 0, 400, 700) };

c.source = { LFNoise1.kr(5, 1300, 1500) };
c.source = { MouseX.kr(100, 5500, 1) };

(
b.source = Pbind(
			\instrument, \who,
			\freq, Pseq([600, 350, 300],inf),
			\legato, 0.1,
			\ffreq, Pseq([c, 100, c, 100, 300, 600], inf), // use proxy in a pattern
			\dur, Pseq([1, 0.5, 0.75, 0.25] * 0.4, inf),
			\amp, Pseq([0.2, 0.2, 0.1, 0.1, 0.2], inf)
		);
)



b[2] = Pbind(\instrument, \who, \freq, 620, \ffreq, Prand([500,c],inf), \legato, 0.1, \dur, 0.1);
b[3] = Pbind(\instrument, \who, \ffreq, 5000, \freq, Pseq([720, 800],inf), \legato, 0.1, \dur, 0.1, \amp, 0.01);
b[4] = Pbind(\instrument, \who, \freq, Pseq([700, 400],inf), \legato, 0.1, \ffreq, 200);
b[1] = { WhiteNoise.ar([0.01,0.01]) };
b[4] = { arg ffreq=800; Resonz.ar(WhiteNoise.ar([1,1]), ffreq, 0.05) };


b.map(\ffreq, c); // map the control to the proxy
b.removeLast;
b.removeLast;
a.source = { b.ar * WhiteNoise.ar(0.1, 1) };
a.source = { b.ar * WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc.ar(SinOsc.kr(0.01, 0, 50, 330))) };

c.source = { XLine.kr(1900, 10, 10) };

a.clear(10); b.clear(10); c.clear(10); // fade out and clear all (free bus, group and synths)
::


class:: NodeProxyEditor
summary:: editor for a nodeproxy - replaced by NdefGui!
categories:: JITLib>GUI, Live Coding
related:: Classes/NdefGui

description::

warning::
NodeProxyEditor has been rewritten and renamed link::Classes/NdefGui::, which has the same functionality, but is both more consistent and more flexible. There are some changes to the strong::*new:: method:

definitionList::
## instead of || *new(proxy, nSliders=16, parent, extras=[\CLR, \reset, \scope, \doc, \end, \fade], monitor, sinks, morph)
## NdefGui uses || *new(object, numItems = 0, parent, bounds, makeSkip, options)
::

strong::proxy:: is now strong::object::, strong::nSliders:: is now strong::numItems::, strong::parent:: is still strong::parent::. strong::bounds:: - can be code::Rect(l, t, w, h):: or code::width@heights::, strong::makeSkip:: - is an option to build without skipjack. strong::extras:: are now strong::options::, and have become more flexible.

Please see link::Classes/NdefGui:: for more details.
::

NodeProxyEditor provides controls for handling and editing a node proxy and its monitors (cross-platform graphics).

list::
## sliders for numerical settings
## mapping of kr proxies to parameters
## optional controls for playing / monitoring
::

link::Classes/NodeProxy:: and link::Classes/Ndef:: implement an strong::edit:: message, which returns a link::Classes/NodeProxyEditor::. Overview: link::Overviews/JITLib::

ClassMethods::

private::initClass

subsection::Creation

method::new
Returns a new instance for a given proxy. If a window (win) or a composite view is given, it uses this.

Examples::

code::
	// preparation
s.boot;
p = ProxySpace.push(s);

(
~test = { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
};
)

	// make a NodeProxyEditor
n = NodeProxyEditor();
n.proxy_(~test);

	// some configuration options
	// number of sliders
n = NodeProxyEditor(~test, 6);

	// the top line has a choice of elements:
	\CLR 		button to clear proxy
	\reset		button to reset proxy nodemap
	\scope		button to scope proxy
	\doc		button to document proxy as code
	\end		button to end proxy
	\fade		EZNumber for setting fadetime

		not in the default elements:
	\rip		button to open a new editor on the proxy (used in ProxyMixer)

	\pausR		a button to toggle pause/resume
	\sendR		a button to re-send; alt-click does Rebuild

	\send		just send
	\rebuild	just rebuild
	\poll		poll the proxy

		// maybe provide later this?
	\name -> { func }; 	// add your own element...

	// The default buttons/controls are:
NodeProxyEditor(extras: nil, monitor: true, sinks: true);
	// these are:
NodeProxyEditor(extras: [\CLR, \reset, \scope, \doc, \end, \fade], monitor: true, sinks: true);
	// if no monitor line, you can add pausR and sendR buttons
NodeProxyEditor(extras: [\CLR, \reset, \pausR, \sendR, \scope], monitor: false, sinks: false);


	// barebones
NodeProxyEditor(extras: [], monitor: false);

	// not done yet - presets and morphing
NodeProxyEditor( morph: true);

	// also works with Ndef
Ndef(\a).ar;
NodeProxyEditor(Ndef(\a));

	// place in existing window
(
w = Window("testing");
n = NodeProxyEditor(nSliders: 6, win: w);
n.proxy_(~test);
)
	// too many controls: an EZScroller helps.
(
~test = { |freq=300, dens=20, amp=0.1, pan, ping=12, tok=13, crak|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
};
Spec.add(\dens, [0.1, 100, \exp, 0.01, 10]);
)
	// gets specs for slider ranges from global lookup in Spec.specs:
Spec.add(\dens, [0.1, 100, \exp, 0.01, 10]);
n.fullUpdate;

(	// keys go away if not needed
~test = { |freq=300, dens=20, amp=0.1|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2))
};
)

(	// and are added in order if needed
~test = { |freq=300, intv=0, dens=20, amp=0.1, pan, pok, ting|
	Pan2.ar(
		Ringz.ar(
			Dust.ar(dens ! 2, amp / (dens.max(1).sqrt)),
			freq * [intv, intv.neg].midiratio, 0.2))
};
)

	// changes in settings are shown:
~test.set(\freq, exprand(100.0, 2000.0));
~test.playN;

	// mapping kr proxies to controls is shown
~lfo = { LFNoise0.kr(8, 4) };
~test.map(\intv, ~lfo);
~test.unmap(\intv);

Spec.add(\intv, ControlSpec(0, 24, \lin, 0.01, 0)); n.fullUpdate;
	// setting a param value unmaps a previous control source
~test.set(\freq, rrand(200, 500), \intv, rrand(-5.5, 5.5));
::

subsection::You can drag and drop proxies between NodeProxyEditors

code::
(
// p = ProxySpace.push(s.boot);

l = NodeProxyEditor(nil, 3); l.w.bounds_(l.w.bounds.moveBy(0, 120));
m = NodeProxyEditor(nil, 3); m.w.bounds_(m.w.bounds.moveBy(0, 240));
n = NodeProxyEditor(nil, 3); n.w.bounds_(n.w.bounds.moveBy(0, 360));
o = NodeProxyEditor(nil, 3); o.w.bounds_(o.w.bounds.moveBy(0, 480));

Spec.add(\dens, [0.1, 300, \exp]);

	// make 3 kinds of proxies: using tilde/proxyspace, Ndef, and unnamed.
~spacy = {|dens=5| Formlet.ar(Dust.ar(dens ! 2), LFDNoise0.kr(20 ! 2).lag(0.1).linexp(-1, 1, 300, 5000), 0.003, 0.03) };
Ndef(\ndeffy, { GrayNoise.ar( 0.1 ! 2) });
c = NodeProxy.audio.source_({ PinkNoise.ar(0.1 ! 2) });

	// put one in each editor
l.proxy_(~spacy);
m.proxy_(Ndef(\ndeffy));
n.proxy_(c);
)
::


class:: NodeWatcher
summary:: notify sc-lang side node objects of their server sided state
related:: Reference/Server-Command-Reference, Classes/Node, Classes/DebugNodeWatcher
categories:: Control, Server>Nodes

description::
Node instances (Synths and Groups) can be registered with the NodeWatcher.
It watches for server node status messages:
n_go n_end n_off n_on

and sets the isPlaying and isRunning variables on the Node instance accordingly. A Node that ends is unregistered at that time.

In some cases this can be an invaluable service. The use of an independant object to maintain the state keeps the implementation of the Node classes simple.
Note that server notification should be on. (this is default. see: aServer.notify)

code::
//the most common use:
NodeWatcher.register(aNode);
::

ClassMethods::

private::initClass

method::new
Create a new instance listening to the server's address

method::newFrom
Create a new instance listening to the server's address. If there is one present already return that one.

method::register

argument::node
Can be a Group or a Synth. The NodeWatcher is created internally.

argument::assumePlaying
If true, the node's strong::isPlaying:: field is set to true.

method::unregister
Remove the node from the list of nodes. This happens also when a node is freed.

InstanceMethods::

method::start
Add the OSCFunc to listen to the address.

method::stop
Remove the OSCFunc to stop listen to the address.

Examples::

code::
(
b = s.makeBundle(false, {
	a = Group.new(s);	//create a node object
	NodeWatcher.register(a); // register before creating on the server
});
)
a.isPlaying;
s.listSendBundle(nil, b);	//start the node on the server
a.isPlaying;
a.isRunning;
a.run(false);
a.isRunning;
s.freeAll;	//free all nodes
a.isPlaying;
a.isRunning;
::


class:: Normalizer
summary:: Flattens dynamics.
related:: Classes/Amplitude, Classes/Compander, Classes/CompanderD, Classes/Limiter
categories:: UGens>Dynamics


Description::

Normalizes the input amplitude to the given level. Normalizer will not
overshoot like  link::Classes/Compander::  will, but it needs to look
ahead in the audio. Thus there is a delay equal to twice the value
of the  code::dur::  parameter.


classmethods::

method::ar

argument::in
The signal to be processed.

argument::level
The peak output amplitude level to which to normalize the input.

argument::dur

The buffer delay time. Shorter times will produce smaller delays
and quicker transient response times, but may introduce amplitude
modulation artifacts.


Examples::

code::

(
// example signal to process
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
}, 0.8)
)

(
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
	[z, Normalizer.ar(z, 0.4, 0.01)]
}, 0.5)
)

::



class:: NoteOffResponder
summary:: allow functions to be registered to respond to MIDI noteOff events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/NoteOnResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which note number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::veloc
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next noteOff message, reset self to match src, chan.
code::
(
c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
	});
	c.learn; // wait for the first note off
)
NoteOffResponder.removeAll
::


Examples::

code::
(
	c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any note
		nil // any vel
	)
)

c.remove
::

code::
(
	c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60), // within this note range
		nil // any vel
	)
)

c.remove
::


class:: NoteOnResponder
summary:: allow functions to be registered to respond to MIDI noteOn events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which note number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::veloc
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next noteOn message, reset self to match src, chan.
code::
(
c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
	});
	c.learn; // wait for the first note
)
NoteOnResponder.removeAll
::


Examples::

code::
(
	c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any note
		nil // any vel
	)
)

c.remove
::

code::
(
	c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60), // within this note range
		nil // any vel
	)
)

c.remove
::


class:: NotificationCenter
summary:: let an object emit notifications
related:: Classes/SimpleController, Classes/NodeWatcher
categories:: Control

description::

In certain cases it may be useful to make an object perform a specific function when receiving a predefined message from another given object.  For example, a GUI element may want to update its state when the state of a server object changes.  Such cases are: Update the count of synthdefs when a new synthdef is loaded, update the enabled/disabled state of a control gui element when a Synth which it controls starts running or is freed, etc. NotificationCenter makes it possible to add such a custom function to any object called the observer, and to perform it whenever another object called the subject issues a notification identified by a symbol called the message.

The implementation provided by NotificationPattern is a variant of a common OOP pattern called the Observer Pattern, which provides a way for an object to flexibly broadcast messages to interested receiver objects.  This pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.  (see: https://www.gofpatterns.com/behavioral-design-patterns/behavioral-patterns/observer-pattern.php and https://en.wikipedia.org/wiki/Observer_pattern ).  An object that  notifies its dependents is called the subject, and the dependents are called observers.

The original implementation of this pattern in SuperCollider involves three steps:

NUMBEREDLIST::
## A subject adds a dependant with: code:: subject.addDependant(observer) ::
## When a subject wants to inform its observers (dependants) that it has changed, it uses the method changed: code:: subject.changed(<optional arguments>...) ::
## The method changed obtains the list of dependants of the subject and iterates over each observer sending it the message code:: update :: : code:: observer.changed(subject, <optional arguments>...) ::
::

Each observer object can then decide how to react to the change broadcast by the subject, based on the code contained in the update method and the arguments received from the subject.

The above implementation is simple to use, because it only requires to register each observer to the intended subject. However it is limited by the fact that the action to be performed by the observer is coded in the update method.  This makes it complicated to code the choice of different actions to be performed depending on the subject, the observer, and the messages sent as arguments with the code:: changed :: message.  The NotificationCenter class provides a way to tell each observer what action to perform depending on the subject and on a symbol which is sent as argument together with the method broadcast by the subject.  Thus, to make an observer perform an action when it receives a message symbol from a subject, it is necessary to specify the following 4 objects:

NUMBEREDLIST::
## The subject (Any kind of object except nil)
## The message (A symbol)
## The observer (Any kind of object except nil)
## The action to be performed (A Function)
::

Using the NotificationCenter class, a connection between a subject and an observer to perform an action in response to a message is created by the following code:

code::
NotificationCenter.register(subject, message, observer, action)
::

To notify observers that a subject has changed, the NotificationCenter must call the method code:: notify :: :

code::
NotificationCenter.notify(subject, message, <optional arguments>...);
::

Any object that has been registered as observer to the subject issuing the notification, will perform the action that is coupled to the message of the notification.  It is thus possible to make any observer object perform a specified action when receiving the corresponding message from the object with which it has been registered. 

section:: Example

When a Server boots or quits, it notifies its observers sending them the message \newAllocators:

code::
NotificationCenter.notify(server, \newAllocators)
::

Therefore any object that wants to perform an action when a server boots or quits, can use NotificationCenter to register the action using the following code:

code::
// using default server as subject and a symbol as observer:
NotificationCenter.register(Server.default, \newAllocators, \yourself, {
	// Substitute anything more meaningful here:
	"symbol yourself was notified newAllocators by default server".postln;
});
::

ClassMethods::

private::initClass

method::notify
The object emits a message and may also pass extra args.

method::register
An interested client can register the action function for the object/message notification. A listener may only register one action per object/message notification.

method::unregister
Remove the registrations.

method::registerOneShot
After the notification has been emitted and handled, automatically unregister.

method::registrationExists
Simply confirms if a registration is already in place.



class:: NumAudioBuses
summary:: Number of audio busses.
related:: Classes/NumBuffers, Classes/NumControlBuses, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of audio busses.


classmethods::

method::ir



class:: NumBuffers
summary:: Number of open buffers.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of open buffers.


classmethods::

method::ir



class:: NumChannels
summary:: Ensures the number of output channels
categories:: UGens>Multichannel

Description::
Ensures the output has the stated number of channels, regardless of the number of input channels.

classmethods::

method:: ar
argument:: input
the audio signal
argument:: numChannels
an integer
argument:: mixdown
true/false, whether you want to mixdown or just use the first channel

discussion::
Mono input is copied.
Multi-channels clumped and if code::mixdown:: is true mixed down, else the first channel used.

Examples::
code::
(
{
	NumChannels.ar(
		SinOsc.ar(100,0,0.2), // 1 becomes 2
		2)
}.play
)

(
{
	NumChannels.ar(
		SinOsc.ar([100,200,300],0,0.2), // 3 becomes 2
		2)
}.play
)

(
{
	NumChannels.ar(
		SinOsc.ar([100,200,300,100],0,0.2), // 4 becomes 2

		2)
}.play
)
::



class:: NumControlBuses
summary:: Number of control busses.
related:: Classes/NumAudioBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of control busses.


classmethods::

method::ir



class:: NumInputBuses
summary:: Number of input busses.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of input busses.


classmethods::

method::ir



class:: NumOutputBuses
summary:: Number of output busses.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of output busses.


classmethods::

method::ir



class:: NumRunningSynths
summary:: Number of currently running synths.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumOutputBuses
categories::  UGens>Info


Description::

Number of currently running synths.


classmethods::

method::ir

Examples::

code::

// example: frequency is derived from the number of synths running
(
SynthDef("numRunning", { arg out;
	Out.ar(out, SinOsc.ar(NumRunningSynths.ir * 200 + 400, 0, 0.1));
}).add;
)

s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);

::



class:: Number
summary:: Mathematical quantity
categories:: Math

description::
Number represents a mathematical quantity.

instancemethods::

subsection:: Math

method:: +
Addition.

method:: -
Subtraction.

method:: *
Multiplication.

method:: /
Division.

method:: div
Integer division.

method:: %
Modulo.

method:: **
Exponentiation.


subsection:: Polar Coordinate Support

method:: rho
Answer the polar radius of the number.

method:: theta
Answer the polar angle of the number.


subsection:: Complex Number Support

method:: real
Answer the real part of the number.

method:: imag
Answer the imaginary part of the number.


subsection:: Conversion

method:: @
Create a new link::Classes/Point:: whose x coordinate is the receiver and whose y coordinate is aNumber.

method:: complex
Create a new link::Classes/Complex:: number whose real part is the receiver with the given imaginary part.

method:: polar
Create a new link::Classes/Polar:: number whose radius is the receiver with the given angle.


subsection:: Iteration

method:: for
Calls strong::function:: for numbers from this up to endval, inclusive, stepping each time by 1.
argument:: endValue
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
argument:: endval, and the second which is a number from zero to the number of iterations minus one.

method:: forBy
Calls strong::function:: for numbers from this up to endval stepping each time by step.
argument:: endValue
a link::Classes/Number::.
argument:: stepValue
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: forSeries
Calls strong::function:: for numbers from this up to endval stepping each time by a step specified by second.
argument:: second
a link::Classes/Number::.
argument:: last
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
endval, and the second which is a number from zero to the number of iterations minus one.


CLASS:: NumberBox
summary:: A view displaying a modifiable numerical value.
categories:: GUI>Views

DESCRIPTION::

A view that displays a numerical value and allows to modify it by typing the value in, and incrementing or decrementing it using the keyboard, or mouse.

Using the keyboard, the value will change on each arrow key press by the amount defined by link::#-step::.

Mouse scrolling is performed by pressing a mouse button inside the view and dragging the mouse vertically. The value will change according to the mouse cursor movement, in steps defined by link::#-scroll_step::.

By default, holding down the Shift, Ctrl, or Alt key while incrementing or decrementing the value will multiply the steps by 100, 10, or 0.1 respectively, though you can customize this by setting link::#-shift_scale::, link::#-ctrl_scale::, or link::#-alt_scale::. Scrolling can be enabled or disabled by modifying the link::#-scroll:: variable.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::




SUBSECTION:: Data

METHOD:: value
	Numerical value between 0 and 1.

	argument::
		A Float.

METHOD:: valueAction
	Sets link::#-value:: to the argument and triggers link::#-action::.

METHOD:: increment
	Increments the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: decrement
	Decrements the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: string
	Text to be displayed instead of the numerical value. Setting link::#-value:: after this will display the value again.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the argument interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.




SUBSECTION:: Restrictions on data

METHOD:: clipLo
	The lowest numerical value allowed. Trying to set a lower value will clip it to this.

	argument::
		A Float.

METHOD:: clipHi
	The highest numerical value allowed. Trying to set a higher value will clip it to this.

	argument::
		A Float.

METHOD:: minDecimals
	The minimum amount of decimal places displayed. If the value can be completely described with less decimal places, zeros will be appended until reaching this.

	argument::
		An Integer.

METHOD:: maxDecimals
	The maximum amount of decimal places displayed. The value will always be rounded to this amount of decimals.

	argument::
		An Integer.

METHOD:: decimals
	Sets both link::#-minDecimals:: and link::#-maxDecimals:: to the argument.

	argument::
		An Integer.




SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed value. See link::Reference/gui_alignments:: for possible values.

METHOD:: stringColor
	The color used to display the value before it is ever changed by user interaction.

	argument::
		A Color.

METHOD:: normalColor
	The color used to display the value after is has been typed in.

	argument::
		A Color.

METHOD:: typingColor
	The color used to display the value while it is being typed in.

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: step
	The amount by which the value will changed when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: scroll_step
	The amount by which the value will changed when scrolled using the mouse.

	argument::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the value by interacting with the view.

METHOD:: defaultKeyDownAction

	Any key representing a character that can make part of a floating point number representation will initiated the editing of the value. Pressing Return (or Enter) will finish the editing and store the value typed in as a Float.

	Aside from that, this method implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::

subsection:: Basic Example

code::
(
    w = Window("NumberBox Example", Rect(100, 500, 400, 120));
    b =     NumberBox(w, Rect(150, 10, 100, 20));
    b.value = rrand(1,15);
    b.action = {arg numb; numb.value.postln; };
    w.front
)
// try these one at time
b.value = rrand(1,15) ;     // sets the value but does not perform the action
b.valueAction_(5);      // sets the value and performs the action
b.step_(0.1);           // change the increment/decrement size for the arrow keys
b.scroll_step=10;    // change the increment/decrement size for the mosueScrolling

b.background_(Color.grey);          // change the background color of the box
b.typingColor_(Color(0.3,1,0.3));   // change the typing color for the box
b.normalColor_(Color.white);        // change the normal color for the box. won't change until next value change

b.stringColor = Color.red;
b.align = \center;

b.increment; // increment or decrement by step
b.decrement;
::


subsection:: Sound Example

Change frequency of a playing synth by step using arrow keys:

code::
(
s.waitForBoot({

    n={arg freq=220;
        var out;
        out=SinOsc.ar(freq,0,0.2);
        8.do{out = AllpassN.ar(out, 0.2,0.02+0.20.rand,8)};
        out;
    }.play;

    w = Window("Use arrow keys to change the frequency by steps", Rect(100, 500, 500, 120));
    b = NumberBox(w, Rect(200, 10, 100, 20));
    b.value = 220;
    b.action = {arg numb; n.set(\freq,numb.value); };
    b.step=55; //make the step a fraction of the freq
    b.focus;
    w.front;

    CmdPeriod.doOnce({w.close});

});
)
::


CLASS:: OSCArgsMatcher
summary:: Test for specific OSC arguments before evaluating a Function
categories:: External Control>OSC>Matchers
related:: Classes/OSCFunc, Guides/OSC_communication

DESCRIPTION::
OSCArgMatcher matches an argument template to a link::Classes/Function:: or similar object. When its value method is called, it evaluates the function if all of the arguments in its template pass a link::Reference/matchItem:: test.  This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using sender address. This class is private, and generally users should not need to address instances directly.

CLASSMETHODS::

METHOD:: new
Make a new OSCArgsMatcher

argument:: argTemplate
An link::Classes/Array:: comprising a template for determining if incoming arguments match. For each argument that you wish to test, you may include a constant (for exact matching), code::nil:: (indicating that all possible values and types will match), or a link::Classes/Function:: to test the incoming argument (see link::Reference/matchItem:: for examples). These should be in the same order as the items in the incoming OSC message, starting from index 1. (Index 0 is the OSC address.)

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: in the form code::[OSCAddress, ...otherArgs]::, the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.


INSTANCEMETHODS::
private:: init

METHOD:: value
Test if an incoming message's arguments match, and if so evaluate this object's function. In normal usage (within an OSCFunc) this is done behind the scenes.

argument:: testMsg
An link::Classes/Array:: in the form code::[OSCAddress, …msgArgs]::.

argument:: time
The time that the message was sent as a link::Classes/Float::.

argument:: addr
A link::Classes/NetAddr:: corresponding to the IP address of the sender.

argument:: recvPort
An link::Classes/Integer:: corresponding to the port on which the message was received.


EXAMPLES::

code::
// Basic example (standalone use)
m = OSCArgsMatcher([1, nil, 2], {'matches!'.postln});
m.value(['/myAddress', 1, 3, 2], 0.0, NetAddr.localAddr, NetAddr.langPort); // matches!
::


class:: OSCBundle
summary:: network bundle object
related:: Guides/OSC_communication
categories:: External Control>OSC

description::
A bundle object that allows to add preparation messages for async processes. If this feature is not needed, a list object can be used instead.

InstanceMethods::

private::prSend

method::add
Add an osc message to the bundle.

method::addAll
Add an array of osc messages to the bundle.

method::addPrepare
Add a preparation osc message, which is sent before the bundle is sent.

method::send
Send the bundle to a server. If preparation messages are given, they are sent, the process waits for their reception abd then sends the bundle.

method::schedSend
Like send, but the sending is synced to a given clock to the next beat.

argument::server
A link::Classes/Server::.

argument::clock
A link::Classes/TempoClock::.

argument::quant
Can be a pair of values: [quant, offset].

Examples::

code::
// create a new, empty instance
a = OSCBundle.new;

// a synthdef that needs to be sent to the server, an operation that is asynchronous,
// i.e. we have to wait until it is finished.
x = SynthDef("test", { OffsetOut.ar(0, BPF.ar(Impulse.ar(4) * 10, Rand(9000, 1000), 0.1)) });
// this is why addPrepare is used.
a.addPrepare(["/d_recv", x.asBytes]);
// add is used with synchronous operations, like starting synths.
a.add(["/s_new", "test", -1]);

// the bundle has now the synchronous separated from the asynchronous bundles:
a.messages;
a.preparationMessages;

// this can be simply sent - the bundle takes care of the server client communication
// like waiting for the synthdef to be loaded. the synth is started when the preparation
// is finished.

s.boot; // boot the server
a.send(s);

s.freeAll; // free all nodes on the server

// scheduled sending: the synths are started on the next beat.

a.schedSend(s, TempoClock.default, 1);
a.schedSend(s, TempoClock.default, 1);
a.schedSend(s, TempoClock.default, 1);

s.freeAll; // free all nodes on the server

// the bundle can contain several preparation messages and messages at a time.
// the proparationMessages are sent first and only when they are all completed,
// the other bundles are sent.
// the bundle can also be reused, if there is no specific allocated buffers/node ids.
::


CLASS:: OSCFunc
summary:: Fast Responder for incoming Open Sound Control Messages
categories:: External Control>OSC
related:: Guides/OSC_communication, Classes/OSCdef, Classes/NetAddr

DESCRIPTION::
OSCFunc (and its subclass link::Classes/OSCdef::) registers one or more functions to respond to an incoming OSC message which matches a specified OSC Address. Many of its methods are inherited from its superclass link::Classes/AbstractResponderFunc::. OSCFunc supports pattern matching of wildcards etc. in incoming messages. For efficiency reasons you must specify that an OSCFunc will employ pattern matching by creating it with the link::#*newMatching:: method, or by passing a matching dispatcher to link::#*new::. For details on the Open Sound Control protocol, see http://opensoundcontrol.org/spec-1_0.html

CLASSMETHODS::
private:: initClass, cmdPeriod

METHOD:: defaultDispatcher
Get or set the default dispatcher object for OSCFuncs (this is what you get if you pass nil as the dispatcher argument to link::#*new::). This object will decide if any of its registered OSCFuncs should respond to an incoming OSC message.

returns:: By default this will be an link::Classes/OSCMessageDispatcher::, but it can be set to any instance of an appropriate subclass of link::Classes/AbstractDispatcher::.

METHOD:: defaultMatchingDispatcher
Get or set the default matching dispatcher object for OSCFuncs (this is what you get if when you create an OSCFunc using link::#*newMatching::). This object will decide if any of its registered OSCFuncs should respond to an incoming OSC message using pattern matching.

returns:: By default this will be an link::Classes/OSCMessagePatternDispatcher::, but it can be set to any instance of an appropriate subclass of link::Classes/AbstractDispatcher::.

METHOD:: new
Create a new, enabled OSCFunc.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message.  When evaluated it will be passed the following arguments:
table::
## msg || message as an link::Classes/Array:: in the form code::[OSC address, args1, arg2, ...]::
## time || the time received (for messages) / the time sent plus the latency (if the message was in a bundle)
## addr || a link::Classes/NetAddr:: corresponding to the IP address of the strong::sender::
## recvPort || link::Classes/Integer:: corresponding to the port on which the message was strong::received::.
::

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCFunc demands OSC compliant addresses. If the path does not begin with a / one will be added automatically.

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received. If set this object will only respond to message received on that port. This method calls link::Classes/Main#-openUDPPort:: to ensure that the port is opened.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: A new instance of OSCFunc.

METHOD:: newMatching
A convenience method to create a new, enabled OSCFunc whose dispatcher will perform pattern matching on incoming OSC messages to see if their address patterns match this object's path.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: [OSCAddress, other args], the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCFunc demands OSC compliant addresses. If the path does not begin with a / one will be added automatically. Pattern matching will be applied to any incoming messages to see if they match this address. Note that according to the OSC spec, regular expression wildcards are only permitted in the incoming message's address pattern. Thus path should not contain wildcards. For more details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

returns:: A new instance of OSCFunc.

METHOD:: trace
A convenience method which dumps all incoming OSC messages.

argument:: bool
A link::Classes/Boolean:: indicating whether dumping is on or off.

argument:: hideStatusMsg
A link::Classes/Boolean:: indicating whether server status messages are excluded from the dump or not.

INSTANCEMETHODS::

private:: init, printOn

METHOD:: path
Get the path of this OSCFunc's OSC Address.

returns:: A link::Classes/String::

METHOD:: recvPort
Get this OSCFunc's receiving port.

returns:: An link::Classes/Integer::



EXAMPLES::

code::
n = NetAddr("127.0.0.1", NetAddr.langPort); // local machine

OSCFunc.newMatching({|msg, time, addr, recvPort| \matching.postln}, '/chat', n); // path matching
OSCFunc({|msg, time, addr, recvPort| \oneShot.postln}, '/chat', n).oneShot; // once only
OSCdef(\test, {|msg, time, addr, recvPort| \unmatching.postln}, '/chat', n); // def style

m = NetAddr("127.0.0.1", NetAddr.langPort); // loopback

m.sendMsg("/chat", "Hello App 1");
m.sendMsg("/chat", "Hello App 1"); // oneshot gone
m.sendMsg("/ch?t", "Hello App 1");
m.sendMsg("/*", "Hello App 1");
m.sendMsg("/chit", "Hello App 1"); // nothing

// Introspection

AbstractResponderFunc.allFuncProxies
AbstractResponderFunc.allEnabled
OSCdef(\test).disable;
AbstractResponderFunc.allDisabled

// change funcs
OSCdef(\test).enable;
OSCdef(\test, {|msg, time, addr, recvPort| 'Changed Unmatching'.postln}, '/chat', n); // replace at key \test
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).add(f = {\foo.postln}); // add another func
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).clear; // remove all functions
m.sendMsg("/chat", "Hello App 1");

//////// Use an argTemplate for finer grained matching

s.boot;
x = Synth(\default);
OSCFunc({ 'ended!'.postln }, '/n_end', s.addr, nil, [x.nodeID]).oneShot;
x.release(3);
::


CLASS:: OSCFuncAddrMessageMatcher
summary:: Matches incoming messages to responder funcs based on sender address
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using sender address. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: addr
The link::Classes/NetAddr:: to attempt to match.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncAddrMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: testAddr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.



CLASS:: OSCFuncBothMessageMatcher
summary:: Matches incoming messages to responder funcs based on receive port and sender address
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages  to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using receive port and sender address. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: addr
The link::Classes/NetAddr:: to attempt to match.

argument:: recvPort
The receive port to attempt to match, in the form of an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncBothMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: testAddr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: testRecvPort
An link::Classes/Integer:: indicating the port on which the message was received.



CLASS:: OSCFuncRecvPortMessageMatcher
summary:: Matches incoming messages to responder funcs based on receive port
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages  to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using receive port. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: recvPort
The receive port to attempt to match, in the form of an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncRecvPortMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaluate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: testRecvPort
An link::Classes/Integer:: indicating the port on which the message was received.



CLASS:: OSCMessageDispatcher
summary:: The default dispatcher class for OSCFunc and OSCdef.
categories:: External Control>OSC>Dispatchers
related:: Classes/OSCFunc, Classes/OSCdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessagePatternDispatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher, Guides/OSC_communication

DESCRIPTION::
OSCMessageDispatcher dispatches incoming OSC messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/OSCFunc:: or link::Classes/OSCdef:: whose function(s) are to be wrapped.

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be an OSC path.

argument:: funcProxy
The link::Classes/OSCFunc:: or link::Classes/OSCdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's path as a link::Classes/Symbol::.

METHOD:: value
Attempt to match an incoming OSC message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.

METHOD:: register
Adds this dispatcher to thisProcess.recvOSCfunc.

METHOD:: unregister
Removes this dispatcher from thisProcess.recvOSCfunc.

METHOD:: typeKey
Returns code::'OSC unmatched'::.

returns:: A link::Classes/Symbol::.



CLASS:: OSCMessagePatternDispatcher
summary:: The default pattern matching dispatcher for OSCFunc and OSCdef.
categories:: External Control>OSC>Dispatchers
related:: Classes/OSCFunc, Classes/OSCdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessageDispatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher, Guides/OSC_communication

DESCRIPTION::
OSCMessageDispatcher dispatches incoming OSC messages to matching functions, using pattern matching to see if regular expressions wildcards in the incoming message's address pattern match one of this dispatcher's OSCFuncs' paths. Normally users should not have to create or message instances of this class directly. For details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: value
Attempt to match an incoming OSC message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.

METHOD:: typeKey
Returns code::'OSC unmatched'::.

returns:: A link::Classes/Symbol::.



CLASS:: OSCdef
summary:: OSC response reference definition
categories:: External Control>OSC>Dispatchers
related:: Guides/OSC_communication, Classes/OSCFunc, Classes/NetAddr

DESCRIPTION::
OSCdef provides a global reference to the functionality of its superclass link::Classes/OSCFunc::. Essentially it stores itself at a key within a global dictionary, allowing replacement at any time. Most methods are inherited from its superclass.


CLASSMETHODS::
private:: initClass

METHOD:: all
Get the global dictionary of all OSCdefs.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled OSCdef. If an OSCdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the following arguments:
table::
## msg || message as an link::Classes/Array:: in the form code::[OSC address, args1, arg2, ...]::
## time || the time received (for messages) / the OSC bundle's timestamp (if the message was in a bundle)
## addr || a link::Classes/NetAddr:: corresponding to the IP address of the strong::sender::
## recvPort || link::Classes/Integer:: corresponding to the port on which the message was strong::received::.
::

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCdef demands OSC compliant addresses. If the path does not begin with a / one will be added automatically.

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received. If set this object will only respond to message received on that port. This method calls link::Classes/Main#-openUDPPort:: to ensure that the port is opened.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCdef should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: An instance of OSCdef.

METHOD:: newMatching
A convenience method to create a new, enabled OSCdef whose dispatcher will perform pattern matching on incoming OSC messages to see if their address patterns match this object's path.

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: [OSC address, args1, arg2, ...], the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCdef demands OSC compliant addresses. If the path does not begin with a / one will be added automatically. Pattern matching will be applied to any incoming messages to see if they match this address. Note that according to the OSC spec, regular expression wildcards are only permitted in the incoming message's address pattern. Thus path should not contain wildcards. For more details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

returns:: An instance of OSCdef.

METHOD:: freeAll
Clears and deactivates all OSCdefs from the global collection.

INSTANCEMETHODS::
private:: addToAll, printOn

METHOD:: key
Get this OSCdef's key.

returns:: Usually a link::Classes/Symbol::.

METHOD:: free
Clears this OSCdef from the global collection and deactivates it.

SECTION::Timing in incoming bundles
The time argument indicates the time the message was sent plus, if given, the latency added to the bundle:
CODE::
(
OSCdef(\x, { |msg, time|
	"reception time: %\nscheduling time: %\ndelta: %\n\n".postf(Main.elapsedTime, time, time - Main.elapsedTime)
}, \time);

n = NetAddr("127.0.0.1", 57120);
)

(
n.sendBundle(0.0, [\time]);
n.sendBundle(1.0, [\time]);
)
::



EXAMPLES::

code::
n = NetAddr("127.0.0.1", 57120); // local machine

OSCdef(\test, {|msg, time, addr, recvPort| \unmatching.postln}, '/chat', n); // def style
OSCdef.newMatching(\test2, {|msg, time, addr, recvPort| \matching.postln}, '/chat', n); // path matching
OSCdef(\test3, {|msg, time, addr, recvPort| \oneShot.postln}, '/chat', n).oneShot; // once only


m = NetAddr("127.0.0.1", 57120); // loopback

m.sendMsg("/chat", "Hello App 1");
m.sendMsg("/chat", "Hello App 1"); // oneshot gone
m.sendMsg("/ch?t", "Hello App 1");
m.sendMsg("/*", "Hello App 1");
m.sendMsg("/chit", "Hello App 1"); // nothing

// Introspection

AbstractResponderFunc.allFuncProxies
AbstractResponderFunc.allEnabled
OSCdef(\test).disable;
AbstractResponderFunc.allDisabled

// change funcs
OSCdef(\test).enable;
OSCdef(\test, {|msg, time, addr, recvPort| 'Changed Unmatching'.postln}, '/chat', n); // replace at key \test
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).add(f = {\foo.postln}); // add another func
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).clear; // remove all functions
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).free;  // unregister OSCdef


//////// Use an argTemplate for finer grained matching

s.boot;
x = Synth(\default);
OSCdef(\watchForXEnd, { 'ended!'.postln }, '/n_end', s.addr, nil, [x.nodeID]).oneShot;
x.release(3);

// Args for which nil is passed will use the old values. While this facilitates swapping only parts of an OSCdef, such as the function, it also means you will have to free and recreate an OSCdef to remove parts.

OSCdef(\argtest, {|msg ... args| msg[1].postln}, '/hey', argTemplate: ['you']);
m.sendMsg("/hey", "you"); // oscdef will respond
m.sendMsg("/hey", "there"); // oscdef will not respond, filtered out by argTemplate

OSCdef(\argtest, argTemplate: nil); // this has no effect
m.sendMsg("/hey", "you"); // oscdef will respond
m.sendMsg("/hey", "there"); // oscdef will not respond, still filtered out by argTemplate

OSCdef(\argtest).free; // in order to get rid of the argTemplate, free the def...
OSCdef(\argtest, {|msg ... args| msg[1].postln}, '/hey'); // ... and recreate it.
m.sendMsg("/hey", "you"); // oscdef will respond
m.sendMsg("/hey", "there"); // oscdef will respond

::


class:: OSCpathResponder
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCresponderNode
categories:: External Control>OSC

description::

note::
This class is deprecated and will be removed in a future version of SC. Use link::Classes/OSCFunc:: and link::Classes/OSCdef:: instead. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally.

The replacement for path matching is to be found in the template argument of OSCFunc and OSCDef (see example below).
::

Register a function to be called upon receiving a command with a specific path.

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any link::Classes/OSCresponder:: in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

subsection::Command paths

OSC commands sometimes include additional parameters to specify the right responder.

For example code::/tr:: commands, which are generated on the server by the link::Classes/SendTrig:: Ugen create an OSC packet consisting of: code:: [ /tr, nodeID, triggerID, value] ::.
This array actually specifies the source of value: code:: [ /tr, nodeID, triggerID] ::.
We will refer to that array as a command path.

To create an OSCpathResponder for a specific trigger, the strong::cmdName:: parameter is simply replaced by the complete command path.

subsection::Path defaults

Any element of the command path array can be set to nil to create a responder that will handle multiple command paths.

For example, setting the commandpath: code:: ['/tr', nil, triggerID] :: makes a responder that responds to code::/tr:: messages from any Synth but with a specific triggerID.

ClassMethods::

method::new

argument::addr
An instance of link::Classes/NetAddr::, usually obtained from your server: server-addr. An address of nil will respond to messages from anywhere.

argument::cmdPath
A command path, such as ['\c_set', bus index].

argument::action
A link::Classes/Function:: that will be evaluated when a cmd of that name is received from addr. arguments: time, theResponder, message
note::
OSCresponderNode evaluates its function in the system process. In order to access the application process (e.g. for GUI access ) use { ... }.defer; within the action function, e.g., code:: { |time, resp, msg| { gui.value_(msg[3]) }.defer } ::
::

Examples::

code::
s.boot;

(
	var commandpath, response, aSynth, nodeID, triggerID;
	triggerID = 1;
	aSynth = { arg freq = 1, triggerID = 1;
		SendTrig.kr(SinOsc.kr(freq), triggerID, 666)
	}.play;
	nodeID = aSynth.nodeID;
	commandpath = ['/tr', nodeID, triggerID];
	response = { arg time, responder, message; message.postln };

	o = OSCpathResponder(s.addr, commandpath, response);
	o.add;
)

// switch on and off:
o.remove;
o.add;


// this can be written now conveniently and efficiently with OSCFunc.
// the argTemplate is like the "path" of OSCpathResponder, but without the OSC-path itself.
(
	var commandpath, response, aSynth, nodeID, triggerID;
	triggerID = 1;
	aSynth = { arg freq = 1, triggerID = 1;
		SendTrig.kr(SinOsc.kr(freq), triggerID, 666)
	}.play;
	nodeID = aSynth.nodeID;
	commandpath = [nodeID, triggerID];
	response = { arg message; message.postln };

	o = OSCFunc(response, '/tr', s.addr, argTemplate: commandpath);

)

// an OSCFunc is removed with cmd-Period.
// in order to switch it on and off programmatically:
o.remove;
o.add;

::


class:: OSCresponder
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCresponderNode, Classes/NetAddr
categories:: External Control>OSC

note::
This class is deprecated and will be removed in a future version of SC. Use link::Classes/OSCFunc:: and link::Classes/OSCdef:: instead. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally.
::

Register a function to be called upon receiving a specific command from a specific OSC address.

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any OSCresponder in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

note::
It is highly recommended to use link::Classes/OSCresponderNode:: or link::Classes/OSCpathResponder:: instead of OSCresponder directly. OSCresponders can overwrite each other, but OSCresponderNodes with the same address and command name can coexist peacefully.
::

ClassMethods::

private::initClass

method::new

argument::addr
The address the responder strong::receives from:: (an instance of link::Classes/NetAddr::, e.g. code::Server.default.addr::). An address of nil will respond to messages from anywhere. An address with a port of nil will respond to messages from any port from that specific IP.

argument::cmdName
An OSC command eg. code::'/done'::.

argument::action
A link::Classes/Function:: that will be evaluated when a cmd of that name is received from addr. arguments: time, theResponder, message, addr
note::
OSCresponder evaluates its function in the system process. In order to access the application process (e.g. for GUI access ) use { ... }.defer; within the action function, e.g., code:: { |time, resp, msg| { gui.value_(msg[3]) }.defer } ::
::

Examples::

see link::Classes/OSCresponderNode::.


class:: OSCresponderNode
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCpathResponder, Classes/NetAddr
categories:: External Control>OSC

description::
note::
This class is deprecated and will be removed in a future version of SC. Use link::Classes/OSCFunc:: and link::Classes/OSCdef:: instead. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally.
::

Register a function to be called upon receiving a specific command from a specific OSC address. Same interface like link::Classes/OSCresponder::, but allows strong::multiple responders to the same command::.

Note that OSCresponderNode evaluates its function in the system process.
In order to access the application process (e.g. for GUI access ) use { ... }.defer;

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any OSCresponder in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

Examples::

subsection::Setting up OSCresponderNode for listening to a remote application

code::
// example: two SuperCollider apps communicating

// application 1:
n = NetAddr("127.0.0.1", 57120); // the url should be the one of computer of app 2 (or nil)

o = OSCresponderNode(n, '/chat', { |t, r, msg| ("time:" + t).postln; msg[1].postln }).add;

// application 2:
m = NetAddr("127.0.0.1", 57120); // the url should be the one of computer of app 1
m.sendMsg("/chat", "Hello App 1");

// sending bundles (including timestamps)
(
m.sendBundle(2.0, ["/chat", "Hello App 1"], ["/chat", "Hallo Wurld"]);
m.sendBundle(0.0, ["/chat", "Hello App 1"], ["/chat", "Hallo Wurld"]);
)

// end application 1:
o.remove;
::

subsection::Listening to data from _any_ client

code::
// same as above, but we set the address to nil so we can receive from anywhere
// no need for a NetAddr since we are just listening (and not sending)

o = OSCresponderNode(nil, '/test', { |t, r, msg| msg.postln }).add;
o.remove;
::

subsection::Listening to data from _any_ client, but from a specific host

code::
// same as above, but we use a NetAddr with a port of nil, so we can receive from a specific host, but from any port

n = NetAddr("127.0.0.1", nil); // the url should be the one of computer of app 2
o = OSCresponderNode(n, '/test', { |t, r, msg| msg.postln }).add;
o.remove;
::

subsection::Listening to data from the server

code::
// example from SendTrig

(
s.boot;
s.notify;
)

(
SynthDef("help-SendTrig",{
	SendTrig.kr(Dust.kr(1.0), 0, 0.9);
}).add;

// register to receive this message
a = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;
	[time, responder, msg].postln;
}).add;
b = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;
	"this is another call".postln;
}).add;
)

x = Synth.new("help-SendTrig");
a.remove;
b.remove;
x.free;
::

subsection::Watching for something specific

code::
// end of group message

s.boot;

a = OSCresponderNode(s.addr,'/n_end',{ arg time,responder,msg;
	[time, responder, msg].postln;
	if(msg[1] == g.nodeID,{
		"g is dead !".postln;
		// g = Group.new;
	});
}).add;

g = Group.new;

g.free;

a.remove;
::

subsection::Watching for errors

code::
// example from ServerErrorGui in crucial lib

f = OSCresponderNode(s.addr, '/fail', { arg time, responder, msg;
	{
		var mins,secs;
		mins = (time/60).round(1);
		secs = (time%60).round(0.1);
		if(secs<10,{ secs = "0"++secs.asString; },{ secs=secs.asString;});
		// put this on a gui
		//errors.label = "% % (%:%)".format(msg[1], msg[2], mins, secs);
		//errors.stringColor = Color.white;
		"% % (%:%)".format(msg[1], msg[2], mins, secs).postln;
	}.defer
});
f.add;

// cause a failure
Synth("gthhhhppppppp!");

f.remove
::


class:: Object
summary:: abstract superclass of all objects
categories:: Core>Kernel, Language>OOP

related:: Classes/Class, Guides/Intro-to-Objects, Reference/Classes

description::
Object is the root class of all other classes. All objects are indirect instances of class Object. We call the "receiver" the object the message is sent to: code::receiver.method(argument)::.


classmethods::
private:: prNewCopyArgs, prNew

method::readArchive

Read in an object from a text archive.

code::
(
a = Array.fill(100, { 100.rand });
a.writeArchive(PathName.tmp ++ "myArray");
b = Object.readArchive(PathName.tmp ++ "myArray");
a == b; // true
)

/////////

// closed Function
(
f = { 1 + 2 };
f.writeArchive(PathName.tmp ++ "myFunc"); // succeeds
)
// open Function
(
var num;
num = 2;
f = { num + 2 };
f.writeArchive(PathName.tmp ++ "myFunc"); // fails
)
::

argument::pathname
A String containing the archive file's path.

method::new

Create a new instance. The creation of new instances of any Object actually happens in this method (or with code::newCopyArgs::) when it is called by a child class. See link::Guides/WritingClasses::.

method::newCopyArgs

Creates a new instance and copies the arguments to the instance variables in the order that the variables were defined. If the superclass's code::new:: method requires arguments, the first arguments passed to code::newCopyArgs:: will be passed on to that method, and the following arguments will be copied to this class's instance variables. Class variables are ignored.

code::
MyClass {
	var a, b, c;

	*new {
		arg arg1, arg2, arg3;
		// will copy arg1, arg2, arg3 to variables a, b, c
		^super.newCopyArgs(arg1, arg2, arg3);
	}
}
::

instancemethods::
private::addFunc, addFuncTo, removeFunc, removeFuncFrom

subsection::Class Membership

method::class

Answer the class of the receiver.

code::
5.class;
::

method::respondsTo

Answer a link::Classes/Boolean:: whether the receiver understands the message selector.

code::
5.respondsTo('+'); // true
5.respondsTo('indexOf'); // false
::


argument::aSymbol
A selector name. Must be a link::Classes/Symbol::.

method::isKindOf

Answer a Boolean indicating whether the receiver is a direct or indirect instance of aClass. Use of this message in code must be questioned, because it often indicates a missed opportunity to exploit object polymorphism.

code::
5.isKindOf(Number); // true
5.isKindOf(String); // false
::

method::isMemberOf

Answer a Boolean whether the receiver is a direct instance of aClass. Use of this message in code is almost always a design mistake.

code::
5.isMemberOf(Number); // false
5.isMemberOf(Integer); // true
::

subsection::Accessing

method::size

Different classes respond to this message differently. Object always returns 0.

subsection::Copying

method::copy

Make a copy of the receiver. The implementation of this message depends on the object's class.  In class Object, copy calls shallowCopy.

method::shallowCopy

Makes a copy of the object. The copy's named and indexed instance variables refer to the same objects as the receiver.

method::deepCopy

Recursively copies the object and all of the objects contained in the instance variables, and so on down the structure. This method works with cyclic graphs.

method::copyImmutable

If object is immutable then return a shallow copy, else return receiver.

subsection::Conversion

To convert an object of a certain class into a similar object of another class, Object provides a number of methods.

method::as

Returns a similar new Object of a different class.

code::
[1, 2, 3].as(Set);
Pwhite(0.0, 1.0, 10).as(Set);
::

method::asArray

Returns an Array with the receiver, unless it is an Array already.

code::
[1, 2, 3].asArray;
5.asArray;
::

method::asCompileString

Returns a String that can be interpreted to reconstruct a copy of the receiver. For the complementary method, see link::Classes/String#-interpret::.

code::
a = { 10.do { 10.postln } };
a.asCompileString.postcs;
a.postcs;
::

method::asInt

Deprecated. Use code::asInteger:: instead.

method::cs

Shorthand for link::#-asCompileString::.

code::
{ 10.do { 10.postln } }.cs;
"Strings don't post with surrounding quotes.".cs;
::

subsection::Archiving

Object implements methods for writing and retrieving objects from disk. Note that you cannot archive instances of Thread and its subclasses (i.e. Routine), or open Functions (i.e., a Function which refers to variables from outside its own scope).

method::writeArchive

Write an object to disk as a text archive.

argument::pathname
A String containing the resulting file's path.


subsection::Equality and Identity

method::==

Answer whether the receiver equals anotherObject. The definition of equality depends on the class of the receiver. The default implementation in Object is to answer if the two objects are identical.

note:: Whenever == is overridden in a class, hash should be overridden as well.::

code::
5.0 == 5; // true
5.0 === 5; // false
a = [1, 2, 3]; b = [1, 2, 3];
a == b; // equal
a === b; // not identical
"worth trying" == "worth trying"; // equal
::


method::===

Answer whether the receiver is the exact same object as anotherObject.

code::
5.0 === 5; // false
"worth trying" === "worth trying"; // not identical
'worth trying' === 'worth trying'; // identical (symbols are unique)
::

method::!=

Answer whether the receiver does not equal anotherObject. The default implementation in Object is to determine '==' for the two operands and negate this result. (see below).

method::!==

Answer whether the receiver is not identical to anotherObject.

method::|==|

A lazy equality operator. For typical object types, code::|==|:: behaves the same as link::Classes/Object#-==::. For link::Classes/AbstractFunction:: and its subclasses (including link::Classes/Pattern:: and link::Classes/UGen::), it does not perform the equality check immediately, but rather composes an equality operation to be performed at the time of evaluating the resulting function or stream.

code::
1 |==| 1  // true

Pseq([1], inf) == 1  // false (because "a Pseq" is not 1)

Pseq([1], inf) |==| 1  // a Pbinop

(Pseq([1], inf) |==| 1).asStream.next  // Pbinop evaluates to true
::

method::|!=|

A lazy inequality operator, defined as code::not(this |==| that)::. See link::Classes/Object#-|==|::.

method:: fuzzyEqual

Returns the degree of equality between two objects with regard to a given precision. The compared objects must support teletype::.max::, subtraction, and division.

code::
5.0.fuzzyEqual(5.0, 0.5);  // 1.0 - full equality
5.25.fuzzyEqual(5.0, 0.5); // 0.5 - 50% equality
4.75.fuzzyEqual(5.0, 0.5); // 0.5 - 50% equality
5.9.fuzzyEqual(5.0, 0.5);  // 0.0 - no equality
::

Resolve to a Boolean within your precision threshold by checking whether the returned degree of equality is above code::0.0::.

code::
(
// Cartesian to Polar and back, accumulating precision error
var x = 3.0, y = 5.0;
var hypot = hypot(y, x);
var angle = atan2(y, x);
var polar = Polar(hypot, angle);
var xFromPolar = polar.asPoint.x;
var equalWithin = 1e-5;
postf(
	"Exactly equal? %\n"
	"Fuzzily equal? %\n",
    x == xFromPolar,
    fuzzyEqual(x, xFromPolar, equalWithin) > 0
);
[x, xFromPolar]
)
::

returns:: A link::Classes/Float:: in the range code::0.0:: to code::1.0::.

method::compareObject

Tests if two Objects (of the same class) are the same in a certain respect: It returns true if instVarNames are equal in both. If none are given, all instance variables are tested (see also: link::#-instVarHash::)

code::
a = Pseq([1, 2, 3], inf); b = Pseq([100, 200, 300], inf);
a.compareObject(b, [\repeats]); // true
a.compareObject(b, [\list]); // false
::

method::hash

Answer a code used to index into a hash table. This is used by Dictionary and Set and their subclasses to implement fast object lookup.  Objects which are equal == should have the same hash values. Whenever == is overridden in a class, hash should be overridden as well.

code::
a = "worth trying"; b = "worth trying";
a.hash;
b.hash;
::

method::identityHash

Answer a code used to index into a hash table. This method is implemented by a primitive and is not overridden. Objects which are identical === should have the same hash values.

code::
a = "worth trying"; b = "worth trying";
a.identityHash;
b.identityHash;
::

method::instVarHash

Returns a combined hash value for the object's instance variables and the object's class. If none are given, all instance variables are tested (see also: link::#-compareObject::).


code::
a = Pseq([1, 2, 3], inf); b = Pseq([100, 200, 300], inf);

a.instVarHash([\repeats]); // same
b.instVarHash([\repeats]);

a.instVarHash([\list]); // different
b.instVarHash([\list]);

a = Pseq([1, 2, 3], inf); b = Prand([1, 2, 3], inf);
a.instVarHash([\list]); // different
b.instVarHash([\list]);
::


subsection::Testing

method::isNil

Answer a Boolean indicating whether the receiver is nil.

method::notNil

Answer a Boolean indicating whether the receiver is not nil.

method::isNumber

Answer a Boolean indicating whether the receiver is an instance of Number.

method::isInteger

Answer a Boolean indicating whether the receiver is an instance of Integer.

method::isFloat

Answer a Boolean indicating whether the receiver is an instance of Float.

method::?

If the receiver is nil then answer anObject, otherwise answer the receiver.

method::??

If the receiver is nil, evaluate the link::Classes/Function:: and return the result.

method::!?

If the receiver is not nil, evaluate the link::Classes/Function:: passing in the receiver as argument and return the result, otherwise return nil.

note::
The function will be inlined if it contains no variables or arguments.
::

discussion::
This method allow building up chains of actions to be performed on an object (possibly across several methods) without having to check if the object is nil or not. After all the desired actions are performed, link::#-??:: can be used to check if result the result is nil and supply a default value in that case.

Examples:
code::
x !? ( _ * 3 ) ?? { "It was a nil, so I give a default value".postln; Point(1,1) }
::
With code::x = nil::, this will result in:
teletype::
It was a nil, so I give a default value
Point( 1, 1 )
::
But if code::x = Point(3,4)::, the result will be:
teletype::
Point( 9, 12 )
::

Nested nil checks:
code::
(
x = nil;
y = Point(3,4);
z = Point(5,6);
x !? { |x| y !? { |y| z !? { |z|  x.rho * y.rho * z.rho } } }
)
::
Results in teletype::nil::
code::
(
x = Point(1,2);
y = Point(3,4);
z = Point(5,6);
x !? { |x| y !? { |y| z !? {  |z| x.rho * y.rho * z.rho } } }
)
::
Results in teletype::87.321245982865::

method::pointsTo

Returns true if receiver has a direct reference to obj.

code::
a = 9;
b = [1, a, 6, 8];
c = [1, b, 5];
c.pointsTo(b); // true
c.pointsTo(a); // false
::

method::mutable

Returns true if receiver is mutable.

code::
a = #[1, 2, 3]; b = [1, 2, 3];
a.mutable; // false
b.mutable; // true
::

method::frozen

Returns true if receiver is frozen.

method::switch

Object implements a switch method which allows for conditional evaluation with multiple cases. These are implemented as pairs of test objects (tested using if this == test.value) and corresponding functions to be evaluated if true. In order for switch to be inlined (and thus be as efficient as nested if statements) the matching values must be literal Integers, Floats, Chars, Symbols and the functions must have no variables or arguments.

discussion::
code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
switch (z.choose.postln,
	1,   { \no },
	1.1, { \wrong },
	1.3, { \wrong },
	1.5, { \wrong },
	2,   { \wrong },
	0,   { \true }
).postln;
)
::

or:

code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
x = switch (z.choose)
	{1}   { \no }
	{1.1} { \wrong }
	{1.3} { \wrong }
	{1.5} { \wrong }
	{2}   { \wrong }
	{0}   { \true };
x.postln;
)
::

subsection::Messaging

Instead of directly sending a method to an object, a method may be invoked given a method selector only (a Symbol). The other arguments may be provided by passing them directly, from an environment. If it is not known whether the receiver implements the method, tryPerform only sends if it does, and superPerform invokes the method of the superclass.


method::perform

The selector argument must be a Symbol. Sends the method named by the selector with the given arguments to the receiver.

If the first argument is an Array or List, this method behaves like code::performMsg::. However, this usage is discouraged, and code::performMsg:: ought to be used instead.

method::performList

The selector argument must be a Symbol. Sends the method named by the selector with the given arguments to the receiver. If the last argument is a List or an Array, then its elements are unpacked and passed as arguments.

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performList(\value, [1, 2, 3]);
::

method::performMsg

The argument must be a List or Array whose first element is a Symbol representing a method selector. The remaining elements are unpacked and passed as arguments to the method named by the selector.

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performMsg([\value, 1, 2, 3]);
::

method::performWithEnvir

argument:: selector
A Symbol representing a method selector.
argument:: envir
The remaining arguments derived from the environment and passed as arguments to the method named by the selector.
discussion::
code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performWithEnvir(\value, (a: 1, c: 3, d: 4, b: 2));
::

method::performKeyValuePairs

argument:: selector
A Symbol representing a method selector.
argument:: pairs
Array or List with key-value pairs.
discussion::
code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performKeyValuePairs(\value, [\a, 1, \b, 2, \c, 3, \d, 4]);
::

method::tryPerform

Like 'perform', but tryPerform passes the method to the receiver only if the receiver understands the method name. If the receiver doesn't implement that method, the result is nil. Note that this does not catch errors like 'try' does (see Exception). If the receiver does have a matching method but that method throws an error, execution will halt. But, 'tryPerform' is faster than 'try'.

code::
(a: 1, b: 2, c: 3).tryPerform(\keysValuesDo, { |key, value| [key, value].postln });

// Set does not understand keysValuesDo -- result is nil
Set[1, 2, 3].tryPerform(\keysValuesDo, { |key, value| [key, value].postln });

// Error occurs within keysValuesDo -- error is thrown back to halt execution
(a: 1, b: 2, c: 3).tryPerform(\keysValuesDo, { |key, value| [key, value].flippityblargh });
::

method::superPerform

Like perform, superPerform calls a method, however it calls the method on the superclass.
selector: A Symbol representing a method selector.
args: Method arguments.


method::superPerformList

Like performList, superPerformList calls a method, however it calls the method on the superclass.
selector: A Symbol representing a method selector.
args: Method arguments. If the last argument is a List or an Array, then its elements are unpacked and passed as arguments.

method::multiChannelPerform
Perform selector with multichannel expansion. See also: link::Guides/Multichannel-Expansion::.

argument:: selector
A Symbol representing a method selector.
argument:: ... args
Method arguments which, if they contain an array, will call the method multiple times for each sub-element.
discussion::
code::
a = { |a, b, c| format("% plus % times % is %", a, b, c, a + b * c).quote; };
a.multiChannelPerform(\value, [1, 10, 100, 1000], [2, 7, 9], [3, 7]);

["foo","bar"].multiChannelPerform('++',["l","bro","t"]);
::

subsection::Unique Methods

Method definitions not yet implemented may be added to an Object instance.

method::addUniqueMethod

Add a unique method.

code::
a = 5;
a.addUniqueMethod(\sayHello, { |to| "hello " ++ to ++ ", I am 5" });
a.sayHello;
::

method::removeUniqueMethod

Remove a unique method.

code::
a.removeUniqueMethod(\sayHello);
a.sayHello;
::

method::removeUniqueMethods

Remove all unique methods of an Object.

subsection::Dependancy

method::addDependant

Add aDependant to the receiver's list of dependants.

method::removeDependant

Remove aDependant from the receiver's list of dependants.

method::dependants

Returns an IdentitySet of all dependants of the receiver.

method::changed

Notify the receiver's dependants that the receiver has changed. The object making the change should be passed as theChanger.

method::update

An object upon which the receiver depends has changed. theChanged is the object that changed and theChanger is the object that made the change.

method::release

Remove all dependants of the receiver. Any object that has had dependants added must be released in order for it or its dependants to get garbage collected.

subsection::Error Support

Object implements a number of methods which throw instances of Error. A number of methods (e.g. doesNotUnderstand) are 'private' and do not normally need to be called directly in user code. Others, such as those documented below can be useful for purposes such as object oriented design (e.g. to define an abstract interface which will be implemented in subclasses) and deprecation of methods. The reserved keyword thisMethod can be used to refer to the enclosing method. See also Method and Function (for exception handling).

method::throw

Throws the receiver as an Exception, which may or may not be caught and handled by any enclosing Function.

method::subclassResponsibility

Throws a SubclassResponsibilityError. Use this to indicate that this method should be defined in all subclasses of the receiver.

discussion::
code::
someMethod {
	this.subclassResponsibility(thisMethod);
}
::

method::shouldNotImplement

Throws a ShouldNotImplementError. Use this to indicate that this inherited method should not be defined or used in the receiver.

method::deprecated

Throws a DeprecatedError. Use this to indicate that the enclosing method has been replaced by a better one (possibly in another class), and that it will likely be removed in the future. Unlike other errors, DeprecatedError only halts execution if code::Error.debug == true::. In all cases it posts a warning indicating that the method is deprecated and what is the recommended alternative.

discussion::
code::
foo {
	this.deprecated(thisMethod, ThisOrSomeOtherObject.findMethod(\foo);
	... // execution of this method will continue unless Error.debug == true
}

// For a class method:
*bar {
	this.deprecated(thisMethod, OtherClass.class.findMethod(\bar));
	...
}
::

subsection::Printing and Introspection

method::post

Print a string representation of the receiver to the post window.
code::
"hello".post; "hello".post; "";
::

method::postln

Print a string representation of the receiver followed by a newline.
code::
"hello".postln; "hello".postln; "";
::

method::postc

Print a string representation of the receiver preceded by comments.
code::
"hello".postc; "hello".postc; "";
::

method::postcln

Print a string representation of the receiver preceded by comments, followed by a newline.
code::
"hello".postcln; "hello".postcln; "";
::

method::postcs

Print the compile string representation of the receiver, followed by a newline.
code::
"hello".postcs; "hello".postcs; "";
::

method::dump

Print a detailed low level representation of the receiver to the post window.
code::
List[1, 2, 3].dump;
::

subsection::System Information

method::gcInfo

Posts garbage collector information in a table format.

discussion::
list::
## flips: the number of times the GC "flipped", i.e. when it finished incremental scanning of all reachable objects
## collects: the number of partial collections performed
## nalloc: total number of allocations
## alloc: total allocation in bytes
## grey: the number of "grey" objects, i.e. objects that point to reachable objects and are not determined to be (un)reachable yet
::

Then for each size class: numer of black, white and free objects, total number of objects and the total set size.

code::
flips 241  collects 689096   nalloc 40173511   alloc 322496998   grey 346541
0  bwf t sz:    882      0 368573   369455    2955640
1  bwf t sz:   6197    122 5702377   5708696   91339136
2  bwf t sz:    947      4 1500009   1500960   48030720
3  bwf t sz:   8056  65201 301800   375057   24003648
4  bwf t sz:   4047    145   3457     7649     979072
5  bwf t sz:    422      1    431      854     218624
6  bwf t sz:    124      2     72      198     101376
7  bwf t sz: 153504      1      0   153505   157189120
8  bwf t sz:     22      0      0       22      45056
9  bwf t sz:      5      0      0        5      20480
10  bwf t sz:      5      0      0        5      40960
12  bwf t sz:      2      0      0        2      65536
13  bwf t sz:      1      0      0        1      65536
19  bwf t sz:      1      0      3        4   16777216
tot bwf t sz: 174215  65476 7876722   8116413   341832120
::


You can also query the amount of free memory with code::Object.totalFree:: and dump the currently grey objects with code::Object.dumpGrey::. More memory status methods are: largestFreeBlock, gcDumpSet, and gcSanity.

subsection::Iteration

method::do

Object evaluates the function with itself as an argument, returning the result. Different classes respond to this message differently.
discussion::
code::
f = { |x, i| [x, i].postln; };
[1, 2, 3].do(f); // Array.do
10.do(f); // Integer.do
($Q).do(f); // Object.do
::

method::generate

Object iterates by the message do, sent to the receiver.
This method is used internally by list comprehensions.

method::dup

Duplicates the receiver n times, returning an array of n copies. Different classes respond to this message differently.  The shortcut "!" can be used in place.
discussion::
code::
8.dup(10);
8 ! 10; // same as above
x = [[1], [2], [3]].dup(5);
x[0] === x[1]; // false: copies receiver.
x[0][0] === x[1][0] // true: doesn't deepCopy receiver
{ 1.0.rand }.dup(5) // other objects respond differently to dup
::

subsection:: Scheduling

method:: awake

This method is called by a link::Classes/Clock:: on which the object was
scheduled when its scheduling time is up. It calls link::#-next::, passing
on the scheduling time in beats as an argument.

argument:: beats
The scheduling time in beats. This is equal to the current logical time
(link::Classes/Thread#-beats::).

argument:: seconds
The scheduling time in seconds. This is equal to the current logical time
(link::Classes/Thread#-seconds::).

argument:: clock
The clock on which the object was scheduled.


subsection:: Stream Support

method:: next

Does nothing; simply returns the object itself.

method:: reset

Does nothing; simply returns the object itself.





subsection::Routine Support

Objects support the basic interface of Stream, just returning itself in response to the following messages:
next, reset, stop, free, clear, removedFromScheduler, asStream.

method::yield

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The result of yield will be the value passed to the Routine's next method the next time it is called.

method::yieldAndReset

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The Routine is reset so that the next time it is called, it will start from the beginning. yieldAndReset never returns within the Routine.

method::alwaysYield

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The Routine, when called subsequently will always yield the receiver until it is reset. alwaysYield never returns within the Routine.

method::embedInStream

Yields the receiver

method::idle

within a routine, return values (the receiver) until this time is over. (see also link::Classes/Routine#-play::)
Time is measured relative to the thread's clock.
code::
a = Routine { 1.yield; 0.idle(3); 400.yield };
fork { loop { a.next.postln; 0.5.wait } };
::

method::iter

Returns a link::Classes/OneShotStream:: with the receiver as return value.
code::
a = 9.iter;
a.nextN(4);
::

method::cyc

Embeds the receiver in the stream n times (default: inf), each time resetting it.
code::
a = 9.cyc(2);
a.nextN(4);
::

method::fin

Calls next with the receiver n times only (default: 1), yielding the result.
code::
a = (10..0).iter.fin(2);
a.nextN(4);
::

method::repeat

Repeatedly embeds the receiver in the stream using a Pn (may thus be used for patterns and other objects alike)
code::
a = (0..3).iter.repeat(2);
a.nextN(9)
::

method::loop

Indefinitely embeds the receiver in the stream

code::
a = (0..3).iter.loop;
a.nextN(9)
::

method:: nextN

Returns an array with the results of calling link::#-next:: a given number of times

argument:: n

Number of message calls

argument:: inval

argument passed to the next message

code::
Routine { inf.do { |i| i.rand.yield } }.nextN(8)
::


method::streamArg
	Dependent on whether an object that is passed to a stream the object will behave differently: it may be embedded in the stream or used as stream directly.

	This method allows to switch between the two behaviors. For efficiency, the subclasses link::Classes/Pattern:: and link::Classes/Stream:: implement this method simply as "asStream".
	argument::embed
	If set to true, the object embeds itself into the stream (and thus return only once). If set to false, it returns itself forever. For simplicity, subclasses implement this method without this switch.


code::
// embedding an event
a = (z: 77);
b = Pset(\y, 8, a.streamArg(true)).asStream;
c = Pset(\y, 8, a.streamArg(false)).asStream;
b.nextN(3, ()); // this ends
c.nextN(3, ()); // this loops

// embedding a pattern
a = Pbind(\note, Pseq([1, 2]));
b = Pset(\y, 8, a.streamArg(true)).asStream;
c = Pset(\y, 8, a.streamArg(false)).asStream;
b.nextN(3, ()); // this ends
c.nextN(3, ()); // this ends, too
::


method::addFunc
method::addFuncTo
method::removeFunc
method::removeFuncFrom


The messages link::Classes/Function#-addFunc::  link::Classes/Function#-addFuncTo::, link::Classes/Function#-removeFunc::, link::Classes/Function#-removeFuncFrom:: are supported by Object.

method::instill
method::obtain
The messages link::Classes/SequenceableCollection#-instill:: and link::Classes/SequenceableCollection#-obtain::, are supported by Object.

subsection:: Math Support
method::blend
Lineraly interpolate between this and argument
code::
blend(10, 100, 0.3);
blend([1, 2, 3], [1, 3, 4], 0.5);
blend((a: 6, b: 7), (a: 0, b: [1, 2], c: 9), 0.5);
::


CLASS:: ObjectGui
summary:: Controller class for MVC architecture, superclass for all XYZGui classes
related:: Reference/gui
categories:: GUI

DESCRIPTION::
In the MVC architecture this is the Controller, which creates Views for manipulating the properties of your Model, and receives messages from the View and enacts the changes on the Model.

Each class specifies its Gui class via the guiClass method.

The default guiClass for an Object is ObjectGui.  So if a class does not implement guiClass at all, then at least there is a default ObjectGui that will display the name.

Many subclasses override the guiClass method to specify a different class, one that subclasses ObjectGui.

It is the simplest display, it is just the object asString.

The .gui method is called on your model:

code::
// standard usage
theModel.gui( parent, bounds )

// this results in these steps:
guiClass = theModel.guiClass;
gui = guiClass.new( theModel );
gui.gui( parent, bounds );
::

In addition to those steps the model/gui dependencies are managed, defaults (nil parent or nil bounds) are managed and when the window or parent view is closed then dependencies are safely managed.


CLASSMETHODS::

METHOD:: new
Create a gui controller object but does not yet create the views / window.  Call .gui to create the views.

argument:: model
The model is the object that the GUI is a graphical interface for.

returns:: the ObjectGui or subclass object


INSTANCEMETHODS::

METHOD:: guiBody
When implementing subclasses this is the primary and often the only method that needs to be implemented.  The ObjectGui parent class takes care of setting up all windows and dependencies and then the guiBody method adds views to the layout.  It is normal to declare instance variables in the ObjectGui subclass that are used to store the widgets so they can be updated later.

argument:: layout
Usually a FlowView : a parent view with a FlowLayout to add views to.

argument:: bounds
nil or a Rect.

argument:: ... args
More args may be passed here.

returns:: this

METHOD:: update
When the model is changed and the .changed method is called then .update is called on all dependants including this gui object.  Update the views you have placed in the guiBody.

argument:: theChanged
The model.  Within your gui class the model is already in the instance variable 'model'.

argument:: theChanger
Depends on the conventions of how .changed was called.  If an object called someModel.changed(this) then it is supplying itself as the changer and will be passed through here.  Sometimes a flag is used: someModel.changed('points') and the gui may know of and participate in that convention.  Sometimes no changer is passed in.


METHOD:: gui
The standard method to create a view / window.  Usually you call yourModel.gui(parent,bounds) and this creates the gui (of the related ObjectGui subclass) and then theObjectGui.gui(parent,bounds) is called, forwarding the arguments.  So this method is what receives the forwarded (parent,bounds) from the initial call to theModel.gui(parent,bounds). Usually you do not call this manually and would avoid reimplementing it.

argument:: parent
parent view : nil, a Window, a FlowView or any other usable container view.

argument:: bounds
nil or a Rect.  The default of nil will offer the entire bounds to the guiBody method and then shrink the view size afterwards to the exact size of the contents that were actually added.

argument::  ... args
More args may be passed into theModel.gui(parent,bounds,anArg,moreArg) and will be forwarded to guiBody.

returns:: this

METHOD:: guify
This converts a supplied parent and bounds into a usable parent container view on a window.  It creates a window if needed.

argument:: parent
parent view or nil

argument:: bounds
desired bounds or nil

argument:: title
window title IF a new window is being created.  if there is a parent view then title is ignored.

returns:: converted parent


METHOD:: model
set a new model. This allows to use a single gui and dynamically swap in a different model of the same class.  The old model releases the gui as a dependant and the new model adds the gui as a dependent.  Then the views are updated.

argument:: newModel
The new object

returns:: (returnvalue)

METHOD:: dragSource
The default implementation of writeName places a nameplate on the gui that is draggable.  This method is an accessor for that dragSource object.

returns:: a GUi.dragSource

METHOD:: viewDidClose
This is called when the parent view closes. It releases dependants.

returns:: this

METHOD:: background
Each ObjectGui subclass may implement a default background color.

returns:: a color

METHOD:: writeName
ObjectGui by default makes a nameplate with the name of the model.  Implement this in subclasses if a different name style or no nameplate is desired.  Note: this may change in the near future.  So many classes override this to shut off the name.

argument:: layout
The layout to place the nameplate on.  Probably the same as is being passed to guiBody

METHOD:: prWriteName
The default write name implementation.  You could call this from a subclass if you are primarily implementing writeName to customize what name is shown or to add other items to that area.

argument:: layout
the layout

argument:: name
the string to display


EXAMPLES::

code::

YourSimpleGuiClass : ObjectGui {

	guiBody { arg layout;
	
		// we refer to the model and
		// access its variable howFast.
		// if its a simple number, it will display
		// using the default ObjectGui class, which
		// will simply show its value as a string.
		model.howFast.gui(layout);
	}
}


// more complex
YourGuiClass : ObjectGui {
	
	var numberEditor;
	
	//for example
	guiBody { arg layout;
		var r;
		// the object you are making a gui for is referred to as the model
		
		// display some param on screen.
		// here we assume that someParam is something that
		//  has a suitable gui class
		// implemented, or that the default ObjectGui is sufficient.
		model.someParam.gui(layout);
		
		// using non 'gui' objects
		r = layout.layRight(300,300); // allocate yourself some space
		Button(layout.win,r)
			.action_({ arg butt;
				model.goApeShit;
			});
		
		// note: NumberEditor is a cruciallib class
		// which is itself a model (its an editor of a value)
		// and has its own gui class that creates and manages the NumberBox view
		numberEditor = NumberEditor(model.howFast,[0,100])
			.action_({ arg val; 
				model.howFast = val; 
				model.changed(this); 
				// tell the model that this gui changed it
			});
		numberEditor.gui(layout);
	}
	
	// your gui object will have update called any time the .changed message
	// is sent to your model
	update { arg changed,changer;
	
		if(changer !== this,{ 
			/* if it is this gui object that changed the value
				using the numberEditor, then we already have a correct
				display and don't need to waste cpu to update it.
				if anyone else changed anything about the model,
				we will update ourselves here.
			*/
			numberEditor.value = model.howFast;
			/*
				note that 
					numberEditor.value = model.howFast;
				is passive, and does not fire the numberEditor's action.	

				numberEditor.activeValue = model.howFast
				would fire the action as well, resulting in a loop that would
				probably crash your machine.
			*/
		}
	}

}
::


CLASS::ObjectTable
summary::associate objects with IDs
categories:: Collections>Unordered

DESCRIPTION::
An ObjectTable is used to associate an id with an object. This is useful
for enabling references to objects on remote systems via Open Sound Control.

CLASSMETHODS::

private::initClass

method::add
Put an object in the main ObjectTable and generate an Integer id.
argument::obj
the object to put in the table.

method::put
Put an object in the main ObjectTable under a specific key.
argument::key
a link::Classes/Symbol::.
argument::obj
the object to put in the table.

method::at
Get an object in the main ObjectTable.
argument::id
an link::Classes/Integer:: or link::Classes/Symbol::.

method::getID
Get the ID of an object in the table.
argument::obj
an object in the table.

INSTANCEMETHODS::

method::add
Put an object in an ObjectTable and generate an Integer id.
argument::obj
the object to put in the table.


class:: OffsetOut
summary:: Write a signal to a bus with sample accurate timing.
related:: Classes/Out, Classes/ReplaceOut, Classes/XOut
categories::  UGens>InOut


Description::

Output signal to a bus,  the sample offset within the bus is kept
exactly; i.e. if the synth is scheduled to be started part way through a
control cycle, OffsetOut will maintain the correct offset by buffering
the output and delaying it until the exact time that the synth was
scheduled for.


For achieving subsample accuracy see  link::Classes/SubsampleOffset::

note::

Note that if you have an input to the synth, it will be coming in and
its normal time, then mixed in your synth, and then delayed with the
output. So you shouldn't use OffsetOut for effects or gating.

::

See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("help-OffsetOut",
	{ arg out=0, freq=440, dur=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction: Done.freeSelf);
		OffsetOut.ar(out, SinOsc.ar(freq, 0, env))
}).send(s);

SynthDef("help-Out",
	{ arg out=0, freq=440, dur=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction: Done.freeSelf);
		//compare to Out:
		Out.ar(out, SinOsc.ar(freq, 0, env))
}).send(s);
)


// these are in sync
(
Routine({
	loop {
		s.sendBundle(0.2, ["/s_new", "help-OffsetOut", -1]);
		0.01.wait;
	}
}).play;
)

// these are less reliably in sync and are placed at multiples of blocksize.
(
Routine({
	loop {
		s.sendBundle(0.2, ["/s_new", "help-Out", -1]);
		0.01.wait;
	}
}).play;
)



SynthDef("trig1",{
	var gate,tone;
	gate = Trig1.ar(1.0,t);
	tone = In.ar(10,1); // tone comes in normally
	// but is then delayed when by the OffsetOut
	OffsetOut.ar(0,
		tone * EnvGen.ar(
				Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
				gate,doneAction: Done.freeSelf
			)
	)
})

::



class:: OnError
summary:: register functions to be evaluated when an error occurs
related:: Classes/StartUp, Classes/ShutDown, Classes/ServerQuit, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
OnError registers functions to perform an action when an error occurs.

ClassMethods::

method::run
Call the object in order.


class:: OnePole
summary:: One pole filter.
related:: Classes/OneZero
categories::  UGens>Filters>Linear


Description::

A one pole filter. Implements the formula:

code::

out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1)).

::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Feedback coefficient. Should be between -1 and +1


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ OnePole.ar(WhiteNoise.ar(0.5), 0.95) }.play

{ OnePole.ar(WhiteNoise.ar(0.5), -0.95) }.play

{ OnePole.ar(WhiteNoise.ar(0.5), Line.kr(-0.99, 0.99, 10)) }.play

::



class:: OneZero
summary:: One zero filter.
related:: Classes/OnePole
categories::  UGens>Filters>Linear


Description::

A one zero filter. Implements the formula:

code::

out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1)).

::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Feed forward coefficient.


+0.5 makes a two point averaging filter
(see also
link::Classes/LPZ1:: ).


-0.5 makes a differentiator
(see also
link::Classes/HPZ1:: ).


+1 makes a single sample delay
(see also
link::Classes/Delay1:: ).


-1 makes an inverted single sample delay.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ OneZero.ar(WhiteNoise.ar(0.5), 0.5) }.play

{ OneZero.ar(WhiteNoise.ar(0.5), -0.5) }.play

{ OneZero.ar(WhiteNoise.ar(0.5), Line.kr(-0.5, 0.5, 10)) }.play

::



class:: Onsets
summary:: Onset detector
categories:: UGens>Analysis
related:: Classes/BeatTrack, Classes/Loudness, Classes/MFCC, Classes/Pitch, Classes/KeyTrack

description::
An onset detector for musical audio signals - detects the beginning of notes/drumbeats/etc. Outputs a control-rate trigger signal which is 1 when an onset is detected, and 0 otherwise.

For more details of all the processes involved, the different onset detection functions, and their evaluation, see:

D. Stowell and M. D. Plumbley. Adaptive whitening for improved real-time audio onset detection. emphasis::Proceedings of the International Computer Music Conference (ICMC2007)::, Copenhagen, Denmark, August 2007. See
http://c4dm.eecs.qmul.ac.uk/papers/2007/StowellPlumbley07-icmc.pdf

classmethods::
private:: categories

method:: kr

argument:: chain
an FFT chain.
argument:: threshold
the detection threshold, typically between 0 and 1, although in rare cases you may find values outside this range useful.
argument:: odftype
chooses which emphasis::onset detection function:: is used. In many cases the default will be fine. More choices are listed below.

The remaining args are all tweak factors, explained below in section Advanced features:

argument:: relaxtime
argument:: floor
argument:: mingap
argument:: medianspan
argument:: whtype
argument:: rawodf

Discussion::

	The following choices are available for code::odftype:: :

definitionlist::
## code::\power:: || generally OK, good for percussive input, and also very efficient
## code::\magsum:: || generally OK, good for percussive input, and also very efficient
## code::\complex:: || performs generally very well, but more CPU-intensive
## code::\rcomplex:: || performs generally very well, and slightly more efficient than code::\complex::
## code::\phase:: || generally good, especially for tonal input, medium efficiency
## code::\wphase:: || generally very good, especially for tonal input, medium efficiency
## code::\mkl:: || generally very good, medium efficiency, pretty different from the other methods
::


For the FFT chain, you should typically use a frame size of 512 or 1024 (at 44.1 kHz sampling rate) and 50% hop size (which is the default setting in SC). For different sampling rates choose an FFT size to cover a similar time-span (around 10 to 20 ms).

The onset detection should work well for a general range of monophonic and polyphonic audio signals. The onset detection is purely based on signal analysis and does not make use of any "top-down" inferences such as tempo.

Which onset detection function should you choose? The differences aren't large, so I'd recommend you stick with the default code::\rcomplex:: unless you find specific problems with it. Then maybe try code::\wphase::. The code::\mkl:: type is a bit different from the others so maybe try that too. They all have slightly different characteristics, and in tests perform at a similar quality level.

subsection:: Advanced features

Further options are available, which you are welcome to explore if you want. They are numbers that modulate the behaviour of the onset detector:

list::
## strong::relaxtime:: and strong::floor:: are parameters to the whitening process used, a kind of normalisation of the FFT signal. (Note: in \mkl mode these are not used.)
	list::
	## strong::relaxtime:: specifies the time (in seconds) for the normalisation to "forget" about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then you might wish to increase this value.
	## strong::floor:: is a lower limit, connected to the idea of how quiet the sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded classical music with wide dynamic variations, I found it helpful to go down as far as 0.000001.
	::
## strong::mingap:: specifies a minimum gap (in FFT frames) between onset detections, a brute-force way to prevent too many doubled detections.
## strong::medianspan:: specifies the size (in FFT frames) of the median window used for smoothing the detection function before triggering.
::

examples::
code::

////////////////////////////////////////////////////////////////////////////////////////////////
// Move the mouse to vary the threshold
(
x = {
	var sig, chain, onsets, pips;

	// A simple generative signal
	sig = LPF.ar(Pulse.ar(TIRand.kr(63, 75, Impulse.kr(2)).midicps), LFNoise2.kr(0.5).exprange(100, 10000)) * Saw.ar(2).range(0, 1);
	// or, uncomment this line if you want to play the buffer in
	//sig = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);

	chain = FFT(LocalBuf(512), sig);

	onsets = Onsets.kr(chain, MouseX.kr(0,1), \rcomplex);

	// You'll hear percussive "ticks" whenever an onset is detected
	pips = WhiteNoise.ar(EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));
	Pan2.ar(sig, -0.75, 0.2) + Pan2.ar(pips, 0.75, 1)
}.play;
)
x.free; // Free the synth

////////////////////////////////////////////////////////////////////////////////////////////////
// Or we could expand this multichannel, run a series of different thresholds at the same time,
// to sonify the effect of the threshold value.
// A little hard to listen to at first: try and identify a pitch at which the best sort of
// detection is happening.
// You'll hear "bobbling" at low pitches where the threshold is definitely too low.

(
var threshes = (0.1, 0.2 .. 1);
x = {
	var sig, chain, onsets, pips;

	// A simple generative signal
	sig = LPF.ar(Pulse.ar(TIRand.kr(63, 75, Impulse.kr(2)).midicps), LFNoise2.kr(0.5).exprange(100, 10000)) * Saw.ar(2).range(0, 1);
	// or, uncomment this line if you want to play the buffer in
	//sig = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);

	chain = FFT(LocalBuf(512), sig);

	onsets = Onsets.kr(chain, threshes, \rcomplex);

	// Generate pips at a variety of pitches
	pips = SinOsc.ar((threshes).linexp(0, 1, 440, 3520), 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.5), onsets)).mean;
	Pan2.ar(sig, -0.75, 0.2) + Pan2.ar(pips, 0.75, 1)
}.play;
)

x.free; // Free the synth
[b, d].do(_.free); // Free the buffers
::


TITLE:: Operand
summary::Idempotent wrapper around math operations
categories:: Core
related:: Classes/AbstractFunction, Classes/Maybe, Classes/Ref, Classes/Rest

DESCRIPTION::
If you need to ensure that math operations always return the result wrapped in a specific object, you can use Operand or subclass from it.
For some practical examples, see its subclass link::Classes/Rest::. If you need to keep nested operations, use link::Classes/Maybe::.


Its creation is idempotent, that is code::Operand(Operand(x)) == Operand(x)::.


code::
// An Operand is an Operand is an Operand
Operand(Operand(Operand(1))) - 1 == 0
::

code::
// math operations
a = Operand(2);
b = Operand([1, 2, 3]);
c = a + b * a; // Operand([ 6, 8, 10 ])
c.value; // [ 6, 8, 10 ]
::

CLASSMETHODS::

METHOD:: new
argument:: value
Return a new instance of Operand, using an arbitrary object as value.

code::
a = Operand(1) + 7; // returns Operand(8)

// the *new method is idempotent:
Operand(Operand(Operand(1))) == Operator(1)
::


INSTANCEMETHODS::

PRIVATE:: composeBinaryOp, composeNAryOp, composeUnaryOp, performBinaryOpOnComplex, performBinaryOpOnSeqColl, performBinaryOpOnSignal, performBinaryOpOnSimpleNumber, reverseComposeBinaryOp

METHOD:: value
Set or return the current value.

code::
a = Operand(2) ** 8;
a.value; // 256
a.value = 78;
a.value; // 78
::

METHOD:: ==
argument:: obj
An Operand is equal to another one if their value are equal.
code::
Operand(1) == Operand(1);
Operand(1) + 2 == Operand(3);
::

METHOD:: hash
Two instances with the same value return the same hash value.
code::
Set[Operand(1), Operand(1)] == Set[Operand(1)] // true
::

METHOD:: dereferenceOperand
This method is called to avoid nesting. You may override it in subclasses to perform actions on resulting values.
code::Operand(Operand(1)) // Operand(1)::.



EXAMPLES::

code::
// you could make a class that always converts values to integers:

IntegerOperand : Operand {
	dereferenceOperand {
		^value.asInteger
	}
}

// then you would get:
IntegerOperand(1) + pi == IntegerOperand(4)
::





CLASS::Order
summary::an order of elements with a numerical index
related::Classes/SparseArray
categories:: Collections>Ordered

DESCRIPTION::
Keeps elements in an order and allows to put them at arbitrary slots
without having to allocate a large array.

note::
link::#-put:: and link::#-at:: are slower than in link::Classes/IdentityDictionary:: / link::Classes/PriorityQueue::, link::#-do:: is faster.
::

CLASSMETHODS::

method::new
Create a new order.
code::
g = Order.new;
g.put(7, 100); // put a value (100) at index 7
g.clear; // empty
::

method::newFromIndices
Create a new order from given items and indices.

INSTANCEMETHODS::

private::resetIndices, nextSlotFor, slotFor, prPutSlot

method::doRange
Iterate over a range of the order's items.

method::pos
Return the current write position.

EXAMPLES::

code::
a = Order.new;

a[0] = \z;
a[0] = \y;
a[5] = \five;
a[4] = \four;

a[0] = \z;
a[5] = \five;
a[4] = \four;

a.indices;

a[9] = 100;
a.indices;
::


CLASS::OrderedIdentitySet
summary::a set according to identity
related::Classes/IdentitySet, Classes/List, Classes/Dictionary
categories::Collections>Ordered

DESCRIPTION::
An OrderedIdentitySet is a collection of objects, no two of which are the same object (aka. "identical").
Most of its methods are inherited. (see link::Classes/Collection:: and link::Classes/Set:: classes).
Unlike link::Classes/IdentitySet::, contents of an OrderedIdentitySet are ordered.

INSTANCEMETHODS::

private::putCheck

method::do
Evaluates strong::function:: for each item in the OrderedIdentitySet. You may depend on the order of items. The function is passed two arguments, the item and an integer index.
code::
OrderedIdentitySet[1, 2, 3, 300].do { |item, i| item.postln };
::


class:: Osc
summary:: Interpolating wavetable oscillator.
related:: Classes/COsc, Classes/OscN, Classes/VOsc, Classes/VOsc3, Classes/Wavetable
categories::  UGens>Generators>Deterministic


Description::

Linear interpolating wavetable lookup oscillator with frequency and
phase modulation inputs.


This oscillator requires a buffer to be filled with a wavetable format
signal. This preprocesses the Signal into a form which can be used
efficiently by the Oscillator. The buffer size must be a power of 2.


This can be achieved by creating a Buffer object and sending it one of
the "b_gen" messages ( link::Classes/Buffer#-sine1::, link::Classes/Buffer#-sine2::, link::Classes/Buffer#-sine3:: ) with the wavetable flag set
to true.


This can also be achieved by creating a link::Classes/Signal:: object and sending it
the 'asWavetable' message, thereby creating a Wavetable object in the required format. Then, the wavetable data may be transmitted to the server using the link::Classes/Buffer#*sendCollection:: or link::Classes/Buffer#*loadCollection:: methods.


classmethods::

method::ar, kr

argument::bufnum
Buffer index.

argument::freq
Frequency in Hertz.

argument::phase
Phase offset or modulator in radians.
(Note: phase values should be within the range +-8pi. If your phase values are larger then simply use code::.mod(2pi):: to wrap them.)

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, 200, 0, 0.5)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, XLine.kr(2000,200), 0, 0.5)// modulate freq
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)


(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum,
			Osc.ar(bufnum,
				XLine.kr(1,1000,9),
				0,
				200,
				800),
			0,
			0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)


(
// modulate phase
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum,
				800,
				Osc.ar(bufnum,
						XLine.kr(20,8000,10),
						0,
						2pi),
				0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)



(
// change the buffer while its playing
s = Server.local;
b = Buffer.alloc(s, 4096, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, [80,80.2], 0, 0.2)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
fork {
	var n = 32;
	50.do {
		b.sine1(Array.rand(n,0,1).cubed, true, true, true);
		0.25.wait;
	};
};
)

::



class:: OscN
summary:: Noninterpolating wavetable oscillator.
related:: Classes/COsc, Classes/Osc, Classes/VOsc, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

Noninterpolating wavetable lookup oscillator with frequency and phase
modulation inputs. It is usually better to use the interpolating
oscillator  link::Classes/Osc:: .


classmethods::

method::ar, kr

argument::bufnum
Buffer index.  the buffer size must be a power of 2.
The buffer should NOT be filled using Wavetable format (b_gen
commands should set wavetable flag to false. Raw signals (not
converted with asWavetable) can be saved to disk and loaded
into the buffer.


argument::freq
Frequency in Hertz.

argument::phase
Phase offset or modulator in radians.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// compare examples below with interpolating Osc examples.

(
s = Server.local;
b = Buffer.alloc(s,512,1);
b.sine1(1.0/[1,2,3,4,5,6],true,false,true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, 500, 0, 0.5)
	)
}).play(s,[0,0,1,b.bufnum]);

)
b.free;



(
// noninterpolating - there are noticeable artifacts
// modulate freq

s = Server.local;
b = Buffer.alloc(s,512,1);
b.sine1(1.0/[1,2,3,4,5,6].squared,true,false,true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, XLine.kr(2000,200), 0, 0.5)
	)
}).play(s,[\out,0,\bufnum,b.bufnum]);

)
b.free;

(
// sounds very different than the Osc example
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum,
			OscN.ar(bufnum,
				XLine.kr(1,1000,9),
				0,
				200,
				800),
			0,
			0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);

)
b.free;

(
// modulate phase
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum,
				800,
				OscN.ar(bufnum,
						XLine.kr(20,8000,10),
						0,
						2pi),
				0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)
b.free;


(
// change the buffer while its playing
s = Server.local;
b = Buffer.alloc(s, 4096, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, [80,80.2], 0, 0.2)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
Routine({
	var n = 32;
	50.do({
		b.sine1(Array.rand(n,0,1).cubed, true, true, true);
		0.25.wait;
	});
}).play;
)
b.free;

::



class:: Out
summary:: Write a signal to a bus.
related:: Classes/OffsetOut, Classes/ReplaceOut, Classes/XOut
categories::  UGens>InOut


Description::

Write a signal to a bus.


Note that using the Bus class to allocate a multichannel bus simply
reserves a series of adjacent bus indices with the Server object's bus
allocators. abus.index simply returns the first of those indices. When
using a Bus with an In or Out UGen there is nothing to stop you from
reading to or writing from a larger range, or from hardcoding to a bus
that has been allocated. You are responsible for making sure that the
number of channels match and that there are no conflicts.


note::

Out is subject to control rate jitter. Where sample accurate output is
needed, use  link::Classes/OffsetOut:: .

::

See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("help-out", { arg out=0, freq=440;
	var source;
		source = SinOsc.ar(freq, 0, 0.1);

		// write to the bus, adding to previous contents
		Out.ar(out, source);

}).add;
)


Synth("help-out", [\freq, 500]);
Synth("help-out", [\freq, 600]);
Synth("help-out", [\freq, 700]);

::



class:: OutputProxy
summary:: Place holder for multiple outputs
categories:: UGens>Base

Description::

OutputProxy is used by some UGens as a place holder for multiple outputs.
There is no reason for a user to create an OutputProxy directly.

code::
var out;
// Pan2 uses an OutputProxy for each of its two outputs.
out = Pan2.ar(WhiteNoise.ar, 0.0);
out.postln;
::

classmethods::
private:: categories

InstanceMethods::

method:: source
The UGen that is the source for this OutputProxy.
discussion::
code::
var left, right;
// Pan2 uses an OutputProxy for each of its two outputs.
# left, right = Pan2.ar(WhiteNoise.ar, 0.0);
left.source.postln;
::

The code::source:: method is also defined in Array, so that the source can be obtained this way as well:

code::
var out;
// Pan2 uses an OutputProxy for each of its two outputs.
out = Pan2.ar(WhiteNoise.ar, 0.0);
out.postln;
out.source.postln;
::



class:: PMOsc
summary:: Phase modulation oscillator pair.
categories::  UGens>Generators>Deterministic


Description::

Phase modulation sine oscillator pair.


classmethods::

method::ar, kr

argument::carfreq
Carrier frequency in cycles per second.

argument::modfreq
Modulator frequency in cycles per second.

argument::pmindex
The modulation index, representing the ratio of modulator deviation to modulator frequency. Higher values generally produce denser spectra.

argument::modphase
A modulation input for the modulator's phase in radians.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

play({ PMOsc.ar(Line.kr(600, 900, 5), 600, 3, 0, 0.1) }); // modulate carfreq

play({ PMOsc.ar(300, Line.kr(600, 900, 5), 3, 0, 0.1) }); // modulate modfreq

play({ PMOsc.ar(300, 550, Line.ar(0,20,8), 0, 0.1) }); // modulate index

(
e = Env.linen(2, 5, 2);
Routine.run({
	loop({
		play({
			LinPan2.ar(EnvGen.ar(e) *
				PMOsc.ar(2000.0.rand,800.0.rand, Line.kr(0.0, 12.0.rand,9),0,0.1), 1.0.rand2)});
		2.wait;
	})
}))

::


class:: PSinGrain
summary:: Very fast sine grain with a parabolic envelope
categories::  UGens>Generators>Deterministic


Description::

Very fast sine grain with a parabolic envelope.


classmethods::
private:: categories

method::ar

argument::freq

Frequency in Hertz.


argument::dur

Grain duration.


argument::amp

Grain amplitude.



class:: PV_Add
summary:: Complex addition.
related:: Classes/FFT, Classes/IFFT, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Complex addition:

code::

RealA + RealB, ImagA + ImagB

::


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-add", { arg out=0, soundBufnum;
	var inA, chainA, inB, chainB, chain ;
	inA = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	inB =  PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum) * 0.5, loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Add(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b.bufnum]);
)

b.free

::


class:: PV_BinScramble
summary:: Scramble bins.
categories:: UGens>FFT

Description::

Randomizes the order of the bins. The trigger will select a new random ordering.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Scrambles more bins as wipe moves from 0 to 1.


argument::width

A value from zero to one, indicating the maximum randomized
distance of a bin from its original location in the spectrum.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
//trig with MouseY
SynthDef("help-binScramble", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinScramble(chain, MouseX.kr , 0.1, MouseY.kr > 0.5 );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::


class:: PV_BinShift
summary:: Shift and stretch bin position.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagShift
categories:: UGens>FFT

Description::

Shift and scale the positions of the bins. Can be used as a very crude
frequency shifter/scaler.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::stretch

Scale bin location by factor.


argument::shift

Add an offset to bin position.

argument::interp

Set to 0 (default) for no interpolation, or 1 to linear-interpolate between bins.


Examples::

code::

s.boot;

(
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-binStretch", { arg out=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)

(
SynthDef("help-binStretch2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \soundBufnum, c.bufnum]);
)

(
SynthDef("help-binShift", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)

(
SynthDef("help-binShift2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \soundBufnum, c.bufnum]);
)

::



class:: PV_BinWipe
summary:: Combine low and high bins from two inputs.
categories:: UGens>FFT

Description::

Copies low bins from one input and the high bins of the other.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::wipe

Can range between -1 and +1.


If
code::wipe::  == 0, then the output is the same
as
code::bufferA:: .


If
code::wipe::  > 0, then it begins replacing
with bins from
code::bufferB::  from the bottom up.


If
code::wipe::  < 0, then it begins replacing
with bins from
code::bufferB::  from the top down.


Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-binWipe", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_BinWipe(chainA, chainB, MouseX.kr(-1, 1));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-binWipe2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_BinWipe(chainA, chainB, MouseX.kr(-1, 1));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)
::


class:: PV_BrickWall
summary:: Zero bins.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Clears bins above or below a cutoff point.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Can range between -1 and +1.


If
code::wipe::  == 0 then there is no effect.


If
code::wipe::  > 0 then it acts like a high
pass filter, clearing bins from the bottom up.


If
code::wipe::  < 0 then it acts like a low
pass filter, clearing bins from the top down.


Examples::

code::

s.boot;

(
{
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BrickWall(chain, SinOsc.kr(0.1));
	IFFT(chain);
}.play
)

::



class:: PV_ChainUGen
summary:: Base class for UGens that operate on FFT chains
categories:: UGens>FFT

description::
code::PV_ChainUGen:: is an abstract class, not used directly, but only its subclasses are. It represents phase-vocoder UGens - i.e. UGens which apply some kind of transformation to the frequency-domain signal produced by link::Classes/FFT::.

It encompasses all unit generators whose output is an FFT chain. This is why link::Classes/FFT:: is in this group but link::Classes/IFFT:: is not - the IFFT ugen outputs ordinary time-domain audio.

For more information on using these unit generators, see link::Guides/FFT-Overview::.

classmethods::
private:: categories

instancemethods::

private::addCopiesIfNeeded

method::fftSize
Returns the FFT chain buffer's size.

code::
(
{
	var chain = FFT(LocalBuf(1024));
	chain.fftSize.poll;
	0.0
}.play;
)
::


method:: pvcalc
pvcalc applies a function to the frequency-domain data of an FFT chain. See link::#-pvcollect:: below for discussion of efficiency considerations. See also link::#-pvcalc2:: below, and link::Classes/UnpackFFT::.

code::
chain = chain.pvcalc(numframes, func, frombin, tobin, zeroothers)
::


argument::numframes
Number of FFT frames to process

argument::func
The function that takes two arrays as inputs  (code::magnitude::, and code::phase::) and returns a resulting pair of arrays code::[magnitude, phase]::.
code::
// example function
{ | magnitudes, phases |
	[mags.reverse, phases.reverse] // e.g. upside-down spectrum
}
::

argument::frombin

Range start (optional)

argument::tobin

Range end (optional)

argument::zeroothers

If set to 1 then bins outside of the range being processed are silenced.



method::pvcalc2
The method pvcalc2 is just like link::#-pvcalc:: but can combine two FFT chains.

code::
chain = chain.pvcalc2(chain2, numframes, func, frombin, tobin, zeroothers)
::

argument::chain2
The scond FFT chain.

argument::numframes
Number of FFT frames to process

argument::func
The function that takes four arrays as inputs (magnitudes1, phases1, magnitudes2, phases2) and returns a resulting pair of arrays code::[magnitude, phase]::.
code::
// example function
{ | magnitudes1, phases1, magnitudes2, phases2 |
	[magnitudes1, phases2] // e.g. use the magnitudes of one, ane the phases of the other
}
::

argument::frombin

Range start (optional)

argument::tobin

Range end (optional)

argument::zeroothers

If set to 1 then bins outside of the range being processed are silenced.



method:: pvcollect
Process each bin of an FFT chain, separately, by applying a function to each bin of an FFT chain.

code::
chain = chain.pvcollect(numframes, func, frombin, tobin, zeroothers)
::

argument::numframes
Number of FFT frames to process

argument::func
The function that processes each bin. It should be a function that takes code:: magnitude, phase, bin, index :: as inputs and returns a resulting array code::[magnitude, phase]::.
code::
// example function
{ | magnitude, phase, bin, index |
	// randomize magnitudes somewhat (noisier signal)
	[magnitude * (5.0.rand2.dbamp), phase]
}
::

The strong::bin:: is the integer bin number, starting at 0 for DC, while strong::index:: is the iteration number, always starting with 0. You can optionally ignore the phase and only return a single (magnitude) value, in which case the phase is assumed to be left unchanged.

argument::frombin

Range start (optional)

argument::tobin

Range end (optional)

argument::zeroothers

If set to 1 then bins outside of the range being processed are silenced.


discussion::


Note that this procedure can be relatively CPU-heavy, depending on how you use it.
Using pvcollect (or its components, UnpackFFT & PackFFT) is usually less efficient than using a single "PV_" unit generator to process an FFT chain, because it involves the creation of quite a large graph of demand-rate unit generators.

If you wish to reduce the CPU impact of using this approach, try the following:
list::
## Use the frombin and tobin arguments to limit the number of FFT bins that will be included in the calculation. Often the lower FFT bins contain the loudest and/or most relevant information, so perhaps your effect sounds very similar if you ignore the higher-up bins (either leave them unprocessed, or discard them by setting the zeroothers argument to 1, which has the effect of a band-pass frequency-domain filter).
## Use a smaller FFT buffer size.
## Avoid creating ugens inside your calculation function if at all possible. For example, a deterministic ugen such as LFPar.kr(0.5, 0, 1) will be replicated once for each bin if specified inside the function, despite the fact that the output is always the same. Define it outside the calculation function and then reference it by variable name.
## Avoid unused calculations! For example, uncommenting all the different lines in the above will waste effort because many values will be calculated but not used. This cannot be optimised away during compilation. It is particularly important because all calculations are duplicated (once for each bin) so can have a significant impact on efficiency.
## If you find yourself calling pvcollect on an FFT chain more than once in series, you should definitely try to combine your processing into a single pvcollect function, to avoid unnecessary unpacking-then-packing-then-unpacking-then-packing.
::

Examples::

subsection:: pvcalc
code::
// a sound file
c.free; c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var in, chain, v;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(1024), in);

	chain = chain.pvcalc(1024, {|mags, phases|
//////// Try uncommenting each of these lines in turn and re-running the synth:
		[mags * {1.5.rand}.dup(mags.size), phases + {pi.rand}.dup(phases.size)]; // Arbitrary filter, arbitrary phase shift
		//[mags.reverse, phases.reverse]; // Upside-down!
		//[mags.differentiate, phases.differentiate]; // Differentiate along frequency axis
		//[mags[30..] ++ mags[..30], phases[30..] ++ phases[..30]]; // ".rotate" doesn't work directly, but this is equivalent
	}, frombin: 0, tobin: 250, zeroothers: 0);

	0.5 * IFFT(chain).dup
}.play
)
::

subsection:: pvcalc2
code::
c.free; c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
x = {
	var fftsize = 1024;
	var in, chain, in2, chain2, out;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(fftsize), in);

	// JMcC babbling brook
	in2 = ({
		RHPF.ar(OnePole.ar(BrownNoise.ar, 0.99), LPF.ar(BrownNoise.ar, 14)
			* 400 + 500, 0.03, 0.003) }!2)
			+ ({ RHPF.ar(OnePole.ar(BrownNoise.ar, 0.99), LPF.ar(BrownNoise.ar, 20)
			* 800 + 1000, 0.03, 0.005) }!2
		) * 4;
	chain2 = FFT(LocalBuf(fftsize), in2);

	chain = chain.pvcalc2(chain2, fftsize, { |mags, phases, mags2, phases2|
		[
			mags * mags2 / 10,
			phases2 + phases
		]
	}, frombin: 0, tobin: 125, zeroothers: 0);

	out = IFFT(chain);
	0.5 * out.dup
}.play
)
::

subsection:: pvcollect
code::
c.free; c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
{
	var in, chain, v;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(1024), in);

	v = LFPar.kr(0.5).range(0.1, 1);

	chain = chain.pvcollect(1024, {|mag, phase, index|

//////// Try uncommenting each of these lines in turn and re-running the synth:
		//mag;
		//[mag, phase];
		//[mag, phase] / 3;
		//[mag, phase].sqrt;
		//[mag, 3.14.rand];
		//[mag, LFNoise0.kr.range(0, 3.14)];
		//[mag * Dseq([1, 0, 0, 1, 1, 0, 1, 0].dupEach(8), 999999999999)]; // Can even use Demand ugens! One val demanded each frame
		//[mag.sqrt, 3.14.rand];
		//if(index % 7 == 0, mag, 0); // Comb filter
		//if(LFNoise0.kr(10) > 0.5, mag, 0);
		//mag + DelayN.kr(mag, 1, v); // Spectral delay

		if((index - LFPar.kr(0.1).range(2, 1024/20)).abs < 10, mag, 0); // Swept bandpass

	}, frombin: 0, tobin: 250, zeroothers: 0);

	0.5 * IFFT(chain).dup
}.play
)

::


class:: PV_ConformalMap
summary:: Complex plane attack.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Applies the conformal mapping

code::

z → (z - a) / (1 - za*)

::

to the phase vocoder bins z with a given by the real and imag inputs to
the UGen.


Makes a transformation of the complex plane so the output is full of
phase vocoder artifacts but may be musically fun. Usually keep

code::
|a| < 1
::
but
you can of course try bigger values to make it really noisy.

code::
a = 0
::
should
give back the input mostly unperturbed.


See  link::http://mathworld.wolfram.com/ConformalMapping.html:: .


classmethods::

method::new

argument::buffer

FFT buffer.


argument::areal

Real part of a.


argument::aimag

Imaginary part of a.


Examples::

code::

// explore the effect

(
SynthDef("conformer2", { |out|
	var in, chain, sound;
	in = Mix.ar(LFSaw.ar(SinOsc.kr(Array.rand(3,0.1,0.5),0,10,[1,1.1,1.5,1.78,2.45,6.7]*220),0,0.3));
	chain = FFT(LocalBuf(2048), in);
	chain = PV_ConformalMap(chain, MouseX.kr(0.01,2.0, 'exponential'), MouseY.kr(0.01,10.0, 'exponential'));
	sound = IFFT(chain);

	Out.ar(out, Pan2.ar(CombN.ar(sound, 0.1, 0.1, 10, 0.5, sound), 0, 0.3));
}).add;
)

a = Synth("conformer2")
a.free

// sound input: use headphones to prevent feedback
(
SynthDef("conformer1", { |out|
	var in, chain;
	in = SoundIn.ar(0, 0.5);
	chain = FFT(LocalBuf(1024), in);
	chain = PV_ConformalMap(chain, MouseX.kr(-1.0,1.0), MouseY.kr(-1.0,1.0));
	Out.ar(out, Pan2.ar(IFFT(chain), 0));
}).add;
)

a = Synth("conformer1")
a.free


::



class:: PV_Conj
summary:: Complex conjugate
categories:: UGens>FFT

description::
Converts the FFT frames to their complex conjugate (i.e. reverses the sign of their imaginary part). This is not usually a useful audio effect in itself, but may be a component of other analysis or transformation processes...

classmethods::
method:: new
argument:: buffer
FFT chain.

examples::
code::
s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
d = Buffer.alloc(s,2048,1);
)

(
SynthDef(\help_pvconj, {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_Conj(chain);
	// Original is left, conj is right
	Out.ar(out, 0.3 * [in, IFFT(chain)]);
}).play(s,[\out, 0, \bufnum, b, \soundBufnum, c]);
)

(
SynthDef(\help_pvconj2, {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chainA, chainB;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(bufnum, in);
	chainB = PV_Copy(chainA, d);
	chainB = PV_Conj(chainB);
	// Now we have the original and conjugate, what happens if we add them?
	Out.ar(out, 0.3 * (IFFT(PV_Add(chainA, chainB)).dup));
}).play(s,[\out, 0, \bufnum, b, \soundBufnum, c]);
)
::



class:: PV_Copy
summary:: Copy an FFT buffer
categories:: UGens>FFT

description::

Copies the spectral frame in code::bufferA:: to code::bufferB::. This allows for parallel processing of spectral data without the need for multiple FFT UGens. Further it allows to extract data at a given point in the FFT chain e.g. for monitoring purposes. 

note::As of SC 3.7 instances of PV_Copy are added automatically where necessary for parallel processing. Please see link::Guides/FFT-Overview:: for the current implementation. 

This document is provided for legacy purposes only. Existing code explicitly using PV_Copy should continue to work.::

classmethods::
method:: new
argument:: bufferA
source buffer.
argument:: bufferB
destination buffer.

note:: 
code::bufferA:: and code::bufferB:: must be the same size.
::

examples::

code::

// read a sound file
d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


// crossfade between original and magmul-ed whitenoise
(
{
	var in, in2, chain, chainB, chainC;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1) * 2;
	in2 = WhiteNoise.ar;
	chain = FFT(LocalBuf(2048), in);
	chainB = FFT(LocalBuf(2048), in2);
	chainC = PV_Copy(chain, LocalBuf(2048));
	chainB = PV_MagMul(chainB, chainC);
	XFade2.ar(IFFT(chain), IFFT(chainB) * 0.1, SinOsc.kr(0.2, 1.5pi));
}.play

)


// as previous but with Blip for 'vocoder' cross synthesis effect
(
{
	var in, in2, chain, chainB, chainC;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1) * 2;
	in2 = Blip.ar(100, 50);
	chain = FFT(LocalBuf(2048), in);
	chainB = FFT(LocalBuf(2048), in2);
	chainC = PV_Copy(chain, LocalBuf(2048));
	chainB = PV_MagMul(chainB, chainC);
	XFade2.ar(IFFT(chain), IFFT(chainB) * 0.1, SinOsc.ar(0.2));
}.play

)



// Spectral 'pan'
(
{
	var in, chain, chainB, pan;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chainB = PV_Copy(chain, LocalBuf(2048));
	pan = MouseX.kr(0.001, 1.001, 'exponential') - 0.001;
	chain = PV_BrickWall(chain, pan);
	chainB = PV_BrickWall(chainB, -1 + pan);
	IFFT([chain, chainB])
}.play
)

// free sound file buffer
d.free;





// proof of concept: copy has identical data
// global buffers for plotting the data
(
b = Buffer.alloc(s, 2048, 1);
c = Buffer.alloc(s, 2048, 1);
)

//  silently record some FFT data into the buffers
(
x = {
	var inA, chainA, chainB;
    inA = LFClipNoise.ar(100);
    chainA = FFT(b, inA);
    chainB = PV_Copy(chainA, c);
    IFFT(chainA) - IFFT(chainB); // proof of concept: cancels to zero
}.play;
)
x.free;

// IFFTed frames contain the same windowed output data
(
b.plot(\b, Rect(200, 430, 700, 300));
c.plot(\c, Rect(200, 100, 700, 300));
)

// free the buffers
[b, c].do(_.free);



// Multiple Magnitude plots



(
~fftSize = 2048;
~allBuffers = ();
~copyToBuffer = { |chain, name|
	var buffer = Buffer.alloc(s, ~fftSize);
	~allBuffers.put(name, buffer);
	PV_Copy(chain, buffer)
};
)

(
x = { var in, chain, chainB, chainC;
	in = WhiteNoise.ar;
	chain = FFT(LocalBuf(~fftSize), in);
	chain = ~copyToBuffer.(chain, 'initial'); // initial spectrum
	chain = PV_RectComb(chain, 20, 0, 0.2);
	chain = ~copyToBuffer.(chain, 'After RectComb'); // after comb
	2.do { chain = PV_MagSquared(chain) };
	chain = ~copyToBuffer.(chain, 'After MagSquared'); // after magsquared
	0.00001 * Pan2.ar(IFFT(chain)); // silently play back
}.play
)


x.free;

// post all buffers
(
~allBuffers.keysValuesDo { |name, buffer, i|
	buffer.getToFloatArray(action: { arg array;
		var z, x;
		// Initially, data is in complex form
		z = array.clump(2).flop;
		z = z.collect { |each| Signal.newFrom(each) };
		x = Complex(z[0], z[1]);
		{ x.magnitude.plot(name, Rect(200, 100 + (230 * i), 700, 200)) }.defer
	});
}
)

 // free the buffers and clean up
(
~allBuffers.do { |x| x.free };
~allBuffers = nil;
~copyToBuffer = nil;
)

::



class:: PV_CopyPhase
summary:: Copy magnitudes and phases.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Combines magnitudes of first input and phases of the second input.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-copyPhase", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	inB = WhiteNoise.ar(0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_CopyPhase(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-copyPhase2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	inB =  SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_CopyPhase(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);

)

::



class:: PV_Diffuser
summary:: Random phase shifting.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift90, Classes/PV_PhaseShift270
categories:: UGens>FFT

Description::

Adds a different constant random phase shift to each bin. When triggered, it selects a new set of random phases.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::trig

A trigger, that selects a new set of random values.


Examples::

code::



(
// trig with MouseY crossing center of screen
{
	var in, chain;
	in = Mix.ar(SinOsc.ar(200 * (1..10), 0, Array.fill(10, { rrand(0.1, 0.2) }) ));
	chain = FFT(LocalBuf(2048), in);
	chain = PV_Diffuser(chain, MouseY.kr > 0.5 );
	0.5 * IFFT(chain).dup;
}.play
);

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// trig with MouseY crossing center of screen
{
	var in, chain;
	in = PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_Diffuser(chain, MouseY.kr > 0.5 );
	0.5 * IFFT(chain).dup;
}.play
);

::



class:: PV_Div
summary:: Complex division
categories:: UGens>FFT
related:: Classes/PV_Mul, Classes/PV_MagDiv

classmethods::

method:: new
argument:: bufferA
fft buffer A.
argument:: bufferB
fft buffer B.

Examples::
In this example we estimate the transfer function of the LPF UGen. The transfer function is estimated by dividing the FFT of the output, by the FFT of the input, and looking at the magnitudes in the result.
code::
(
s.waitForBoot({
	var fftsize = 16384;
	b = Buffer.alloc(s, fftsize)
})
);


(
x = {
	// Any input should theoretically be OK, white noise is a good choice
	var son = WhiteNoise.ar;
//	var son = Impulse.ar;
	var out = LPF.ar(son, MouseX.kr(100, 10000, 1));
	var fft1 = FFT(LocalBuf(b.numFrames), son, wintype: 1);
	var fft2 = FFT(b, out, wintype: 1);

	// As with most PV_ ugens, the result is *actually* stored in the first fft buf
	var result = PV_Div(fft2, fft1);

	out.dup * 0.1
}.play;
)

// Now we can grab the FFT buffer and peek at the magnitudes
(
p = Plotter.new;
t = Task {
	loop {
		0.1.wait;
		b.loadToFloatArray(action: {|data|
			{
			p.value = data[2..]
				.clump(2)
				.collect {|a| a[0].squared + a[1].squared }
				.collect {|a| if(a.isNaN) { 0.post } { a } }
		}.defer
		})
}}.play;
)
::



class:: PV_HainsworthFoote
summary:: FFT onset detector.
related:: Classes/PV_JensenAndersen
categories::  UGens>FFT


Description::

FFT onset detector based on work described in emphasis:: Hainsworth, S. (2003) Techniques for the Automated Analysis of Musical Audio. PhD, University of Cambridge engineering dept. ::
See especially p128. The Hainsworth metric is a modification of the Kullback Liebler
distance.


The onset detector has general ability to spot spectral change, so may
have some ability to track chord changes  aside from obvious transient
jolts, but there's no guarantee it won't be confused by frequency
modulation artifacts.


Hainsworth metric on it's own gives good results but Foote might be
useful in some situations: experimental.


classmethods::
private:: categories

method::ar

argument::buffer

FFT buffer.


argument::proph

What strength of detection signal from Hainsworth metric to use.


argument::propf

What strength of detection signal from Foote metric to use. The
Foote metric is normalised to (0..1).


argument::threshold

Threshold hold level for allowing a detection.


argument::waittime

If triggered, minimum wait until a further frame can cause
another spot (useful to stop multiple detects on heavy signals).


Examples::

code::

// just Hainsworth metric with low threshold
(
SynthDef(\fftod, { |out|
	var source1, detect;
	source1 = SoundIn.ar(0);
	detect = PV_HainsworthFoote.ar(FFT(LocalBuf(2048),source1), 1.0, 0.0);
	Out.ar(out, SinOsc.ar([440, 445], 0, Decay.ar(0.1 * detect, 0.1)));
}).play(s);
)


// spot note transitions
(
SynthDef(\fftod, { |out|
	var source1, detect;
	source1= LFSaw.ar(LFNoise0.kr(1, 90, 400), 0, 0.5);
	detect= PV_HainsworthFoote.ar(FFT(LocalBuf(2048), source1), 1.0, 0.0, 0.9, 0.5);
	Out.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));
}).play(s);
)



// Foote solo - never triggers with threshold over 1.0, threshold under mouse control
(
SynthDef(\fftod, { |out|
	var source1, detect;
	source1= SoundIn.ar(0);
	detect= PV_HainsworthFoote.ar(FFT(LocalBuf(2048), source1), 0.0, 1.0, MouseX.kr(0.0,1.1), 0.02);
	Out.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));
}).play(s);
)


// compare to Amplitude UGen
(
SynthDef(\fftod, { |out|
		var source1, detect;
		source1 = SoundIn.ar(0);
		detect= Amplitude.ar(source1) > MouseX.kr(0.0, 1.1);
		Out.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));
	}).play(s);
)

::



class:: PV_JensenAndersen
summary:: FFT feature detector for onset detection.
related:: Classes/PV_HainsworthFoote
categories::  UGens>FFT


Description::

FFT feature detector for onset detection based on work described in
emphasis::
Jensen, K. & Andersen, T. H. (2003). Real-time Beat Estimation
Using Feature Extraction. In Proceedings of the Computer Music Modeling
and Retrieval Symposium, Lecture Notes in Computer Science. Springer
Verlag.
::

First order derivatives of the features are taken.
code::threshold::  may need to be set low to pick up on
changes.


classmethods::
private:: categories
method::ar

argument::buffer

FFT buffer.


argument::propsc

Proportion of spectral centroid feature.


argument::prophfe

Proportion of high frequency energy feature.


argument::prophfc

Proportion of high frequency content feature.


argument::propsf

Proportion of spectral flux feature.


argument::threshold

Threshold level for allowing a detection.


argument::waittime

If triggered, minimum wait until a further frame can cause
another spot (useful to stop multiple detects on heavy signals).


Examples::

code::
(
SynthDef(\fftod, { |out|
	var source1, detect, chain;
	source1 = SoundIn.ar(0);
	chain = FFT(LocalBuf(2048), source1);
	detect = PV_JensenAndersen.ar(chain, threshold:MouseX.kr(0.1, 1.0));
	Out.ar(out, SinOsc.ar([440, 445], 0, Decay.ar(0.1 * detect, 0.1)));
}).play(s);
)
::


class:: PV_LocalMax
summary:: Pass bins which are a local maximum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_MagBelow, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is above a threshold and above their nearest neighbors.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-localMax", { arg out=0;
	var in, chain;
	in = Mix.arFill(3, { LFSaw.ar(exprand(100, 500), 0, 0.1); });
	chain = FFT(LocalBuf(2048), in);
	chain = PV_LocalMax(chain, MouseX.kr(0, 50));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-localMax2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_LocalMax(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::



class:: PV_MagAbove
summary:: Pass bins above a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_LocalMax, Classes/PV_MagBelow, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is above a threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-magAbove", { arg out=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	//in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, 310);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magAbove2", { arg out=0;
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, MouseX.kr(0, 10));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magAbove3", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, MouseX.kr(0, 310));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::


class:: PV_MagBelow
summary:: Pass bins below a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_LocalMax, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is below a threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magBelow", { arg out=0, bufnum=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, 10);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magBelow2", { arg out=0, bufnum=0;
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, MouseX.kr(0, 7));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magBelow3", { arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, MouseX.kr(0, 310));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::



class:: PV_MagClip
summary:: Clip bins to a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_LocalMax, Classes/PV_MagBelow
categories:: UGens>FFT

Description::

Clips bin magnitudes to a maximum threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
	var in, chain;
	in = Mix.arFill(3, { LFSaw.ar(exprand(100, 500), 0, 0.1); });
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagClip(chain, MouseX.kr(0, 15));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magClip2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagClip(chain, MouseX.kr(0, 50));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::



class:: PV_MagDiv
summary:: Division of magnitudes
categories:: UGens>FFT

description::
Divides magnitudes of two inputs and keeps the phases of the first input.

classmethods::
private:: categories

method:: new
argument:: bufferA
fft buffer A.
argument:: bufferB
fft buffer B.
argument:: zeroed
number to use when bins are zeroed out, i.e. causing division by zero (defaults to 0.0001)

examples::
code::
s.boot;

(
SynthDef("help-magMul", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagDiv(chainA, chainB);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)


c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magMul2", { arg out=0, soundBufnum=0;
	var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar([100, 150], 0, 0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagDiv(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain));
}).play(s,[\out, 0, \soundBufnum, c]);
)

c.free;
::



class:: PV_MagFreeze
summary:: Freeze magnitudes.
categories:: UGens>FFT

Description::

Freezes magnitudes at current levels when  code::freeze::  > 0.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::freeze

If > 0, then magnitudes are frozen at current levels.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-magFreeze", { arg out=0;
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr(5.2,250,400));
	chain = FFT(LocalBuf(2048), in);
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr(0.2) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);

)

(
//trig with MouseY
SynthDef("help-magFreeze2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagFreeze(chain, MouseY.kr > 0.5 );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s,[\soundBufnum, b]);
)

b.free

::


class:: PV_MagMul
summary:: Multiply magnitudes.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Multiplies magnitudes of two inputs and keeps the phases of the first input.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magMul", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magMul2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar([100, 150], 0, 0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB);
	Out.ar(out,  0.03 * IFFT(chain));
}).play(s, [\soundBufnum, b.bufnum]);
)

b.free

::



class:: PV_MagNoise
summary:: Multiply magnitudes by noise.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Magnitudes are multiplied with noise.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magNoise", { arg out=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagNoise(chain);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magNoise2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagNoise(chain);
	Out.ar(out, 0.2 * IFFT(chain).dup);
}).play(s,[\soundBufnum, b]);
)

b.free;

::



class:: PV_MagShift
summary:: shift and stretch magnitude bin position.
related:: Classes/FFT, Classes/IFFT, Classes/PV_BinShift
categories:: UGens>FFT

Description::

Shift and stretch the positions of only the magnitude of the bins. Can be used as a very crude frequency shifter/scaler.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::stretch

Scale bin location by factor.


argument::shift

Add an offset to bin position.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magStretch", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magStretch2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

(
SynthDef("help-magShift", { arg out=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magShift2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::



class:: PV_MagSmear
summary:: Average magnitudes across bins.
categories:: UGens>FFT

Description::

Average a bin's magnitude with its neighbors.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::bins

Number of bins to average on each side of bin. As this number
rises, so will CPU usage.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magSmear", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(500, 0, Decay2.ar(Impulse.ar(2,0,0.2), 0.01, 2));
	chain = FFT(bufnum, in);
	chain = PV_MagSmear(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magSmear2", { arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagSmear(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::


class:: PV_MagSquared
summary:: Square magnitudes.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Squares the magnitudes and renormalizes to previous peak. This makes weak
bins weaker.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magSquared", {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagSquared(chain);
	Out.ar(out, 0.003 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::



class:: PV_Max
summary:: Maximum magnitude.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Output copies bins with the maximum magnitude of the two inputs.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);
		SynthDef("help-max", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_Max(chainA, chainB);
			Out.ar(out,  0.1 * IFFT(chain).dup);
		}).play(s, [\soundBufnum1, b.bufnum, \soundBufnum2, exBuf.bufnum]);
	})
},{
	"cancelled".postln;
});
)

b.free;

::



class:: PV_Min
summary:: Minimum magnitude.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Mul
categories:: UGens>FFT

Description::

Output copies bins with the minimum magnitude of the two inputs.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);
		SynthDef("help-min", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_Min(chainA, chainB);
			Out.ar(out,  0.1 * IFFT(chain).dup);
		}).play(s,[\soundBufnum1, b.bufnum, \soundBufnum2, exBuf.bufnum]);
	})
},{
	"cancelled".postln;
});
)

b.free

::



class:: PV_Mul
summary:: Complex multiply.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min
categories:: UGens>FFT

Description::

Complex Multiplication:

code::

(RealA * RealB) - (ImagA * ImagB),
(ImagA * RealB) + (RealA * ImagB)

::


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;

(
SynthDef("help-mul", { arg out=0;
	var inA, chainA, inB, chainB, chain ;
	inA = SinOsc.ar(500, 0, 0.5);
	inB =  SinOsc.ar(Line.kr(100, 400, 5), 0, 0.5);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Mul(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s);
s.scope;
)

(
SynthDef("help-mul2", { arg out=0;
	var inA, chainA, inB, chainB, chain ;
	inA = SinOsc.ar(500, 0, 0.5) * Line.kr;
	inB = LFNoise1.ar(20);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Mul(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s);
s.scope;
)

::



class:: PV_PhaseShift
summary:: Shift phase.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift90, Classes/PV_PhaseShift270, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::shift

Phase shift in radians.

argument::integrate

If greater than zero, integrate the phase-shift across calls (for an accumulating phase shift).

Examples::

code::

s.boot;

(
SynthDef("help-phaseShift", { arg out=0;
        var in, chain;
        in = SinOsc.ar(500);
        chain = FFT(LocalBuf(2048), in);
        chain = PV_PhaseShift(chain, LFNoise2.kr(1, 180, 180));
        Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)
::



class:: PV_PhaseShift270
summary:: Shift phase by 270 degrees.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift90, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins by 270 degrees.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
{
	var in, fft, fft2, shifted;
	in = SinOsc.ar(500, 0, 0.1);
	fft = FFT(LocalBuf(2048), in);
	fft2 = FFT(LocalBuf(2048), in);
	shifted = PV_PhaseShift270(fft);
	[IFFT(fft2), IFFT(shifted)]
}.scope
)

::



class:: PV_PhaseShift90
summary:: Shift phase by 90 degrees.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift270, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins by 90 degrees.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
{ |out=0, bufnum=0|
	var in, fft, fft2, shifted;
	in = SinOsc.ar(500, 0, 0.1);
	fft = FFT(LocalBuf(2048), in);
	fft2 = FFT(LocalBuf(2048), in);
	shifted = PV_PhaseShift90(fft);
	Out.ar(out, [IFFT(fft2), IFFT(shifted)]);
}.scope
)

::



class:: PV_RandComb
summary:: Pass random bins.
related:: Classes/PV_RandWipe
categories:: UGens>FFT

Description::

Randomly clear bins.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Clears bins from input in a random order as wipe goes from 0 to
1.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-randcomb", { | out=0 |
	var sig, chain;
	sig = WhiteNoise.ar(0.8);
	chain = FFT(LocalBuf(2048), sig);
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4));
	Out.ar(out, IFFT(chain).dup);
}).play(s);
)

(
//trig with MouseY
SynthDef("help-randcomb2", { | out=0, soundBufnum=2 |
	var sig, chain;
	sig = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), sig);
	chain = PV_RandComb(chain, MouseY.kr, Impulse.kr(0.4));
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\soundBufnum, c.bufnum]);
)

::



class:: PV_RandWipe
summary:: Crossfade in random bin order.
related:: Classes/PV_RandComb
categories:: UGens>FFT

Description::

Crossfades between two sounds by copying bins in a random order.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::wipe

Copies bins from bufferB in a random order as wipe goes from 0
to 1.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;

(
//trig with MouseY
SynthDef("help-randWipe", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = Mix.arFill(6, { LFSaw.ar(exprand(400, 1000), 0, 0.1) });
	inB = Mix.arFill(6, { LFPulse.ar(exprand(80, 400), 0, 0.2, SinOsc.kr(8.0.rand, 0, 0.2).max(0)) });
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_RandWipe(chainA, chainB, MouseX.kr.poll, MouseY.kr.poll > 0.5);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

::



class:: PV_RectComb
summary:: Make gaps in spectrum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_RectComb2
categories:: UGens>FFT

Description::

Makes a series of gaps in a spectrum.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::numTeeth

Number of teeth in the comb.


argument::phase

Starting phase of comb pulse.


argument::width

Pulse width of the comb.


Examples::

code::


(
{
	var sig, chain;
	sig = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), sig);
	chain = PV_RectComb(chain, 8, LFTri.kr(0.097, 0, 0.4, 0.5),
	LFTri.kr(0.24, 0, -0.5, 0.5));
	IFFT(chain).dup
}.play;
)

(
{
	var sig, chain;
	sig = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), sig);
	chain = PV_RectComb(chain,  MouseX.kr(0, 32), MouseY.kr, 0.2);
	IFFT(chain).dup
}.play;
)

::



class:: PV_RectComb2
summary:: Make gaps in spectrum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_RectComb
categories:: UGens>FFT

Description::

Alternates blocks of bins between the two inputs.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::numTeeth

Number of teeth in the comb.


argument::phase

Starting phase of comb pulse.


argument::width

Pulse width of the comb.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);

		SynthDef("help-max", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_RectComb2(chainA, chainB,  MouseX.kr(0, 32), MouseY.kr, 0.3);
			Out.ar(out,  0.5 * IFFT(chain).dup);
		}).play(s, [\soundBufnum1, b, \soundBufnum2, exBuf]);
	})
},{
	"cancelled".postln;
});
)

::



class:: PackFFT
summary:: Pack separate demand-rate FFT bin streams into an FFT chain buffer
categories:: UGens>FFT
related:: Classes/UnpackFFT

description::
Takes an array of magnitudes and phases, and packs them into an FFT buffer ready for transforming back into time-domain audio using IFFT.

Most people won't need to use this directly - instead, use pvcollect, pvcalc, or pvcalc2 methods from the link::Classes/PV_ChainUGen:: base class.

classmethods::
private:: categories

method:: new

argument:: chain
The link::Classes/FFT:: chain

argument:: bufsize
FFT buffer size

argument:: magsphases
The input data should be a flat array containing magnitude and phase of all bins in ascending order.
e.g. code:: [mag0, phase0, mag1, phase1, mag2, phase2, ... magN, phaseN] ::
This input is typically demand-rate.

argument:: frombin
restricts the frequency band

argument:: tobin
restricts the frequency band

argument:: zeroothers
set to 1 to zero all the magnitudes outside the restricted frequency band

discussion::
This is technically similar to Demand or Duty in that it calls demand-rate UGens further up the graph to process the values, eventually calling UnpackFFT. These two ends of the process must in most cases see the same chain...! Otherwise behaviour is undefined and, who knows, possibly unpleasant.

Optional parameters: frombin and tobin allow you to fill the supplied data only into a subset of the FFT bins (i.e. a single delimited frequency band), and if you do this, you can also optionally set zeroothers to 1 to zero all the magnitudes outside this band (otherwise they stay intact).

examples::
Here's an unusual example which uses PackFFT without using UnpackFFT first - essentially creating our FFT data from scratch.
code::
// Reminder: This isn't the intended typical usage! It's OK to do this though.
(
x = {
	var mags, phases, chain, sig;
	// Create simple undulating magnitudes
	mags = { FSinOsc.kr(ExpRand(0.1, 1)).range(0, 1) }.dup(100);
	// Then give them a "rolloff" to make the sound less unpleasant
	mags = mags  * ((1, 0.99 .. 0.01).squared);
	// Let's turn the bins on and off at different rates, I'm *sure* that'll sound interesting
	mags = mags * { LFPulse.kr(2 ** IRand(-3, 5)).range(0, 1) }.dup(100);
	// Let's ignore phase for now
	phases = 0.dup(100);
	// We need to create an FFT chain to feed our data in to.
	// The easiest way is to do an FFT on some signal which we then ignore!
	chain = FFT(LocalBuf(512), FSinOsc.ar);
	// Now we can do the packing
	chain = PackFFT(chain, 512, [mags, phases].flop.flatten, 0, 99, 1);
	sig = IFFT(chain);
	sig.dup
}.play
)
x.free;
::



class:: Padd
summary:: add to value of a key in event stream
related:: Classes/Paddp, Classes/Pmul
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::name

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern

Examples::

code::
(
var a, b;
a = Padd(\freq, 801, Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
(
var a, b;
a = Padd(\freq, Pseq([401, 801], 2), Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, gate=1;
		var env;
		env = EnvGen.kr(Env.asr(0.001, 1, 0.2), gate, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \freq, 440);
b = Padd(\freq, Pseq([10, 30, 100], inf), a);
b.play;
)
::


class:: Paddp
summary:: add each value of a pattern to the value at a key in event stream
related:: Classes/Padd, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Adds a value to a named value in an event pattern or stream until it ends. Repeats this with new values until the value stream ends.

ClassMethods::

method::new
argument::name
the named value in the event pattern or stream to add to.
argument::value
The value, pattern, stream or array to add. The resulting stream ends when this incoming stream ends.
argument::pattern
The event pattern or stream within which to add the new values.

Examples::

code::
(
var a, b;
a = Paddp(\freq, Pseq([2, 3, pi],inf), Pbind(\freq, Pseq([100, 200, 300])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\freq, Pseq([500, 600, 700]), \instrument, \sinegrain);
a = Paddp(\freq, Pseq([30, 90, -100], inf), a);
a.play;
)
::


class:: Paddpre
summary:: event pattern that adds to existing value of one key
related:: Classes/Padd, Classes/Paddp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Adds a value in an event, strong::before it is passed up:: the stream. To add to the value after it has been passed to the stream, use link::Classes/Padd::.

code::
(
var a, b;
a = Paddpre(\x, 8, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next((\x:4)).postln; });
)
::

Paddpre does not override incoming values:
code::
(
var a, b;
a = Paddpre(\freq, 302, Pset(\freq, 500, Pbind(\dur, 0.3)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

ClassMethods::

method::new

argument::name
the key

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern


Examples::

code::
(
var a, b;
a = Paddpre(\legato, Pseq([0.2, 0.4], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
b = Paddpre(\freq, Pseq([10, 30, 100], inf), a);
b.play;
)
::


CLASS:: PageLayout
summary:: a Window with a FlowView on it for use in ObjectGui's MVC model
categories:: GUI
related:: Classes/ObjectGui, Classes/FlowView, Classes/Window, Classes/NotificationCenter

DESCRIPTION::
This class encapsulates the common task of creating a Window, adding a FlowView (CompositeView with a FlowLayout on it).  It also supports the MVC model by registering controllers that are then removed (sent the .remove message) when the Window closes.  Additionally it can resize itself to fit the contents.


CLASSMETHODS::

METHOD:: new
Create a Window with a FlowView on it.  The PageLayout object can be treated like a Window or like a View.

argument:: title
Window title

argument:: bounds
Bounds or nil.  Default of nil will size the window to the entire screen size.  Use .resizeToFit to shrink the window to the content size.

argument:: margin
FlowLayout margin.

argument:: background
Background color

argument:: scroll
boolean: add scroll bars or not.

argument:: front
boolean: whether to immediately display the window, bringing it to the front.  default is true.  You may choose to first add your views to the window and then front it which is useful for large slow GUIs

returns:: a PageLayout


INSTANCEMETHODS::

METHOD:: window
the Window object

returns:: a Window

METHOD:: view
the top most view on the Window

returns:: a View

METHOD:: isClosed
boolean: has the window been closed ?

returns:: boolean

METHOD:: onClose
Just as for Window, this method is called when the PageLayout's window is closed.  The actual Window's onClose method is used to trigger clean up operations, releasing dependencies and will also call this onClose function.

returns:: get/set onClose handler

METHOD:: asView
returns the top view

returns:: a View

METHOD:: asFlowView

argument:: bounds
if bounds are nil then it returns self, as a PageLayout is compatible with FlowView.  If bounds are supplied then a child FlowView is placed and returned

returns:: self or a new FlowView

METHOD:: bounds
inner bounds of the top level view.

returns:: a Rect

METHOD:: asPageLayout
Similar to asFlowView, this message converts nil and various other objects to a PageLayout. This is already a PageLayout, so it returns self.

argument:: name
Ignored. If the receiver had been nil then the name would be the Window name. 

argument:: bounds
Ignored. Would have been used to size the PageLayout

returns:: self

METHOD:: startRow
compatible with FlowView

returns:: self

METHOD:: indentedRemaining
compatible with FlowView

returns:: self

METHOD:: checkNotClosed
isClosed.not

returns:: boolean

METHOD:: front
bring Window to the front

returns:: self

METHOD:: hide
Hide window

returns:: self

METHOD:: show
Show the window if it was previously hidden.

returns:: self

METHOD:: close
Close the window, releasing any dependencies and calling the onClose handler.

returns:: self

METHOD:: refresh
Refresh the top level view

returns:: self

METHOD:: background
set background color of top level view

argument:: c
color

returns:: self

METHOD:: removeOnClose
Register an object, usually a ObjectGui subclass or an Updater so that when the Window closes the .remove message will be sent to it. This will cause the object to release its dependencies on its Model.  This means the ObjectGui (or other controller object) will stop getting update messages and will stop trying to update the View which has just been closed along with the Window.  It also means that if there is no link to the Model and no longer any Views that held links to the controller object, that the controller is now unreferenced and will be garbage collected.

argument:: dependant
the object that wishes to be sent .remove on closing the window

returns:: self

METHOD:: resizeToFit
Resize the top FlowView to fit its contents and then resize the Window to fit that.=

argument:: reflow
boolean: FlowView can relay all of its child views in cases where the bounds have changed or views have been removed.  This puts them all back in place one by one for the updated bounds.  So this may result in smaller over all bounds, after which the window is shrunk.

argument:: center
boolean: after resizing, re-center the window in the screen.

returns:: self

METHOD:: reflowAll
see FlowView reflowAll

returns:: self

METHOD:: fullScreen
go Full screen

returns:: self

METHOD:: endFullScreen
end full screen

returns:: self

subsection::FlowView extensions

METHOD:: flow
Place a new FlowView on the window

argument:: func
A handler that recieves the new FlowView as argument

argument:: bounds
Bounds fo the FlowView

returns:: (returnvalue)

METHOD:: vert
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

argument:: spacing
(describe argument here)

returns:: (returnvalue)

METHOD:: horz
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

argument:: spacing
(describe argument here)

returns:: (returnvalue)

METHOD:: comp
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

returns:: (returnvalue)

METHOD:: scroll
(describe method here)

argument::  ... args
(describe argument here)

returns:: (returnvalue)


EXAMPLES::

code::
PageLayout.new
::


CLASS::Pair
summary::LISP-like two element cells
categories:: Collections>Ordered

DESCRIPTION::

note::
Implementation incomplete. See link::Guides/J-concepts-in-SC:: for similar functionality.
::

Most methods are inherited from the superclasses.

CLASSMETHODS::

method::new
Return new instance.

method::newFrom
Convert collection (e.g. arrays of arrays) to pairs.

INSTANCEMETHODS::

private::storeOn, printOn, storeArgs

method::size
Return the size when linking across.

method::depth
Return the size when linking down.

method::do
Iterate over the two elements.

Traverse
Same like: link::#-depthFirstPreOrderTraversal::

method::depthFirstPreOrderTraversal
Traverse the data structure first link down, then across (see link::#examples::).

method::depthFirstPostOrderTraversal
Traverse the data structure from bottom up (see link::#examples::).

EXAMPLES::

code::
a = Pair(Pair(Pair(1, 2), 4), Pair(5, 6));

a.size;
a.depth;
a.do { |x| x.postln };
a.traverse { |x| x.postln };
a.depthFirstPreOrderTraversal { |x| x.postln };
a.depthFirstPostOrderTraversal { |x| x.postln };


// alternative instantiations:

Pair.newFrom([1, [2, [[4, 5], 6]]]);

[1, [2, [[4, 5], 6]]].as(Pair); // equivalent.
::


class:: Pan2
summary:: Two channel equal power pan.
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Two channel equal power panner. Pan2 takes the square root of the linear scaling factor going from 1 (left or right) to 0.5.sqrt (~=0.707) in the center, which is about 3dB reduction. With linear panning (LinPan2) the signal is lowered as it approaches center using a straight line from 1 (left or right) to 0.5 (center) for a 6dB reduction in the middle. A problem inherent to linear panning is that the perceived volume of the signal drops in the middle. Pan2 solves this.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::pos

Pan position, -1 is left, +1 is right.


argument::level

A control rate level input.


Examples::
code::
// hear the difference, LinPan having a slight drop in the middle...
{ LinPan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play

// ... whereas Pan2 is more smooth
{ Pan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play

// other examples
{ Pan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2), 0.3) }.play;
::



class:: Pan4
summary:: Four channel equal power pan.
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan2, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Four channel equal power panner. Outputs are in order LeftFront,
RightFront, LeftBack, RightBack.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::xpos

X  pan position from -1 to +1 (left to right).


argument::ypos

Y pan position from -1 to +1 (back to front).


argument::level

A control rate level input.


Examples::

code::

// You'll only hear the front two channels on a stereo setup.

{ Pan4.ar(PinkNoise.ar, FSinOsc.kr(2), FSinOsc.kr(1.2), 0.3)) }.play;


{ Pan4.ar(PinkNoise.ar, -1,  0, 0.3) }.play; // left pair
{ Pan4.ar(PinkNoise.ar,  1,  0, 0.3) }.play; // right pair
{ Pan4.ar(PinkNoise.ar,  0, -1, 0.3) }.play; // back pair
{ Pan4.ar(PinkNoise.ar,  0,  1, 0.3) }.play; // front pair

{ Pan4.ar(PinkNoise.ar,  0,  0, 0.3) }.play; // center

::



class:: PanAz
summary:: Azimuth panner
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan2, Classes/Pan4
categories::  UGens>Multichannel>Panners


Description::

Multichannel equal power panner.


classmethods::

method::ar, kr

argument::numChans

Number of output channels.


argument::in

The input signal.


argument::pos

pan position (code::kr:: or code::ar::). Channels are evenly spaced over a cyclic period of code::2.0:: in pos with code::0.0:: equal to channel zero and code::2.0/numChans:: equal to channel 1, code::4.0/numChans:: equal to channel 2, etc.


Thus all channels will be cyclically panned through if a bipolar sawtooth wave from code::-1:: to code::+1:: is used to modulate the pos.


argument::level

A control rate level input.


argument::width

The width of the panning envelope. Nominally this is code::2.0:: which pans between pairs of adjacent speakers.
Values greater than code::2:: will spread the pan over greater numbers of speakers.
Values less than code::1:: will leave silent gaps between speakers.


argument::orientation

Should be code::0:: if the front is a vertex of the spanning polygon.
The first speaker will be directly in front. Should be code::0.5:: if the front
bisects a side of the spanning polygon.
Then the first speaker will be the one left of center.

section::Comparison to Pan2

Despite a certain similarity, link::Classes/Pan2:: and link::Classes/PanAz:: with 2 channels behave differently.

code::
// one full cycle for PanAz: from -1 to 1
{ PanAz.ar(2, DC.ar(1), Line.ar(-1, 1, 0.1), orientation: 0) }.plot(0.1)
// comparing with Pan2
{ Pan2.ar(DC.ar(1), Line.ar(-1, 1, 0.1)) }.plot(0.1)
// to create one full cycle for Pan2, move from 1 to -1 and back to 1
{ Pan2.ar(DC.ar(1), EnvGen.ar(Env([1, -1, 1], [0.05, 0.05]))) }.plot(0.1)
::

The same in one plot window:

code::
(
{
	[
		PanAz.ar(2, DC.ar(1), Line.ar(-1, 1, 0.1), orientation: 0),
		Pan2.ar(DC.ar(1), Line.ar(-1, 1, 0.1)),
		Pan2.ar(DC.ar(1), EnvGen.ar(Env([1, -1, 1], [0.05, 0.05])))
	].flat;
}.plot(0.1)
)
::

In other words, while code::Pan2:: needs a position change of code::2:: from channel code::0:: to code::1::

code::
{ Pan2.ar(DC.ar(1), Line.ar(-1, 1, 0.1)) }.plot(0.1)
// we need a position change of 1 in PanAz:
{ PanAz.ar(2, DC.ar(1), Line.ar(0, 1, 0.1), orientation: 0) }.plot(0.1)
::

In one plot window:

code::
(
{
	[
		Pan2.ar(DC.ar(1), Line.ar(-1, 1, 0.1)),
		PanAz.ar(2, DC.ar(1), Line.ar(0, 1, 0.1), orientation: 0)
	].flat
}.plot(0.1)
)
::

Examples::

Five channel circular panning with first channel on the left

code::

(
{
	PanAz.ar(
		numChans: 5,
		in: ClipNoise.ar(0.1),
		pos: LFSaw.kr(MouseX.kr(0.2, 8, 'exponential')),
		level: 0.5,
		width: 3,
		orientation: 0.5
	);
}.scope
)

::



class:: PanB
summary:: Ambisonic B-format panner.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Ambisonic B format panner. Output channels are in order W, X, Y, Z.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::azimuth

Azimuth in radians, -π to +π.


argument::elevation

Elevation in radians, -0.5π to +0.5π.


argument::gain

A control rate level input.


Examples::

code::

// You'll only hear the first two channels on a stereo setup.
play({
	#w, x, y, z = PanB.ar(WhiteNoise.ar, LFSaw.kr(0.5,pi), FSinOsc.kr(0.31, 0.5pi), 0.3);
	//decode for 4 channels
	DecodeB2.ar(4, w, x, y, 0.5);
});

::



class:: PanB2
summary:: 2D Ambisonic B-format panner.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Encodes a mono signal to 2-dimensional ambisonic B-format.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::azimuth

Position around the circle from -1 to +1. -1 is behind, -0.5 is
left, 0 is forward, +0.5 is right, +1 is behind.


argument::gain

Amplitude control.


Examples::

code::

(
{
	var w, x, y, p, a, b, c, d;

	p = PinkNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)

::



Class:: ParGroup
summary:: Client-side representation of a parallel group node on the server
categories:: Server>Nodes, Server>Abstractions

Description:: Parallel Groups are server-side node containers that work similar to link::Classes/Group::s, but without
ordering constraints for the contained nodes. This means that on parallel architectures the elements of a Parallel Group
can be executed concurrently.

ClassMethods::
private:: creationCmd

subsection:: Creation with Immediate Instantiation on the Server

copymethod:: Group *new

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions above:

copymethod:: Group *after
copymethod:: Group *before
copymethod:: Group *head
copymethod:: Group *tail
copymethod:: Group *replace

subsection:: Creation without Instantiation on the Server

Like with Groups, it is possible to create a a ParGroup object without immediately creating a parallel group in the server.

method:: basicNew
Create and return a ParGroup object without creating a group node on the server. (This method is inherited from Node and is documented here only for convenience.)
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.

discussion::
For a detailed discussion please refer to link::Classes/Group#*basicNew::.

Examples::

code::
fork {
	p = ParGroup.new;
	loop {
		(
			degree: rrand(0.0, 12.0).round(1/4),
			group: p,
			db: rrand(-30, -25),
			pan: rrand(-1.0, 1.0)
		).play;
		0.2.wait;
	}
}
::


TITLE:: ParamView
summary:: show a parameter of a JITLib process
categories:: JITLib
related:: Classes/JITGui, Overviews/JITLib

DESCRIPTION::
ParamView displays a parameter value, and switches representation as appropriate for value: A single number is shown by an EZSlider, a pair of numbers by an EZRanger, and anything else as code on an EZText.

First examples:
code::

w = Window("test", Rect(20, 820, 400, 100)).front;
w.addFlowLayout;
~pv = ParamView(w, Rect(20, 20, 360, 20));
~pv2 = ParamView(w, Rect(20, 20, 360, 40));

// not working properly yet
~pv.bounds_(Rect(4, 4, 300, 40));

~pv.dump
~pv.viewType_(0); // EZNumber
~pv.viewType_(1); // EZRanger
~pv.viewType_(2); // EZText

~pv.label_(\freq);
~pv.spec_(\freq);  // needs spec for EZSlider


~pv.value_(200);
~pv.value_(2000);
// switches to EZRanger
~pv.value_([200, 2000]);
// 3 numbers -> switches to EZText
~pv.value_([20, 200, 2000]);
// anything else -> EZText
~pv.value_(\blonk);
~pv.action = { |pv| pv.value.postcs };

::

CLASSMETHODS::

METHOD:: new
create a new ParamView with
ARGUMENT:: parent
the parent window or view
ARGUMENT:: bounds
the bounds of the view
ARGUMENT:: label
a label to display
ARGUMENT:: spec
a controlspec for the value
ARGUMENT:: action
an action to do when the value changes
ARGUMENT:: initVal
an initial value
ARGUMENT:: initAction
a boolean whether to perform the action on init.


INSTANCEMETHODS::

METHOD:: label
get and set the view's label

METHOD:: spec
get and set the view's control spec

METHOD:: action
get and set the paramview's action

private:: zone, zones

METHOD:: ezviews, slider, ranger, textview
the 3 ezviews between which the ParamView switches

METHOD:: currview
the currently shown view of these

METHOD:: value
get and set value

METHOD:: valueAction
get and set value and do action

METHOD:: doAction
do the view's action

METHOD:: viewType
get and set the view's type:
0 is single number -> EZSlider,
1 is pair of numbers -> EZRanger,
2 is anything else

METHOD:: valueType
determine viewType for a given value


METHOD:: background
get and set background color

private:: init


class:: PartConv
summary:: Real-time partitioned convolution
categories:: UGens>FFT, UGens>Convolution
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution2L, Classes/Convolution3

description::
Partitioned convolution. Various additional buffers must be supplied.

Mono impulse response only! If inputting multiple channels, you'll need independent PartConvs, one for each channel.

But the charm is: impulse response can be as large as you like (CPU load increases with IR size. Various tradeoffs based on fftsize choice, due to rarer but larger FFTs. This plug-in uses amortisation to spread processing and avoid spikes).

Normalisation factors difficult to anticipate; convolution piles up multiple copies of the input on top of itself, so can easily overload.

classmethods::
method:: ar

argument:: in
processing target.
argument:: fftsize
spectral convolution partition size (twice partition size). You must ensure that the blocksize divides the partition size and there are at least two blocks per partition (to allow for amortisation).
argument:: irbufnum
prepared buffer of spectra for each partition of the inpulse response.
argument:: mul
argument:: add

examples::
code::

// preparation; essentially, allocate an impulse response buffer, then
// follow a special buffer preparation step to set up the data the plugin needs.
// Different options are provided commented out for loading impulse responses from soundfiles.
(

 // also 4096 works on my machine; 1024 too often and amortisation too pushed, 8192 more high load FFT
~fftsize = 2048;

s.waitForBoot {

	{
		var ir, irbuffer, bufsize;

		// // MONO ONLY
		// pre-existing impulse response sound files
		// (could also use any general soundfile too for cross-synthesis effects)
		// irbuffer = Buffer.read(s, "/Volumes/data/audio/ir/ir2.wav");

		// synthesise the honourable 'Dan Stowell' impulse response

		ir = [1] ++ 0.dup(100) ++ (
			(1, 0.99998 .. 0)
			.collect {|f|
				f = f.squared.squared;
				f = if(f.coin) { 0 }{ f.squared };
				f = if(0.5.coin) { 0 - f } { f }
			} * 0.1
		);
		ir = ir.normalizeSum;

		irbuffer = Buffer.loadCollection(s, ir);

		s.sync;

		bufsize = PartConv.calcBufSize(~fftsize, irbuffer);

		// ~numpartitions= PartConv.calcNumPartitions(~fftsize, irbuffer);

		~irspectrum = Buffer.alloc(s, bufsize, 1);
		~irspectrum.preparePartConv(irbuffer, ~fftsize);

		s.sync;

		irbuffer.free; // don't need time domain data anymore, just needed spectral version
	}.fork;

}
)



~target = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var input = PlayBuf.ar(1, ~target, loop:1);
	PartConv.ar(input, ~fftsize, ~irspectrum.bufnum, 0.5)
}.play
)


// convolve with live input
(
{
	var input = SoundIn.ar(0);
	PartConv.ar(input, ~fftsize, ~irspectrum.bufnum)
}.play
)


// should get back original impulse response (once every four seconds)
(
{
	var input = Impulse.ar(0.25);
	PartConv.ar(input, ~fftsize, ~irspectrum.bufnum)
}.play
)


// only free buffers once you're finished with examples
// if you free whilst PartConv is still running, the server won't crash, but PartConv output will go to zero abruptly
(
~irspectrum.free;
~target.free;
currentEnvironment.clear;
)
::


class:: PathName
summary:: file and directory path utilities
related:: Classes/File, Classes/String
categories:: Files

description::
PathName is a utility class for manipulating file names and paths. It expects a path to a file, and lets you access parts of that file path.

ClassMethods::

private::initClass

method::new

argument::path
a link::Classes/String:: which likely contains one or more / as typical for folder separation. ~ will be converted to your fully addressed home directory, as per link::Classes/String#-standardizePath::.
code::
PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
::

method::tmp
Get or set the global temp directory as a link::Classes/String::. This is used by link::Classes/Buffer::, etc. By default this is "/tmp/" for Linux and macOS, and "/WINDOWS/TEMP/" for Windows.

InstanceMethods::

method::fileName
returns just the name of the file itself; i.e. everything after the last slash in the full path.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.fileName.postln;
)
::

method:: fileNameWithoutExtension
returns the name of the file itself without the file extension.

method::extension
returns the file extension, i.e. everything after the last full-stop in the link::#-fileName::.

method::pathOnly
returns the full path up to the file name itself; i.e. everything up to and including the last slash. This is handy e.g. for storing several files in the same folder.

code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.pathOnly.postln;
)
::

method::isAbsolutePath, asAbsolutePath, isRelativePath, asRelativePath
you MUST have correctly initialized the scroot classvar for this to know what it is relative to !

method::folderName
returns only the name of the folder that the file is in; i.e. everything in between the last but one and the last slash.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.folderName.postln;
)
::

method::fullPath
returns the full path name that PathName contains.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.fullPath.postln;
)
::

method::entries
returns a list of all the files+folders inside the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.entries.postln;
)
::

method::files
returns a list of all the files in the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.files.postln;
)
::

method::folders
returns a list of all the subfolders of the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.folders.postln;
)
::

method::isFile
returns a link::Classes/Boolean:: indicating whether or not the path represents a file (not a folder).
code::
(
var myPath;
myPath = PathName.new("./");
myPath.isFile.postln;
)
::

method::isFolder
returns a link::Classes/Boolean:: indicating whether or not the path represents a folder (not a file).
code::
(
var myPath;
myPath = PathName.new("./");
myPath.isFolder.postln;
)
::

method::filesDo
Iterates over all files found in the pathname, including ones in subfolders.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.filesDo{|afile| afile.postln};
)
::

method::allFolders
returns a list of all the folder names contained in the pathname itself.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.allFolders.postln;
)
::

method::diskName
if path is an absolute path, returns the disk name; else a blank string.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.diskName.postln;
)

( // note the / at the start
var myPath;
myPath = PathName.new("/MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.diskName.postln;
)
::

method::+/+
Path concatenation operator - useful for avoiding doubling-up slashes unnecessarily.
code::
(PathName("/somewhere") +/+ PathName("over/the/rainbow")).postln;
(PathName("/somewhere") +/+ PathName("/over/the/rainbow")).postln;
::

method::endNumber
returns a number at the end of PathName. Returns zero if there is no number.
code::
PathName("floating1").endNumber.postln;
PathName("floating").endNumber.postln;
::

method::noEndNumbers
returns link::#-fullPath:: without any numbers at the end.
code::
PathName("floating1").noEndNumbers.postln;
PathName("floating").noEndNumbers.postln;
::

method::nextName
generates a sensible next name for a file by incrementing a number at the end of PathName, or by adding one if there is none. This is useful for recording files with consecutive names, and e.g. to generate a new filename when you don't want to overwrite an existing file with the current name.
code::
PathName("floating34").nextName.postln;
PathName("floating").nextName.postln;
PathName("floating12_3A4X_56.7").nextName.postln;
::

Examples::

Here is an example that uses many instance methods. Just pick any file to see all the parts of its path.

code::
(
FileDialog.new(
	{ arg ok, path;
	var myPathName;
	if (ok,
		{
			myPathName = PathName.new(path);

			"New PathName object:  ".postc;
			myPathName.postln;

			"fileName only:        ".postc;
			myPathName.fileName.postln;

			"path up to file only: ".postc;
			myPathName.pathOnly.postln;

			"folder Name:          ".postc;
			myPathName.folderName.postln;
		}
	)
	}
)
)
::

Choose a soundfile to put into the library, using its foldername and filename.

code::
(
FileDialog.new(
	{ arg ok, path;
	var myPathName, myFile;
	if (ok,
		{
			myPathName = PathName.new(path);

			// read your file from disk, e.g. a soundFile/

			myFile = SoundFile.new;
			if (myFile.openRead(path),
				{
					Library.put(
						[ myPathName.folderName.asSymbol, myPathName.fileName.asSymbol ],
						myFile);
					("Check Library.global" + myPathName.folderName + "please.").postln;
				},
				{ ("Could not read soundfile" + path ++ ".").postln; }
			);
			myFile.close;
		}
	)
	}
)
)
::

Save three tables in the same folder. Note: The file name chosen in the dialog is ignored! The files are always named table1, table2, table3.

code::
(
var table1, table2, table3;

table1 = Wavetable.sineFill(1024, [1,2,3]);
table2 = Signal.newClear.asWavetable;
table3 = Wavetable.sineFill(1024, Array.rand(64, 0.0, 1.0));

FileDialog.new(
	{ arg ok, path;
	var myPathName, myPathOnly;
	if (ok,
		{
			myPathName = PathName.new(path);
			myPathOnly = myPathName.pathOnly;
			("writing files tables1-3 to"+myPathOnly).postln;
			table1.write(myPathOnly ++ "table1");
			table2.write(myPathOnly ++ "table2");
			table3.write(myPathOnly ++ "table3");
		}
	)
	}
)
)
::


class:: Pattern
summary:: abstract class that holds a list
related:: Classes/Stream, Classes/FilterPattern, Classes/ListPattern
categories:: Streams-Patterns-Events>Patterns

description::

subsection::Patterns versus Streams

strong::Pattern:: is an abstract class that is the base for the Patterns library. These classes form a rich and concise score language for music. The series of help files entitled link::Tutorials/Streams-Patterns-Events1:: gives a detailed introduction. This attempts a briefer characterization.

A strong::Stream:: is an object that responds to code::next::, code::reset::, and code::embedInStream::. Streams represent sequences of values that are obtained one at a time by with message code::next::. A code::reset:: message will cause the stream to restart (many but not all streams actually repeat themselves.) If a stream runs out of values it returns code::nil:: in response to code::next::. The message code::embedInStream:: allows a stream definition to allow another stream to "take over control" of the stream.
All objects respond to code::next:: and code::reset::, most by returning themselves in response to next. Thus, the number 7 defines a Stream that produces an infinite sequence of 7's. Most objects respond to code::embedInStream:: with a singleton Stream that returns the object once.

A strong::Pattern:: is an object that responds to code::asStream:: and code::embedInStream::. A Pattern defines the behavior of a Stream and creates such streams in response to the messages code::asStream::.
The difference between a Pattern and a Stream is similar to the difference between a score and a performance of that score or a class and an instance of that class. All objects respond to this interface, most by returning themselves. So most objects are patterns that define streams that are an infinite sequence of the object and embed as singleton streams of that object returned once.

Patterns are defined in terms of other Patterns rather than in terms of specific values. This allows a Pattern of arbitrary complexity to be substituted for a single value anywhere within a Pattern definition. A comparison between a Stream definition and a Pattern will help illustrate the usefulness of Patterns.

subsection::example 1 - Pseq vs. Routine

The Pattern class strong::Pseq(array, repetitions):: defines a Pattern that will create a Stream that iterates an array. The class strong::Routine(func, stackSize):: defines a single Stream, the function that runs within that stream is defined to perform the array iteration.

Below a stream is created with link::Classes/Pseq:: and an code::asStream:: message and an identical stream is created directly using Routine.

code::
// a Routine vs a Pattern
(
	a = [-100, 00, 300, 400];			// the array to iterate

	p = Pseq(a);					// make the Pattern
	q = p.asStream;					// have the Pattern make a Stream
	r = Routine({ a.do({ arg v; v.yield}) }) ;	// make the Stream directly

	5.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

subsection::example 2 - Nesting patterns

In example 1, there is little difference between using link::Classes/Pseq:: and link::Classes/Routine::. But Pseq actually iterates its array as a collection of emphasis::patterns to be embedded::, allowing another Pseq to replace any of the values in the array. The Routine, on the other hand, needs to be completely redefined.

code::
(
	var routinesA;
	a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];
	routinesA = [[3], [-100, 00, 300, 400], [-100, 00, 300, 400].reverse];
	p = Pseq(a);
	q = p.asStream;

	r = Routine({
		routinesA.do({ arg v;
			v.do({ arg i; i.yield})
		}) ;
	});
	10.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

subsection::example 3 - Stream-embedInStream

The message code::embedInStream:: is what allows Patterns to do this kind of nesting. Most objects
(such as the number 3 below) respond to code::embedInStream:: by yielding themselves once and returning. Streams respond to embedInStream by iterating themselves to completion, effectively "taking over" the calling stream for that time.

A Routine can perform a pattern simply by replacing calls to code::yield:: with calls to code::embedInStream::.
code::
(
	a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];

	r = Routine({ a.do({ arg v; v.embedInStream}) }) ;
	p = Pseq(a);
	q = p.asStream;
	10.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

Of course, there is no concise way to emphasis::define:: this stream without using Pseq.

note::
For reasons of efficiency, the implementation of code::embedInStream:: assumes that it is called from within a link::Classes/Routine::. Consequently, code::embedInStream:: should never be called from within the function that defines a link::Classes/FuncStream:: or a link::Classes/Pfunc:: (the pattern that creates FuncStreams).
::

subsection::Event Patterns

An link::Classes/Event:: is a link::Classes/Environment:: with a 'play' method. Typically, an Event consists of a collection of key/value pairs that determine what the play method actually does. The values may be any object including functions defined in terms of other named attributes. Changing those values can generate a succession of sounds sometimes called 'music'... The pattern link::Classes/Pbind:: connects specific patterns with specific names. Consult its help page for details.

subsection::Playing Event Patterns

The link::#-play:: method does not return the pattern itself. Instead, it returns the link::Classes/EventStreamPlayer:: object that actually runs the pattern. Control instructions -- stop, pause, resume, play, reset -- should be addressed to the EventStreamPlayer. (The same pattern can play many times simultaneously, using different EventStreamPlayers.)

code::
p = Pbind(...);
p.play;
p.stop;	// does not stop because p is not the EventStreamPlayer that is actually playing

p = Pbind(...).play;
p.stop;	// DOES stop because p is the EventStreamPlayer
::

subsection::Recording Event Patterns

Patterns may be recorded in realtime or non-realtime. See the method link::#-record:: for realtime recording.

For non-realtime recording see the link::Classes/Score:: helpfile, especially "creating Score from a pattern." It can be tricky, because NRT recording launches a new server instance. That server instance is not aware of buffers or other resources loaded into the realtime server you might have been using for tests. The pattern is responsible for (re)loading any resources (buffers, effects etc.). link::Classes/Pfset:: or link::Classes/Pproto:: may be useful.

InstanceMethods::

method::asStream
Return a link::Classes/Stream:: from this pattern. One pattern can be used to produce any number of independent streams.

code::
a = Pgeom(1, Pwhite(1.01, 1.2), inf);
b = a.asStream; c = a.asStream;

b.next;
b.next;
b.next;

c.next; // c is independent from b
c.next;


::

method::embedInStream
Given a link::Classes/Stream:: like e.g. link::Classes/Routine::, yield all values from this pattern before continuing. One pattern can be used to produce values for any number of independent streams.

argument::inval
The inval is passed into all substreams and can be used to control how they behave from the outside.

code::
a = Pgeom(1, Pwhite(1.01, 1.2), 5);
r = Routine { 2.yield; 3.yield; a.embedInStream; 7.yield; };
r.nextN(12); // the next 12 values from r
::


method::play

argument::clock
The tempo clock that will run the pattern. If omitted, TempoClock.default is used.

argument::protoEvent
The event prototype that will be fed into the pattern stream on each iteration. If omitted, event.default is used.

argument::quant
see the link::Classes/Quant:: helpfile.

method::record
Opens a disk file for recording and plays the pattern into it.

argument::path
Disk location for the recorded file. If not given, a filename is generated for you and placed in the default recording directory: code::thisProcess.platform.recordingsDir::.

argument::headerFormat
File format, defaults to link::Classes/Server#-recHeaderFormat##server.recHeaderFormat:: - see link::Classes/SoundFile:: for supported header and sample formats.

argument::sampleFormat
Sample format, defaults to link::Classes/Server#-recSampleFormat##server.recSampleFormat::.

argument::numChannels
Number of channels to record, default 2.

argument::dur
How long to run the pattern before stopping. If nil (default), the pattern will run until it finishes on its own; then recording stops. Or, use cmd-period to stop the recording. If a number is given, the pattern will run for that many beats and then stop (using link::Classes/Pfindur::), ending the recording as well.

argument::fadeTime
How many beats to allow after the last event before stopping the recording. Default = 0.2.

argument::clock
Which clock to use for play. Uses TempoClock.default if not otherwise specified.

argument::protoEvent
Which event prototype to use for play. Falls back to Event.default if not otherwise specified.

argument::server
Which server to play and record. Server.default if not otherwise specified.

argument::out
Output bus to hear the pattern while recording, default = 0.

argument::outNumChannels
the number of out channels to play to the recorder. If larger than numChannels, outNumChannels will wrap .

Examples::

Below are brief examples for most of the classes derived from Pattern. These examples all rely on the patterns assigned to the Interpreter variable p, q, and r in the first block of code.

code::
s.boot;

(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
	var out, eg, fc, osc, a, b, w;
	fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
	osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
	eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction: Done.freeSelf);
	out = eg * RLPF.ar(osc, fc, 0.1);
	#a, b = out;
	Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

SynthDef("sinegrain2",
	{ arg out=0, freq=440, sustain=0.05, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction: Done.freeSelf);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

p = Pbind(
	[\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
	\amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

q = Pbindf(p, \instrument, \default );

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

)
::

subsection::EVENT PATTERNS - patterns that generate or require event streams

code::
// Pbind( ArrayOfPatternPairs )

p = Pbind(
	[\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
	\amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

p.play;

//Ppar(arrayOfPatterns, repeats) - play in parallel

Ppar([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Ptpar(arrayOfTimePatternPairs, repeats) - play in parallel at different times

Ptpar([1, Pseq([p], 4), 0, Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

// Pbindf( pattern, ArrayOfNamePatternPairs )

q = Pbindf(p, \instrument, \default );
q.play;

//Pfset(function, pattern)
// function constructs an event that is passed to the pattern.asStream

Pfset({ ~freq = Pseq([500, 600, 700], 2).asStream }, q).play;

//Pset(name, valPattern, pattern)
// set one field of the event on an event by event basis (Pmul, Padd are similar)

Pset(\freq, Pseq([500, 600, 700], 2), q).play;

//Psetp(name, valPattern, pattern)
// set once for each iteration of the pattern (Pmulp, Paddp are similar)

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Psetpre(name, valPattern, pattern)
// set before passing the event to the pattern (Pmulpre, Paddpre are similar)

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Pstretch(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretch(Pn(Env([0.5, 2, 0.5], [10, 10])), Pn(r)).play;

Pset(\stretch, Pn(Env([0.5, 2, 0.5], [10, 10]) ), Pn(r)).play

//Pstretchp(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretchp(Pn(Env([0.5, 2, 0.5], [10, 10])), r).play;

// Pfindur( duration, pattern ) - play pattern for duration

Pfindur(2, Pn(q, inf)).play;

// PfadeIn( pattern, fadeTime, holdTime, tolerance )
PfadeIn(Pn(q), 3, 0).play(quant: 0);

// PfadeOut( pattern, fadeTime, holdTime, tolerance )
PfadeOut(Pn(q), 3, 0).play(quant: 0);

// Psync( pattern, quantization, dur, tolerance )
// pattern is played for dur seconds (within tolerance), then a rest is played so the next pattern

Pn(Psync(
	Pbind(\dur, Pwhite(0.2, 0.5).round(0.2),
		\db, Pseq([-10, -15, -15, -15, -15, -15, -30])
	), 2, 3
)).play

//Plag(duration, pattern)

Ppar([Plag(1.2, Pn(p, 4)), Pn(Pbindf(q, \ctranspose, -24), 5)]).play
::

subsection::GENERAL PATTERNS that work with both event and value streams

code::
//Ptrace(pattern, key, printStream) - print the contents of a pattern

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Ptrace(r).play;
Ptrace(r, \freq).play;

(
{ var printStream;
	printStream = CollStream.new;
	Pseq([Ptrace(r, \freq, printStream), Pfunc({printStream.collection.dump; nil }) ]).play;
}.value;
)

//Pseed(seed, pattern) - set the seed of the random number generator
// to force repetion of pseudo-random patterns

Pn(Pseed(44, Pbindf(q, \ctranspose, Pbrown(-3.0, 3.0, 10) ) ) ).play;

//Prout(function) - on exit, the function must return the last value returned by yield
// (otherwise, the pattern cannot be reliably manipulated by other patterns)

Prout({ arg inval;
	inval = p.embedInStream(inval);
	inval = Event.silent(4).yield;
	inval = q.embedInStream(inval);
	inval = r.embedInStream(inval);
	inval;
}).play

//Pfunc(function) - the function should not have calls to embedInStream, use Prout instead.

Pn(Pbindf(q, \legato, Pfunc({ arg inval; if (inval.at(\degree)== 5) {4} {0.2}; })) ).play



// the following patterns control the sequencing and repetition of other patterns

//Pseq(arrayOfPatterns, repeats) - play as a sequence

Pseq([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Pser(arrayOfPatterns, num) - play num patterns from the arrayOfPatterns

Pser([p, q, r], 5).play

//Place(arrayOfPatterns, repeats) - similar to Pseq
// but array elements that are themselves arrays are iterated
// embedding the first element on the first repetition, second on the second, etc

Place([[p, q, r], q, r], 5).play

// Pn( pattern, patternRepetitions ) - repeat the pattern n times

Pn(p, 2).play;

// Pfin( eventcount, pattern ) - play n events from the pattern

Pfin(12, Pn(p, inf)).play;

// Pdup( eventRepetitions, pattern ) - repeat each event from the pattern n times

Pdup(4, q).play

//Pwhile(function, pattern)

Pwhile({coin(0.5).postln;}, q).play

// Pswitch( patternList, selectPattern ) - when a pattern ends, switch according to select

Pswitch([p, q, r], Pwhite(0, 100)).play

// Pswitch1( patternList, selectPattern ) - on each event switch according to select

Pn(Pswitch1([p, q, r], Pwhite(0, 2))).play

// Prand( patternList, repeats ) - random selection from list
Prand([p, q, r], inf).play

// Pxrand( patternList, repeats ) - random selection from list without repeats
Pxrand([p, q, r], inf).play

// Pwrand( patternList, weights, repeats ) - weighted random selection from list
Pwrand([p, q, r], #[1, 3, 5].normalizeSum, inf).play

// Pwalk( patternList, stepPattern, directionPattern ) - walk through a list of patterns

Pwalk([p, q, r], 1, Pseq([-1, 1], inf)).play

// Pslide(list, repeats, length, step, start)

Pbind(\degree, Pslide(#[1, 2, 3, 4, 5], inf, 3, 1, 0), \dur, 0.2).play

// Pshuf( patternList, repeats ) - random selection from list
Pn(Pshuf([p, q, r, r, p])).play

// Ptuple(list, repeats)

Pbind(\degree, Ptuple([Pwhite(1, -6), Pbrown(8, 15, 2)]),
	\dur, Pfunc({ arg ev; ev.at(\degree).last/80 round: 0.1}),
	\db, Pfunc({ if (coin(0.8)) {-25} {-20} })
).play



// the following patterns can alter the values returned by other patterns

//Pcollect(function, pattern)

Pcollect({ arg inval; inval.use({ ~freq = 1000.rand }); inval}, q).play

//Pselect(function, pattern)

Pselect({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Preject(function, pattern)

Preject({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Ppatmod(pattern, function, repeats) -
// function receives the current pattern as an argument and returns the next pattern to be played

Ppatmod(p, { arg oldPat; [p, q, r].choose }, inf).play
::

subsection::VALUE PATTERNS: these patterns define or act on streams of numbers

code::
// Env as a pattern

Pbindf(Pn(q, inf), \ctranspose, Pn(Env.linen(3, 0, 0.3, 20), inf) ).play;

// Pwhite(lo, hi, length)

Pbindf(Pn(q, inf), \ctranspose, Pwhite(-3.0, 3.0) ).play;

// Pbrown(lo, hi, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pbrown(-3.0, 3.0, 2) ).play;

// Pseries(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pseries(0, 0.1, 10) ).play;

// Pgeom(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pgeom(1, 1.2, 20) ).play;

// Pwrap(pattern, lo, hi)

Pbind(\note, Pwrap(Pwhite(0, 128), 10, 20).round(2), \dur, 0.05).play;

// PdegreeToKey(pattern, scale, stepsPerOctave)
// this reimplements part of pitchEvent (see Event)

Pbindf(Pn(q, inf), \note, PdegreeToKey(Pbrown(-8, 8, 2), [0, 2, 4, 5, 7, 9, 11]) ).play;

// Prewrite(pattern, dict, levels) - see help page for details.
// (notice use of Env to define a chord progression of sorts...

Pbind(\degree,
	Prewrite(0, ( 0: #[2, 0],
			1: #[0, 0, 1],
			2: #[1, 0, 1]
		), 4
	) + Pn(Env([4, 0, 1, 4, 3, 4], [6.4, 6.4, 6.4, 6.4, 6.4], 'step')),
	\dur, 0.2).play

// Psubdivide( repetitionPattern, patternOfDurations ) -
Pbindf(Pn(q), \dur, Psubdivide(
	Pseq(#[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 4, 5, 7, 15], inf),
	Pseq(#[0.5], inf)
	)
).play;


// Pstep2add( pat1, pat2 )
// Pstep3add( pat1, pat2, pat3 )
// PstepNadd(pat1, pat2, ...)
// PstepNfunc(function, patternArray )
// combine multiple patterns with depth first traversal

Pbind(
	\octave, 4,
	\degree, PstepNadd(
		Pseq([1, 2, 3]),
		Pseq([0, -2, [1, 3], -5]),
		Pshuf([1, 0, 3, 0], 2)
	),
	\dur, PstepNadd(
		Pseq([1, 0, 0, 1], 2),
		Pshuf([1, 1, 2, 1], 2)
	).loop * (1/8),
	\legato, Pn(Pshuf([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), inf),
	\scale, #[0, 1, 3, 4, 5, 7, 8]
).play;
::


class:: PatternConductor
summary:: Simple interactive control for playing patterns
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns

description::

PatternConductor provides a simple interactive control (supporting play, pause, resume, stop) for playing pattern, much like link::Classes/Pattern#-play::. However, PatternConductor creates its own clock and directly controls the release of sounding notes as well as their initiation by the pattern.

InstanceMethods::

private::prPlay

method::tempo
Sets the tempo of the PatternConductor

method::play
Play the pattern. A link::Classes/TempoClock:: is created, its tempo is set to the PatternConductor tempo, and the pattern is played using that clock. If quant is non-zero, this is synchronized with TempoClock.default at the specified quantization.

method::pause
Pause the pattern, sustaining notes indefinitely. A subsequent link::#-resume:: will return to the original tempo (so the notes will end as scheduled). A subsequent link::#-play:: will cut-off any sounding notes and resume play at the original tempo.

method::stop
can cut-off or shorten sounding notes, depending on the value of tempo. If stopTempo is nil, all notes are cut-off immediately. Otherwise, notes end at the specified tempo.

Examples::

code::
(
// a pattern with long notes
p = Pbind(
	\freq, Pwhite(0,log(32)).exp.round(1) * 36.midicps,
	\detune, Pfunc({ | ev | ev[\freq]  * rand(0.01) }),
	\sustain, Pwhite(log(0.1), log(20)).exp,
	\dur, Prand([0.1,0.1,0.1,0.1,0.2,1,2],inf),
	\db, Pstep(Pseq([-20,-30,-25,-30], inf),0.2)
);

// unrelated cluster pattern running on TempoClock.default
Pbind(\dur,2, \midinote, Pseq([(48..60)],20), \db, -30).play;

// make a conductor
a = PatternConductor(p, quant: 2);
a.play;
)


// now try some interactive control options line by line:
a.quant = 0;
a.pause;
a.resume;
a.stop;
a.play;
a.pause;
a.play;
a.stop(1000);
::


class:: PatternProxy
summary:: stream reference
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdefn

description::
Keeps a reference to a stream that can be replaced while playing. Multiple streams are thus handled without creating dependencies.

ClassMethods::

private::at, hasGlobalDictionary, parallelise, postRepository, removeAll, basicNew, clear, event

method::new
create a new instance with a pattern (the source). the pattern should be a emphasis::value pattern:: (see link::Classes/Pdefn::).

for event pattern proxy, see: link::Classes/EventPatternProxy::. instead of a pattern, a strong::function:: can be passed in, creating a routine.

method::default
a default source, if none is given. the default is 1.0 (it is not 0.0 in order to make it safe for durations)

method::defaultQuant
set the default quantization value for the class. (default: nil)

method::defaultValue
a default return value, if no source is given. the default is 1.0 (it is not 0.0 in order to make it safe for durations). This is used in link::#-endless::.

InstanceMethods::

method::asStream
Return a link::Classes/Stream:: from this pattern. One pattern proxy can be used to produce any number of independent streams.

code::
a = PatternProxy.new;
a.source = Pgeom(1, Pwhite(1.01, 1.2), inf);
b = a.asStream; c = a.asStream;

b.next;
b.next;
b.next;

c.next; // c is independent from b
c.next;

a.source = Pgeom([1, 2, 3], Pwhite(1.01, 1.2), inf); // replace the source

b.next;
c.next;

::

method::embedInStream
Given a link::Classes/Stream:: like e.g. link::Classes/Routine::, yield all values from the pattern in the proxy before continuing. One pattern proxy can be used to produce values for any number of independent streams.

argument::inval
The inval is passed into all substreams and can be used to control how they behave from the outside.

argument::embed
See link::Classes/Object#-streamArg:: for explanation.

argument::default
Replacement for code::nil:: outputs of the source pattern. One use case is link::#-endless::.

code::
a = PatternProxy.new;
a.source = Pgeom(1, Pwhite(1.01, 1.2), 4);
r = Routine { loop { 2.yield; 3.yield; a.embedInStream }; };
r.nextN(12); // the next 12 values from r
a.source = Pgeom([1, 2, 3], Pwhite(1.01, 1.2), inf); // replace the source
r.nextN(12); // the next 12 values from r
::


method::source
set the source. If a quantization is given, schedule this change to the next beat

method::clear
set the source to nil

method::quant
set or get the quantization value

method::condition
provide a condition under which the pattern is switched when a new one is inserted. the stream value and a count is passed into the function. the methods strong::count_(n):: simply counts up to n and switches the pattern then

method::embedInStream
just like any pattern, embeds itself in stream

subsection::Methods implemented for subclasses

PatternProxy implements some methods for the benefits of its subclasses link::Classes/Pdefn:: / link::Classes/Pdef:: / link::Classes/Tdef:: which are not useful for link::Classes/PatternProxy:: and link::Classes/TaskProxy::.

method::envir
provide a default environment for the proxy. If given, it is used as an environment for the routine function. When set for the first time, the routine pattern is rebuilt.

method::set
set arguments in the environment. If there is none, it is created and the pattern is rebuilt.

method::endless
returns a Prout that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (1). This allows to create streams that idle on until a new pattern is inserted.

Examples::

code::
a = PatternProxy(Pseq([1, 2, 3], inf));

x = Pseq([0, 0, a], inf).asStream;

t = Task({ loop({ x.next.postln; 0.3.wait }) }).play;


a.source = Pseq([55, 66, 77], inf);
a.source = Pseq([55, 66, 77], 1);

t.stop;
::

code::
// PatternProxy, like Pdefn can be accessed in multiple streams

(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction: Done.freeSelf);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
s.boot;
)

(
x = PatternProxy.new;
x.source = Pseq([0, 3, 2], inf);

Pset(\instrument, \Pdefhelp,
	Ppar([
	Pbind(\degree, x),
	Pbind(\degree, x, \dur, 1/3)
])
).play;
)

x.source = Prand([0, 3, [1s, 4]], inf);

x.source = Pn(Pshuf([0, 3, 2, 7, 6], 2), inf);



// if quant is set, the update is done at the next beat or whatever is specified:

x.quant = 4;
x.source = Pn(Pseries(0, 1, 8), inf);

x.quant = nil; // reactivate immediacy

(
x.source = Prout {
	loop {
	4.do { |i|
		#[2, 3, 4].choose.yield;
		#[5, 0, 11].choose.yield;
		#[6, 3, 4].choose.do { |j| (i % j).yield };
	}
	}
}
)
::


class:: Pause
summary:: When triggered, pauses a node.
related:: Classes/Free
categories::  UGens>Synth control


Description::

When triggered, pauses a node.


classmethods::

method::kr

argument::gate

When gate is 0, node is paused, when 1 it runs.


argument::id

Node to be paused.


Examples::

code::

s.boot;

SynthDef(\a, { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).add;

SynthDef(\b, { |gate = 1| Out.ar(1, PinkNoise.ar(0.3)); Pause.kr(gate, 1001) }).add;

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\s_new, \b, 1002, 0, 0);

s.sendMsg(\n_set, 1002, \gate, 0);

s.sendMsg(\n_set, 1002, \gate, 1);

::



class:: PauseSelf
summary:: When triggered, pause enclosing synth.
related:: Classes/FreeSelf
categories::  UGens>Synth control


Description::

Pause enclosing synth when input signal crosses from non-positive to
positive.


classmethods::

method::kr

argument::in

The input signal.


Examples::

code::

(
SynthDef("pauseSelf-help", { arg out, t_trig;
	PauseSelf.kr(t_trig);
	Out.ar(out, SinOsc.ar(400,0,0.2));
}).add;
)

s.sendMsg("/s_new", "pauseSelf-help", 1731);
s.sendMsg("/n_set", 1731, \t_trig, 1);
s.sendMsg("/n_run", 1731, 1);
s.sendMsg("/n_set", 1731, \t_trig, 1);
s.sendMsg("/n_free", 1731);

::



class:: PauseSelfWhenDone
summary:: FIXME: PauseSelfWhenDone purpose.
related:: Classes/Done, Classes/FreeSelfWhenDone
categories::  UGens>Synth control, UGens>Undocumented


Description::

FIXME: PauseSelfWhenDone description.


classmethods::

method::kr

argument::src

FIXME: explain parameter src.




class:: Pavaroh
summary:: applying ascending and descending scales to event stream
categories:: Streams-Patterns-Events>Patterns>Math

description::

Basic classical indian scale pattern. Allowing to apply an ascending scale (aroh) and a descending scale (avaroh).

Note that no special pakads (movements) or vakras (twists) are applied.

The pakad is often a natural consequence of the notes of arohana / avarohana (ascending and descending structures). This is the purpose of this pattern.

Examples::

code::
(
Pbind(\note, Pavaroh(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 2),
			#[0, 2, 3, 6, 7, 9],
			#[0, 1, 3, 7, 8, 11]
		),
	\dur, 0.25
).play;
)


//___indian video game (1)
(
SynthDef("ivg", { arg out, freq=900, pan;
	var trig, snd;
	trig = Impulse.kr(LFClipNoise.kr(4, 3, LFClipNoise.kr(0.2, 2, 7)));
	snd = RLPF.ar(
		SinOsc.ar(freq, 0, Decay.kr(trig, 1.8)).distort
		, 554, 0.3)
	* 0.1;
	Out.ar(out, Pan2.ar(snd, pan))
 }).add;
)

(
	var aroh, avaroh, synth, str, pat;

	//gandhari raga.  vadi: dha (7) samvadi: ga (3)

	aroh = #[0, 2, 5, 7, 10];
	avaroh =  #[0, 1, 3, 5, 7, 9, 10];

	synth = Synth.head(s, \ivg);
	pat = Prand([0, 2, 3, 4, 2, 1, 0, -1, -2], inf);
	str = Pavaroh(pat, aroh, avaroh).asStream;
	Routine({

		loop({
			synth.set(\freq, midicps(str.next + 60) );
			rrand([0.1,1.0].choose, 0.5).wait;
		});

	}).play;
)
::


class:: Pbeta
summary:: random values that follow a Eulerian Beta Distribution
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::prob1
The probability that a value will occur near lo. <1, probability of a value near lo increases. =1, uniform dist. >1 will create a bounded Gaussian-like distribution.

argument::prob2
The probability that a value will occur near hi. <1, probability of a value near lo increases. =1, uniform dist. >1 will create a bounded Gaussian-like distribution.

argument::length
number of values produced (default: inf).

Examples::

code::
(
var a, c, w;
a = Pbeta(0.0, 1.0, 0.1, 0.1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pbeta(0.0, 1.0, 1, 1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);(discrete: true);
)

(
var a, c, w;
a = Pbeta(0.0, 1.0, 3, 3, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pbeta(0.0, 1.0, 0.1, 0.1, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Pbeta(0.0, 1.0, 1.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Pbeta(0.0, 1.0, 3.0, 3.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pbind
summary:: combine several value patterns to one event stream by binding keys to values
related:: Classes/Pattern, Classes/Event, Classes/Pmono, Classes/Rest
categories:: Streams-Patterns-Events>Patterns>Event

description::

Pbind combines several value streams into one event stream. Each value stream is assigned to one or more keys in the resulting event stream. It specifies a stream of strong::Events:: in terms of different patterns that are strong::bound:: to different keys in the Event.
The patterns bound to keys are referred to as emphasis::value patterns:: and the Pbind itself is termed an event pattern.

The keys used in a Pbind are usually determined by link::Classes/Event::'s default mechanism and the controls defined for the link::Classes/SynthDef:: to be played. (See link::#SynthDef and Event:: below for a brief discussion of both in relation to Pbind.)

ClassMethods::

method::new
The arguments to Pbind are an alternating sequence of keys and patterns. A pattern can also be bound to an array of keys. In this case, the pattern must specify a sequence whose elements are arrays with at least as many elements as there are keys.

Examples::

code::
(
a = Pbind(\x, Pseq([1, 2, 3]), \y, Prand([100, 300, 200], inf), \zzz, 99);
x = a.asStream;
)

x.next(()); // pass in an event ()
x.next(());
x.next(());
x.next(()); // end: nil
::

code::
// sound examples

// using the default synth def
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, 0.1).play;
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, Prand([0.1, 0.3], inf)).play;

Pbind(\freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;
::

code::
(
// a SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: Done.freeSelf);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
)

Pbind(\instrument, \test, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;



// standard syntax, arguments alternate symbols and patterns
(
Pbind(
	\instrument,		\test,
	\nharms,	     	Pseq([4, 10, 40], inf),
	\dur,			    Pseq([1, 1, 2, 1]/10, inf),
	#[freq, sustain],	Ptuple([ // assignment to multiple keys
					        Pseq( (1..16) * 50, 4),
				     	    Pseq([1/10, 0.5, 1, 2], inf)
				        ])
).play;
)
::

It is possible to specify a Pbind with an link::Classes/Array:: preceded by *. This takes advantage of a special
syntactic shortcut in SC where using * expands an Array into a list of method arguments. You can see more information
about this and other syntactic shortcuts in link::Reference/Syntax-Shortcuts:: and
link::Overviews/SymbolicNotations::.  Another useful shortcut is that Arrays treat identifiers ending with a colon as
link::Classes/Symbol::s. Both of these shortcuts together help make the syntax of the Pbind specification a bit more
concise:

code::
(
// Alternative syntax, using a key/pattern array:
Pbind(*[
	instrument:			\test,
	nharms:				Pseq([4, 10, 40], inf),
	dur:				Pseq([1, 1, 2, 1]/10, inf),
	#[freq, sustain]:	Ptuple([
							Pseq( (1..16) * 50, 4),
							Pseq([1/10, 0.5, 1, 2], inf)
						])
]).play;
)
::

subsection::SynthDef and Event

The keys used in a Pbind are determined by the link::Classes/SynthDef:: used and the structure of the extensive default mechanism provided by link::Classes/Event::. This section provides a brief review of both.

A link::Classes/SynthDef:: assigns a name to an interconnection of unit generators to be run as a synth on a server. It also assigns strong::control names:: to the synth's control inputs. In the following example the SynthDef \test has control inputs strong::out::, strong::freq::, strong::amp::, strong::nharms::, strong::pan::, and strong::gate::.

code::
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: Done.freeSelf);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
::

The SynthDef needs to be downloaded to the server upon which it is to be run. Use strong::.add:: instead of .send to ensure that any patterns using this SynthDef have information about the available control inputs (see link::Classes/SynthDesc::). Alternately, strong::.store:: may be used to save the SynthDef to disk and add the SynthDesc to the library.

An link::Classes/Event:: is a Dictionary that specifies an action to be taken in response to strong::play:: and a time increment to be returned in response to strong::delta::. Events can be written as a series of key value pairs enclosed in parentheses. Empty parentheses create an empty event.

By default, Events play synths on a server. Such emphasis::note events:: use the following keys:

definitionList::
## instrument (\default) || The synthdef to be played
## variant (nil, optional) || The set of variant control defaults to use (see link::Classes/SynthDef::)
## server (Server.default) || The server that plays the synth
## group (1) || The new synth's or the synth the new synth is placed before or after
## addAction (0) || How the synth is placed relative to the target specified by strong::group::
definitionList::
## 0 || head of group
## 1 || tail of group
## 2 || before group (could be a Synth)
## 3 || after group (could be a Synth)
::
## delta (function) || The time until the next event in a sequence of events, generally specified indirectly through strong::dur::
::

When the Event is played, it creates an OSC command to play a synth. It uses the name assigned to strong::instrument:: to the select the SynthDef to be played. The SynthDef's control names (found in its link::Classes/SynthDesc::) are looked up in the event and the corresponding values included in the command.

Playing a synth is the normal action taken by an Event. The default event structure defines several other event types that can perform a wide variety of server actions. See the link::Classes/Event:: help file for a list of event types.

There are a number of conventional names typically used to identify controls in a synth.

definitionList::
## out || output bus index
## in || input bus index (for filters, modulators, etc)
## gate || envelope gate (not level!) - should default to 1.0, deletes synth when released
## trig || envelope gate (not level!) - should default to 1.0, does not delete synth when released
## pan || panning position
## bufnum || buffer number (used in synths that utilize link::Classes/PlayBuf::, link::Classes/DiskIn::, etc)
## sustain || duration of the synth
## amp || amplitude of the synth
## freq || base pitch of the synth
::

Event implements a layered specification scheme for some of these controls. In the following list, the first and leftmost name is the actual control name, names below and indented are more abstract ways to specify the control.

definitionList::
## delta || The time until the next event. Generally determined by:
definitionList::
## dur || The time until next event in a sequence of events
## stretch || Scales event timings (i.e. stretch == 2 => durations are twice as long)
::
## sustain || Duration of the synth, typically determined (in stretched time units) by:
definitionList::
## legato || The ratio of the synth's duration to the event's duration
::
## amp || synth amplitude (typically ranging from 0 to 1), often determined by
definitionList::
## db || Amplitude in decibels
::
## detunedFreq || actual "pitch" of a synth, determined by:
definitionList::
## freq + detune; || freq is determined by:
definitionList::
## (midinote + ctranspose).midicps * harmonic; || midinote is determined by:
definitionList::
## (note + gtranspose + root)/stepsPerOctave * octave * 12; || note is determined by:
definitionList::
## (degree + mtranspose).degreeToKey(scale, stepsPerOctave) ||
::
::
::
::
::

code::
(
// the SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: Done.freeSelf);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;

// Events are written as parantheses enclosing key/value pairs
(instrument: \test).play;
(instrument: \test, freq: 20, nharms: 50).play;
)
::

subsection::Rests

See link::Classes/Rest:: for a discussion of marking events as rests in Pbind.

subsection::The Play Method

While the play method is actually defined in the class link::Classes/Pattern::, it is useful to review it here:

definitionList::
## play (clock, protoEvent, quant) || returns an link::Classes/EventStreamPlayer::.
## clock || The clock that schedules the EventStreamPlayer, defaults to TempoClock.default. Patterns that change graphics must use link::Classes/AppClock::.
## protoEvent || The initial event modified by Pbind, defaults to Event.default.
## quant || A quantization value used by clock. When a number, the pattern will start at the next even multiple of that number. May also be a link::Classes/Quant::, which specifies quantization, time position within that quantization, and a timingOffset. See link::Classes/Quant:: for details.
::

subsection::Realtime Control with EventStreamPlayer

The link::Classes/EventStreamPlayer:: provides realtime control through strong::mute::, strong::unmute::, strong::stop::, strong::play:: and strong::reset::.

code::
(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
	var out, eg, fc, osc, a, b, w;
	fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
	osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
	eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction: Done.freeSelf);
	out = eg * RLPF.ar(osc, fc, 0.1);
	#a, b = out;
	Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

e = Pbind(
	\degree, Pseq((0..12), inf),
	\dur, 0.2,
	\instrument, \cfstring1
).play; // returns an EventStream
)

( // an interactive session
e.stop
e.play
e.reset

e.mute; // keeps playing, but replaces notes with rests

e.unmute;

e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.

e.pause; // will resume where paused.

e.play;

e.stop; // will reset before resume.

e.play;
)
::

In addition, the stream the EventStreamPlayer plays can be altered while it is running through the method
strong::stream_(aStream)::.

code::
(
e.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf),
	\amp, 0.05, \octave, 5,
	\instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf),
	\amp, 0.05, \octave, 5,
	\instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
	\degree, Pxrand([0, 1, 2, 4, 6, 3, 5, 7, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf), \amp, 0.05,
	\octave, 5, \instrument, \cfstring1
).asStream;
)
::

subsection::Additional arguments

Here is an example with more bindings. Here we have added a filter with cutoff and resonance arguments.
You will need to hit command '.' before executing the next few pbind ex. without having them stack up.
also, due to the synthdef's and synthdeclib, if the server is shut down you will have to reload the
synthdef and re-read the synthdesclib.

code::
(
SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 1, cut = 4000, rez = 0.8, amp = 1;
	Out.ar(out,
		Pan2.ar(
			RLPF.ar(
				Pulse.ar(freq, 0.05),
			cut, rez),
		pan) * EnvGen.kr(Env.linen(0.01, 1, 0.3), gate, amp, doneAction: Done.freeSelf);
	)
}).add;
)

(
Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, -12,
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2).play;
)
::

The link::Classes/ListPattern::s can be put around Event Streams to create sequences of Event Streams.

code::
(
Pseq([
	Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
		\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
		\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2),

	Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
		\pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)
::

'Pseq' in the above ex. can be any pattern object:

code::
(
Prand([
	Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
		\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
		\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}),
		\amp, 0.2),

	Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
		\pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)
::

subsection::Multichannel Expansion

If we supply an array for strong::any:: argument, the synth node will automatically replicate to handle the additional arguments.

The only strong::exception:: to this is: code::\instrument:: and code::\dur::. For the general schema, see also: link::Guides/Multichannel-Expansion::.

code::
// When we provide the 'root' argument an array, we should hear a chord.
// the synth def is defined above
(
Pbind(
	\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf),
	\root, [-24, -17],  // expand root
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf),
	\pan, Pfunc { 1.0.rand2 },
	\cut, Pxrand([1000, 500, 2000, 300], inf),
	\rez, Pfunc { 0.7.rand + 0.3 },
	\amp, 0.2).play;
);

// multiple arrays are correlated in parallel, the shorter one wraps:
(
Pbind(
	\instrument, \acid,
	\dur, Pseq([0.25, 0.5, 0.25], inf),
	\root, [-24, -17], // expand root ...
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf) + [0, 6, 9], // ... and expand degrees
	\pan, Pfunc { 1.0.rand2 },
	\cut, Pxrand([1000, 500, 2000, 300], inf),
	\rez, Pfunc { 0.7.rand + 0.3 },
	\amp, 0.2).play;
);
::

note::In Pbind, you can’t have arrays of patterns, but only patterns that strong::return:: arrays.::

code::
// so this does not expand:
Pbind(\degree, [Pseq([0, 2, 3], inf), Pseq([2, 4, 5, 6], inf)]).play;

// but this does:
Pbind(\degree, Pseq([ [ 0, 2 ], [ 2, 4 ], [ 3, 5 ], [ 0, 6 ] ], inf)).play;
::


code::
// transform an array of patterns into a pattern that returns arrays, use Ptuple:
a = [Pseq([1, 2, 3], inf), Prand([100, 299, 399], inf), Pseries(0, 6, inf)];
b = Ptuple(a);
b.asStream.nextN(8)
::

code::
Pbind(\degree, Ptuple([Pseq([0, 2, 3], inf), Pseq([2, 4, 5, 6], inf)])).play;
::

code::
// an example: instead of \degree, [p1, p2] you write \degree, Ptuple([p1, p2])
(
Pdef(\x,
	Pbind(
		\instrument, \test,
		\legato, 0.2,
		\degree, Ptuple([0, Pwalk(Scale.hijaz.degrees, Prand([1, -1], inf))]),
		\scale, Scale.hijaz,
		\strum, 0.05
	)
).play;
)
::


subsection::Experimenting with Patterns

Using link::Classes/Pdef:: (provided by link::Overviews/JITLib::) makes it easy to replace patterns on the fly:

code::
(
Pdef(\buckyball).play;
)

(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0, 3, 5, 7, 9, 11, [5, 17], 1], inf), \pan, Pfunc({[1.0.rand2, 1.0.rand2]}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, [0.15, 0.22]));
)
(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0b, 3b, 5b, 7b, 9b, 11b, 5b, 0b], inf), \pan, Pfunc({1.0.rand2}), //notice the flats
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2));
)

//stop the Pdef
Pdef(\buckyball).stop;

//start the Pdef
Pdef(\buckyball).resume;

//removing the Pdef
Pdef.remove(\buckyball);
::

subsection::Sending to effects

Assignment to effect processors can be achieved by setting the 'out' argument to the desired efx's input bus. The effect Synth must also be created. Synth.new is one way of doing this.

code::
(
// efx synthdef- dig the timing on the delay and the pbind. :-P
SynthDef(\pbindefx, { arg out, in, time1=0.25, time2=0.5;
	var audio, efx;
	audio = In.ar([20, 21], 2);
	efx=CombN.ar(audio, 0.5, [time1, time2], 10, 1, audio);
	Out.ar(out, efx);
}).add;

// create efx synth
a = Synth.after(1, \pbindefx);

// if you don't like the beats change to 0.4, 0.24
// a.set(\time1, 0.4, \time2, 0.24);

SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 0, cut = 4000, rez = 0.8, amp = 1;
	Out.ar(out,
		Pan2.ar(
			RLPF.ar(
				Pulse.ar(freq, 0.05),
			cut, rez),
		pan) * EnvGen.kr(Env.linen(0.02, 1, 0.3), gate, amp, doneAction: Done.freeSelf);
	)
}).add;
)

(
Pbind(\instrument, \acid, \out, 20, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.12).play;
)
::

subsection::Additional examples

code::
(
SynthDef(\berlinb, { arg out=0, freq = 80, amp = 0.01, pan=0, gate=1;
	var synth, env;
	env = Decay2.kr(gate, 0.05, 8, 0.0003);
	synth = RLPF.ar(
		LFPulse.ar(freq, 0, SinOsc.kr(0.12, [0, 0.5pi], 0.48, 0.5)),
		freq * SinOsc.kr(0.21, 0, 18, 20),
		0.07
	);
	#a, b = synth*env;
	DetectSilence.ar(a, 0.1, doneAction: Done.freeSelf);
	Out.ar(out, amp * Mix.ar(PanAz.ar(4, [a, b], [pan, pan+1])));
}).add;
)

(
f = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, 0.5, \octave, 3, \instrument, \berlinb
).play;
)

(
f.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, 0.5, \octave, [2, 1],
	\instrument, \berlinb,
	\pan, Pfunc({1.0.rand2})
).asStream;
)
::


class:: PbindProxy
summary:: incremental event pattern reference
categories:: JITLib>Patterns,  Streams-Patterns-Events>Patterns, Live Coding
related:: Classes/Pbindef, Classes/Pdef

description::
keeps a reference to a link::Classes/Pbind:: in which single keys can be replaced. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

ClassMethods::

method::new
create a new instance of PbindProxy with the given patternpairs

InstanceMethods::

method::source
returns the wrapper for the Pbind

method::set
set the given patternpairs.

method::at
return a pattern at that key. this can be used to set quant value individually, so different elementary patterns can be quantized differently.
code::
x.at(\freq).quant = 2;
::

method::quant
set the quant of all elementary patterns, or return the quant value of the source pattern.

Examples::

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction: Done.freeSelf);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));
}).add;
)
s.boot;


x = PbindProxy.new;
x.set(\instrument, \Pdefhelp);

x.play;

x.set(\degree, Pseq([0, 2, 5b, 1b], inf));
x.set(\dur, 0.1);
x.set(\degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
x.set(\legato, Prand([1.0, 2.4, 0.2], inf), \mtranspose, -3);
x.set(\mtranspose, nil); // remove key

x.set(\degree, Pseq([1, 2, 3, 4, 5, 6], 1));
x.play;

x.set( \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.02);
x.play;

x.set(\degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.1);
x.play;


// embed in other patterns:
(
x.set(\degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
Ppar([
x,
Pbindf(x, \ctranspose, 4)
]).play;
)


x.set(\degree, Pseq([1b, 5, 1b, 4, 0], inf), \dur, 0.4);
::


class:: Pbindef
summary:: incremental event pattern reference definition
categories:: JITLib>Patterns, Live Coding,  Streams-Patterns-Events>Patterns
related:: Classes/Pdef, Classes/Pbind

description::
Pbindef keeps a reference to a Pbind in which single keys can be replaced, combining link::Classes/PbindProxy:: and link::Classes/Pdef::. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

the difference to Pdef is that it allows to incrementally change the elementary patterns (patternpairs) of a Pbind - also of an already existing Pbind inside a Pdef.

Pbindef and Pdef use the same global collection, while Pdef and Pdefn use separate ones.

Pbindef inherits most methods from link::Classes/Pdef::. Overview: link::Overviews/JITLib::

ClassMethods::

method::new
store the pattern in the global dictionary of link::Classes/Pdef:: under key. (if there is already a Pdef there, replace its pattern with the new one. If there is already a strong::Pbindef:: there, set the parameters only, or add a new one (the whole pattern is replaced).

Using strong::*new(key):: you can access the pattern at that key (if none is there, a default pattern is created). see link::Classes/Pdef::.

Examples::

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.01, sustain), 1, doneAction: Done.freeSelf);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));
}).add;
)
s.boot;


Pbindef(\a, \instrument, \Pdefhelp).play;
Pbindef(\a, \degree, Pseq([0, 2, 5b, 1b], inf));
Pbindef(\a, \dur, 0.1);
Pbindef(\a, \degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
Pbindef(\a, \legato, Prand([1.0, 2.4, 0.2], inf), \mtranspose, -3);
Pbindef(\a, \mtranspose, nil); // remove key

Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1));
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.02);
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.1);

// apart from this Pbindef behaves like Pdef:

Pbindef(\a).quant = 0.0;
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1));

Pbindef(\a).stop;
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1)); // does not resume now

Pbindef(\a).playOnce; // play single instance
Pseq([Pbindef(\a), Pdef(\a)]).play; // same here (Pdef(\a) is the same pattern as Pbindef))

Pbindef(\a) === Pdef(\a) // identical.



// an already existing Pdef can be incrementally changed

Pdef(\x, Pbind(\instrument, \Pdefhelp, \dur, 0.3));
Pdef(\x).play;

Pbindef(\x, \degree, 7.rand);
Pbindef(\x, \degree, Pseq([0, 7, 3, 7, 4], inf), \dur, Pn(Pseries(0.2, -0.02, 10)));
Pbindef(\x, \stretch, 2);
::


class:: Pbindf
summary:: bind several value patterns to one existing event stream by binding keys to values
related:: Classes/Pattern, Classes/Event, Classes/Pbind, Classes/Pchain
categories:: Streams-Patterns-Events>Patterns>Composition

description::

Pbindf adds several value streams into one existing event stream. Each value stream is assigned to one or more keys in the resulting event stream, overriding any values from the input stream.

The patterns bound to keys are referred to as value patterns and the Pbindf itself is termed an emphasis::event pattern::.

ClassMethods::

method::new
The arguments to Pbindf is the initial pattern followed by an alternating sequence of keys and patterns. A pattern can also be bound to an array of keys. In this case, the pattern must specify a sequence whose elements are arrays with at least as many elements as there are keys.

Examples::

code::
(
a = Pbind(\x, Pseq([1, 2, 3]), \zzz, 9000); // input stream
b = Pbindf(a, \y, Prand([100, 300, 200], inf), \zzz, 99);
x = b.asStream;
)

x.next(()); // pass in an event ()
x.next(());
x.next(());
x.next(()); // end: nil



// sound examples

// using the default synth def
a = Pbind(\dur, 0.1);
Pbindf(a, \freq, Prand([300, 500, 231.2, 399.2], inf)).play;
Pbindf(a, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200).play;


(
// a SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: Done.freeSelf);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
)

a = Pbind(\instrument, \test, \dur, 0.1);

Pbindf(a, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200).play;
::


class:: Pbinop
summary:: binary operator pattern
related:: Classes/Pnaryop, Classes/Punop, Classes/BinaryOpFunction
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the binary operator to the stream values of the receiver. Usually, this is the result of applying a binary operator (i.e. a method with one argument) to a pattern.

Examples of binary operators are: +, -, /, *, min, max, hypot ...

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

argument::b
a pattern (or compatible pattern input)

argument::adverb

Examples::

code::
(
var a;
a = Pbinop(\hypot, Pseries(0, 1, 12), Pseries(3, -1, 12));
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).hypot(Pseries(3, -1, 12));
a.asStream.all;
)

// also written as:
(
var a;
a = Pseries(0, 1, 12) hypot: Pseries(3, -1, 12);
a.asStream.all;
)

// some common cases:
Pseq([1, 2, 3]) + 2;
Pseq([1, 2, 3]) / Pseq([3, 4, 5, 6]);
max(Pwhite(-10, 10, inf), Pseq([0, 2, 3, 4]));
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Pbinop(\hypot, Pseries(0, 1, 34), Pseries(3, -1, 34)), inf).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Pbinop(\hypot, Pwhite(0, 12, 13), Pseries(3, -1, 12)))
).play;
)



// these are the same as:

(
var a;
a = Pn(Pseries(0, 1, 34) hypot: Pseries(3, -1, 34), inf).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)


(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Pwhite(0, 12, 13) hypot: Pseries(3, -1, 12))
).play;
)
::


class:: Pbrown
summary:: brownian motion pattern
related:: Classes/BrownNoise, Classes/Pgbrown
categories:: Streams-Patterns-Events>Patterns>Random

description::

Returns a stream that behaves like a brownian motion.

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::step
maximum change per step - the distribution is xrand2.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pbrown(0.0, 1.0, 0.1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbrown", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a;
a = Pbrown(0.0, 1.0, 0.2, inf);
a.asStream.nextN(1000).plot;
)
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pbrown(0.0, 1.0, 0.1, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)



// parallel browninan motions
(
var a, x, f;
a = Pbrown(0.0, 1.0, 0.1, inf);

f = { |pattern, dt=0.02, min=300, max=900|
	{
		var x = pattern.asStream;
		loop {
			Synth.grain(\help_sinegrain, [\freq, x.next.linexp(0, 1, min, max), \sustain, dt]);
			dt.wait;
		}
	}.fork;
}.flop;

// 3 parallel motions
f.(a, [0.02, 0.08, 0.16]);
)
::


class:: Pbus
summary:: isolate a pattern by restricting it to a bus
related:: Classes/Pfx, Classes/Pfxb, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Starts a new group and plays the pattern in this group, on a private bus. The group and the bus is released when the stream has ended.

This is useful in order to isolate a link::Classes/Pfx::.

ClassMethods::

method::new

argument::pattern

argument::dur
delay to allow inner patterns to decay.

argument::fadeTime
fading out the inner pattern after dur over this time.

argument::numChannels
number of channels of the bus (should match the synthdef).

argument::rate
bus rate.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

 // watch the node structure as it changes
s.waitForBoot({ s.plotTree });


(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Ppar(
	[p, q, r, o].collect(Pbus(_)); // play each in a different bus.
).play;
)



// compare to playing them together on one bus.
(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Ppar([p, q, r, o]).play;
)
::


class:: Pcauchy
summary:: random values that follow a Cauchy Distribution
related:: Classes/BrownNoise, Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::spread
The horizontal dispersion of the random values. The distribution is unbounded.

argument::length
Number of values produced.

Examples::

code::
(
var a, c, w;
a = Pcauchy(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pcauchy", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pcauchy(0.0, 10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pcauchy(0.0, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pchain
summary:: pass values from stream to stream
related:: Classes/Pbindf
categories:: Streams-Patterns-Events>Patterns>Composition

description::

definitionList::
## Pchain(pattern1, pattern2, ... patternN) || pattern1 <- pattern2 <- ...patternN
::

Values produced by the stream of strong::pattern2:: are used as inval to the stream of strong::pattern1::. Therefore pattern1 overrides (or filters) the output of pattern2, and so forth. This is an equivalent to the composite pattern: emphasis::pattern1 <> pattern2 <> ... patternN::

ClassMethods::

method::new

argument:: ... patterns
The patterns to be chained up.

InstanceMethods::

method::<>
Add another pattern to the chain.

Examples::

code::
(
Pchain(
	Pbind(\detune, Pseq([-30, 0, 40], inf), \dur, Prand([0.2, 0.4], inf)),
	Pbind(\degree, Pseq([1, 2, 3], inf), \dur, 1)
).trace.play;
)


// also events can be used directly:
(
Pchain(
	Pbind(\degree, Pseq([1, 2, 3], inf)),
	(detune: [0, 4])
).trace.play;
)

// compose some more complicated patterns:
(
var a, b;
a = Prand([
	Pbind(\degree, Pseq([0, 1, 3, 5, 6])),
	Pbind(\dur, Pshuf([0.4, 0.3, 0.3]), \degree, Pseq([3, -1]))
], inf);
b = Prand([
	Pbind(\ctranspose, Pn(1, 4)),
	Pbind(\mtranspose, Pn(2, 7))
], inf);
c = Prand([
	Pbind(\detune, Pfuncn( { [0, 10.0].rand }, 5), \legato, 0.2, \dur, 0.2),
	Pbind(\legato, Pseq([0.2, 0.5, 1.5], 2), \dur, 0.3)
], inf);
Pchain(a, b, c).trace.play;
)
::

section::pattern composition

pattern <> pattern <> pattern

code::
// implicitly, the composition operator <> returns a Pchain when applied to a pattern.
// so that a <> b creates a Pchain (a, b).
// as seen above, in Pchain(a, b), a specifies (and overrides) b: b is the input to a.

// the above example is equivalent to:

(Pbind(\degree, Pseq([1, 2, 3], inf)) <> (detune: [0, 4])).trace.play;

(
a = Pbind(\degree, Pseq([1, 2, 3], inf), \dur, Prand([0.2, 0.4], inf));
b = Pbind(\detune, Pseq([-30, 0, [0, 40]], inf), \dur, 0.1);
c = b <> a;
c.play; // see that the \dur key of a is overridden by b
)

// also value streams can be composed
(
a = Pfunc { |x| x + 1.33 };
b = Pfunc { |x| x * 3 };
c = Pseries(1, 2, inf);
)

// post some values from the composite streams:

t = (a <> b).asStream;
10.do { t.value(10).postln };

t = (a <> b <> c).asStream;
10.do { t.value(10).postln };

t = (b <> c <> a).asStream;
10.do { t.value(10).postln };
::


TITLE:: Pclump
summary:: A pattern that takes another pattern and groups its values into arrays.
related:: Classes/SequenceableCollection#-clump
categories:: Streams-Patterns-Events>Patterns>List

DESCRIPTION::
Groups the source pattern into arrays whose size is given by n. Similar to LINK::Classes/SequenceableCollection#-clump::.

E.g. If the source pattern has 5 elements and you choose a clump size of 2, the new pattern will return two arrays containing 2 elements and a final array containing 1 element.

CLASSMETHODS::

METHOD:: new

ARGUMENT:: n
An integer, or a pattern that returns an integer. This integer will determine the size of the next clump.

ARGUMENT:: pattern
The pattern to be filtered.

EXAMPLES::

code::
// This will give you the sequence: [1, 2] [3] nil
// Note that the last grouping is just the remainder of the pattern (in this case [3]).
x = Pclump(2, Pseq([1,2,3], 1)).asStream;
x.next;
x.next;
x.next;
::

Play some random chords:
code::

Pbind(
  \degree, Pclump(Pseq([3, 3, 4, 2, 4, 2, 4], inf), Pseq([1, 3, 5, 7, 9], 8), inf),
  \dur, 1).play
::


class:: Pclutch
summary:: sample and hold a pattern
related:: Classes/StreamClutch, Classes/Pdup, Classes/Latch
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new

argument::pattern
any pattern.

argument::connected
a pattern that returns either a series of link::Classes/Boolean::s or the equivalent 0 and 1. If true (or 1), the pattern plays as usual, if false (or 0), the previous value is kept.

Examples::

code::
Pclutch(Pseq([1, 2, 3, 4, 5], 3), Pseq([0, 0, 1, 0, 0, 0, 1, 1])).asStream.nextN(10);

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pclutch(
		Pseq([1, 2, 3, 4, 5], inf),
		Pseq([0, 0, 1, 0, Pn(0, {30.rand}), 0, 1, 1], inf)
	).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 200 + 200]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pcollect
summary:: Apply a function to a pattern
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pselect, Classes/Preject

description::
Modifies each value by passing it to the function. This is the pattern library's equivalent of link::Classes/Collection#-collect::.

classmethods::

method:: new
argument:: func
A link::Classes/Function::. Receives values from code::pattern::.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
a = Pcollect( { |item| item * 3 }, Pseq( #[ 1, 2, 3 ], inf ) );
x = a.asStream;
9.do( { x.next.postln; } );
)
::

The message code::collect:: returns a Pcollect when passed to a pattern. Note that because the pattern is converted to a link::Classes/Stream:: (more precisely a link::Classes/FuncStream::) the collect function is evaluated for one item each time the message code::next:: is passed.
code::
(
a = Pseq( #[ 1, 2, 3 ], inf ).collect( { arg item; item * 3 } );
a.postln;

x = a.asStream;
9.do( { x.next.postln; } );
)
::


class:: Pconst
summary:: constrain the sum of a value pattern
related:: Classes/Pfindur, Classes/Pfin, Classes/Pfinval
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

Similar to link::Classes/Pfindur::, but works with the value directly.

note::
Be careful if this is used, directly or indirectly, for a note-length parameter! The difference may be very small and this could result in zombie nodes, due to a bug in link::Classes/EnvGen:: for very short sustain times.
::

ClassMethods::

method::new
Embeds elements of the strong::pattern:: into the stream until the sum comes close enough to strong::sum::. At that point, the difference between the specified sum and the actual running sum is embedded.

Examples::

code::
(
var a, x;
a = Pconst(5, Prand([1, 2, 0.5, 0.1], inf));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)


//Pconst used as a sequence of durations

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
Pn(
	Pbind(
		\dur, Pconst(1, Prand([1, 0.02, 0.2], inf)),
		\instrument, \help_sinegrain,
		\degree, Pseries(0, 1, inf),
		\octave, 6
	)
).play;
)
::


class:: Pdef
summary:: stream reference definition
categories:: JITLib>Patterns
related:: Classes/Pdefn, Classes/PdefGui

description::
Pdef registers patterns by key. All accesses to the registered patterns go through the Pdef class via that key. Registered patterns can be replaced while running. The old pattern and its replacement can automatically crossfade and the time of replacement can be quantized.

Pdef is a class that provides an interface to its superclass link::Classes/EventPatternProxy::, keeping a reference to a stream that can be replaced while playing. One pattern may be used in many streams in different places. A change in the pattern definition propagates through all streams.

Pdef and Pdefn use separate global collections.

code::
Pdef(key)	//returns the instance
Pdef(key, pat)	//stores the pattern and returns the instance, like Tdef and Ndef.
::

It can be used to store event Patterns globally. Changes in this global library have immediate effect.

For strong::non-event patterns:: link::Classes/Pdefn:: is used instead. For another use of Pdef see also link::Tutorials/JITLib/recursive_phrasing::. Graphical overview over all current Pdefs: link::Classes/PdefAllGui::. Overview: link::Overviews/JITLib::.

subsection::First Example

code::
s.boot;

Pdef(\x, Pbind(\note, Pbrown(0, 6, 0.1, inf)));
Pdef(\x).quant = 0; // no waiting.
Pbindf(Pdef(\x), \dur, 0.03).play;
Pbindf(Pdef(\x), \dur, 0.1, \ctranspose, 15).play;
Pbindf(Pdef(\x), \dur, 0.3, \ctranspose, 2).play;
// now change the definition
Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));
Pdef(\x, Pbind(\freq, Pseq([1000, 1923, 245.2, 1718] / 1.2 + 0.1, inf)));
::

ClassMethods::

method::all
A global link::Classes/IdentityDictionary:: with all proxies.


private::initClass

subsection::Creation

method::new
Store the pattern in a global dictionary under key, replacing its pattern with the new one. If the pattern is a strong::function::, Pdef creates a link::Classes/PlazyEnvir:: internally that dynamically creates the pattern returned from the function, applying the arguments from the inevent.

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default silent event is created)

argument::key
An identifier for the proxy. Usually, it is a link::Classes/Symbol::. The key transparently accesses the global link::Classes/IdentityDictionary::.

argument::item
An object for (re)defining the source of the proxy. If code::nil::, the proxy is returned unmodified.

code::

(
SynthDef(\Pdefhelp, { arg out, freq, sustain=1, amp=1, pan;
    var env = EnvGen.kr(Env.perc(0.01, sustain), 1, doneAction: Done.freeSelf);
    Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0.5pi, amp * env), pan));
}).add;
)

// event pattern as an argument
Pdef(\x, Pbind(\instrument, \Pdefhelp, \note, Pbrown(0, 6, 0.1, inf), \dur, 0.2));
Pdef(\x); // omitting the second argument, we can access the proxy
Pdef(\x).play; // ... play one event stream
Pdef(\x).source.postcs; // ... and inspect the event pattern itself.


// function as an argument, create a new pattern each time it is called
Pdef(\x, { Pbind(\note, Pseries(10.rand, 5.rand, 8.rand + 1), \dur, 1 / (8.rand + 1)) });
Pn(Pdef(\x)).play;

// the function is called in the incoming event as current environment, so parameters can be passed:
Pdef(\stut, { Pdup(~dup ? 1, ~pattern) });
Pdef(\x, Pbind(\instrument, \Pdefhelp, \note, Pseq([0, 4, 7, 3, 0, 1, 0], inf)));
Pdef(\y, Pdef(\stut) <> (pattern: Pdef(\x), dup: Pseq([2, 2, 4, 3], inf)) <> (dur: 0.1, legato: 0.2)).play;

::



method::default
Default source, if none is given. The default is an Event.silent of 1.0 beat duration.

method::removeAll
Remove all proxies from the global dictionary ( link::#*all:: )

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all Pdefs.

method::defaultQuant
Set the default quantisation for new instances (default: 1.0). This can be an array [quant, phase, timingOffset, outset]

InstanceMethods::

private::prAdd

subsection::Changing the definition / setting the source

One pattern may have many streams in different places. A change in the pattern definition Pdef propagates through all streams. The change does not have to be immediate - there is a scheme to schedule when the change becomes effective: a strong::quant:: and strong::clock:: (like elsewhere) and a strong::condition::.

method::clock
get or set the instance's default clock, used by link::#-play:: if no other clock is specified. Defaults to TempoClock.default.

method::quant
Set the quantisation time for beat accurate scheduling.

argument::val
can be an array strong::[quant, phase, timingOffset, outset] ::, or just strong::[quant, phase]:: etc.

method::condition
Provide a condition under which the pattern is switched when a new one is inserted. The stream value and a count value is passed into the function.

method::count
Create and update condition that simply counts up to n and switches the pattern then

method::reset
Switch the pattern immediately (stuck conditions can be subverted by this).

method::fadeTime
When the synthdefs that are used contain an code::\amp:: control, the patterns are replaced by crossfading the previous with the new over this time (in beats)

method::envir
Set the event for the Pdef. It is used to filter the incoming stream before it is passed to the source pattern. This is similar to link::Classes/NodeProxy#-nodeMap::. When set for the first time, the pattern is rebuilt.

method::set
Set arguments in the default event. If there is none, it is created and the pattern is rebuilt.

method::map
Map Pdefn to the keys in the event.

method::clear
Set the source to nil

method::endless
Returns a link::Classes/Prout:: that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (silent event). This allows to create streams that idle on until a new pattern is inserted.

subsection::Pdef as stream reference

A single Pdef may serve as a definition for multiple streams. These methods show how to fork off separate streams from one instance. Even if they run in different contexts, their definition may still be changed.

method::fork
Play an independent stream in parallel.

argument::argClock
The clock to run the substream on.

argument::quant
can be an array of [quant, phase, offset], or a link::Classes/Quant:: value.

argument::protoEvent
An link::Classes/Event:: to pass in that is used by the substream

returns:: an link::Classes/EventStreamPlayer::.


method::embed
Pass a value (typically an link::Classes/Event::) into the pattern inval, and embed the Pdef in the stream.

embedInStream
just like any pattern, embeds itself in stream

subsection::Pdef as EventStreamPlayer

For live coding, each Pdef also may control one instance that plays one stream off it. This is an link::Classes/EventStreamPlayer::, accessible in the instance variable link::#-player::.

method::play
Starts the Pdef and creates a player. (See: link::Classes/EventPatternProxy#-play::)

method::stop
Stops the player

method::player
Return the current player (if the Pdef is simply used in other streams this is nil)

method::pause, resume, reset
Perform this method on the player.

method::isPlaying
Returns true if player is running. If a Pdef is playing and its stream ends, it will schedule a stream for playing strong::as soon as a new one is assigned to it::. If it is stopped by strong::stop::, it won't.

Examples::

subsection::Pdef as stream reference

code::

s.boot;

(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction: Done.freeSelf);
	3.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
)

Pdef(\metronom, Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, 16, \legato, 0.1)).play;

x = Pseq([Pdef(\a), Pdef(\b), Pdef(\c)], inf).play;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3])));
Pdef(\b, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8])));
Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2)));




Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[4, 3, 1, 2]*3)));


// infinite loops are scheduled (to ths clock's next beat by default) and released:

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pseq(#[0, 5, 4, 3, 2], inf)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5, 4, 3] + 1, 1)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3] - 4, 1)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5] - 1, 1)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pshuf(#[0, 5, 4, 3, 2], inf)));

x.stop;
Pdef(\metronom).stop;

// Pdef can be used in multiple patterns:

(
x = Ppar([
	Pbindf(Pn(Pdef(\a), inf),
		\gtranspose, Pdup(8, Pseq(#[0, 2, 0, 3],inf))
	),
	Pbindf(Pn(Pdef(\a), inf),
		\gtranspose, Pdup(8, Pseq(#[7, 4, 0, 3],inf)),
		\dur, 0.6
	),
	Pbindf(Pn(Pdef(\a), inf),
		\degree, Pseq(#[0, 5, 4, 3, 2, 3, 2], 1)
	)
]).play;
)

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1, 0, 1, 2], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, Pseq([0, 4], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1b, 1, 2b, 2, 3, 4b, 4, 5], inf)));

// using a fade time, the above changes are crossfaded
Pdef(\a).fadeTime = 2;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf)));

// ...

Pdef(\a).set(\detune, -50); // set environment
Pdef(\a).set(\detune, 0);

x.stop;
::

subsection::Pdef as EventStreamPlayer

code::
(
// load a synthdef
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)


Pdef(\x); // creates a Pdef with a default pattern.


Pdef(\x).play; // play it. A silent resting pattern is used.
Pdef(\y).play; // play a second one (automatically instantiated)


// assign various patterns to it:

Pdef(\x, Pbind(\dur, 0.25, \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6], inf), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]+1, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-1, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b]-2, inf), \instrument, \gpdef));

// using fadeTime:

Pdef(\y).fadeTime = 8.0;
Pdef(\y, Pbind(\dur, 0.125, \degree, Pseq([3, 4, 5b, 6]+4.rand, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-2, inf), \instrument, \gpdef));

(
Pdef(\x, Pbind(
		\dur, 1 / 6,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1) - 5, 6]+1, inf),
		\instrument, \gpdef
		)
	);
)
(
Pdef(\x, Pbind(
		\dur, 0.25,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1), 6], inf),
		\instrument, \gpdef)
	);
)
Pdef(\x).stop;

Pdef(\x).play;

// tempo change
TempoClock.default.tempo = 1.3;
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5, 6]+1, inf), \instrument, \gpdef));

// drop in ending patterns

Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, [7,4], 5, 6]-2), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.125, \degree, Pseq([3, [7,4], 5, 4]-3), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.35, \degree, Pseq([3, [7,4], 5, 4, 3]-3), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pshuf([3, [7,4], 5, 6]-2), \instrument, \gpdef));


// clear all.
Pdef(\x).clear;
Pdef(\y).clear;
TempoClock.default.tempo = 1.0;


// GUI example: see also
PdefAllGui(18);
::

subsection::Recursion

Pdefs can be used recursively under the condition that the stream call structure allows it. a structure like the following works:

code::
Pdef(\x, Pseq([Pbind(\instrument, \gpdef), Pdef(\x)], inf));
Pdef(\x).play;
::

but the following would crash, because code::.embedInStream:: is called recursively with no limit:

code::
// Pdef(\y, Pseq([Pdef(\y), Pbind(\instrument, \gpdef)], inf));
::

subsection::Quantizing and outset

When quantizing to a larger number of beats, the changes become very slow if one has to wait for the next beat. Providing an strong::outset:: quant value is a way to make the change so that it appears as if it had been done at the previous grid point already. The stream is fast forwarded to the current position relative to the quant grid. Providing a number larger than zero, the next possible quant point is used as outset.

For example, if quant is 32, and one has just missed the first beat when changing the pattern,
one has to wait for 32 beats until the change happens. Using an outset of 1, it is assumed that you had already
changed the pattern at the first beat, the stream is fast forwarded to the time it would be at now if you had done so. The new pattern is inserted at the next beat (outset=1).

quant can be: strong::[quant, phase, timingOffset, outset]::

note::
This fast forwarding might create a cpu peak if the pattern is very complex/fast or quant is very long. This is hard to avoid, so it simply has to be taken into account.
::

code::
(
Pdef(\x).quant_([8, 0, 0, 1]);
Pdef(\y).quant_([8, 0.5, 0, 1]); // phase: half a beat
Pdef(\x).play;
Pdef(\y).play;
)

Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf)));
Pdef(\y, Pbind(\degree, Pseq((0..7)-2, inf)));
Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf), \dur, 0.5));
Pdef(\y, Pbind(\degree, Pseq((0..7).scramble-2, inf), \dur, 0.25, \legato, 0.3));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf)));

Pdef(\x, Pbind(\degree, Pseq([ 1, 5, 6, 7, 0, 3, 2, 4 ], inf), \dur, 1));
Pdef(\x, Pbind(\degree, Pseq([ 0, 2, 2, 4, 0, 4, 0, 4 ], inf), \dur, 1));

Pdef(\x).quant_([8, 1/3, 0, 1]); // phase: 1/6 beat relative to y
Pdef(\x, Pbind(\degree, Pseq([ 1, 1, 1, 7, 0, 2, 2, 4 ], inf), \legato, 0.1));
Pdef(\x, Pbind(\degree, Pseq([ 3, 3, 3, 4b ], inf), \legato, 0.1));
Pdef(\y, Pbind(\degree, Pseq((0..7).scramble-4, inf), \dur, 0.25, \legato, 0.3));




// some testing
(
var quant = #[8, 0, 0, 1]; // quantise to 8 beats, no phase, insert quant to 1 beat
Pdef(\x).quant_(quant);
Pdef(\x).play;
Routine { loop { 8.do { |i| ("uhr:"+i).postln; 1.wait } } }.play(quant:quant);
Pbind(\degree, Pseq((0..7), inf)).play(quant:quant);
)

Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf)).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf) + [0, 3]).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf) + [0, 6], \dur, 0.5).trace(\degree));


Pdef(\x).fadeTime = 8;

Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7).reverse, inf) + [0, 6], \dur, 0.5));

Pdef(\x).fadeTime = nil;
Pdef(\x).quant = 1;

Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));

Pdef(\x).quant = 8;
Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));
::

subsection::Update condition

In order to be able to switch to a new pattern under a certain link::#-condition::, the instance variable condition can be set to a function that returns a boolean. Value and a count index are passed to the function. The condition is always valid for the strong::next pattern:: inserted. For stuck conditions, the link::#-reset:: message can be used.

As counting up (such as emphasis::"every nth event, a swap can happen"::) is a common task, there is a method for this, called link::#-count::(n).

code::
Pdef(\x).play;
Pdef(\x).quant = 0; // we don't want quant here.
Pdef(\x, Pbind(\degree, Pseq((0..5), inf), \dur, 0.3)).condition_({ |val, i| i.postln % 6 == 0 });
Pdef(\x, Pbind(\degree, Pseq((0..7) + 5.rand, inf), \dur, 0.3)).condition_({ |val, i| (i % 8).postln == 0 });

// the above is equivalent to:
Pdef(\x, Pbind(\degree, Pseq((0..7) + 5.rand, inf), \dur, 0.3)).count(8);

// the value that is sent in is the event, so decisions can be made dependent on the event's fields
::

subsection::reset

code::
// reset to change immediately:
Pdef(\x).reset;
::


class:: PdefAllGui
summary:: see all Pdefs and their state
categories:: JITLib>GUI, Live Coding
related:: Classes/TdefAllGui, Classes/PdefGui

description::

PdefAllGui uses link::Classes/PdefGui:: views to display all Pdefs, or a selection. Overview: link::Overviews/JITLib::

ClassMethods::

subsection::Creation

method::new

argument::numItems
the maximum number of Pdefs that can be shown.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
///// Not Done Yet, but on the list

A flag whether to make a skipjack.

argument::options
///// Not Done Yet, but on the list

the only option for PdefAllGui will be [\makeEdit]. adding a "front" PdefGui that also shows the front Pdef's envir.

Examples::

code::
(
Pdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
Pdef(\b, { |e| 100.do { |i| Pdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
t = PdefAllGui(8);
)

	// if you have too many Pdefs, an ezscroller lets you select
"abcdefghijk".do { |ch| Pdef(ch.asSymbol) };

	// you can also filter which ones you see:
Pdef(\a_otti);
Pdef(\a_annerl);
Pdef(\a_bebe);

	// or better from gui
t.prefix_("a_");
t.filtering_(true);

	// if prefix is "", it will filter anything with "_" in it.
t.prefix_("");
t.filtering_(false);
::


class:: PdefEditor
summary:: will be replaced - please use PdefGui now!
categories:: JITLib>GUI, Live Coding
related:: Classes/PdefGui

description::

warning::
has been rewritten and renamed link::Classes/PdefGui::, which has largely the same functionality, but is more consistent and more flexible. There are some changes to the strong::*new:: method:

definitionList::
## instead of || *new(px, nVars, height, width, parent, makeWatcher)
## PdefGui uses || *new (object, numItems, parent, bounds, extras)
::

strong::px:: is now strong::object::, strong::nVars:: is now strong::numItems::, strong::width & height:: can be put as strong::bounds: height @ width ::, strong::parent:: is still strong::parent::, strong::makeWatcher:: is now strong::makeSkip:: .

Please see link::Classes/PdefGui:: for more details.
::


class:: PdefGui
summary:: a line of editing controls for a Pdef, and optionally its envir
categories:: JITLib>GUI, Live Coding
related:: Classes/PdefAllGui, Classes/TdefGui, Classes/TdefAllGui, Classes/EnvirGui

description::

A gui showing the link::Classes/Pdef::'s name, playing state, source state, and envir state. Optionally, its envir can also be edited.

subsection::First example

code::
g = PdefGui();			// make a PdefGui
g.object = Pdef(\a);		// show when a Pdef is put in
Pdef(\a, Pbind(\note, 12)); 	// show whether it has a source
Pdef(\a).play; 			// show whether playing, stopped, or ended, and pausable
Pdef(\a).set(\dur, 0.25); 	// show whether the Pdef has an envir
g.close;

g = PdefGui(Pdef(\a), 3);	// with an envirgui for 3 items
Pdef(\a).set(\lofreq, [1, 10], \str, "someString", \oops, \oneSymbolTooMany);
Pdef(\a).clear;
Pdef(\a).envir.clear;
g.close;

(				// put it in an existing window - margin is 0@0
w = Window("my win", Rect(200, 200, 300, 200)).front;
w.addFlowLayout;
PdefGui(Pdef(\a), 0, w);
PdefGui(Pdef(\a), 3, w);
)
::

subsection::Details on the GUI elements

definitionList::
## name button
|| when selected, typing the delete key will delete its Pdef.
## play/stop button
|| indicates whether the Pdef is playing:
table::
## " >" || if stopped,
## " _" || if playing and active,
## " |" || if it is playing, but the stream has ended.
::
## pause/resume button
|| only visible if one can pause or resume the Pdef, i.e. while it is playing.
table::
## "paus" || shown when you can pause it,
## "rsum" || shown when you can resume it.
::
## src button
|| opens a document to edit the source (function) of the Pdef.
table::
## green || a source exists,
## white || the source is nil.
::
## env button
|| opens a document to edit the environment of the Pdef, which is where one can keep all variables the Pdef uses for easy access.
table::
## green || the Pdef has an envir,
## white || the envir is nil.
::
::

ClassMethods::

subsection::Creation Methods

method::new
Create a new link::Classes/JITGui:: that will be watching an object and display its state.

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a link::Classes/Point:: or link::Classes/Rect::, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
A flag whether to make a skipjack.

argument::options
a list of additional information, e.g. flags about optional buttons. (this is used is some subclasses)

InstanceMethods::

method::object
a link::Classes/Pdef::, or nil

method::numItems
the number of items in the envirGui

method::parent
the parent view

method::bounds
the bounds of the link::#-zone::

method::zone
the link::Classes/CompositeView:: within which the PdefGui is shown

method::nameBut, playBut, pauseBut, srcBut, envBut
the buttons

method::envirGui
the gui for the Pdef's envir - nil if numItems is 0.

method::object
put an object in the gui.

method::moveTo
(if the jitGui is in its own window)

move it to some specific location.

method::clear
(if the jitGui is in its own window)

set the PdefGui's object to nil

method::close
(if the jitGui is in its own window)

and close its window.

subsection::Internal methods

method::srcString
a compileString that recreates the Pdef.

code::
// assume g from above is still there
g.srcString;
::

method::editString
a compileString that recreates the Pdef's envir at edKey.

method::editStrings
a compileString that recreates the Pdef's envir at edKeys.

argument::edKeys
Default value is nil.

code::
// assume g from above is still there
g.editString;
Pdef(\a).set(\foo, \bar);
g.editString(\foo);

g.editStrings;
::

method::getUsedKeys
the keys in use in the envir

code::
g.getUsedKeys;
::

method::openDoc
open a document with some strings at some location

code::
g.openDoc(g.editStrings);
::

method::makeEnvirGui
make an envirGui within zone - called internally.

Examples::

code::
Pdef(\a, Pbind(\freq, Prand((1..16) * 55, inf)));
Pdef(\a).play;
t = PdefGui(Pdef(\a), 4);
Pdef(\a).set(\dur, 0.125, \amp, 0.05);

Pdef(\a).stop;
Pdef(\a).play;
Pdef(\a).pause;
Pdef(\a).resume;

t.object_(nil);
t.object_(Pdef(\a));

(
w = Window("put it in a selfmade window").front;
w.addFlowLayout;
w.view.decorator.shift(50, 50);
PdefGui(Pdef(\a), 12, w);
)

Pdef(\b, Pbind(\note, Pxrand((0..7), inf), \dur, 0.125));
Pdef(\b).play;
PdefGui(Pdef(\b));

	// see all Pdefs:
PdefAllGui(16);
::


class:: Pdefn
summary:: non event stream reference definition
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdef

description::
Pdefn provides an interface to its superclass link::Classes/PatternProxy::, keeping a reference to a stream that can be replaced while playing. One pattern may be used in many streams in different places. A change in the pattern definition propagates through all streams.

Pdef and Pdefn use separate global collections.

code::
Pdefn(key)	//returns the instance
Pdefn(key, pat)	//defines the pattern and returns the instance, like Pdef, Tdef and Ndef.
::

It is very similar to link::Classes/PatternProxy::.

Pdefn can be used to store value patterns globally (for strong::event patterns::, see link::Classes/Pdef::). Overview: link::Overviews/JITLib::

subsection::First Example

code::
s.boot;

Pdefn(\x, Pbrown(0, 6, 0.1, inf));
Pbind(\note, Pdefn(\x), \dur, 0.3).play;
Pbind(\note, Pdefn(\x), \dur, 0.1, \ctranspose, 15).play;
// now change the definition
Pdefn(\x, Pseq([0, 3, 5, 7, 9, 11], inf));
Pdefn(\x, Pseq([0, 3, 3, 7], inf) + Pseq([0, [0, 3], [0, 5, 7]], inf));
::

ClassMethods::

private::initClass

method::all
A global link::Classes/IdentityDictionary:: with all proxies.



subsection::Creation

method::new
Store the pattern in a global dictionary under key, replacing its pattern with the new one. If the pattern is a strong::function::, Pdefn creates a link::Classes/Prout:: with this function, passing in the envir, if given(see below).

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default silent event is created)

argument::key
An identifier for the proxy. Usually, it is a link::Classes/Symbol::. The key transparently accesses the global link::Classes/IdentityDictionary::.

argument::item
An object for (re)defining the source of the proxy. If code::nil::, the proxy is returned unmodified.

code::

// pattern as an argument
Pdefn(\x, Pseq([1, 2, 5, 6, 7], inf));
Pdefn(\x); // omitting the second argument, we can access the proxy
Pdefn(\x).asStream.nextN(20); // ... play one event stream
Pdefn(\x).source.postcs; // ... and inspect the event pattern itself.


// function as an argument, create a new pattern each time it is called
Pdefn(\x, { Pseq({ 10.rand } ! 8) });
Pn(Pdefn(\x)).asStream.nextN(16);

// the function is called in the incoming event as current environment, so parameters can be passed:
Pdef(\stut, { Pdup(~dup ? 1, ~pattern) }); // we use here a Pdef (not a Pdefn!)
Pdefn(\y, Pdef(\stut) <> (pattern: Pdefn(\x), dup: Pseq([2, 2, 4, 3], inf))).asStream.nextN(16);

::

method::default
Default source, if none is given. The default is a Pattern that returns 1.0 (This is 1 and not 0 to avoid deadlocks when used as a duration pattern. In a sense, 1 is just as generic as 0).

method::removeAll
Remove all proxies from the global dictionary ( link::#*all::)

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all Pdefns.

InstanceMethods::

private::prAdd

Examples::

subsection::Pdefn in expressions

code::
Pdefn(\c, Pdefn(\a) + Pdefn(\b));

t = Pdefn(\c).asStream; // create a stream from Pdefn(\c)

t.value; // default value for a Pdefn is 1, so that it is a good time value default.

Pdefn(\a, 100); // (re)define Pdefn(\a) as 100

t.value;

Pdefn(\b, Pseq([1, 2, 3], inf)); // (re)define Pdefn(\b) as Pseq([1, 2, 3], inf)

3.do { t.value.postln };

Pdefn(\c, Pdefn(\a) * Pdefn(\b) - Pdefn(\a)); // (re)define Pdefn(\c)

8.do { t.value.postln };

Pdefn(\a, Prand([1, 4, 2], inf)); // (re)define Pdefn(\a)
::

subsection::Embedding Pdefn in other patterns

code::
Pdefn(\x, Pseq([1, 2, 3], inf));

x = Pseq([0, 0, Pdefn(\x)], inf).asStream;

t = Task({ loop({ x.next.postln; 0.3.wait }) }).play;


Pdefn(\x, Pseq([55, 66, 77],inf));
Pdefn(\x, Pseq([55, 66, 77],1));

t.stop;



// Pdefn can be accessed in multiple streams

(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction: Done.freeSelf);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
s.boot;
)

(
Pdefn(\deg, Pseq([0, 3, 2],inf));

Pset(\instrument, \Pdefhelp,
	Ppar([
		Pbind(\degree, Pdefn(\deg), \pan, -0.8),
		Pbind(\degree, Pdefn(\deg), \dur, 1/3, \pan, 0.8)
])
).play;
)

Pdefn(\deg, Prand([0, 3, [1s, 4]],inf));

Pdefn(\deg, Pn(Pshuf([0, 3, 2, 7, 6],2),inf));

(
Pdefn(\deg, Plazy { var pat;
	pat = [Pshuf([0, 3, 2, 7, 6],2), Pseries(0, 1, 11), Pseries(11, -1, 11)].choose;
	Pn(pat, inf)
});
)
::

subsection::Timing

When does the definition change?

If quant is set, the update is done at the next beat or whatever is specified:

code::
Pdefn(\deg).quant = 4;
Pdefn(\deg, Pn(Pseries(0, 1, 8),inf));

Pdefn(\deg).quant = nil; // activate immediately again

(
Pdefn(\deg, {
	loop {
	5.do { |i|
		#[1, 3, 4].choose.yield;
		#[5, 0, 12].choose.yield;
		#[14, 3, 4].choose.do { |j| (i % j).postln.yield };
	}
	}
})
)
::

subsection::update condition

In order to be able to switch to a new pattern under a certain condition, the instance variable strong::condition:: can be set to a function that returns a boolean. Value and a count index are passed to the function. The condition is always valid for the strong::next pattern:: inserted. For stuck conditions, the strong::reset:: message can be used.

As counting up (such as emphasis::"every nth event, a swap can happen"::) is a common task, there is a method for this, called strong::count(n)::.

code::
z = Pbind(\degree, Pdefn(\x, \), \dur, 0.25).play;
Pdefn(\x, Pseq((0..5), inf)).condition_({ |val, i| i.postln % 6 == 0 });
Pdefn(\x, Pseq((7..0), inf)).condition_({ |val, i| i.postln % 8 == 0 });


// the above is equvalent to:
Pdefn(\x, Pseq((7..0), inf)).count(8);
::

subsection::Reset

code::
// reset to change immediately:
Pdefn(\x).reset;

Pdefn(\x).stop;
::

subsection::Functions as arguments to Pdefn

code::
Pdefn(\deg, { loop { yield(0.1.rand.round(0.01) + [2, 3, 9].choose) } });

// equivalent to:

Pdefn(\deg, Prout { loop { yield(0.1.rand.round(0.01) + [2, 3, 9].choose) } });

// this is not exactly true, see below..
::

subsection::The (inner) environment

code::
// set() creates a local environment that overrides the outer currentEnvironment

Pdefn(\z).set(\a, 1, \b, 5);
(
Pdefn(\z, { |e|
	loop { yield((e.a + e.b) + 0.1.rand.round(0.01)) }
})
); // [1]

t = Pdefn(\z).asStream;

t.nextN(3);

(
Pdefn(\z, { |e|
	//(e.a + e.b) + 0.1.rand.round(0.01) 1
	Pseq([1, 2, e.a], 1)
})
);

Pdefn(\z, Pseq([1, 2, 3], 1));

e = Pdefn(\z).envir


Pdefn(\z).set(\a, 3);

t.next;

Pdefn(\z).set(\a, Pseq([1, 2, 3], inf));

t.reset;
t.nextN(3);

Pdefn(\z).envir; // post the envir



// if you want to keep using the currentEnvironment at the same time,
// assign the currentEnvironment to the envir's parent (or proto) field
// (this shouldn't be a proxy space of course.)

Pdefn(\z).envir.parent = currentEnvironment;
~a = 9;
~b = 10;

t.nextN(3);
::


TITLE:: PdefnAllGui
summary:: show all current Pdefns as code
categories:: JITLib>GUI, Live Coding
related:: Classes/Pdefn, Classes/PdefnGui

DESCRIPTION::
PdefnAllGui displays all current Pdefns as code.
See also TdefAllGui for general info, search functions, etc.

CLASSMETHODS::

METHOD:: observedClass
Pdefn

METHOD:: tpGuiClass
PdefnGui

EXAMPLES::

code::
PdefnAllGui(();
Pdefn(\a, 1);
Pdefn(\b, [1, 2, 3]);
Pdefn(\x, Pwhite());
::


TITLE:: PdefnGui
summary:: a simple gui for Pdefns
categories:: JITLib>GUI, Live Coding
related:: Classes/Pdefn, Classes/PdefnAllGui, Classes/TdefAllGui

DESCRIPTION::
PdefnGui displays a PdefnGui, and allows editing and evaluating its code.


CLASSMETHODS::

METHOD:: observedClass
Pdefn

INSTANCEMETHODS::

strong::JITGui methods: ::
METHOD:: accepts
test whether object can be displayed

METHOD:: getState, checkUpdate

EXAMPLES::

code::
g = PdefnGui();
Pdefn(\abc, [1, 2, 3]);
g.object_(Pdefn(\abc));
Pdefn(\abc, 345);

// Note: When editing code in the csView and evaluating,
// there is a short delay before displaying. this is intended.

::


class:: PdegreeToKey
summary:: index into a scale
related:: Classes/Scale
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a series of notes derived from an index into a scale.

ClassMethods::

method::new

argument::pattern
integer index into the scale.

argument::scale
an array or pattern. If a pattern, it streams the scales accordingly.

argument::stepsPerOctave
the number of steps per octave in the scale.

Examples::

code::
(
Pbind(\note, PdegreeToKey(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 2),
			#[0, 2, 3, 6, 7, 9],
			12
		),
	\dur, 0.25
).play;
)


(
var scales;
scales = #[[0, 2, 3, 6, 7, 9], [0, 1, 5, 6, 7, 9, 11], [0, 2, 3]];
Pbind(\note, PdegreeToKey(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 4),
			Pdup(3, Prand(scales, inf)),
			12
		),
	\dur, 0.25
).play;
)
::


class:: Pdfsm
summary:: deterministic finite state machine
related:: Classes/Pfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Pdfsm is a deterministic finite state machine with signal input (written by by ccos).

ClassMethods::

method::new

argument::list
a list consisting of the stream which gives input signals to determine state transitions, and then dictionary entries, one for each state, mapping the destination state and yield streams to those input signals.

argument::startState
an integer index for the state to start with.

argument::repeats
an integer giving the number of times the pattern should cycle. A cycle ends when the strong::signal stream:: ends or nil is given for the destination state to a signal value, see below.

Examples::

definitionList::
## list structure:
|| [
definitionList::
## signal stream || can be a stream of anything which can serve as a key for an associative collection. integers, symbols, etc... asStream is called on this for each repeat.
## states || states should be an instance of link::Classes/IdentityDictionary::, link::Classes/Event:: or some other associative collection.
::
## ] ||
## list syntax:
|| [
definitionList::
## signal stream, ||
## ( // state 0, ||
definitionList::
## signal value : [destination state, return stream or pattern], ||
## signal value : [destination state, return stream or pattern] ||
::
## ), ||
## ... // state 1 ... N ||
::
## ] ||
::

Any number of states can be given, and are indexed by the order in which they are given.

If the fsm is in state x and it receives a strong::signal value:: y it looks up y in the state dictionary supplied for x, if there is no y entry, it looks for a \default entry and uses that.

The next state is then set to strong::destination state::, and the stream yielded is given by strong::return stream or pattern::. That is unless the strong::destination state:: is given as nil, or if a strong::destination state:: is given for which you have not supplied a dictionary - in both cases the current cycle ends and any remaining repeats are executed. If there is no strong::signal value:: given for a particular signal, and no \default is supplied then one will get a runtime error.

code::
(
	p = Pdfsm(
		[
			Pseq( [\foo,\bar], 2 ), // foobar signals
			( // state 0
				\foo : [ 1, Pseq([ 0, 1 ], 2 ) ]
			),
			( // state 1
				\bar : [ 0, 3 ]
			)
		],
		0,
		2
	).asStream;

	11.do({ p.next.postln });
)

(
SynthDef(\help_Pdfsm1,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar([freq, freq + 0.1.rand2], 0, env))
	}).add;
)

(
var p;
p = Pdfsm(
	[
		Prand([0,1,2],inf),	// signalStream

		IdentityDictionary[	// state 0
			0 -> [ 2, Pseq([67,68,69], 2) ],
			1 -> [ 0, 66 ],
			2 -> [ 1, 65 ]
		],
		IdentityDictionary[	// state 1
			1 -> [ 1, Pseq([69,68,67],2) ],
			\default -> [ 0, 70 ]
		],
		IdentityDictionary[
			0 -> [ 0, 71 ],
			1 -> [ 0, 72 ],
			2 -> [ nil ]	// signalStream is infinitely long,
					// so the fsm only ends because of this nil
					// 2 -> [nil, nil] is also fine
		]
	],
	1, 				// startState
	1 				// repeats
).asStream;

Routine({
	var freq;
	while({ (freq = p.next.postln).notNil },{
		Synth(\help_Pdfsm1, [ \freq, freq.midicps ]);
		0.1.wait;
	})
}).play;
)

(
SynthDef(\help_Pdfsm2,
	{ |out, freq, gate=1|
		var n=8, env, osc;
		env = Linen.kr( gate, 0.01, 1, 0.03, 2 );
		osc = {
			Mix.fill( n, { |i|
				FSinOsc.ar(freq + Rand(-2.0,2.0), Rand(0, 0.05pi)) ring4:
				FSinOsc.ar(freq * (i+1));
			})
		}.dup * FSinOsc.kr(Rand(1.5,4.5),{Rand(-0.1pi,0.1pi)}.dup,0.6,env*0.4);
		Out.ar(out, env * osc / (n*4) )
}).add;
)

(
var n=3, base, penult;

base = [3,4,4,0];

for( 1, n, { arg i;
	penult = Pbind( \degree, Pshuf(base - (i*5), 2), \dur, Pseq([0.2],2) );
	Pset(
		\instrument, \help_Pdfsm2,
		Pdfsm(
			[
				Pseq([	// signalStream
					Pn(1,22 + i),
					Pn(0,4),
					Pn(1,8),
					Pseq([
						Pn(0,3),
						Prand([0,1],8),
						Pn(1,8)
					], 3 ),
					Pn(2,2)
				], 1 ),
				(	// state 0
					0 : [ 0, Pbind( \degree, Pseq(base - i, 1), \dur, Pxrand([0.2,0.3],4) ) ],
					1 : [ 1, Pbind(
							\degree, Pseq(base.reverse - (i*2), 2),
							\dur, Pseq([0.2,0.21],1)
							)
						],
					2 :	[ 2, penult ]
				),
				(	// state 1
					0 : [ 0, Pbind( \degree, Pshuf(base * i.neg, 8), \dur, Pseq([0.08],8) ) ],
					1 : [ 0, Pbind( \degree, Pseq(base - (i*3),3+i), \dur, Pseq([0.11],3+i) ) ],
					2 : [ 2, penult ]
				),
				(	// state 2
					\default : [ 2, Pbind(
									\degree, Prand(base - (i*7), 5),
									\dur, Prand([0.6,0.8],5)
								)
							]
				)
			],
			i % 2 		// startState
		)
	).play;
})
)
::


class:: Pdict
summary:: pattern that embeds patterns from a dictionary
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pbind

description::
A general purpose lookup stream.

Examples::

code::
SynthDescLib.read;

(
e = (
	a: Pbind(\dur, 0.1, \degree, Pseq([0, 5, 4, 3, 2])),
	b: Pbind(\dur, 0.06, \degree, Pseq([7, 8, 7, 8])),
	c: Pbind(\dur, 0.3, \degree, Pseq([0, 1, 2], 2))
);

x = Pdict(e, Pseq([
			\a, \b,
			Prand([\a, \c])
		], 4)
	);
x.play;
)
::


class:: Pdiff
summary:: returns the difference between the current and previous values of an enclosed pattern
related:: Classes/Pseries
categories:: Streams-Patterns-Events>Patterns

description::

A pattern that returns the difference between the current and previous values of an enclosed pattern.

Examples::

code::
p = Pbind(
	\degree, Pxrand([0,2,3,4,6,7],12),
	\dur, Pdiff(Pkey(\degree)).abs/4,
).play;
::


class:: Pdrop
summary:: skips (drops) the first n events from a pattern
related:: Classes/Pclutch
categories:: Streams-Patterns-Events>Patterns

description::

Skips an initial (count) number of events from a pattern.

ClassMethods::

method::new
drops strong::count:: elements of the strong::pattern:: from the stream.

Examples::

code::

(
p = Pdrop(2, Pseq([1,2,3,4],6));
q = p.asStream.nextN(20).postln;
)

::


class:: Pdup
summary:: repeat input stream values
related:: Classes/Pn, Classes/Pattern#-dup
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

repeat each element n times.

code::
(
var a, b;
a = Pdup(2, Pwhite(-1.0, 1.0));
x = a.asStream;
8.do { x.next.postln };
)
::

This is also a response to link::Classes/Pattern#-dup::


ClassMethods::

method::new

argument::n
The number of repeats for each new element. n may be a pattern, so the number of times can vary each iteration.

argument::pattern
the pattern to repeat.

Examples::


code::
// the first argument can be a pattern, too:
(
var a, b;
a = Pdup(Prand([1, 2, 5], inf), Pwhite(-1.0, 1.0)); // repeat either once, twice, or five times
x = a.asStream;
20.do { x.next.postln };
)

// using event patterns:
(
SynthDef(\help_sinegrain,
	{ | out=0, freq=440, sustain=0.05 |
		var env;
		        env = Env.perc(0.01, sustain, 0.2).kr(doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0.5pi, env))
}).add;
)

(
a = Pbind(
	\instrument, \help_sinegrain,
	\note, Pxrand([0, 5, 7, 9], inf),
	\dur, 0.05,
	\sustain, 0.1
);
Pdup(Pseq([1, 2, 3, 4], inf), a).trace.play;
)


// Pdup used as a sequence of pitches

(
c = Pdup(3, Pxrand([1, 2, 3], inf) * 4 + 65);
x = c.asStream;
Routine {
	loop {
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.12.wait;
	}
}.play;
)


// Voss algorithm for pink noise
// note that pattern.dupEach(n) is a synonym for Pdup(n, pattern)
a = Pwhite();
c = (2 ** (0..10)).sum { |n| a.dupEach(n) };
c.asStream.nextN(1000).plot


// Voss-McCartney algorithm: balance calculation for realtime use
a = Pwhite();
c = (2 ** (0..10)).sum { |n| a.dupEach(n.div(2).fin(1)) ++ a.dupEach(n) };
c.asStream.nextN(1000).plot

::


class:: PdurStutter
summary:: partition a value into n equal subdivisions
related:: Classes/Psubdivide, Classes/Pdup
categories:: Streams-Patterns-Events>Patterns>Repetition

note::It is recommended to use link::Classes/Psubdivide:: instead. This class is retained for backwards compatibility.::
warning::PdurStutter will return link::Classes/Psubdivide::::

description::

A filter pattern designed for a stream of float durations.

Subdivides each duration by each stutter and yields that value stutter times. A stutter of 0 will skip the duration value, a stutter of 1 yields the duration value unaffected.

Examples::

code::
(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,0,1,3,4,0],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
100.do({ x.next.postln; });
)


(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;

Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)


(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)
::

Frequencies like being divided too.

code::
(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq((80 + [ 0, 2, 3, 5, 7, 9, 10 ]).midicps ,inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, x.next.postln]);
		0.25.wait
	})
}).play(TempoClock.default);
)
::


class:: Peak
summary:: Track peak signal amplitude.
related:: Classes/PeakFollower
categories::  UGens>Analysis>Amplitude


Description::

Outputs the peak amplitude of the signal received at the input. When
a trigger occurs at the  code::reset::  input, the maximum
output value is reset to the current value.


Internally, the absolute value of the signal is used, to prevent
underreporting the peak value if there is a negative DC offset. To obtain
the minimum and maximum values of the signal as is, use the
link::Classes/RunningMin::  and  link::Classes/RunningMax::  UGens.


classmethods::

method::ar, kr

argument::in

The input signal.

argument::trig

Trigger. Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::

(
{
	SinOsc.ar(
			Peak.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			Peak.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)

::



class:: PeakFollower
summary:: Track peak signal amplitude.
related:: Classes/Peak
categories::  UGens>Analysis>Amplitude


Description::

Outputs the peak amplitude of the signal received at the input. If level
is below maximum, the level decreases by the factor given in
code::decay:: .


Internally, the absolute value of the signal is used, to prevent
underreporting the peak value if there is a negative DC offset. To obtain
the minimum and maximum values of the signal as is, use the
link::Classes/RunningMin::  and  link::Classes/RunningMax::  UGens.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::decay

Decay factor.


Examples::

code::

s.boot;

// no decay
(
{
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 1.0) * 1500 + 200,
			0, 0.2
	)

}.play;
)

// a little decay
(
{
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 0.999) * 1500 + 200,
			0, 0.2
	)

}.play;
)

// mouse x controls decay, center of the
(
{
	var decay;
	decay = MouseX.kr(0.99, 1.00001).min(1.0);
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20), decay) * 1500 + 200,
			0, 0.2
	);

}.play;
)




// follow a sine lfo, decay controlled by mouse x
(
{
	var decay;
	decay = MouseX.kr(0, 1.1).min(1.0);
	SinOsc.ar(
			PeakFollower.kr(SinOsc.kr(0.2), decay) * 200 + 500,
			0, 0.2
	)

}.play;
)

::



class:: Pen
summary:: Draw custom graphics
categories:: GUI>Accessories
related:: Classes/QPenPrinter

description::
A class which allows you to draw custom graphics on a UserView or Window.

The following methods must be called within a link::Classes/Window#-drawFunc:: or a link::Classes/UserView#-drawFunc:: function, and will only be visible once the window or the view is refreshed. Each call to link::Classes/Window#-refresh:: or link::Classes/UserView#-refresh:: will 'overwrite' all previous drawing by executing the currently defined function, unless link::Classes/UserView#-clearOnRefresh:: is set to code::false::

classmethods::
private:: prAddAnnularWedge, prAddArc, prDrawImage, prSetFont, prTileImage

subsection:: Construct path
The following methods define paths. You will need to call link::#*stroke:: or link::#*fill:: to actually draw them.

method:: moveTo
Move the Pen to point.
argument:: point
An instance of link::Classes/Point::

method:: lineTo
Draw a line (define a path) from the current position to point.
argument:: point
An instance of link::Classes/Point::

method:: line
Draw a line (define a path) from p1 to p2. Current position will be p2.
argument:: p1
An instance of link::Classes/Point::
argument:: p2
An instance of link::Classes/Point::

method:: curveTo
Draws a cubic bezier curve from the current position to point.
strong::cpoint1:: and strong::cpoint2:: are control points determining the curve's curvature.
argument:: endPoint
An instance of link::Classes/Point::
argument:: cPoint1
An instance of link::Classes/Point::
argument:: cPoint2
An instance of link::Classes/Point::

method:: quadCurveTo
Draws a quad bezier curve from the current position to point.
strong::cpoint:: is a control point determining the curve's curvature.
argument:: endPoint
An instance of link::Classes/Point::
argument:: cPoint
An instance of link::Classes/Point::

method:: arcTo
Draws an arc of a circle using a radius and tangent points.
argument:: point1
The end point of the first tangent line. Its start point is the current position. An instance of link::Classes/Point::
argument:: point2
The end point of the second tangent line. Its start point is point1. An instance of link::Classes/Point::
argument:: radius
The radius of the arc.
discussion::
example:
code::
(
var w = Window("arcTo", Rect(100, 200, 300, 300)).front;
var r= 15;
w.drawFunc = { |v|
    Pen.fillColor = Color.blue;
    Pen.strokeColor = Color.red;
    Pen.moveTo(150@150);
    Pen.arcTo(200@150, 200@225, r);
    Pen.arcTo(200@225, 100@225, r);
    Pen.arcTo(100@225, 100@150, r);
    Pen.arcTo(100@150, 150@150, r);
    Pen.lineTo(150@150);
    Pen.fillStroke;
};
)
::

method:: addArc
Draw an arc around the link::Classes/Point:: strong::center::, at strong::radius:: number of pixels. strong::startAngle:: and strong::arcAngle:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    10.do{
        // set the Color
        Pen.color = Color.red(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addArc((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, pi);
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addWedge
Draw a wedge around the link::Classes/Point:: strong::center::, at strong::radius:: number of pixels. strong::startAngle:: and strong::sweepLength:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    10.do{
        // set the Color
        Pen.color = Color.blue(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addAnnularWedge
Draw an annular wedge around the link::Classes/Point:: strong::center::, from strong::innerRadius:: to strong::outerRadius:: in pixels. strong::startAngle:: and strong::sweepLength:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    1000.do{
        // set the Color
        Pen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addAnnularWedge(
            (100.rand)@(100.rand),
            rrand(10, 50),
            rrand(51, 100),
            2pi.rand,
            2pi.rand
        );
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addRect
Adds a link::Classes/Rect:: to the drawing.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    80.do{
        // set the Color
        Pen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addRect(
            Rect(20, 20, (w.bounds.width-40).rand, (w.bounds.height-40).rand)
        );
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addOval
Adds an Oval shape that fits inside the link::Classes/Rect:: to the current path.


subsection:: Draw the path

method:: stroke
Outline the previous defined path.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.strokeColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.stroke
};
w.refresh;
)
::

method:: fill
Fill the previous defined path.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.fill
};
w.refresh;
)
::

method:: draw
Draw the previous defined path using any of the following options:
argument:: style
table::
## 0 || fill
## 1 || fill using even-odd rule
## 2 || stroke
## 3 || fill and stroke the current path
## 4 || fill and stroke using even-odd rule
::
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.draw(4); // fill and then stroke
};
w.refresh;
)
::

method:: fillStroke
Fill and stroke the current path. Shortcut to the draw(3) method.


subsection:: Construct and draw
These methods do not require separate calls to link::#*stroke:: or link::#*fill::.

method:: strokeRect
Strokes a link::Classes/Rect:: into the window.

method:: fillRect
Draws a filled link::Classes/Rect:: into the window.

method:: strokeOval
Strokes an oval into the window.

method:: fillOval
Draws a filled oval into the window.

subsection:: Gradients

method:: fillAxialGradient
Fills an Axial gradient.
discussion::
example:
code::
(
w = Window.new.front;
w.drawFunc = {
    // fill the gradient
    Pen.addRect(w.view.bounds.insetBy(30));
    Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);
};
w.refresh;
)
::

method:: fillRadialGradient
Fills a Radial gradient.
discussion::
example:
code::
(
w = Window.new.front;
w.drawFunc = {
    // fill the gradient
    Pen.addOval(w.view.bounds.insetBy(30));
    Pen.fillRadialGradient(w.view.bounds.center,
        w.view.bounds.center, 0, w.bounds.width, Color.rand, Color.rand);
};
w.refresh;
)
::

subsection:: Graphics State Methods

The following commands transform the graphics state, i.e. they effect all subsequent drawing commands. These transformations are cumulative, i.e. each command applies to the previous graphics state, not the original one.

method:: translate
Translate the coordinate system to have its origin moved by x,y
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.strokeColor = Color.blue;
    Pen.translate(200,100); // 0@0 is now 200@100
    Pen.moveTo(0@0);
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.stroke
};
w.refresh;
)
::
Cumulative translations:
code::
(
w = Window.new.front;
w.view.background_(Color.clear);
w.drawFunc = {
    Pen.strokeColor = Color.black;
    35.do { // draw 35 lines
        Pen.moveTo(0@0);
        Pen.lineTo(50@350);
        Pen.translate(10, 0); // shift 10 to the right every time
        Pen.stroke
    }
};
w.refresh;
)
::

method:: scale
Scales subsequent drawing. x and y are scaling factors (i.e. 1 is normal, 2 is double size, etc.).
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.strokeColor = Color.green;
    Pen.translate(200,100);
    Pen.scale(0.5, 2);
    Pen.moveTo(0@0); // you have to set a starting point...
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.stroke
};
w.refresh;
)
::

method:: skew
Skews subsequent drawing. x and y are skewing factors (i.e. 1 is normal).
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.fillColor = Color.green(0.5, 0.8);
    Pen.translate(200,100);
    Pen.skew(0.5, 0.2);
    Pen.moveTo(0@0); // you have to set a starting point...
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.fill
};
w.refresh;
)
::

method:: rotate
Rotates subsequent drawing around the link::Classes/Point:: code::x@y:: by the amount strong::angle:: in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
c = 0;
w.drawFunc = {
    Pen.translate(220, 200);
    10.do({
        Pen.translate(0,10);
        Pen.fillColor = Color.hsv(c.fold(0, 1), 1, 1, 0.5);
        Pen.moveTo(0@0); // you have to set a starting point...
        Pen.lineTo(50@100);
        Pen.lineTo(100@100);
        Pen.lineTo(0@150);
        Pen.lineTo(-100@100);
        Pen.lineTo(-50@100);
        Pen.lineTo(0@0);
        Pen.fill;
        Pen.rotate(0.2pi);
        c = c + 0.1;
    });
};
w.refresh;
)
::

method:: matrix
Gets or sets the coordinate system transformation matrix.

See link::#Matrix example:: for an example.

argument:: matrixArray
An array of the form code::[ zoomX, shearingY, shearingX, zoomY, translateX, translateY ]::

method:: width
Sets the width of the Pen for the whole stroke

method:: use
Draw function, and then revert to the previous graphics state. This allows you to make complex transformations of the graphics state without having to explicitly revert to get back to 'normal'.
discussion::
example:
code::
(
// modified by an example of Stefan Wittwer
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    //paint origin
    Pen.fillColor = Color.gray(0, 0.5);
    Pen.addArc(0@0, 20, 0, 2pi);
    Pen.fill;
    Pen.width = 10;

    Pen.use { // draw something complex...
        Pen.width = 0.5;
        Pen.translate(100,100);
        Pen.fillColor = Color.blue;
        Pen.addArc(0@0, 10, 0, 2pi);
        Pen.fill;
        20.do{
            Pen.moveTo(0@0);
            Pen.lineTo(100@0);
            Pen.strokeColor = Color.red(0.8, rrand(0.7, 1));
            Pen.stroke;
            Pen.skew(0, 0.1);
        };
    };

    // now go on with all params as before
    // translation, skewing, width, and color modifications do not apply
    Pen.line(10@120, 300@120);
    Pen.stroke;
};
w.refresh
)
::

method:: path
Make a path, consisting of the drawing made in function.
note::
Unfortunately not working for now...
(there's no Pen.endPath which currently is used in this method)
::

method:: beginPath
Discard any previous path.

method:: beginTransparencyLayer
Begins a new transparency layer. Transparency layers are useful when you want to apply an effect to a group of objects or create a composite graphic. See link::#Transparency layer example::.

method:: endTransparencyLayer
Ends the current transparency layer.

method:: clip
Use the previously defined path as a clipping path.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // outline the clipping path
    Pen.moveTo(110@110);
    Pen.lineTo(290@110);
    Pen.lineTo(290@240);
    Pen.lineTo(110@240);
    Pen.lineTo(110@110);
    // now clip
    Pen.clip;

    // everything else we draw is now clipped
    Pen.fillColor = Color.yellow;
    Pen.fillRect(Rect(0,0,400,400));
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);

    Pen.fill;
};
w.refresh;
)
::

method:: smoothing
Turns on/off anti-aliasing.
discussion::
example:
code::
(
var w = Window("smoothing", Rect(100, 200, 500, 300)).front;
w.view.background_(Color.white);
w.drawFunc = { |v|
    Pen.strokeColor = Color.grey(0.25);
    Pen.smoothing_(false); //no anti-aliasing
    50.do{|i|
        Pen.moveTo(50@50.rrand(250));
        Pen.lineTo(250@50.rrand(250));
    };
    Pen.stroke;
    Pen.smoothing_(true); //anti-aliasing (default)
    50.do{|i|
        Pen.moveTo(250@50.rrand(250));
        Pen.lineTo(450@50.rrand(250));
    };
    Pen.stroke;
};
)
::

method:: setShadow
Will fill the current path with a shadow.
You should use this option between Pen.push / Pen.pop (or Pen.use)

method:: joinStyle
Set the lines joining style according to the defined options:
table::
## 0 || miter
## 1 || round
## 2 || bevel
::

method:: capStyle
Set the lines joining style according to the defined options:
table::
## 0 || butt
## 1 || round
## 2 || square
::
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
StaticText(w, Rect(0,0,200,20))
    .string_(" Change Line Cap & Join Styles: ");
y = PopUpMenu(w, Rect(200,0,130,20))
    .items_(["Butt - Miter", "Round - Round", "Square - Bevel"])
    .action_({w.refresh});
w.drawFunc = {
    Pen.strokeColor = Color.red;
    Pen.width_(8.0);
    Pen.capStyle_(y.value);
    Pen.joinStyle_(y.value);
    Pen.moveTo(200@100);
    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);
    Pen.stroke;
};
w.refresh;
)
::

method:: alpha
Set the opacity level.

method:: blendMode
Set the blending mode to use.
See link::#Blending modes:: for more information.

method:: lineDash
Set the line dash pattern.
pattern should be a link::Classes/FloatArray:: of values that specify the lengths of the painted segments and not painted segments.

method:: drawImage
Draw a bitmap image using the Image class.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background = Color.red;
i = Image.open(SCDoc.helpSourceDir +/+ "images/Swamp.png");
w.drawFunc_({
	Pen.drawImage( Point(140, 140), i, operation: 'sourceOver', opacity:1);
});
)
::

examples::
Simple rotating and scaling:
code::
(
	w = Window("Pen Rotation and Scaling", Rect(128, 64, 360, 360));
	w.drawFunc = {
		Pen.use {
			// use the same rect for everything, just scale and rotate
			var r = Rect(0,0,200,80);
			Pen.fillColor = Color.black;
			// offset all subsequent co-ordinates
			Pen.translate(80,20);
			Pen.fillRect(r);
			Pen.fillColor = Color.red;
			// scale all subsequent co-ordinates
			Pen.scale(0.8, 0.8);
			Pen.translate(8,10);
			// rotate all subsequent co-ordinates
			Pen.rotate(0.1pi);
			Pen.fillRect(r);
			Pen.strokeColor = Color.blue;
			// lather, rinse, repeat
			Pen.scale(0.8, 0.8);
			Pen.rotate(0.1pi);
			Pen.width = 3;
			Pen.strokeRect(r);
			Pen.fillColor = Color.yellow(1,0.5);
			Pen.scale(0.8, 0.8);
			Pen.rotate(0.1pi);
			Pen.translate(20,-20);
			Pen.fillOval(r);
		}
	};

	w.front;
)
::
Redraw at random interval, different every time:
code::
(
var w, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 800));
w.view.background = Color.white;
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		Pen.width = 0.2;
		400.do {
			Pen.beginPath;
			Pen.moveTo(Point(10.rand * 80 + 40, 10.rand * 80 + 40));
			Pen.lineTo(Point(10.rand * 80 + 40, 10.rand * 80 + 40));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 1.0.rand.wait } }.fork(AppClock)

)
::
code::
(
var w, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 500));
w.view.background = Color.white;
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		Pen.width = 2;
		80.do {
			Pen.width = rrand(0,4) + 0.5;
			Pen.beginPath;
			Pen.moveTo(Point(800.rand, 500.rand));
			Pen.lineTo(Point(800.rand, 500.rand));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 1.0.rand.wait } }.fork(AppClock)

)
::

subsection:: Animation

Uses random seed to 'store' data
By reseting the seed each time the same random values and shapes are generated for each 'frame'
These can then be subjected to cumulative rotation, etc., by simply incrementing the phase var.
code::
(
// By James McCartney
var w, h = 700, v = 700, seed, run = true, phase = 0;
w = Window("wedge", Rect(40, 40, h, v), false);
w.view.background = Color.rand(0,0.3);
w.onClose = { run = false }; // stop the thread on close
w.front;
// store an initial seed value for the random generator
seed = Date.seed;
w.drawFunc = {
	Pen.width = 2;
	Pen.use {
		// reset this thread's seed for a moment
		thisThread.randSeed = Date.seed;
		// now a slight chance of a new seed or background color
		if (0.006.coin) { seed = Date.seed; };
		if (0.02.coin) { w.view.background = Color.rand(0,0.3); };
		// either revert to the stored seed or set the new one
		thisThread.randSeed = seed;
		// the random values below will be the same each time if the seed has not changed
		// only the phase value has advanced
		Pen.translate(h/2, v/2);
		// rotate the whole image
		// negative random values rotate one direction, positive the other
		Pen.rotate(phase * 1.0.rand2);
		// scale the rotated y axis in a sine pattern
		Pen.scale(1, 0.3 * sin(phase * 1.0.rand2 + 2pi.rand) + 0.5 );
		// create a random number of annular wedges
		rrand(6,24).do {
			Pen.color = Color.rand(0.0,1.0).alpha_(rrand(0.1,0.7));
			Pen.beginPath;
			Pen.addAnnularWedge(Point(0,0), a = rrand(60,300), a + 50.rand2, 2pi.rand
				+ (phase * 2.0.rand2), 2pi.rand);
			if (0.5.coin) {Pen.stroke}{Pen.fill};
		};
	};
};

// fork a thread to update 20 times a second, and advance the phase each time
{ while { run } { w.refresh; 0.05.wait; phase = phase + 0.01pi;} }.fork(AppClock)

)
::
code::
(
var w, phase = 0, seed = Date.seed, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 800));
w.view.background = Color.blue(0.4);
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		if (0.02.coin) { seed = Date.seed; };
		thisThread.randSeed = seed;
		Pen.strokeColor = Color.white;
		200.do {
			var a = 4.rand;
			var b = 24.rand;
			var r1 = 230 + (50 * a);
			var a1 = 2pi / 24 * b + phase;
			var r2 = 230 + (50 * (a + 1.rand2).fold(0,3));
			var a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;
			Pen.width = 0.2 + 1.0.linrand;
			Pen.beginPath;
			Pen.moveTo(Polar(r1, a1).asPoint + Point(400,400));
			Pen.lineTo(Polar(r2, a2).asPoint + Point(400,400));
			Pen.stroke;
		};
		thisThread.randSeed = Date.seed;
		40.do {
			var a = 4.rand;
			var b = 24.rand;
			var r1 = 230 + (50 * a);
			var a1 = 2pi / 24 * b + phase;
			var r2 = 230 + (50 * (a + 1.rand2).fold(0,3));
			var a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;
			Pen.width = 0.2 + 1.5.linrand;
			Pen.beginPath;
			Pen.moveTo(Polar(r1, a1).asPoint + Point(400,400));
			Pen.lineTo(Polar(r2, a2).asPoint + Point(400,400));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 0.1.wait; phase = phase + (2pi/(20*24)) } }.fork(AppClock)

)
::

code::
(
var w, h = 800, v = 600, seed = Date.seed, phase = 0, zoom = 0.7, zoomf = 1, run = true;
w = Window("affines", Rect(40, 40, h, v));
w.view.background = Color.blue(0.4);
w.onClose = { run = false };
w.front;
w.drawFunc = {
	thisThread.randSeed = Date.seed;
	if (0.0125.coin) { seed = Date.seed; phase = 0; zoom = 0.7; zoomf = exprand(1/1.01, 1.01); }
	{ phase = phase + (2pi/80); zoom = zoom * zoomf; };
	thisThread.randSeed = seed;
	Pen.use {
		var p1 = Point(20.rand2 + (h/2), 20.rand2 + (v/2));
		var p2 = Point(20.rand2 + (h/2), 20.rand2 + (v/2));
		var xscales = { exprand(2** -0.1, 2**0.1) } ! 2;
		var yscales = { exprand(2** -0.1, 2**0.1) } ! 2;
		var xlates = { 8.rand2 } ! 2;
		var ylates = { 8.rand2 } ! 2;
		var rots = { 2pi.rand + phase } ! 2;
		var xform;
		xscales = (xscales ++ (1/xscales)) * 1;
		yscales = (yscales ++ (1/yscales)) * 1;
		xlates = xlates ++ xlates.neg;
		ylates = ylates ++ xlates.neg;
		rots = rots ++ rots.neg;
		xform = {|i| [xlates[i], ylates[i], rots[i], xscales[i], yscales[i]] } ! 4;
		Pen.strokeColor = Color.grey(1,0.5);
		Pen.width = 8.linrand + 1;
		Pen.translate(400, 400);
		Pen.scale(zoom, zoom);
		Pen.translate(-400, -400);
		1200.do {
			var p, rot, xlate, ylate, xscale, yscale;
			Pen.width = 8.linrand + 1;
			Pen.beginPath;
			#rot, xlate, ylate, xscale, yscale = xform.choose;
			Pen.translate(xlate, ylate);
			Pen.rotate(rot, h/2, v/2);
			Pen.scale(xscale, yscale);
				Pen.moveTo(p1);
				Pen.lineTo(p2);
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 0.05.wait; } }.fork(AppClock)

)
::

subsection:: Matrix example
code::
(
var controlWindow, w;
var r, a, b, c, d, matrix = [1, 0, 0, 1, 10, 10];
var sliders, spex, name;

w = Window.new.front;
w.view.background_(Color.white);

// create a controller-window
controlWindow = Window("matrix controls", Rect(400,200,350,120));
controlWindow.front;

// determine the rectangle to be drawn
r = Rect.fromPoints(a = 0 @ 0, c = 180 @ 180);
b = r.leftBottom;
d = r.rightTop;

// the drawFunc
w.drawFunc = {
    Pen.strokeColor = Color.red;
    Pen.matrix = matrix;
    Pen.width = 5;
    Pen.strokeRect(r);
    Pen.strokeOval(r);
    Pen.color = Color.blue;
    Pen.width = 0.1;
    Pen.line(a, c);
    Pen.line(b, d);
    Pen.stroke;

    Pen.font = Font( "Helvetica-Bold", 12 );
    Pen.stringAtPoint( "A", a - 6 );
    Pen.stringAtPoint( "B", b - 6 );
    Pen.stringAtPoint( "C", c - (0@6) );
    Pen.stringAtPoint( "D", d - (0@6) );

    Pen.font = Font( "Helvetica", 10 );
    Pen.stringInRect( "a matrix test", r.moveBy( 50, 50 ));
};

controlWindow.view.decorator = sliders = FlowLayout(controlWindow.view.bounds);
spex = [
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 200.0].asSpec,
    [0, 200.0].asSpec
];
name = #[zoomX, shearingY, shearingX, zoomY, translateX, translateY];
6.do { |i|
    EZSlider(controlWindow, 300 @ 14, name[i], spex[i], { |ez| var val;
            val = ez.value;
            [i, val.round(10e-4)].postln;
            matrix.put(i, val);
            w.refresh; // reevaluate drawFunc function
    }, matrix[i]);
    sliders.nextLine;
};
w.refresh;
)
::

subsection:: Transparency layer example
code::
(
w = Window.new("Transparency Layer test", Rect(400,400,430,450)).front;
w.drawFunc = {
    Color.blue.setStroke;

    Pen.use {
    Pen.setShadow(2@2, 10, Color.black);
    Pen.beginTransparencyLayer;

    Color.red.setFill;
    Pen.addOval(Rect(20,40,100,100));
    Pen.fill;

    Color.green.setFill;
    Pen.addOval(Rect(30,70,100,100));
    Pen.fill;

    Color.blue.setFill;
    Pen.addOval(Rect(60,40,100,100));
    Pen.fill;

    "With Transparency Layer".drawCenteredIn(Rect(30, 40, 100, 100), Font.default, Color.white);
    Pen.endTransparencyLayer;
    };

    Pen.use {
    Pen.translate(200, 0);
    Pen.setShadow(2@2, 10, Color.black);


    Color.red.setFill;
    Pen.addOval(Rect(20,40,100,100));
    Pen.fill;

    Color.green.setFill;
    Pen.addOval(Rect(30,70,100,100));
    Pen.fill;

    Color.blue.setFill;
    Pen.addOval(Rect(60,40,100,100));
    Pen.fill;

    "Without Transparency Layer".drawCenteredIn(Rect(30, 40, 100, 100), Font.default, Color.white);
    };

    Pen.use {
        Pen.translate(0, 200);
        Pen.setShadow(2@2, 10, Color.black);
        Pen.beginTransparencyLayer;

        Pen.push;
        Pen.addOval(Rect(20,40,170,170));
        Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);
        Pen.pop;

        "With Transparency Layer".drawCenteredIn(Rect(20,40,170,170), Font.default, Color.white);

        Pen.endTransparencyLayer;
    };

    Pen.use {
        Pen.translate(200, 200);
        Pen.setShadow(2@2, 10, Color.black);
        Pen.addOval(Rect(20,40,170,170));
        Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);

        "Without Transparency Layer".drawCenteredIn(Rect(20,40,170,170), Font.default, Color.white);
    };
};
w.refresh;
)
::

subsection:: Blending modes
code::
/*
different blend modes:
--------------------
0 - Normal
1 - Multiply
2 - Screen
3 - Overlay
4 - Darken
5 - Lighten
6 - ColorDodge
7 - ColorBurn
8 - SoftLight
9 - HardLight
10 - Difference
11 - Exclusion
12 - Hue
13 - Saturation
14 - Color
15 - Luminosity
16 - Clear
17 - Copy
18 - SourceIn
19 - SourceOut
20 - SourceATop
21 - DestinationOver
22 - DestinationIn
23 - DestinationATop
24 - XOR
25 - PlusDarker
26 - PlusLighter
*/

(
	var blendMode=0, blendString="Normal";
	w = Window.new.front;
	m = PopUpMenu(w, Rect(10, w.view.bounds.height - 30, 150, 20));
	m.items = [
		"0 - Normal",
		"1 - Multiply",
		"2 - Screen",
		"3 - Overlay",
		"4 - Darken",
		"5 - Lighten",
		"6 - ColorDodge",
		"7 - ColorBurn",
		"8 - SoftLight",
		"9 - HardLight",
		"10 - Difference",
		"11 - Exclusion",
		"12 - Hue",
		"13 - Saturation",
		"14 - Color",
		"15 - Luminosity"
	];

	m.action_({|view|
		blendMode = view.value;
		blendString = view.items.at(blendMode);
		w.refresh;
	});
	w.drawFunc = {
		80.do{|i|
			Pen.use {
			Pen.blendMode_(blendMode);
			Pen.color = Color.green(0.6, 0.10);
			Pen.addRect(
				Rect(20, 20, 20 + (i*4), 20 + (i*4));
			);
			Pen.fill;
			};
		}
	};
	w.refresh;
)
::


class:: Penvir
summary:: use an environment when embedding the pattern in a stream
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Data Sharing

ClassMethods::

method::new

argument::envir
an environment with objects to embed.

argument::pattern
pattern or stream, usually a link::Classes/Pfunc::, link::Classes/Prout::.

argument::independent
if true streams can write to the environment without influencing other streams created from this pattern. if false, the streams write to a common namespace.

Examples::

code::
(
x = (a:8);
y = Penvir(
	x,
	Pfunc { ~a * 2 }
);

t = y.asStream;
)

t.next;



(
x = (a:8);
y = Penvir(
	x,
	Pfunc { ~a = ~a * 2 }
);

t = y.asStream;
z = y.asStream;
)

t.next;
t.next;
x.postln;	// x stays unchanged
::


class:: Pevent
summary:: Provide an inval for an event stream.
related:: Classes/Pkey, Classes/Pchain
categories:: Streams-Patterns-Events>Patterns

This pattern is mainly used in two cases:
definitionlist::
## using an event pattern as a stream directly
||
code::
a = Pbind(\note, Prand([1, 2, 3], inf)).asStream;
a.next; // returns nil
a = Pevent(Pbind(\note, Prand([1, 2, 3], inf))).asStream;
a.next; // returns an event
::

## setting some default values before they are processed by the pattern
||
code::
Pevent(Pbind(\harmonic, Pseq([24, 25, 29, 30], inf)), (octave: 3, dur: 0.2)).trace.play;
::
::

Pevent is a simpler form of link::Classes/Pchain::, so that these are equivalent:

code::
Pevent(pattern, event)
Pchain(pattern, event)
pattern <> event
::

By contrast to Pchain, Pevent uses an  link::Classes/Event#*default:: if nothing is provided.

ClassMethods::

method:: new

argument::pattern
pattern or stream that returns or modifies events.

argument:: event
an event with objects to embed.  If none is provided, it uses link::Classes/Event#*default::.

examples::

code::
(
SynthDef(\help_sinegrain,
	    { arg out=0, freq=440, sustain=0.05;
		        var env;
		        env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		        Out.ar(out, SinOsc.ar(freq, 0, env))
    }).add;

a = Pn(
	Plazy({
		Pbind(
			\instrument, \help_sinegrain,
			\freq, Pgeom(rrand(200, 600), rrand(1.001, 1.01), rrand(10, 100)).wrap(100, 15000),
			\dur, Pgeom(rrand(0.2, 0.3), rrand(0.99, 0.92))
		)
	})
);


Tdef(\x, {
	var str = Pevent(a).asStream, event;
	loop {
		event = str.next;
		if(event[\freq] % 50 < 20) { event[\freq] = event[\freq] * [1, 1.2, 1.5] };
		event.play;
		event[\dur].wait;
	}

}).play;
)

::


class:: Pexprand
summary:: random values that follow a Exponential Distribution
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new
note::
lo and hi should both be positive or negative (their range should not cross 0).
::

argument::lo
lower boundary of values.

argument::hi
upper boundary of values

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pexprand.new(0.0001, 1, inf);
c = a.asStream.nextN(500);
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pexprand(0.0001, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


TITLE::PfadeIn
SUMMARY::Fade an event pattern in
CATEGORIES::Streams-Patterns-Events>Patterns>Filter
RELATED::Classes/PfadeOut

DESCRIPTION::
Fade an event pattern in by scaling its amplitude over a period of time.

NOTE::This only works on event patterns that are playing synths that have a
code::\amp:: argument in them.::

CLASSMETHODS::
METHOD::new
ARGUMENT::pattern
The pattern to fade in. Must be an event pattern that plays a synth with the code::\amp:: parameter.
ARGUMENT::fadeTime
The time it will take to fade.
ARGUMENT::holdTime

ARGUMENT::tolerance
The tolerance for the rounding of elapsed time used when setting the amplitude
of the input pattern.

INSTANCEMETHODS::
METHOD::fadeTime
Get or set the fadetime

METHOD::holdTime
Get or set the hold time

METHOD::tolerance
Get or set the tolerance used when rounding the internal time.

METHOD::embedInStream
ARGUMENT::inval

METHOD::storeArgs

EXAMPLES::

CODE::
(
// Create a pattern that you want to fade
var pat = Pbind(\dur, 0.125, \degree, Pwhite(1,10));

// Fade it in over 30 beats
pat = PfadeIn.new(pattern:pat, fadeTime:30.0, holdTime:1.0, tolerance:0.0001);

// Play it
pat.play;
)
::


TITLE::PfadeOut
SUMMARY::Fade an event pattern out
CATEGORIES::Streams-Patterns-Events>Patterns>Filter
RELATED::Classes/PfadeIn

CLASSMETHODS::
METHOD::new
ARGUMENT::pattern
The pattern to fade out. Must be an event pattern that plays a synth with the code::\amp:: parameter.
ARGUMENT::fadeTime
The time it will take to fade.

ARGUMENT::holdTime

ARGUMENT::tolerance
The tolerance for the rounding of elapsed time used when setting the amplitude
of the input pattern.

INSTANCEMETHODS::
METHOD::fadeTime
Get or set the fadetime

METHOD::holdTime
Get or set the hold time

METHOD::tolerance
Get or set the tolerance used when rounding the internal time.

METHOD::embedInStream
ARGUMENT::inval

METHOD::storeArgs

EXAMPLES::

CODE::
(
// Create a pattern that you want to fade
var pat = Pbind(\dur, 0.125, \degree, Pwhite(1,10));

// Fade it out over 30 beats
pat = PfadeOut.new(pattern:pat, fadeTime:30.0, holdTime:1.0, tolerance:0.0001);

// Play it
pat.play;
)
::


class:: Pfin
summary:: limit number of events embedded in a stream
related:: Classes/Pfinval, Classes/Pfindur, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

Limits the number of output values from the given pattern or stream. If the stream is able to output more values, Pfin will terminate it early.

The number may be given as a constant, or calculated on the fly from a function or stream. See the "sequence of pitches" example below.

ClassMethods::

method::new
embeds strong::count:: elements of the strong::pattern:: into the stream.

Examples::

code::
(
var a, b;
a = Pfin(5, Pseq(#[1, 2, 3],inf));
b = a.asStream;
9.do({ b.next.postln; });
)


//Pfin used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c, b;
c = Pn(Pfin({ rrand(3, 5) }, Pseq([1, 2, 3, 4, 5, 6], inf) * 4 + 65), inf);
b = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, b.next.midicps]);
		0.12.wait;
	})
}).play;
)

// or, more concisely:

p = Pbind(
	\instrument, \help_sinegrain,
	\midinote, Pn(Pfin({ rrand(3, 5) }, Pseq([1, 2, 3, 4, 5, 6], inf) * 4 + 65), inf),
	\dur, 0.12
).play;

p.stop;
::


class:: Pfindur
summary:: limit total duration of events embedded in a stream
related:: Classes/Pfinval, Classes/Pfin, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new
Embeds elements of the strong::pattern:: into the stream until the duration comes close enough to strong::dur::.

argument::dur
The duration in beats after which the stream should end, derived from the event keys code::dur:: or code::delta::. The delta of the last event is adjusted so that the total duration fits this value. If the stream is shorter than dur, a code::filler:: (see below) can be used to fill the gap.

argument::pattern
The pattern to cut short. This should be an event pattern (returning a stream of events).

argument::tolerance
measuring tolerance for the total duration to avoid jitter




Examples::

code::
(
var a, b;
a = Pfindur(5, Pbind(\dur, Prand([1, 2, 0.5, 0.1], inf)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)


(
var a, b;
a = Pfindur(5, Pbind(\dur, Prand([1, 2, 0.5, 0.1], 4)), filling: (note: 1920));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)


//Pfindur used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c;
c = Pbind(
	\dur, Prand([1, 0.02, 0.2], inf),
	\instrument, \help_sinegrain,
	\degree, Pseries(0, 1, inf),
	\octave, 6
);

Pn(
	Pfindur(1, c)
).play;
)
::


class:: Pfinval
summary:: limit number of items embedded in a stream
related:: Classes/Pfindur, Classes/Pfin, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

note::
Pfinval is not appropriate for wrapping link::Classes/Pmono::, link::Classes/Pfx:: etc. For these types of event patterns, you should use link::Classes/Pfin::.
::

ClassMethods::

method::new
Embeds strong::count:: elements of the strong::pattern:: into the stream.

Examples::

code::
(
var a, b;
a = Pfinval(5, Pseq(#[1, 2, 3],inf));
b = a.asStream;
9.do({ b.next.postln; });
)


//Pfinval used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c, b;
c = Pn(Pfinval({ rrand(3, 5)}, Pseq([1, 2, 3, 4, 5, 6],inf)*4+65),inf);
b = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, b.next.midicps]);
		0.12.wait;
	})
}).play;
)
::


class:: Pfset
summary:: Insert an environment into the event prototype before evaluating the supplied pattern
related:: Classes/Pset
categories:: Streams-Patterns-Events>Patterns>Data Sharing

description::
Good for setting default values or loading server objects.


classmethods::

method:: new

argument:: func
Use environment variable syntax (e.g., code:: ~x = 0 ::) to store values in the internal environment. These values are copied into the event prototype before running the supplied pattern. 
argument:: pattern
An event pattern (such as link::Classes/Pbind::). 
argument:: cleanupFunc
Optional. A function to evaluate when the pattern is stopped, or when the supplied pattern runs out of values. For example, if you loaded a link::Classes/Buffer:: in the initializer function, you could free it in the code::cleanupFunc::.


examples::
code::
(
var a, b;
a = Pfset({
	~legato = 0.3;
	~detune = rrand(0, 30);
}, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

Pfset does not override values placed into the event by the inner pattern:
code::
(
var a, b;
a = Pfset({
	~dur = 0.3;
}, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

Sound example
code::
(
SynthDef(\sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \x, Pfunc { rrand(500, 600) });
a = Pfset({ ~freq = { ~x.postln * 2 }; ~legato = 3; },  a);
a.play;
)
::


class:: Pfsm
summary:: Finite State Machine
related:: Classes/Pdfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Every state consists of an item and an array of integer indices of possible strong::next states::. The initial state is chosen at random from the array of strong::entry states::. That chosen state's item is returned, and the next state is chosen from its array of possible strong::next states::. When the end state is chosen, the stream ends.

Examples::

definitionList::
## list:
|| [
definitionList::
## [ entry states ], ||
## item, [ next states ], ||
## item, [ next states ], ||
## ... ||
## end item (or nil), nil ||
::
## ] ||
::

next states: nil is terminal

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pfsm([
		#[0,1],
		67, #[0, 0, 3],
		72, #[2],
		73, #[0, 2],
		Pseq([74, 75, 76, 77]), #[2, 3, 3],
		nil, nil
	], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)

(
Pfsm([
	#[5, 6, 7], // entry states

	//e1 (== state 0)
	Pbind( \dur, Pseq([ 1/8, 3/8 ]), \midinote, Pseq([ 86, 75 ]) ),
	//#[1],	// as given in CMJ
	// my de-boredom-ated version..
	#[1, 1, 1, 1, 1, 1, 1, 8],
	//e2 (== state 1)
	Pbind( \dur, 1/2, \midinote, Pseq([ 69 ]) ),
	#[0, 1],
	//e3 (== state 2)
	Pbind( \dur, 1/3, \midinote, Pseq([ 55, 60, 66 ]) ),
	#[0, 1, 2, 2, 2, 2, 3, 3, 3, 3],
	//e4 (== state 3)
	Pbind( \dur, 1/4, \midinote, Pseq([ 81, 80, 77, 76 ]) ),
	#[1, 4, 4, 4, 4],
	//e5 (== state 4)
	Pbind( \dur, Pseq([1, 2/3, 2/3, 2/3, 1]), \midinote, Pseq([ \, 70, 70, 70, \ ]) ),
	#[2, 3],
	//e6 (== state 5)
	Pbind( \dur, 1/4, \midinote, Pseq([ 59, 61 ]) ),
	#[0, 2, 4, 5, 5, 5, 5, 5, 5, 5],
	//e7 (== state 6)
	Pbind( \dur, 1/4, \midinote, Pseq([ 87, 88 ], 2) ),
	#[4, 4, 4, 4, 6, 6, 6, 7, 7, 7],
	//e8 (== state 7)
	Pbind( \dur, 1, \midinote, Pseq([ 56 ]) ),
	#[1, 3, 6, 6, 6],
	// terminal state
	nil, nil
]).play;
)
::


class:: Pfunc
summary:: Function pattern
categories:: Streams-Patterns-Events>Patterns>Function
related:: Classes/Pfuncn, Classes/FuncStream

description::
Returns a link::Classes/Stream:: that returns values from the code::nextFunc::. To return a pattern, see link::Classes/Plazy::.


classmethods::

method:: new
argument:: nextFunc
Stream function. In an event stream code::nextFunc:: receives the current link::Classes/Event:: as argument, and more generally the argument passed to the stream's code::next:: call.
argument:: resetFunc
Function that is called when the stream is reset. code::resetFunc:: receives no arguments.


examples::

Numeric stream examples

code::
(
var a, x;
a = Pfunc({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, { \reset.postln });
x = a.asStream;
x.nextN(20).postln;
x.reset;
)

// with argument passed to nextFunc
(
x = Pfunc({ |inval| (10 ** inval.value) * rrand(1, 9) }).asStream;
[2, 3, 2].do { |i| x.next(i).postln };
x.nextN(5, (:0..)).postln;
)
::

Event stream (sound) examples:

code::
(
SynthDef(\help_sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pfunc({ exprand(0.1, 0.3) + #[1, 2, 3, 6, 7].choose }).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)
::

When an Event is played, if code::\freq:: is set then code::\degree:: is ignored (due to the code::Event.default:: machinery). In a chain of Patterns, a code::Pfunc:: can be used to delete a key from the Event stream; this can even be done inside a Pbind.

code::
q = Pbind(\freq, 300, \dur, Pn(0.3, 2));
q.trace.play;

// Sound-wise ineffective modification of the incoming stream
p = Pbind(\degree, 6) <> q;
p.trace.play;

// Instead
p = Pbind(\degree, 6) <> Pfunc { |ev| ev.freq = nil } <> q;
p.trace.play;

// Alternatively
p = Pbind(\degree, Pfunc { |ev| ev.freq = nil; 6 } ) <> q;
p.trace.play;

// Just setting a key to nil from a Pbind pair will end the stream
p = Pbind(\freq, nil, \degree, 6) <> q;
p.trace.play; // silent because it outputs no events
::


class:: Pfuncn
summary:: Function pattern of given length
categories:: Streams-Patterns-Events>Patterns>Function
related:: Classes/Pfunc, Classes/FuncStream

description::
Returns a stream that returns values from the code::func::.


classmethods::

method:: new
argument:: func
Stream function. In an event stream receives the current link::Classes/Event:: as argument.
argument:: repeats
End after this number of times.


examples::
code::
(
var a, b, c;
a = Pfuncn({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, 2);
b = Pfuncn({ #[-2, -3].choose }, 2);
Pseq([a, b], inf).asStream.nextN(20).postln;
)
::

Sound example
code::
(
SynthDef(\help_sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a, b, c;
a = Pfuncn({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, 2);
b = Pfuncn({ #[-2, -3].choose }, 7);
c = Pseq([a, b], inf).asStream;
{
	c.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pfx
summary:: add an effect synth to the synths of a given event stream
related:: Classes/Pfxb, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Puts an effect node on the tail of the current group and releases it when the contained pattern finishes. If a bus is given, it is used as an effect bus. Name value pairs are inserted into the event for starting the effect node. The effect parameters are set from the event.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Pseq([p, q, r, o], 2).play;
)
::


class:: Pfxb
summary:: add an effect synth to the synths of a given event stream
related:: Classes/Pfx, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Puts an effect node on the tail of the current group and releases it when the contained pattern finishes. Name value pairs are inserted into the event for starting the effect node. The effect parameters are set from the event.

In difference to link::Classes/Pfx::, a strong::private effect bus:: is provided according to the number of channels in the effect synth def.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfxb(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfxb(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfxb(r, \wah);

Pseq([p, q, r, o], 2).play;
)


// test order of effect chain
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\addbeeps, { arg out=0, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) + (LFPulse.kr(1, 0, 0.3) * SinOsc.ar(1000) * 0.4) ));
}, [\ir, 0.1, 0.1, 0]).add;
)

(
var a;
a = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
a = Pfxb(a, \echo, \dtime, 0.2, \decay, 3);
a = Pfxb(a, \addbeeps);
a.play;
)

(
var a;
a = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
a = Pfxb(a, \addbeeps);
a = Pfxb(a, \echo, \dtime, 0.2, \decay, 3);
a.play;
)
::


class:: Pgate
summary:: A gated stream that only advances when a particular event key is true.
related:: Classes/Pn
categories:: Streams-Patterns-Events>Patterns>Repetition
description::

Pgate advances its subpattern whenever strong::key:: is true. Pgate must be used within an Event pattern. You can either set the key manually, or use LINK::Classes/Pn::.

CLASSMETHODS::

METHOD:: new

ARGUMENT:: pattern
The source pattern to be filtered.

ARGUMENT::repeats
Repeat the enclosed pattern strong::repeats:: times.

ARGUMENT::key
Pgate will only return the next value in the source pattern if the event that it belongs to has strong::key:: set to true. Otherwise it will keep returning the same value. This allows for a gated effect on streams.

Examples::

code::
// Use \step to change the octave randomly
(
Pbind(
	\degree, Pseq((0..7), inf),
	\step, Pseq([false, false, false, true, false, true, false], inf),
	\octave, Pgate(Pwhite(3,7), inf, \step),
	\dur, 0.2
).play
)
::

code::
// Pn advances Pgate each time its subpattern is repeated
(
Pbind(
	\degree, Pn(Pseq((0..7)), inf, \step),
	\mtranspose, Pgate(Pwhite(0,5), inf, \step),
	\dur, 0.2
).play
)


// Two different Pgates advanced at two different rates
(
Pbind(

	\scale,	Scale.minor,
	\foo, Pn(Pseq((0..2)),inf,  \step1),
	\degree, Pn(Pseq((0..7).mirror), inf, \step),
	\ctranspose, Pgate(Pwhite(0,5), inf, \step) + Pgate(Pseq([0,7,0,-7], inf), inf, \step1),
	\dur, 0.2
).play
)
::



class:: Pgauss
summary:: random values that follow a Gaussian Distribution
related:: Classes/Ppoisson
categories:: Streams-Patterns-Events>Patterns>Random

description::

This pattern uses the Box-Muller transform to generate a gaussian distribution from uniformly distributed values: code::sqrt(-2 * log(1.0.rand)) * sin(2pi.rand)::

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::dev
The spread of values around the mean (standard deviation).

argument::length
Number of values produced.

Examples::

code::
(
var a;
a = Pgauss(0.0, 100, inf);
c = a.asStream.nextN(500);
w = Window.new("Pgauss", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pgauss(0.0, 10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pgauss", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pgauss(0.0, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pgbrown
summary:: geometric brownian motion pattern
related:: Classes/BrownNoise, Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>Random

description::

Returns a stream that behaves like a geometric brownian motion.

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::step
maximum multiplication factor per step (omega) - the distribution is xrand2.

argument::length
number of values produced.

Examples::

code::
(
var a, b;
a = Pgbrown(0.0, 1.0, 0.2, inf);
b = a.asStream;
7.do({ b.next.postln; });
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pgbrown(1.0, 2.0, 0.1, inf).asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
	0.02.wait;
	})
}).play;
)

// compare with normal brownian motion:

(
var a;
a = Pbrown(1.0, 2.0, 0.1, inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	})
}).play;
)
::


class:: Pgeom
summary:: geometric series pattern
related:: Classes/Pseries
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a stream that behaves like a geometric series.

ClassMethods::

method::new

argument::start
start value.

argument::grow
multiplication factor.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pgeom(1.0, 1.1, inf);
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pgeom(300, 1.03, 70).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val]);
		0.02.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\freq, Pgeom(800, Pbrown(0.99, 1.01, 0.01, inf), inf)
).play;
)
::


TITLE:: Pget
summary:: Retrieve a value within the scope (namespace) of a Plambda
categories:: Streams-Patterns-Events>Patterns>Data Sharing
related:: Classes/Plambda, Classes/Plet

DESCRIPTION::
link::Classes/Pget:: retrieves the value of a link::Classes/Plet::. 
link::Classes/Plet::/link::Classes/Pget:: are used to share data between patterns inside of a link::Classes/Plambda::

CLASSMETHODS::

METHOD:: new

ARGUMENT:: key
The name of the variable

ARGUMENT:: default
default value if none is defined by a paired link::Classes/Plet::

ARGUMENT:: repeats

INSTANCEMETHODS::

METHOD:: default

METHOD:: storeArgs

METHOD:: key

METHOD:: repeats

METHOD:: embedInStream

ARGUMENT:: inval

EXAMPLES::

code::
(
	/*

	Two patterns playing in parallel, 
	sharing data between eachother

	*/

	// a melody playing random scale degrees
	a = Pbind(
		\dur, 0.125, 
		\octave, 4,
		\degree, Plet(\melody, pattern: Pwhite(0,7))
	);

	// the bass, scale degrees sampled from the \melody variable defined above 
	b = Pbind(
		\dur, 0.5, 
		\octave, 3,
		\degree, Pget(\melody, default: 1, repeats: inf).trace
	);

	// Play the patterns in parallel
	Plambda(
		Ppar([a, b], inf)
	).play;
)
::


class:: Pgpar
summary:: embed event streams in parallel and put each in its own group
related:: Classes/Ppar, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order. When one stream ends, the other streams are further embedded until all have ended.

note::
In order to fully separate these layers from other synths, use link::Classes/Pbus::.
::

See link::Classes/Pgroup:: for a description of the code::\groupReleaseTime:: event key.

ClassMethods::

method::new

argument::list
list of patterns or streams.

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// an example analogous to the one in the Pfx helpfile

(

SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1, rate=0.3;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(rate), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

 // watch the node structure as it changes
s.waitForBoot({ s.plotTree });


(
var p, q, r, o;
Pbus(
	Pgpar([
		Pbind(\degree, Prand((0..7), inf), \dur, 0.3, \legato, 0.2),
		Pbind(\instrument, \echo, \dur, 3, \legato, 1.1,
			\dtime, Pwhite(0.01, 0.1, inf), \decay, 3),
		Pbind(\instrument, \distort, \dur, 1.2, \legato, 1.1,
			\pregain, Pwhite(1, 20, inf), \amp, 0.25),
		Pbind(\instrument, \wah, \dur, 4.0, \legato, 1.1,
			\rate, Pwhite(0.1, 3, inf))
	])
).play
)
::

code::
// synthdefs
(
SynthDef(\gap, { arg out, sustain=1.0, attack=0.0001, decay=0.01, leak;
	var level;
	level = EnvGen.ar(Env.linen(attack, sustain, decay, 1-leak), doneAction: Done.freeSelf);
	XOut.ar(out, level, Silent.ar ! 2)
}).add;

SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
}).add;
)


// play a layered pattern with gaps and overlays
(
x = Pbind(
	\instrument, \help_sinegrain,
	\degree, Pn(Plazy({ Prand([0, 4, 5], 16) + 5.rand })) + Prand(#[0, [0, 3], [0, 7]], inf),
	\dur, Prand([0.25, 0.5, 1.0], inf),
	\scale, #[0, 3, 5, 9, 10]
);
y = Pbind(
	\instrument, \gap,
	\dur, Prand([0.25, 0.5, 1.0], inf) * Pdup(inf, Prand([0.25, 1, 2],1)),
	\legato, Prand([0.25, 0.5, 1.0], inf),
	\leak, 0.25
);
a = Pbus(Pgpar([x, y, x, y, x, y]));
a.play;
)
::


class:: Pgroup
summary:: Starts a new Group and plays the pattern in this group
related:: Classes/Group, Classes/Pbus
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

The group is released when the stream has ended. The group's strong::release:: is delayed (default 0.1 beats) until after the last note releases. But, Pgroup does not know how long the synths' envelopes last. You can extend the lag by putting the number of beats into the event prototype's code::\groupReleaseTime:: key:
code::
Pgroup(...).play(protoEvent: Event.default.put(\groupReleaseTime, releaseLag));
::

Examples::

code::

p = Pbind(\degree, Prand((0..7), inf), \dur, 0.3, \legato, 0.2);

 // watch the node structure as it changes
s.waitForBoot({ s.plotTree });

// one group
Pgroup(p).play;

// two nested groups
Pgroup(Pgroup(p)).play;
Pgroup(Ppar([Pgroup(p), Pgroup(p)])).play;




::


class:: Pgtpar
summary:: embed event streams in parallel and put each in its own group, with time offset
related:: Classes/Pgpar, Classes/Ptpar, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Similar to link::Classes/Pgpar:: but with additional timing offsets.

ClassMethods::

method::new

argument::list
list of pairs of times and patterns or streams: [time, pat, time, pat .. ].

note:: times are in beats and depend on the tempo of the link::Classes/TempoClock:: in use.::

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// synthdef
(
SynthDef(\help_sinegrain,
    { arg out=0, freq=440, sustain=0.05;
        var env;
        env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
        Out.ar(out, SinOsc.ar(freq, 0, env))
}).add;
)

// pattern with different start times
(
x = Pbind(
    \instrument, \help_sinegrain,
    \degree, Pseq(#[0, 5, 4, 2, 1, 1, 3], inf),
    \dur, Pseq(#[0.25, 0.5, 1.0], inf),
    \scale, #[0, 3, 5, 9, 10]
);
a = Pbus(Pgtpar([0.0, x, 1.5, x, 2.25, x])).play;
)
s.plotTree;
a.stop;
::


class:: Phasor
summary:: A resettable linear ramp between two levels.
categories::  UGens>Triggers, UGens>Buffer


Description::

Phasor is a linear ramp between start and end values. When its trigger
input crosses from non-positive to positive, Phasor's output will jump to
its reset position. Upon reaching the end of its ramp Phasor will wrap
back to its start.


note::
N.B. Since end is defined as the wrap point, its value is never
actually output.
::

note::
If one wants Phasor to output a signal with frequency teletype::freq:: oscillating between teletype::start:: and teletype::end::, then the rate should be teletype::(end - start) * freq / sr:: where teletype::sr:: is the sampling rate.
::

Phasor is commonly used as an index control with link::Classes/BufRd:: and link::Classes/BufWr::.


classmethods::

method::ar, kr

argument::trig

When triggered, jump to resetPos (default: 0, equivalent to
start).


argument::rate

The amount of change per sample, i.e at a rate of 1 the value of
each sample will be 1 greater than the preceding sample.


argument::start

Start point of the ramp.


argument::end

End point of the ramp.


argument::resetPos

The value to jump to upon receiving a trigger.


Examples::

code::

// phasor controls sine frequency: end frequency matches a second sine wave.

(
{ var trig, rate, x, sr;
	rate = MouseX.kr(0.2, 2, 1);
	trig = Impulse.ar(rate);
	sr = SampleRate.ir;
	x = Phasor.ar(trig, rate / sr);
	SinOsc.ar(
		[
			LinLin.kr(x, 0, 1, 600, 1000), // convert range from 0..1 to 600..1000
			1000 // constant second frequency
		], 0, 0.2)

}.play;
)


// two phasors control two sine frequencies: mouse y controls resetPos of the second
(
{ var trig, rate, x, sr;
	rate = MouseX.kr(1, 200, 1);
	trig = Impulse.ar(rate);
	sr = SampleRate.ir;
	x = Phasor.ar(trig, rate / sr, 0, 1, [0, MouseY.kr(0, 1)]);
	SinOsc.ar(x * 500 + 500, 0, 0.2)
}.play;
)


// use phasor to index into a sound file

// allocate a buffer with a sound file
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// simple playback (more examples: see BufRd)
// Start and end here are defined as 0 and the number of frames in the buffer.
// This means that the Phasor will output values from 0 to numFrames - 1 before looping,
// which is perfect for driving BufRd. (See note above)
{ BufRd.ar(1, b.bufnum, Phasor.ar(0, BufRateScale.kr(b.bufnum), 0, BufFrames.kr(b.bufnum))) }.play;


// two phasors control two sound file positions: mouse y controls resetPos of the second
(
{ var trig, rate, framesInBuffer;
	rate = MouseX.kr(0.1, 100, 1);
	trig = Impulse.ar(rate);
	framesInBuffer = BufFrames.kr(b.bufnum);
	x = Phasor.ar(trig, BufRateScale.kr(b.bufnum), 0, framesInBuffer,
		[0, MouseY.kr(0, framesInBuffer)]);
	BufRd.ar(1, b.bufnum, x);
}.play;
)

::


class:: Phprand
summary:: random values that tend toward hi
related:: Classes/Plprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Phprand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Phprand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Phprand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, max(rrand(0.0, 1.0), rrand(0.0, 1.0)) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pif
summary:: Pattern-based conditional expression
related:: Classes/Pwhile
categories:: Streams-Patterns-Events>Patterns>Language Control

ClassMethods::

method::new

argument::condition
A pattern or stream returning a link::Classes/Boolean:: value.

argument::iftrue
This stream is evaluated if the link::Classes/Boolean:: is true.

argument::iffalse
This stream is evaluated if the link::Classes/Boolean:: is false.

argument::default
This value (not stream) is returned if "iftrue" or "iffalse" return nil at any time.

Examples::

code::
p = Pif(Pfunc({ 0.3.coin }), Pwhite(0, 9, inf), Pwhite(100, 109, inf)).asStream;
p.nextN(20);

// 7 of the 20 values, or roughly 30%, are in the 0-9 range:

[ 105, 107, 107, 8, 100, 3, 105, 5, 107, 106, 1, 104, 8, 102, 102, 4, 108, 8, 109, 101 ]


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pif(Pfunc({ 0.3.coin }), Pn(Pseries(0.5, 0.1, 10)), Pn(Pseries(6, -0.1, 10))).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.2.wait;
	}
}.fork;
)
::


class:: Pindex
summary:: pattern that indexes into an array
related:: Classes/Pswitch
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

This allows an link::Classes/ArrayedCollection:: to be accessed within patterns.

ClassMethods::

method::new

argument::listPat
the array. Can be a link::Classes/Pattern::.

argument::indexPat
the value to retrieve. Can be a link::Classes/Pattern::.

argument::repeats
specifies the number of repeats.

Examples::

code::
(
SynthDef(\help_pindex, { | out, amp=0.1, freq=440, gate=1 |
	var son = Saw.ar(freq * [0.99, 1, 1.01]).mean;
	son = son * EnvGen.ar(Env.adsr, gate: gate, doneAction: Done.freeSelf);
	Out.ar(out, son.dup * amp);
}).add;
)

(
var data = [7, 13, 12, 2, 2, 2, 5];
var indices = [0, 0, 2, 0, 4, 6, 7];
Pbind(
	\instrument, \help_pindex,
	\choice, Prand(indices, inf),
	\degree, Pindex(data, Pkey(\choice), inf),
	\dur, 0.7
).play
)
::


class:: PingPong
summary:: Stereo ping-pong delay.
related:: Classes/SinOsc
categories::  UGens>Delays>Buffer


Description::

Bounces sound between two outputs…  Like a ping-pong ball. PingPong is
actually a compound built upon  link::Classes/RecordBuf::  and
link::Classes/PlayBuf:: .


classmethods::

method::ar

argument::bufnum
First index of a multi channel buffer.

argument::inputs
An array of audio inputs, the same size as your buffer.

argument::delayTime
Delay time in seconds.

argument::feedback
Feedback coefficient.

argument::rotate

Which rotates the inputArray by one step. (left → right, right →
left). Rotation of 0 (or 2) would result in no rotation to the
inputArray. You cannot modulate this number by assigning it to a control in a SynthDef.


Examples::

code::

(
s = Server.local;
s.waitForBoot({

b = Buffer.alloc(s, 44100 * 2, 2);

SynthDef("help-PingPong", { |out = 0, bufnum = 0, feedback = 0.5, delayTime = 0.2|
	var left, right;
	left = Decay2.ar(Impulse.ar(0.7, 0.25), 0.01, 0.25,
		SinOsc.ar(SinOsc.kr(3.7,0,200,500)));
	right = Decay2.ar(Impulse.ar(0.5, 0.25), 0.01, 0.25,
		Resonz.ar(PinkNoise.ar(4), SinOsc.kr(2.7,0,1000,2500), 0.2));

	Out.ar(out ,
		PingPong.ar(bufnum, [left,right], delayTime, feedback, 1)
	)
}).play(s, [\out, 0, \bufnum, b.bufnum, \feedback, 0.5, \delayTime,0.1]);

})
)

b.free;

(
s = Server.local;
s.waitForBoot({

b = Buffer.alloc(s, 44100 * 2, 2);

SynthDef("help-PingPong", { |out = 0, bufnum = 0|
	var left, right;
	left = Decay2.ar(Impulse.ar(0.7, 0.25), 0.01, 0.25,
		SinOsc.ar(SinOsc.kr(3.7,0,200,500)));
	right = Decay2.ar(Impulse.ar(0.5, 0.25), 0.01, 0.25,
		Resonz.ar(PinkNoise.ar(4), SinOsc.kr(2.7,0,1000,2500),
0.2));

	Out.ar(out,
		PingPong.ar(bufnum, [left, right] *  EnvGen.kr(Env([1, 1, 0], [2, 0.1])),
			0.1, 0.8, 1)
	)
}).play(s, [\out, 0, \bufnum, b.bufnum]);
});
)

b.free;


::



class:: PinkNoise
summary:: Pink Noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/ClipNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose spectrum falls off in power by 3 dB per octave, which gives equal power over the span of each octave.
This version is band-limited to 8 octaves.

Internally, this UGen calculates its output by means of the Voss-McCartney algorithm.
link::http://www.firstpr.com.au/dsp/pink-noise/allan-2/spectrum2.html::

note::
The values produced by this UGen were observed to lie with very high probability between approximately -0.65 and +0.81 (before being multiplied by mul). The signal's RMS is approximately -16 dB.
::


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-PinkNoise", { arg out=0;
	Out.ar(out,
		PinkNoise.ar(0.4)
	)
}).play;
)

::



class:: Pipe
summary:: pipe stdin to, or stdout from, a UNIX shell command
related:: Classes/UnixFILE
categories:: Files

description::
Pipe stdin to, or stdout from, a UNIX shell command. Pipe treats the shell command as if it were a UnixFILE, and returns nil when done. See link::Classes/UnixFILE:: for details of the access methods. Pipe must be explicitly closed. Do not rely on the garbage collector to do this for you!

ClassMethods::

method::new

argument::commandLine
A link::Classes/String:: representing a valid shell command.

argument::mode
A link::Classes/String:: representing the mode. Valid modes are "w" (pipe to stdin) and "r" (pipe from stdout).

method::argv

argument::args
A link::Classes/SequenceableCollection:: containining strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.

argument::mode
A link::Classes/String:: representing the mode. Valid modes are "w" (pipe to stdin) and "r" (pipe from stdout).

InstanceMethods::

private::prClose, prOpen, prOpenArgv

method::open
Open the file.

argument::commandLine
A command line link::Classes/String:: passed to popen.

argument::mode
A link::Classes/String:: passed to popen, so should be one of: "r","w"

method::openArgv
Open the file.

argument::args
A link::Classes/SequenceableCollection:: containining strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.

argument::mode
A link::Classes/String:: passed to popen, so should be one of: "r","w"

method::close
Closes the pipe, waiting for the command to finish. You must do this explicitly before the Pipe object is garbage collected.

returns:: The exit status of the command (an Integer).

Examples::

code::
// this pipes in stdout from ls
(
var p, l;
p = Pipe.new("ls -l", "r");			// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::

without using a shell:

code::
// this pipes in stdout from ls
(
var p, l;
p = Pipe.argv(["ls","-l"], "r");			// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::

A more time-intensive request:
code::
(
var p, l;
p = Pipe.new("ping -c10 sourceforge.net", "r");	// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::


class:: Pitch
summary:: Autocorrelation pitch follower
categories:: UGens>Analysis>Pitch

description::
This is a better pitch follower than link::Classes/ZeroCrossing::, but more costly of CPU. For most purposes the default settings can be used and only code::in:: needs to be supplied. Pitch returns two values (via an link::Classes/Array:: of OutputProxys, see the link::Classes/OutputProxy:: help file), a code::freq:: which is the pitch estimate and code::hasFreq::, which tells whether a pitch was found. Some vowels are still problematic, for instance a wide open mouth sound somewhere between a low pitched short 'a' sound as in 'sat', and long 'i' sound as in 'fire', contains enough overtone energy to confuse the algorithm.

classmethods::
private:: categories
method:: kr
argument::in
argument::initFreq
argument::minFreq
argument::maxFreq
argument::execFreq
argument::maxBinsPerOctave
argument::median
argument::ampThreshold
argument::peakThreshold
argument::downSample
argument::clar

discussion::
The pitch follower executes periodically at the rate specified by code::execFreq:: in cps. code::execFreq:: is clipped to be between code::minFreq:: and code::maxFreq::. First it detects whether the input peak to peak amplitude is above the code::ampThreshold::.
If it is not then no pitch estimation is performed, code::hasFreq:: is set to zero and code::freq:: is held at its previous value. It performs an autocorrelation on the input and looks for the first peak after the peak around the lag of zero that is above code::peakThreshold:: times the amplitude of the peak at lag zero.

If the code::clar:: argument is greater than zero (it is zero by default) then code::hasFreq:: is given additional detail. Rather than simply being 1 when a pitch is detected, it is a "clarity" measure in the range between zero and one. (Technically, it's the height of the autocorrelation peak normalised by the height of the zero-lag peak.)
It therefore gives a kind of measure of "purity" of the pitched signal.

Using a code::peakThreshold:: of one half does a pretty good job of eliminating overtones, and finding the first peak above that threshold rather than the absolute maximum peak does a good job of eliminating estimates that are actually multiple periods of the wave.

The autocorrelation is done coarsely at first using a maximum of code::maxBinsPerOctave:: lags until the peak is located. Then a fine resolution search is performed until the peak is found. (Note that maxBinsPerOctave does NOT affect the final pitch resolution; a fine resolution search is always performed.
Setting maxBinsPerOctave larger will cause the coarse search to take longer, and setting it smaller will cause the fine search to take longer.)

The three values around the peak are used to find a fractional lag value for the pitch. If the pitch frequency is higher than code::maxFreq::, or if no peak is found above code::minFreq::, then code::hasFreq:: is set to zero and code::freq:: is held at its previous value.

It is possible to put a median filter of length code::median:: on the output estimation so that outliers and jitter can be eliminated. This will however add latency to the pitch estimation for new pitches, because the median filter will have to become half filled with new values before the new one becomes the median value.
If median is set to one then that is equivalent to no filter, which is the default.

When an in range peak is found, it is inserted into the median filter, a new pitch is read out of the median filter and output as code::freq::, and code::hasFreq:: is set to one.

It is possible to down sample the input signal by an integer factor code::downSample:: in order to reduce CPU overhead. This will also reduce the pitch resolution.

Until Pitch finds a pitch for the first time, it will output code::initFreq::.

None of these settings are time variable.

instancemethods::
private:: init

examples::

code::
	// (use headphones!)

	(
		SynthDef("pitchFollow1", { |out|
			var in, amp, freq, hasFreq, sound;
			in = Mix.new(SoundIn.ar([0, 1]));
			amp = Amplitude.kr(in, 0.05, 0.05);
			# freq, hasFreq = Pitch.kr(in, ampThreshold: 0.02, median: 7);
			//freq = Lag.kr(freq.cpsmidi.round(1).midicps, 0.05);
			sound = Mix.new(VarSaw.ar(freq * [0.5, 1, 2], 0, LFNoise1.kr(0.3, 0.1, 0.1), amp));
			6.do {
				sound = AllpassN.ar(sound, 0.040, [0.040.rand,0.040.rand], 2)
			};
			Out.ar(out, sound);
		}).play
	)
::

code::

	(
		SynthDef("pitchFollow2", { |out|
			var in, amp, freq, hasFreq, sound;
			in = Mix.new(SoundIn.ar([0, 1]));
			amp = Amplitude.kr(in, 0.05, 0.05);
			# freq, hasFreq = Pitch.kr(in, ampThreshold: 0.02, median: 7);
			sound = CombC.ar(LPF.ar(in, 1000), 0.1, (2 * freq + 10).reciprocal, -6).distort * 0.05;
			6.do({
				sound = AllpassN.ar(sound, 0.040, [0.040.rand, 0.040.rand], 2)
			});
			Out.ar(out, sound);
		}).play(s);
	)

/*

RM octaver

inSignal is RingModulated by a sinusoidal tone with half frequency.
The resulting spectrum is given by all the components of inSignal with
half freqs.
This means that the new spectrum is a one 8ve below version of the input signal's one,
with only odd partials.
As a consequence, if inSignal is added again, even partials are
recovered.

See:
Miller Puckette, The Theory and Technique of Electronic Music, p. 126
http://crca.ucsd.edu/~msp/techniques/latest/book.pdf
http://crca.ucsd.edu/~msp/techniques/latest/book-html/node77.html#sect5.ringmod

andreavalle

*/

	(
		SynthDef(\RmOctaver, { |out|
			var in, freq, hasFreq;
			in = SoundIn.ar(0);
			# freq, hasFreq = Pitch.kr(in);
			Out.ar(out, SinOsc.ar(freq: freq * 0.5) * in + in);
		}).add;
	)

	Synth.new(\RmOctaver);

::


class:: PitchShift
summary:: Time domain pitch shifter.
categories::  UGens>Filters>Pitch


Description::

A time domain granular pitch shifter. Grains have a triangular amplitude
envelope and an overlap of 4:1, and use linear interpolation of the buffer.


classmethods::

method::ar

argument::in

The input signal.


argument::windowSize

The size of the grain window in seconds. This value cannot be
modulated. The minimum value is 3 sample periods. If you supply a smaller
value, it will be rounded up to the minimum.


argument::pitchRatio

The ratio of the pitch shift. Must be from 0 to 4.


argument::pitchDispersion

The maximum random deviation of the pitch from the

code::pitchRatio:: .


argument::timeDispersion

A random offset from zero to code::timeDispersion:: seconds is added to the
delay of each grain. Use of some dispersion can alleviate a hard
comb filter effect due to uniform grain placement. It can also be
an effect in itself.
code::timeDispersion:: can be no larger than code::windowSize::.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

(
play({
	z = Blip.ar(800, 6, 0.1);
	PitchShift.ar(z, 0.02, Line.kr(0.1,4,20), 0, 0.0001)
}))

(
// pitch shift input - USE HEADPHONES to prevent feedback.
play({
	PitchShift.ar(
		SoundIn.ar([0, 1]),	// stereo audio input
		0.1, 			// grain size
		MouseX.kr(0,2),	// mouse x controls pitch shift ratio
		0, 				// pitch dispersion
		0.004			// time dispersion
	)
}))

(
// use PitchShift to granulate input - USE HEADPHONES to prevent feedback.
// upper left corner is normal playback. x = pitch dispersion, y = time dispersion
var grainSize;
grainSize = 0.5;
play({
	PitchShift.ar(
		SoundIn.ar([0, 1]),
		grainSize,
		1,						// nominal pitch rate = 1
		MouseX.kr(0,1), 			// pitch dispersion
		MouseY.kr(0, grainSize)	// time dispersion
	)
}))

::


class:: Pkey
summary:: access a key in an event stream
related:: Classes/Penvir
categories:: Streams-Patterns-Events>Patterns>Data Sharing

description::

Pkey simplifies backward access to values in an event being processed by link::Classes/Pbind:: or another event pattern.

ClassMethods::

method::new

argument::key
The name of the event variable to read from.

argument::repeats
The number of items returned before finishing. Using code::nil::, the default value, makes the stream infinite.

Examples::

code::
// \b should thus take twice the value of \a in each event:
p = Pbind(\a, Pwhite(1, 10, inf), \b, Pkey(\a) * 2).asStream;


p.next(())	// for Pbind, must pass in a default event even if empty

( 'a': 10, 'b': 20 )
( 'a': 2, 'b': 4 )
( 'a': 5, 'b': 10 )
( 'a': 4, 'b': 8 )
( 'a': 2, 'b': 4 )

// note: to check if a Pkey's result /equals/ another value,
// be sure to use |==|
p = Pbind(
	\a, Pseries(1, 1, inf),
	\b, Pif(
		Pkey(\a) == 2,
		"equals 2",
		"nope"
	)
).asStream;

p.next(());  // 'b' is always "nope"

p = Pbind(
	\a, Pseries(1, 1, inf),
	\b, Pif(
		Pkey(\a) |==| 2,
		"equals 2",
		"nope"
	)
).asStream;

p.next(());  // 'b' is as expected
::


class:: Place
summary:: interlaced embedding of subarrays
related:: Classes/Ppatlace
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns elements in the list. If an element is an array itself, it embeds the first element when it comes by first time, the second element when it comes by the second time... The nth when it comes by the nth time.

Examples::

code::
(
var a, b;
a = Place(#[1, [2,5], [3, 6]], inf);
x = a.asStream;
8.do({ x.next.postln; });
)

1
2
3
1
5
6
1
2



//Place used as a sequence of pitches

(
SynthDef("help-sinegrain",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
c = Place(#[0, 0, [0, 4, 7], [1, 5, 8], [2, 6, 9]], inf) + 67;
x = c.asStream;
Routine({
	loop({
		Synth("help-sinegrain", [\freq, x.next.midicps]);
		0.17.wait;
	})
}).play;
)
::


class:: Plambda
summary:: create a scope (namespace) for enclosed streams
related:: Classes/Penvir, Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Data Sharing

Plambda is used to create a namespace for patterns to share data among each other.

Used in combination with link::Classes/Plet:: and link::Classes/Pget::, it allows you to get the output of a pattern from one stream and use it in another stream and as such create a dataspace for your patterns.

ClassMethods::

method::new

argument::pattern
an event stream.

argument::scope
an event with default bindings (can be nil).

Examples::

code::
/*

A simple example:
Two patterns playing in parallel,
sharing data between eachother

*/
(
	// a melody playing random scale degrees
	a = Pbind(
		\dur, 0.125,
		\octave, 4,
		\degree, Plet(\melody, pattern: Pwhite(0,7))
	);

	// the bass, scale degrees sampled from the \melody variable defined above
	b = Pbind(
		\dur, 0.5,
		\octave, 3,
		\degree, Pget(\melody, default: 1, repeats: inf).trace
	);

	// Play the patterns in parallel
	Plambda(
		Ppar([a, b], inf)
	).play;
)
/*

A more complex example:
Three patterns running in parallel

*/
(
SynthDef(\sine,
	{ arg out=0, freq=440, sustain=0.05, pan=0, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(Rand(0.001, 0.02), sustain, AmpCompA.kr(freq)*amp), doneAction: Done.freeSelf);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq), pan, env))
	}).add;
)

(
a = Plambda(
	Pseq([
	Pfindur(5,
		Ppar([
			Pbind(\note, Plet(\x, Prand([1, 5, 1, [10, 14]], inf)), \dur, 8/3, \pan, -1),
			Pbind(\note, Plet(\y, Pseq([5, 3, 2, 0, [0, 5, 6, 9]], inf)), \dur, 0.5, \pan,1),
			Pbind(\note, Pseq([Pget(\x), Pget(\y)], inf) + 12, \pan, 0, \dur, 2/3)
		])
	),
	Pbind(\note, Pget(\x, 0, 6) + [0, 5], \dur, Pdup(inf, Prand([2/3, 1/6])))
	], inf).trace(\eventScope) // internally, the values are shared via \eventScope
);

b = Pbindf(a, \instrument, \sine, \legato, 0.1);
b.play
)

// Play two copies of the complex pattern above in parallel, one of them transposed and playing with shorter durations
Ppar([b, Pbindf(b, \ctranspose, 24, \dur, Pkey(\dur) * 0.25)]).play;
::


class:: Platform
summary:: handle cross-platform differencies
categories:: Platform

description::
The Platform class (along with its subclasses) handles things which differ between operating systems (mac/linux/windows/...), to simplify cross-platform aspects of SuperCollider.

Platform is an abstract class encapsulating various platform dependent constants and properties, such as directories, primitive features and startup files. The platform object is accessible through the code::platform:: method of the main process instance:
code::
thisProcess.platform
::

Currently implemented platforms include: OSXPlatform, LinuxPlatform, WindowsPlatform, UnixPlatform.

classmethods::
Most of Platforms class methods are simply wrappers to code::thisProcess.platform.method::.

subsection:: Platform name and platform dependent actions

method:: case
Perform actions depending on the current platform (name), just like Object:switch:
code::
Platform.case(
    \osx,       { "OSX".postln },
    \linux,     { "Linux".postln },
    \windows,   { "Windows".postln }
);
::

method:: ideName
returns a String indicating which IDE the language believes it is running in. (Often this is determined via the "-i" option to the sclang executable.) This is determined when sclang starts and cannot be changed dynamically.

The main purpose of this is to include/exclude folders from the class search patch depending on which IDE is in use: for example, if the value of ideName is "scapp" then folders named "scide_scapp" are included and all other folders beginning with "scide_" are excluded. The default value of this is "none".

Known IDE names in use are "scapp" (SuperCollider.app on Mac), "scvim" (vim), "scel" (emacs). Others may be used.

subsection:: Directories and filesystem stuff
method:: classLibraryDir
location of the bundled class library

method:: helpDir
location of the bundled help files

method:: systemAppSupportDir
system application support directory

method:: systemExtensionDir
system extension directory (see link::Guides/UsingExtensions::)

method:: userHomeDir
user home directory

method:: userAppSupportDir
user application support directory

method:: userConfigDir
directory for configuration files

method:: userExtensionDir
user extension directory (see link::Guides/UsingExtensions::)

method:: platformDir
platform specific directory for class files (see link::Guides/UsingExtensions::)

method:: pathSeparator
platform specific path separator

method:: resourceDir
platform specific resource directory

method:: recordingsDir
platform recordings directory

method:: defaultTempDir
default directory for temporary files

method:: hasQt
true if the Qt library is available, false otherwise

method:: hasQtWebEngine
true if the QtWebEngine library is available, false otherwise

method:: architecture
A link::Classes/Symbol:: naming the architecture for which this version of SuperCollider was built.
Returns one of 'AArch32' (32-bit ARM), 'AArch64' (64-bit ARM, introduced in ARMv8), 'Itanium64', 'i386', 'x86_64',
'PowerPC', or 'unknown' if the architecture is unidentifiable.

subsection:: Features

method:: when
Evaluate ifFunction if all features are present, otherwise evaluate elseFunction.
code::
Platform.when(#[\Document, \SCWindow], { "yeehah!".postln });
::

instancemethods::

private:: shutdown, startup

method:: name
returns the platform name

method:: recompile
recompile class library

subsection:: Directories and filesystem stuff

method:: classLibraryDir
location of the bundled class library

method:: helpDir
location of the bundled help files

method:: systemAppSupportDir
system application support directory

method:: systemExtensionDir
system extension directory (see link::Guides/UsingExtensions::)

method:: userHomeDir
user home directory

method:: userAppSupportDir
user application support directory

method:: userConfigDir
directory for configuration files

method:: userExtensionDir
user extension directory (see link::Guides/UsingExtensions::)

method:: platformDir
platform specific directory for class files (see link::Guides/UsingExtensions::)

method:: pathSeparator
platform specific path separator

method:: pathDelimiter
platform specific path delimiter

method:: recordingsDir
platform recordings directory

method:: resourceDir
platform specific resource directory

method:: defaultTempDir
default directory for temporary files

method:: formatPathForCmdLine

argument:: path
A path string.

returns:: The input string formatted as a command-line argument. On Windows this
method quotes the string. On Unix-based systems this method escapes space
characters with a backslash.

subsection:: Startup files

method:: startupFiles
files to be loaded on startup

method:: loadStartupFiles
(re)load startup files

subsection:: System commands

method:: killAll
kill all processes as defined by cmdLineArgs.
argument:: cmdLineArgs
a string containing one or several process names.
code::
// e.g. kill all possibly running servers (scsynth or supernova)
thisProcess.platform.killAll("scsynth supernova");
::

method:: killProcessByID
kill a single process as identified by its process ID.
argument:: pid
an Integer which is the pid of the process to kill.
code::
// start a server program from the cmdLine for testing
~pid = unixCmd(Server.program + s.options.asOptionsString(57100));
// kill just that server program by its pid:
thisProcess.platform.killProcessByID(~pid);
::

subsection:: Features

Features are abstract symbols that can be declared by extension authors and be checked during runtime in user code. Apart from explicitly declared features, class and primitive names are implicitly declared.

method:: declareFeature
Declare aSymbol to be a feature present in the runtime. Class names and primitive names cannot be declared as features.

method:: hasFeature
Return true if the feature aSymbol is present in the runtime system. aSymbol can refer to explicitly declared features as well as class and primitive names.
code::
thisProcess.platform.hasFeature(\Object);
thisProcess.platform.hasFeature('_SCWindow_BeginFullScreen');
thisProcess.platform.hasFeature('_myFuncyPrimitive');

thisProcess.platform.declareFeature('superCrazyCompositionSystem');
thisProcess.platform.hasFeature('superCrazyCompositionSystem');
::

method:: when
Evaluate ifFunction if all features are present, otherwise evaluate elseFunction.
code::
thisProcess.platform.when(#[\Document, \SCWindow], { "yeehah!".postln });
::


class:: PlayBuf
summary:: Sample playback oscillator.
related:: Classes/RecordBuf, Classes/DiskIn, Classes/BufRd
categories::  UGens>Buffer


Description::
Plays back a sample resident in memory.

classmethods::

method::ar, kr

argument::numChannels
Number of channels that the buffer will be. This must be a fixed
integer. The architecture of the SynthDef cannot change after it
is compiled.

argument::bufnum
The index of the buffer to use.
note::
If you supply a bufnum of a buffer with a differing number of channels
than the one specified in this PlayBuf, it will post a warning and output the channels it can.
::

argument::rate
1.0 is the server's sample rate, 2.0 is one octave up, 0.5 is one
octave down -1.0 is backwards normal rate… etc. Interpolation
is cubic.


argument::trigger
A trigger causes a jump to the startPos. A trigger occurs when a
signal changes from negative value to positive value.

argument::startPos
Sample frame to start playback.

argument::loop
1 means true, 0 means false. This is modulateable.

argument:: doneAction
an integer representing an action to be executed when the buffer is finished playing. This can be used to free the enclosing synth, etc. See link::Classes/Done:: for more detail. code::doneAction:: is only evaluated if loop is 0.

Examples::

code::
s.boot // Boot the server, if you need to

// read a whole sound into memory
// note: not *that* columbia, the first one
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav"); // remember to free the buffer later.

SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), doneAction: Done.freeSelf)
	)
}).play(s, [\out, 0, \bufnum, b]);
::

In the above example, note how the code::doneAction: Done.freeSelf:: causes the synth to free itself when the buffer reaches its end.

Note again that the number of channels must be fixed for the SynthDef. It cannot vary depending on which buffer you use.

code::
// loop is true
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), loop: 1.0)
	)
}).play(s, [\out, 0, \bufnum, b]);


// trigger one shot on each pulse
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	var trig;
	trig = Impulse.kr(2.0);
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, 0, 0)
	)
}).play(s, [\out, 0, \bufnum, b]);


// trigger one shot on each pulse
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	var trig;
	trig = Impulse.kr(XLine.kr(0.1, 100, 30));
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, 5000, 0)
	)
}).play(s, [\out, 0, \bufnum, b]);


// mouse control of trigger rate and startpos
SynthDef(\help_PlayBuf, { arg out=0, bufnum=0;
	var trig;
	trig = Impulse.kr(MouseY.kr(0.5, 200, 1));
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, MouseX.kr(0, BufFrames.kr(bufnum)), 1)
	)
}).play(s, [\out, 0, \bufnum, b]);


// accelerating pitch
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	var rate;
	rate = XLine.kr(0.1, 100, 60);
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)*rate, 1.0, 0.0, 1.0)
	)
}).play(s, [\out, 0, \bufnum, b]);


// sine wave control of playback rate. negative rate plays backwards
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	var rate;
	rate = FSinOsc.kr(XLine.kr(0.2, 8, 30), 0, 3, 0.6);
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * rate, 1, 0, 1)
	)
}).play(s, [\out, 0, \bufnum, b]);


// zig zag around sound
SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	var rate;
	rate = LFNoise2.kr(XLine.kr(1, 20, 60), 2);
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * rate, 1, 0, 1)
	)
}).play(s, [\out, 0, \bufnum, b]);

b.free;
::



class:: Plazy
summary:: instantiate new patterns from a function
related:: Classes/PlazyEnvir, Classes/PlazyEnvirN, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Plazy evaluates a function that returns a pattern and embeds it in a stream.

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

Examples::

code::
(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 100].choose, 1);
	Pshuf(x,1);
});
x = Pn(a, inf).asStream;
30.do({ x.next.postln });
)


//Plazy used to produce a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 5].choose, 1);
	x.put(x.size.rand, 8+0.1.rand2);
	Pseq(x,1);
});
x = Pn(a, inf).asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, (x.next*5+70).midicps]);
		0.13.wait;
	})
}).play;
)


// using event streams

(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 5].choose, 1);
	x.put(x.size.rand, 8+0.1.rand2);
	Pbind(
		\instrument, \help_sinegrain,
		\dur, 0.12,
		\degree, Pseq(x, 2)
	)
});

Pn(a, inf).play;
)
::


class:: PlazyEnvir
summary:: instantiate new patterns from a function
related:: Classes/Plazy, Classes/PlazyEnvirN, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Evaluates a function that returns a pattern and embeds it in a stream. In difference to link::Classes/Plazy::, the function is evaluated using the environment passed in by the stream.

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

Examples::

code::
(
a = PlazyEnvir({ arg a=0, b=1; Pshuf([a, a, b], 2) }); // a, b default to 0,1
x = Pn(a, inf).asStream;

10.do { x.next.postln }; Post.nl;
e = (a:100);
10.do { x.next(e).postln }; Post.nl;
e = (a:100, b:200);
10.do { x.next(e).postln };
)


//PlazyEnvir used to produce a Pbind:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan=0;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

a = PlazyEnvir({ arg g=0, h=0, dur=1;
	postf("g: %, h: %, dur: %\n", g, h, dur);
	Pbind(
		\instrument, \help_sinegrain,
		\dur, dur,
		\degree, Pseq([g, g, h, g, h], 2)
	)
});
)

// different variants
(a <> (g: 0, h: 3, dur:0.2)).play; // single stream
(a <> (g: [0, 4], h: [3, -1], dur:0.2)).play; // same durations, two streams
::

For more about the composition operator code::<>:: see: link::Classes/Pchain::.

Some parameters, like duration, cannot be used in the form of an array in the link::Classes/Pbind::. For full parallel expansion see link::Classes/PlazyEnvirN::.


class:: PlazyEnvirN
summary:: instantiate new patterns from a function and multichannel expand them
related:: Classes/Plazy, Classes/PlazyEnvir, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Evaluates a function that returns a pattern and embeds it in a stream.
list::
## In difference to link::Classes/Plazy::, the function is evaluated using the environment passed in by the stream.
## In difference to link::Classes/PlazyEnvir::, PlayzEnvirN expands to strong::multiple parallel patterns:: if the function arguments receive multiple channels. This works only with event streams.
::

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

code::
(
f = { arg g=0, h=0, dur=1;
	Pbind(\degree, Pseq([g, g, h, g, h], 2), \dur, Pseries(dur, 0.1))
};
// compare:
a = Pchain(PlazyEnvirN(f), (g: [1, 2], h: 3, dur:0.2)).trace(\degree).asStream;
c = Pchain(Plazy(f), (g: [1, 2], h: 3, dur:0.2)).asStream;
)

a.nextN(4);
c.nextN(4); // no degrees, because stream ends
::


Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan=0;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

a = PlazyEnvirN({ arg g=0, h=0, dur=1;
	postf("g: %, h: %, dur: %\n", g, h, dur);

	Pbind(
		\instrument, \help_sinegrain,
		\dur, dur,
		\degree, Pseq([g, g, h, g, h], 2)
	)
});
)

// different variants
(a <> (g: 0, h: 3, dur:0.2)).play; // single stream
(a <> (g: [0, 4], h: [3, -1], dur:0.2)).play; // same durations, two streams
(a <> (g: [0, 4], h: [3, -1], dur: [0.2, 0.3])).play; // different durations, two streams
::

For more about the composition operator code::<>:: see: link::Classes/Pchain::.


TITLE:: Plet
summary:: Define a value within the scope (namespace) of a Plambda
categories:: Streams-Patterns-Events>Patterns>Data Sharing
related:: Classes/Plambda, Classes/Pget

DESCRIPTION::
link::Classes/Plet::/link::Classes/Pget:: are used to share data between patterns inside of a link::Classes/Plambda::

Plet defines a variable containing a pattern or data for sharing within the scope of a link::Classes/Plambda::. 

Using the link::Classes/Pget:: class, the contents of this variable can then be accessed by key in other patterns within the link::Classes/Plambda::.

CLASSMETHODS::

METHOD:: new

ARGUMENT:: key
The name of the variable

ARGUMENT:: pattern
The contents of the variable

ARGUMENT:: return
If return is nil, the pattern will be returned.
If not nil, the contents of the return argument will be returned while the variable defined by the Plet will be set to the value of pattern

INSTANCEMETHODS::

METHOD:: storeArgs

METHOD:: embedInStream

ARGUMENT:: inval

METHOD:: pattern

METHOD:: silent

METHOD:: key

METHOD:: return

EXAMPLES::

code::
(
	/*

	Two patterns playing in parallel, 
	sharing data between eachother

	*/

	// a melody playing random scale degrees
	a = Pbind(
		\dur, 0.125, 
		\octave, 4,
		\degree, Plet(\melody, pattern: Pwhite(0,7))
	);

	// the bass, scale degrees sampled from the \melody variable defined above 
	b = Pbind(
		\dur, 0.5, 
		\octave, 3,
		\degree, Pget(\melody, default: 1, repeats: inf).trace
	);

	// Play the patterns in parallel
	Plambda(
		Ppar([a, b], inf)
	).play;
)
::


class:: Plotter
summary:: Plot numerical data on a window or view
categories:: GUI>Accessories
related:: Reference/plot


description::
Plot data of up to three dimensions on a link::Classes/Window:: or link::Classes/UserView::.


subsection:: Keyboard shortcuts

When the plotter window has focus, the following keyboard shortcuts can be used to change the display:
table::
## + / - || vertical zoom
## = || compare plot channels
## n || toggle normalize display (0..1) / (-1..1), or fit range
## s || toggle superposition (see: superpose)
## m || switch plot mode (see: link::Classes/Plotter#-plotMode::)
## e || toggle editing (see: link::Classes/Plotter#-editMode::)
## g || toggle horizontal (domain) grid
## G || toggle vertical (codomain) grid
## p || print curve
## ctrl-+ / - || zoom font
## alt-click || post value
::


subsection:: Method extensions
Plotter extends other classes with methods. To see what classes implements plot, see link::Overviews/Methods#plot::


method:: plot (args)

code::
// plot array
[1, 6, 2, -5, 2].plot;
(0..100).normalize(0, 8pi).sin.plot;

// nested arrays
{ (0..100).normalize(0, 15.0.rand).sin }.dup(3).plot;
{ { (0..17).normalize(0, 15.0.rand).sin }.dup(4) }.dup(3).plot;

// UGen functions
{ SinOsc.ar([700, 357]) * SinOsc.ar([400, 476]) * 0.2 }.plot;

// Buffer
{ var b = Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff"); s.sync; b.plot }.fork(AppClock);

// Env
Env.perc(0.4, 0.6).plot;
::


method:: plotGraph (n,from,to,...)

code::
{ |x| sin(x) }.plotGraph(300, 0, 2*pi);
{ |x| sin(1/x) * x }.plotGraph(from: 0.0001, to: 0.2);
::


classmethods::

method:: new
argument:: name
Plot window title.
argument:: bounds
The window bounds (a link::Classes/Rect::).
argument:: parent
Either a link::Classes/Window:: / link::Classes/View:: may be passed in - then the plot is embedded. Otherwise a new link::Classes/Window:: is created.
discussion::
code::
(
a = Plotter("the plot", Rect(600, 30, 800, 250));
a.value = (0..1000).normalize(0, 14pi).curdle(0.01).scramble.flat.sin;
)
::


instancemethods::


subsection:: Embedding in another view


method:: makeWindow
Open given plotter in a new window or within a given composite view.

See the link::#Embedding in another View or GUI:: example.

argument:: argParent
Either a link::Classes/Window:: or link::Classes/View:: may be passed in - then the plot is embedded. Otherwise a new link::Classes/Window:: is created.

argument:: argBounds
The window bounds (a link::Classes/Rect::).


subsection:: Plot properties


method:: plotMode
Get/Set the style of data display. This can be an array of different modes for
multi-channel data.
Available modes:
table::
## code::\linear:: || connecting data points with linear interpolation
## code::\points:: || draw data points only
## code::\plines:: || combination of lines and points
## code::\levels:: || horizontal lines
## code::\steps:: || connecting data points with step interpolation
## code::\bars:: || bar graph with filled bars
::

argument:: modes
A link::Classes/Symbol:: or an link::Classes/Array:: of link::Classes/Symbol::s.

If code::modes.size < numChannels::, the plots will emphasis::wrap:: around the
array of modes.

returns::
An link::Classes/Array:: of link::Classes/Symbol::s,
unless there is only one mode specified or if all modes of a multi-channel plot
are the same, in which case a single link::Classes/Symbol:: is returned.

discussion::
code::
a = (0..20).scramble.plot;
a.plotMode = \points; a.refresh;
a.plotMode = \plines; a.refresh;
a.plotMode = \levels; a.refresh;
a.plotMode = \steps; a.refresh;
a.plotMode = \linear; a.refresh;
a.plotMode = \bars; a.refresh;

/* mixed modes */
(
d = 4.collect({ |i| 100.collect({ |j| sinPi(1+i.squared*j * 50.reciprocal) })});
p = d.plot;
p.plotColor_([Color.red, Color.cyan, Color.green, Color.blue]);
p.plotMode_([\steps, \linear, \plines, \points]);
// superpose will trigger a refresh to update colors/modes
p.superpose_(true);
)
::


method:: plotColor
Set or get the colors of your data plot.

argument:: colors
This can be an link::Classes/Array:: of link::Classes/Color::s for
multichannel data, or a single link::Classes/Color:: to map to all channels.

If code::colors.size < numChannels::, the plots will emphasis::wrap:: around the
array of colors.
returns::
An link::Classes/Array:: of link::Classes/Color::s, unless there is only one
color specified or if all colors of a multi-channel plot are the same, in which
case a link::Classes/Color:: is returned.


method:: superpose
If code::true::, plotter displays channels overlaid on a single plot. (keyboard shortcut: s)
code::
a = { (0..30).scramble }.dup(2).plot;
a.superpose = true; a.refresh;
::


method:: axisLabelX
Get/set the label for the x-axes. Can be a link::Classes/String:: or an link::Classes/Array:: of
link::Classes/String::s, or code::nil:: to remove the label.
See link::#Axis labels:: example below.


method:: axisLabelY
Get/set the label for the y-axes. Can be a link::Classes/String:: or an link::Classes/Array:: of
link::Classes/String::s, or code::nil:: to remove the label.
See link::#Axis labels:: example below.


method:: showUnits
Get/set whether the corresponding link::Classes/ControlSpec#-units:: are displayed as labels. The state of link::#-unitLocation:: determines whether the units are shown as axis labels or appended to the tick labels.

argument:: bool
A code::Boolean::.

discussion::
When enabling code::showUnits::, axis or tick labels will only be updated to show the units when the code::axisLabelX/Y:: or grid code::labelAppendString:: properties are code::nil::, empty, or were previously set to show the spec units — i.e. code::showUnits:: won't overwrite a label that has been explicitly set.

See link::#Unit labels:: example below.


method:: unitLocation
Get/set the label type on which the code::Spec:: link::Classes/ControlSpec#-units:: are shown.

See the Discussion in link::#-showUnits:: about the interraction with pre-existing labels at the strong::location::, and link::#Unit labels:: example below.

argument:: location
A code::Symbol::, code::\axis:: or code::\ticks::, to show the units as the axis label or appended to each of the tick labels, respectively.


method:: setProperties
Set properties of all plot views. Defaults are taken from code::GUI.skins.at(\plot);::

warning:: It's preferrable to use Plotter's instance methods when possible
to set Plot properties to ensure proper behavior when using link::#-superpose::.
::

argument:: ... pairs
A list of symbol,value pairs. Supported properties:
list::
## font
## fontColor
## gridColorX
## gridColorY
## plotColor (an link::Classes/Array::)
## backgroundColor
## gridLinePattern
## gridLineSmoothing ( link::Classes/Boolean:: )
## labelX
## labelY
## gridOnX ( link::Classes/Boolean:: )
## gridOnY ( link::Classes/Boolean:: )
::

discussion::
Example:
code::
(
a = { (0..30).scramble }.dup(2).plot;
a.setProperties(
  \fontColor, Color.yellow,
  \plotColor, Color.magenta,
  \backgroundColor, Color.black,
  \gridColorX, Color.green,
  \gridColorY, Color.green,
  \labelX, "Frames",
  \labelFontColor, Color.magenta
);
a.refresh;
);

GUI.skins.at(\plot); // defaults
::


method:: plots

returns:: An link::Classes/Array:: of link::Classes/Plot::s.


subsection:: Grid properties

method:: setGridProperties
Set one or more properties of the code::DrawGridX:: or code::DrawGridY:: used by all code::Plots::.

argument:: axis
A code::Symbol:: denoting the axis whose grid you're modifying: code::\x:: or code::\y::.

argument:: ... propertyPairs
Key value pairs, listed as successive arguments, of the properties to change and their new values. The property key is a code::Symbol::.

Any of setters of code::DrawGridX:: or code::DrawGridY:: can be used. Here is a subset of useful properties:
table::
## code::\labelAnchor:: || A code::Symbol:: denoting the point on the label's bounding link::Classes/Rect:: that anchors to the point where the grid line meets the base of the axis. code::\center, \top, \bottom, \left, \right, \topLeft, \topRight, \bottomLeft, \bottomRight, \leftTop, \rightTop, \leftBottom, \rightBottom::.
## code::\labelOffset:: || A link::Classes/Point:: describing the offset of the code::\labelAnchor:: from the point where the grid line meets the base of the axis. The positive direction for the teletype::x:: and teletype::y:: dimensions is right and down, respectively.
## code::\labelAlign:: || Alignment of the text within its bounding code::Rect::: code::\left::, code::\center::, or code::\right::.
## code::\constrainLabelExtents:: || A code::Boolean:: specifying whether the tick labels at either end of the axis are constrained by, or can extend beyond, the grid bounds.
## code::\drawBaseLine:: || A code::Boolean:: whether a line is drawn at the minimum extent of this strong::axis::.
## code::\drawBoundingLines:: || A code::Boolean:: whether a line is drawn at both ends of the extent of this strong::axis::.
## code::\drawBoundingRect:: || A code::Boolean:: whether a code::Rect:: is drawn around the bounds of the grid area.
## code::\labelAppendString:: || A string to append to all of the axis's tick labels.
## code::\tickSpacing:: || Set the emphasis::minimum:: spacing between grid lines ("ticks") for each axis. See link::Classes/DrawGrid#-tickSpacing:: for details.
## code::\numTicks:: || Set the emphasis::approximate:: number of grid lines ("ticks") for each axis. See link::Classes/DrawGrid#-numTicks:: for details.
## code::\font:: || A link::Classes/Font:: (including size) to be used for the tick labels.
## code::\fontColor:: || The link::Classes/Color:: of the tick labels.
## code::\gridColor:: || The link::Classes/Color:: of the axis grid lines.
::

The properties code::\drawBaseLine::,  code::\drawBoundingLines::, or code::\drawBoundingRect:: are mutually exlusive — setting any of them to true will set the others two to code::false::. In the context of code::Plotter::, setting code::\drawBoundingRect:: on one axis to code::true:: has the same appearance of setting code::\drawBoundingLines:: on emphasis::both:: axes to code::true::.

discussion::
This is a convenience method to set the grid properties for emphasis::all:: code::Plot::s to the same values.
An Example:
code::
(
var plotter = [10, 34, 167].collect({ |freq|
	101.collect{|i| sin((i/1000) * 2pi * freq)}
}).plot;
plotter.setGridProperties(\x,
	\labelAnchor, \topLeft,
	\labelAlign, \left,
	\labelOffset, 1 @ 5,
	\labelAppendString, " samp"
).setGridProperties(\y,
	\labelAnchor, \right,
	\labelAlign, \right,
	\labelOffset, -5 @ 0,
	\constrainLabelExtents, false
)
)
::

To set the properties of grids on each code::Plot:: separately, iterate over the plots:
code::
(
var plotter, labelAnchors;
plotter = [10, 34, 167].collect({ |freq|
	101.collect{|i| sin((i/1000) * 2pi * freq)}
}).plot;

labelAnchors = [\topLeft, \top, \bottomLeft];

plotter.plots.do{ |plot, i|
	plot.drawGrid.x
	.labelAnchor_(labelAnchors[i])
	.constrainLabelExtents_(true);
};
plotter.updatePlotBounds;
)
::


method:: getGridProperty
Get the value of a grid property. See link::#-setGridProperties:: for a list of available properties.

argument:: axis
A code::Symbol:: denoting the axis whose grid you're modifying: code::\x:: or code::\y::.

argument:: property
The property name as a code::Symbol::.

discussion::
As a convenience method, code::getGridProperty:: assumes that properties across all code::Plot::s are the same (as would be the case if set by link::#-setGridProperties::) so returns a single value. Alternatively, properties from individual plot grids can be collected by iterating over the plots:
code::
( // inspect the \labelAnchor of each DrawGridX
var plotter  = [10, 34, 167].collect({ |freq|
	101.collect{|i| sin((i/1000) * 2pi * freq)}
}).plot;

plotter.plots.collect({ |plot|
	plot.drawGrid.x.labelAnchor
}).postln;
)
::


method:: drawGridBoundingRect
Set whether a link::Classes/Rect:: is drawn around the boundary of the grid. Setting to code::false:: disables any bounding grid lines (including "base" lines).

argument:: bool
A code::Boolean::.

discussion::
In some cases, the link::Classes/GridLines:: of the grid will not fall on the minimum or maximum of it's spec's range. Using link::#-drawGridBaseLines:: or link::#-drawGridBoundingRect:: will give the appearance of grid lines at the lower end ("base") of the grid, or at both ends of the grid, respectively.


method:: drawGridBaseLines
Set whether a line is drawn at the lower extent of the grid axes. Setting to code::false:: disables any bounding grid lines (including a bounding code::Rect::). See also the Discussion in link::#-drawGridBoundingRect::.

argument:: bool
A code::Boolean::.


subsection:: Data display properties


method:: specs
Set or get the link::Classes/ControlSpec##spec:: for the y-axis (codomain).

code::
a = { (40..3000).scramble }.dup(2).plot;
a.specs = \freq.asSpec;
::
See also the link::#Explicit domain and axis specs:: example below.


method:: domainSpecs
Set or get the link::Classes/ControlSpec##spec:: for the x-axis (domain).

code::
a = { (40..300).scramble }.dup(2).plot;
a.domainSpecs = \freq.asSpec;
::
See also the link::#Explicit domain and axis specs:: example below.

discussion::
When setting your code::Plotter:: link::#-value::, the default strong::domainSpecs:: is a linear spec in the range code::[0, value.size-1]:: (i.e. the indices of the values). Therefore, your values are displayed as evenly sampled between the code::minval:: and code::maxval::, unless you have explicitly set the link::#-domain:: values.

If a new link::#-value:: is set, you will need to update your domainSpecs.


method:: domain
Set/get the x-axis positions of your data points. The size of the code::domainArray:: must equal the size of your link::#-value:: array, i.e. a domain value specified for each data point.

code::
(
var data, domain, plot;
domain = 25.collect({rrand(0, 50)}).sort;
data = domain.linlin(0, 50, 0, 1);

plot = data.plot.plotMode_(\points);
plot.domainSpecs_([0, 50].asSpec);
plot.domain_(domain);
)
::
See also the link::#Explicit domain and axis specs:: example below.

discussion::
Domain values are mapped into the range of the link::#-domainSpecs::, so need
not be evenly distributed. If link::#-domain:: is set to code::nil::, your
values are displayed as evenly sampled between the code::minval:: and
code::maxval:: of the link::#-domainSpecs::.

Currently, for multichannel data plots, it's assumed that all channels of data
share a single link::#-domain::. I.e. code::domainArray:: must be an
link::Classes/Array:: of rank 1.

If a new link::#-value:: is set, you will need to update your link::#-domain::.


method:: resolution
Set the minimum number of pixels between data points (default: 1)
code::
// Changing plot resolution (x-axis)
p = 5000.collect({ |i| sinPi(i * 0.0025) }).plot;
p.resolution_(5).refresh;  // 5px
p.resolution_(10).refresh;
p.resolution_(50).refresh; // undersampled
p.resolution_(1).refresh;  // default
::


subsection:: Plot data


method:: value
Return or set the data values. Data may be numerical arrays of up to 3 dimensions.
code::
a = [1, 4, 2, 7, 4].dup(2).plot;
a.value;
::


method::setValue
Set the data values, with additional arguments determining how the plot is updated.

argument:: arrays
Arrays of data to plot. Data may be numerical arrays of up to 3 dimensions.

argument:: findSpecs
A code::Boolean::. If code::true:: (default), bounds of the plot(s) are determined automatically.
If code::false::, previous bounds will persist.

argument:: refresh
A code::Boolean::. If code::true:: (default), refresh the view immediately.

argument:: separately
A code::Boolean::. If code::true:: (default), min and max of each set of data will be calculated
and displayed separately for each plot. If code::false::, each plot's range on the
y-axis will be the same.

argument::minval
(Optional) The minimum value displayed on the y-axis.

argument::maxval
(Optional) The maximum value displayed on the y-axis.

argument:: defaultRange
(Optional) A default range for the y-axis in the case
that the max and min values of the data are identical.


method:: findSpecs
If code::true::, specs are derived from new data (using min and max values) automatically. Default: code::true::.


method:: data
Reference to the current internal data (with shape up to depth of 3).


subsection:: Edit mode


method:: editMode
If the edit mode is set to true, the data may be edited via cursor.
code::
a = (0..20).plot;
a.editMode = true; // now edit the data by clicking into the plot..
a.value; // the updated values
::


method:: editFunc
Supply a function which is evaluated when editing data. The function is called with the arguments: code::plotter::, code::plotIndex::, code::index::, code::val::, code::x::, code::y::.

discussion::
Example:
code::
(
a = { (0..10).scramble.normalize }.dup(2).plot;
a.editMode = true;
a.editFunc = { |...args| args.postln };
)

// using plotter as a control interface
(
a = { (0..10).scramble.normalize(300, 400) }.dup.plot;
a.specs = \freq; a.plotMode = \bars;
a.editMode = true;
x = {
	var phase = SinOsc.ar(\rate.kr(a.value[1]));
	SinOsc.ar(\freq.kr(a.value[0]), phase).mean * 0.1
}.play;
a.editFunc = { |plotter, plotIndex, i, val|
	x.setn(\freq, a.value[0]);
	x.setn(\rate, a.value[1]);
};
a.parent.onClose = { x.release };
)
::


method:: cursorPos

returns:: The last cursorPos (a link::Classes/Point::).


private:: plotColors, prReshape, pointIsInWhichPlot, prSetUpInteractionView


examples::

code::
(
a = Plotter("the plot", Rect(600, 30, 600, 400));
a.value = (0..100).normalize(0, 8pi).sin;
)

a.value = { |i| (0..90) % (i + 12) + ( (0..90) % (i + 2 * 1) ) }.dup(3);
a.value = (0..12).squared;
a.plotMode = \points; a.refresh;
a.plotMode = \levels; a.refresh;
a.plotMode = \plines; a.refresh;

a.domainSpecs = [[0, 115, \lin, 1]]; a.refresh;

a.parent.close; // close window
a.makeWindow; a.updatePlotBounds; // open it again

a.value = { (0..70).scramble }.dup(3);
a.plotMode = \linear; a.refresh;
a.value = { |i| (0..2000).normalize(0, 4pi + i).sin } ! 4; // lots of values, test efficiency
a.value = { |i| (0..10000).normalize(0, 8pi + i).sin } ! 3; // lots of values, test efficiency
a.value = { (0..140).scramble } ! 7;

a.value = { |i| (0..90).normalize(0, 8pi + (i*2pi)).sin } ! 2 * [400, 560] + 700;
a.value = { |i| (_ + 2.0.rand).dup(100).normalize(0, 8pi + i).sin } ! 2 * 400 + 700;


// Multi channel expansion of single values
a.value = { |i| (_ + 2.0.rand).dup(100).normalize(0, 8pi + i).sin *.t [1, 2, 3] } ! 2 * 400 + 700;
a.value = { |i| (0..10) **.t [1, 1.2, 1.3, 1.5] * (3.5 ** i) }.dup(3);

a.parent.bounds = Rect(400, 100, 500, 700);
a.parent.bounds = Rect(600, 30, 500, 300);

a.superpose = true;
a.value = { |i| (0..20) * (3.5 ** i) }.dup(5);
a.superpose = false;
::

subsection:: Object .plot methods

code::

// Array:plot
(
a = (4 ** (-5..0)).postln.plot;
a.specs = \delay; a.refresh;
a.domainSpecs = [0, 10, \lin, 0, 0, " Kg"].asSpec; a.refresh;
);

a.domainSpecs = [0.1, 10, \exponential, 0, 0, " Kg"].asSpec; a.refresh;
a.domainSpecs = [-10, 10, \lin, 0, 0, " Kg"].asSpec; a.refresh;

a = [(0..100) * 9, (200..1300) * 2, (200..1000)/ 5].plot;
a.superpose = true;

a = [[0, 1.2, 1.5], [0, 1.3, 1.5, 1.6], [0, 1.5, 1.8, 2, 6]].midiratio.plot;
a.plotMode = \levels; a.refresh;
a.superpose = false;

// Function:plot
a = { SinOsc.ar([700, 357]) * SinOsc.ar([400, 476]) * 0.2 }.plot;
a = { SinOsc.ar([700, 357] *0.02) * SinOsc.ar([400, 476]) * 0.3 }.plot(0.2, minval: -1);

// Env:plot
Env.perc(0.4, 0.6).plot;
Env.new({ 1.0.rand2 }! 8, { 1.0.rand } ! 7, \sin).plot;

// Buffer:plot
(
s.waitForBoot({
	var b = Buffer.read(s,
		Platform.resourceDir +/+ "sounds/SinedPink.aiff"
	);
	s.sync;
	b.plot;
	b.free;
});
)
::


subsection:: Explicit domain and axis specs
code::
// data
a = (50..90).midicps.scramble.plot;
// specs (y-axis)
a.specs = ControlSpec(100, 2000, units: "Hz"); a.refresh;

a.value = 50.collect{ exprand(1e4, 1e7) };
a.specs = [1e4, 1e7, \exp].asSpec; a.refresh;

// domainSpecs (x-axis)
// If domain is unassigned, values are
// distributed evenly within the spec range
a.domainSpecs = [-10, 70].asSpec; a.refresh;


// Setting the domain, run the full block:
(
var ys, xs; // ys: data, xs: domain positions
var rs = 0, plt2;

// xs are the sample points over a 2pi range

// sample locations, normalized
xs = 50.collect({rrand(0.05, 1)}).normalizeSum;
xs.do{ |me, i| xs[i] = me + rs; rs = rs + me; };

// force beginning/end to land on 0/2pi
xs[0] = 0;
xs[xs.size-1] = 1;

// scale these points to a 2pi range
xs = xs * 2pi;

// ys are the values of the sinusoid at the sampled points
ys = sin(xs);

// the uneven sampling is apparent when
// displayed as uniformly sampled
ys.plot("original data plot, uniform domain", [100, 100, 385, 285].asRect);

// generate a second plot whose domainSpec is specified:
// we see a smooth sinusoid cycle beginning
// at 0 and ending at 2pi
plt2 = ys.plot("resampled domain", [100+400, 100, 385, 285].asRect);

// domain values place plotted points where they
// actually sampled the sinusoid, thus visually
// reconstructing it.
plt2.domain = xs;

// these values are placed within the domainSpec
// so we can pad the plot on either side.
plt2.domainSpecs_(([-0.5pi, 2.5pi]).asSpec);
)

// Non-linear scaling of axes.
// plot 1000 values, linearly distributed on X and Y
p = (1, 2 .. 1000).plot.domainSpecs_([1, 1000, \lin].asSpec).refresh;
// scale y axis exponentially
p.specs_([[1, 1000, \exp].asSpec]).refresh;
// then scale x axis exponentially
p.domainSpecs_([1, 1000, \exp].asSpec).refresh;
::


subsection:: Axis labels

code::
(
p = 4.collect({
	100.collect({ rrand(0,1.0) })
}).plot(bounds: Rect(50,50,500,650));
p.plotColor_([Color.red, Color.blue, Color.green, Color.cyan]);
)

// a single label propagates through all Plots
p.axisLabelX_("one");
// set each individually
p.axisLabelX_(["one", "two", "three", "four"]);
// superposed plots default to the first label
p.superpose_(true);
p.superpose_(false); // labels are restored
// nil element removes a label
p.axisLabelX_(["one", "two", nil, "four"]);
// assigning nil removes all labels
p.axisLabelX_(nil);
// ... axisLabelY behaves the same way
::

subsection:: Unit labels
The units of the grid specs are shown as labels, either axis labels or appended to tick labels. Unit labels won't overwrite preexisting labels, and can be disabled altogether.
code::
( // units displayed in the axis labels by default
p = (4 ** (-1.5, -1.25 .. 0)).plot;
p.specs = \delay.asSpec.minval_(0.1);
p.domainSpecs = [0, 10, \lin, 0, 0, "xUnits"].asSpec;
p.setGridProperties(\y, \constrainLabelExtents, false);
p.setGridProperties(\x, \constrainLabelExtents, true);
)

p.showUnits = false;      // hide units
p.unitLocation = \ticks;  // move units to tick labels
p.showUnits = true;       // show units
p.axisLabelX = "X LABEL"; // set an axis label
p.unitLocation = \axis;   // move units to axes
// ... x-axis label isn't overwritten
p.axisLabelX = nil        // remove x-axis label
p.unitLocation = \axis;   // set units to axes again
// ... units now appear on the x-axis

// customize the Y labels
p.setGridProperties(\y, \labelAppendString, " y");
// move units to tick labels
p.unitLocation = \ticks;
// ... y-axis tick labels aren't overwritten
// now remove y-tick label string
p.setGridProperties(\y, \labelAppendString, nil);
// set units to tick labels again
p.unitLocation = \ticks;
// ... units now appear on the y-tick labels
::

subsection:: Embedding in another View or GUI

code::
(
var w, z, p, d, func;
w = Window("plot panel", Rect(20, 30, 520, 450));
z = CompositeView(
    w, Rect(10, 35, 490, 400)
).background_(Color.rand(0.7)).resize_(5);
p = Plotter("plot", parent: z);
d = Array.rand(32, 0, 20);
func = { |v|
	var offset = v.value.linlin(0, 1, 0, d.size.neg).asInteger;
    p.value = d.rotate(offset).keep(8);
    w.refresh;
};
Slider.new(w, Rect(10, 10, 490, 20)).resize_(2).action_({ |v| func.(v.value) });
func.value(0);
w.front;
)
::


subsection:: Changing global defaults

The default styles are kept (and may be overridden) in code::GUI.skins.at(\plot)::. See also link::Classes/GUI:: help.

code::
// specify plot layout
(
GUI.skins.plot.gridLinePattern = FloatArray[1, 0];
GUI.skins.plot.fontColor = Color(0.5, 1, 0);
GUI.skins.plot.gridColorX = Color.yellow(0.5);
GUI.skins.plot.gridColorY = Color.yellow(0.5);
GUI.skins.plot.background = Color.black;
GUI.skins.plot.plotColor = Color.red;
GUI.skins.plot.labelX = "X";
GUI.skins.plot.labelY = "Y";
)

(
x = { |i| (0..60).scramble * (3.5 ** i) }.dup(3);
x.plot("ARRAY:PLOT", Rect(200, 300, 600, 500));
)

GUI.skins.plot.put(\plotColor, { Color.rand(0.0, 0.8) } ! 8);
[(0..100), (20..120), (40..140)].squared.flop.bubble.plot;

// reset the defaults:
Plot.initClass;
::


class:: Plprand
summary:: random values that tend toward lo
related:: Classes/Phprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Plprand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Plprand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Plprand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, min(rrand(0.0, 1.0), rrand(0.0, 1.0)) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pluck
summary:: A Karplus-Strong UGen
categories:: UGens>Delays

description::
A Karplus-Strong UGen

classmethods::
method:: ar

argument:: in
an excitation signal.
argument:: trig
upon a negative to positive transition, emphasis::n:: samples of the excitation signal will be fed into the delay line, where emphasis::n = delaytime * sample_rate / 2::, using a rectangular envelope (no fading).
argument:: maxdelaytime
the max delay time in seconds (initializes the internal delay buffer).
argument:: delaytime
delay time in seconds.
argument:: decaytime
time for the echoes to decay by 60 decibels. Negative times emphasize odd partials.
argument:: coef
the coef of the internal OnePole filter. Values should be between -1 and +1 (larger values will be unstable... so be careful!).
argument:: mul
argument:: add

examples::
code::
s.boot;

// excitation signal is WhiteNoise, triggered twice a second with varying OnePole coef
(
	{Pluck.ar(WhiteNoise.ar(0.1), Impulse.kr(2), 440.reciprocal, 440.reciprocal, 10,
		coef:MouseX.kr(-0.999, 0.999))
	}.play(s)
)
s.quit;
// a group of angry fretless mandolin players
(
	{
		var freq, numparts;
		numparts = 50;
		freq = SinOsc.kr(Array.fill(numparts, {Rand(0.05, 0.2)}),
			Array.fill(numparts, {Rand(0, 1.0)})).range(1000, 3000);
		LeakDC.ar(
			Pan2.ar(
				Pluck.ar(
					WhiteNoise.ar(0.1).dup(numparts),
					Impulse.kr(Array.fill(numparts, {Rand(10, 12)})),
					100.reciprocal, freq.reciprocal, 2, Rand(0.01, 0.2), mul: 1),
				Array.fill(numparts, {Rand.new(-1.0, 1.0)}))
			.sum
			);
		}.play(s);
)
::


class:: Pmeanrand
summary:: random values that tend toward ((lo + hi) / 2)
related:: Classes/Plprand, Classes/Phprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Pmeanrand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pmeanrand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pmeanrand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, (rrand(0.0, 1.0) + rrand(0.0, 1.0) * 0.5) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pmono
summary:: monophonic event stream
related:: Classes/Pbind, Classes/PmonoArtic
categories:: Streams-Patterns-Events>Patterns>Event

description::

Plays one instance of a link::Classes/Synth::. The pattern pairs define changes in that one synth's controls. This node is created when entering a Pmono, and released when the Pmono terminates. There is just one node for the duration of the entire pattern, and it will sustain through each event. If a monophonic phrase requires staccato notes or re-articulation between some notes, see link::Classes/PmonoArtic::.

If event[\id] is not nil, Pmono simply directs its pattern changes to that node and does not create an extra synth.

Examples::

code::
p = Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100 ).play

p.stop

// multi channel expansion is supported:
p = Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100, \detune, [0,2,5,1]).play

p.stop


// the following example will end after 5 seconds
// or you can stop it sooner with a stop message
(
p = Pfindur(5,
	Pset(\detune,Pwhite(0,1.0) * [0,1,3,7],
		Ppar([
			Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100 ),
			Pmono(\default, \dur, 0.1, \freq, Pwhite(1,8) * 300)
		])
	)
).play;
)
p.stop;
::

subsection::A related approach

A related approach is to instantiate a Synth yourself and then set its values by using an link::Classes/Event:: whose "type" is code::\set::, as illustrated here. The user is responsible for ensuring proper synchronization between link::Classes/Synth:: creation and pattern execution.

code::
// First we create something to control
x = {|freq=440, amp=0.6| MoogFF.ar(PinkNoise.ar(amp), freq).dup}.play;

// In the following pattern, the first two keys are the ones that create the monophonic behaviour:
(
p = Pbind(
	\type, \set,	// This tells it we'll be setting parameters of an existing node...
	\id, x.nodeID,	// ...this tells it whose parameters we'll be setting
	\args, #[\freq, \amp],  // and this tells it which parameters to set
	\freq, Pwhite(100, 1000),
	\dur, 0.2,
	\amp, Pseq((1,0.99 .. 0.1), inf)
).play;
)

p.stop
x.free
::

For more details on the code::\set:: event type, see its description in Chapter 8, link::Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters##Event Types and Parameters:: of the Practical Guide To Patterns.

subsection::SynthDef variant support

SynthDefs allow alternate sets of default values to be defined (see "Variants" in link::Classes/SynthDef:: help). Most event patterns, such as Pbind, specify the variant using the variant key in the output events. (Note that variants are always optional.) In Pmono, the mechanism is different because the SynthDef name, including variant suffix, must be known before evaluating the first event. So, the variant suffix is provided in the first Pmono argument:

code::
Pmono('synthDefName.variant', pairs...)
::


class:: PmonoArtic
summary:: partly monophonic event stream
related:: Classes/Pbind, Classes/Pmono
categories:: Streams-Patterns-Events>Patterns>Event

description::

Like link::Classes/Pmono::, PmonoArtic plays one synth at a time (where successive events change the parameters of the existing synth node). PmonoArtic, however, allows events to re-articulate and supports staccato in the middle of a monophonic phrase.

If an event specifies a 'sustain' value shorter than the event delta, it means the synth should not sustain all the way through to the next event. In that case, the node will be released according to 'sustain' and the next event will start a new synth.

If sustain >= delta, the synth will play through and its parameters will change (just like link::Classes/Pmono::).

Since sustain is calculated as code::~dur * ~legato::, this means code::~legato < 1.0:: causes re-articulation while code::~legato >= 1.0:: causes a slur.

Examples::

code::
// This SynthDef has a harder attack than the default, illustrating rearticulation more clearly.
(
SynthDef(\sawpulse, { |out, freq = 440, gate = 0.5, plfofreq = 6, mw = 0, ffreq = 2000, rq = 0.3, freqlag = 0.05, amp = 1|
	var sig, plfo, fcurve;
	plfo = SinOsc.kr(plfofreq, mul:mw, add:1);
	freq = Lag.kr(freq, freqlag) * plfo;
	fcurve = EnvGen.kr(Env.adsr(0, 0.3, 0.1, 20), gate);
	fcurve = (fcurve - 1).madd(0.7, 1) * ffreq;
	sig = Mix.ar([Pulse.ar(freq, 0.9), Saw.ar(freq*1.007)]);
	sig = RLPF.ar(sig, fcurve, rq)
		* EnvGen.kr(Env.adsr(0.04, 0.2, 0.6, 0.1), gate, doneAction: Done.freeSelf)
		* amp;
	Out.ar(out, sig ! 2)
}).add;
)

p = PmonoArtic(\sawpulse, \dur, 0.2, \freq, Pwhite(1,8) * 100, \legato, Pwrand(#[0.5, 1.0], #[0.1, 0.9], inf) ).play;

p.stop;
::


class:: Pmul
summary:: multiply with value of a key in event stream
related:: Classes/Padd, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::name
the key

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern

Examples::

code::
(
var a, b;
a = Pmul(\freq, 801, Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
(
var a, b;
a = Pmul(\freq, Pseq([3, 4, 6], 2), Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, gate=1;
		var env;
		env = EnvGen.kr(Env.asr(0.001, 1, 0.2), gate, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \freq, 440);
b = Pmul(\freq, Pseq([1, 2, 3, 4, 5, 6, 7], inf), a);
b.play;
)
::


class:: Pmulp
summary:: multiply with each value of a pattern to value of a key in event stream
related:: Classes/Pmul, Classes/Paddp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Adds a value to a named value in an event pattern or stream until it ends. Repeats this with new values until the value stream ends.

ClassMethods::

method::new
argument::name
the named value in the event pattern or stream to multiply.
argument::value
The value, pattern, stream or array to multiply with. The resulting stream ends when this incoming stream ends.
argument::pattern
The event pattern or stream within which to multiply the new values.

Examples::

code::
(
var a, b;
a = Pmulp(\freq, Pseq([2, 3, pi],inf), Pbind(\freq, Pseq([100, 200, 300])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\freq, Pseq([500, 600, 700]), \instrument, \sinegrain);
a = Pmulp(\freq, Pseq([0.5, 0.9, 0.8], inf), a);
a.play;
)
::


class:: Pmulpre
summary:: multiplies with value of a key in event stream, before it is passed up
related:: Classes/Pmul, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Multiplies with a value in an event, strong::before it is passed up:: the stream. To multiply with the value after it has been passed down, use link::Classes/Pmul::.

code::
(
var a, b;
a = Pmulpre(\note, 2, Pbind(\note, Pseq([1, 2, 3])));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

Pmulpre does not override incoming values:
code::
(
var a, b;
a = Pmulpre(\freq, 801, Pset(\freq, 500, Pbind(\dur, 0.2)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

ClassMethods::

method::new

argument::name

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern

Examples::

code::
(
var a, b;
a = Pmulpre(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
b = Pmulpre(\freq, Pseq([1, 2, 3], inf), a);
b.play;
)
::


class:: Pn
summary:: repeatedly embed a pattern
related:: Classes/Pdup
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new

argument::pattern
the pattern to repeat

argument::repeats
Repeats the enclosed pattern strong::repeats:: times.

argument::key
If strong::key:: is non-nil, it sets the value of that key to true whenever it restarts the pattern. This can be used to advance Patterns enclosed by link::Classes/Pgate::.

Examples::

code::
(
var a, b;
a = Pn(Pseq(#[1, 2, 3], 1), 4);	// repeat pattern four times
b = a.asStream;
16.do({ b.next.postln; });
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Pshuf([1, 2, 2, 3, 3, 3], 4)).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.2.wait;
	}
}.fork;
)
::


class:: Pnaryop
summary:: n-ary operator pattern
related:: Classes/Pbinop, Classes/Punop, Classes/NAryOpFunction
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the n-ary operator to the stream values of the receiver, taking n-1 streams as arguments. Usually, this is the result of applying an n-ary operator (i.e. a method with more than one argument) to a pattern.

Examples of n-ary operators are: blend, linlin, linexp, explin, expexp, clip, fold, wrap.

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

argument::arglist
a list of patterns (or compatible pattern inputs)

Examples::

code::
(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]);
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).wrap(3, 7);
a.asStream.all;
)

// the scale argument can also be a pattern:

(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [Pseq([3, 4, 5], inf), Pseq([9, 7], inf)]);
a.asStream.all;
)


// common cases:
Pwhite(0, 1, inf).linexp(0, 1, 200, 1000);
Pwhite(0, 1, inf).degreeToKey([0, 1, 3, 5, 7, 9, 11], 10);
blend(Pseq([1, 2, 3], inf), Pseq([3, 2, 1, 0], inf), Pseries(0, 0.01, inf));
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, (val + 72) .midicps.postln]);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]);
).play;
)



// these are the same as:

(
var a;
a = Pseries(0, 1, 12).wrap(3, 7).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, (val + 72) .midicps.postln]);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pwhite(0, 12, inf).wrap(3, 7);
).play;
)
::


class:: Pnsym
summary:: use a pattern of symbols to embed Pdefns
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdefn

description::
for event patterns see link::Classes/Psym::. Overview: link::Overviews/JITLib::.

ClassMethods::

method::new

argument::pattern
a pattern that returns symbols or characters. Arrays are converted to parallel patterns ( link::Classes/Ptuple:: ).

argument::dict
the dictionary to be used for lookup. By default, this is code::Pdefn.all::, so one can embed Pdefns by name.

InstanceMethods::

method::dict
set the dictionary to be used.

Examples::

code::
(
// load a synthdef
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

Pdefn(\x, Pn(1, 3));
Pdefn(\y, Prand([5, 9, 1], 2));
Pdefn(\z, Pdefn(\y) * 2);

(
Pdef(\play,
	Pbind(
		\instrument, \gpdef,
		\harmonic, Pnsym(Pseq([\x, \x, Prand([\x, \y]), [\z, \y], \y], inf)).trace,
		\dur, 0.2, \note, 10
	)
).play;
)

// change root pattern:
Pdefn(\x, Pn(2, 3));
Pdefn(\x, Pseq([1, 3, 1, 2, 1, 4, 5]));
Pdefn(\x, Pseq([1, 3, 1, 2, [1, 3], 4, 5]));
::


class:: Point
summary:: Cartesian point
related:: Classes/Polar, Classes/Complex
categories:: Geometry

description::
Defines a point on the Cartesian plane.

classmethods::

method::new
Defines a new point.

instancemethods::

subsection:: Accessing

method::x
Get or set the x coordinate value.

method::y
Get or set the y coordinate value.

method::set
Sets the point x and y values.

subsection:: Testing

method::==
Answers a Boolean whether the receiver equals the argument.

method::hash
Returns a hash value for the receiver.

subsection:: Math

method::+
Addition.

method::-
Subtraction.

method::*
Multiplication.

method::/
Division.

method::translate
Addition by a Point.

method::scale
Multiplication by a Point.

method::rotate
Rotation about the origin by the angle given in radians.

method::abs
Absolute value of the point.

method::rho
Return the polar coordinate radius of the receiver.

method::theta
Return the polar coordinate angle of the receiver.

method::dist
Return the distance from the receiver to aPoint.

method::transpose
Return a Point whose x and y coordinates are swapped.

method::round
Round the coordinate values to a multiple of quantum.

method::trunc
Truncate the coordinate values to a multiple of quantum.

subsection:: Conversion

method::asPoint
Returns the receiver.

method::asComplex
Returns a complex number with x as the real part and y as the imaginary part.

method::asString
Return a string representing the receiver.


class:: Polar
summary:: Polar coordinates
related:: Classes/Point, Classes/Complex
categories:: Math

description::
Represents polar coordinates.

classmethods::

method:: new
Create a new polar coordinate with the given radius, rho, and angle in radians, theta.



instancemethods::

subsection:: Math
method:: +, -, *, /
The math operations of addition, subtraction, multiplication and division are accomplished by
first converting to complex numbers.

method:: scale
Scale the radius by some value.

method:: rotate
Rotate the angle by some value.

method:: neg
Rotate by pi.


subsection:: Conversion

method:: magnitude
Answer the radius.

method:: angle
Answer the angle in radians

method:: phase
Answer the angle in radians

method:: real
Answer the real part.

method:: imag
Answer the imaginary part.

method:: asComplex
Convert to Complex

method:: asPoint
Convert to Point



class:: Poll
categories:: UGens>Info
summary:: Print the current output value of a UGen
related:: Classes/SendTrig, Classes/OSCFunc

description::

Print the current output value of a UGen, useful for debugging SynthDefs.

WARNING:: Printing values from the Server in intensive for the CPU. Poll should be used for debugging purposes.::

classmethods::
private:: categories, new, new1

method:: ar, kr
argument::trig
a non-positive to positive transition telling Poll to return a value
argument::in
the signal you want to poll
argument::label
a string or symbol to be printed with the polled value
argument::trigid
if greater then 0, a '/tr' message is sent back to the client (similar to SendTrig)

returns:: its in signal (and is therefore transparent).

instancemethods::
private:: checkInputs, init

examples::
code::
s.boot;

{ Poll.kr(Impulse.kr(10), Line.kr(0, 1, 1), \test) }.play(s);

// multichannel expansion:

{ Poll.kr(Impulse.kr([10, 5]), Line.kr(0, [1, 5], [1, 2]), [\test, \test2]) }.play(s);



// using the poll message:

{ SinOsc.ar(375, 0, 1).poll(Impulse.ar(20), \test2) }.play(s);

// if no arguments are given, the poll is done every 0.1 sec.
{  Line.kr(0, 1, 1).poll }.play(s);


// send a '/tr' message back to the client. This can be useful if the server runs on another
// computer than the client, i.e. the post messages by the server cannot be read locally.

o = OSCFunc({arg msg; msg.postln;}, '/tr', s.addr);

{Poll.ar(Impulse.ar(5), Line.ar(0, 1, 1), \test2, 1234)}.play(s);
{SinOsc.ar(220, 0, 1).poll(Impulse.ar(15), "test", 1234)}.play(s);

o.free;
s.quit;




// This example will kill the server (by outputting NaN).
// Poll.ar will help us spot why it's happening.
// Warning: You may need to reboot your server after running this.
(
{
var cutoff, son;
cutoff = LFPar.kr(0.2, 0, 500, 500);
son = LPF.ar(WhiteNoise.ar, cutoff);

// Using Poll to debug by spitting out a value if the output hits NaN
Poll.ar(if((son<=0)||(son>=0), 0, 1), cutoff, "Cutoff value which causes NaN:");

son;

}.play(s);
)


// This example polls when someone hits the trigger
(
x = {|t_poll=0|
var minfreq, maxfreq, son;
minfreq = LFNoise2.ar(0.25, 100, 110);
maxfreq = LFNoise2.ar(0.25, 200, 220);

son = Gendy1.ar(minfreq: minfreq, maxfreq: maxfreq, mul: 0.1);

Poll.kr(t_poll, [minfreq, maxfreq], ["minfreq", "maxfreq"]);

son;

}.play(s);
)

x.set(\t_poll, 1); // Hit this whenever you want to know what the parameters are
::



CLASS:: PopUpMenu
summary:: A view displaying a text item selectable from a drop-down menu.
categories:: GUI>Views

DESCRIPTION::

When clicked, this view opens a menu containing several text items, then closes the menu and displays one of the items after it is selected.

CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::



SUBSECTION:: Data

METHOD:: items
	The list of items displayed in a menu when the view is clicked.

	argument::
		An Array of Strings or Symbols.

METHOD:: clear
 Removes all items.

METHOD:: item
	The currently selected item.

	returns::
		A String.

METHOD:: value
	The index of the currently selected item.

	argument::
		An integer, or nil meaning no selected item.

METHOD:: valueAction
	Sets link::#-value:: and triggers link::#-action::.

	argument::
		An integer, or nil meaning no selected item.



SUBSECTION:: Appearance

METHOD:: stringColor
	The color used to display text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the area of the view under the text with the given color.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: allowsReselection
	Determines whether the action is triggered when selecting already selected item. Defaults to false.

	argument::
		A Boolean.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the selected item from the menu. See link::#-allowsReselection:: for customization.



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::

subsection:: Basic Example

code::
(
w = Window.new("The Eightfold Path").front;
m = PopUpMenu(w, Rect(10, 10, 180, 20));

m.items = [
 "right view", "right thinking", "right mindfulness", "right speech",
 "right action", "right diligence", "right concentration", "right livelihood"
];

m.background_(Color.green(0.7));  // only changes the look of displayed item
m.stringColor_(Color.white);   // only changes the look of displayed item
m.font_(Font("Courier", 13));   // only changes the look of displayed item
m.action = { arg menu;
 [menu.value, menu.item].postln;
};
)

m.value;   // returns the index of the current item;
m.item;    // returns the String or Symbol of the current item

m.value_(2);  // changes the displayed item, but does not evaluate the action
m.valueAction_(3); // evaluates the action.
::

subsection:: Sound Example

Play different functions:

code::
(
s.waitForBoot({

 var w, menu, snd, funcs, b;

 w = Window.new.front;

 menu = PopUpMenu(w, Rect(10, 10, 90, 20))
  .items_(["Sine", "Saw" , "Noise" , "Pulse"]);

 funcs = [
  { SinOsc.ar(440, 0, 0.3) },
  { Saw.ar(440, 0.3) },
  { WhiteNoise.ar(0.3) },
  { Pulse.ar(440, 0.2, 0.3) }
 ];

 b = Button(w, Rect(110, 10, 180, 20))
  .states_([["play", Color.black, Color.green]])
  .mouseDownAction_({
    snd = funcs.at(menu.value).play;
   })
  .action_({ arg butt, mod;
    snd.release;
   });

 w.front;

 p = CmdPeriod.add({ b.value_(0) }); // set button to 0 on hitting Cmd-period
 w.onClose_{ snd.release; CmdPeriod.removeAll }; // clean up when window is closed

})
)
::


CLASS::Post
summary::posts text to the post window
categories:: Files

DESCRIPTION::
The class Post is a stream destination. Its main use is that it can sometimes make code more readable and execution slightly more efficient.
code::
Post <<< a << " " <<< b << " " <<< c << " " <<< d << Char.nl;
::
vs
code::
(a.asCompileString + b.asCompileString + c.asCompileString + d.asCompileString).postln;
::

warning::
<< also means object left shift.
::

CLASSMETHODS::

method::<<
Post as string
code::
Post << "string";
::

method::<<<
Post as compile string
code::
Post <<< "string";
::

method::comma
Prints a comma
code::
Post.comma;
::

method::space
Prints a space
code::
Post.space;
::

method::nl
Prints a newline
code::
Post.nl;
::

method::ff
Prints the char $\f
code::
Post.ff;
::

method::tab
Prints a tab
code::
Post.tab;
::

EXAMPLES::

code::
a = "a string";
b = 'a symbol';
c = 4;
d = [1,2,3,4,a,b];

// post as string
Post << a << Char.nl;
// post as compile string
Post <<< a << Char.nl;

// post as string
Post << d << Char.nl;
// post as compile string
Post <<< d << Char.nl;

//This is the equivalent of :
d.postln;
//or
d.asCompileString.postln;
::


class:: Ppar
summary:: embed event streams in parallel
related:: Classes/Ptpar, Classes/Pgpar, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order. When one stream ends, the other streams are further embedded until all have ended.

ClassMethods::

method::new

argument::list
list of patterns or streams.

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// see the delta values in the resulting events
(
var a, b, c, t;
a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
c = Ppar([a, b]);
t = c.asStream;
20.do({ t.next(Event.default).postln; });
)

// sound example
(
var a, b;
a = Pbind(\note, Pseq([7, 4, 0], 4), \dur, Pseq([1, 0.5, 1.5], inf));
b = Pbind(\note, Pseq([5, 10, 12], 4), \dur, 1);
Ppar([ a, b ]).play;
)
::


class:: PparGroup
summary:: Starts a new ParGroup and plays the pattern in this group
related:: Classes/ParGroup, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

The class has a semantics similar to link::Classes/Pgroup::, but instead of a Group, it creates a ParGroup on the
server.

Examples::

code::
(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

PparGroup(p).play;

// post the node structure:
fork {
	s.queryAllNodes;
	3.wait;
	s.queryAllNodes;
	2.wait;
	s.queryAllNodes;
}
)
::


class:: Ppatlace
summary:: interlace streams
related:: Classes/Place
categories:: Streams-Patterns-Events>Patterns>List

description::

Similar to link::Classes/Place::, but the list is an array of streams or patterns. The results of each stream will be output in turn.

Examples::

code::
p = Ppatlace([Pwhite(1, 5, 5), Pgeom(10, 1.01, 10)], inf);
x = p.asStream;
x.all;


5		// from Pwhite
10		// from Pgeom
4		// from Pwhite
10.1		// etc....
5
10.201
4
10.30301
2
10.4060401
10.510100501
10.61520150601
10.72135352107
10.828567056281
10.936852726844
nil
::

Note that the Ppatlace has an infinite number of repeats, but the resulting stream is finite because the member streams are all finite. When the first stream (Pwhite) comes to an end, it is skipped and you see only the second stream until it stops.

If even one member stream is infinite and Ppatlace has infinite repeats, the Ppatlace stream will also be infinite.


code::
//Ppatlace as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


// interlace two streams
(
var c = Ppatlace([
		Pseq([0, 0, 0, 0, 8, 0, 8], inf),
		Pseries(1, 1, 32)
	], inf) + 67;
x = c.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps, \dur, 0.2]);
		0.17.wait;
	})
}).play;
)




// a more complicated example:
(
c = Ppatlace([
	Pxrand([
		Pseq(#[0, -2, -3, -5, -7], 1), Pwhite(-12, 4, 3), Pshuf(#[0, -2, -3, -5, -7], 1)
	], inf),
	Pxrand([
		Pseq(#[0, 2, 4, 5, 7], 1), Pwhite(-4, 12, 3), Pshuf(#[0, 2, 4, 5, 7], 1)
	], inf)
], inf) + 67;
x = c.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps, \dur, 0.2]);
		0.17.wait;
	})
}).play;
)
::


class:: Ppatmod
summary:: modify a given pattern before passing it into the stream
related:: Classes/Plazy
categories:: Streams-Patterns-Events>Patterns>Filter

ClassMethods::

method::new

argument::pattern
the pattern.

argument::func
A link::Classes/Function:: that modifies the enclosed pattern and embeds it in the stream.

argument::repeats
the number of repeats.

Examples::

code::
(
a = Ppatmod(
	Pseq([0, 0, 0, 0],1),
	{ arg pat, i;
		var list;
		list = pat.list;
		pat.list = list.put(list.size.rand, 2);
	}, inf);

x = a.asStream;
30.do({ x.next.postln });
)


//Ppatmod used to modify a pattern that produces a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(
	Ppatmod(
		Pseq([0, 0, 0, 0],1),
		{ arg pat, i;
			var list;
			list = pat.list;
			pat.list = list.put(list.size.rand, 2);
		}, 15),
inf).asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, (a.next*5+77).midicps]);
		0.13.wait;
	})
}).play;
)
::


class:: Ppoisson
summary:: random values that follow a Poisson Distribution (positive integer values)
related:: Classes/Pgauss
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::length
Number of values produced.

Examples::

code::
(
var a, c, w;
a = Ppoisson(1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Ppoisson", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Ppoisson(10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Ppoisson", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Ppoisson(1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, (a.next + 72).midicps]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Ppoisson(7.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, (a.next + 72).midicps]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pprob
summary:: random values with arbitrary probability distribution
related:: Classes/Ppoisson
categories:: Streams-Patterns-Events>Patterns>Random

description::

Creates an integral table on instantiation (cpu intensive) which is then used by the streams to generate random values efficiently.

ClassMethods::

method::new

argument::distribution
desired probability distribution (histogram).

argument::lo
lower bound of the resulting values.

argument::hi
upper bound of the resulting values.

argument::length
number of values to repeat.

argument::tableSize
resample table to this size. If the size of the distribution is smaller than 64, it is (linearly) resampled to this minimum size.

argument::distribution
set the distribution, the table is recalculated.

argument::tableSize
set the resample size, the table is recalculated.

Examples::

code::
// a consistency test
(
var a = Pprob([0,0,0,0,1,1,1,1,3,3,6,6,9].scramble);
var b = a.asStream;
b.nextN(800).sort.plot("sorted distribution");
b.nextN(800).sort.plot("sorted distribution, again");
)


// comparison: emulate a linrand
(
var a, b, x, y;
a = Pprob([1, 0]);
x = Pfunc({ 1.0.linrand });

b = a.asStream;
y = x.asStream;

postf("Pprob mean: % linrand mean: % \n", b.nextN(800).mean, y.nextN(800).mean);

b.nextN(800).sort.plot("this is Pprob");
y.nextN(800).sort.plot("this is linrand");
)


// compare efficiency

bench { Pprob([0, 1]) } // this is fairly expensive
bench { 16.do { Pseq([0, 1] ! 32) } }

x = Pprob([0, 1]).asStream;
y = Pseq([0, 1], inf).asStream;

bench { 100.do { x.next } }; // this very efficient
bench { 100.do { y.next } };



// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var t;
a = Pprob([0, 0, 1, 0, 1, 1, 0, 0], 60, 80);
t = a.asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, t.next.midicps]);
	0.01.wait;
	})
}).play;
)

a.distribution = [0, 1];
a.distribution = [1, 0];
a.distribution = [0, 0, 0, 0, 1, 0];
a.distribution = [0, 1, 0, 0, 0, 0];

// higher resolution results in a more accurate distribution:
a.tableSize = 512;
a.tableSize = 2048;
::


class:: Pprotect
summary:: evaluate a function when an error occured in the thread
related:: Classes/Ptrace
categories:: Streams-Patterns-Events>Patterns>Language Control

ClassMethods::

method::new

argument::pattern
any pattern

argument::func
a link::Classes/Function:: to be evaluated when an error occurs. The error and the thread are passed as arguments to the function.

Examples::

code::
(
var x;
var func = { "an error happened".postln };
a = Pprotect(Pseq([1, 3, 3, Pfuncn({ Error.new.throw }), 2]), func);
x = Pbind(\degree, a, \dur, 0.5).play;
)
::


class:: Pproto
summary:: provide a proto event for an event stream
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Pproto uses the strong::makeFunction:: to allocate resources (buffers, buses, groups) and create a protoEvent that makes those resources available to a pattern. It is fully compatible with non-realtime synthesis using strong::render::.

The strong::makeFunction:: "makes" the protoEvent (i.e. protoEvent is code::currentEnvironment::). Typically, it defines and yields a sequence of events that create the needed resources using the following link::Overviews/Event_types:::

definitionList::
## \allocRead || load a file from ~path, starting at ~firstFileFrame, reading ~numFrames sample frames
## \cue || cue a file for DiskIn, with ~bufferSize frames
## \table || load ~amps directly into a buffer
## \sine1 || generate a buffer from ~amps
## \sine2 || generate a buffer from ~freqs, ~amps
## \sine3 || generate a buffer from ~freqs, ~amps, ~phases
## \cheby || generate a waveshape buffer from ~amps
## \audioBus || allocate ~channels consecutive audio buses
## \controlBus || allocate ~channels consecutive control buses
## \on || create a synth

::

note::
These eventTypes will allocate their own buffers and buses unless they are specified. To support this, the key code::\bufNum:: is used rather than code::\bufnum:: which has a default value assigned.
::

When Pproto ends, these eventTypes will respond to the strong::cleanup:: call by strong::deallocating any resources they have allocated::. Do not assume your buffers, buses etc. will exist after Pproto stops!

The function yields each event. That event is then performed with possible modifications by enclosing patterns and the player (either an link::Classes/EventStreamPlayer:: or a link::Classes/ScoreStreamPlayer::). The resultant event is returned to the function where it can be assigned to a key within the protoEvent.

The patternarray is played using Pfpar, a variant of Ppar that ends when any of its subpatterns end. In this way,
you can use Pproto to create effects that can be controlled by a pattern that runs in parallel with the note generating pattern and ends together with that note generating pattern (see example 4 below).

A strong::cleanupFunction:: that deallocates resources when the pattern ends or is stopped is automatically created. It can be replaced with a user defined cleanup if needed. This function receives two arguments: strong::proto::, the prototype event, and strong::flag::, which is set false if all nodes have been freed already by link::Classes/CmdPeriod::.

Examples::

note::The syntax used for patterns like Pbind and Pmono is a little bit different for making the code more readable. The difference has nothing to do with Pproto. This is the same: code::Pbind(\freq, 700, \amp, 0.1):: and code::Pbind(*[freq: 700, amp: 0.1])::
::


subsection::Example 1, loading and granulating a sound file.

code::
(
SynthDef(\help_playbuf, { | out=0, bufnum = 0, rate = 1, startPos = 0, amp = 0.1, sustain = 1, pan = 0, loop = 1|
	var audio;
	rate = rate * BufRateScale.ir(bufnum);
	startPos = startPos * BufFrames.ir(bufnum);

	audio = BufRd.ar(1, bufnum, Phasor.ar(0, rate, startPos, BufFrames.ir(bufnum)), 1, 1);
	audio = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: Done.freeSelf) * audio;
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, audio);
}).add;  //use .store for rendering example below

a = Pproto({
	~newgroup = (type: \group).yield;
	~sf1 = (type: \allocRead, path: Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff").yield;
},
	Pbind(*[
		instrument:	\help_playbuf,
		dur:		Pseg([0,0,0.25,0.5, 0.75, 1],10).linexp(0,1,0.01,2),
		legato:		4,
		startPos:	Pn(Pseg([0,1], 20), inf),
		rate:		Pwhite(1, 1).midiratio,
		loop:		0,
		group:		Pkey(\newgroup),
		bufnum:		Pkey(\sf1)
	])
);
a.play;
)

//a.render("sounds/test.aif", 40)
//SoundFile.openRead("sounds/test.aif").play
::

subsection::Example 2, loading a waveform buffer and modifying it in performance.

code::
(
SynthDef(\osc,{ arg out=0, bufnum=0, numbufs = 8, sustain = 1, freq = 500, amp = 0.1, pan = 0;
	var audio;
	audio = Osc.ar(bufnum, freq);
	audio = EnvGen.ar(Env.linen(0.01, 0.90,0.9), 1, timeScale: sustain, doneAction: Done.freeSelf) * audio;
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, audio);
}).add;  //use .store for rendering example below

b = Pproto({
	~bufnum = (type: \sine1, amps: 1.0/[1,2,3,4,5,6] ).yield;
	},
	Ppar([
		Pbind(*[
			instrument: 	\osc,
			freq:		Pwhite(1, 16) * 100,
			detune:		Pfunc { Array.fill(3.rand + 1, {3.0.rand}) },
			dur:		Prand([2,2,2.5,1],10),
			db:		Pn(Pstep([-10, -20, -20, -15, -20, -20, -20], 0.5) ),
			legato:		Pwhite(0.0,1).linexp(0,1,0.1, 3)
		]),
		Pbind(*[
			type:		\sine1,
			amps:		Pseg(Pfunc{ | ev | Array.fill(10, {1.0.rand}) }, 1),
			numOvertones:	Pseg(Pwhite(0, 9), 10).asInteger,
			amps:		Pfunc{ | ev | ev[\amps].copyRange(0, ev[\numOvertones]) },
			dur: 		0.05,
			bufNum:		Pkey(\bufnum)
		])
	])
);
b.play
)

//b.render("sounds/test.aif", 40)
//SoundFile.openRead("sounds/test.aif").play
::

subsection::Example 3, loading a waveshaper buffer and modifying it in performance.

code::
(
SynthDef(\shaper,{ arg out=0, bufnum=0, numbufs = 8, sustain = 1, freq = 500, amp = 0.1, pan = 0;
	var audio;
	audio = SinOsc.ar(freq);
	audio = EnvGen.ar(Env.linen(0.4, 0.50,0.9), 1, timeScale: sustain, doneAction: Done.freeSelf) * audio;
	audio = Shaper.ar(bufnum, audio);
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, LeakDC.ar(audio));
}).add;  //use .store for rendering example below

c = Pproto({
	~bufnum = (type: \cheby, amps: 1.0/[1,2,3,4,5,6] ).yield;
	},
	Ppar([
		Pbind(*[
			instrument: 	\shaper,
			freq:		Pwhite(1, 16) * 100,
			detune:		Pfunc { Array.fill(3.rand + 1, {3.0.rand}) },
			dur:		Prand([2,2,2.5,1],inf),
			db:		Pn(Pstep([-10, -20, -20, -15, -20, -20, -20], 0.5) ),
			legato:		Pwhite(0.0,1).linexp(0,1,1.1, 5)
		]),
		Pbind(*[
			type:		\cheby,
			amps:		Pseg(Pfunc{ | ev | Array.fill(10, {1.0.rand}) }, 4),
			dur: 		0.05
		])
	])
);
c.play
)
//c.render("sounds/test.aif", 40)
//SoundFile("sounds/test.aif").play
::

subsection::Example 4, using an effect with parallel control.

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 5, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, Lag.kr(dtime, 4), decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\fm, { arg out=0, freq, index, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 5, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, SinOsc.ar(freq, in * index));
}).add;

Pproto({
	// start two effect synths (just switching them on) and store the parameters in the environment
	~fsynth = (type: \on, instrument: \fm, freq: 4, index: 1, addAction: 1, db: -30).yield;
	~fControl = [\set, ~fsynth[\id], ~fsynth[\msgFunc] ];

	~synth = (type: \on, instrument: \echo, addAction: 1).yield;
	~sControl = [\set, ~synth[\id], ~synth[\msgFunc] ];

	}, [
	Pbind(*[
		#[type, id, msgFunc],	Pkey(\fControl), // fetch the parameters from the environment

		freq:	Pseg([0,1], 10).linexp(0,1, 0.1, 1000),
		index:	Pseg([0,1], 10).linexp(0,1, 0.1, 100),
		dur:	0.1
	]),
	Pbind(*[
		#[type, id, msgFunc],	Pkey(\sControl), // fetch the parameters from the environment

		dtime:	Pwhite(0,0.2),
		decay:	Pwhite(0.1,2),
		dur:	1
	]),
	Pbind(*[
		instrument: \default,
		freq: Pwhite(1,16) * 100,
		dur: 0.2,
		db:	0
	])
	]
).play
)
::


class:: Prand
summary:: embed values randomly chosen from a list
related:: Classes/Pxrand, Classes/Pwrand
categories:: Streams-Patterns-Events>Patterns>List

description::

Embed one item from the list at random for each repeat.

Examples::

code::
(
var a, b;
a = Prand([1, 2, 3, 4, 5], 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

// return also a subpattern:
(
var a, b;
a = Prand([1, Pseq([10, 20, 30]), 2, 3, 4, 5], 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

//Prand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Prand(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::


class:: Preject
summary:: Filters a source pattern by rejecting particular values.
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pselect, Classes/Pcollect, Classes/Collection#-reject

description::
Preject filters the source strong::pattern:: using strong::func::. Values for which strong::func:: returns true will not be returned by Preject.

This is the pattern library's equivalent of link::Classes/Collection#-reject::.

classmethods::

method:: new
argument:: func
A link::Classes/Function::. The function used to reject values. It should take a single parameter (the next value from code::pattern::), and return a boolean.

argument:: pattern
The link::Classes/Pattern:: to be filtered.


examples::
code::
(
var a, b;
a = Preject({ arg item; item == 1 }, Pseq(#[1, 2, 3],inf));
x = a.asStream;
9.do({ x.next.postln; });
)
::

The message reject returns a Preject when passed to a pattern
code::
(
var a, b;
a = Pseq(#[1, 2, 3],inf).reject({ arg item; item == 1 });
a.postln;
x = a.asStream;
9.do({ x.next.postln; });
)
::



class:: Prewrite
summary:: L-system pattern for selfsimilar structures
related:: Classes/Pfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Lindenmayer system pattern for selfsimilar structures. Its strong::dictionary (or event):: maps one element to an array of child elements. The algorithm replaces iteratively (strong::levels:: deep) elements by arrays of elements starting with the values in the strong::pattern::.

ClassMethods::

method::new

argument::pattern
starting value

argument::dict
a dictionary or an event.

argument::levels
number of levels

code::
IdentityDictionary[
	elem1 -> [ otherElements ],
	elem2 -> [ otherElements ],
	elem2 -> [ otherElements ]
]
::

Examples::

The examples use the code::():: shortcut for link::Classes/Event::.

code::

// A generative song
(
// Scale degrees going up
Pdef(\a, Pbind(\dur, 0.25, \degree, Pseq((0..3))));

// Scale degrees going down
Pdef(\b, Pbind(\dur, 0.25, \degree, Pseq((3..0))));

// Random scale degrees
Pdef(\c, Pbind(\dur, 0.125, \degree, Pwhite(0,10, 8)));

// Use the L-system to put together a sequence of keys
// Psym will then retrieve the patterns from the global Pdef dictionary
// See the post window for info about which of these are playing
Psym(
	Prewrite(\a, // start with pattern \a
		(
			\a: #[\a, \b],
			\b: #[\c, \a],
			\c: #[\a, \b]
	), 4).trace
).play
)

// Inspect the L-system to see what data it produces
(
a = Prewrite(0, // start with 0
	(
		0: #[2,0],
		1: #[0,0,1],
		2: #[1,0,1]
), 4);
x = a.asStream;
30.do({ x.next.postln });
)
::


CLASS::PriorityQueue
summary:: Priority queue data structure
categories:: Collections>Ordered

DESCRIPTION::
PriorityQueue implements a priority queue data structure, which is used to build schedulers. It allows you to put in items at some arbitrary time and pop them in
time order.

INSTANCEMETHODS::
private::prInternalArray


method::put
Puts the item in the queue at the given time.

method::topPriority
Returns the time of the earliest item in the queue.

method::pop
Returns the earliest item in the queue.

method::clear
Empty the queue.

method::isEmpty
Return a link::Classes/Boolean:: whether the queue is empty.

method::notEmpty
Return a link::Classes/Boolean:: whether the queue is not empty.

method::removeValue
Remove all instances of value from the queue.


EXAMPLES::

code::
(
var p;
p = PriorityQueue.new;

p.put(0.1, \a);
p.put(2.0, \b);
p.put(0.5, \c);
p.put(0.2, \d);
p.put(1.0, \e);

while ({ p.notEmpty },{
	[p.topPriority, p.pop].postln;
});


p.pop.postln;
p.pop.postln;
p.pop.postln;

)

[ 0.1, a ]
[ 0.2, d ]
[ 0.5, c ]
[ 1, e ]
[ 2, b ]
nil
nil
nil
::


class::Process
categories::Core>Kernel
summary:: Runtime environment for the virtual machine and interpreter.

description::
A Process is the runtime environment for the virtual machine and interpreter.
It has a subclass named link::Classes/Main:: which is where you should override the methods
of Process. There are two methods of interest. One is named code::startup:: and is
called after the class library has been compiled. The other is named code::run:: and
is called when the user chooses the Run menu command.

classMethods::

method::tailCallOptimize
Get or set tail call optimization. The default is on. Setting this to code::false:: can help with debugging by including intermediate levels in an error backtrace.

instanceMethods::

method::nowExecutingPath

Usage: code::thisProcess.nowExecutingPath::

Returns the full path to the file containing the code that is currently executing emphasis::interactively:: in the interpreter. Usually this is the current document. If the code block executes another file on disk, using link::Classes/String#-load:: or link::Classes/String#-loadPaths::, teletype::nowExecutingPath:: will be the location of the executed file.

teletype::nowExecutingPath:: is valid only for interactive code, i.e., code files with a teletype::.scd:: extension. It does not apply to class definitions (teletype::.sc::). For that, use code::thisMethod.filenameSymbol:: or code::this.class.filenameSymbol::.

This method is supported in the SuperCollider IDE, the macOS-only SuperCollider.app, and the scel (SuperCollider-Emacs-Lisp) environment. In other editor environments, it will return code::nil::.

WARNING:: teletype::nowExecutingPath:: has a corresponding setter method, teletype::nowExecutingPath_::, for internal use only by the interpreter. Do not call the setter method!::

method::startup

called after the class library has been compiled. Override this in class link::Classes/Main:: to do whatever you want.

method::run

called when the user chooses the Run menu command. Override this in class link::Classes/Main:: to do whatever you want.

method::mainThread

The top-level link::Classes/Thread::, i.e the link::Classes/Thread#-parent#parent:: of all
other Threads. This instance of Thread always exists and is created with the Process when
SuperCollider starts.

discussion::

All SuperCollider code initially runs in the context of the main Thread:

list::
## Code evaluated in code editor
## Code evaluated on command line
## Tasks scheduled on any link::Classes/Clock::
## Functions evaluated in response to incoming OSC and MIDI messages
::

This means that link::Classes/Thread#.thisThread#thisThread:: will always initially point
to the main Thread. However, when some code starts a link::Classes/Routine::, the Routine
becomes the current Thread, with the main Thread as its parent.


class:: ProgramChangeResponder
summary:: allow functions to be registered to respond to MIDI program change events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::value
An link::Classes/Integer:: between 0 and 127 that selects which program change number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::install
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added.

Examples::

code::
(
	c = ProgramChangeResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
::

code::
(
	c = ProgramChangeResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60) // within this value range
	)
)

c.remove
::


class:: Prorate
summary:: divide stream proportionally
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::proportion
a pattern that returns either numbers (divides the pattern into pairs) or arrays of size n which are used to split up the input into n parts.

argument::pattern
a numerical pattern.

Examples::

code::
// divide 1 into various proportions
(
a = Prorate(Pseq([0.35, 0.5, 0.8]), 1);
x = a.asStream;
x.nextN(8)
)

// divide a pattern into various proportions
(
a = Prorate(Pseq([0.35, 0.5, 0.8]), Prand([20, 1], inf));
x = a.asStream;
x.nextN(8)
)


// divide 1 into several parts
(
a = Prorate(Pseq([[1, 2], [5, 7], [4, 8, 9]]).collect(_.normalizeSum), 1);
x = a.asStream;
x.nextN(8)
)


// sound example

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a, x;
a = Prorate(
	Prand([2/3, 1/3, [0.3, 0.3, 0.4], [0.6, 0.4]], inf),
	Pseq([1, 2, 1, 3, 12], inf)
);

3.do {
	{
	var x = a.asStream;
	var freq = rrand(72, 84).midicps;
		loop {
			Synth(\help_sinegrain, [\freq, freq]);
			(0.25 * x.next).wait;
		}
	}.fork;
};
)
::


class:: Prout
summary:: routine pattern
related:: Classes/Routine
categories:: Streams-Patterns-Events>Patterns>Function

description::

note that there is a shortcut to create a Prout:

code::p(func)::

ClassMethods::

method::new
Returns a routine from the function.

argument::routineFunc
routine function.

Examples::

code::
(
var a;
a = Prout({ loop { 1.yield; 2.yield; 7.yield; 10.do { 1.0.rand.yield } }});
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.1), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Prout({ loop { 1.yield; 2.yield; 7.yield; 10.do { 1.0.rand.yield } }}).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)

// shortcut:
(
Pbind(
	\instrument, \help_sinegrain,
	\freq, p { loop { ([1000, 2000].choose + [100, 200].choose + [10, 20].choose).postln.yield } },
	\dur, 0.1
).play;
)
::


class:: ProxyMixer
summary:: mix control for a proxyspace or Ndef.all
categories:: JITLib>GUI, Live Coding
related:: Classes/ProxySpace, Classes/Ndef, Classes/JITGui, Classes/NdefGui, Classes/MonitorGui, Classes/NdefParamGui

description::

ProxyMixer provides controls for handling and editing the node proxies in a proxyspace and their monitors (cross-platform graphics). It replaces the earlier ProxyMixer class. For Ndefs, use link::Classes/NdefMixer::.

Overview: link::Overviews/JITLib::

code::

// First examples:
(
p = ProxySpace.push(s.boot, p);
"abcde".do { |k| p[k.asSymbol].ar };
m = ProxyMixer(p, 8);
m.parent.alwaysOnTop_(true); // show mixer in front of IDE
)

p.do(_.play(0));
m.object_(nil);
m.object_(p);

// if you have JITLibExtensions installed, try ProxyMeter to see the proxy levels:
if (\ProxyMeter.asClass.notNil) { ProxyMeter.addMixer(m); };


"abcdefghijk".do { |k| p[k.asSymbol].ar };

"lmnopqrtuvw".do { |k| p[k.asSymbol].kr };

"abcdefghijk".do { |k, i|
	p[k.asSymbol].playN(vol: 0.8 - (0.1 * i) );
	p[k.asSymbol].source = {
		VarSaw.ar((i + 1 * 100) + [-1, 1])
		* LFSaw.ar((i + 1 * 0.25));
	};
};
::

ClassMethods::

subsection::Creation

method::new

argument::obj
the proxyspace to show and control

argument::numItems
how many ar and kr proxies can be shown

argument::parent
by default nil, so a window is made automatically. if a parent is supplied, the ProxyMixer will be shown there.

argument::bounds
window bounds - default is nil, so it determines it size.

argument::makeSkip
a flag whether to make make a skipjack

argument::options
additional settings - currently none provided.

method::small
like *new, but creates a proxyMixer for small screen sizes.


InstanceMethods::

subsection::Instance variables

strong::GUI areas and elements: ::
method::arZone, krZone, editZone, arGuis, krGuis, editGui, arScroller, krScroller

strong::current state and access methods: ::
method::proxyspace, existingProxies, activeProxies, playingProxies, selectedKeys, arNames, krNames, numArs, numKrs, atAr, atKr

subsection::Instance methods

method:: highlight, unhighlight
highlight and unhighlight an arGui slot in the arZone (left)
method:: highlightSlots
highlight a block of the arGuis in the arZone/

method::sizes, switchSize
switch between display modes 0: ar, 1: ar+kr, 2: ar+kr+ed

method::arKeysRotation, krKeysRotation
if too many proxies are present, by how much to rotate arKeys or krKeys to display.

method:: title
get the proxymixer window title.


method:: getNameLeftBorder
gets current left border of nameView
method:: setNameLeftBorder
sets current left border of nameView, trading size with volume slider
method:: shiftNameLeftBorder
shifts current left border of nameView

code::
m.getNameLeftBorder; // get its current left border position
m.setNameLeftBorder(250); // default
m.setNameLeftBorder(200); // aps left pos, smaller slider
// relative adjust:
m.shiftNameLeftBorder(10);
m.shiftNameLeftBorder(-10);

strong::standard JITGui methods: ::
method:: setDefaults, accepts, getState, checkUpdate

strong::internal - making the ProxyMixer gui elements: ::
method:: makeViews, makeTopLine, makeArZone, makeKrZone, makeEditZone, setEdButs

Examples::

code::

// make a proxyspace and 5 ar proxies, and a mixer to show them
(
p = ProxySpace.push(s.boot, p);
"abcde".do { |k| p[k.asSymbol].ar };
m = ProxyMixer(p, 8);
p.do(_.play(0));
)

m.object_(nil); // no object
m.object_(p);   // the proxyspace

// if you have JITLibExtensions installed, try ProxyMeter to see the proxy levels:
if (\ProxyMeter.asClass.notNil) { ProxyMeter.addMixer(m); };

    // make too many ar proxies, get a scroller
"abcdefghijk".do { |k| p[k.asSymbol].ar };

    // make too many kr proxies, get a scroller
"lmnopqrtuvw".do { |k| p[k.asSymbol].kr };

p.stop;
    // play some of them
m.arNames.scramble.keep(5).do { |k| p[k.asSymbol].playN };

    // the top left menu sets which proxies will be shown.

        // existingProxies: even an empty proxy is shown
~test.ar;

(        // activeProxies: proxy appears when it is alive
~test = { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
    var env = EnvGen.kr(
        Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
        timeScale: timescale);
    var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
    Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
};
)
~test.lag(\freq, 4);

        // playingProxies : only those that really play are shown.
~test.playN(vol: 1);

// switch back to active proxies...
        // the reduce button removes all proxies that are not playing
        // and that are not used as sources in other proxies:
~otto = { |dens=12| Dust.ar(dens) };

~otto.clear;        // remove it
p.reduce;

        // doc and docSel post the current proxyspace as code
p.document;

        // ProxyMixer has three preset widths:
m.switchSize(0);    // ar zone only
m.switchSize(1);    // ar + kr
m.switchSize(2);    // ar + kr + edit zone

        // try with a small ProxyMixer:
l = ProxyMixer.small(p, 8);
l.switchSize(0, true);    // ar zone only
l.switchSize(1, true);    // ar + kr
l.switchSize(2, true);    // ar + edit zone

        // Record opens a utility window, RecordProxyMixer.
        // this requires the JITLibExtensions quark.

    // the line of controls for one proxy and its monitor is
    // a ProxyMonitorGui, so for full details see ProxyMonitorGui.help.

    // it displays current volume,
~test.vol_(0.05);
~test.vol_(0.1);

    // proxy name; play/stop/end control:
~test.playN;        // playN as is
~test.stop;        // stop
~test.end;        // option-click on stop : end the monitor and the proxy itself.
~test.playN(vol: 0);    // option-click on play : start playing with volume zero.

~test.playNDialog;  // shift-click on play/stop: set multichan outputs from code


s.scope(8);
~test.playN(4);    // set proxy's first output channel:
~test.playN(0);

// One can move the border between sliders and nameView:

n.enableNameResize(true);	// try click and dragging that border now

n.setNameLeftBorder(200);   // or set by code

    //    paus/rsum toggles pause and resume:
~test.pause;
~test.resume;

    // send button resends the proxy,
    // option-click on send rebuilds the proxy
    // (e.g. for lookup in client-site state)
~test.send;
~test.send;
~test.rebuild;
~test.rebuild;


    // the ed button sends this proxy to the editor - see below

        // kr proxies show up in the middle
~lfo = { SinOsc.kr(2) };
~lfnoyz0 = { |lofreq = 0.5, mul=1, add| LFDNoise0.kr(lofreq, mul, add) };

        // the editor zone is a NodeProxyEditor
        // open it and set some params
m.switchSize(2);
m.editGui.object_(~test);
~test.set(\freq, exprand(80, 1250));    // set ~tests parameters
~test.set(\intv, 1.0.linrand);

    //    if you declare global specs for the range of a parameter,
    //    they can be used in the editor:
m.editGui.paramGui.specs.clear;

Spec.add(\intv, [0, 36, \lin]);
Spec.add(\timescale, [0.001, 10, \exp]);
Spec.add(\loopnode, [0, 7, \lin, 1]);
Spec.add(\curve, [-10, 10]);

m.editGui.object_(~test);

        // you can map a kr proxy to a control param;
~test.map(\intv, ~lfnoyz0);
~test.unmap(\intv);
        // this also works by dragging the kr proxy name
        // the field left of the param name.


p.reduce(method: \clear);

p.clean;

p.clear;

::


class:: ProxyMixerOld
summary:: mix control for a proxyspace
categories:: JITLib>GUI
related:: Classes/ProxySpace, Classes/NodeProxyEditor

description::

warning::
ProxyMixer has been updated - some little adaptations to existing uses may be needed. If you like, you can also replace "ProxyMixer" with "ProxyMixerOld" to keep using the old style of ProxyMixer.
::

ProxyMixer provides controls for handling and editing the node proxies in a proxyspace and their monitors (cross-platform graphics).

Overview: link::Overviews/JITLib::

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::proxyspace
a link::Classes/ProxySpace::

argument::nProxies
the maximum number of proxies you plan to use

argument::title
window title

argument::where
window bounds

Examples::

code::
p = ProxySpace.push(s.boot, \p);
m = ProxyMixer(p, 8, \p, Rect(20, 500, 0,0));

m = ProxyMixer(p, 8)

	// the top left menu sets which proxies will be shown.

		// existingProxies: even an empty proxy is shown
~test.ar;

(		// activeProxies: proxy appears when it is alive
~test = { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
	var env = EnvGen.kr(
		Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
		timeScale: timescale);
	var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
	Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
};
)
~test.lag(\freq, 4);

		// playingProxies : only those that really play are shown.
~test.playN(vol: 1);

// switch back to active proxies...

		// the reduce button removes all proxies that are not playing
		// and that are not used as sources in other proxies:
~otto = { |dens=12| Dust.ar(dens) };

~otto.clear;		// remove it
p.reduce;

		// doc and docc post the current proxyspace as code
p.document;

		// openEdit opens the editor zone, see below;
m.openEditZone(1);

		// R opens a Record utility, see below.

	// the line of controls for one proxy and its monitor is
	// a ProxyMonitorGui, so for full details see ProxyMonitorGui.help.

	// it displays current volume,
~test.vol_(0.05);
~test.vol_(0.1);

	// proxy name; play/stop/end control:
~test.playN;		// playN as is
~test.stop;		// stop
~test.end;		// option-click on stop : end the monitor and the proxy itself.
~test.playN(vol: 0);	// option-click on play : start playing with volume zero.

~test.vol_(0.1);

s.scope(8);
~test.playN(4);	// set proxy's first output channel:
~test.playN(0);

	// the "-=" / "-<" button supports multichannel monitoring,
	// see ProxyMonitorGui.help

	//	paus/rsum toggles pause and resume:
~test.pause;
~test.resume;

	// send button resends the proxy,
	// option-click on send rebuilds the proxy
	// (e.g. for lookup in client-site state)
~test.send;
~test.send;
~test.send;
~test.rebuild;
~test.rebuild;
~test.rebuild;


	// the ed button sends this proxy to the editor - see below

		// kr proxies show up in the middle
~lfo = { SinOsc.kr(2) };
~lfnoyz0 = { |lofreq, mul=1, add| LFDNoise0.kr(lofreq, mul, add) };

		// the editor zone is a NodeProxyEditor
		// open it and set some params
m.openEditZone(1);
m.editor.proxy_(~test);
~test.set(\freq, exprand(80, 1250));	// set ~tests parameters
~test.set(\intv, 1.0.linrand);

	//	if you declare global specs for the range of a parameter,
	//	they can be used in the editor:
Spec.add(\intv, [0, 36, \lin]);
Spec.add(\timescale, [0.001, 10, \exp]);
Spec.add(\loopnode, [0, 7, \lin, 1]);
Spec.add(\curve, [-10, 10]);

m.editor.proxy_(~test);

		// you can map a kr proxy to a control param;
~test.map(\intv, ~lfnoyz0);
~test.unmap(\intv);
		// this also works by dragging the kr proxy name
		// the field left of the param name.


	//	some more tests :
	// if there are too many ar proxies, a scroller appears
(		// test too many
10.do { |i| p[("test" ++ i).asSymbol] = {
	Pan2.ar(Ringz.ar(Impulse.ar(exprand(0.5, 4)), exprand(300, 3000), 0.02), 1.0.rand2, 0.2) };
};
)

10.do { |i| p[("test" ++ i).asSymbol].playN(vol: linrand(1.0), fadeTime: exprand(0.01, 5)) };

	// and the same for kr proxies
10.do { |i| p[("kr" ++ i).asSymbol] = { LFNoise0.kr(exprand(5, 50)) }; };

p.krProxyNames.do { |key| p.removeAt(key) };

p.reduce(method: \clear);

p.clean;
::


class:: ProxyMonitorGui
summary:: controls the top-level of a nodeproxy and its monitor
categories:: JITLib>GUI, Live Coding
related:: Classes/ProxyMixer, Classes/NodeProxyEditor

description::

is a GUI for controlling the top-level of a nodeproxy and its monitor. It is e.g. used in ProxyMixer, and NodeProxyEditor, and it is cross-platform.

Examples::

code::
s.boot;

	// make a proxy space and a test proxy
(
s.scope(8);
p = ProxySpace.push;

~test = { |freq=1000, dens=5, amp=1, lev=3|
	var freqline = { exprand(0.3, 3) } ! 3 * XLine.kr(0.125, 1, 2);
	Ringz.ar(Dust.ar(dens ! 3, dens.reciprocal.sqrt), freq * freqline, 0.1)
};
~test.playN(0, vol: 0.1);
)

	// make a ProxyMonitorGui
z = ProxyMonitorGui();

	// switching between proxies: drag-view displays proxy key
z.proxy = ~otto12345;	// up to 9 letters or so on macOS
z.proxy = ~test;		// make audio controls available if proxy is audio
z.proxy = nil;
z.proxy = ~otto; ~otto.kr;	//
z.proxy = ~test;



	// configuration variants

	// pudgier
ProxyMonitorGui(~test, bounds: 300@30);

	// place it in an existing window:
ProxyMonitorGui(~test, Window("ProxyMonitor", Rect(200, 200, 400, 100)).front);

ProxyMonitorGui(~test, Window("ProxyMonitor").front, bounds: 350@40);

ProxyMonitorGui(~test, Window("ProxyMonitor").front, bounds: Rect(20, 20, 360, 20));


	// show level in dB - off by default
ProxyMonitorGui(~test, showLevel: true, showPlayN: false);

	// without multichan out button - then uses proxy.play. true = playN by default.
ProxyMonitorGui(~test, showPlayN: false);

	// show proxy name or not. on by default.
ProxyMonitorGui(~test, showName: false);

	// show proxy pause and send buttons - true by default
ProxyMonitorGui(~test, showPauseSend: true, showPlayN: false);


	// turn off SkipJack view updates - updates are on by default.
ProxyMonitorGui(~test, makeWatcher: false);

	// minimal:
ProxyMonitorGui.new(~test, bounds: 300@40, showPlayN: false, showPauseSend: false);


	// the GUI functions:

ProxyMonitorGui(~test);
	// left slider is vol
~test.vol_(0.1);
~test.vol_(0.25);

~test.stop;	// play / stop button:
~test.playN;	//
~test.end;	// alt-stop fully ends the proxy.
~test.playN(vol: 0);	// alt-playN starts with volume 0.

	// number box sets first output channel
	// when you want to play out of adjacent channels.
~test.playN(0);
~test.out_(1);

	// playing out to multiple channels
~test.playN([0, 2, 5]);
~test.playN([1, 2, 5]);
	// switches the button next to it to show a different output shape:
	// ("-<" is multiple outs, "-=" is directly adjacent outs.
	// clicking on that button opens an editing dialog:
~test.playNDialog;

~test.out_(0);

	// the pause button pauses and resumes
~test.pause;
~test.resume;

	// snd button re-sends proxy's sound as compiled,
~test.send;
	// or with option-click, it rebuilds the proxy's sound function,
	// so e.g. normal random numbers or lookups in the lang get remade.
~test.rebuild;


//	ProxyMonitorGui gets its look from GUI.skin, so you could customize it there,
//	or pass your own look in:

ProxyMonitorGui(skin: <your look here>)

y = ProxyMonitorGui(~test);
::


class:: ProxyNodeMap
summary:: store control values and bus mappings for NodeProxy
categories:: JITLib>NodeProxy
related:: Classes/Bus

description::
Object to store control values and bus mappings independantly of a specific NodeProxy.



class:: ProxySpace
summary:: an environment of references on a server
categories:: JITLib>Environments, Live Coding, Collections>Unordered
related:: Classes/NodeProxy, Classes/ProxyMixer, Overviews/JITLib

description::
Generally a strong::proxy:: is a placeholder for something. A node proxy is a placeholder for something strong::playing on a server:: that writes to a limited number of busses (e.g. a synth or an event stream). NodeProxy objects can be replaced and recombined while they play. Also they can be used to build a larger structure which is used and modified later on. Overview: link::Overviews/JITLib::

When accessed, ProxySpace returns a link::Classes/NodeProxy::. A similar class without environment: link::Classes/Ndef::

For more examples see: link::Tutorials/JITLib/proxyspace_examples::, link::Tutorials/JITLib/jitlib_basic_concepts_01::

For GUI overview, see link::Classes/ProxyMixer::. See link::Classes/NodeProxy:: for many relevant methods.

subsection::First Example

code::
s.boot;

p = ProxySpace.new;
p.fadeTime = 2; // fadeTime specifies crossfade
p[\out].play; // monitor an empty placeholder through hardware output
// set its source
p[\out] = { SinOsc.ar([350, 351.3], 0, 0.2) };
p[\out] = { Pulse.ar([350, 351.3] / 4, 0.4) * 0.2 };
p[\out] = Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350));

// route one proxy through another:
p[\out] = { Ringz.ar(p[\in].ar, [350, 351.3] * 8, 0.2) * 4 };
p[\in] = { Impulse.ar([5, 7]/2, [0, 0.5]) };

p.clear(3); // clear after 3 seconds
::

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::server
a link::Classes/Server:: object. Note that on remote computers the clock must be in sync.

argument::name
a link::Classes/Symbol::. If a name is given, the proxy space is strong::stored:: in code::ProxySpace.all:: under this name.

argument::clock
for event-based or beat-sync playing use a link::Classes/TempoClock::.

method::push
replace the currentEnvironment with a new ProxySpace and strong::clear:: the current one, if it is a ProxySpace (this is to avoid piling up proxy spaces).

In order to move to another ProxySpace while keeping the current, use strong::pop:: and then strong::push:: a new one. To have multiple levels of proxy spaces, use strong::.new.push;::

method::pop
restore the previous currentEnvironment

method::clearAll
clear all registered spaces

InstanceMethods::

subsection::Play back and access

method::play
returns a group that plays the link::Classes/NodeProxy:: at that strong::key::.

argument::key
a link::Classes/Symbol::

argument::out
output channel offset

argument::numChannels
play this number of channels.

method::record
returns a link::Classes/RecNodeProxy:: that records the NodeProxy at that key.

method::ar, kr
returns a NodeProxy output that plays the NodeProxy at that key, to be used within a function used as input to a node proxy

method::wakeUp
when the proxyspace is created without a running server this method can be used. To run it (internally this is done by link::#-play:: as well).

method::fadeTime
set the fadetime of all proxies as well as the default fade time

method::clock
set the clock of all proxies as well as the default clock.

method::quant
set the quant of all proxies as well as the default quant.

method::free
free all proxies (i.e. free also the groups, do not stop the monitors)

method::release
release all proxies (i.e. keep the groups running)

method::stop
stop all proxies (stop only monitors, do not stop synths)

method::end
end all proxies (free and stop the monitors)

method::clear
clear all proxies and remove them from the environment. This frees all buses. If a fadeTime is given, first fade out, then clear.

method::add
add the ProxySpace to the repository (name required)

method::remove
remove the ProxySpace from the repository

subsection::Setting the sources

The strong::rate:: and strong::numChannels:: of the link::Classes/NodeProxy:: determined in a lazy way from the first object put into this environment (see helpfile). Once it is created it can only be set to a function that returns the same rate and a number of channels equal to the intial one or smaller. For details, see link::Tutorials/JITLib/the_lazy_proxy::.

method::put
Gets the NodeProxy at strong::key:: (if none exists, returns a new one) and sets its source to strong::obj::. For how this works, see also link::Classes/LazyEnvir:: and link::Classes/NodeProxy::.

method::at
Return the proxy source object at that key.

subsection::garbage collecting

method::clean
free and remove all proxies that are not needed in order to play the ones passed in with 'exclude'. if none are passed in, all proxies that are monitoring (with the .play message) are kept as well as their parents etc.

method::reduce
free all proxies that are not needed in order to play the ones passed in with 'to'. if none are passed in, all proxies that are monitored (with the play message) are kept as well as their parents etc.

subsection::making copies

method::copy
Copies the environment into a new one, with each proxy being copied as well (See: link::Classes/NodeProxy#-copy::). Also the instance variables that determine the ProxySpace behaviour are included, such as server, fadeTime, quant, reshaping (this happens in the code::copyState:: method).

code::
p = ProxySpace.push(s.boot);
p.reshaping = \elastic;
~out.play;
~out = { Blip.ar(~freq, ~numharm) };
~freq = 70;
~numharm = { MouseX.kr(2, 100, 1) };

q = p.copy; p.pop; q.push;

q.reshaping.postln; // also elastic
~out.play;
~freq = { MouseY.kr(2, 1000, 1) * [1, 1.2] };

p.end; q.end;
::


subsection::Writing code

method::document
creates a new document with the current proxyspace state. This does not allow open functions as proxy sources. see: link::Tutorials/JITLib/jitlib_asCompileString::.

argument::keys
list of keys to document a subset of proxies

argument::onlyAudibleOutput
a boolean.

argument::includeSettings
a boolean.

method::asCode

If proxyspace is globally accessible, this posts a code string that can access it.

code::
p = ProxySpace.push(s.boot);
p.reshaping = \elastic;
p.asCode;
p.pop;

Ndef(\x); // initializes an Ndef proxyspace for default server
Ndef.all[\localhost]; // access that proxyspace
Ndef.all[\localhost].asCode; // posts as valid code
::

Examples::

code::
// ProxySpace returns instances of NodeProxy:
a = NodeProxy(s) 	is equivalent to ~a;
a.source = ...		is equivalent to ~a = ...
a[3] = ...		is equivalent to ~a[3] = ...

// the two expressions are equivalent:
~out = something;
currentEnvironment.put(\out, something);
::

code::
// examples

p = ProxySpace.push(s.boot); // use ProxySpace as current environment.

~out.play;

~out = { SinOsc.ar([400, 407] * 0.9, 0, 0.2) };

~out = { SinOsc.ar([400, 437] * 0.9, 0, 0.2) * LFPulse.kr([1, 1.3]) };

~out = { SinOsc.ar([400, 437] * 0.9, 0, 0.2) * ~x.kr(2) };

~x = { LFPulse.kr([1, 1.3] * MouseX.kr(1, 30, 1)) };

~out = { SinOsc.ar([400, 437] * Lag.kr(0.1 + ~x, 0.3), 0, 0.2) * ~x };

p.fadeTime = 5;

~out = { SinOsc.ar([400, 437] * 1.1, 0, 0.2) * ~x.kr(2) };

p.clear(8); // end and clear all in 8 sec.


p.pop; // move out.
::


class:: ProxySynthDef
summary:: synth def that wraps ugen graph
categories:: JITLib>NodeProxy
related:: Classes/NodeProxy

description::
(used internally by link::Classes/NodeProxy::)

for inner workings see link::Tutorials/JITLib/jitlib_fading::

ClassMethods::

method::new

argument::name
like in link::Classes/SynthDef::. todo: add variants.

argument::func
like in link::Classes/SynthDef::. todo: add variants.

argument::rates
like in link::Classes/SynthDef::. todo: add variants.

argument::prependArgs
like in link::Classes/SynthDef::. todo: add variants.

argument::makeFadeEnv
if true it constructs a fader envelope and adds controls for gate and fadeTime

argument::channelOffset
a constant offset that is added to the out number

argument::chanConstraint
max numChannels for the synthdef. If ugenfunc returns a larger array, it wraps

argument::rateConstraint
a symbol like \audio, \control or \scalar.

method::sampleAccurate
always use link::Classes/OffsetOut::, if set to true (default: false)

Examples::

code::
a = ProxySynthDef("xtest", { SinOsc.ar(400) * 0.1 });

a.add;

x = Synth("xtest");
x.release;


/*

	if the resulting number of channels is larger than a given channelConstraint,
	it behaves according to the rate: audio rate signals are wrapped around
	a smaller channel size, control rate signals are not (the exceeding channels are left out)

*/
::


class:: Pseed
summary:: set the random seed in subpattern
related:: Reference/randomSeed
categories:: Streams-Patterns-Events>Patterns>Language Control

description::

Set the random generator seed of the resulting stream.

ClassMethods::

method::new

argument::randSeed
integer number, pattern or stream that returns an integer number.

note::
randSeed is always treated as a pattern/stream. If you provide a single, constant seed value, it will behave as an infinite-length stream. This will cause the subpattern to be embedded an infinite number of times. Compare:

code::
// Pwhite repeats its three values forever
Pseed(1000, Pwhite(1, 10, 3)).asStream.nextN(10);

// Pwhite runs once:
// the output stream consists of three values, then 'nil' ad infinitum
Pseed(Pn(1000, 1), Pwhite(1, 10, 3)).asStream.nextN(10);
::
::

argument::pattern

Examples::

code::
a = Pseed(1972, Prand([1,2,3], inf));

b = a.asStream;
10.do({ b.next.post });

c = a.asStream;
10.do({ c.next.post });


// using a seed pattern as input:

a = Pseed(Pseq([1812, 1912], inf), Prand([1,2,3], 5));

b = a.asStream;
2.do({ 5.do({ b.next.post });"".postln;  });

c = a.asStream;
2.do({ 5.do({ c.next.post });"".postln;  });


// outer thread is independant:

a = Pseed(Prand([1534, 1600, 1798, 1986, 2005], inf), Pshuf([1, Prand([7, 9], 2), 1, 2, 3], 1));

// returns random streams
b = a.asStream;
2.do({ 5.do({ b.next.post });"".postln;  });

c = a.asStream;
2.do({ 5.do({ c.next.post });"".postln;  });


// Some examples of how Pseed can be used in music.
(
SynthDef.new(\varsaw, {
	arg dur, attack=0.01, release=1.0,
	t_gate=1, out, freq=442, cutoff=5500,
	rq=1, pan=0.0, amp=0.5, width=0.1;

	var env = EnvGen.kr(Env.perc(attack, release), t_gate, timeScale: dur, doneAction: 2);
	var sig = VarSaw.ar(freq: freq, mul: env, width: width);
	sig = RLPF.ar(sig, cutoff.clip(20.0, 20000.0), rq.clip(0.0,1.0));
	sig = Pan2.ar(sig, pan);
	Out.ar(out, sig * amp);
}).add;
)

(
Pdef(\varsawPat,
	Pseed(490, // This number is the seed.
		Pbind(*[
			instrument: \varsaw,
			attack: Plprand(0.01, 1.0),
			release: Pwrand([0.5, 8], [8, 1].normalizeSum, inf),
			dur: 1 / Pstutter(Phprand(5, 11), Plprand(5, 11)),
			freq: 100 * Plprand(1, 9),
			width: Phprand(0.0, 0.5),
			cutoff: Phprand(20, 5500),
			pan: Pmeanrand(-1.0, 1.0),
		])
	)
).play
)

// Reevaluate the above pattern to hear the same start. An infinity of variations unfold from a single number.
// Change the seed for another infinite deterministic stream of choices.


(
SynthDef(\drum, {|out, dur, t_gate =1, pew=1, sustain=1, pan, fed=0, tun, amp = 1 |
	var env, freq, sig;
	tun = ((tun>0)*tun) + ((tun<1)*3);
	freq = (tun*10).midicps;
	env = EnvGen.ar(Env.linen(0.01, 0, 1, 1, -3), t_gate, timeScale: dur , doneAction: 2);
	sig = LPF.ar(SinOscFB.ar(XLine.ar(freq.expexp(10, 2000, 1000, 8000), freq, 0.025/pew), fed), 9000);
	sig = Pan2.ar(sig, pan);
	Out.ar(out, sig * amp);
}).add
)

(
Pdef(\drumPat,
	Pseed(9223372036854775807, // This is the highest 64 bit number.
		Psync(
			Pbind(*[
				instrument: \drum,
				tun: Pstutter(Plprand(4, 8), Plprand(0.0, 8.0).round(1/8)),
				amp: Plprand(-7.5.dbamp, -1.5.dbamp),
				dur: 1 / Pstutter(Phprand(5, 11), Pwhite(5, 11)),
				legato: Plprand(0.75, 4.0),
				pan: Prand([Phprand(0.0, 0.5, 1), Plprand(0.5, 1.0, 1)], inf),
				//pew: 0.4,
				//pew: Phprand(0.4, 10.0),
			]), 1, 2.0, // Loop length is the second number here.
		)
	)
).play(quant:1);
)

/*
When Pseed wraps around a whole pattern like in the above example the values are being generated for the parameters from top to bottom.
Uncommenting the static pew value does not change the pattern but uncommenting the line below with the stochastic choice does.
The pew parameter is now receiving the value that would have gone to the tun parameter and so this alternate timeline diverges more and more
as time passes.
*/

(
Pdef(\varsawPat,
	Pbind(*[
		instrument: \varsaw,
		attack: Plprand(0.01, 1.0),
		release: Pwrand([0.5, 8], [8, 1].normalizeSum, inf),
		dur: 1 / Pseed(490, Pstutter(Phprand(5, 11), Plprand(5, 11))), // Pseed used on a single parameter.
		amp: Plprand(-18.dbamp, -12.dbamp),
		freq: 100 * Plprand(1, 9),
		width: Plprand(0.0, 0.5),
		cutoff: Phprand(20, 5500),
		pan: -1,
	])
).play(quant: 1);

Pdef(\drumPat,
	Pbind(*[
		instrument: \drum,
		tun: Pstutter(Plprand(4, 8), Plprand(0.0, 8.0).round(1/8)),
		fed: Plprand(0.0, 1.0),
		amp: Plprand(-18.dbamp, -12.dbamp),
		dur: 1 / Pseed(490, Pstutter(Phprand(5, 11), Plprand(5, 11))), // Same seed, same rhythm.
		legato: Plprand(0.75, 4.0),
		pan: 1,
	])
).play(quant:1);
)

/*
In the above example Pseed is used as a kind of "data sharing" strategy. The two patterns aren't actually sharing data. They are both
using the same seed to generate all future stochastic choices for the dur parameter.
All other parameters in the two patterns are unaffected.
*/

::


class:: Pseg
summary:: timed embedding of values
related:: Classes/Ptime, Classes/Pstep, Classes/Env
categories:: Streams-Patterns-Events>Patterns>Time

description::

Pseg defines a function of time as a breakpoint envelope using the same parameters as link::Classes/Env::. These patterns can be used to describe tempo or dynamic variations independent of the rhythmic patterns that express them.

ClassMethods::

method::new

argument::levels
A link::Classes/Pattern:: that returns the levels. The first level is the initial value of the envelope, all subsequent values are interpolated.

argument::durs
A link::Classes/Pattern:: that returns segments durations in beats.

argument::curves
a link::Classes/Symbol::, link::Classes/Float::, or an link::Classes/Array:: of those. Determines the shape of the segments.

argument::repeats
a number.

The possible values are:
table::
## code::\step:: || || flat segments.
## code::\linear:: || code::\lin:: || linear segments, the default.
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segments.
## code::\welch:: || code::\wel:: || sinusoidal segments shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment.
## code::\cubed:: || code::\cub:: || cubed segment.
## a link::Classes/Float:: || || a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.
## an link::Classes/Array:: of symbols or floats || || curvature values for each segment.
::

Examples::

code::
// change a parameter
(
Pbind(
	\note,  Pseg( Pseq([1, 5],inf), Pseq([4, 1],inf), \linear),
	\dur, 0.1
).play;
)

(
Pbind(
	\freq,  Pseg( Pseq([400, 1500], inf), Pseq([4, 4],inf), Pseq([\linear, \exp],inf)),
	\dur, 0.1
).play;
)
::


class:: Pselect
summary:: Filters values returned by a source pattern.
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pcollect, Classes/Preject, Classes/Collection#-select

description::
This pattern will filter the source pattern using the supplied function strong::func::.

Values from the source pattern will be passed to strong::func::. Pselect will only return that value if the strong::func:: returns true.

This is the pattern library's equivalent of link::Classes/Collection#-select#select::.

classmethods::

method:: new
argument:: func
A link::Classes/Function:: that takes one parameter (the next value from strong::pattern::) and returns a boolean.

argument:: pattern
The source link::Classes/Pattern::.


examples::
code::
(
var a, b;
a = Pselect({ arg item; item != 2 }, Pseq(#[1, 2, 3],inf));
x = a.asStream;
9.do({ x.next.postln; });
)
::

The message code::select:: returns a Pselect when passed to a pattern.
code::
(
var a, b;
a = Pseq(#[1, 2, 3],inf).select({ arg item; item != 2 });
a.postln;
x = a.asStream;
9.do({ x.next.postln; });
)
::


class:: Pseq
summary:: sequentially embed values in a list
related:: Classes/Pser
categories:: Streams-Patterns-Events>Patterns>List

description::

Cycles over a list of values. The repeats variable gives the number of times to repeat the entire list.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], 2);	// repeat twice
b = a.asStream;
7.do({ b.next.postln; });
)
::

Pseq also has an offset argument which gives a starting offset into the list.
code::
(
var a, b;
a = Pseq([1, 2, 3, 4], 3, 2);	// repeat 3, offset 2
b = a.asStream;
13.do({ b.next.postln; });
)
::

You can pass a function for the repeats variable that gets evaluated when the stream is created.
code::
(
var a, b;
a = Pseq([1, 2], { rrand(1, 3) });	// repeat 1,2, or 3 times
b = a.asStream;
7.do({ b.next.postln; });
)
::

If you specify the value inf for the repeats variable, then it will repeat indefinitely.
code::
(
var a, b;
a = Pseq([1, 2, 3], inf);	// infinite repeat
b = a.asStream;
10.do({ b.next.postln; });
)
::


Pseq used as a sequence of pitches:
code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::


class:: Pser
summary:: sequentially embed values in a list
related:: Classes/Pseq
categories:: Streams-Patterns-Events>Patterns>List

description::

is like link::Classes/Pseq::, however the repeats variable gives strong::the number of items:: returned instead of the number of complete cycles.

Examples::

code::
(
var a, b;
a = Pser([1, 2, 3], 5);	// return 5 items
b = a.asStream;
6.do({ b.next.postln; });
)

//Pser used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pser([Pser(#[60, 61, 63, 65, 72], 3)], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::


class:: Pseries
summary:: arithmetic series pattern
related:: Classes/Pgeom
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a stream that behaves like an arithmetic series.

ClassMethods::

method::new

argument::start
start value.

argument::step
addition factor.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pgeom(1.0, 1.1, inf);
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pseries(300, 20, 70).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val]);
		0.02.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\freq, Pseries(800.0, Pbrown(-1.0, 3.0, 0.1, inf), inf)
).play;
)
::


class:: Pset
summary:: event pattern that sets values of one key
related:: Classes/Pbindf, Classes/Psetp
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Pset sets a value in an event stream. It acts like one key in a link::Classes/Pbindf::.
code::
(
var a, b;
a = Pset(\freq, 801, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

ClassMethods::

method::new

argument::name
the key.

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern.

Examples::

code::
//Pset overrides incoming values:

(
var a, b;
a = Pset(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


(
var a, b;
a = Pset(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
a = Pset(\freq, Pseq([500, 600, 700], inf), a);
a = Pset(\legato, Pseq([0.01, 1],inf), a);
a.play;
)
::


class:: Psetp
summary:: event pattern that sets values of one key
related:: Classes/Pbindf, Classes/Pset
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Sets a value in an event stream until it ends, repeats this with new values until the value stream ends.

ClassMethods::

method::new

argument::name

argument::value
can be a pattern, a stream or an array. The resulting stream ends when that incoming stream ends.

argument::pattern

Examples::

code::
(
var a, b;
a = Psetp(\freq, Pseq([801, 1008],inf), Pbind(\dur, Pseq([0.5, 0.111, 0.22])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)

//Psetp overrides incoming values:

(
var a, b;
a = Psetp(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, Pseq([0.5, 0.3, 0.1]), \instrument, \sinegrain);
a = Psetp(\freq, Pseq([500, 600, 700], inf), a);
a.play;
)
::


class:: Psetpre
summary:: set values of one key in an event before it is passed up
related:: Classes/Pset, Classes/Psetp
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Sets a value in an event, before it is passed up the stream. To set the value after it has been passed to the stream, use link::Classes/Pset::.
code::
(
var a, b;
a = Psetpre(\freq, 801, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

ClassMethods::

method::new

argument::name
the key

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern

Examples::

code::
//Psetpre does not override incoming values:

(
var a, b;
a = Psetpre(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


(
var a, b;
a = Psetpre(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
a = Psetpre(\freq, Pseq([500, 600, 700], inf), a);
a = Psetpre(\legato, Pseq([0.01, 1],inf), a);
a.play;
)
::


class:: Pshuf
summary:: sequentially embed values in a list in constant, but random order
related:: Classes/Prand
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a shuffled version of the strong::list:: item by item, with n strong::repeats::.

Examples::

code::
(
var a, b;
a = Pshuf([1, 2, 3, 4, 5], 3);	// repeat 3 times
b = a.asStream;
16.do({ b.next.postln; });
)

//Pshuf used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(Pshuf(#[60, 60, 60, 61, 63, 65, 72], 4), inf).asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, a.next.midicps]);
	0.15.wait;
	})
}).play;
)
::


class:: Pslide
summary:: slide over a list of values and embed them
related:: Classes/Ptuple
categories:: Streams-Patterns-Events>Patterns>List

ClassMethods::

method::new

argument::list

argument::repeats
number of segments.

argument::len
length of each segment.

argument::step
how far to step the start of each segment from previous. step can be negative.

argument::start
what index to start at.

argument::wrapAtEnd
if true (default), indexing wraps around if goes past beginning or end. If false, the pattern stops if it hits a nil element or goes outside the list bounds.

Examples::

code::
(
var a, b;
a = Pslide([1, 2, 3, 4, 5], inf, 3, 1, 0);
x = a.asStream;
13.do({ x.next.postln; });
)

//Pslide used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
c = Pslide(#[1, 2, 3, 4, 5], inf, 3, 1, 0) * 3 + 67;
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.17.wait;
	})
}).play;
)
::


class:: Pspawn
summary:: Spawns sub-patterns based on parameters in an event pattern
related:: Classes/Pspawner, Classes/Spawner
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Pspawn is a pattern-based version of link::Classes/Pspawner::. Where Pspawner uses a Routine-style function to determine when and how to spawn child patterns into the result stream, Pspawn uses an event pattern to determine the actions to take.

Recommended to read the link::Classes/Pspawner:: help file to become familiar with pattern spawning capabilities.

note::
Important: There are two kinds of events involved in Pspawn:

definitionList::
## strong::parent:: events
|| which specify the pattern to embed, how to embed it (in parallel or sequence), and how long to wait until the next action;
## strong::child:: events
|| which produce the resulting notes (or take other actions on the server).
::
::

Of these, only the child events are returned to the event stream player during play. The parent events are used strictly internally to control spawning behavior. The parent and child event streams do not mix together. Thus pattern composition ( link::Classes/Pchain:: ) and parallelization ( link::Classes/Ppar:: ) may be used without special handling. It is up to the user to be aware of whether the parent or child stream should be subject to further manipulation, and put that manipulation in the right place. If it is to affect the child stream, it should enclose the entire Pspawn; for the parent stream, it should be inside Pspawn. (See the link::#examples:: below.)

Pspawn uses the following items in the parent pattern:
definitionList::
## method
|| The action to call on the spawner object. Currently supported: wait, seq, par, suspendAll.
## delta
|| How long to wait until the next action.
## dict
|| If 'pattern' is given as a symbol (see below), this is the dictionary in which the pattern will be looked up. If not specified, the link::Classes/Pdef:: collection will be used.
## pattern
|| If 'method' is seq or par, this is a pattern or function to be embedded, according to the following rules.
::

table::
## strong::'pattern' in the event:: || strong::Resulting behavior::
## A link::Classes/Function:: : code:: { ... } :: || The function should return a pattern; this pattern is spawned.
## A link::Classes/Ref:: to a pattern: code::`Pbind(...):: || The referenced pattern is spawned.
## A link::Classes/Symbol:: : code::\scaleUp:: || The pattern is looked up in the event's 'dict'.
::

subsection::Using references to protect patterns from embedding

Normally, when a pattern appears inside another pattern, the subpattern is embedded in the main output stream. It is not visible to the outside world as a pattern in itself; only its values appear.

code::
Pseq([Pwhite(0, 9, 5), Pwhite(10, 19, 5)], 1).asStream.all;
::

When using Pspawn, a sub pattern must be returned directly into the event. To accomplish this, every such pattern should be wrapped in a link::Classes/Ref:: :

code::
Pseq([`Pwhite(0, 9, 5), `Pwhite(10, 19, 5)], 1).asStream.all;
::

Hint: link::Classes/Pfunc:: is another good way to wrap patterns, because it simply returns its result values without further embedding. See the first example.

ClassMethods::

method::new

argument::pattern
An event pattern (typically link::Classes/Pbind::) encapsulating the desired spawning behavior. Parameters in this event are described below.

argument::spawnProtoEvent
The event prototype against which the pattern is evaluated. Good for giving default values that should apply to all spawning (parent) events.

Examples::

code::
// Play overlapping major scales, up and down
(
p = Pspawn(Pbind(
		// Pbind returned by Pfunc is not embedded, just placed in the event
		// So, it can be spawned
	\pattern, Pfunc { Pbind(\degree, Pseries(rrand(0, 10), #[-1, 1].choose, rrand(4, 10)), \dur, 0.125) },
	\delta, Pwhite(1, 5, inf) * 0.125,
	\method, \par
)).play;
)

p.stop;


// Same, using a dictionary of patterns, changing dur rhythm also
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Pspawn(Pbind(
	\pattern, Prand([\up, \down], inf),
	\delta, Pwhite(1, 5, inf) * 0.125,
	\method, \par
), (dict: patternChoices)).play;
)

p.stop;


// Using pattern composition (perhaps gratuitously) to build the parent events
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Pspawn(Pchain(
	Pbind(
		\pattern, Prand([\up, \down], inf),
		\method, \par
	),
	Pbind(
		\delta, Pwhite(1, 5, inf) * 0.125
	)
), (dict: patternChoices)).play;
)

p.stop;


// Play parallel scales in the left channel and sequentially-arranged scales in the right
// This means parallelizing (Ppar) the child streams; thus Ppar surrounds a pair of Pspawns

// Handling of \pan is interesting: \pan needs to be a property of the patternChoices items
// It is NOT a property of the spawning events
// To reuse patternChoices, the Pspawns wrap the base patterns in a Pbindf, which adds new values
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Ppar([
	Pspawn(Pbind(
			// intermediate value
		\patternKey, Prand([\up, \down], inf),
			// pattern is selected and pan applied here
		\pattern, Pfunc { |ev| Pbindf(ev.dict[ev.patternKey].value, \pan, -1) },
		\delta, Pwhite(1, 5, inf) * 0.125,
		\method, \par
	), (dict: patternChoices)),
	Pspawn(Pbind(
		\patternKey, Prand([\up, \down], inf),
		\pattern, Pfunc { |ev| Pbindf(ev.dict[ev.patternKey].value, \pan, 1) },
		\delta, Pwhite(1, 5, inf) * 0.125,
		\method, \seq
	), (dict: patternChoices)),
]).play;
)

p.stop;
::


class:: Pspawner
summary:: dynamic control of multiple event streams from a Routine
related:: Classes/Pspawn
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Pspawner allows a routine to dynamically start and stop subpatterns.

ClassMethods::

method::new

argument::routineFunc
The function defines a link::Classes/Routine:: that receives a link::Classes/Spawner:: as its sole argument. All control of subpatterns is through the spawner.

link::Classes/Spawner:: responds to the messages:

definitionlist::
## par ||
Begin an event stream in parallel to the routine. If delta is non-zero, the pattern will begin that many beats after 'now', provided that now + delta is later than the next event that the Spawner will generate. The method returns the stream. This may be called from any object.

## seq ||
Run the entire pattern and then return control to the routine.

## wait ||
Wait strong::dur:: seconds and then return control to the routine.

## suspend ||
Find the stream in the Spawner and stop it, returns nil if the stream is not found, the stream otherwise.

## suspendAll ||
Stop all substreams of the Spawner.
::

note::
These are also documented in link::Classes/Spawner::.
::

Examples::

code::
// example 1: a simple Pspawner

(
Pspawner({ | sp |

// parallel in-c'ish pulses will run throughout the example
	sp.par(Pbind(*[ degree: [0,7], octave: 7, dur: 0.2, db: Pseq([-20, -24, -22, -24], inf)]) );

// scales in sequence with pauses
	sp.seq(
		Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2])
	);
	sp.wait(0.4);
	sp.seq(
		Ppar([
			Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2, octave: 4]),
			Pbind(*[ degree: Pseq((0..7).reverse.mirror), dur: 0.2])
		])

	);
	sp.wait(3);
	sp.seq(
		Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2, mtranspose: (0,2..14)])
	);

// scales overlaped at 0.4 second intervals

	10.do {
		sp.par(
			Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2])
		);

		sp.wait(0.4)
	};
	sp.wait(1.6);
	sp.suspendAll;
}).play
)


(
// example 2: create 6 streams at 4 second intervals
// then delete them in the order they were created

Pspawner({ | sp |
	var streams, stream;
	// start patterns, collect the resultant event streams
	streams = [2, 3, 4, 6, 7, 8].collect { | i |
		stream = sp.par(Pbind(*[
			harmonic: i,
			ctranspose: 	[0, 1, 3]/40,
			octave:	Pbrown(2,8,2), dur: 1/i, db: -30
		]) );
		sp.wait(4);
		stream;
	};

	// now stop those streams one by one
	streams.do { | s | sp.suspend(s); sp.wait(4) };
}).play
)

(
// example 3: define a Pspawner and use Pattern manipulations
p = Pspawner({ | sp |
	var pat = Pbrown( -7, 7, 3);

	sp.par(Pbind(*[octave: 5, degree: pat, dur: 1/4]) );
	sp.wait(2);
	sp.par(Pbind(*[octave: 6, degree: pat, dur: 1/8]) );
	sp.wait(3);
	sp.par(Pbind(*[octave: 7, degree: pat, dur: 1/6, db: -20]) );
	sp.wait(4);
	sp.par(Pbind(*[octave: 4, degree: pat, dur: 1/4]) );

	sp.wait(8);
	sp.suspendAll;
});
)

// play the basic patten
p.play;

(
// manipulate basic pattern with Pchain
Pchain(
	Pbind(*[mtranspose: Pkey(\mtranspose) + Pdup(8, Prand([0,[0,3,-2],[0,2,4]], inf)) ] ), //make some notes into triads
	Pbind(*[ctranspose: Pwhite(-0.1, 0.1)]), //add random detuning to notes
	Pbind(*[\scale, Scale.minor]), //alter the scale
	Pn(Pseq([p, (type:\rest, dur: 1.0)]) ), //repeat the pattern after a 1 second pause
	Pbind(*[
		db: Pstep(Pseq([-10, -13, -13, -11, -13, -13], inf), 0.1) - 10,
		mtranspose: Pstep(Pwhite(-7,7), Prand([5,4,2],inf) ) //random modal transposition
	])
).play(protoEvent: Event.default)
)

// example 4: altering the contents of the Pspawner from separate code

(
a = Pspawner({ |sp |
	c = sp; 			// store the Spawner in a global variable
	100.do{ sp.wait(1) }
});
a.play;
)

(					// c will not be valid until the Pspawner has run
b = c.par(				// now start a pattern in spawner
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)
c.suspend(b)				// we can suspend and resume the stream
c.par(b)
c.suspend(b)
(
b = c.par(				// or just start up a new pattern
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)

// example 5: Spawner can be used directly in the manner of Pspawner.
// This allows external code to access to the spawner whether or not it has run
(
c = Spawner({ |sp |
	100.do{ sp.wait(1) }
});
b = c.par(				// now start a pattern in spawner
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
c.play;					// in this case, c is always valid
)
c.suspend(b)				// we can suspend and resume the stream
c.par(b)
c.suspend(b)
(
b = c.par(				// or just start up a new pattern
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)

(
Pspawner({ | sp |
	(1..5).do { | i |
		sp.par(Pbind(*[
			octave: i + 2,
			degree:	Pwhite(0,7), dur: 1/i, db: -30
		]) );
		sp.wait(4);
	};
	sp.suspendAll;
}).play
)
::


class:: Pstep
summary:: timed, sample-and-hold embedding of values
related:: Classes/Pseg
categories:: Streams-Patterns-Events>Patterns>Time

description::

Pstep is a "sample and hold" pattern: The value returned by teletype::next:: is held at each value in teletype::levels:: for the corresponding duration in teletype::durs::. This cycling is similar to link::Classes/Ptuple::, in that the current repeat ends when eiher pattern returns nil.

Pstep measures elapsed time using the thread's logical time. That is, it assumes it will be evaluated only exactly when needed, not before.

See link::Classes/Pseg:: for a pattern whose value changes like an link::Classes/Env::.

ClassMethods::

method::new
Create an instance of Pstep.

argument::levels
A number, collection, or link::Classes/Pattern:: that returns the levels.

argument::durs
A number, collection, or link::Classes/Pattern:: that returns segments durations in beats.

argument::repeats
An integer, or teletype::inf::.

Examples::

code::
(
// select a chord and duration and repeat it for a random time interval
p = Pstep(
	Pbind(
		\ctranspose, [0, 4, 7],
		\note,	Pwhite(0, 12),
		\dur,	Prand([0.2, 0.4, 0.8], inf)
	),
	Prand([1, 2, 4], inf)/4
);
Ppar([p, p]).play;
)
// change degree independently of number of events that have been playing

(
Pchain(
	Ppar([
		Pbind(
			\degree, Pbrown(0, 12, 1),
			\dur, Pstep( Pseq([0.1, 0.2, 0.4, 0.8, 1.6], inf), 3.2)
		),
		Pbind(
			\degree, Pbrown(0, 20, 1),
			\dur, Pstep( Pseq([0.1, 0.2, 0.4, 0.8, 1.6], inf), 4.5)
		)
	]),
	Pbind(
		\scale, Pstep(Pseq([ [0, 2, 4, 5, 7, 9, 11], [0, 1, 2, 3, 4, 5, 6]], inf), 5),
		\db, Pstep(Pseq([2, -2, 0, -2], inf), 0.25) - 10
	)
).play;
)

// use a simple pattern
(
Pchain(
	Ppar([
		Pbind(
			\octave, [5, 6] + Prand([0, 0, \r], inf),
			\degree, Prout({ | ev | loop { ev = Pseq(ev[\degree]).embedInStream } }),
			\dur,	Prout({ loop { Pseq([0.2, 0.2, 0.2, 0.2, 0.3].scramble).embedInStream } })
		),
		Pbind(
			\octave, 4,
			\legato, 1.2,
			\dur, Prout({ loop { Pseq([0.2, 0.2, 0.2, 0.2, 0.3].scramble * 5).embedInStream }})
		),
	]),
	Pstep(Pbind(
		\db, Pseq([0, -4, -2, -4, -3, -4, -3, -4], inf) - 20
	), 0.2),
	Pstep(
		Pbind(
			\degree, 	Pfunc({ {10.rand}.dup(10) }),
			\scale,	Pfunc({ {rrand(1, 2)}.dup(7).integrate })
		),
		5
	)
).play
)



// change one parameter
(
Pbind(
	\degree, Pstep(Pseq([1, 2, 3, 4, 5]), 1.0).trace,
	\dur, Pseries(0.1, 0.1, 15)
).play;
)


// change degree independant of number of events that have been playing

(
var a, b;
a = Pbind(
	\degree, Pstep(Pseq([0, 2b, 3], 1), 1.0),
	\dur, Prand([0.2, 0.5, 1.1, 0.25, 0.15], inf)
);
b = Pbind(
	\degree, Pseq([0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pseq([Event.silent(1.25), Ppar([a, b])], inf).play;
)



// test tempo changes

(
var a, b;
a = Pbind(
	\degree, Pstep(Pseq([0, 2b, 3], 1), 1.0),
	\dur, Prand([0.2, 0.5, 1.1, 0.25, 0.15], 9)
);
b = Pbind(
	\degree, Pseq([0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);

Ppar([a, b], inf).play;
)


SystemClock.sched(0, { TempoClock.default.tempo = [1, 2, 3, 5].choose.postln; 2 });

TempoClock.default.tempo = 1.0;



// timing test:
// parallel streams


(
var a, b, x;
var times, levels;

SynthDef(\pgrain,
	{ arg out = 0, freq=800, sustain=0.001, amp=0.5, pan = 0;
		var window;
		window = Env.sine(sustain, amp);
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq) * EnvGen.ar(window, doneAction: Done.freeSelf),
				pan
			)
		)
	}
).add;

times = Pseq([3.4, 1, 0.2, 0.2, 0.2], inf);
levels = Pseq([0, 1, 2, 3, 4], inf);

a = Pstep(levels, times);
b = Pbind(\instrument, \pgrain, \octave, 7, \dur, 0.12, \degree, a);
x = times;

Ppar([b, Pset(\mtranspose, 2, b) ]).play;

b.play;
r {
	var z = x.asStream; // direct times
	0.5.wait;
	loop {
		z.next.wait;
		s.makeBundle(0.2, {
			Synth(\pgrain, [\freq, 3000, \sustain, 0.01]); // signal tone
		})
	}
}.play(quant:1)
)
::


class:: PstepNadd
summary:: pattern that returns combinatoric sums
related:: Classes/Pstep3add
categories:: Streams-Patterns-Events>Patterns>Time

description::

Combines an arbitrary number of patterns by summing (depth first traversal). When a stream ends it is recreated from its pattern until the top stream ends.

Examples::

code::
// comparing PstepNadd and Pstep3add (test)
(
x = PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;
y = Pstep3add(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;

50.do({ [x.next, y.next].postln });
)

// pattern return stream until the longest stream ended
(
x = PstepNadd(
		Plazy({ "pattern1.asStream".postln; Pseq([1, 2, 3], 2) }),
		Plazy({ "pattern2.asStream".postln; Pshuf([10, 20, 30, 40]) }),
		Plazy({ "pattern3.asStream".postln; Pseq([100, 200, 300]) }),
		Plazy({  Pseries(1, 1, 4) * 0.01 })
	).asStream;
150.do({ x.next.postln });
)

// if the last pattern loops it the combinatorics loop there:
x = PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300], inf)).asStream;
50.do({ x.next.postln });

// if the first pattern loops, the whole iteration loops as if it was used in a Pn(.., inf):
x = PstepNadd(Pseq([1, 2, 3], inf), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;
y = Pn(PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])), inf).asStream;
150.do({ [x.next, y.next].postln });

// sound example
(
Pbind(
	\octave, 4,
	\degree, PstepNadd(
				Pseq([1, 2, 3]),
				Pseq([0, -2, [1, 3], -5]),
				Pshuf([1, 0, 3, 0], 2),
				Pseq([1, -1], 5)
			),
	\dur, PstepNadd(
				Pseq([1, 0, 0, 1], 2),
				Pshuf([1, 1, 2, 1], 2)
		).loop * (1/8),
	\legato, Pn(Pshuf([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), inf),
	\scale, #[0, 1, 3, 4, 5, 7, 8]
).play;
)
::


class:: PstepNfunc
summary:: combinatoric pattern
related:: Classes/PstepNadd
categories:: Streams-Patterns-Events>Patterns>Time

description::

Combines an arbitrary number of patterns by evaluating a function (depth first traversal). When a stream ends it is recreated from its pattern until the top stream ends.

Examples::

code::
(
f = { arg vals;
	vals.postln;
};
x = PstepNfunc(f, [
		Pseq([1, 2, 3]), Pseq([4, 5, 6]), Pseq([7, 8, 9])
	]).asStream;
50.do({ x.next });
)

(
f = { arg vals;
	var r;
	r = vals.copy.removeAt(0);
	vals.do({ arg item;  r = item / r.squared * 10 });
	r
};
x = PstepNfunc(f,
	[
		Pseq([1, 2, 3], inf),
		Pseq([2, pi, 1]),
		Pseq([0.1, 3, 0.2, 3])
	]
	).asStream;

50.do({ x.next.postln });
)

// note that if the last pattern loops it will stick to that one:
(
f = { arg vals;
	vals.postln;
};
x = PstepNfunc(f, [Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300], inf)]).asStream;
50.do({ x.next });
)


(
f = { arg vals;
	vals.inject(1, { arg x, y; x * y })
};
x = PstepNfunc(f,
	[
		Pseq([1, 2, 3], inf),
		Pseq([2, pi, 1]),
		Pseq([0.1, 3, 0.2, 3])
	]
	).asStream;

50.do({ x.next.postln });
)
::


class:: Pstutter
summary:: repeat input stream values
related:: Classes/Pdup, Classes/Pn, Classes/Pattern#-dup
categories:: Streams-Patterns-Events>Patterns>Repetition

note::It is recommended to use link::Classes/Pdup:: instead. This class is retained for backwards compatibility.::
warning::Pstutter will return link::Classes/Pdup::::

description::
repeat each element n times.

code::
(
var a, b;
a = Pstutter(2, Pwhite(-1.0, 1.0));
x = a.asStream;
8.do { x.next.postln };
)
::

This is also a response to link::Classes/Pattern#-dup::


ClassMethods::

method::new
argument::n
The number of repeats for each new element. n may be a pattern, so the number of times can vary each iteration.

argument::pattern
the pattern to repeat.
returns:: link::Classes/Pdup::

Examples::


code::
// the first argument can be a pattern, too:
(
var a, b;
a = Pstutter(Prand([1, 2, 5], inf), Pwhite(-1.0, 1.0)); // repeat either once, twice, or five times
x = a.asStream;
20.do { x.next.postln };
)

// using event patterns:
(
SynthDef(\help_sinegrain,
	{ | out=0, freq=440, sustain=0.05 |
		var env;
        env = Env.perc(0.01, sustain, 0.2).kr(doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0.5pi, env))
	}).add;
)

(
a = Pbind(
	\instrument, \help_sinegrain,
	\note, Pxrand([0, 5, 7, 9], inf),
	\dur, 0.05,
	\sustain, 0.1
);
Pstutter(Pseq([1, 2, 3, 4], inf), a).trace.play;
)


// Pstutter used as a sequence of pitches

(
c = Pstutter(3, Pxrand([1, 2, 3], inf) * 4 + 65);
x = c.asStream;
Routine {
	loop {
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.12.wait;
	}
}.play;
)


// Voss algorithm for pink noise
// note that pattern.stutter(n) is a synonym for Pstutter(n, pattern)
a = Pwhite();
c = (2 ** (0..10)).sum { |n| a.stutter(n) };
c.asStream.nextN(1000).plot


// Voss-McCartney algorithm: balance calculation for realtime use
a = Pwhite();
c = (2 ** (0..10)).sum { |n| a.stutter(n.div(2).fin(1)) ++ a.stutter(n) };
c.asStream.nextN(1000).plot

::


class:: Psubdivide
summary:: partition a value into n equal subdivisions
related:: Classes/Pdup
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

A filter pattern designed for a stream of float durations.

Subdivides each duration by each subdivision and yields that value n times. A subdivision of 0 will skip the duration value, a subdivision of 1 yields the duration value unaffected.

Examples::

code::
(
a = Psubdivide(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,0,1,3,4,0],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
100.do({ x.next.postln; });
)


(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Psubdivide(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;

Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)


(
a = Psubdivide(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)
::

Frequencies like being divided too.

code::
(
a = Psubdivide(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq((80 + [ 0, 2, 3, 5, 7, 9, 10 ]).midicps ,inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, x.next.postln]);
		0.25.wait
	})
}).play(TempoClock.default);
)
::


class:: Pswitch
summary:: embed values in a list according to a pattern of indices
related:: Classes/Pswitch1
categories:: Streams-Patterns-Events>Patterns>List>Indexing

ClassMethods::

method::new
Pswitch chooses elements from the strong::list:: by a stream of indices ( strong::which:: ) and embeds them in the stream. If the element is itself a pattern, it first completely embeds it before looking for the next index.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], 2);
b = Pseq([65, 76]);
c = Pswitch([a, b, 800], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
24.do({ x.next.postln; });
)


//Pswitch used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq([73, 71, 69], 2);
b = Pseq([0, 0, 0, 4, 0]+64);
c = Pswitch([a, b, 75], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.18.wait;
	})
}).play;
)
::


class:: Pswitch1
summary:: embed values in a list according to a pattern of indices
related:: Classes/Pswitch
categories:: Streams-Patterns-Events>Patterns>List>Indexing

ClassMethods::

method::new
Pswitch1 chooses elements from the strong::list:: by a stream of indices ( strong::which:: ) and embeds them in the stream. If the element is itself a pattern, it embeds only one of its values for each index, and thus switches between all patterns in the list.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], inf);
c = Pswitch1([a, b, 800], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
24.do({ x.next.postln; });
)


//Pswitch used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pseq([73, 71, 69], inf);
b = Pseq([0, 0, 0, 4, 0]+64, inf);
c = Pswitch1([a, b, 75], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.18.wait;
	})
}).play;
)
::


class:: Psym
summary:: use a pattern of symbols to embed Pdefs
categories:: JITLib>Patterns, Live Coding
related:: Classes/Pdef

description::
for non-event patterns see link::Classes/Pnsym::. Overview: link::Overviews/JITLib::.

ClassMethods::

method::new

argument::pattern
a pattern that returns symbols or characters. Arrays are converted to parallel patterns ( link::Classes/Ppar:: ).

argument::dict
the dictionary to be used for lookup. By default, this is code::Pdef.all::, so one can embed Pdefs by name.

InstanceMethods::

method::dict
set the dictionary to be used.

Examples::

code::
(
// load a synthdef
s.boot;
SynthDef(\gpdef,
	{ |out=0, freq=440, sustain=0.05, amp=0.1, pan|
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

Pdef(\x, Pbind(\dur, Pn(0.25, 3), \instrument, \gpdef));
Pdef(\y, Pchain(Pbind(\degree, Prand([5, 9, 0], inf), \legato, Pseq([0.3, 2.2], inf)), Pdef(\x)));
Pdef(\z, Pchain(Pbind(\degree, Pseq([0, 2, 5, 7, 8, 9], 1)), Pn(Pdef(\y))));

Pdef(\play, Psym(Pseq([\x, \x, Prand([\x, \y]), \z, \y], inf).trace)).play;

// change root pattern:
Pdef(\x, Pbind(\dur, Pn(0.125, 2), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, Pn(0.125, 3), \instrument, \gpdef, \ctranspose, 2));
Pdef(\x, Pbind(\dur, Pn(0.125, 2), \instrument, \gpdef, \ctranspose, 0));

// change sequence:
Pdef(\play, Psym(Prand([Pseq([\x, \y], 5), Pseq([\z, \y], 5)], inf).trace)).play;

// use a sequence of characters:
Pdef(\play, Psym(Pseq("xxyxxzz", inf).trace)).play;

// play in parallel:
(
Pdef(\play, Psym(
	Prand([
		Pseq([[\x, \y], \z], 5),
		Pseq([[\z, \y], \x, \x, \y])
		]
	, inf).trace)
).play
);

Pdef(\z, Pchain(Pbind(\mtranspose, -5), Pdef(\y)));
Pdef(\y, Pchain(Pbind(\degree, Pseq([4, 3, 4, 2, 4, 1, 4, 0], 1)), Pdef(\x)));


Pdef(\play).stop; // stop it
Pdef.clear; // clear all
::


class:: Psync
summary:: synchronise and limit pattern duration
related:: Classes/Pfindur
categories:: Streams-Patterns-Events>Patterns>Repetition

Description::

Psync behaves somewhat like link::Classes/Pfindur:: -- it has a teletype::maxdur:: argument that limits the total duration of the event stream.

The difference is in what happens if the event pattern stops on its own before teletype::maxdur:: is reached. If the total duration of the event pattern is shorter than the given maximum duration:

list::
## Pfindur simply ends: no further time manipulation.
## Psync inserts a rest to round the total duration up to the nearest multiple of the given teletype::quant::.
::

table::
## strong::Pbind's natural duration:: || code::Pfindur(16, Pbind(....)):: strong::behavior:: || code::Psync(Pbind(....), 4, 16):: strong::behavior::
## 6 beats || Pfindur plays only 6 beats || Psync rounds up to 8 beats (adds a two-beat rest)
## 18 beats || Pfindur cuts off after 16 beats || Psync cuts off after 16 beats
::

teletype::maxdur:: may be omitted. If the Pbind stops by itself, the rest will be inserted according to teletype::quant::, but the total duration will be unlimited.

ClassMethods::

method::new

argument::pattern
a pattern that returns events.

argument::quant
rounding factor for total duration (effectively a "bar length")

argument::maxdur
maximum duration

argument::tolerance
threshhold that the stream must exceed maxdur to be ended.

argument::mindur
guarantees that the total duration is no less than a given limit, independent of the quant value.

Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction: Done.freeSelf);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

(
// a fixed duration pattern:

f = Pbind(
	\dur, 0.5,
	\degree, Pn(4,1),
	\instrument, \help_sinegrain
);

// this pattern has indetermined length:
a = Prand([
	Pbind(
		\dur, Pseq([0.02, 0.002, 0.1, 0.1],2),
		\degree, Pseq([9, 7, 5],inf),
		\instrument, \help_sinegrain
	),
	Pbind(
		\dur, Pseq([1, 0.35],2),
		\degree, Pseq([0, [2b,5b]],inf),
		\instrument, \help_sinegrain
	),
	Pbind(
		\dur, Pseq([0.15, 0.25, 1.3],2),
		\degree, Pseq([2b,4,5b],inf),
		\instrument, \help_sinegrain
	)
]);
)

Pseq([f, f, a, a], inf).play; // play a sequence


// Psync allows to limit the duration of a stream relative to a beat grid

b = Psync(a, 1, 1); // create a sequence of exactly 1 beat elements
Pseq([f, f, b, b], inf).play;


b = Psync(a, 1, 2); // create a sequence of elements of either 1 or 2 beats length
Pseq([f, f, b, b], inf).play;

(
b = Psync(a, 2);	// create a sequence of elements with a minimum of 2 beats,
			// but with undetermined upper limit
Ppar([
	Pseq([f, f, b, b], inf), // sequence
	Pbind(\instrument, \help_sinegrain, \freq, 1000, \sustain, 0.01, \dur, 2) // metronome
]).play;
)
::


class:: Ptime
summary:: returns time in beats from moment of embedding in stream
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Time

Examples::

code::
(
a = Ptime.new;
x = a.asStream;
)

x.next;
x.next;
x.next;

// post time in a playing event stream
(
Pbind(
	\pfunc, Ptime.new.trace,
	\dur, Pseries(0.5, 0.5, 5)
).play;
)


// change degree independant of number of events that have been playing

(
var a, b;
a = Pbind(
	\degree, Pswitch(#[0, 2b, 3], Ptime(8).round(2) / 2),
	\dur, Prand(#[0.2, 0.5, 1.1, 0.25, 0.15], inf)
);
b = Pbind(
	\degree, Pseq(#[0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pseq([Event.silent(1.25), Ppar([a, b])], inf).play;
)


// test tempo changes

(
var a, b;
a = Pbind(
	\degree, Pswitch(#[0, 2b, 3], Ptime(8).round(2) / 2),
	\dur, Prand(#[0.2, 0.5, 1.1, 0.25, 0.15], 9)
);
b = Pbind(
	\degree, Pseq(#[0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pn(
	Pfset({ ~tempo = #[1, 2, 4].choose.postln },
		Pseq([
			Event.silent(1.25),
			Ppar([a, b])
		])
	)
).play
)
::


class:: Ptpar
summary:: embed event streams in parallel, with time offset
related:: Classes/Ppar
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order, providing a global strong::offset:: for each. When one stream ends, the other streams are further embedded until all have ended.

ClassMethods::

method::new

argument::list
list of pairs of times and patterns: [time, pat, time, pat .. ].

note:: times are in beats and depend on the tempo of the link::Classes/TempoClock:: in use.::

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// see the delta values in the resulting events
(
var a, b, c, t;
a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
c = Ptpar([0.0, a, 1.3, b]);
t = c.asStream;
20.do({ t.next(Event.default).postln; });
)

// sound example
(
var a, b;
a = Pbind(\note, Pseq([7, 4, 0], 4), \dur, Pseq([1, 0.5, 1.5], inf));
b = Pbind(\note, Pseq([5, 10, 12], 4), \dur, 1);
Ptpar([ 0.0, a, 1.3, b ]).play;
)
::


TITLE:: Ptrace
summary:: Print out the results of a stream
related:: Classes/Stream, Classes/FilterPattern
categories:: Streams-Patterns-Events>Patterns

DESCRIPTION::
Print out the results of a stream while returning the original values.

Tracing a pattern is most commonly done by using the strong::.trace:: method directly on the pattern like this:

code::
Pbind(\degree, Pwhite(0,10)).trace.play
::

CLASSMETHODS::

METHOD:: new

ARGUMENT:: pattern
printOn this stream (default: link::Classes/Post::).

ARGUMENT:: key
when streaming events, post only this key.

ARGUMENT:: printStream
(describe argument here)

ARGUMENT:: prefix
string added to the printout to separate different streams.

returns:: Original values


INSTANCEMETHODS::

METHOD:: storeArgs

METHOD:: embedInStream


ARGUMENT:: inval

METHOD:: key


EXAMPLES::

code::
(
// An event pattern playing random scale degrees
p = Pbind(\dur, 0.125, \degree, Pwhite(0,10));

// Se what the value of the scale degrees are using trace
Ptrace(p, \degree, prefix: "Current scale degree: ").play
)
::


class:: Ptuple
summary:: combine a list of streams to a stream of lists
related:: Classes/Ppar
categories:: Streams-Patterns-Events>Patterns>List

description::

At each iteration, Ptuple returns a tuple (array) combining the output of each of the patterns in the list. When any of the patterns returns a nil, Ptuple ends that 'repeat' and restarts all of the streams.

ClassMethods::

method::new

argument::list
an link::Classes/Array:: of patterns.

argument::repeats
an link::Classes/Integer:: or inf.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], inf);
c = Ptuple([a, a, b], inf);
x = c.asStream;
8.do({ x.next.postln; });
)


(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], 3); // stops after 3 cycles
c = Ptuple([a, a, b], 4); // stops after 4 cycles
x = c.asStream;
8.do({ x.next.postln; });
)


//Ptuple used as a sequence of pitches (chords)

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq([73, 71, 69, 69, 65, 64], inf);
b = Pseq([0, 0, 0, 4, 0, 3, 2], inf) + a;
c = Ptuple([a, b], inf);
x = c.asStream;
Routine({
	var chord;
	loop({
		chord = x.next.postln.midicps;
		(instrument: \help_sinegrain, freq: chord).play;
	0.2.wait;
	})
}).play;
)
::


class:: Pulse
summary:: Band limited pulse wave.
related:: Classes/LFPulse
categories::  UGens>Generators>Deterministic


Description::

Band limited pulse wave generator with pulse width modulation.


classmethods::

method::ar, kr

argument::freq

Frequency in Hertz.


argument::width

Pulse width ratio from zero to one. 0.5 makes a square wave.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// modulate frequency
{ Pulse.ar(XLine.kr(40, 4000, 6), 0.1, 0.2) }.play;

// modulate pulse width
{ Pulse.ar(200, SinOsc.kr(0.2).range(0.01, 0.99), 0.2) }.play;

// two band limited square waves thru a resonant low pass filter
{ RLPF.ar(Pulse.ar([100, 250], 0.5, 0.1), XLine.kr(8000, 400, 5), 0.05) }.play;

::



class:: PulseCount
summary:: Pulse counter.
related:: Classes/Stepper
categories::  UGens>Triggers


Description::

Each trigger increments a counter which is output as a signal.


classmethods::

method::ar, kr

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::reset

Resets the counter to zero when triggered.


Examples::

code::

SynthDef("help-PulseCount",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			PulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,
			0, 0.05
		)
	)
}).play;

::



class:: PulseDivider
summary:: Pulse divider.
categories::  UGens>Triggers


Description::

Outputs one impulse each time it receives a certain number of triggers at
its input.


classmethods::

method::ar, kr

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::div

Number of triggers to count before outputting an impulse.


argument::start

Starting value for the trigger count. This lets you start
somewhere in the middle of a count. If start is negative
it adds that many counts to the first time the output is
triggered.


Examples::

code::

SynthDef("help-PulseDivider",{ arg out=0;
	var p, a, b;
	p = Impulse.ar(8);
	a = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));
	b = SinOsc.ar(600,  0, Decay2.ar(PulseDivider.ar(p, 4), 0.005, 0.5));

	Out.ar(out,(a + b) * 0.4)
}).play;

::


class:: Punop
summary:: unary operator pattern
related:: Classes/Pbinop, Classes/Pnaryop, Classes/UnaryOpFunction, Overviews/Operators
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the unary operator to the stream values of the receiver. Usually, this is the result of applying a unary operator (i.e. a method with one argument) to a pattern.

Examples of unary operators are: squared, sqrt, sin, tan ...

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

Examples::

code::
(
var a;
a = Punop(\sqrt, Pseries(0, 1, 12));
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).sqrt;
a.asStream.all;
)

// some common cases:
Pseq([1, 2, 3]).squared;
Pseq([0.2, 0.5, 0.8]).coin;
Pwhite(-100, 100, inf).abs;



// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Punop(\sqrt, Pseries(0, 1, 12))).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Punop(\sqrt, Pseries(0, 1, 12)))
).play;
)


// these are the same as:

(
var a;
a = Pn(Pseries(0, 1, 12).sqrt).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pn(Pseries(0, 1, 12).sqrt)
).play;
)
::


TITLE:: PureUGen
summary:: Pure UGen
categories:: UGens
related:: Classes/UGen

DESCRIPTION::

A Pure UGen is a UGen, which does not access any shared resources like busses, buffers or random number generators. UGen
classes which are derived from PureUGen are candidates for common subexpression elimination and dead code elimination
passes during the SynthDef compilation.

INSTANCEMETHODS::
PRIVATE:: optimizeGraph


class:: Pwalk
summary:: A one-dimensional random walk over a list of values that are embedded
related:: Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>List

ClassMethods::

method::new

argument::list
The items to be walked over.

argument::stepPattern
Returns integers that will be used to increment the index into list.

argument::directionPattern
Used to determine the behavior at boundaries. When the index crosses a boundary, the next direction is drawn from this stream: 1 means use stepPattern as is, -1 means go in the reverse direction. Common patterns:
definitionList::
## 1 || always wrap around to the other boundary.
## Pseq([1, -1], inf) || go forward first, then backward, then forward again.
::

argument::startPos
Where to start in the list.

Examples::

code::
(
a = Pwalk(
	Array.series(20, 0, 1),		// integers, 0-19
		// steps up to 2 in either direction, weighted toward positive
	Pwrand([-2, -1, 0, 1, 2], [0.05, 0.1, 0.15, 1, 0.1].normalizeSum, inf),
		// reverse direction at boundaries
	Pseq([1, -1], inf),
	10);	// start in the middle
x = a.asStream;
)

200.do({ x.next.post; ", ".post });

b = a.copy.directionPattern_(1);	// this one will always wrap around
x = b.asStream;

200.do({ x.next.post; ", ".post });



// non-random walk: easy way to do up-and-down arpeggiation
s.boot;
(
a = Pwalk(
	[60, 64, 67, 72, 76, 79, 84].midicps,	// C major
	Pseq([1], inf),
	Pseq([1, -1], inf),	// turn around at either end
	0);
x = a.asStream;

SynthDef(\help_walk, { |out, freq|
	Out.ar(out, Saw.ar([freq, freq+1], 0.5) * EnvGen.kr(Env.perc(0.01, 0.1), doneAction: Done.freeSelf))
}).add;
)

(
r = Task({
	{
		Synth.new(\help_walk, [\freq, x.next]);
		0.1.wait;
	}.loop;
}).play(SystemClock);
)

r.stop;
::


class:: Pwhile
summary:: While a condition holds, repeatedly embed stream
categories:: Streams-Patterns-Events>Patterns>Language Control

description::
Repeatedly strong::embed:: a link::Classes/Stream:: while the result of code::func:: is code::true::.


classmethods::

method:: new
argument:: func
Stream function. In an event stream receives the current link::Classes/Event:: as argument.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
z = true;
a = Pwhile({ z }, Pseq(#[1, 2, 3]));
x = a.asStream;
);

7.do({ x.next.postln; }); // while z == true, the values are embedded
z = false; // set z to false
x.next; // the rest of the stream is still embedded
x.next;
x.next; // but then it is not continued.
x.next;
x.next;
x.next;
::


class:: Pwhite
summary:: random values with uniform distribution
related:: Classes/Pgauss
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pwhite(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pwhite", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a;
a = Pwhite(0.0, 1.0, inf);
a.asStream.nextN(1000).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pwhite(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, rrand(0.0, 1.0) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::


class:: Pwrand
summary:: embed values randomly chosen from a list
related:: Classes/Prand, Classes/Pxrand
categories:: Streams-Patterns-Events>Patterns>List

description::
Returns one item from the list at random for each repeat, the probability for each item is determined by a list of weights which should sum to 1.0.

Examples::

code::
(
var a, b;
a = Pwrand.new([1, 2, 3], [1, 3, 5].normalizeSum, 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

//Prand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pwrand([60, 61, 63, 65, 72], [10, 2, 3, 1, 3].normalizeSum, inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)
::


class:: Pwrap
summary:: constrain the range of output values by wrapping
related:: Classes/SimpleNumber
categories:: Streams-Patterns-Events>Patterns>Math

description::
Note: this is equivalent to pattern.wrap(lo, hi)

Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(
	Pwrap(
		Pgeom(200,1.07,96),
		200,
		1000.0
	),
	inf
);
x = a.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.debug,\dur,0.3]);
		0.12.wait;
	})
}).play;
)
::


class:: Pxrand
summary:: embed values randomly chosen from a list
related:: Classes/Prand, Classes/Pwrand
categories:: Streams-Patterns-Events>Patterns>List

description::
Like link::Classes/Prand::, returns one item from the list at random for each repeat, but Pxrand never repeats the same element twice in a row.

Examples::

code::
(
var a, b;
a = Pxrand.new(#[1, 2, 3], 10);	// return 10 items
b = a.asStream;
11.do({ b.next.postln; });
)

//Pxrand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pxrand(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)
::


class:: QPalette
summary:: Set of colors used by the GUI
categories::  GUI>Accessories


Description::

QPalette is a strong::set of colors:: that the GUI system uses to draw the views. The colors are organized into three strong::color groups:: (active, inactive and disabled) used according to the state of the views drawn, and each group containing one color assigned to each of the various strong::color roles:: (window, windowText, button, buttonText, etc.), used to draw distinct elements of the views. See link::Reference/palette_color_roles:: and link::Reference/palette_color_groups:: for details.

A palette can be assigned to the whole GUI using link::Classes/QtGUI#*palette::, or to a particular view using link::Classes/View#-palette::. Views will inherit a palette from their parent, and ultimately QtGUI, unless a palette is explicitly assigned to them. Moreover, when setting a palette on a view, it will be combined with the inherited one, overriding only those colors that have been explicitly set on the palette (see link::#-hasColor::). Hence, assigning a new and unmodified palette will reset all the colors to the inherited ones.

There are also two predefined palettes accessible using link::#*light:: and link::#*dark::. The light palette is assigned to QtGUI by default on startup. Should you wish to use a palette that matches the color scheme used natively on your platform, you can access such palette using link::#*system::.

If you wish to design your own palette, it is most convenient to use link::#*auto::, which will automatically derive a palette from only two colors, and then modify the details as you see fit.

Note that in Qt GUI most color-related methods of views (like link::Classes/Window#-background::, link::Classes/Slider#-knobColor::, etc.) actually modify the view's palette.



CLASSMETHODS::

METHOD:: new
	Instantiates a new palette, equivalent to the global palette assigned to QtGUI. All colors are considered to not be set (see link::#-hasColor::).

METHOD:: auto
	Instantiates a new palette, with colors automatically derived from the given colors for 'button' and 'window' color roles. All colors are considered to be set (see link::#-hasColor::).

	argument:: buttonColor
		The Color assigned to the button role.
	argument:: windowColor
		The Color assigned to the window role.

METHOD:: light
	A predefined palette using light colors. All colors are considered to be set (see link::#-hasColor::).

METHOD:: dark
	A predefined palette using dark colors. All colors are considered to be set (see link::#-hasColor::).

METHOD:: system
	The native system palette. All colors are considered to be set (see link::#-hasColor::).


INSTANCEMETHODS::


PRIVATE:: prInit
PRIVATE:: prAuto
PRIVATE:: prSystem
PRIVATE:: prColor
PRIVATE:: prSetColor
PRIVATE:: prHasColor

METHOD:: color
	Returns the color assigned to a color role within a color group.
	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::, or nil, in which case the current color group is used.

METHOD:: setColor
	Assigns a color to a color role within a color group.

	argument:: color
		A Color.
	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::, or nil, in which case the color will be assigned to all groups.

METHOD:: hasColor
	Whether the color belonging to a color role and group has been set on this QPalette instance.

	When setting a palette on a view, only colors for which this methods returns true will be changed, others will be inherited from the parent view (or QtGUI if this view has no parent).

	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::.

METHOD:: window
	Convenience method to get or set the color for the 'window' role.

METHOD:: windowText
	Convenience method to get or set the color for the 'windowText' role.

METHOD:: button
	Convenience method to get or set the color for the 'button' role.

METHOD:: buttonText
	Convenience method to get or set the color for the 'buttonText' role.

METHOD:: base
	Convenience method to get or set the color for the 'base' role.

METHOD:: baseText
	Convenience method to get or set the color for the 'baseText' role.

METHOD:: highlight
	Convenience method to get or set the color for the 'highlight' role.

METHOD:: highlightText
	Convenience method to get or set the color for the 'highlightText' role.


CLASS:: QPenPrinter
summary:: QPen PDF export and printing of vector graphics
categories:: GUI>Accessories
related:: Classes/Pen

DESCRIPTION::
QPenPrinter allows Pen to operate on a printer device. The graphics can be exported to PDF by using "print to file" as printer device.

CLASSMETHODS::
private:: qtClass


METHOD:: new
Create a new QPenPrinter object.

returns:: an instance of QPenPrinter

METHOD:: print
Convenience function to show a print dialog and print.

argument:: printFunc
A link::Classes/Function:: to be evaluated when the user presses "Print", with the printer object as Pen painter target.
See strong::aPrintFunc:: in link::#-print:: below.

argument:: cancelFunc
An optional link::Classes/Function:: to be evaluated if the user presses "Cancel".


INSTANCEMETHODS::
private:: init

subsection:: Printing

METHOD:: showDialog
Shows a Print Dialog to allow the user to configure the printer object. This is asynchronous and the method will return immediately.
When the user presses the "Print" button, strong::aOkFunc:: is called with this QPenPrinter object as argument.

argument:: aOkFunc
A link::Classes/Function:: to be evaluated when the user presses "Print".

argument:: aCancelFunc
An optional link::Classes/Function:: to be evaluated if the user presses "Cancel".


METHOD:: print
This method does the actual printing or PDF export. It evaluates strong::aPrintFunc:: with the printer object as Pen painter target. This QPenPrinter object is passed as the argument.

All the ordinary link::Classes/Pen:: commands can be used inside the function.

argument:: aPrintFunc
A link::Classes/Function:: to be evaluated to draw the graphics.

discussion::
If this method is called without configuring the printer object first, it will print on the default printer with default settings.

This method is typically called from within the strong::aOkFunc:: of link::#-showDialog:: above. After showDialog has configured the printer once, this method can be called multiple times to reuse the last printer configuration.

The point at (0@0) will coincide with the origin of link::#-pageRect::, which is offset by the page margins. So you don't need to translate the Pen.


METHOD:: newPage
Starts a new page. Typically called within the strong::aPrintFunc:: of link::#-print::.


subsection:: Properties

METHOD:: paperRect
Get the paper bounds.

returns:: a link::Classes/Rect::


METHOD:: pageRect
Get the page bounds, which is the printable area and usually smaller than link::#-paperRect:: due to margins.

returns:: a link::Classes/Rect::

discussion::
The strong::origin:: of the Rect is relative to the paper, and will be non-zero due to margins.


METHOD:: pageSize
Get the page size as a Size.

returns:: a link::Classes/Size::

discussion::
This can be used to scale the graphics to fit the page if the bounds of the graphics is known:
code::
x = penPrinter.pageSize.width / bounds.width;
Pen.scale(x,x);
// ... draw stuff here ...
::

subsection:: Page range
The methods below returns the page range selected by the user. Page number starts at 1. When both methods returns 0 it means "print all pages".

METHOD:: fromPage
Get the start page.

returns:: an link::Classes/Integer::

METHOD:: toPage
Get the end page.

returns:: an link::Classes/Integer::



EXAMPLES::

Simple usage:
code::
QPenPrinter.print {
    // first page
    Pen.moveTo(100@100);
    Pen.lineTo(300@300);
    Pen.stroke;

    // second page
    p.newPage;
    Pen.addRect(p.pageSize.asRect);
    Pen.stroke;
}
::

Keep the QPenPrinter object to save configuration state:
code::
p = QPenPrinter();
::
The code below can then be called multiple times:
code::
p.showDialog {
    p.print {
        // first page
        Pen.moveTo(100@100);
        Pen.lineTo(300@300);
        Pen.stroke;

        // second page
        p.newPage;
        Pen.addRect(p.pageSize.asRect);
        Pen.stroke;
    }
} {
    "Printing cancelled!".postln;
};
::



class:: QtGUI
summary:: Top-level controls for Qt GUI
categories:: GUI

description::

QtGUI provides top-level control for the Qt GUI bindings and some platform-level functionality.

classmethods::

private:: prStringBounds, prSetStyle, view, compositeView, hLayoutView, vLayoutView, window
private:: scrollView, staticText, button, checkBox, textField, numberBox, slider, multiSliderView
private:: rangeSlider, slider2D, knob, listView, treeView, popUpMenu, textView, freqScope, freqScopeView
private:: scopeView, stethoscope1, stethoscope, soundFileView, envelopeView, levelIndicator, webView
private:: userView, dragSource, dragSink, dragBoth, dialog, ezScroller, ezSlider, ezListView, ezPopUpMenu
private:: ezNumber, ezRanger, hLayout, vLayout, gridLayout, stackLayout, pen, font, image, qcView
private:: notImplemented, stop, id

method:: availableStyles

Returns an array of all available styles on this platform. For use with link::#-style::.

method:: cursorPosition

Gets the current position of the cursor as a link::Classes/Point::.

method:: debugLevel

Gets or sets the verbosity level for debug output from "QtCollider" code. SuperCollider must have
been built in debug mode for messages to appear. Valid values are -1 (none), 0 (warnings only,
default), 1 (most messages), and 2 (verbose). Values outside this range are effectively clipped.

method:: focusView

Gets the currently focused view.

method:: palette

Gets or sets the link::Classes/QPalette:: used for GUI display.

method:: selectedText

Gets the selected text in the currently focused view. If there is no such string then return
empty string.

Internally, first calls code::selectedText:: if that method is available; otherwise, calls
code::selectedString:: if that method is available. Otherwise, returns empty string.

method:: stringBounds

Returns a link::Classes/Rect:: representing the size of the smallest rectangle that could contain a
given string rendered with the given font.

code::
QtGUI.stringBounds("hellooo", Font(Font.defaultSansFace, 100))
::

argument:: aString
A link::Classes/String:: to render.

argument:: aFont
An instance of link::Classes/Font::.

method:: style

Gets or sets the current GUI style. The given style must be a link::Classes/String:: or
link::Classes/Symbol:: that names one of the styles returned by link::#-availableStyles::.


class:: QuadC
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadN, Classes/QuadL

description::
A cubic-interpolating sound generator based on the difference equation:

teletype::
	x(n+1) = a * x(n)^2 + b * x(n) + c
::

sclang code translation:

code::
(
var a = 1, b = -1, c = -0.75, xi = 0, size = 64;
plot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x

examples::
code::
// default params
{ QuadC.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadC.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadC.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::


class:: QuadL
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadC, Classes/QuadN

description::
A linear-interpolating sound generator based on the difference equation:

teletype::
	x(n+1) = a * x(n)^2 + b * x(n) + c
::

sclang code translation:

code::
(
var a = 1, b = -1, c = -0.75, xi = 0, size = 64;
plot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x

examples::
code::
// default params
{ QuadL.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadL.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadL.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::


class:: QuadN
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadL, Classes/QuadC

description::
A non-interpolating sound generator based on the difference equation:

teletype::
        x(n+1) = a * x(n)^2 + b * x(n) + c
::

sclang code translation:

code::
(
var a = 1, b = -1, c = -0.75, xi = 0, size = 64;
plot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x
argument:: mul
argument:: add

examples::
code::
// default params
{ QuadN.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadN.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadN.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::


CLASS::Quant
categories::Scheduling
summary::encapsulate quantization issues associated with EventStreamPlayer and TempoClock

DESCRIPTION::
Represents the standard scheduling model for Routines, Tasks and Patterns. A Quant object stores the parameters needed to calculate the precise time when a Routine/Task/Pattern will start playing on a specified TempoClock.

The standard scheduling model uses quant and phase to locate the starting time. They are evaluated with reference to the TempoClock's baseBarBeat, which is normally zero but is updated when you change the clock's meter using the clock's setMeterAtBeat method. Thus scheduling still makes sense even after a meter change. See the link::Classes/TempoClock:: help file for details on its representation of time.

CLASSMETHODS::

method::new
Explicitly create an instance of Quant, which may be used and reused. Phase and offset may be nil, in which case they are treated as 0. If quant is nil, it will schedule for the current time exactly.

INSTANCEMETHODS::

method::quant
Quantization granularity. The routine will begin on the next integer multiple of this number after the baseBarBeat. If negative, it indicates the number of bars in the future to schedule (where the bar length is taken from the clock's beatsPerBar variable).

method::phase
An offset to push the scheduling time into the middle of the bar. +1 is one beat later, -1 is one beat earlier. A negative phase is legal, but it might result in a scheduling time that is later than the current time, in which case scheduling will be incorrect. It's your responsibility to take this into account.

method::timingOffset
For use with patterns only -- this enables patterns to run slightly ahead of their sounding time on the clock, giving you control over the order in which threads execute.

EXAMPLES::

definitionlist::
## quant = 1 || schedule for the next whole beat
## quant = 4, phase = -1 || a one beat pick-up to the next 4/4 barline
::
Suppose the clock's meter was 3/4 for 3 bars (starting at 0). Then:
definitionlist::
## quant = 3, phase = 1 || would schedule for 1, 4, or 7 beats
::
During this time, clock.setMeterAtBeat(4, 9) is executed. Then:
definitionlist::
## quant = 4, phase = 0 || would schedule for 9, 13, 17, 21 etc. beats
::
Every point in time can be precisely identified this way, and it can be related back easily to the Western concept of meter or time signature.

subsection::Automatic instantiation

Certain objects convert themselves into Quant objects when used with link::Classes/Routine#-play::, link::Classes/Task#-play:: or link::Classes/Pattern#-play::.

definitionlist::
## link::Classes/SimpleNumber::
|| code:: 4.0 --> Quant(4.0, nil, nil) ::
## link::Classes/Array:: ||
code:: [4.0, 1.0] --> Quant(4.0, 1.0, nil) ::

code:: [4.0, 1.0, 0.1] --> Quant(4.0, 1.0, 0.1) ::
## link::Classes/Nil::
|| code:: nil --> Quant(nil, nil, nil) ::
::
This simplifies the syntax:
code::
Routine({ ... }).play(quant: 4.0):: vs. code::Routine({ ... }).play(quant: Quant(4.0))
::

subsection::Timing offset in Patterns

In some cases, you might want two patterns that are sounding at the same time to evaluate in a specific order -- for instance, the second pattern might depend upon data calculated by the first. If they are scheduled on the clock for exactly the same time, you have no control over the order of execution: the second pattern might evaluate first, in which case it would be using stale data for the pattern that should have run first.

The timing offset is a positive number, usually small, that pushes the scheduling time slightly earlier, guaranteeing that patterns with larger timing offsets will execute earlier than others. The timing offset value is saved in the event prototype, which then delays its messages to the server by exactly that number of beats.

Two patterns, scheduled for the same quant and phase but with different timing offsets, should sound exactly together.

code::
(
// timing offset = 0
p = Pbind(\freq, 440, \pan, -1, \delta, 1.0, \sustain, 0.1).play(quant: [2, 0, 0]);
// timing offest = 0.1
q = Pbind(\freq, 880, \pan, 1, \delta, 0.5, \sustain, 0.1).play(quant: [2, 0, 0.1]);
)

// p's nextBeat is x.0 - q's is x.4 or x.9 (e.g., halves of a beat minus 0.1)
[p.nextBeat, q.nextBeat]

p.stop; q.stop;
::

subsection::Extensibility: adding custom scheduling models

While the standard scheduling model should be sufficient for most uses, the point of using an object to encapsulate scheduling details is that you can use a different object to schedule Routines or Patterns differently. (Users are not forced to use the standard scheduling model in every case.)

If it's a kind of scheduling you expect to use often, you can create a subclass of Quant that implements the following methods:

*new(...): create a new instance, with whatever arguments you need

nextTimeOnGrid(clock): calculate the exact beat number on the clock

Your class should also have methods asQuant, offset and offset_. If your class is a subclass of Quant, it will inherit those methods automatically.

You can also use an Event for one shot scheduling. It should at least have an entry for nextTimeOnGrid, which will usually be a function taking the arguments "self" and "clock" that returns the absolute scheduling time. Any other values needed for that calculation should also be present in the Event.

code::
// schedule for a random number of beats after the next integer
Pfuncn({ thisThread.clock.beats.debug("scheduled for"); nil }, 1)
	.play(quant: (
		nextTimeOnGrid: { |self, clock|
			clock.beats.roundUp(1).debug("clock beats") + rrand(self.lo, self.hi).debug("rand")
		},
		lo: 0, hi: 4
	));
::


TITLE:: Quark
summary:: Object for managing a Quark - a package of source code
categories:: Quarks
related:: Guides/UsingQuarks, Classes/Quarks

DESCRIPTION::
A Quark is a folder of source code, a package. It may be cloned from a git repository, or maybe not.
This class is used by the Quarks class and you will not usually want to use it directly.

CLASSMETHODS::

METHOD:: new
ARGUMENT:: name
Quark name, git url or local path (absolute or relative)
ARGUMENT:: refspec
ARGUMENT:: url
ARGUMENT:: localPath
returns:: this

METHOD:: fromLocalPath
alternate constructor
ARGUMENT:: path
returns:: this

METHOD:: fromDirectoryEntry
alternate constructor
ARGUMENT:: name
ARGUMENT:: directoryEntry
returns:: this

METHOD:: parseQuarkName
ARGUMENT:: name
ARGUMENT:: refspec
ARGUMENT:: url
ARGUMENT:: localPath
returns:: this

METHOD:: parseDependency
private
ARGUMENT:: dep
ARGUMENT:: forQuark
returns:: this

PRIVATE::prMakeDep

INSTANCEMETHODS::

METHOD:: name
returns:: String

METHOD:: dependencies
Based on the dependencies list in the quark file, returns an array of Quarks.
returns:: Array of Quark

METHOD:: deepDependencies
Declared dependencies of this Quark and those of each dependency.
This will check out all dependencies.
returns:: Array of Quarks

METHOD:: data
Lazily parses the quark file (if found) and caches it
returns:: Dictionary - the contents of the quark file

METHOD:: refspec
Git refspec (tag or sha hash)
returns:: this

METHOD:: localPath
Absolute path where the Quark is located
returns:: this

METHOD:: summary
Summary text from the quark file
returns:: this

METHOD:: url
Git repository url. If not declared when creating, it will examine the checked out git source
and get the origin.
returns:: this

METHOD:: isDownloaded
returns:: Boolean

METHOD:: isInstalled
returns:: Boolean

METHOD:: git
Quarks that have git repos have a Git object that can be used for checking out, listing tags etc.
returns:: a Git object

METHOD:: init
private
ARGUMENT:: argName
ARGUMENT:: argUrl
ARGUMENT:: argRefspec
ARGUMENT:: argLocalPath
returns:: this

METHOD:: install
returns:: this

METHOD:: uninstall
returns:: this

METHOD:: checkout
Clone and checkout the url and refspec.
Used by install and for switching versions.
returns:: this

METHOD:: version
returns:: String

METHOD:: branch
returns the current branch name.
returns:: String or nil, if failed

METHOD:: tags
returns:: Array of Strings

METHOD:: isCompatible
Evaluates the 'isCompatible' function in the quarkfile, if there is one.
This allows a quarkfile to check its environment and raise an alarm before it gets installed and breaks something.
returns:: Boolean

METHOD:: definesClasses
Classes that are defined by this Quark
returns:: Array of Classes

METHOD:: definesExtensionMethods
Methods that this Quark defines that overwrite implementations in other packages including in Common.
returns:: Array of Methods

METHOD:: help
Open the help file. Either as specified in the quark file as 'schelp' or searches by the name of the quark.
returns:: this

METHOD:: changed
After un/installing or checking out, state is set to changed.
code smell: this is for the gui
returns:: Boolean

METHOD:: runHook
Runs the function code::hook:: which is defined in the code::.quark:: file. This can be used for running a function before or after installation, see link::Guides/UsingQuarks#Hooks:: for more information.
In case the function can not be executed properly a warning will be printed and the update or installation process will be stopped.
argument:: hook
Name of function to run.
returns:: this

METHOD:: printOn
ARGUMENT:: stream
returns:: this

METHOD:: parseQuarkFile
private
returns:: this

PRIVATE::prCollectDependencies


TITLE:: Quarks
class:: Quarks
summary:: Package manager
categories:: Quarks
related:: Guides/UsingQuarks, Classes/Quark

DESCRIPTION::
See link::Guides/UsingQuarks:: for an introduction to the Quarks package system.

CLASSMETHODS::

METHOD:: gui
Show the interface for managing quarks
returns:: QuarksGui

METHOD:: install
Will execute the link::Guides/UsingQuarks#Hooks#hooks:: code::\preInstall:: and code::\postInstall:: if defined.
ARGUMENT:: name
Name of a quark that is listed in the directory,
or the url of a git repository
or the path (absolute or relative to current working directory) of a folder to install.
ARGUMENT:: refspec
Optional git refspec. By default it will install the latest version.
Optionally you can specify a tag: "tags/1.0.0"
A sha commit: "15e6ea822a18d06b286c3f10918f83b8d797d939"
"HEAD"
nil (default)
returns:: this

METHOD:: installQuark
Install a quark
Usually you use *install with a name, url or path.
ARGUMENT:: quark
returns:: this

METHOD:: uninstall
Will execute the link::Guides/UsingQuarks#Hooks#hooks:: code::\preUninstall:: and code::\postUninstall:: if defined.
ARGUMENT:: name
Name (String) of a quark that is listed in the directory,
or url of a git repository
or the path (absolute or relative to current working directory) of a folder to uninstall.
returns:: this

METHOD:: clear
Uninstall all Quarks, by setting LanguageConfig.installedPaths to empty.
returns:: this

METHOD:: addFolder
ARGUMENT:: path
In addition to the default downloaded-quarks
add folders that contain quarks to offer on the menu for installation.
These may be private quarks, cloned working copies or folders where you have manually downloaded quarks.
NOTE:: The argument should be a path to a directory emphasis::containing quark directories::. It should emphasis::not:: be an isolated quark directory by itself. Users are discouraged from scattering quark directories in isolated locations. ::
returns:: this

METHOD:: all
All Quarks whether downloaded or installed or not. Includes any Quarks that were installed by path.
returns:: Array of Quarks

METHOD:: installed
All currently installed Quarks
returns:: Array of Quarks

METHOD:: isInstalled
ARGUMENT:: name
Name, url or path
returns:: Boolean

METHOD:: save
Saves the currently installed quarks to a file as a list of urls and refspecs.
ARGUMENT:: path
path of file to save to
returns:: this

METHOD:: load
Clear all installed quarks and load a list from a file.
Relative paths in the file are resolved relative to the file itself.
eg. ./classes/my-quark
Unix style tildes (~/supercollider/quarks/my-quark) resolve to the user's home directory, even on Windows.
By convention the file is called quarks.txt
ARGUMENT:: path
path of file to load. May contain ~ or relative paths (root is current working directory)
ARGUMENT:: done
function to be evaluated when loading is done

returns:: this

METHOD:: update
Runs 'git pull' on the checked out copy of the quark. The gui provides a more robust way to do updates.
Will execute the link::Guides/UsingQuarks#Hooks#hooks:: code::\preUpdate:: and code::\postUpdate:: if defined.
ARGUMENT:: name
name of quark
returns:: this

METHOD:: openFolder
Open the downloaded-quarks folder
returns:: this

METHOD:: folder
Path of the downloaded-quarks folder where Quarks are cloned to before installing.
returns:: path

METHOD:: checkForUpdates
Scan through all downloaded, git-repository quarks and download any updates. This uses teletype::git fetch::; updates will be retrieved but not applied to the working copy (i.e., no visible change to the environment). After this, repositories will be aware of new branches and version tags.

This will take several seconds per quark. The SC interpreter will be unresponsive during each individual quark update.
ARGUMENT:: done
(Optional) A function to evaluate after all quarks have been checked.
ARGUMENT:: quarkAction
(Optional) A function to evaluate emphasis::before:: checking each individual quark. This function receives the Quark object as an argument, so you can use it, for instance, to print the quark name and have a running status update in the post window: code::Quarks.checkForUpdates(quarkAction: { |quark| "Updating %\n".postf(quark.name) });::.

METHOD:: fetchDirectory
Private.
Fetches the directory listing into downloaded-quarks/quarks
If a local copy already exists and it is not a git repo then this is used instead.
ARGUMENT:: force
(Boolean)
Force fetch. By default it is fetched once per session. Recompile the class library to fetch it again, or
call Quarks.fetchDirectory(true) to force it.
returns:: this

METHOD:: classesInPackage
Returns the Classes that are defined in the Quark or package.
ARGUMENT:: packageName
name of quark or any folder in Extensions or Common.
"Common" is a package that refers to the standard library.
returns:: Array of Classes

METHOD:: link
Adds the path to LanguageConfig.installedPaths.
private
ARGUMENT:: path
returns:: this

METHOD:: unlink
Removes a path from LanguageConfig.installedPaths.
private
ARGUMENT:: path
returns:: this

METHOD:: initClass
private
returns:: this

METHOD:: findQuarkURL
private
ARGUMENT:: name
returns:: this

METHOD:: directoryUrl
The URL of the directory.txt file
returns:: this

METHOD:: directory
The community contributed Quarks directory. Fetched from the directoryUrl
and parsed.
returns:: Dictionary[name->url@refspec]

METHOD:: asAbsolutePath
Helper method to resolve paths to absolute paths.
ARGUMENT:: path
ARGUMENT:: relativeTo
optional root for resolving relative paths
returns:: absolute path

METHOD:: quarkNameAsLocalPath
private
ARGUMENT:: name
quark name, path or git url.
returns:: absolute path where the Quark is

METHOD:: at
private. gets or creates a Quark by name, storing it in a central cache.
ARGUMENT:: name
returns:: Quark

PRIVATE:: prReadDirectoryFile



INSTANCEMETHODS::


TITLE:: QuartzComposerView
summary:: view for rendering Quartz Composer Compositions
categories:: GUI>Views

NOTE:: code::QuartzComposerView:: is deprecated in SC 3.13 and won't be available in subsequent versions that will use Qt 6.x. ::

DESCRIPTION::
QuartzComposerView allows for the rendering of Quartz Composer Compositions within SC on macOS. Quartz Composer is a visual programming environment for processing and rendering graphical data, which is distributed free of charge as part of Apple's XCode Development Tools. QC is highly optimised to work with the macOS graphics system, and in general should be more efficient than Pen. For more information on QC see: https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html and http://en.wikipedia.org/wiki/Quartz_Composer

You can access input and output ports using the methods setInputValue, getInputValue and getOutputValue, or (do to a slight of hand in the implementation, using the port keys as getters and setters directly. The following two lines of code are thus equivalent:

code::
myQCView.setInputValue(\valueIn, 1);
myQCView.valueIn = 1;
::


INSTANCEMETHODS::

METHOD::path
Get or set the path of the currently composition as a link::Classes/String::.

METHOD::inputKeys
Get the keys of the current composition's input ports.

returns:: An link::Classes/Array:: of link::Classes/Symbol::s.

METHOD::outputKeys
Get the keys of the current composition's output ports.

returns:: An link::Classes/Array:: of link::Classes/Symbol::s.

METHOD::start
Start rendering the loaded composition.

METHOD::stop
Stop rendering the loaded composition.

METHOD::setInputValue
Set the value of the input port specified by key.

argument::key
A link::Classes/String:: or link::Classes/Symbol:: matching the port's key.

argument::value
The type of value must correspond to the type of the port, but Floats, Integers, and Booleans are converted if needed. (true = 1, false = 0)

METHOD::getInputValue
Get the current value of an input port. The type of object returned will correspond to the port's type.

argument::key
A link::Classes/String:: or link::Classes/Symbol:: matching the port's key.

METHOD::getOutputValue
Get the current value of an output port. The type of object returned will correspond to the port's type.

argument::key
A link::Classes/String:: or link::Classes/Symbol:: matching the port's key.

METHOD::maxFPS
Set the maximum frames per second at which the composition will render.
argument::rate
A link::Classes/Float:: or link::Classes/Integer:: specifying the desired max frame rate. A value of 0 indicates no limit.

METHOD::openInQC
Open the currently loaded composition in Quartz Composer. You will need to reload the composition into the view before any saved changes take effect.

EXAMPLES::

code::
////////// Simple example
(
w = Window("Simple QC Test").front;
b = Button(w, Rect(0, 0, 150, 20))
	.states_([["pick another QC file"]])
	.action_({ File.openDialog("", { |path| m.path_(path) }) });
m = QuartzComposerView(w, Rect(0,20,400, 260));
m.path = Platform.helpDir +/+ "QC/Cells.qtz";
)
m.start;
m.stop;

////////// Set and get inputs and outputs
(
w = Window("SCTV").front;
m = QuartzComposerView(w, Rect(0,20,400, 260));
m.path = Platform.helpDir +/+ "QC/QuartzComposerViewTest.qtz";
m.start;
)

// get the names of input and output keys
m.inputKeys;
m.outputKeys;
m.openInQC; // you can see the published inputs and outputs in the composition

// You can access input and output ports using setInputValue, getInputValue and getOutputValue
// or directly using the keys as getters and setters
m.setInputValue(\direction, 1);
m.direction = 0;
m.direction;
m.fontSize; // font size in QC Units
m.fontSize_(0.1);

m.string_("SCTV").fontName_("Courier");
m.startColor_(Color.green);
m.billboardEnable_(false);
m.billboardEnable_(true);
m.maxFPS_(5.0);
m.maxFPS_(10);
m.maxFPS_(0.0); // no max

m.getOutputValue(\interpResult); // current rotation of the text in degrees
m.interpResult;
m.systemTime; // current System Time published in the composition
m.endColor.class; // yup, it's a SC Color object
m.endColor == Color.white;

(
// probably more efficient to do this in QC, but...
{
c = Color.blue;
100.do({ m.startColor_(c = c.vary(1)); 0.1.wait; });
}.fork(AppClock);
)

m.bounds = Rect(100, 20, 200, 260);

m.stop;

///////////// Fullscreen

(
w = Window("SCTV", Rect(0,0,360, 280), border: false).front;
b = SCButton(w, Rect(0, 0, 150, 20))
	.states_([["Close Me"]])
	.action_({w.close});
m = QuartzComposerView(w, Rect(0,20,360, 260));
m.path = Platform.helpDir +/+ "QC/QuartzComposerViewTest.qtz";

m.resize = 5;
m.start;
)

w.fullScreen;


////////// Structure test
(
w = Window("SCTV").front;
m = QuartzComposerView(w, Rect(0,20,400, 260));
m.path = Platform.helpDir +/+ "QC/QuartzComposerViewStructureTest.qtz";
m.start;
)

m.inputKeys;
m.outputKeys;
m.openInQC; // Take a look at the various inputs and outputs. Select and mouseover for key names.

// set several parameters at once
// [background color, num copies, scale, string, [font size in QC units, font]]
m.structure = [Color.red, 4, 1.5, "Hello", [0.2, "Courier"]];
m.structure = [Color.red, 3, 1.5, "World", [0.4, "Arial"]];
m.structure = [Color.red, 4, 0.1, "!!", [0.7, "Times"]];
m.structure = [Color.black, 4, 0.1, "!!!", [0.6, "Courier"]];
m.dictStructure = IdentityDictionary[\x->(-0.4), \y->0.4];

// get stuff out
// QCView stores all structures as instances of NSCFDictionary internally
// so all structure outputs are instances of IdentityDictionary
m.structure = [Color.blue, 4, 0.2, "Gruess Welt", [0.12, "Zapfino"]];
x = m.stringStruct; // separates the string into components
x[\component_1];

// pass something through
m.arbStructIn = ["foo", "bar", ["foobar"]]; // array in
x = m.arbStructOut; // IdentDict out with Integer Symbols as keys
x[\0];
x[\2][\0];
(
// convert to array
y = Array.newClear(x.size);
x.keysValuesDo({|i, elem| y[i.asInteger] = elem});
y.postln;
)

// use QC to concat the strings)
m.stringConcatIn = ["foo", "bar"]; // array in
x = m.stringConcatOut; // String Out

////////// Image Test

(
w = Window("Simple QC Test").front;
b = Button(w, Rect(0, 0, 150, 20))
    .states_([["pick another QC file"]])
    .action_({ File.openDialog("", { |path| m.path_(path) }) });
m = QuartzComposerView(w, Rect(0,20,400, 260));
m.path = Platform.helpDir +/+ "QC/ImageFilter.qtz";
)
m.start;
m.stop;
i = m.getOutputValue(\_protocolOutput_Image)
i.plot;

j = Image.color(100, 100, Color.rand);
j.plot;
m.setInputValue(\_protocolInput_Image, j);


////////// Control some audio: Stupid Pan Example

(
w = Window("Stupid Pan Example", Rect(0,20,600, 150)).front;
m = QuartzComposerView(w, Rect(0,20,600, 100));
m.path = Platform.helpDir +/+ "QC/Stupid Pan.qtz";
m.resize = 5;
m.start;
)

s.boot;
// use mouse to set pan position
(
{
loop({
{ Pan2.ar(Saw.ar(mul: 0.1) * EnvGen.ar(Env.perc, timeScale: 4, doneAction: Done.freeSelf), m.x_pos) }.play;
1.wait;
});
}.fork(AppClock);
)

////////// Sonogram

// could be better optimised, but proves the concept
(
w = Window("Sonogram", Rect(0,20,600, 300)).front;
m = QuartzComposerView(w, Rect(0,20,600, 256));
m.path = Platform.helpDir +/+ "QC/SCQCsonogramCount2.qtz";
m.start;
m.setInputValue(\framesPerView, 300);
m.setInputValue(\magnitudes, (0, 0.01..1));
)

s.boot;
b = Buffer.alloc(s,256);
(
a = { FFT(b, LFSaw.ar(4000)); 0.0 }.play; // sawtooth

p = 0.25; i = 0;
//m.setInputValue(\period, p);
//m.maxFPS_(p.reciprocal * 2);
SystemClock.sched(0.0, {
b.getn(0, 256, { arg buf;
	var z, x;
	z = buf.clump(2).flop;
	z = [Signal.newFrom(z[0]), Signal.newFrom(z[1])];
	x = Complex(z[0], z[1]);
	//{m.setInputValue(\magnitudes, x.magnitude.resamp1(m.bounds.height * 0.5));}.defer
	{m.setInputValue(\magnitudes, x.magnitude * 0.025); m.setInputValue(\count, i);}.defer;
	i = i + 1;
}); p
});
)

a.free;
a = { FFT(b, Dust2.ar(500) * 5); 0.0 }.play; // Impulses

a.free;
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
(
m.setInputValue(\framesPerView, 50);
a = { var colum;
	colum = PlayBuf.ar(1, c, BufRateScale.kr(c) * Line.kr(1, 3, 20), loop: 1);
	FFT(b, colum);
	colum
}.play;
)

///////////// Cheap Level Meter
(
w = Window("Level Meters", Rect(128, 64, 200, 400)).front;

m = QuartzComposerView(w, Rect(20,20,50, 360));
n = QuartzComposerView(w, Rect(130,20,50, 360));
m.path = Platform.helpDir +/+ "QC/SCLevelMeter.qtz";
n.path = Platform.helpDir +/+ "QC/SCLevelMeter.qtz";
m.maxFPS_(20); n.maxFPS_(20);
m.start; n.start;
~meters = [m, n];
)

s.boot;

// MouseX controls noise amp
(
o = OSCresponder(s.addr, '/tr', {arg time, resp, msg;
	{~meters[msg[2]].level = (msg[3] + 0.01).explin(0.01,1.01, 0, 1);}.defer;
}).add;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
a = { var colum, noise, imp, delimp;
	imp = Impulse.kr(20);
	delimp = Delay1.kr(imp);
	colum = PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1);
	noise = PinkNoise.ar(MouseX.kr);
	// measure Peak
	SendTrig.kr(imp, 0, Peak.ar(colum, delimp));
	SendTrig.kr(imp, 1, Peak.ar(noise, delimp));
	[colum, noise];
}.play;
)

a.free;


/// using an event type to control a QCView by patterns:

Event.addEventType(\quartz, { |server|
	var latency = server.latency;
	var view = ~view.postln;
	var key = ~key, value = ~value;
	AppClock.sched(latency, { view.postln; view.setInputValue(key, value) });
});


(
w = Window("Level Meters", Rect(128, 64, 200, 400)).front;

m = QuartzComposerView(w, Rect(20,20,50, 360));
m.path = "Help/GUI/Cocoa-GUI/QuartzComposerView/SCLevelMeter.qtz".standardizePath;
m.maxFPS_(20);
m.start;
)

(
Pbind(
	\type, \quartz,
	\view, m,
	\key, \level,
	\value, Pwhite(0, 1.0, inf).explin(0.01,1.01, 0, 1),
	\dur, 0.1
).play;
)

m.setInputValue(\level, 0.5);
::


class:: RHPF
summary:: A resonant high pass filter.
related:: Classes/Formlet, Classes/RLPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

A resonant high pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ RHPF.ar(Saw.ar(200,0.1), FSinOsc.kr(XLine.kr(0.7,300,20), 0, 3600, 4000), 0.2) }.play;

(
{ 	var ctl = RHPF.kr(LFSaw.kr(2), SinOsc.kr(XLine.kr(0.07,30,20), 0, 35, 40), 0.05);
	SinOsc.ar(ctl * 200 + 500);
}.play;
)

::



class:: RLPF
summary:: A resonant low pass filter.
related:: Classes/Formlet, Classes/RHPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

A resonant low pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ RLPF.ar(Saw.ar(200, 0.1), SinOsc.ar(XLine.kr(0.7, 300, 20), 0, 3600, 4000), 0.2) }.play;


(
{ var ctl = RLPF.ar(Saw.ar(5, 0.1), 25, 0.03);
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)


(
{ var ctl = RLPF.ar(Saw.ar(5,0.1), MouseX.kr(2, 200, 1), MouseY.kr(0.01, 1, 1));
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)

::




class:: RadiansPerSample
summary:: Number of radians per sample.
related:: Classes/ControlRate, Classes/SampleDur, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the number of radians per sample.


classmethods::

method::ir



class:: Ramp
summary:: Break a continuous signal into line segments
related:: Classes/Lag, Classes/VarLag, Classes/Slew
categories::  UGens>Filters>Linear


Description::

Break a continuous signal into linearly interpolated segments with specific durations.

Feeding Ramp with noise is similar to link::Classes/LFNoise1::
code::
Ramp.kr(WhiteNoise.kr(1),0.5)
::
is equal to:
code::
LFNoise1.kr(1 / 0.5)
::

For smoothing out control signals, take a look at link::Classes/Lag:: and link::Classes/VarLag::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

segment duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
s.boot;
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Ramp.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.scope;
)

// Compare
(
var pulse;
{
	pulse = LFPulse.kr(8.772);
	Out.kr(0,[Ramp.kr(pulse, 0.025), Lag.kr(pulse, 0.025), pulse]);
}.play;
s.scope(3, bufsize: 44100, rate: \control, zoom: 40);
)
::



class:: Rand
summary:: Single random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in uniform distribution from
code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::

(
SynthDef("help-Rand", { arg out=0;
	Out.ar(out,
		FSinOsc.ar(
			Rand(200.0, 400.0),
			0, Line.kr(0.2, 0, 1, doneAction: Done.freeSelf))
	)
}).add;
)

(
Routine({
	8.do({
		Synth.new("help-Rand"); 1.0.wait;
	})
}).play;
)

::



class:: RandID
summary:: Set the synth's random generator ID.
related:: Classes/RandSeed
categories::  UGens>Generators>Stochastic, UGens>Random


Description::

Choose which random number generator to use for this synth.
All synths that use the same generator reproduce the same sequence
of numbers when the same seed is set again.


classmethods::

method::kr, ir

argument::id
The random number generator ID.

Examples::

code::

//start a noise patch and set the id of the generator
(
SynthDef("help-RandID", { arg out=0, id=1;
	RandID.ir(id);
	Out.ar(out,
		WhiteNoise.ar(0.05) + Dust2.ar(70)
	)
}).add;
)

//reset the seed of my rgen at a variable rate
(
SynthDef("help-RandSeed", { arg seed=1910, id=1;
		RandID.kr(id);
		RandSeed.kr(Impulse.kr(FSinOsc.kr(0.2, 0, 10, 11)), seed);
}).add;

)

//start two noise synths on left and right channel with a different randgen id
a = Synth("help-RandID", [\out, 0, \id, 1]);
b = Synth("help-RandID", [\out, 1, \id, 2]);

//reset the seed of randgen 1
x = Synth("help-RandSeed", [\id, 1]);

//change the target randgen to 2 (affects right channel)
x.set(\id, 2);

::



class:: RandSeed
summary:: Sets the synth's random generator seed.
related:: Classes/RandID
categories::  UGens>Generators>Stochastic, UGens>Random


Description::

When the trigger signal changes from nonpositive to positive, the synth's
random generator seed is reset to the given value. All synths that use
the same random number generator reproduce the same sequence of numbers
again.


See  link::Classes/RandID::  UGen for setting the randgen id and
link::Reference/randomSeed:: for the client side equivalent.


classmethods::

method::kr, ir

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::seed
The random seed.

Examples::

code::

// start a noise patch

(
{
var noise, filterfreq;
noise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);
filterfreq = LFNoise1.kr(3, 5500, 6000);
Resonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)
}.play;
)

// reset the seed at a variable rate
(
x = { arg seed=1956;
		RandSeed.kr(Impulse.kr(MouseX.kr(0.1, 100)), seed);
}.play;
)



x.set(\seed, 2001);
x.set(\seed, 1798);
x.set(\seed, 1902);


// above you can see that the sound of the LFNoise1 is not exactly reproduced (filter frequency)
// this is due to interference between the internal phase of the noise ugen and the
// seed setting rate.

// a solution is to start a new synth:

(
SynthDef("pseudorandom", { arg out, sustain=1, seed=1967, id=0;
	var noise, filterfreq;
	RandID.ir(id);
	RandSeed.ir(1, seed);


	noise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);
	filterfreq = LFNoise1.kr(3, 5500, 6000);

	Out.ar(out,
		Resonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)
		*
		Line.kr(1, 0, sustain, doneAction: Done.freeSelf)
	)

}).add;
)

// the exact same sound is reproduced
(
fork {
	loop {
		Synth("pseudorandom");
		1.1.wait; // wait a bit longer than sustain, so sounds don't overlap
	}
}
)

// changing the rand seed changes the sound:

(
fork {
	(1902..2005).do { |seed|
		seed.postln;
		3.do {
			Synth("pseudorandom", [\seed, seed]);
			1.1.wait;
		}
	}
}
)

// cd skipper
(
fork {
	(1902..2005).do { |seed|
		seed.postln;
		rrand(4,10).do {
			Synth("pseudorandom", [\seed, seed, \sustain, 0.05]);
			0.06.wait;
		}
	}
}
)

// if the sounds overlap, this does not work as expected anymore
// sounds vary.

(
fork {
	loop {
		Synth("pseudorandom");
		0.8.wait; // instead of 1.1
	}
}
)

// rand id can be used to restrict the resetting of the seed to each voice:

(
fork {
	var id=0;
	(1902..2005).do { |seed|
		seed.postln;
		3.do {
			Synth("pseudorandom", [\seed, seed, \id, id]);
			id = id + 1 % 16; // there is 16 different random generators
			0.8.wait;
		}
	}
}
)

::



CLASS:: RangeSlider
summary:: A view consisting of a sliding extendable handle
categories:: GUI>Views

DESCRIPTION::

A view that allows setting two numerical values between 0 and 1, represented by the two ends of a movable and extendable handle. It can have horizontal or vertical orientation, meaning the direction in which the handle moves and extends.

Dragging the mouse pointer on either end of the range moves the end by itself. Dragging in the middle of the range moves the whole range without changing its size.


CLASSMETHODS::

PRIVATE:: key

METHOD:: new

    When a new RangeSlider is created, its link::#-orientation:: is determined by the initial size: if it is wider than high, the orientation will be horizontal, otherwise it will be vertical.




INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: lo

	The low end of the range.

	If you attempt to set it higher then the current link::#-hi::, -hi will be set instead, and -lo will become the old -hi.

	When setting -lo the value will always be clipped to the range between 0 and 1.

	argument::
		A Float between 0 and 1.

METHOD:: hi

	The high end of the range. If you attempt to set it lower then the current link::#-lo::, -lo will be set instead, and -hi will become the old -lo.

	When setting -hi the value will always be clipped to the range between 0 and 1.

	argument::
		A Float between 0 and 1.

METHOD:: activeLo

	Sets link::#-lo:: to the argument and triggers link::#-action::.

METHOD:: activeHi

	Sets link::#-hi:: to the argument and triggers link::#-action::.

METHOD:: range

	The difference between link::#-hi:: and link::#-lo::. Setting -range will set -hi to -lo + -range.

METHOD:: activeRange

	Sets link::#-range:: to the argument and triggers link::#-action::.

METHOD:: setSpan

	Sets link::#-lo:: and link::#-hi:: to each of the arguments, respectively.

METHOD:: setSpanActive

	Calls link::#-setSpan::, forwarding the arguments, and triggers link::#-action::.

METHOD:: setDeviation

	Sets link::#-lo:: and link::#-hi:: according to their deviation and their average instead of their absolute values.

	argument:: deviation
		A Float determining the absolute deviation of -lo and -hi from their average.
	argument:: average
		A Float determining the average of -lo and -hi.

METHOD:: increment
	Increments both link::#-lo:: and link::#-hi:: by link::#-step:: multiplied by 'factor'.

	argument:: factor
		A Float.

METHOD:: decrement
	Decrements both link::#-lo:: and link::#-hi:: by link::#-step:: multiplied by 'factor'.

	argument:: factor
		A Float.





SUBSECTION:: Appearance

METHOD:: orientation
	The orientation of the RangeSlider - the direction in which the handle moves and is extendable. The default value depends on the size of the view when created.

	argument::
		One of the two Symbols: \horizontal or \vertical.

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: step
	The amount by which the range will change when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStep
	The absolute amount by which the range would change if the handle moved by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the position or size of the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## a               || lo_(0), hi_(1), and triggers action
	## n               || lo_(0), hi_(0), and triggers action
	## x               || lo_(1), hi_(1), and triggers action
	## c               || lo_(0.5), hi_(0.5), and triggers action
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		A Point of which the x and y coordinates are set to link::#-lo:: and link::#-hi::, respectively.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Point.

METHOD:: defaultReceiveDrag
	Sets  link::#-lo:: and link::#-hi:: to the two coordinates of the Point stored as the current drag data, respectively, and triggers the link::#-action::.



EXAMPLES::

subsection:: Basic examples

code::
(
w = Window.new.front;
a = RangeSlider(w, Rect(20, 80, 120, 30))
    .lo_(0.2)
    .range_(0.4)
    .action_({ |slider|
        [\sliderLOW, slider.lo, \sliderHI, slider.hi].postln;
    });
)
::

code::
(
w = Window.new.front;
a = RangeSlider(w, Rect(20, 80, 120, 30))
    .lo_(0.2)
    .hi_(0.8)
    .action_({ |slider|
        b.activeLo_(slider.lo); // this will trigger the action of b (and set it's value)
        b.hi_(slider.hi);
    });
b = RangeSlider(w, Rect(220, 80, 20, 130))
    .lo_(0.2)
    .hi_(0.8)
    .knobColor_(HiliteGradient(Color.grey, Color.white,\h))
    .action_({ |slider|
        [\sliderLOW, slider.lo, \sliderHI, slider.hi].postln;
    });

)
::

subsection:: Use of setDeviation

code::
(

w = Window("setDeviation", Rect(300, 300, 300, 150));
a = RangeSlider(w, Rect(10, 10, 200, 30))
    .lo_(0)
    .hi_(1);
b = Slider(w, Rect(10, 50, 200, 30))
    .action_(
        {   arg me;
            a.setDeviation(c.value, b.value);
        });
c = Slider(w, Rect(10, 100, 200, 30))
    .action_(
        {   arg me;
            a.setDeviation(c.value, b.value);
        }
    );
c.valueAction = 0.2;
w.front;
)
::

subsection:: Sound example

Shape a bandpass filter.

In Cocoa GUI, hold down the Ctrl key to move the whole range; in other GUI kits you can simply click within the range and drag it.

code::
(
s.waitForBoot({
    a={arg freq=1800, bw=0.2;
            var r;
            BBandPass.ar(WhiteNoise.ar(0.3), freq, bw);

            }.play;

    w = Window("2DSlider", Rect(100,Window.screenBounds.height-400, 400 ,50));
    t = RangeSlider(w, Rect(10, 10, 380, 30))
            .lo_(0.4)
            .hi_(0.6)
            .action_({|sl|
                a.set(\freq,1800*(sl.lo+sl.lo)+10,\bw, (sl.hi-sl.lo).abs+0.01);
            });
    t.doAction;

    w.front;
    CmdPeriod.doOnce({w.close});
})
)
::


CLASS::RawArray
categories::Collections>Ordered
summary:: Abstract superclass for arrays holding raw data values

DESCRIPTION::
RawArray is the abstract superclass of a group of array classes that hold raw data values.

INSTANCEMETHODS::

private::archiveAsCompileString, archiveAsObject


class::RawPointer
categories::Core>Kernel
summary:: Hold raw pointers from the host environment

description::

A class used to hold raw pointers from the host environment.
No instance variables, no methods.



TITLE:: ReadableNodeIDAllocator
summary:: an allocator for nodeIDs with human-readable ownership
categories:: Control
related:: Classes/Server, Guides/MultiClient_Setups

DESCRIPTION::
In multi-client setups, it is useful to know which client created which nodeIDs on a shared server. ReadableNodeIDAllocator provides that facility by using a decimal prefix based on the clientID.


code::
// default server uses a ReadableNodeIDAllocator
s.nodeAllocator;
s.nodeAllocator.userID; // its userID is
s.clientID

// which creates this defaultGroup 1
s.defaultGroup;
s.defaultGroupID;
// and temp nodes begin with 1000 ...
3.do { s.nextNodeID.postln };


// make a dummy server with different clientID
r = Server(\remote4, s.addr, s.options, clientID: 4);
// defaultGroup begins with 400000 ... prefix and ends with 1
r.defaultGroup;
r.defaultGroupID;
// and temp nodes begin with 400001000 ...
3.do { r.nextNodeID.postln };
::

CLASSMETHODS::

METHOD:: new
make a new instance for given clientID, offset for lowest temporary id, and
argument:: clientID
the clientID for which to create an offset/prefix
argument:: lowestTempID
the offset for the lowest temporary id
argument:: numClients
the number of clients for which to split the number range

code::
// make an allocator with id 11
a = ReadableNodeIDAllocator(11, 1000, 12);
// begins with 1100000 ... prefix
3.do { a.alloc.postln };
::

INSTANCEMETHODS::

METHOD:: clientID
the clientID for which to create an offset/prefix

METHOD:: numClients
the number of clients for which to split the number range

METHOD:: lowestTempID
the offset from where temporary nodeID begin

METHOD:: idOffset
the offset from where nodeID range begins

METHOD:: maxPermID
the highest permanent nodeID

METHOD:: numIDs
the number of IDs before the allocator will wrap

METHOD:: alloc
allocate next temporary nodeID

METHOD:: allocPerm
allocate next permanent nodeID

METHOD:: freePerm
free a permanent nodeID
argument:: id

METHOD:: isPerm
test whether num is in the allocator's range of permanent numbers
argument:: num

METHOD:: reset
reset allocator to initial state



class:: RecNodeProxy
summary:: a NodeProxy that can record
categories:: JITLib>NodeProxy
related:: Classes/NodeProxy

description::
this is also created from a link::Classes/NodeProxy::, or an link::Classes/Ndef:: with the message strong::record::.

ClassMethods::

method::new
see superclass

method::audio
see superclass

method::newFrom
instantiate a new proxy that listens to the in proxy.

InstanceMethods::

method::open
open new file and initialize buffer on server

method::record
start the recording synth.

argument::paused
if paused is false start recording immediately.

argument::clock
optional - the clock to use for scheduling recording ...
argument::quant
... if a non-nil quant is given.

method::close
stop recording, close file

method::isRecording
see if recording right now

method::wakeUp
until the proxy is not used by any output ( either .play or .ar/.kr ) it is not running on the server. you can wake it up to force it playing.

Examples::

code::
s.boot;

a = RecNodeProxy.audio(s, 2);
a.source = { SinOsc.ar([400,500], 0, 0.1) };
a.play; //monitor;
a.open("xproxySpace.aif");
a.record(false);

a.source = { SinOsc.ar([400,700], 0, 0.1) };
a.source = { SinOsc.ar([410,510], 0, 0.1) };
a.source = { SinOsc.ar([LFNoise1.kr(80, 100, 300),500], 0, 0.1) };

//stop recording and close file
a.close;

//monitor off
a.stop;
::

subsection::recording from some bus

code::
a = Bus.audio(s, 2);

SynthDef("test", { arg out; Out.ar(out, { WhiteNoise.ar(0.1) }.dup(2)) }).add;
x = Synth("test", [\out, a]);


n = RecNodeProxy.audio(s, 2);
n.source = { InFeedback.ar(a, 2) };

n.play;//monitor
n.stop;//turn off monitor

n.open("noise.aif");
n.record;
n.unpause;

n.close;
::

subsection::instance creation from an existent node proxy

code::
b = NodeProxy.audio(s, 2);
b.play; //listen to b
b.source = { SinOsc.ar([400,500], 0, 0.1) }; //play something

r = RecNodeProxy.newFrom(b);
r.open("recproxy514.aif"); //open file
r.record; //start recorder (paused)

r.unpause; //start recording

b.source = { SinOsc.ar([430,500], 0, 0.1) };
b.source = { SinOsc.ar([410,510], 0, 0.1) };
b.source = { SinOsc.ar([LFNoise1.kr(80, 100, 300), 500], 0, 0.1) };
r.pause;
b.source = { WhiteNoise.ar(0.01) };
r.unpause;
r.pause;


//stop recording and close file
r.close;
b.stop; //stop listen to b
::

subsection::instance creation from an existent node proxy again

code::
b = NodeProxy.audio(s, 2);
b.play; //listen to b
b.source = { SinOsc.ar([400,500], 0, 0.1) }; //play something

r = b.record("recproxy101.aiff"); //start recorder (paused)
r.unpause; //start recording
r.close; //end recording, close file
b.stop;	//stop listen
::

subsection::recording from other sources

code::
s.boot;

a = RecNodeProxy.audio(s, 2);
b = a.index; //get the bus index;
a.play;		//monitor;
a.open("xproxySpace.aif");
a.record;
a.unpause;

(
Routine({
	var id;
	loop({
		id = s.nextNodeID;
		s.sendMsg("/s_new", "default", id,0,0, \out, b, \freq, rrand(400, 800));
		0.2.wait;
		s.sendMsg("/n_set", id, \gate, 0);
		0.2.wait;
	})
}).play;
)


//stop recording and close file
a.close;

//monitor off
a.stop;
::


class:: RecordBuf
summary:: Record or overdub into a Buffer.
related:: Classes/PlayBuf
categories::  UGens>Buffer

Description::
Records input into a link::Classes/Buffer::.

If recLevel is 1.0 and preLevel is 0.0 then the new input overwrites the
old data. If they are both 1.0 then the new data is added to the existing
data. (Any other settings are also valid.)

note:: The number of channels must be fixed for the SynthDef, it cannot vary depending on which buffer you use. ::

classmethods::

method::ar, kr

argument::inputArray
An Array of input channels.

argument::bufnum
The index of the buffer to use.

argument::offset
An offset into the buffer in samples.

argument::recLevel
Value to multiply by input before mixing with existing data.

argument::preLevel
Value to multiply to existing data in buffer before mixing with input.

argument::run
If zero, then recording stops, otherwise recording proceeds.

argument::loop
If zero then don't loop, otherwise do. This is modulatable.

argument::trigger
a trigger causes a jump to the start of the Buffer. A trigger
occurs when a signal changes from negative value to positive
value.

argument:: doneAction
an integer representing an action to be executed when the buffer is finished recording. This can be used to free the enclosing synth, etc. See link::Classes/Done:: for more detail. code::doneAction:: is only evaluated if loop is 0.

Examples::

code::
// Execute the following in order
(
// allocate a Buffer
s = Server.local;
b = Buffer.alloc(s, 44100 * 4.0, 1); // a four second 1 channel Buffer
)

// record for four seconds
(
SynthDef(\help_RecordBuf, { arg out = 0, bufnum = 0;
	var formant;
	formant = Formant.ar(XLine.kr(400,1000, 4), 2000, 800, 0.125);
	RecordBuf.ar(formant, bufnum, doneAction: Done.freeSelf, loop: 0);
}).play(s,[\out, 0, \bufnum, b]);
)

// play it back
(
SynthDef(\help_RecordBuf_playback, { arg out = 0, bufnum = 0;
	var playbuf;
	playbuf = PlayBuf.ar(1,bufnum);
	FreeSelfWhenDone.kr(playbuf); // frees the synth when the PlayBuf is finished
	Out.ar(out, playbuf);
}).play(s, [\out, 0, \bufnum, b]);
)

// overdub
(
SynthDef(\help_RecordBuf_overdub, { arg out=0, bufnum=0;
	var formant;
	formant = Formant.ar(XLine.kr(200, 1000, 4), 2000, 800, 0.125);
	// mixes equally with existing data
	RecordBuf.ar(formant, bufnum, 0, 0.3, 0.5, doneAction: Done.freeSelf, loop: 0);
}).play(s, [\out, 0, \bufnum, b]);
)

// play back the overdubbed version
Synth.new(\help_RecordBuf_playback, [\out, 0, \bufnum, b], s);

// write the contents of the buffer to a file (see Buffer for more options)
(
b.write(sampleFormat: 'int16');
thisProcess.platform.recordingsDir +/+ "SC_" ++ Date.localtime.stamp ++ ".aiff"; // generated path
)

b.close; b.free; // cleanup
::



class:: Recorder
summary:: Write Audio to Harddisk
categories:: Server>Abstractions
related:: Classes/Server, Classes/DiskOut, Guides/Non-Realtime-Synthesis

description:: A Recorder allows you to write audio to harddisk, reading from a given bus and a certain number of channels, relative to a given node. A link::Classes/Server:: has one instance, which is accessible also through the link::Classes/ScIDE::. You can use the server directly to record its output


code::
(
{ SinOsc.ar(
	SinOsc.ar(
		XLine.kr(1, 100, 5)).exprange(*XLine.kr([20, 800], [7000, 200], 10)
    )
   ) * 0.1

}.play;
s.record(duration: 10);
)
::


This functionality is also available through the recording button on the server windows.
Pressing it once calls record, and pressing it again calls stopRecording (see below). When doing so the file created will be in your recordings folder and be named for the current date and time.
The default location of the recordings folder varies from platform to platform. Setting this variable allows you to change the default.

code::
// find where the recordings are written to
thisProcess.platform.recordingsDir
::

NOTE::
By default, record creates the recording synth after the Server's default group and uses In.ar. Thus if you add nodes after the recording synth their output will not be captured.
To avoid this, either use Node objects (which use the default node as their target) or (when using messaging style) use a target nodeID of 1.
code::
s.sendMsg("/s_new", "default", s.nextNodeID, 1, 1);
::
::

For more detail on this subject see link::Guides/Order-of-execution::, link::Reference/default_group::, and link::Guides/NodeMessaging::.

See link::Classes/SoundFile:: for information on the various sample and header formats.
Not all sample and header formats are compatible. Note that the sampling rate of the output file will be the same as that of the server app. This can be set using the Server's link::Classes/ServerOptions::.



ClassMethods::

method::new
Create a new instance for a given server.

argument::server


InstanceMethods::

method:: prepareForRecord
Allocates the necessary buffer, etc. for recording the server's output. (See code::record:: below.)

argument:: path
a link::Classes/String:: representing the path and name of the output file. If the directory does not exist, it will be created for you. (Note, however, that if this fails for any reason, recording will also fail.)

argument::numChannels
The number of output channels to record.

discussion::
If you do not specify a path than a file will be created in your recordings folder (see the note above on this) called code::SC_thisDateAndTime::. Changes to the header or sample format, or to the number of channels must be made strong::before:: calling this.



method:: record
Starts or resumes recording the output.
argument:: path
this is optional, and is passed to code::prepareForRecord:: (above).

argument:: bus
The bus (link::Classes/Bus:: object or integer bus index), the offset at which to start to count the number of channels. You can record any adjacent number of bus channels.

argument:: numChannels
The number of output channels to record.

argument:: node
The link::Classes/Node:: to record immediately after. By default, this is the default group 1.

argument:: duration
If set, this limits recording to a given time in seconds.

note::The recording starts when the buffer has been allocated, and after the usually very short network latency. It will last for the code::duration:: exactly down to one server block size (64 samples). For scheduling the starting point of a recording precisely, call link::#-prepareForRecord:: first, and then call link::#-record:: a bundle (see link::Classes/Server#-bind:: and  link::Classes/Server#-sync::).::

discussion::
If you have not called prepareForRecord first (see above) then it will be invoked for you (but that adds a slight delay before recording starts for real).

code::
r = Recorder(s);
{ GVerb.ar(Dust.ar(4)) }.play; // play on bus 64
r.record(numChannels:2);
r.stopRecording;
::

method:: pauseRecording
Pauses recording. Can be resumed by executing record again, or by calling resumeRecording.

method:: resumeRecording
Start recording again.

method:: stopRecording
Stops recording, closes the file, and frees the associated resources.
discussion::
You must call this when finished recording or the output file will be unusable. Cmd-. while recording has the same effect.

method::filePrefix
a string used as prefix for the path when recording. This can be used to separate the outputs of several recorders. The default is code::"SC_"::.

method::numChannels
a number of sound file channels that is used always when using this recorder, unless a different one is specified in the link::#-record:: method. When not set, we use link::Classes/Server#-recChannels::.

method:: recHeaderFormat
Get/set the header format (string) of the output file. The default is "wav". Must be called strong::before:: prepareForRecord.

method:: recSampleFormat
Get/set the sample format (string) of the output file. The default is "float". Must be called strong::before:: prepareForRecord.

method::recBufSize
Get/set the size of the link::Classes/Buffer:: to use with the link::Classes/DiskOut:: UGen. This must be a power of two. The default is the code::sampleRate.nextPowerOfTwo:: or the first power of two number of samples longer than one second. Must be called strong::before:: prepareForRecord.

method::isRecording
returns true if we are in the process of recording

method::paused
returns true if recording is paused

method::duration
returns the number of seconds we have been recording so far

method::path
returns the path of the current recording

method::numFrames
returns the number of frames of the recording buffer

method::notifyServer
if set to true, it will send code::changed:: notifications to the server instance. This is used internally by the link::Classes/Server:: class.


method::server
server to record from

private::cmdPeriod
private::prRecord
private::prStopRecord
private::makePath
private::changedServer

section::Examples


code::
// something to record
(
SynthDef("bubbles", { |out|
	var f, sound;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8, 7.23], 0, 3, 80)).midicps; // glissando function
	sound = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(out, sound);
}).add;

SynthDef("tpulse", { |out = 0, freq = 700, sawFreq = 440.0|
	Out.ar(out, SyncSaw.ar(freq, sawFreq, 0.1))
}).add;

)

x = Synth.new("bubbles");

s.prepareForRecord; // if you want to start recording on a precise moment in time, you have to call this first.

s.record; // start recording. This can also be called directly, if it isn't imprtant when precisely you need to start.

s.pauseRecording; // pausable

s.record // start again

s.stopRecording; // this closes the file and deallocates the buffer recording node, etc.

x.free; // stop the synths

// look in your recordings folder and you'll find a file named for this date and time
::

code::
// set location to your home folder (change user with your username)
thisProcess.platform.recordingsDir = "/home/user/";

// instantiate the Recorder
r = Recorder.new(s);

// record into a flac file
r.recHeaderFormat = "flac";

// default 'float' is incompatible with flac. set to 24bit:
r.recSampleFormat = "int24";

// set very obvious prefix for files
r.filePrefix = "SuperCollider_";

// start recording:
r.record;

// stop recording
r.stopRecording;
::

class:: Rect
summary:: Rectangle
categories:: Geometry

ClassMethods::

method::new
Return a new Rect with the given upper left corner and dimensions.

method::newSides
Return a new Rect with the given boundaries.

method::fromPoints
Return a new Rect defined by the given Points.

InstanceMethods::

method::left
Get or set the value of the boundary.

method::top
Get or set the value of the boundary.

method::right
Get the value of the boundary.

method::bottom
Get the value of the boundary.

method::set
Set the boundaries to the given values.

method::setExtent
Set the dimensions.

method::width
Set or get the width.

method::height
Set or get the height.

method::origin
Return the upper left corner as a Point.

method::extent
Return a Point whose x value is the height and whose y value is the width.

method::leftTop
Return the upper left corner as a Point.

method::rightTop
Return the upper right corner as a Point.

method::leftBottom
Return the lower left corner as a Point.

method::rightBottom
Return the lower right corner as a Point.

method::moveBy
Returns a new Rect which is offset by x and y.

method::moveTo
Returns a new Rect whose upper left corner is moved to (x, y).

method::moveToPoint
Returns a new Rect whose upper left corner is moved to aPoint.

method::resizeBy
Returns a new Rect whose dimensions have been changed by (x, y).

method::resizeTo
Returns a new Rect whose dimensions are (x, y).

method::insetBy
Returns a new Rect whose boundaries have been inset by (x, y). If only one argument is supplied, it will be used for both x and y.

method::insetAll
Returns a new Rect whose boundaries have been inset by the given amounts.

method::contains
Answers whether aPoint is in the receiver.

method::union, |
Returns a new Rect which contains the receiver and aRect.

method::sect, &
Returns a new Rect which is the intersection of the receiver and aRect.



class:: Ref
summary:: a reference to a value
categories:: Core

description::

A Ref holds an object which may be retrieved and altered with the messages value and value_(obj).
The backquote code:: ` :: is a unary operator that is equivalent to calling code::Ref.new(obj)::.

Refs are most commonly used to prevent multi-channel expansion in link::Classes/SynthDef::s and link::Classes/Pattern::s (see link::Classes/Klank:: for an example).
Refs can also be used to simplify the coding of co-routines used in EventStreams (see link::Classes/Prout:: for an example).

code::

x = Ref(nil);
z = obj.method(x);		// method puts something in reference
x.value.doSomething;	// retrieve value and use it

::

Ref is also used as a quoting device to protect against multi channel expansion in certain UGens that require Arrays.

classmethods::

method::new

create a Ref of an object.
discussion::
Another syntax:

code::
`5
::

instancemethods::

method::dereference

Answer the value. This message is also defined in class Object where it just returns the receiver.  Therefore anything.dereference will remove a Ref if there is one. This is slightly different than the value message, because value will also cause functions to evaluate themselves whereas dereference will not.

method::asRef

Answers the receiver. In class Object this message is defined to create a Ref of the object.

method::value

Get or set the value.

method::get

Returns value.

method::set

Sets value.

method::at

Returns code::value.at(index)::

method::put
Executes value.put(index, value)

method::seq

this method is used to return values from within a Routine definition

discussion::
code::
{ this.value = output.embedInStream(this.value); }
::

method::asUGenInput

Returns the Ref - this prevents multi-channel expansion in a SynthDef

method::asControlInput

Returns the value - this is used when sending a Ref as a control value to a server Node.

section::Typical uses of Ref:

subsection::preventing multi-channel expansion

Consult link::Guides/Multichannel-Expansion:: for details on multi-channel expansion in SynthDefs.

Refs prevent multi-channel expansion in a SynthDef, so the array below defines one Klank UGen rather than three.

code::
{ Klank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;
::

Refs cannot be used reliably to suppress multi-channel expansion within Events and Patterns.
Instead, it is necessary to enclose the array of values in another array:

code::
(
	SynthDef(\multi, { | out, freq = #[100,200,300], amp = 0.1, pan = 0, sustain = 1|
		var audio, env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction: Done.freeSelf);
		audio = Mix(Saw.ar(freq));
		audio = Pan2.ar(audio * env, pan, amp);
		OffsetOut.ar(out, audio)
	}).add;

	( instrument: \multi, freq: [ [500, 501, 700] ], sustain: 2).play

)
::

code::
(
	Pbind(*[
		instrument: \multi,
		freq: 	Prand([
						[[100, 141, 103] ],
						[[100, 310, 190] ],
						[[100, 100.1, 110] ],
				], inf),
		dur: 0.2,
		sustain: 0.3
	]).play;
)
::


method::multichannelExpandRef
This method is called internally on inputs to UGens that take multidimensional arrays, like link::Classes/Klank:: and it allows proper multichannel expansion even in those cases. For SequenceableCollection, this returns the collection itself, assuming that it contains already a number of Refs.

argument::rank
The depth at which the list is expanded. For instance the Klank spec has a rank of 2.
code::
`([[[100, 200], 500], nil, [[[0.01, 0.3], 0.8]]]).multichannelExpandRef(2);
[`[[100, 200], nil, [0.2, 0.8]], `[[130, 202], nil, [0.2, 0.5]]].multichannelExpandRef(2);
::


class::RefCopy
summary::a reference to the copy of a value
categories::Core

description::
A Ref  instance is an object with a single slot named 'value' that serves as a holder of  an object.
RefCopy, in difference to Ref, returns only copies of the value when next is called.
This can be useful when the original is to be kept unchanged.

see link::Classes/Ref:: for other methods.

examples::

code::
a = [1, 2, 3];
x = RefCopy(a);
b = x.next;
b.put(0, 100); // modify b
a; // a is unchanged.
::


class:: ReplaceOut
summary:: Send signal to a bus, overwriting previous contents.
related:: Classes/OffsetOut, Classes/Out, Classes/XOut
categories::  UGens>InOut


Description::
link::Classes/Out::  adds it's output to a given bus, making it
available to all nodes later in the node tree (See link::Classes/Synth:: and
link::Guides/Order-of-execution:: for more information). ReplaceOut overwrites those
contents. This can make it useful for processing.


See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("ReplaceOutHelp", { arg out=0, freq=440;
	var source;
		source = SinOsc.ar(freq, 0, 0.1);

		// write to the bus, replacing previous contents
		ReplaceOut.ar(out, source);

}).add;
)

// each Synth replaces the output of the previous one
x = Synth.tail(s, "ReplaceOutHelp", [\freq, 500]);
y = Synth.tail(s, "ReplaceOutHelp", [\freq, 600]);
z = Synth.tail(s, "ReplaceOutHelp", [\freq, 700]);

// release them in reverse order; the older Synths are still there.
z.free;
y.free;
x.free;

::



class:: Resonz
summary:: Resonant filter.
related:: Classes/Formlet, Classes/RHPF, Classes/RLPF, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

This is the same as  link::Classes/Ringz:: , except that it has a constant gain at 0 dB instead of being constant skirt.

It is a two pole resonant filter with zeroes at

code::
z = ±1
::


Based on  emphasis::K. Steiglitz,  "A Note on Constant-Gain Digital Resonators", Computer Music Journal, vol 18, no. 4, pp. 8-10, Winter 1994::.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Resonant frequency in Hertz.
WARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!

argument::bwr

Bandwidth ratio (reciprocal of Q). rq = bandwidth / centerFreq.


The reciprocal of Q is used rather than Q because it saves a
divide operation inside the unit generator.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ Resonz.ar(WhiteNoise.ar(0.5), 2000, 0.1) }.play

// modulate frequency
{ Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.play

// modulate bandwidth
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(1, 0.001, 8)) }.play

// modulate bandwidth opposite direction
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(0.001, 1, 8)) }.play

::



CLASS:: Rest
summary:: Represents a rest in event patterns
categories:: Streams-Patterns-Events
related:: Classes/Pbind, Classes/Event, Classes/AbstractFunction

DESCRIPTION::
A Rest may be used in event patterns to indicate that the resulting event should be a rest (i.e., silent). It should be used in one of the child patterns belonging to a Pbind, for instance.

code::
// do nothing for 2 seconds
(note:Rest(), dur:2).play;

// intersperse pauses in pattern
Pbind(\note, Pseq([0, 4, 7, 11], inf), \dur, Pseq([2, 1, Rest(1)], inf) / 5).play;
::

subsection:: Expressing rests in event patterns

The Rest class allows rests to be indicated in any stream, not only frequency or event type. Also, using the duration argument (see the link::#*new:: method below), rests may be embedded into a duration stream. That is, rests may be treated as part of the rhythmic specification, rather than the pitch specification.


note::
As of SuperCollider 3.9, code::Rest::'s behavior has changed to be more intuitive. Note that you have to now use code::Rest():: - the shortcut of code::Rest:: as class directly is strong::not supported:: anymore.
::


subsection:: Usage

list::
## link::Classes/Event#-isRest:: checks every item in the event to see if it meets the condition to be a rest: it may be a code::Rest:: instance, the code::Rest:: class, or either of the symbols code:: \ :: or code::\r::. If any item meets the condition, the event will be considered a rest and it will not take action when played.

## If a Pbind child pattern yields a Rest object, the Rest is placed directly into the event. This is a change of behavior from 3.8.

## If a Rest object has a value, it will respond to math operations: code::Rest(1) * 2 == Rest(2)::.
::


CLASSMETHODS::
All methods of Rest except *new are private, and should not be used directly.

private:: processRest
private:: embedInStream
private:: asStream

METHOD:: new
Create an instance of Rest, with a value to be used in the resulting rest event.

argument:: value
The Rest instance's numeric value, to be used in math operations. Note that a Rest's value is ignored for most Event keys (assuming the Event does nothing in response to code::.play::). If a Rest appears in a rhythm key (code::dur:: or code::delta::), then the number is the time until the next event. Consequently, numeric Rests are often used for duration -- but there is no requirement that a Rest's value must be a duration.

discussion::
code::
a = Rest(6);
b = a * 2; // returns Rest(12)
b = 2 * a; // the same
b.value; // returns 12
::

The rest of a rest is always a rest. This idempotence is implemented by Rest's superclass link::Classes/Operand::.
code::
Rest(Rest(1)) // returns Rest(1)
::


INSTANCEMETHODS::
private:: dur
private:: embedInStream
private:: asStream
private:: asControlInput
private:: playAndDelta

METHOD:: isRest
returns true

METHOD::unwrapBoolean
returns the value.
discussion::
This method implements the following behavior.
code::
Rest(6) + 1 // Rest(7)
Rest(true) // true
::
This makes comparisons work:
code::
Rest(6) < 7 // true, and not Rest(true)
a = Pseq([1, 2, 1, 3, Rest(1), 2, Rest(3)], inf); // e.g. as a duration pattern
b = a.collect { |x| if(x > 2) { x / 2 } { x } };
b.asStream.nextN(8)
::

EXAMPLES::


Using Rest instances in a pitch stream

code::
(
Pbind(
	\degree, Pif(
		0.1.loop.coin,
		Pseq([Rest(), 7], inf), // every second is a Rest
		Pseries(0, 1, inf).fold(-7, 7)
	),
	\dur, 0.125
).play
)
::

Using a Rest instance in a duration stream
code::
(
Pbind(
	\degree, Pseries(0, 1, inf).fold(-7, 7),
	\dur, Pseq([Pn(0.125, { rrand(3, 6) }), Rest(0.25)], inf)
).play
)
::


subsection:: Alternatives to Rest

In addition to Rest, in events, rests can be specified in two other ways (legacy usages).

list::
## A link::Classes/Symbol:: may be specified in any frequency stream (under the keys degree, note, midinote or freq). The exception to this rule is control bus mapping symbols, beginning with 'c' followed by a number. Typical symbols that have been used include strong::\rest::, strong::\r:: and the empty symbol strong:: \ ::.

code::
(
p = Pbind(
	\degree, Pseq([
		0, 1, 2, 0, 0, 1, 2, 0,
		2, 3, 4, \rest, 2, 3, 4, \rest
	]),
	\dur, 0.25
).play;
)
::

## The event's strong::\type:: may be set to strong::\rest::.

code::
(
p = Pbind(
	\degree, Pseries(0, 1, inf).fold(-7, 7),
	\dur, 0.125,
	\type, Pwrand([\note, \rest], [0.9, 0.1], inf)
).play;
)

p.stop;
::
::


CLASS:: RingBuffer
SUMMARY:: Fixed size ringbuffer
CATEGORIES:: Collections>Ordered
RELATED:: Classes/LinkedList

DESCRIPTION::
A circular buffer that holds a fixed-size collection. Can be used as a queue.


CLASSMETHODS::

METHOD:: new
Create a new buffer.

ARGUMENT:: size
Initial size. The collection will be able to hold one minus this number of values.

ARGUMENT:: collectionClass
Defaults to the LINK::Classes/Array:: class.


INSTANCEMETHODS::

METHOD:: array
The collection.

METHOD:: readPos
Current read position.

METHOD:: writePos
Current write position.

METHOD:: maxSize
Maximum capacity.

METHOD:: size
Alias of LINK::#-readable::.

METHOD:: readable
Number of readble items.

METHOD:: writable
Number of writable items.

METHOD:: add
Add value and increase LINK::#-writePos::. Do nothing if no items can be written.

METHOD:: pop
Return next readable item and increase LINK::#-readPos::. Return CODE::nil:: if no items can be read.

METHOD:: overwrite
Add value and increase LINK::#-writePos:: by overwriting oldest readable item.

METHOD:: do
Iterate over the currently readable items.


EXAMPLES::

CODE::

r = RingBuffer(4);
r.add(\one);
r.add(\two);
r.add(\three);
r.readable;
r.do{ | x | x.postln};


r = RingBuffer(12, Int16Array);
r.writable.do{ | i | r.add(i + 1 * 100) };
r.array;
r.readable;  //11
r.writable;  //0 = full
r.pop;
r.pop;
r.pop;
r.readable;  //8
r.writable;  //3


(
var num = 100;
var m = MultiSliderView().elasticMode_(1).size_(num).front;
var r = RingBuffer(num + 1, DoubleArray);
Routine({
	while { m.isClosed.not } {
		if(r.writable == 0, { r.pop });
		r.add(sin(thisThread.seconds).abs);
		r.do{ | v, i |
			m.index = i;
			m.currentvalue = v;
		};
		(1/60).wait;
	}
}).play(AppClock);
)
::


class:: Ringz
summary:: Ringing filter.
related:: Classes/Formlet, Classes/RHPF, Classes/RLPF, Classes/Resonz
categories::  UGens>Filters>Linear


Description::

This is the same as  link::Classes/Resonz:: , except that it is a constant skirt gain filter, meaning that the peak gain depends on the value of Q. Also, instead of the
resonance parameter in Resonz, the bandwidth is specified in a 60dB ring decay time. One Ringz is equivalent to one component of the
link::Classes/Klank::  UGen.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Resonant frequency in Hertz.


argument::decaytime

The 60 dB decay time of the filter.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
{ Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.play

{ Ringz.ar(WhiteNoise.ar(0.005), 2000, 0.5) }.play

// modulate frequency
{ Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.play

{ Ringz.ar(Impulse.ar(6, 0, 0.3), XLine.kr(100,3000,10), 0.5) }.play

// modulate ring time
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(4, 0.04, 8)) }.play

// modulate ring time opposite direction
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(0.04, 4, 8)) }.play

(
{
    var exciter;
    exciter = WhiteNoise.ar(0.001);
    Mix.arFill(10, {
        Ringz.ar(exciter,
        XLine.kr(exprand(100.0,5000.0), exprand(100.0,5000.0), 20),
        0.5)
    })
}.play
)
::

Section:: Interaction with sample rate

Ringz (and UGens that are based on it: link::Classes/Klank::, link::Classes/DynKlank:: and link::Classes/Formlet::) are "sample-rate independent" with respect to emphasis::impulses:: at the input. That is, given single-sample impulses, the output signal at different sample rates should be the same frequency and amplitude.

This design has a side effect: If the input is not made of impulses, the output amplitude is proportional to the sample rate.

code::
(
a = {
	// rectangular pulse exciter (deterministic input)
	var exc = EnvGen.ar(Env([1, 1, 0], [0.01, 0], \lin)),
	sig = Ringz.ar(exc, 440, decaytime: 0.2),
	rms = sqrt(Integrator.ar(sig.squared) * (0.2 / SampleRate.ir)),
	end = DetectSilence.ar(sig, doneAction: 2);
	rms.poll(end);
	Silent.ar(1)
}.play;
)
::

At 44.1 kHz, this prints a RMS amplitude of 1.0758. At 88.2 kHz, the amplitude doubles.

Modal synthesis (simulating the vibrating modes of a struck surface) feeds a short, decaying burst of noise into Ringz-style resonators. This is a common use case that emphasis::is:: subject to this amplitude effect.

If you will need the results to be compatible at different sample rates, make sure to scale the volume appropriately: if code::sig:: is the Ringz, Klank or Formlet signal, use code::sig * (originalSampleRate / SampleRate.ir):: and substitute the right value in place of code::originalSampleRate::.


class:: RootNode
summary:: The persistent root group on the server
categories:: Server>Nodes
related:: Classes/Group, Reference/default_group

description::
A RootNode is the Group with the nodeID of 0 which is always present on each Server and represents the root of that server's node tree.

It is always playing, and always running, cannot be freed, or moved anywhere.

Caching is used so that there is always one RootNode per link::Classes/Server::.
code::
s = Server.local;

a = RootNode(s);
b = RootNode(s);

a === b; // identical object
::
sending code::"/s_new":: messages to the server, the target 0 is what is represented by this object.
code::
s.sendMsg("/s_new", "default", -1, 0, 0);//the last argument is the target id
::
IMPORTANT: In general one should strong::not:: add nodes to the RootNode unless one has a specific reason to do so. Instead one should add nodes to the default_group.
This provides a known basic node order and protects functionality like Server.record, Server.scope, etc. The default group is the default target for all new nodes, so when using object style nodes will normally not be added to the RootNode unless that is explicitly specified. See link::Reference/default_group:: for more information.

classmethods::
private:: initClass
instancemethods::
private:: rninit, free, moveBefore, moveAfter, moveToHead, moveToTail, run



class:: Rotate2
summary:: Rotate a sound field.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB, Classes/PanB2
categories::  UGens>Multichannel>Ambisonics, UGens>Multichannel>Panners


Description::

Rotate2 can be used for rotating an ambisonic B-format sound field around
an axis. Rotate2 does an equal power rotation so it also works well on
stereo sounds. It takes two audio inputs (x, y) and an angle control
(pos). It outputs two channels (x, y). It computes this:

code::
xout = cos(angle) * xin + sin(angle) * yin;
::

code::
yout = cos(angle) * yin - sin(angle) * xin;
::

where angle = pos * pi,  so that -1 becomes -pi and +1 becomes +pi. This
allows you to use an LFSaw to do continuous rotation around a circle.


classmethods::

method::ar, kr

argument::x

Input signal X.


argument::y

Input signal Y.


argument::pos

angle to rotate around the circle from -1 to +1. -1 is 180
degrees, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind.


Examples::

code::

(
{
	var w, x, y, p, q, a, b, c, d;

	p = WhiteNoise.ar(0.05); // source
	q = LFSaw.ar(200,0,0.03)+LFSaw.ar(200.37,0,0.03)+LFSaw.ar(201,0,0.03);

	// B-format encode 2 signals at opposite sides of the circle
	#w, x, y = PanB2.ar(p, -0.5) + PanB2.ar(q, 0.5);

	#x, y = Rotate2.ar(x, y, MouseX.kr(-1,1));

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)



// Rotation of stereo sound:
(
{
	// rotation via lfo
	var x, y;
	x = PinkNoise.ar(0.4);
	y = LFTri.ar(800) * LFPulse.kr(3,0,0.3,0.2);
	#x, y = Rotate2.ar(x, y, LFSaw.kr(0.1));
	[x,y]
}.play;
)

{
	// rotation via mouse
	var x, y;
	x = Mix.fill(4, { LFSaw.ar(200 + 2.0.rand2, 0, 0.1) });
	y = SinOsc.ar(900) * LFPulse.kr(3,0,0.3,0.2);
	#x, y = Rotate2.ar(x, y, MouseX.kr(0,2));
	[x,y]
}.play;


// Rotate B-format about Z axis:

wout = win;
zout = zin;
#xout, yout = Rotate2.ar(xin, yin, pos);

// Rotate B-format about Y axis:

wout = win;
yout = yin;
#xout, zout = Rotate2.ar(xin, zin, pos);

// Rotate B-format about X axis:

wout = win;
xout = xin;
#yout, zout = Rotate2.ar(yin, zin, pos);

::



class::Routine
categories::Core>Kernel
summary:: Functions that can return in the middle and then resume where they left off
related:: Classes/Stream

description::
A Routine runs a link::Classes/Function:: and allows it to be suspended in the middle
and be resumed again where it left off. This functionality is supported by the Routine's
superclass link::Classes/Thread::. Effectively, Routines can be used to implement
co-routines as found in Scheme and some other languages.

A Routine is strong::started:: the first time link::#-next:: is called, which will run
the Function from the beginning. It is strong::suspended:: when it "yields"
(using link::Classes/Object#-yield:: within the Function), and then strong::resumed::
 using link::#-next:: again. When the Function returns, the Routine is considered
strong::stopped::, and calling link::#-next:: will have no effect - unless the Routine is
strong::reset:: using link::#-reset::, which will rewind the Function to the beginning.
You can stop a Routine before its Function returns using link::#-stop::.

When a Routine is strong::scheduled:: on a link::Classes/Clock:: (e.g. using
link::#-play::), it will be started or resumed at the scheduled time. The value yielded
by the Routine will be used as the time difference for rescheduling the Routine. (See
link::#-awake::).

Since Routine inherits from link::Classes/Thread::, it has its own associated
link::Classes/Thread#-beats#logical time::, etc. When a Routine is started or
resumed, it becomes the link::Classes/Thread#.thisThread#current thread::.

Routine also inherits from link::Classes/Stream::, and thus shares its ability to be
combined using math operations and "filtered".


classMethods::

method::new

Creates an instance of Routine, passing it the Function with code to run.

argument::func
A Function with code for the Thread to run.

argument::stackSize
Call stack size (an Integer).

discussion::
code::
a = Routine.new({ 1.yield; 2.yield; });
a.next.postln;
a.next.postln;
a.next.postln;
::

The Function class provides its own shortcut method code::r:: that calls code::Routine.new::, thus one can also write:

code::
a = r { 1.yield; 2.yield };
::

instanceMethods::

method::next

This method performs differently according to the Routine's state:
list::
## Starts the Routine, if it has not been started yet or it has been
link::#-reset#reset::; i.e runs its Function from the beginning, passing on the
code::inval:: argument.
## Resumes the Routine, if it has been suspended (it has yielded); i.e. resumes its
Function from the point where link::Classes/Object#-yield#yield:: was called on an Object,
passing the code::inval:: argument as the return value of code::yield::.
## Does nothing if the Routine has stopped (because its Function has returned, or
link::#-stop:: has been called).
::

code::thisThread:: : Since Routine inherits from link::Classes/Thread::, it will become the
emphasis::current thread:: when it is started or resumed; i.e.
link::Classes/Thread#.thisThread#thisThread:: used in the Routine Function will return
the Routine.

Time: Just before code::next:: is called, code::thisThread:: points either to another Routine, or the top-level Thread. During the code::next:: call, this becomes the parent thread (see link::Classes/Thread#-parent::). code::next:: then evaluates on the parent's clock, at the parent's logical time.

Synonyms for code::next:: are link::#-value:: and link::#-resume::.

returns::
list::
## Either the value that the Routine yields (the Object on which
link::Classes/Object#-yield#yield:: is called within the Routine Function),
## ...or code::nil::, if the Routine has stopped.
::

discussion::

When a Routine is started by a call to this method (or one of its synonyms), the method's
argument is passed on as the argument to the Routine Function:

code::
Routine { arg inval;
	inval.postln;
}.value("hello routine");
::

After the Routine has yielded (it has been suspended at the point in its Function where
code::yield:: is called on an Object), a call to this method (or its synonyms) resumes
executing the Function and the argument to this method becomes the return value of
code::yield::. To access that value within the Function, you have to assign it to a
variable - typically, the argument of the Function is reused:

code::
(
r = Routine { arg inval;
	inval.postln;
	inval = 123.yield;
	inval.postln;
}
)

r.value("hello routine");
r.value("goodbye routine");
::

Typically, a Routine yields multiple times, and each time the result of the yield is
reassigning to the argument of its Function.

code::
(
r = Routine { arg inval;
	inval.postln; // Post the value passed in when started.
	5.do { arg i;
		inval = (i + 10).yield;
		inval.postln; // Post the value passed in when resumed.
	}
}
)
(
5.do {
	r.value("hello routine").postln; // Post the value that the Routine yields.
}
)
::

method::value

Equivalent to link::#-next::.

method::resume

Equivalent to link::#-next::.

method::stop

Equivalent to the Routine Function reaching its end or returning: after this, the Routine
will never run again (the link::#-next:: method has no effect and returns code::nil::),
unless link::#-reset:: is called.

method::reset

Causes the Routine to start from the beginning next time link::#-next:: is called.

discussion::

If a Routine is stopped (its Function has returned or link::#-stop:: has been called), it
will never run again (the link::#-next:: method has no effect and returns code::nil::),
unless this method is called.

A Routine cannot reset itself, except by calling link::Classes/Object#-yieldAndReset::.

See also: link::Classes/Object#-yield::, link::Classes/Object#-alwaysYield::


method::play

Schedules the Routine on the given link::Classes/Clock::, at a time specified by code::quant::. At that time, the Routine will wake up (by calling link::Classes/Routine#-awake::), setting the clock and time and evaluating the Routine. If the Routine yields a number, this number of beats will be added to the current time and the Routine will be rescheduled. (This behavior is compatible with scheduling a link::Classes/Stream:: or a link::Classes/Function::.)

argument::clock
a Clock, TempoClock by default

argument::quant
see the link::Classes/Quant:: helpfile

discussion::
using link::Classes/Object#-idle:: within a routine, return values until this time is over. Time is measured relative to the thread's clock.
code::
// for 6 seconds, return 200, then continue
(
r = Routine {
		199.yield;
		189.yield;
		200.idle(6);
		199.yield;
		189.yield;
};

fork {
	loop {
		r.value.postln;
		1.wait;
	}
}
);

// the value can also be a stream or a function
(
r = Routine {
		199.yield;
		189.yield;
		Routine { 100.do { |i| i.yield } }.idle(6);
		199.yield;
		189.yield;
};

fork {
	loop {
		r.value.postln;
		1.wait;
	}
}
);
::

method:: reschedule

If a Routine is currently scheduled on a clock, it will be expected to "awake" at a specific time, on a specific clock. code::reschedule:: allows you to change to a different clock or to a later time.

argument:: argClock
The new clock on which to run the Routine. If code::nil::, the routine's clock will not be changed. (Note: Currently incompatible with link::Classes/AppClock::; rescheduling depends upon the method code::schedAbs::, which AppClock does not implement.)

argument:: quant
A quantization specifier, identifying a time emphasis::later:: than the next-scheduled time. If code::nil::, the current value of code::nextBeat:: will be used.

discussion::

list::
## Rescheduling to a different clock will be continuous in terms of seconds, but not necessarily continuous in terms of beats. Time-based patterns such as link::Classes/Pseg::, or the use of link::Classes/Env:: as a stream, may not follow the envelope shape continuously. (Pseg and Env-as-stream measure time in beats on the clock that is playing. In normal use, the clock never changes, so time advances monotonically through the envelope's breakpoints. If a thread is rescheduled to a different clock, the beats values are very unlikely to be the same on the new clock. So the envelope would jump forward or backward in time.)

When switching the clock, code::reschedule:: will first calculate the new "awake" time, in beats, based on the given code::quant::. Then it converts that code::beats:: value into the new clock's code::beats:: for the same instant in time. If the old clock's tempo is 1 and the Routine is waiting for 1 beat, the next "awake" should happen after one second. When rescheduling without a code::quant::, the next "awake" will emphasis::still:: happen after one second -- but the code::beats:: value will adjust for the new clock.

## Currently code::quant:: will resolve to a time emphasis::later:: than the Routine's current code::nextBeat::. If you try to force it earlier, there is likely to be some discontinuity. This is because the Routine cannot reschedule until it wakes up normally. The workaround is to switch the Routine into a different link::Classes/Task:: wrapper.

## Currently the routine must be playing (already scheduled on a clock). This is because the handoff to the new clock or time occurs during the thread's "awake" process. If the routine is not playing, then it will not awake, and nothing will happen.
::

code::
// Rescheduling to a different clock, same time
c = TempoClock.new;

(
t = Routine {
	var lastSeconds = thisThread.seconds;
	loop {
		1.0.wait;
		[thisThread.beats, thisThread.seconds - lastSeconds].postln;
		lastSeconds = thisThread.seconds;
	}
}.play;
)

t.reschedule(c);  // seconds delta = 1.0 throughout

t.stop;

// Rescheduling to a later time, same clock
(
t = Routine {
	var lastSeconds = thisThread.seconds;
	loop {
		1.0.wait;
		[thisThread.beats, thisThread.seconds - lastSeconds].postln;
		lastSeconds = thisThread.seconds;
	}
}.play;
)

t.reschedule(quant: 1);

t.stop;

// Rescheduling to an earlier time (workaround, only possible way)
// Requires you to start with a PauseStream!
// This does not work if 't' is a Routine initially.
(
t = PauseStream(Routine {
	var lastSeconds = thisThread.seconds;
	loop {
		1.0.wait;
		[thisThread.beats, thisThread.seconds - lastSeconds].postln;
		lastSeconds = thisThread.seconds;
	}
}).play;
)

// shorter than 1 beat later
(
u = PauseStream(t.stream);
TempoClock.schedAbs(t.nextBeat.trunc, u.refresh);
t.stop;
)

u.stop;
::

method:: awake

This method is called by a link::Classes/Clock:: on which the Routine was scheduled
when its scheduling time is up. It calls link::#-next::, passing on the scheduling
time in beats as an argument. The value returned by code::next:: (the value yielded
by the Routine) will in turn be returned by this method, thus determining the time
which the Routine will be rescheduled for.

argument:: inBeats
The scheduling time in beats. This is equal to the current logical time
(link::Classes/Thread#-beats::).

argument:: inSeconds
The scheduling time in seconds. This is equal to the current logical time
(link::Classes/Thread#-seconds::).

argument:: inClock
The clock which awoke the Routine.


method:: p

Convert the routine to a (subclass of) link::Classes/Pattern::.

returns::

A link::Classes/Prout:: that (in response to code::asStream::) acts as a generator of independent copies of the original routine (the receiver of code::p::).


discussion::

Any subclass of Pattern returns a Stream in response to code::asStream::. However, the exact subclass of Stream returned depends on the class of the Pattern. In particular, a Prout returns a Routine in response to code::asStream::. Thus, a way to make an independent copy of a Routine is to make a Prout from it with the method code::p::, and then create a new Routine from this Prout. In the example immediately below, this second step is done explicitly by calling code::asStream::, but in the context of passing arguments to other Patterns, this latter step usually happens automatically, as shown in later examples.

code::
(
r = Routine { "hi".yield; "bye".yield };
r.next.postln;    // "hi" posted

q = r.p.asStream; // or just: r.p.iter
q.next.postln;    // "hi" again

r.next.postln;    // "bye" because r kept its own state, separate from q
)
::

note::
New routines produced by code::.p.asStream:: run the original routine's function from the beginning. There is no copy of the internal state of the original routine, only its function is copied. On a related note, code::Routine.copy:: (inherited from code::Thread::) does not create a new, separate Routine; it just returns the receiver.
::

The Routine method code::p:: is mostly useful in the context of using the result of Routine-returning expressions as arguments to Patterns, when the intent is to use the Routine's result as a pattern, i.e. multiple occurrences acting independently of each other.

code::
(
r = (:2..5); // a seriesIter Routine
Ptuple([r, r]).asStream.all.postln; // posts [ [ 2, 3 ], [ 4, 5 ] ]
r.next.postln; // nil

p = r.p; // make a Pattern from r; it doesn't matter that r has ended
Ptuple([p, p]).asStream.all.postln;
// posts [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]

// Obviously, explicitly writing the same Routine-valued subexpression twice
// also creates separate Routines.
Ptuple([(:2..5), (:2..5)]).asStream.all.postln;
// posts [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]
)
::

In the following example, directly reusing the same Routine object twice in a code::Pseq:: fails to duplicate its output, because the first embedding fully consumes the routine's (non-nil) output.

code::
(
r = (:2..6);
Pseq([r, r]).asStream.all.postln;
// [ 2, 3, 4, 5, 6 ]

p = r.p;
Pseq([p, p]).asStream.all.postln;
// [ 2, 3, 4, 5, 6, 2, 3, 4, 5, 6 ]

Pseq([(:2..6), (:2..6)]).asStream.all.postln;
// [ 2, 3, 4, 5, 6, 2, 3, 4, 5, 6 ]
)
::


subsection::Accessible instance variables

Routine inherits from link::Classes/Thread::, which allows access to some of its state:

code::
(
r = Routine { arg inval;
	loop {
		// thisThread refers to the routine.
		postf("beats: % seconds: % time: % \n",
			thisThread.beats, thisThread.seconds, Main.elapsedTime
		);
		1.0.yield;

	}
}.play;
)

r.stop;
r.beats;
r.seconds;
r.clock;
::

method::beats

returns:: The elapsed beats (logical time) of the routine. The beats do not proceed when the routine is not playing.

method::seconds

returns:: The elapsed seconds (logical time) of the routine. The seconds do not proceed when the routine is not playing, it is the converted beat value.

method::clock

returns:: The thread's clock. If it has not played, it is the SystemClock.

examples::

code::
(
var r, outval;
r = Routine.new({ arg inval;
	("->inval was " ++ inval).postln;
	inval = 1.yield;
	("->inval was " ++ inval).postln;
	inval = 2.yield;
	("->inval was " ++ inval).postln;
	inval = 99.yield;
});

outval = r.next('a');
("<-outval was " ++ outval).postln;
outval = r.next('b');
("<-outval was " ++ outval).postln;
r.reset; "reset".postln;
outval = r.next('c');
("<-outval was " ++ outval).postln;
outval = r.next('d');
("<-outval was " ++ outval).postln;
outval = r.next('e');
("<-outval was " ++ outval).postln;
outval = r.next('f');
("<-outval was " ++ outval).postln;
)
::

code::
// wait

(
var r;
r = Routine {
	10.do({ arg a;
		a.postln;
		// Often you might see Wait being used to pause a routine
		// This waits for one second between each number
		1.wait;
	});
	// Wait half second before saying we're done
	0.5.wait;
	"done".postln;
}.play;
)
::

code::
// waitUntil

(
var r;
r = Routine {
	var times = { rrand(1.0, 10.0) }.dup(10) + thisThread.beats;
	times = times.sort;
	times.do({ arg a;
		waitUntil(a);
		a.postln;
	});
	// Wait half second before saying we're done
	0.5.wait;
	"done".postln;
}.play;
)
::

code::
// Using Routine to set button states on the fly.
(
var update, w, b;
w = SCWindow.new("State Window", Rect(150,SCWindow.screenBounds.height-140,380,60));

// a convenient way to set the button label
update = {
	|but, string| but.states = [[string.asString, Color.black, Color.red]];
	but.refresh;
};

b = SCButton(w, Rect(10,10,360,40));
b.font_(Font("Impact", 24));

update.value(b, "there is only one state");

// if an action should do something different each time it is called, a routine is the
// right thing to use. This is better than creating variables outside and setting them
// from the action function to keep state from one action to the next

b.action_(Routine { |butt|
	rrand(15, 45).do { |i|
		update.value(butt, "%. there is still only 1 state".format(i + 2));
		0.yield; // stop here
	};
	w.close;
});

w.front;
)
::

code::
// drawing in a window dynamically with Pen
(
var w, much = 0.02, string, synth;

w = Window.new("swing", Rect(100, 100, 300, 500)).front;
w.view.background_(Color.new255(153, 255, 102).vary);

string = "swing ".dup(24).join;

w.drawFunc = Routine {
	var i = 0;
	var size = 40;
	var func = { |i, j| sin(i * 0.07 + (j * 0.0023) + 1.5pi) * much + 1 };
	var scale;
	Pen.font = Font("Helvetica-Bold", 40);
	loop {
		i = i + 1;
		string.do {	|char, j|

			scale = func.value(i, j).dup(6);

			Pen.fillColor = Color.new255(0, 120, 120).vary;
			Pen.matrix = scale * #[1, 0, 0, 1, 1, 0];
			Pen.stringAtPoint(char.asString,
				((size * (j % 9)) - 10) @ (size * (j div: 9))
			);
		};
		0.yield // stop here, return something unimportant
	}
};

fork { while { w.isClosed.not } { defer { w.refresh }; 0.04.wait; } };

w.front;

)
::



class:: RunningMax
summary:: Track maximum level.
related:: Classes/RunningMin, Classes/RunningSum
categories::  UGens>Maths


Description::

Outputs the maximum value received at the input. When a trigger occurs at
the reset input, the maximum output value is reset to the current value.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::trig

Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::

(
{
	SinOsc.ar(
			RunningMax.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			RunningMax.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)

::



class:: RunningMin
summary:: Track minimum level.
related:: Classes/RunningMax, Classes/RunningSum
categories::  UGens>Maths


Description::

Outputs the minimum value received at the input. When a trigger occurs at
the reset input, the minimum output value is reset to the current value.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::trig

Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::

(
{
	SinOsc.ar(
			RunningMin.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			RunningMin.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)

::



class:: RunningSum
summary:: Running sum over n frames
categories:: UGens>Analysis, UGens>Maths

description::
A running sum over a user specified number of samples, useful for running RMS power windowing.

classmethods::
method:: ar, kr
argument::in
Input signal
argument::numsamp
How many samples to take the running sum over (initialisation time only, not modulatable. default: 40)

examples::

code::
// distorts of course - would need scaling
{ RunningSum.ar(SoundIn.ar) }.play

// Running Average over x samples
(
{
    var x = 100;
    RunningSum.ar(LFSaw.ar, x) * (x.reciprocal)
 }.play
)
::

code::
// RMS Power
(
{
    var input, numsamp;

    input = LFSaw.ar;
    numsamp = 30;

    (RunningSum.ar(input.squared, numsamp) / numsamp).sqrt
}.play
)
::

code::
// shortcut in class
{ RunningSum.rms(SoundIn.ar) }.play
::

code::
// play around
(
{
    var input, numsamp, power;
    numsamp = 500;
    input = SoundIn.ar;
    power = MouseX.kr(0.1, 4);

    (RunningSum.ar(input ** power, numsamp)/numsamp) ** (power.reciprocal)
}.play
)
::


class:: SCContainerView
summary:: An abstract superclass for container views
categories:: GUI>Kits>Cocoa
related:: Classes/CompositeView, Classes/HLayoutView, Classes/VLayoutView, Classes/ScrollView

description::
Users will not normally directly create instances of ContainerView, but only use it through its subclasses. It provides the basic mechanisms for container views of various kinds, which are used for placing and grouping widgets in a window.



subsection:: Some Important Issues Regarding ContainerView

Container views are meant for placing and grouping child views and widgets. While they accept key actions, many do not accept mouse clicks or drags. The exception is SCTopView and its subclasses.

classmethods::


instancemethods::

subsection:: Accessing Instance and Class Variables

method:: decorator
An automatic layout management for a container. Currently the only one existing is link::Classes/FlowLayout::.
note::Crucial Library also has a useful layout tool called GridLayout.::
argument:: arg1

method:: addFlowLayout
A convenience utility which sets decorator to link::Classes/FlowLayout:: and returns the decorator. See link::Classes/FlowLayout:: for examples.
argument:: margin
An instance of link::Classes/Point::.
argument:: gap
An instance of link::Classes/Point::.

method:: children
An array containing all the views (children) contained in the container.



subsection:: Adding and Removing Subviews

method:: add
Adds a view to children. The placement of the child view will depend on the decorator, and the child's bounds. Normally you don't need to call this directly, since subviews call it automatically when you create them.
argument:: child

method:: removeAll
Removes all children from the view.



subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method::init
argument:: argParent
argument:: argBounds

method:: prRemoveChild
Private method.
argument:: child

method:: prClose
Private method.


class:: SCDoc
summary:: Help system main class
categories:: HelpSystem
related:: Reference/SCDocSyntax, Guides/WritingHelp, Classes/SCDocHTMLRenderer, Classes/SCDocNode, Classes/SCDocEntry

DESCRIPTION::
SCDoc manages the SuperCollider documentation system.

It uses parses help files written in link::Reference/SCDocSyntax##SCDoc markup language:: and renders them as human-readable documents.

A guide to writing help can be found here: link::Guides/WritingHelp::.

CLASSMETHODS::

subsection:: Document index

method:: indexAllDocuments
Index all documents and undocumented classes on the system, putting them in the code::SCDoc.documents:: dictionary. If run inside a Routine, this method will yield occasionally.

Run this method if you added a new document and want to see the changes without restarting SuperCollider.

argument:: clearCache
If true, force re-render of files even if the schelp source file is not newer than the destination.

discussion::
This will take a couple of seconds, and will be done automatically once before any help can be viewed. You might consider putting this in your startup.scd file to avoid getting this delay later when you decide to view a helpfile.

method:: documents
The dictionary of indexed documents. They keys are the path relative to the Help folder and without extension, like teletype::Classes/SinOsc:: or teletype::Reference/SCDocSyntax::. The values are instances of link::Classes/SCDocEntry::

method:: didIndexDocuments
A Boolean indicating if code::SCDoc.indexAllDocuments:: was called in this session yet.

method:: helpSourceDir
get/set the system-wide directory of help sourcefiles. Defaults to code::Platform.classLibraryDir.dirname +/+ "HelpSource":: and should typically not be changed by the user.

method:: helpSourceDirs
get the list of HelpSource folders, including extensions and quarks (unless they are excluded from library compilation, e.g. by link::Classes/LanguageConfig#*excludeDefaultPaths::)
discussion::
This searches recursively for all folders named "HelpSource" under link::Classes/LanguageConfig#*includePaths::, as well as including the system-wide code::helpSourceDir::.
Unless link::Classes/LanguageConfig#*excludeDefaultPaths:: is on, code::Platform.userExtensionDir:: and code::Platform.systemExtensionDir:: are searched too.

method:: findHelpFile
Find help for a given string. Tries to be smart.
returns:: the URL for help on given string

method:: verbosity
Verbosity level. 0 is silent.

subsection:: Parsing and Rendering

private:: checkVersion, exportDocMapJS, handleCopyMethods, postMsg, prParseFile, renderUndocClass

method:: renderer
The default renderer, defaults to link::Classes/SCDocHTMLRenderer::

method:: helpTargetDir
get/set the user help target directory. Defaults to code::Platform.userAppSupportDir +/+ "Help":: and should typically not be changed by the user.

method:: parseFileFull
Parse file.
argument::
Full path to .schelp file
returns::
An link::Classes/SCDocNode:: tree

method:: parseFileMetaData
Parse only the stuff needed for metadata.
argument::
Base HelpSource directory.
argument::
Path relative above dir.
returns::
An link::Classes/SCDocNode:: tree

method:: parseFilePartial
Parse a file without header, for merging of document additions
argument::
Full path to .ext.schelp file
returns::
An link::Classes/SCDocNode:: tree

method:: parseDoc
Parse the files associated with an link::Classes/SCDocEntry::, including any document additions (teletype::*.ext.schelp::)
argument:: doc
The link::Classes/SCDocEntry:: to parse.
returns::
An link::Classes/SCDocNode:: tree

method:: parseAndRender
Parse and render a specific document.
argument:: doc
The link::Classes/SCDocEntry:: to parse and render.

method:: renderAll
Render all help-files. Useful mainly if you want to render all help to put online or similar.
argument:: includeExtensions
If false, skip quarks, plugins and other extensions.

method:: prepareHelpForURL
Prepare help for the given URL by checking if the file needs rendering from schelp source, or some other action needs to be done.
Used as a wrapper to get on-the-fly rendering and processing of help files.
argument:: url
The url to prepare. If this is not a local file inside link::#*helpTargetDir:: then it will just pass through the url directly.
returns:: the URL or nil if file not found.

subsection:: Utilities

method:: getMethodDoc
Extract the link::Classes/SCDocNode:: tree for the specified method documentation.
argument::
Name of class
argument::
Name of method, prefixed with teletype::*:: for classmethods and teletype::-:: for instancemethods.
returns::
An link::Classes/SCDocNode:: tree

method:: makeClassTemplate
Create a schelp template for specified class.
argument:: doc
The link::Classes/SCDocEntry:: for the undocumented class.
returns::
Returns the template string.

method:: classHasArKrIr
argument:: c
The link::Classes/Class:: to check.
Returns:: code::true:: if the class responds to ar, kr or ir classmethods.

section:: Parser node tree output
The SCDoc parser outputs a tree of link::Classes/SCDocNode::s

The nodes reflects the tags in the input, but it's not a one-to-one correspondence.
A more detailed structure is added in the node tree, for easier rendering.

Example:

DOCUMENT
tree::
    ## HEADER
    tree::
        ## TITLE teletype::"SinOsc"::
        ## SUMMARY teletype::"Interpolating sine wavetable oscillator"::
        ## RELATED
        tree::
            ## STRING teletype::"Classes/FSinOsc"::
            ## STRING teletype::"Classes/SinOscFB"::
        ::
        ## CATEGORIES
        tree::
            ## STRING teletype::"UGens>Generators>Deterministic"::
            ## STRING teletype::"UGens>Oscillators"::
        ::
    ::
    ## BODY
    tree::
        ## DESCRIPTION
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"A paragraph with "::
                ## LINK teletype::"Classes/Osc##a link"::
                ## TEXT teletype::" to another document."::
            ::
            ## PROSE
            tree::
                ## TEXT teletype::"Another paragraph with "::
                ## STRONG teletype::"strong words"::
                ## TEXT teletype::" in it."::
            ::
        ::
        ## CLASSMETHODS
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Some text..."::
            ::
            ## CMETHOD
            tree::
                ## METHODNAMES
                tree::
                    ## STRING teletype::"ar"::
                    ## STRING teletype::"kr"::
                ::
                ## METHODBODY
                tree::
                    ## PROSE
                    tree::
                        ## TEXT teletype::"Some text..."::
                    ::
                    ## ARGUMENTS
                    tree::
                        ## ARGUMENT teletype::"freq"::
                        tree::
                            ## PROSE
                            tree::
                                ## TEXT teletype::"Frequency in hertz"::
                            ::
                        ::
                        ## ARGUMENT teletype::"phase"::
                        tree::
                            ## PROSE
                            tree::
                                ## TEXT teletype::"Phase modulation"::
                            ::
                        ::
                    ::
                ::
            ::
        ::
        ## EXAMPLES
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Here are some examples:"::
            ::
            ## CODEBLOCK
            teletype::
"{ SinOsc.ar(200, 0, 0.5) }.play;
// modulate freq
{ SinOsc.ar(XLine.kr(2000, 200), 0, 0.5) }.play;
// modulate freq
{ SinOsc.ar(SinOsc.ar(XLine.kr(1, 1000, 9), 0, 200, 800), 0, 0.25) }.play;
// modulate phase
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(1, 1000, 9), 0, 2pi), 0.25) }.play;"
::
        ::
        ## SECTION teletype::"Another section"::
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Some text..."::
            ::
        ::
    ::
::


title:: SCDocEntry
summary:: An SCDoc document index entry
related:: Classes/SCDoc
categories:: HelpSystem

description::
This class is used by link::Classes/SCDoc:: to represent a document in the help file index.

The document represented can be either a real .schelp file, or an auto-generated stub for undocumented classes.

classmethods::

method:: new
Create and initialize a new instance.
argument:: node
An link::Classes/SCDocNode:: instance. Does not have to be a fully parsed document, since only the header tags, methods and keywords are used. (See link::Classes/SCDoc#*parseFileMetaData::).

argument:: path
A link::Classes/String:: for the document key, like "Classes/SinOsc".

method:: newUndocClass
Create and initialize a new instance for an undocumented class.
argument:: name
Name of undocumented class

instancemethods::

private:: prAddCopyMethod, prAddMethodNames, printOn, prJSONList, prJSONString, prScanMethodsKeywords, setAdditions, init, indexUndocumentedMethods

subsection:: Document properties

method:: path
A link::Classes/String:: for the document key, like "Reference/SCDocSyntax".

method:: title
Document title. Should equal the classname for class reference docs.

method:: summary
Document summary.

method:: categories
Document categories. An link::Classes/Array:: of Strings.

method:: related
Related document links. An link::Classes/Array:: of Strings.

method:: keywords
Keywords listed in the document. An link::Classes/Array:: of Strings.

method:: fullPath
The full path to this documents .schelp file, if any.

method:: mtime
The modification time of the .schelp file, if any.

method:: destPath
The render destination path.

method:: docmethods
Documented methods which are not class or instance methods. An link::Classes/Array:: of Strings.

method:: additions
A list of document additions (*.ext.schelp) for this document. An link::Classes/Array:: of Strings.

method:: isExtension
True if this document is an extension (not part of the main library). A link::Classes/Boolean::

method:: isClassDoc
True if this document is a class doc. A link::Classes/Boolean::

subsection:: Class docs
These methods and properties are only used for class docs.

method:: klass
The link::Classes/Class:: documented.

method:: isUndocumentedClass
True if this class is undocumented (which means there are no .schelp file).
A link::Classes/Boolean::

method:: doccmethods
A list of documented class methods.

method:: docimethods
A list of documented instance methods.

method:: privcmethods
A list of private class methods.

method:: privimethods
A list of private instance methods.

method:: undoccmethods
A list of undocumented class methods.

method:: undocimethods
A list of undocumented instance methods.

method:: makeMethodList
Return a list of strings for all non-private methods, prefixed with teletype::xy:: where x is teletype::_:: for documented methods and teletype::?:: for undocumented methods, and y is teletype::*:: for class methods, teletype::-:: for instance methods and teletype::.:: for other/generic methods.

method:: redirect

The name of the class variable holding the implementing class. Used by GUI redirection system, for example.

method:: implKlass

The implementing link::Classes/Class::, if code::redirect:: was set.

method:: implements

The link::Classes/Class:: being implemented. For example, the entry for link::Classes/QButton:: has this set to link::Classes/Button::

method:: toJSON
Write a representation of this document entry as JSON to Stream. Used to export the document entries to the javascript used in the link::Classes/HelpBrowser##HTML help browser::.
argument:: stream
A Stream.



class:: SCDocHTMLRenderer
summary:: Render SCDoc markup text to HTML
categories:: HelpSystem
related:: Classes/SCDoc, Guides/WritingHelp, Reference/SCDocSyntax

description::
This class is part of the SCDoc help system, and handles the rendering of the parsed document tree into HTML output.

In normal cases you won't need to use this class directly, link::Classes/SCDoc:: uses this class by default to render help files.

classmethods::

method:: renderOnStream
Renders a parsed document as HTML onto given stream.
argument:: stream
A stream, for example a link::Classes/File:: instance.
argument:: doc
An instance of link::Classes/SCDocEntry::
argument:: root
An instance of link::Classes/SCDocNode::

method:: renderToFile
Opens a file and passes it to link::#*renderOnStream::

method:: htmlForLink
Create a html string for the given scdoc link.
argument:: link
An scdoc link, such as a document key like "Classes/SinOsc", or an URL, or link to other file installed with the help.
argument:: escape
a boolean to set whether to escape special characters.
returns::
A String

method:: makeArgString
Used internally.
Returns:: A link::Classes/String:: representing the arguments (with defaults) for a link::Classes/Method::.


section:: CSS styling
The rendered HTML reads the global style from teletype::scdoc.css::, but also reads teletype::frontend.css:: and teletype::custom.css:: (in that order) if available, to enable specific frontends and users to override the CSS.

So to customise the CSS, the user can create a teletype::custom.css:: in their link::Classes/SCDoc#*helpTargetDir:: or at the root of any HelpSource directory (for example in teletype::YourExtension/HelpSource/custom.css:: ).



title:: SCDocNode
summary:: An SCDoc parsed document node
related:: Classes/SCDoc
categories:: HelpSystem

description::
This class is used internally by link::Classes/SCDoc:: to represent a node in the parsed document tree returned by the  parser. It has an id symbol, optional text and optional children.

classmethods::

method:: new
Create a new node

instancemethods::

private:: addDivAfter, makeDiv, notPrivOnly, printOn, sort, sortClassDoc

method:: id
The node ID. A link::Classes/Symbol::

method:: text
Text associated with this node. A link::Classes/String:: or nil.

method:: children
Children of this node. A link::Classes/Array:: or nil.

method:: merge
Merge another document node tree with this one. Used by document additions (*.ext.schelp)
argument:: root2
Another SCDocNode instance.

method:: findChild
Find the first child of this node with specified id.
argument:: id
A link::Classes/Symbol::


class:: SCDragView
summary:: An abstract superclass for drag views
categories:: GUI>Kits>Cocoa
related:: Classes/DragSource, Classes/DragSink, Classes/DragBoth

description::
Users will not normally directly create instances of SCDragView, but only use it through its subclasses. The three subclasses, link::Classes/DragSource::, link::Classes/DragSink::, link::Classes/DragBoth::, all function basically the same way: they are simple, graphically represented rectangles, which act as a drag-source, a drag target, or both. Their dragging behavior only differs from other GUI views, in that they do not require the cmd key to be held down for dragging. All other dragging functions are those defined by link::Classes/View::. They inherit from SCStaticTextBase, and thus store their content in object and by default display their content using code::asString::. You can keep their string independent of the content, if you set code::setBoth = false::. You can also set a label to be displayed while dragging by using code::dragLabel_()::.



instancemethods::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: defaultGetDrag
The method called by default when initiating a drag. Returns object.



examples::
code::
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anything
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "receive anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red)};
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
::


class:: SCEnvelopeEdit
summary:: An envelope editor view
categories:: GUI>Kits>Cocoa
related:: Classes/EnvelopeView

description::
An editable Envelope view.

subsection:: Some Important Issues Regarding SCEnvelopeEdit

The breakpoints are color coded as follows:
table::
## blue || normal
## red || sustain node
## green || loop node
::


classmethods::

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
argument:: env
The envelope. An instance of link::Classes/Env::.
argument:: pointsPerSegment
The resolution in points per segment. Default value is 10.

method:: paletteExample
argument:: parent
argument:: bounds

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: viewClass

instancemethods::

method:: refresh
If the link::Classes/Env:: object is modified directly, this needs to be called to update the GUI.

maxLevel
Changes maximum level shown in editor.
argument:: level
An instance of link::Classes/Float::.

method:: minLevel
Changes minimum level shown in editor.
argument:: level
An instance of link::Classes/Float::.

method:: minTime
Changes minimum time (sec) shown in editor. Negative times are okay because link::Classes/Env:: uses inter-node durations.
argument:: sec
An instance of link::Classes/Float::. Seconds.

method:: maxTime
Changes maximum time (sec) shown in editor.
argument:: sec
An instance of link::Classes/Float::. Seconds.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: defaultMouseDownAction
argument:: x
argument:: y
argument:: modifiers
argument:: buttonNumber
argument:: clickCount


method:: env
argument:: e

method:: addBreakPoint
argument:: level

method:: insertAtTime
argument:: time
argument:: level

method:: pointsPerSegment

method:: initSCEnvelopeEdit
argument:: argEnv
argument:: argPPS
argument:: setMinMax

method:: redraw

method:: updateAll

method:: updateSegment
argument:: segNum

method:: clear

examples::

Make a basic editor:
code::
(
e = Env([1, 2], [10]);
w = Window("Env Editor", Rect(200, 200, 300, 200));
v = SCEnvelopeEdit(w, w.view.bounds.moveBy(20, 20).resizeBy(-40, -40), e, 20).resize_(5);
w.front;
)

v.addBreakPoint;

(
v.clear;
v.redraw;
v;
)

v.maxLevel_(2); // to give more headroom
v.maxTime_(2); // to increase release point
v.minTime_(-1); // to increase attack time

e.curves_('sin'); // env object is changed
v.refresh; // must refresh editor
::

Controlling a Synth
code::
s.boot;

(
e = Env([0, 1, 0.7, 0.9, 0], [0.03, 0.03, 0.03, 0.03], 'sin');
f = Env([0, 1, 0.7, 0.9, 0], [0.03, 0.03, 0.03, 0.03], 'sin');
w = Window("Shards", Rect(100, 100, 500, 400));
v = SCEnvelopeEdit(w, w.view.bounds.resizeBy(-20, -200), e, 10).resize_(2);
StaticText(w, v.bounds).string_(" amplitude").resize_(2);
x = SCEnvelopeEdit(w, v.bounds.moveBy(0, 200), f, 10).resize_(2);
StaticText(w, x.bounds).string_(" frequency").resize_(2);
w.front;
)

(
SynthDef("sineBlip", {
	arg freq = 440, vol = 0.1, la0, la1, la2, la3, la4, ta0, ta1, ta2, ta3, crva,
		lf0, lf1, lf2, lf3, lf4, tf0, tf1, tf2, tf3, crvf;
	var signal, fenv, aenv;
	fenv = EnvGen.ar(Env([lf0, lf1, lf2, lf3, lf4], [tf0, tf1, tf2, tf3], crvf));
	aenv = EnvGen.ar(Env([la0, la1, la2, la3, la4], [ta0, ta1, ta2, ta3], crva), doneAction: Done.freeSelf);
	signal = SinOsc.ar([freq, freq*2] * fenv) * aenv * vol;
	Out.ar(0, signal.dup);
}).add;
)

(
Routine({
	var par, indices;
	indices = (2..21);
	loop({
		par = (indices +++ (
			v.env.levels ++
			v.env.times ++
			v.env.curves ++
			x.env.levels ++
			x.env.times ++
			x.env.curves)).flatten;
		s.sendBundle(s.latency, [\s_new, "sineBlip", -1, 1, 1, \freq, exprand(4e3,11e3)] ++ par);
		0.04.wait;
	});
}).play;
)
::


class:: SCImage
summary:: image component
categories:: GUI>Views
related:: Classes/SCImageFilter, Classes/SCImageKernel

DESCRIPTION::

SCImage is an image component for the macOS SuperCollider client. SCImage is currently a wrapper around different models : you can use it for bitmap operations, image embedding for custom UI and for more advanced image processing as applying filters and kernels, both provided with the CoreImage framework.

SCImage currently supports most formats including tiff, bmp, gif, jpeg, png, tga...ect.. for reading. But for for writing it supports only those in code::SCImage.formats::.

NOTE::
link::Classes/GUI:: Issue : since it is macOS only, be sure to call code::GUI.cocoa:: before any SCImage.call
::

CLASSMETHODS::

PRIVATE::initClass, prFromWindowRect, prFreeAll

METHOD::new
Creates a new SCImage instance. multiple stands here for multiple arguments.

ARGUMENT::multiple
May be a...
list::
## link::Classes/Number:: to create an strong::empty:: image of size multiple as width and height
code::
i = SCImage.new(400);		// Create a 400x400 pixels SCimage.
i.dump;
i.free;

i = SCImage.new(400,200);	// Create a 400x200 pixels SCimage.
i.dump;
i.free;
::
## link::Classes/Point:: to create an strong::empty:: image of size multiple.x as width and multiple.y as height
code::
i = SCImage.new(400@200);	// Create a 400x200 pixels SCimage.
i.dump;
i.free;
::
## link::Classes/String:: to create an image from a strong::local file:: or from an strong::URL:: (http://, ftp://, file:///)
code::
//	Path string
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
[i.width, i.height].postln;
i.plot;
i.free;
//	URL string - http:// or ftp:// - blocks until image is downloaded
i = SCImage.new("http://www.google.com/intl/en_ALL/images/logo.gif");
i.plot;
i.url;
i.free;
::
::

METHOD::color
Creates a new SCImage instance filled with the specified color.
code::
i = SCImage.color(400, 200, Color.blue(0.9,0.1));
i.plot(freeOnClose:true);
::

ARGUMENT::args
multiple arguments. the last argument should be a valid link::Classes/Color::

METHOD::open
Creates a new SCImage instance from the local file at strong::path::.
code::
(
i = SCImage.open("/Library/Desktop Pictures/Ripples Blue.jpg");
i.plot(freeOnClose:true);
i.url.postln;
)
::

METHOD::openURL
Creates a new SCImage instance from a valid image at the specified URL strong::path::.
code::
i = SCImage.openURL("file:///Library/Desktop%20Pictures/Ripples%20Blue.jpg");
i.url;
w = i.plot(freeOnClose:true);
::

METHOD::fromImage
Creates a new SCImage instance from another SCImage.
code::
i = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
j = SCImage.fromImage(i);
i.dump;
j.dump;
[i, j].do(_.plot);
[i, j].do(_.free);
::

METHOD::fromWindow
Creates a new SCImage from a portion of a SCWindow. this can be used to capture either a window or a specific SCView.

code::
// WINDOW Example:
// First create a window and draw inside of it
(
	w = SCWindow.new;
	w.front; // comment this to copy offscreen window
	w.view.background_(Color.white);
	w.drawFunc = {
		SCPen.translate(100, 100);
		10.do{
			// set the Color
			SCPen.color = Color.blue(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);
			SCPen.perform([\stroke, \fill].choose);
		}
	};
	w.refresh;
)

// then grab the window
(
	i = SCImage.fromWindow(w);
	w.close;
	i.plot(freeOnClose:true);
)

// VIEW Capture Example:
// First create a window and add some views inside of it
(
	w = SCWindow.new.front;
	b = [10, 80].asSpec;
	c = SCNumberBox(w, Rect(20, 20, 60, 40));
	a = SCSlider(w, Rect(20, 80, 100, 40))
		.focusColor_(Color.red(alpha:0.2))
		.action_({
			c.value_(b.map(a.value).round(0.01))
	// round the float so it will fit in the SCNumberBox
			});
)

// then grab the window
(
	i = SCImage.fromWindow(w, a.bounds);
	w.close;
	i.plot(freeOnClose:true);
)
::

ARGUMENT::window
the SCWindow object.

ARGUMENT::rect
optional. the constrained rect to capture inside the SCWindow. By default, it is the window size.

SUBSECTION::Class variables and attributes

METHOD::formats
returns all the valid image formats as an link::Classes/Array::
code::
SCImage.formats;
::

METHOD::compositingOperations
returns all the valid compositing operations you can use when drawing an SCImage as an link::Classes/Array::
code::
SCImage.compositingOperations;
::

METHOD::interpolations
returns an link::Classes/Array:: of the different levels of interpolation you can specify when drawing an SCImage.
code::
SCImage.interpolations;
::

METHOD::closeAllPlotWindows
close all the SCImage plot windows currently opened.

INSTANCEMETHODS::

PRIVATE::prLockFocus, prDrawAtPoint, prSync, prApplyFilters, prTileInRect, prUpdatePixelsInRect, prGetPixel, prInit, prSetInterpolation, prFree, prSetPixel, prLoadPixels, prSetBackground, prApplyKernel, prUpdatePixels, prWriteToFile, prUnlockFocus, prInitFromURL, prSetColor, prGetColor, prSetName, prGetInterpolation, prDrawInRect

SUBSECTION::commons / general attributes

METHOD::width
returns or set the width of the receiver

METHOD::height
returns or set the height of the receiver

METHOD::setSize
set the size of the receiver

METHOD::bounds
returns the bounds of the receiver.

METHOD::free
deallocate the receiver. this method is useful if you want to manage and reclaim yourself resources. otherwise you do not need to call this method since each object is automatically garbage collected.
code::
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
SCImage.all;
i.free;
SCImage.all;
::

METHOD::scalesWhenResized
flag to tell or set if the receiver should update its bitmap representation to scale when a resize operation if performed
code::
(
	i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	i.bounds.postln; // getting the dimensions
	w =i.plot;
)

// changing the size of an image
(
	i.scalesWhenResized_(true);
	i.setSize(400, 400 / (i.width / i.height));
	a =i.plot;
)
(
a.close; w.close; i.free;
)
::

METHOD::url
returns or set the url of the receiver. Returning only if any where supplied at creation, otherwise returns nil. Setting may be used for different purpose but try to supply a valid one since it is used for archiving the image as an object.
code::
i = SCImage.new("http://www.google.com/intl/en_ALL/images/logo.gif");
i.url;
i.plot;
i.free;
::

METHOD::accelerated
if true, the receiver currently use the CoreImage model, possibly caching its data on GPU, if not the bitmap model. Set it to switch representation.
WARNING::
this method should never be used directly unless you know perfectly what you are doing. Since the SCImage will switch internally and manage itself the syncronization between representations.
::

METHOD::interpolation
get or set the level of interpolation used when rendering the image - it has not effect when the SCImage is accelerated. see link::#*interpolations:: for a valid range of values.
code::
(
i = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
w = i.plot;
i.interpolation;			// get the image current interpolation mode
)

(
i.interpolation = 'none';		// experiment with interpolation modes
w.refresh;
)

(
i.interpolation = 'low';
w.refresh;
)

(
i.interpolation = 1;			// same as 'low'
w.refresh;
)

(
i.interpolation = 'high';
w.refresh;
)

(
i.interpolation = 'default';
w.refresh;
)

(
i.accelerated_(true);
i.interpolation = 'none'; // does not work on coreimage accelerated image
w.refresh;
)

i.free;
::

SUBSECTION::saving and archiving

METHOD::write
write the SCImage to a file.
code::
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.dump
i.write("~/Desktop/my_image.png");
i.free;

//	storeOn / asCompileString
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.url;
i.asCompileString;
i.writeArchive("~/Desktop/my_image.scd".standardizePath);

i.free;
i = nil;

Document.open("~/Desktop/my_image.scd".standardizePath);

i = Object.readArchive("~/Desktop/my_image.scd".standardizePath);
i.plot;
i.free;
::

ARGUMENT::path
the location where to save it

ARGUMENT::format
(optional) format to use. see SCImage.formats for supported formats. If nil, it will get the format depending on the path extension.

SUBSECTION::rendering

METHOD::plot
plots the image in a SCWindow.
code::
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
w = i.plot;
w.close;

w = i.plot(showInfo:false);
w.close;
i.free;

// other option - image will be automatically freed when closed
SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg").plot("Hello", freeOnClose:true);
::

ARGUMENT::name
the title of the SCWindow. may be nil.

ARGUMENT::bounds
the bounds of the SCWindow. may be nil.

ARGUMENT::freeOnClose
flag to tell if the SCWindow should free the SCImage when closed.

ARGUMENT::background
additional background to apply to the SCWindow. may be useful for artifacts due to alpha / compositing...

ARGUMENT::showInfo
shows pixel coordinates while the mouse is over the image's plot window.

METHOD::lockFocus
sets the receiver as the current graphic context. So you can use SCPen to draw inside of it.

METHOD::unlockFocus
restore the graphic context state. the receiver is not anymore the current graphic context.
code::
(
	j = SCImage.new(400,300);

	j.lockFocus;

		SCPen.translate(100, 100);
		1000.do{
			// set the Color
			SCPen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addAnnularWedge(
				(100.rand)@(100.rand),
				rrand(10, 50),
				rrand(51, 100),
				2pi.rand,
				2pi.rand
			);
			SCPen.perform([\stroke, \fill].choose);
		};

	j.unlockFocus;
)

j.plot;
j.write("~/Desktop/my_drawing.png"); // write the image
j.free;
::

METHOD::draw
shortcut for drawing inside an image. equivalent to :
list::
## receiver.lockFocus
## aFunction
## receiver.unlockFocus
::
code::
(
	j = SCImage.new(400,300);
	j.draw({ arg image;

		SCPen.translate(100, 100);
		1000.do {
			// set the Color
			SCPen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addAnnularWedge(
				(100.rand)@(100.rand),
				rrand(10, 50),
				rrand(51, 100),
				2pi.rand,
				2pi.rand
			);
			SCPen.perform([\stroke, \fill].choose);
		};
	}).plot(freeOnClose:true);
)

//	String drawing support on the image
//	drawStringAtPoint(string, point, font, color);
(
	j = SCImage.new(150,50);
	j.draw({ arg bounds;
		j.drawStringAtPoint("Hello, world!", 10@10, Font("Lucida Grande", 24), Color.black);
	});
)

j.plot;
j.write("~/Desktop/hello.png");
j.free;
::

METHOD::drawStringAtPoint
renders *correctly* a String inside an SCImage :) code::// to fix to have a compliant interface::
code::
(
	var width, height, tgHeight, ratio, str, font, color, strb, targetWidth=400, shadowColor, run = true;
	shadowColor = Color.black;

	color = Color.gray(0.8);
	str = "I Love Pixels";
	font = Font("Monaco", 10);
	strb = str.bounds(font);
	width = strb.width;
	height = strb.height;
	ratio = height / width;
	i = SCImage(width@(height));
	i.draw({|bb|
		SCPen.smoothing_(false);
		i.drawStringAtPoint(str, 0@0, font, color);
	});
	i.interpolation_(\none);
	tgHeight = targetWidth * ratio;
	w = SCWindow.new("", Rect(400,400, 450, 150)).drawFunc_({
		SCPen.setShadow(2@2, 0.4, color:Color.red);
		i.drawInRect(Rect(5,5,targetWidth, tgHeight));
	});

	w.view.background_(Color.white);
	w.onClose_({run = false; i.free;});
	w.front;
)
::

METHOD::drawAtPoint
render the image or a portion of it in the current graphic context.
code::
(
	var operation='sourceOver', fraction=1.0, i, w;

	i = SCImage.new(
	//	"http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	//	SCDoc.helpSourceDir +/+ "images/duck_alpha.png"
		SCDoc.helpSourceDir +/+ "images/Swamp.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;

	SCSlider.new(w, Rect(10, 150, 150, 16))
		.value_(1.0)
		.action_({ arg sl;
			fraction = sl.value;
			w.refresh;
		});

	SCPopUpMenu.new(w, Rect(170, 150, 100, 16))
		.items_( SCImage.compositingOperations.collect({ arg i; i.asString }) )
		.value_(2)
		.action_({ arg pm;
			operation = SCImage.compositingOperations.at(pm.value);
			w.refresh;
		});

	w.onClose_({ i.free }); // free the image when the window is closed

	w.drawFunc_({

		i.drawAtPoint(10@10, nil, operation, fraction);

	});
)
::

ARGUMENT::point
the link::Classes/Point:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::drawInRect
render the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
(
	i = SCImage.new(
		// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
		SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;
	w.onClose_({ i.free }); // free the image when the window is closed
	w.drawFunc_({
		i.drawInRect(Rect(10,10,50,50), Rect(10,10,50,50), 2, 1.0); // only a section
	});
)
::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::tileInRect
tile the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
(
	i = SCImage.new(
		// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
		SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;
	w.onClose_({ i.free }); // free the image when the window is closed
	w.drawFunc_({
		i.tileInRect(w.view.bounds, nil, 2, 1.0); // all image contents
	});
)
::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.
NOTE::
Compositing operations are currently disabled for tileInRect
::

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

SUBSECTION::Instance Methods / accessing and setting pixels

METHOD::setPixel
fill a pixel located at x @ y.
code::
i = SCImage.color(60, 60, Color.blue(0.1,0.1));
w = i.plot;
i.setPixel([255,0,0,255].asRGBA, 0, 0); // setting red
w.refresh;
("pixel at 0 @ 0:"+i.getPixel(0,0).rgbaArray).postln;
i.free;
::

ARGUMENT::rgbaInteger
an 32 bit link::Classes/Integer:: containing color information packed as 8bit RGBA

METHOD::getPixel
retrieve the pixel value at x @ y as a RGBA integer
code::
// A simple example on how to manipulate pixels with SCImage
b = Int32Array[
	Integer.fromRGBA(255,0,0,255), // red
	Integer.fromRGBA(0,255,0,255), // green
	Integer.fromRGBA(0,0,255,255), // blue
	Integer.fromRGBA(255,0,255,255) // purple
];

b[0].red; // 255 see Integer.red
b[0].green; // 0 see Integer.green
b[0].blue; // 0 see Integer.blue
b[0].alpha; // 255 see Integer.alpha

a = SCImage.new(b.size@1).pixels_(b).interpolation_(\none);
a.plot;


// Set + Get
a.setPixel([255, 0, 255, 128].asRGBA /* create an Integer from 0-255 integer rgba value */, 0, 0).plot;
p = a.getPixel(0,0);

p.red; // 255
p.green; // 0
p.blue; // 255
p.alpha; // 128

// now another important example
a.setPixel([255, 0, 255, 0].asRGBA, 1, 0).plot; // clear color -> alpha is 0
p = a.getPixel(1,0);

p.red; // you expect 255 but you get 0 ??? Why = because SCImage uses premultiplied color component value internally
// meaning all Red, Green, and Blue component are premultiplied by the alpha
// if alpha is 0 you get 0 back for all components.

p.green; // 0
p.blue; // 0
p.alpha; // 0

p = a.getColor(1,0); // more explicit - but same here
::

METHOD::setColor
fill the pixel located at x @ y with the specified strong::color::.

METHOD::getColor
retrieve the pixel value at x @ y as a link::Classes/Color::.

METHOD::pixels
retrieve or set all the pixels of the receiver.
NOTE::
Carefull: the returned Array is a link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer
::

ARGUMENT::array
an link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer

METHOD::loadPixels
load all the pixels of the receiver in an array. it is better and faster to call this function instead of link::#-pixels:: if you plan to retrieve frequently the pixel data (since it won't allocate a new array everytime !)
code::
// exec one line at a time
i = SCImage.new(
	// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
);

// first grab the pixels
p = i.pixels;

// do some mods - here invert
i.invert;

// reload directly in my array - do not need to call i.pixels again
i.loadPixels(p);
i.free;
p;
::

ARGUMENT::array
the array that will be filled. Should be an link::Classes/Int32Array:: of size receiver.width * receiver.height.

ARGUMENT::region
the targeted rectangular region. (nil by default, meaning full size)

ARGUMENT::start
the start index of the array.

METHOD::setPixels
set the pixels in a specific portion of the receiver.
code::
(
	i = SCImage.new(20@20);
	i.pixels_(
		Int32Array.fill(i.width * i.height, {
			Integer.fromRGBA(255.rand,127.rand,255.rand,255)
		})
	);
	//i.interpolation_(\none); // uncomment to see the difference
	w = i.plot(freeOnClose:true);
	i.pixels.postln;
)

(
	i = SCImage.color(50@50, Color.white);
	i.setPixels(
		Int32Array.fill(20*20,{Integer.fromRGBA(255.rand, 127.rand, 255.rand, 255)}),
		Rect(10,10,20,20)
	);
	i.interpolation_(\none); // uncomment to see the difference
	w = i.plot(freeOnClose:true);
	i.pixels.postln;
)
::

ARGUMENT::array
an link::Classes/Int32Array:: of size strong::rect::.width * strong::rect::.height containing all pixel values as 32bit Integer

ARGUMENT::rect
a rectangle defining the portion to update in the receiver. By default strong::rect:: is nil, meaning full image size.

ARGUMENT::start
the array start index.

SUBSECTION::Instance Methods / Attributes for SCImageFilter support

see link::Classes/SCImageFilter:: for more info

METHOD::applyFilters
apply an array of link::Classes/SCImageFilter:: to the image. this should be considered as an in place operation, meaning the SCImage is altered after it.
code::
// ******** Built In CoreImage Generators ********
// Generators are not filters, they actually create an image but do not need an input image
// you just have to create an image of a new size
// ** The Simple Random Filter **
(
f = SCImageFilter.new(\CIRandomGenerator);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
a.bounds.postln;
)

// ** The StarShine example **
(
var width=500, height=500, centerVector;

centerVector = [ width*0.5, height*0.5 ];
a = SCImage.new(500@500);
f = SCImageFilter.new(\CIStarShineGenerator);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.blue);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);

a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.gray); // change background to see
)


// ** Starshine + Pixellate + ZoomBlur **
(
var width=500, height=500, centerVector;

centerVector = [ width*0.5, height*0.5 ];
a = SCImage.new(500@500);

f = SCImageFilter.new(\CIStarShineGenerator);
g = SCImageFilter.new(\CIPixellate);
h = SCImageFilter.new(\CIZoomBlur);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.blue);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);
g.center_(centerVector);
h.center_(centerVector);
h.amount_(50);

a.applyFilters([f, g, h]);
w = a.plot(freeOnClose:true, background:Color.black);
)
::

ARGUMENT::filters
a SCImageFilter or an array of link::Classes/SCImageFilter:: to be applied

ARGUMENT::crop
the crop region to finally use. This may be required for extending bounds since some SCImageFilter / CoreImageFilters require to set a wider region (to be applied correctly) or may create a huge image. Setting crop to nil sets no crop region. In case the current maximum size of a filtered SCImage is 4096 / 4096. Any larger size will be clipped. by default crop is constrained to the receiver bounds.

ARGUMENT::region
option to constrain the filter to a specific region IN the SCImage.

METHOD::filteredWith
returns a new SCImage, copy of the receiver filtered with an array of SCImageFilter. arguments are the same as link::#-applyFilters:: (except for strong::region::).
NOTE::
Beware: you are responsible for freeing the newly created SCImage !!!
::

METHOD::filters
filters is the instance variable that holds the array of SCImageFilter attached to the receiver. This is a convenient for applying filters out place and changing the SCImageFilter's attributes. see link::#-addFilter::, link::#-removeFilter::

see link::Classes/SCImageFilter:: for an example on how to use the strong::filters:: array.

METHOD::addFilter
you can also attach filters to the receiver for real-time changing operations. In this case the receiver will create a cache before each rendering to maintain its previous state, and allowing you to use filters without applying them in place. The cache is managed directly by the receiver. you can add several filters to the receiver, the first filter in the array is the first applied in the rendering chain.

see link::Classes/SCImageFilter:: for an example on how to use strong::addFilter::.

ARGUMENT::filter
a SCImageFilter to apply before rendering of the image

METHOD::removeFilter

see link::Classes/SCImageFilter:: for an example on how to use strong::removeFilter::.

ARGUMENT::filter
the SCImageFilter to remove from the rendering chain.

METHOD::flatten
if link::#-filters:: is not zero sized, this method will apply all those filters in place. if the image is accelerated this method force a bitmap representation of the receiver.

METHOD::invert
invert the receiver
code::
(
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.invert;
i.plot(freeOnClose:true);
)
::

METHOD::crop
crop the receiver
code::
(
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.crop( Rect(10,10,120,100) );
i.plot(freeOnClose:true);
)
::

ARGUMENT::aRect
the cropping region

SUBSECTION::Instance Methods / Attributes for SCImageKernel support

see link::Classes/SCImageKernel:: for examples and more info.

METHOD::applyKernel
apply a Kernel in place. the receiver is modified after this call.

ARGUMENT::kernel
a link::Classes/SCImageKernel::

EXAMPLES::

SUBSECTION::Views addition

you can now use a SCImage as a valid view background. 16 drawing modes are defined to behave differently.

definitionList::
## tileMode values: ||
table::
## 1 || fixed to left, fixed to top
## 2 || horizontally tile, fixed to top
## 3 || fixed to right, fixed to top
## 4 || fixed to left, vertically tile
## 5 || horizontally tile, vertically tile
## 6 || fixed to right, vertically tile
## 7 || fixed to left, fixed to bottom
## 8 || horizontally tile, fixed to bottom
## 9 || fixed to right, fixed to bottom
## 10 || fit
## 11 || center, center (scale)
## 12 || center , fixed to top
## 13 || center , fixed to bottom
## 14 || fixed to left, center
## 15 || fixed to right, center
## 16 || center, center (no scale)
::

## SCView:backgroundImage_ ||

strong::image:: - the SCImage to use

strong::tileMode:: - the mode to use. by default fixed to left, fixed to top

strong::alpha:: - opacity 0 < x < 1

strong::fromRect:: - the portion of the image to use. by default use the full image.
::
code::
(
	b = 1.0;
	a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
	r = Rect(20,3,40,40);
	w = SCWindow.new("SCImage background" /*, textured:false*/ );
	w.view.background_(Color.gray);
	w.view.backgroundImage_(a, 5, b, r);
	w.front;
)

// monte carlo :) exec every line to test
// r = nil; // uncomment for full image
w.view.backgroundImage_(a, 1, b, r);
w.view.backgroundImage_(a, 2, b, r);
w.view.backgroundImage_(a, 3, b, r);
w.view.backgroundImage_(a, 4, b, r);
w.view.backgroundImage_(a, 5, b, r);
w.view.backgroundImage_(a, 6, b, r);
w.view.backgroundImage_(a, 7, b, r);
w.view.backgroundImage_(a, 8, b, r);
w.view.backgroundImage_(a, 9, b, r);
w.view.backgroundImage_(a, 10, b, r);
w.view.backgroundImage_(a, 11, b, r); // find best ratio - move to see
w.view.backgroundImage_(a, 12, b, r);
w.view.backgroundImage_(a, 13, b, r);
w.view.backgroundImage_(a, 14, b, r);
w.view.backgroundImage_(a, 15, b, r);
w.view.backgroundImage_(a, 16, b, r);

// this is safe even if window is still open because Background object holds the SCImage
a.free;

w.close;

(
	a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	w = SCWindow.new("SCImage background");
	l = SC2DSlider.new(w, Rect(10,10,200,200))
		.backgroundImage_( a, 5, 1, Rect(0,0,10,10) );
	w.front;
	a.free; // safe
)

(
	var bounds = Rect(10,10,150,18);
	a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	w = SCWindow.new("SCImage background");
	l = SCSlider.new(w, bounds)
		.backgroundImage_(a);
	w.front;
	a.free; // safe
)
::


class:: SCImageFilter
summary:: filter class to use with SCImage
categories:: GUI>Views
related:: Classes/SCImage, Classes/SCImageKernel

DESCRIPTION::

currently this class represents the CoreImage Filters you can apply to a SCImage. All the built-in filters and docs: http://developer.apple.com/documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html

CLASSMETHODS::

PRIVATE::prFilterSet, prGetFilterAttributes, initClass, prGetFilterNames

METHOD::new
code::
f = SCImageFilter.new(\CIStarShineGenerator);
f.attributes;

// or you can do also Synth like style if you already know the attributes of this synth
f = SCImageFilter.new(\CIStarShineGenerator, [\center, [200,200], \radius, 200*0.05]);
f.values; //
::

ARGUMENT::filterName
The filter name link::Classes/Symbol:: or link::Classes/String::

ARGUMENT::args
The filter name link::Classes/Symbol:: or link::Classes/String::

METHOD::filterCategories
Returns a Dictionary containing all the filters associated by categories.
code::
// getting filter categories (dictionary)
(
	SCImageFilter.filterCategories.keysDo({|cat|
		cat.postln;
	});
	"ok".postln;
)

// getting Filters for a category - returns a SymbolArray
SCImageFilter.filterCategories.at(\CICategoryGeometryAdjustment);
SCImageFilter.filterCategories.at(\CICategoryGenerator);

// finding Non Built In Plugins usually plugins loaded in (/Library/Graphics/Image Units/)
// all plugins are loaded at startup
// you can find free plugins at http://www.noiseindustries.com/products/
(
var n = 0;
SCImageFilter.filterCategories.do ({
	|symbolArray|
	symbolArray.do ({|pluginName|
		if(pluginName.asString.beginsWith("CI").not, {
			("External Filter Found: " ++ pluginName).postln;
			n = n+1;
		});
	});
});
(n + "plugins found").postln;
n;
)
::

INSTANCEMETHODS::

PRIVATE::prAttributeRange, doesNotUnderstand

METHOD::attributes
returns an link::Classes/IdentityDictionary:: containing for each association:
list::
## the attribute/property name as the key.
## the SuperCollider link::Classes/Class:: you should use as an argument to set the attribute.
::
Once you know the attributes you can set them like using normal instance setters, use the name and append '_'.
code::
(
f = SCImageFilter.new(\CIStarShineGenerator);
f.attributes.keysValuesDo({|k, v|
	("CIStarShineGenerator responds to "++k.asString++"_("++v.asString++")").postln;
});
)

f.center_([200,200]);
f.radius_(200*0.05);
::

METHOD::attributeRange
get the numerical range and the default Value for an attribute. returns an Array as code::[ min, max, default ]::. min, max, or default may be a link::Classes/Float::, a link::Classes/Color::, an link::Classes/Array:: or link::Classes/Nil::.
code::
// a SCImageFilter
f = SCImageFilter.new(\CIFlashTransition);

f.dump;

f.attributes;

f.attributeRange(\time);

// getting all attributes MIN - MAX possible values
(
f.attributes.keysDo({|attr|
	(attr ++ " = " + f.attributeRange(attr)).postln; // nil results means there is no min max for those attributes
});
)
::

METHOD::values
returns all the values you set for each attributes. If a value is not explicitly set for an attribute, it will be set to default when applied to the SCImage.
code::
(
	f = SCImageFilter.new(\CIStarShineGenerator);
	f.center_([200,200]);
	f.radius_(200*0.05);
	f.color_(Color.blue);
	f.crossWidth_(2.0);
	f.crossAngle_(0.0);
	f.crossOpacity_(-4.0);
	f.values.postln;
)
::

METHOD::set
set the attributes for this SCImageFilter
code::
(
	f = SCImageFilter.new(\CIStarShineGenerator);
	f.set(\center, [200,200], \radius, 200*0.05, \color, Color.blue, \crossWidth, 2.0);
	f.values.postln;
)
::

METHOD::enable
enable or not the Filter when applied to a SCImage.

ARGUMENT::value
If this is false, applying the filter will do nothing.

EXAMPLES::

code::
// thor's fast experimentation request
// example with the filters array which allows you to use filters without applying them in place
// convenient for RT use / test or whatever...

// here scale down the image otherwise with the zoomblur it will take your computer
// to its knees using addFilter and not applyFilter
// kinda fast swapping test

a = SCImage.new("/Library/Desktop Pictures/Plants/Peony.jpg").scalesWhenResized_(true).setSize(500, 400);
a.plot; // look at me first - i am beautiful

// but i want you to be posterize
(
h = SCImageFilter.new(\CIColorPosterize);
a.addFilter(h); // first call needed
a.plot; // there should have it
)

// then you can freely access and set the slot directly - easier
(
a.filters[0] = SCImageFilter.new(\CIColorInvert);
a.plot;
)

// again
(
a.filters[0] = SCImageFilter.new(\CIZoomBlur);
a.plot;
)

// again
(
a.filters[0] = SCImageFilter.new(\CIRandomGenerator);
a.plot;
)

(
a.removeAllFilters;
a.plot(freeOnClose:true);
)


// ** Masking Example **
(
f = SCImageFilter.new(\CIColorMonochrome); // create a GrayScale image
g = SCImageFilter.new(\CISourceInCompositing); // compositing we will use
f.color_(Color.black);
f.intensity_(1.0);
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
a.bounds;
b = SCImage.new(SCDoc.helpSourceDir +/+ "images/flowers2.jpg");
a.applyFilters([f, SCImageFilter(\CIColorInvert), SCImageFilter(\CIMaskToAlpha)]); // grayscale + invert + maskToAlpha = create a mask
g.backgroundImage_(a); // set up background image
b.applyFilters(g); // create masked image
a.free;
w = b.plot(freeOnClose:true, background:Color.clear); // set to clear color to see plainly the image
)


// *** Kinda very simple real time FX using the .filters property of SCImage **
// SCImage.filters provides a way to set up filters to apply in the rendering chain
// this can be useful to modify in RT some filter properties
// but they won't be processed in place, they will be computed at each rendering
// here the filter calc is performed at each rendering call
// so this is convenient but not optimal
// SCPhotoshop :)
(
var width=500, height=500, centerVector;
var controller, specs;

centerVector = [width*0.5, height*0.5];
a = SCImage.new(500@500);
a.accelerated_(true);
f = SCImageFilter.new(\CIStarShineGenerator);
g = SCImageFilter.new(\CIPixellate);
h = SCImageFilter.new(\CIZoomBlur);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.green);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);
g.center_(centerVector);
h.center_(centerVector);
h.amount_(50);

// simple example control
specs = [
	[f, \crossOpacity_, [-8, 0].asSpec, -4],
	[f, \crossAngle_, [-pi, pi].asSpec, 0.0],
	[h, \amount_, [0, 200].asSpec, 50],

]; // CIStarShine opacity, CIZoomBlur

controller = SCWindow.new("Close Me First !!!", Rect(400,400,300,specs.size * 40));
controller.view.decorator = FlowLayout(controller.view.bounds.insetBy(10), 10@10);
specs.size.do {|i|
	SCSlider.new(controller, Rect(0,0,150,20))
	.action_({|obj|
		specs[i][0].perform(specs[i][1], specs[i][2].map(obj.value));
		w.refresh;
	})
	.value_(specs[i][2].unmap(specs[i][3]));
	controller.view.decorator.nextLine;
};

// adding filters
a.addFilter(f);
a.addFilter(g);
a.addFilter(h);

a.filters.do {|filt, i|
	if(i != 0, {
		SCButton.new(controller, Rect(0,0,20,20))
		.action_({|obj|
			filt.enable_(obj.value != 1);
			w.refresh;
		})
		.states_([["", Color.white], ["", Color.white, Color.black]]);
	});
};

// plotting
w = a.plot(background:Color.black);
controller.front;
controller.onClose_({
	{
	w.close;
	}.defer(0.1);
});
)


/*
// ******** Using EXTERNAL NI Image Units Generator + FX *******
// Download them --- MIGHT BE 10.5 Only so
// http://www.noiseindustries.com/downloads/Units.dmg
// When using for the first time an Image plugin, it might take some extra time due to the plugin loading
// Random
(
f = SCImageFilter.new(\NINoiseGenerator);
f.width_(500); f.height_(500);
f.grayscale_(true);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
)


(
f = SCImageFilter.new(\NIDropShadow);
f.offsetX_(0);
f.offsetY_(0);
f.radius_(30);
f.shadowColor_(Color.red);
a = SCImage.new("vduck2.jpg");
a.applyFilters(f, a.bounds.outsetBy(500));
w = a.plot(freeOnClose:true, background:Color.clear);
a.bounds;
)

(
f = SCImageFilter.new(\NIDotsGenerator);
f.softness_(1);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
)

(
f = SCImageFilter.new(\NICircle);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true);
)
*/
::


class:: SCImageKernel
summary:: kernel class to use with SCImage
categories:: GUI>Views
related:: Classes/SCImage, Classes/SCImageFilter

DESCRIPTION::

code::// very experimental :)::

Currently this class represents the CoreImage strong::CIKernel:: you can apply to a link::Classes/SCImage::. The Kernel language is a subset of the OpenGL Shading Language. more information about the Kernel Language can be found here : http://developer.apple.com/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/chapter_1_section_1.html

and here: http://developer.apple.com/documentation/GraphicsImaging/Reference/CIKernelLangRef/chapter_2_section_1.html#//apple_ref/doc/uid/TP40004397-CH206-TPXREF101

here is the translation table between Kernel language Objects and SuperCollider objects

table::
## strong::Kernel Language Object:: || strong::SuperCollider Object::
## sampler || link::Classes/SCImage::
## __color || link::Classes/Color::
## float || link::Classes/Number::
## vec2, vec3, vec4 || link::Classes/Array::
## __table || link::Classes/SCImage:: (basically the __table modifier just use Images as a data providers - LUT)
::

CLASSMETHODS::

METHOD::new
creates a new SCImageKernel

ARGUMENT::shader
optional. the shader code string. nil by default

ARGUMENT::values
optional. the values that match the kernel proc function defined in the shader string. nil by default

ARGUMENT::bounds
optional. not used for now. nil by default

INSTANCEMETHODS::

METHOD::shader
get or set the shader string.

METHOD::values
get or set the values array. When setting the object indexes in the values Array must match the argument declaration order as defined in the main emphasis::kernel vec4 routine::. See link::#examples:: for more info.

METHOD::isValid
very basic verification to tell if all arguments of the shader are set.

METHOD::compile
compile the SCImageKernel object (and cache it).
NOTE::
when rendered the first time, the kernel object is always compiled first. If you plan to change the shader string after, you must explicitely compile it to make it effective.
::

EXAMPLES::

code::
/**** Kernels ****/
// very experimental
// COLOR INVERSION SHADER EXAMPLE
(
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg"); // get the image
k = SCImageKernel.new;
k.shader_("

vec4	invertPixel(vec4 pix) {
	return vec4(1.0 - pix.r, 1.0 - pix.g, 1.0 - pix.b, pix.a);
}

kernel vec4 _invertColor(sampler source)
{
	vec4 pixel;
	pixel = sample(source, samplerCoord(source));
	unpremultiply(pixel);
	return unpremultiply(invertPixel(pixel));
}
");

// the argument order should be kept in the array
// here we need only the "sampler" argument which should be as the translation table informs you a SCImage
// the signature of the Kernel function is normally 'kernel vec4'
// you can of course add other functions in the shader
k.values_([a]);

k.isValid.postln; // is it ok
a.applyKernel(k);

w = a.plot(freeOnClose:true);
)


(
// ANOTHER APPLE KERNEL EXAMPLE - See CoreImage programming guide for original example
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg"); // get the image
k = SCImageKernel.new;
k.shader_("
vec2 testVec(float x, float y)
{
	return vec2(x, y);
}

kernel vec4 testKernelFromApple( sampler src, __color color, float distance, float slope )
{
	vec4 	t;
	float	d;
	d = destCoord().y * slope + distance;
	t = unpremultiply(sample(src, samplerCoord(src)));
	t = (t - d*color) / (1.0-d);
	return premultiply(t);
}
");

// as stated in the Apple Example
// distance - min: 0.0 max: 1.0
// slope - min: -0.01 max: 0.01
k.values_(
	[
	a,		// arg 0: the SCImage
	Color.white,	// arg 1: color
	0.5, 		// arg 2: distance
	-0.002		// arg 3: slope
	]
);

a.applyKernel(k);

w = a.plot(freeOnClose:true);
)




(
// OK a Better Colorful Kernel
a = SCImage.new(600@600); // get the image
k = SCImageKernel.new;

k.shader_(
// shader/kernel from toneburst.com
// Generates spherical and planar displacement maps for VBO-based 3D heightfield.
// http://machinesdontcare.wordpress.com
"
const float PI = 3.14159265359;
const float TWOPI = 6.28318530718;

kernel vec4 _heightMap(sampler image, vec3 scale)
{
	vec2 xyNorm = samplerCoord(image) / samplerSize(image);
	float u = xyNorm.x * PI;
	float v = xyNorm.y * TWOPI;
	vec3 spherical;
	spherical.r = cos(v) * sin(u);
	spherical.g = sin(v) * sin(u);
	spherical.b = cos(u);

	spherical.r = (spherical.r * 0.5 + 0.5) * scale.x;
	spherical.g = (spherical.g * 0.5 + 0.5) * scale.y;
	spherical.b = (spherical.b * 0.5 + 0.5) * scale.z;

	return vec4(spherical,1.0);
}
");

k.values_([a, [1.0, 1.0, 1.0]]);

// k.isValid; // is it ok
a.applyKernel(k);
//.flatten; // ensure a bitmap rep so the kernel is not applied at each rendering call - uncomment that and rescale the plot window to see the difference.

w = a.plot(freeOnClose:true);
)
::


CLASS:: SCViewHolder
summary:: Instead of subclassing a (Q/SC)View, this is a proxy/adapter object that holds the View
categories:: GUI
related:: Classes/View

DESCRIPTION::
When writing gui widgets it is sometimes not desirable to subclass a view class. Its preferable to write a class that acts like a View and is used where Views normally are used but isn't a direct subclass of a View class.

In the View hierarchy it is not possible to subclass an View class because under the hood there is always a strict relationship between the View subclass and its paired C++ class.  The C++ class makes the actual view, the SC class is an interface to that C++ object.

In Qt there is a bit more flexibility.

But there are other reasons to not inherit from a specific view: your widget may not be a single view, in which case you would want to place a CompositeView and then place subviews inside of that.  Altogether these views are what your widget manages.  SCViewHolder can be used in this situation and it would set the top level CompositeView as its primary view.

Although it is still called "SC"ViewHolder it is in fact cross platform since it doesn't draw the view(s), it simply holds them.

Another possible name might be ViewAdapter or PseudoView.  It was originally called SCViewAdapter.

Most of the standard view methods here simply defer to the proxied view.  This makes the ViewHolder act and quack like a View.

Messages that are not understood by the view holder are forwarded to the proxied view.

Historical note: this class was originally in the cruciallib.  ObjectGui is a subclass of this.

CLASSMETHODS::

METHOD:: consumeKeyDowns
global preference variable: if true then subclasses that do not set a keyDownAction do NOT bubble up keyDown events by default.

returns:: The result of calling the method on the proxied view


INSTANCEMETHODS::


METHOD:: view
get or set the view for which this object is a proxy/adapter.

argument:: v
the view: a link::Classes/View::

returns:: The result of calling the method on the proxied view


METHOD:: doesNotUnderstand
Messages that are not understood by the view holder are forwarded to the proxied view.  So when the interpreter is told to send a message to a view holder object and that message is not understood, it calls doesNotUnderstand

argument:: selector
The message that was not understood

argument::  ... args
The arguments that were supplied

returns:: the result of calling the method on the proxied view


METHOD:: viewDidClose
Unsets the view variable. After the view is closed (removed from the window) then all calls to the view holder will fail, and should fail as there is no view anymore.  You can check viewHolder.isClosed if you are unsure

returns:: this

METHOD:: remove
Removes the view from the window if it has not already been removed.

returns:: this

METHOD:: action
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view

METHOD:: doAction
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: keyDownAction
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view

METHOD:: keyDownResponder
This method is forwarded to the view.  Note: this is a cruciallib convention and will be deprecated here.

returns:: The result of calling the method on the proxied view

METHOD:: enableKeyDowns
This method is forwarded to the view. Note: this is a cruciallib convention and will be deprecated here.

returns:: The result of calling the method on the proxied view

METHOD:: asView
returns the view

returns:: the view

METHOD:: bounds
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: resize
This method is forwarded to the view

argument:: r


returns:: The result of calling the method on the proxied view

METHOD:: enabled
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: refresh
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: background
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: focus
This method is forwarded to the view

argument:: flag


returns:: The result of calling the method on the proxied view

METHOD:: visible
This method is forwarded to the view

argument:: boo


returns:: The result of calling the method on the proxied view

METHOD:: isClosed
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: font
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view






class:: SOS
summary:: Second order filter section (biquad).
related:: Classes/FOS
categories::  UGens>Filters>Linear


Description::

A standard second order filter section. Filter coefficients are given
directly rather than calculated for you. Formula is equivalent to:

code::

out(i) = (a0 * in(i)) + (a1 * in(i-1)) + (a2 * in(i-2)) + (b1 * out(i-1)) + (b2 * out(i-2))

::


classmethods::

method::ar, kr

argument::in

signal input

argument::a0
See formula above.

argument::a1
See formula above.

argument::a2
See formula above.

argument::b1
See formula above.

argument::b2
See formula above.

argument::mul

argument::add

Examples::

code::

// example: same as TwoPole
(
{
	var rho, theta, b1, b2;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;
	SOS.ar(LFSaw.ar(200, 0, 0.1), 1.0, 0.0, 0.0, b1, b2)
}.play
)


(
{
	var rho, theta, b1, b2;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;
	SOS.ar(WhiteNoise.ar(0.1 ! 2), 1.0, 0.0, 0.0, b1, b2)
}.play
)

// example with SOS.kr kr as modulator
(
{
	var rho, theta, b1, b2, vib;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;

	vib = SOS.kr(LFSaw.kr(3.16), 1.0, 0.0, 0.0, b1, b2);
	SinOsc.ar( vib * 200 + 600) * 0.2
}.play
)

::



class:: SampleDur
summary:: Duration of one sample.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the current sample duration of the server.
Equivalent to 1/SampleRate.


classmethods::

method::ir



class:: SampleRate
summary:: Server sample rate.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleDur, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the current sample rate of the server.


classmethods::

method::ir

Examples::

code::

// compares a 441 Hz sine tone derived from sample rate (44100 * 0.01, left)
// with a 440 Hz tone (right), resulting in a 1 Hz beating
(
{
	var freq;
	freq = [ SampleRate.ir * 0.01, 440];
	SinOsc.ar(freq, 0, 0.1)
}.play;
)

::



class:: Sanitize
summary:: Remove infinity, NaN, and denormals
categories:: UGens>Info

description::
Replaces infinities, NaNs, and subnormal numbers (denormals) with a given signal, zero by default. The method link::Classes/UGen#-sanitize:: provides a shorthand for this.

See also link::Classes/CheckBadValues::, which allows you to discriminate specific kinds of bad values and print information about them to the post window.

classmethods::

method:: ar, kr
argument:: in
Input signal to sanitize.

argument:: replace
The signal that replaces bad values.



class:: Saw
summary:: Band limited sawtooth.
related:: Classes/SyncSaw, Classes/VarSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

Band limited sawtooth wave generator.


classmethods::

method::ar

argument::freq

Frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// modulating the frequency

{ Saw.ar(XLine.kr(40,4000,6),0.2) }.play;

// two band limited sawtooth waves through a resonant low pass filter

{ RLPF.ar(Saw.ar([100,250],0.1), XLine.kr(8000,400,5), 0.05) }.play;

::



TITLE:: ScIDE
summary:: interaction with the Qt IDE
categories:: Frontends
related:: Classes/Document

DESCRIPTION::

The ScIDE class contains a number of class methods for interaction with the Qt IDE. Most users won't need to access these methods directly. For example, the link::Classes/Document:: class wraps most of the document-related functionality.

There's no use calling *new on this class. It has no instance methods!


CLASS::Scale
summary::represents a musical scale
related::Classes/Tuning
categories::Math, Tuning

DESCRIPTION::
Scale supports arbitrary octave divisions and ratios, and (in conjunction with link::Classes/Tuning::) can generate pitch information in various ways, including as input to Patterns.

code::
s.boot;

a = Scale.major;
a.degrees;		// [ 0, 2, 4, 5, 7, 9, 11 ]
a.semitones;		// [ 0, 2, 4, 5, 7, 9, 11 ]
a.cents;		// [ 0, 200, 300, 500, 700, 900, 1100 ]
a.ratios;		// [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]

Pbind(\scale, a, \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;

// use non-standard tuning
a.tuning_(\just);
a.degrees;		// no change; degrees are independent of tuning
a.semitones;		// [ 0, 2.0391000173077, 3.1564128700055, 4.9804499913461, etc. ]
a.ratios.collect(_.round(0.001));	// [ 1, 1.125, 1.2, 1.333, 1.5, 1.667, 1.875 ]

Pbind(\scale, a, \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;
::

subsection::Creation

strong::*major, *minor, *dorian, *chromatic, *todi, *hijaz, *partch_o1, etc.::

Creates a scale from the library stored in the instance variable "all". Each scale comes with an appropriate default link::Classes/Tuning::, but alternate tunings can be specified at creation time:
code::
Scale.phrygian(\pythagorean)
::
If the tuning size does not match the scale's link::#-pitchesPerOctave::, a warning will be thrown, and the scale will use its default tuning.

For a complete list of available scales, execute
code::
Scale.directory
::

CLASSMETHODS::

method::all
The scale repository, to which new scales can be added.

code::
Scale.all.put(\catastrophic, Scale([0, 0.01, 0.04, 11.2]));
Scale.at(\catastrophic); // access the scale
::

method::at
Access from the scale repository.
code::
Scale.all.put(\catastrophic, Scale([0, 0.01, 0.04, 11.2]));
Scale.at(\ionian);
Scale.newFromKey(\ionian); // access a copy of the scale for modification
::

method::choose
Creates a random scale from the library, constrained by size and pitchsPerOctave if desired.
code::
Scale.choose;		// could be anything
Scale.choose(7);	// will be a seven-note scale in its default tuning (could be any)
Scale.choose(7, 12);	// will be a seven-note scale in a twelve-tone tuning (usually ET!2)

// Random seven-note scale in random twelve-tone tuning
a = Scale.choose(7, 12).tuning_(Tuning.choose(12));
a.tuning.name;
::

method::new
Creates a Scale from scratch. strong::degrees:: should be an array of Integers or scale name. If strong::pitchesPerOctave:: is nil, will guess the most appropriate number based on degrees. strong::tuning:: can be an instance of link::Classes/Tuning:: or a symbol; if nil, will be equal temperament of pitchesPerOctave. Specify strong::descDegrees:: if the Scale should play differently when descending than when ascending; otherwise it should be nil.
code::
Scale.new(#[0, 1, 3, 6, 8, 10, 11], name: "My ET12");		// will be in ET12
Scale.new(#[0, 3, 7, 10, 15, 19, 22], name: "My Quarter-Tone");	// will be in ET24
Scale.new(#[0, 6, 17, 21, 30, 39], 43, \partch, "My Partch");
::

method::chromatic

Returns a chromatic scale for a specific tuning.

INSTANCEMETHODS::

private::storeOn, storedKey, storeArgs, printOn

method::tuning
Sets or gets the tuning of the Scale.
argument::inTuning
can be either an instance of link::Classes/Tuning:: or a symbol matching a library tuning.

method::semitones
Returns a tuned array of semitone values. link::#-as::(Array) is equivalent; link::#-as::(List) returns it as a list, etc.

method::cents
Returns a tuned array of cent values.

method::ratios
Returns a tuned array of ratios.

method::as
Converting. For example code::as(Array)::, code::as(List):: and code::as(LocalBuf):: which is useful for server-side work.
code::
(
r = {
	var scale = Scale.choose.postln;
	SinOsc.ar(
		(
			DegreeToKey.kr(
				scale.as(LocalBuf),
				MouseX.kr(0,15), // mouse indexes into scale
				scale.stepsPerOctave,
				1, // mul = 1
				60 // offset by 72 notes
			)
			+ LFNoise1.kr([3,3], 0.04) // add some low freq stereo detuning
		).midicps, // convert midi notes to hertz
		0,
		0.25
	)
}.play;
)

r.free;
::

method::size
Returns the length of the scale.
code::
Scale.ionian.size; // 7
Scale.minorPentatonic.size; // 5
Scale.ajam.size; // 7
Scale.partch_o1.size; // 6
::

method::pitchesPerOctave
Returns the size of the pitch class set from which the tuning is drawn.
code::
Scale.ionian.pitchesPerOctave; // 12
Scale.minorPentatonic.pitchesPerOctave; // 12
Scale.ajam.pitchesPerOctave; // 24--this is a quarter-tone scale
Scale.partch_o1.pitchesPerOctave; // 43
::

method::stepsPerOctave
Usually 12, but may be different if the current tuning has a stretched or compressed octave. Needed for degreeToKey.
code::
Scale.new((0..14), 15, tuning: \wcAlpha).stepsPerOctave;	// ~ 11.7
Scale.new(#[0, 3, 6, 9, 12], 13, tuning: \bp).stepsPerOctave;	// ~ 19.02
::
but note:
code::
Scale.ajam.stepsPerOctave;	// 12 -- quarter-tone scales have normal octaves
::

method::at, wrapAt
These access the array generated by semitones.
code::
a = Scale.major;
a.wrapAt(4);	// 7
a.wrapAt(5);	// 9
a.wrapAt(6);	// 11
a.wrapAt(7);	// 0
::

method::degreeToFreq
Returns a frequency based on current tuning and rootFreq argument.
code::
Scale.major.degreeToFreq(2, 60.midicps, 1);		// 659.25511...
Scale.major(\just).degreeToFreq(2, 60.midicps, 1);	// 654.06391...
::

method::degreeToRatio
Returns a ratio based on current tuning.
code::
Scale.major.degreeToRatio(2, 1).round(0.001);		// 2.52
Scale.major(\just).degreeToRatio(2, 1).round(0.001);	// 2.5
::

EXAMPLES::

code::
(
s.waitForBoot({
	a = Scale.ionian;

	p = Pbind(
		\degree, Pseq([0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0, \rest], inf),
		\scale, Pfunc({ a }, inf),
		\dur, 0.25
	);

	q = p.play;
})
)

// change scale
a = Scale.phrygian;

// change tuning
a.tuning_(\just);

// can also set tuning at creation time
a = Scale.ionian(\pythagorean);

// if you use a tuning with the wrong number of pitches per octave,
// you get a warning and the scale reverts to default tuning
a.tuning_(\partch);

// random scale
(
a = Scale.choose(7, 12);
[a.name, a.tuning.name].postln;
)

(
// or make up your own arbitrary scales and tunings
a = Scale.new(
	#[0, 2, 4, 5, 7, 9, 10],
	12,
	Tuning.new([0, 0.8, 2.1, 3, 4.05, 5.2, 6, 6.75, 8.3, 9, 10.08, 11.5]),
	"Custom"
);
)

// tuning has its own class
t = Tuning.werckmeister;

a = Scale.lydian(t);

q.stop;

// getting info
a.name;
a.degrees;
a.semitones;
a.ratios;

a.tuning.name;
a.tuning.semitones;
a.tuning.ratios;
::

code::
// for ascending/descending scales, use Pavaroh
(
Pbind(\note, Pavaroh(
	Pseq([0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0, \rest], 2),
		Scale.melodicMinor,
		Scale.melodicMinorDesc
	),
	\dur, 0.25
).play;
)
::

code::
// note that the root pitch is not stored in the Scale (which should arguably be called a Mode for that reason)
// instead you supply it at play time:

// key of A
Pbind(
	\degree, Pseq((0..7), inf), // your melody goes here
	\scale, Scale.major, // your scale goes here
	\root, -3 // semitones relative to 60.midicps, so this is A
).play;
::


TITLE:: ScelDocument
summary:: Document subclass for scel editor
categories:: IDE
related:: Classes/Document

DESCRIPTION::
Is this already implemented?
Please fill in details...


CLASS::Scheduler
categories::Scheduling
summary::schedules functions to be evaluated in the future

DESCRIPTION::
A Scheduler can be used to schedule and reschedule functions to be evaluated at a specific time-point. The Scheduler's time needs to be advanced manually. In most cases you will probably want to use a Clock (e.g. link::Classes/TempoClock::, link::Classes/SystemClock::, link::Classes/AppClock::) instead, in which the march of time is handled for you.

CLASSMETHODS::

method::new
argument::clock
A clock, like SystemClock.
argument::drift
If code::true::, link::#-sched:: will schedule tasks relative to the current absolute time ( link::Classes/Process#*elapsedTime#Main.elapsedTime:: ), otherwise to the current logical time of the scheduler ( link::#-seconds:: ).
argument::recursive
Sets link::#-recursive::.

INSTANCEMETHODS::

method::play
Schedules the task immediately. Equivalent to code::sched(0, task)::.

method::sched
Schedule the task at code::delta:: seconds relative to the current time, as defined by the code::drift:: argument of the link::#*new#constructor::.

Regardless of what time a task is scheduled, it will only be awaken the next time link::#-seconds:: is set.

method::schedAbs
Schedule the task at absolute code::time:: in seconds.

method::advance
Advance the current logical time by code::delta:: seconds. Has same effect as setting link::#-seconds::.

method::seconds
The current logical time of the scheduler.

Setting a new time will wake up (evaluate) any tasks scheduled within that time; a task that returns a new time will be rescheduled accordingly.

method::isEmpty
Returns whether the scheduling queue is empty.

method::clear
Clears the scheduling queue

method::queue
returns:: The instance of link::Classes/PriorityQueue:: used internally as scheduling queue.

method::recursive
If waking up items results in new items being scheduled, but some of them are already expired (scheduled at current time or earlier), this variable determines whether those items will be awaken as well in the same call to -seconds.

EXAMPLES::

code::
a = Scheduler(SystemClock);

a.sched(3, { "now it is 3 seconds.".postln; nil });
a.sched(5, { "now it is 5 seconds.".postln; nil });
a.sched(1, { "now it is 1 second.".postln; nil });

a.advance(0.5);
a.advance(0.5);
a.advance(2);
a.advance(2);

// the beats, seconds and clock are passed into the task function:
a.sched(1, { arg beats, secs, clock; [beats, secs, clock].postln });
a.advance(1);

// the scheduling is relative to "now":
a.sched(3, { "now it was 3 seconds.".postln });
a.sched(5, { "now it was 5 seconds.".postln });
a.sched(1, { "now it was 1 second.".postln });

a.advance(0.5);
a.advance(0.5);
a.advance(2);
a.advance(2);

// play a Routine or a task:
a.play(Routine { 5.do { arg i; i.postln; 1.yield } });
a.advance(0.9);
::

code::
// scheduling tasks
(
x = Scheduler(TempoClock.default);

Task {
	inf.do { |i|
		("next " ++ i ++ " in task." + Main.elapsedTime).postln;
		0.5.wait;
	}
}.play(x);
)

x.advance(0.1);
x.seconds;
x.advance(5);
x.seconds;

(
Routine {
	loop { x.advance(0.1); 0.1.wait };
}.play;
)

(
Task { 5.do {
	x.advance(1);
	2.0.rand.wait;
	}
}.play;
)

x.advance(8.1);

Pbind(\degree, Pseries(0, 2, 8), \dur, 0.25).play(x);

(
Task { 5.do {
	x.advance(0.20);
	1.0.wait;
	}
}.play;
)
::


class:: Schmidt
summary:: Schmidt trigger.
related:: Classes/InRange, Classes/InRect
categories::  UGens>Maths


Description::

If code::in > hi::, output 1. If code::in < lo::, output 0. Otherwise, repeat the
last sample of output, assumed to be 0 at initialization. In sclang-flavored
pseudocode:

code::
out[i] = if(in[i] < lo[i]) {
    0
} {
    if(in[i] > hi[i]) {
        1
    } {
        out[i-1]
    }
};
::

classmethods::

method::ar, kr

argument::in

Signal to be tested.


argument::lo

Low threshold.


argument::hi

High threshold.


Examples::

code::

s.boot;

{ Schmidt.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15)}.scope; // see the trigger

{ Schmidt.kr(MouseX.kr(0, 1), 0.2, 0.8)}.scope; // try it with the cursor

// threshold octave jumps
(
{
	var in = LFNoise1.kr(3);
	var octave = Schmidt.kr(in, -0.15, 0.15) + 1;
	SinOsc.ar(in * 200 + 500 * octave, 0, 0.1)
}.scope;
)

::



class:: ScopeOut
summary:: FIXME: ScopeOut purpose.
categories::  UGens>Buffer, UGens>Undocumented


Description::

FIXME: ScopeOut description.


classmethods::

method::ar, kr

argument::inputArray

FIXME: explain parameter inputArray.


argument::bufnum

FIXME: explain parameter bufnum.



CLASS:: ScopeView
summary:: A buffer plotting view.
categories:: GUI>Views
related:: Classes/Stethoscope, Classes/FreqScopeView, Classes/FreqScope

DESCRIPTION::

ScopeView is mainly intended to support the implementation of link::Classes/Stethoscope:: (an oscilloscope), link::Classes/FreqScopeView:: (a basic frequency spectrum plotting view) and link::Classes/FreqScope:: (a frequency spectrum analyzer tool).

It is optimized to efficiently perform frequent plotting of the contents of a link::Classes/Buffer:: into which a link::Classes/ScopeOut2:: UGen is writing. It will periodically poll the buffer for data and update the plot, as long as the ScopeOut2 UGen is writing into it; the buffer will not be plotted otherwise.


CLASSMETHODS::

PRIVATE:: key


INSTANCEMETHODS::

METHOD:: bufnum
    The number of the Buffer to plot.

    To set up the ScopeView object for plotting, one needs to set a valid buffer number and tell a link::Classes/ScopeOut2:: UGen to write to it. Before the view starts periodically plotting the buffer, however, one needs to assign it a link::Classes/Server:: object and call the link::#-start:: method on it.

    If the ScopeOut2 UGen stops writing or an invalid buffer number is set, the plotting will pause.

    argument::
        An integer.

METHOD:: server
    An instance of ScopeView must be assigned to a particular server for it to work.

    argument::
        A link::Classes/Server:: object

METHOD:: start
    Tells the ScopeView object to start plotting.

METHOD:: stop
    Tells the ScopeView object to stop plotting. Plotting can be resumed anytime with the link::#start:: method.

METHOD:: style
    The plotting style:
    list::
    ## 0 = the channels are vertically spaced
    ## 1 = the channels are overlaid
    ## 2 = lissajou; the first two channels are used for 2D plotting (as streams of x and y coordinates).
    ::

    argument::
        One of the above Integers.

METHOD:: xZoom
    The scaling factor on the horizontal axis.

    argument::
        A Float.

METHOD:: yZoom
    The scaling factor on the vertical axis.

    argument::
        A Float.

METHOD:: x
    The horizontal offset.
    argument::
        A Float.

METHOD:: y
    The vertical offset.
    argument::
        A Float.

METHOD:: fill
    Fill area under scope.
    argument::
        A Boolean.

METHOD:: waveColors
    The colors used to plot each of the channels.

    argument::
        An Array of Colors, one per channel.

EXAMPLES::

SUBSECTION:: A step-by-step example

code::
// boot the server (if not already booted)
s.boot;

// execute the following two blocks in succession:
(
f = Buffer.alloc(s,1024,2);
b = Bus.audio(s,1);

w = Window.new.front;
w.onClose = { // free everything when finished
    c.stop; a.free; d.free; f.free; b.free;
    "SynthDefs, busses and buffers have all been freed.".postln;
};
c = ScopeView(w.view,w.view.bounds.insetAll(10,10,10,10));
c.bufnum = f.bufnum;
c.server = s; // Important: one must assign the ScopeView to a server
)

(
// listening to the bus, using ScopeOut2 to write it to the buffer
a = SynthDef("monoscope", { arg bus, bufnum;
    var z;
    z = In.ar(bus, 2);

    ScopeOut2.ar(z, bufnum);
    Out.ar(0, z);
}).play(
    target: RootNode(s),
    args: [\bus, b.index, \bufnum, f.bufnum],
    addAction: \addToTail // make sure it goes after what you are scoping
);

// making noise onto the buffer
d = SynthDef("noise", { arg bus;
    var z;
    z = LFSaw.ar(SinOsc.kr(0.1).range(300,1000),[0,1]*pi) * 0.1;
    Out.ar(bus, z);
}).play(
    s,
    [\bus,b.index]
);
c.start; // Tell the ScopeView to start
CmdPeriod.doOnce({w.close});
)


c.style = 0; // vertically spaced
c.style = 1; // overlapped
c.style = 2; // x/y

::

SUBSECTION:: An interactive example with sound

This explains all the options:

code::
(
s.waitForBoot({
    var func, sdef1, sdef2, syn1, syn2,startButton ;
    f = Buffer.alloc(s,1024,2);
    b = Bus.audio(s,1);

    w = Window("Scope", Rect(150, Window.screenBounds.height-500,790,400)).front;
    c = ScopeView(w,Rect(10,10,380,380)); // this is SCScope
    c.bufnum = f.bufnum;

    // IMPORTANT
    c.server = s;

    v = CompositeView(w,Rect(400,10,380,380)).background_(Color.rand(0.7));
    v.decorator = n = FlowLayout(v.bounds, margin: 0@0, gap: 5@5);

    a = StaticText(v, Rect(20, 70, 90, 20)).string_(" xZoom = 1").background_(Color.rand);
    m = Slider(v, Rect(20, 60, 285, 20)).background_(a.background).action_({func.value}).value_(0.5);
    d = StaticText(v, Rect(20, 70, 90, 20)).string_(" yZoom = 1").background_(Color.rand);
    g = Slider(v, Rect(20, 60, 285, 20)).background_(d.background).action_({func.value}).value_(0.5);

    h = StaticText(v, Rect(20, 70, 90, 20)).string_(" x = 0").background_(Color.rand);
    i = Slider(v, Rect(20, 60, 285, 20)).background_(h.background).action_({func.value}).value_(0.5);

    Button(v, Rect(0,0,380, 20))
    .states_([["waveColors = [ Color.rand, ... ]",Color.black,Color.rand]])
    .action_({c.waveColors = [Color.rand,Color.rand]});

    Button(v, Rect(0,0,380, 20))
    .states_([[" background = Color.rand(0.1,0.3) ",Color.black,Color.rand]])
    .action_({c.background = Color.rand(0.1,0.3) });

    t = Button(v, Rect(0,0,380, 20))
    .states_([["Current style is 0",Color.black,Color.rand],
        ["Current style is 1",Color.black,Color.rand],
        ["Current style is 2",Color.black,Color.rand]])
    .action_({func.value});

    func = {
        c.xZoom = ([0.25, 10, \exp, 1/8, 1].asSpec.map(m.value)); a.string = " xZoom = %".format(c.xZoom);
        c.yZoom = ([0.25, 10, \exp, 1/8, 1].asSpec.map(g.value)); d.string = " yZoom = %".format(c.yZoom);
        c.x = ([ -1024,1024, \linear, 1/8, 1].asSpec.map(i.value)); h.string = " x = %".format(c.x);
        c.style=t.value
    };

    startButton = Button.new(v, Rect(0,0,380, 50))
    .states_([["Start Sound",Color.black,Color.green],["Stop Sound",Color.black,Color.red]]).action_({});


    startButton.action_{
        (startButton.value==1).if{
            syn1 = SynthDef("test1", { arg bus, bufnum;
                var z;
                z = In.ar(bus,2);
                // ScopeOut2 writes the audio to the buffer
                // IMPORTANT - ScopeOut2, not ScopeOut
                ScopeOut2.ar(z, bufnum);
                Out.ar(0,z);
            }).play(
                RootNode(s),
                [\bus,b.index, \bufnum, f.bufnum] ,
                \addToTail // make sure it goes after what you are scoping
            );

            // making noise onto the buffer
            syn2 = SynthDef("test2", { arg bus;
                var z;
                z = PMOsc.ar([300,250],*SinOsc.ar([0.027,0.017])*pi) * 0.1;
                Out.ar(bus, z);
            }).play(s,[\bus,b.index]);

        }{syn1.free; syn2.free};
    };

    // IMPORTANT
    c.start;

    w.onClose={syn1.free; syn2.free; b.free; f.free};
    CmdPeriod.doOnce({w.close});
})
)
::


class:: Score
summary:: score of timed OSC commands
related:: Guides/Non-Realtime-Synthesis
categories:: Control, Server>NRT, External Control>OSC

description::
Score encapsulates a list of timed OSC commands and provides some methods for using it, as well as support for the creation of binary OSC files for non-realtime synthesis. See link::Guides/Non-Realtime-Synthesis:: for more details.

The list should be in the following format, with times in ascending order. Bundles are okay.

code::
[
[beat1, [OSCcmd1]],
[beat2, [OSCcmd2], [OSCcmd3]],
...
[beat_n, [OSCcmdn]],
[beatToEndNRT, [\c_set, 0, 0]] // finish
]
::

For NRT synthesis the final event should a dummy event, after which synthesis will cease. It is thus important that this event be timed to allow previous events to complete.

Score scheduling defaults to link::Classes/TempoClock::. A setting of code::TempoClock.default.tempo = 1 :: (60 beats per minute), may be used to express score events in seconds if desired.

ClassMethods::

private::initClass

method::new
returns a new Score object with the supplied list.

argument::list
can be an link::Classes/Array::, a link::Classes/List::, or similar object.

method::newFromFile
as link::#*new::, but reads the list in from a text file.

argument::path
a link::Classes/String:: indicating the path of the file. The file must contain a valid SC expression.

method::play
as link::#*new:: but immediately plays it. (See also the instance method below.)

argument::list
the list.

argument::server
If no value is supplied it will play on the default link::Classes/Server::.

method::playFromFile
as link::#*play::, but reads the list from a file.

method::write
a convenience method to create a binary OSC file for NRT synthesis. Does not create an instance.

argument::list
the list.

argument::oscFilePath
a link::Classes/String:: containing the desired path of the OSC file.

argument::clock
Use clock as a tempo base. code::TempoClock.default:: is used if clock is nil.

method::writeFromFile
as link::#*write:: but reads the list from a file.

argument::path
a path to a file with a list.

argument::oscFilePath
a link::Classes/String:: containing the desired path of the OSC file.

argument::clock
Use clock as a tempo base. code::TempoClock.default:: is used if clock is nil.

method::recordNRT
a convenience method to synthesize strong::list:: in non-realtime. This method writes an OSC file to strong::oscFilePath:: (you have to do your own cleanup if desired) and then starts a server app to synthesize it. For details on valid headerFormats and sampleFormats see link::Classes/SoundFile::. Use code::TempoClock.default:: as a tempo base. Does not return an instance.

argument::list
the list.

argument::oscFilePath
the path to which the binary OSC file will be written.

argument::outputFilePath
the path of the resultant soundfile.

argument::inputFilePath
an optional path for an input soundfile.

argument::sampleRate
the sample rate at which synthesis will occur.

argument::headerFormat
the header format of the output file. The default is 'AIFF'.

argument::sampleFormat
the sample format of the output file. The default is 'int16'.

argument::options
an instance of link::Classes/ServerOptions::. If not supplied the options of the default link::Classes/Server:: will be used.

argument::completionString

argument::duration

argument::action
A function to be evaluated once the NRT server has finished rendering its score.

InstanceMethods::

method::play
play the list on strong::server::, use strong::clock:: as a tempo base and quantize start time to strong::quant::. If strong::server:: is nil, then on the default server. code::TempoClock.default:: if strong::clock:: is nil. now if strong::quant:: is 0.

method::stop
stop playing.

method::write
create a binary OSC file for NRT synthesis from the list. Use strong::clock:: as a tempo base. code::TempoClock.default:: if strong::clock:: is nil.

method::score
get or set the list.

method::add
adds bundle to the list.

method::sort
sort the score time order. This is recommended to do strong::before recordNRT or write:: when you are not sure about the packet order.

method::recordNRT
synthesize the score in non-realtime. For details of the arguments see link::#*recordNRT:: above.

method::saveToFile
save the score list as a text file to strong::path::.

Examples::

subsection::NRT Examples

code::
// A sample synthDef
// Here we use store instead of add to store the compiled synthdef in Platform.defaultTempDir +/+ "synthdefs/"
// and make it available to the NRT server
(
SynthDef("helpscore", { |out, freq = 440|
	Out.ar(out,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: Done.freeSelf)
	)
}).store;
)

// write a sample file for testing
(
var f, g;
TempoClock.default.tempo = 1;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660]],
	[0.3, [\s_new, \helpscore, 1002, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
f = File(Platform.defaultTempDir +/+ "score-test","w");
f.write(g.asCompileString);
f.close;
)

//convert it to a binary OSC file for use with NRT
Score.writeFromFile(Platform.defaultTempDir +/+ "score-test", Platform.defaultTempDir +/+ "test.osc");
::

From the command line, the file can then be rendered from within the build directory:

code::
scsynth -N test.osc _ test.aif 44100 AIFF int16 -o 1
::

Score also provides methods to do all this more directly:

code::
(
var f, o;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660],
		[\s_new, \helpscore, 1002, 0, 0, \freq, 880]],
	[0.3, [\s_new, \helpscore, 1003, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
o = ServerOptions.new.numOutputBusChannels = 1; // mono output
Score.recordNRT(g, Platform.defaultTempDir +/+ "help-oscFile", Platform.defaultTempDir +/+ "helpNRT.aiff", options: o); // synthesize
)
::

subsection::Real-time Examples

code::
s.boot; // boot the default server

// A sample synthDef
(
SynthDef("helpscore", { |out, freq = 440|
	Out.ar(out,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: Done.freeSelf)
	)
}).store;
)

// write a sample file for testing
(
var f, g;
TempoClock.default.tempo = 1;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660],
		[\s_new, \helpscore, 1002, 0, 0, \freq, 880]],
	[0.3, [\s_new, \helpscore, 1003, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
f = File(Platform.defaultTempDir +/+ "score-test","w");
f.write(g.asCompileString);
f.close;
)

z = Score.newFromFile(Platform.defaultTempDir +/+ "score-test");

// play it on the default server
z.play;

// change the list
(
x = [
[0.0, [ \s_new, \helpscore, 1000, 0, 0, \freq, 1413 ]],
[0.1, [ \s_new, \helpscore, 1001, 0, 0, \freq, 712 ]],
[0.2, [ \s_new, \helpscore, 1002, 0, 0, \freq, 417 ]],
[0.3, [ \s_new, \helpscore, 1003, 0, 0, \freq, 1238 ]],
[0.4, [ \s_new, \helpscore, 1004, 0, 0, \freq, 996 ]],
[0.5, [ \s_new, \helpscore, 1005, 0, 0, \freq, 1320 ]],
[0.6, [ \s_new, \helpscore, 1006, 0, 0, \freq, 864 ]],
[0.7, [ \s_new, \helpscore, 1007, 0, 0, \freq, 1033 ]],
[0.8, [ \s_new, \helpscore, 1008, 0, 0, \freq, 1693 ]],
[0.9, [ \s_new, \helpscore, 1009, 0, 0, \freq, 410 ]],
[1.0, [ \s_new, \helpscore, 1010, 0, 0, \freq, 1349 ]],
[1.1, [ \s_new, \helpscore, 1011, 0, 0, \freq, 1449 ]],
[1.2, [ \s_new, \helpscore, 1012, 0, 0, \freq, 1603 ]],
[1.3, [ \s_new, \helpscore, 1013, 0, 0, \freq, 333 ]],
[1.4, [ \s_new, \helpscore, 1014, 0, 0, \freq, 678 ]],
[1.5, [ \s_new, \helpscore, 1015, 0, 0, \freq, 503 ]],
[1.6, [ \s_new, \helpscore, 1016, 0, 0, \freq, 820 ]],
[1.7, [ \s_new, \helpscore, 1017, 0, 0, \freq, 1599 ]],
[1.8, [ \s_new, \helpscore, 1018, 0, 0, \freq, 968 ]],
[1.9, [ \s_new, \helpscore, 1019, 0, 0, \freq, 1347 ]],
[2.0, [\c_set, 0, 0]] // finish
];

z.score_(x);
)

// play it
z.play;

// play and stop after one second
(
z.play;
SystemClock.sched(1.0, {z.stop;});
)
::

subsection::creating Score from a pattern

code::
(
SynthDef("helpscore", { |out, freq = 440|
    Out.ar(out,
        SinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: Done.freeSelf)
    )
}).store;
)

// new pattern
(
p = Pbind(
    \instrument, \helpscore,
    \dur, Prand([0.3, 0.5], inf),
    \freq, Prand([200, 300, 500],inf)
);
)

// make a score from the pattern, 4 beats long
z = p.asScore(4.0);
z.score.postcs;
z.play;

// rendering a pattern to sound file directly:
// render the pattern to wav (4 beats)
p.render(Platform.defaultTempDir +/+ "asScore-Help.wav", 4.0);
::


class:: ScrollView
summary:: A container view that can scroll its contents
categories:: GUI>Views
related:: Classes/CompositeView

DESCRIPTION::

A container view which allows the user to scroll across contents when they exceed the view's bounds.

subsection:: The canvas

The view places the children onto a emphasis::canvas::, which may then be scrolled. The child views' position is always relative to the canvas, and thus not affected by scrolling.

The size of the canvas is always equal to the collective bounds of the children, and automatically adjusts when they are added, moved, resized and removed. If you wish to set it to a particular size, you could do so by first placing e.g. a link::Classes/CompositeView:: (or another container) of desired size, and then placing all the other views into that container.

Exceptionally though, you can strong::replace the canvas:: with any other view (e.g. simply with link::Classes/View::), which allows you to install a link::Classes/Layout##layout:: on it. In that case, the canvas will fill the whole visible area of the ScrollView, if the layout contents allow so, or a larger area, if the layout contents demand so. Effectively, the strong::contents will resize:: together with the ScrollView, unless their size constraints prevent that, and if link::#-autohidesScrollers:: is code::true::, a scrollbar will only be shown if the contents can not be resized small enough in the scrollbar's direction. See link::#-canvas:: for further explanation.

subsection:: Restrictions

note::
list::
## The link::Classes/View#-resize:: mode of the children is ignored.
## One should not use a decorator such as FlowLayout directly on a ScrollView, only on a container view placed within it.
::
::


CLASSMETHODS::
PRIVATE::key


INSTANCEMETHODS::


SUBSECTION:: Geometry

METHOD:: canvas

Returns the current canvas that carries the child views, or replaces it with another.

By default, the canvas is a subclass of QObject, and hence does not allow the type of manipulations that views do. However, it can only be replaced with a subclass of View, which greatly extends the possibilities, including the use of layouts on the canvas.

The new canvas will always resize with the ScrollView, as far its size constraints allow. A plain link::Classes/View:: which completely disregards its children will be freely resizable, and hence the scrolling will never be possible, since the scrollbars are activated according to the size of the canvas. To prevent this, you can either place explicit size constraints on it using link::Classes/View#-minSize:: and similar, or you can install a layout on it, which will forward to it the size constraints of the children.

See the link::#examples#example:: below.

Once the canvas is replaced, new views constructed with the ScrollView as the parent will end up as children of the canvas view, equivalent to constructing them with the canvas as the parent, or inserting them into the layout installed on the canvas.

warning:: Replacing the canvas will remove and destroy all the views placed on the previous one! ::

METHOD:: innerBounds

Returns either the rectangle corresponding to the size of the canvas, or the visible area of the ScrollView's background, whichever is larger. The position of the rectangle is always 0@0.

See the link::#description#discussion:: above regarding the size of the canvas.

Returns:: A Rect.

METHOD:: visibleOrigin

Gets the position on the canvas corresponding to its upper-left-most visible point, or moves the canvas so as to leave the given point on it at the top-left corner of the visible bounds, if possible.

Argument::
A Point.


SUBSECTION:: Behavior

METHOD:: autohidesScrollers

Sets or gets whether the view hides one or another scrollbar if the contents do not exceed the view's bounds in the scrollbar's direction.

If link::#-hasHorizontalScroller:: or link::#-hasVerticalScroller:: is set to code::false::, the respective scrollbar will always be hidden, regardless of this policy.

Defaults to strong::true::.

METHOD:: hasHorizontalScroller

Sets or gets whether the view has the horizontal scrollbar. If this is code::true::, the scrollbar may still be hidden if link::#-autohidesScrollers:: allows so; however, if this is code::false:: the scrollbar will never be shown.

Defaults to strong::true::.

METHOD:: hasVerticalScroller

Sets or gets whether the view has the vertical scrollbar. If this is code::true::, the scrollbar may still be hidden if link::#-autohidesScrollers:: allows so; however, if this it code::false:: the scrollbar will never be shown.

Defaults to strong::true::.

SUBSECTION:: Appearance

METHOD:: hasBorder

Sets or gets whether the view draws its border.

Defaults to strong::true::.

SUBSECTION:: Actions

METHOD:: action

Sets or gets the object to be evaluated when the user moves the scrollbars, or when link::#-visibleOrigin:: is set.

EXAMPLES::

SUBSECTION:: Layout management on the canvas


By replacing the canvas of the ScrollView with a View, and installing a layout on it, the contents will expand to the edge of the ScrollView, and only exceed the edge if necessary.

code::
(
var scroll = ScrollView(bounds:Rect(0,0,300,300).center_(Window.availableBounds.center));
var canvas = View();
var layout;
var i = 0;

var makeEntry = {
	var view = View().background_(Color.rand).layout_(
		HLayout(
			TextField().string_( ("This is entry number " + i.asString) ),
			Button().states_([["Delete"]]).action_({view.remove; i = i - 1;})
		)
	);
	i = i + 1;
	view;
};

layout = VLayout();
layout.add ( View().background_(Color.black).layout_(
	HLayout(
		Button().states_([["Add"]]).action_({ layout.insert(makeEntry.(), i) }),
		nil // stretch remaining empty space
	)
));

canvas.layout = layout;
10.do { canvas.layout.add( makeEntry.() ) };
canvas.layout.add(nil); // stretch remaining empty space

scroll.canvas = canvas;
scroll.front;
)
::

SUBSECTION:: Force a canvas size

code::
(
w = Window.new;

b = ScrollView(w, Rect(0, 0, 300, 300)).hasBorder_(true);
c = CompositeView(b, Rect(0, 0, 500, 500)); // 'canvas' is this big
c.decorator = FlowLayout(c.bounds); // now we can use a decorator

Slider2D(c, Rect(0, 0, 240, 240));
Slider2D(c, Rect(0, 0, 240, 240));
Slider2D(c, Rect(0, 0, 240, 240));

c.decorator.nextLine;
w.front;
)
::

SUBSECTION:: "Rulers", using an action function

code::
(
var drawFunc;
w = Window.new;

a = ScrollView(w, Rect(40, 40, 300, 300));
b = ScrollView(w, Rect(0, 40, 40, 300)).hasHorizontalScroller_(false).hasVerticalScroller_(false);
c = ScrollView(w, Rect(40, 0, 300, 40)).hasHorizontalScroller_(false).hasVerticalScroller_(false);
b.background = Color.grey;
c.background = Color.grey;

d = UserView(a, Rect(0, 0, 620, 620));
e = UserView(b, Rect(0, 0, 40, 630));
f = UserView(c, Rect(0, 0, 630, 40));

a.action = { var origin;
	origin = a.visibleOrigin;
	b.visibleOrigin = 0@(origin.y);
	c.visibleOrigin = (origin.x)@0;
};

drawFunc = {
	30.do({arg i;
		(i+1).asString.drawAtPoint((i+1 * 20)@0, Font("Courier", 9), Color.black);
	});
};

d.drawFunc = {
	Pen.use({
		Pen.translate(0, 5);
		drawFunc.value;
	});
	Pen.translate(15, 0).rotate(0.5pi);
	drawFunc.value;
};

e.drawFunc = {
	Pen.translate(40, 0).rotate(0.5pi);
	drawFunc.value;
};

f.drawFunc = {
	Pen.translate(0, 25);
	drawFunc.value;
};

w.front;
)
::
Note:: Apparently a method 'autoScrolls' was planned but not implemented yet; its doc said that it sets or gets whether the view scrolls automatically when you drag on a child view past the edge of visible bounds.
::


class:: Select
summary:: Select output from an array of inputs.
categories:: UGens>Multichannel>Select
related:: Classes/SelectX, Classes/SelectXFocus, Classes/LinSelectX

Description::
The output is selected from an array of inputs.

note:: All the UGens are continuously running. This may not be the most efficient
way if each input is CPU-expensive. ::

Note that the array is fixed at the time of writing the SynthDef, and the
whole array is embedded in the SynthDef file itself.  For small arrays
this is more efficient than reading from a buffer.


classmethods::

method::ar, kr

argument::which

Integer index


argument::array

Input array of signals


Examples::

code::
(
SynthDef("help-Select",{ arg out=0;

	var a,cycle;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	cycle = a.size  * 0.5;
	Out.ar(out,
		Select.ar(LFSaw.kr(1.0,0.0,cycle,cycle),a) * 0.2
	)
}).play;

)

//Here used as a sequencer:
(
SynthDef("help-Select-2",{ arg out=0;

	var a,s,cycle;
	a = Array.fill(32,{ rrand(30,80) }).midicps;
	a.postln;
	cycle = a.size  * 0.5;

	s = Saw.ar(
			Select.kr(
				LFSaw.kr(1.0,0.0,cycle,cycle),
				a
			),
			0.2
	);
	Out.ar(out,s )
}).play;
)

::



class:: SelectX
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectXFocus, Classes/LinSelectX

description::
The output is mixed from an array of inputs, performing an equal power crossfade between two adjacent channels.

classmethods::
method:: ar, kr

argument:: which
argument:: array
argument:: wrap
wrap does not work yet.

examples::
code::
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar(300),
			Pulse.ar(230)
		];

	SelectX.ar(MouseX.kr(0, 1) * a.size, a) * 0.2
}.play;
)

(
{
	var a;
	a = [
			SinOsc.kr(0.25),
			LFSaw.kr(10),
			LFPulse.kr(0.3)
		];

	SinOsc.ar(SelectX.kr(MouseX.kr(0, 1) * a.size, a) * 300 + 400) * 0.2
}.play;
)
::

note::
all the ugens are continuously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

wrap does not work yet.

(by adc)


class:: SelectXFocus
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectX, Classes/LinSelectX

description::
The output is mixed from an array of inputs, linearly interpolating from a number of adjacent channels. A focus argument allows to control how many adjacent sources are mixed.

classmethods::
method:: ar, kr

argument:: which
Index of the selected input, which is also the center of the selection for a focus > 0.
argument:: array
A collection of inputs.
argument:: focus
The "fuzziness" of the selection: the larger the focus, the less adjacent inputs are mixed in.
argument:: wrap
If set to true, index will wrap around the array of inputs (see also: link::Classes/Array#-wrapAt::).

code::
(
{
	var array = { Saw.ar(rrand(1.0, 3.0)) * Saw.ar(rrand(100.0, 3000.0)) } ! 8;
	SelectXFocus.ar(MouseX.kr(-20, 20), array, 0.3, true) * 0.1
}.play
)
::


examples::
code::
(
{
	var a;
	a = [
			Saw.ar(LFSaw.kr(3 * [1, 1.01], 0, 100, 230)),
			SinOsc.ar,
			Pulse.ar(LFPulse.kr(3 * [1, 1.02], 0, 0.4, 100, 230)),
			SinOsc.ar(SinOsc.kr(4 * [1, 1.03], 0, 200, 300))
		];

	SelectXFocus.ar(MouseX.kr(0, 1) * a.size, a, MouseY.kr(0, a.size)) * 0.2
}.play;
)
::

note::
all the ugens are continuously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

code::
// radio tuner
// (jrh) (cc 2006)
(
{
	var a, n, mx, my, mwrap;
	n = 8;
	mx = MouseX.kr(0, 1, 0, 0.1);
	my = MouseY.kr;
	mwrap = { |pmin, pmax, min, max| sin(mx * ExpRand(pmin, pmax)) + 1 * 0.5 * ExpRand(min, max) };
	a = {
		var freq, fmul, phase;
		freq = mwrap.(10, 40, 200, 5000) + ExpRand(200, 3000);
		fmul = LFNoise0.kr(ExpRand(0.1, 8)).round(1/6).exprange(1, Rand(1, 1.2));
		phase = LFNoise2.ar(mwrap.(1, 20, 10, 1000), Rand(2, 5));
		SinOsc.ar(freq * fmul, phase)
	} ! n;
	a = a.add(
		SinOsc.ar(LFDNoise0.kr(11, SetResetFF.kr(*Dust.kr([1, 2] * 0.3))).range(0, 700) + 220)
	);
	SelectXFocus.ar(mx * n, a, my * n) * 0.2 + OnePole.ar(PinkNoise.ar(0.5 ! 2), 0.4)
	* Line.kr(0, 1, 3);
}.play;
)


// jimmy played harmonica in the pub where I was born
// (hh) (jrh) (cc 2006)
(
{
	var blas, zieh, mx, my, trig, which, amp, u, schnauf;
	var del = 9, det = 0.1;
	schnauf = 0.3;
	mx = MouseX.kr;
	my = MouseY.kr(0.1, 2, 1);

	blas = [0, 12, 24] +.x [60, 64, 67] ++ [60+36];
	zieh = [62, 67, 71,   74, 77, 81, 83,   86, 89, 93];

	trig = Dust.kr(1);
	which = ToggleFF.kr(TDelay.kr(trig, schnauf));
	amp = EnvGen.kr(Env([1, 0, 1], [schnauf, schnauf]), trig);
	blas = Select.kr(which, [blas, zieh]);
	u = SelectXFocus.ar(
		mx * blas.size,
		blas.collect {|f|
			Pulse.ar((Rand(-0.04, 0.09) + f).midicps * 0.5, 0.48 + LFNoise1.kr(0.06, 0.1), 0.2)
		},
		my
	) * Slope.kr(mx + my).abs.lag2(2) * amp;
	u = Pan2.ar(OnePole.ar(u, -0.3), mx * 2 - 1);
	DelayL.ar(BPF.ar(u * 2, 1500, 0.3), del + det, LFNoise2.kr(0.2, det, del)) + u
}.play;
);
::


CLASS::Semaphore
categories::Scheduling
summary::control parallel execution of threads

CLASSMETHODS::

method::new
Create a new instance, set the maximum number of running threads (default: 1).

INSTANCEMETHODS::

method::count
Determines the number of running threads.

method::clear
Remove any reference to threads, but do not reschedule any pending ones.

method::wait
Stop current thread if already too many are running, otherwise continue.

method::signal
Unblock the semaphore, reschedule next pending thread.

EXAMPLES::

code::
// allow only one thread
(
c = Semaphore(1);
fork {
	c.wait;
	"thread 1> now I am doing something for 10 seconds. Block the semaphore meanwhile.".postln;
	10.wait;
	c.signal;
	"thread 1> ok, done. Release the semaphore.".postln;
};
fork {
	3.0.rand.wait;
	"thread 2> I would like to go on, if I may.".postln;
	c.wait; // may I?
	"thread 2> this took until the other thread has released the semaphore. "
		"Blocking for 4 seconds.".postln;
	4.wait;
	"thread 2> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	4.wait;
	"thread 3> I, too, would like to go on, if I may.".postln;
	c.wait; // may I?
	"thread 3> this took until both other threads had released the semaphore.".postln;
	c.signal;
};
)
::

code::
// allow two threads at a time.
(
c = Semaphore(2);
fork {
	c.wait;
	"thread 1> now I am doing something for 20 seconds. Block the semaphore.".postln;
	10.wait;
	"thread 1> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	rrand(3.0, 5.0).wait;
	"thread 2> I would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 3> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 1> ok, going ahead.".postln;
	17.wait;
	"thread 2> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	6.wait;
	"thread 3> I, too, would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 3> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 3> ok, this took until the first thread had released the semaphore. "
		"Ok, doing something for 4 seconds. Block the semaphore".postln;
		4.wait;
	"Releasing the semaphore.".postln;
	c.signal;
};
fork {
	7.wait;
	"thread 4> Me, the fourth one, would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 4> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 4> ok, this took until the third thread had released the semaphore. "
		"Ok, doing something for 3 seconds. Block the semaphore".postln;
		3.wait;
	"Releasing the semaphore.".postln;
	c.signal;
};
)
::

code::
// grant exclusive access to data to only one thread
// there should never be mixed values in the data array
(
var data, useAndModify;

data = [1, 2, 3];
c = Semaphore(1);
// c = Semaphore(2); use this to test how it would behave without exclusive access.
useAndModify = { |newData, who|
	postln(who + "trying to get blocking access.");
	if(c.count <= 0) { who + "ok, then I wait ...".postln };
	c.wait; // may I access? if not, I wait. if yes, disallow others.
	"\n".post;
	(who + "continuing...").postln;
	data.do({ |x|
			0.1.wait;
			postln(who + x);
		});
	"\n".post;
	newData.do { |x, i| data[i] = x };
	postln(who + "rewriting data to:" + newData);
	postln(who + "releasing");
	c.signal; // allow others access again
};

// e.g. set the values to integers
u = Routine {
	inf.do { |i|
		useAndModify.value([100, 200, 300], "thread 1>");
		rrand(1, 3).wait;
	}
};

// e.g. set the values to floats
k =  Routine {
	0.5.wait;
	inf.do { |i|
		useAndModify.value([pi, 0.5pi, 2pi], "thread 2>");
		rrand(1, 5).wait;
	}
};
u.play;
k.play;
);
::


class:: SemiColonFileReader
summary:: file reader for semi-colon separated data
related:: Classes/File
categories:: Files

description::
SemiColonFileReader reads semi-colon delimited files into 2D arrays.

For tab delimited files use link::Classes/TabFileReader::. For comma-separated files use link::Classes/CSVFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
(
// write a test file:
f = File("SemiColonTest.sc", "w");
f.write(
"Some semi-colon delimited data;

123;;4;
0.5;0.6;0.7
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = SemiColonFileReader.read("SemiColonTest.sc").postcs;

	// can skip empty lines:
x = SemiColonFileReader.read("SemiColonTest.sc", true).postcs;

	// can skip blank entries caused by multiple commas:
x = SemiColonFileReader.read("SemiColonTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("SemiColonTest.sc", "r"); f.isOpen;
t = SemiColonFileReader(f);
t.read;
f.close;

(
// write a test file with numbers:
f = File("SemiColonTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ ";"); };
f.close;
)

x = SemiColonFileReader.read("SemiColonTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or you can do it immediately:
x = SemiColonFileReader.readInterpret("SemiColonTestNum.sc").postcs;

(
// write a test file with numbers:
f = File("SemiColonTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, $;, Char.nl)); };
f.close;
)


x = SemiColonFileReader.readInterpret("SemiColonTestNum.sc").postln;
::


CLASS:: SendPeakRMS
summary:: Track peak and power of a signal for GUI applications.
related:: Classes/Peak, Classes/PeakFollower, Classes/OSCFunc
categories::  UGens>Analysis>Amplitude


DESCRIPTION::

The SendPeakRMS unit generator computes peak and power of a signal and sends the
computed values back to the clients. It does not produce any output.


CLASSMETHODS::

private:: new1


method::ar, kr

Unlike with other unit generators, the code::ar:: and code::kr:: methods do not
specify the rate of the computation, but the granularity. When the SendPeakRMS ugen
is instantiated with code::kr::, the reply rate is quantized to control-rate
blocks.

argument::sig

The input signal.

argument::replyRate

Float or Integer. Specifies the number of replies that are sent to the clients
per second.

argument::peakLag

Float or Integer. Lag time, which is applied to the peak values. This option is
commonly used for GUI VU meters.

argument::cmdName

Symbol or String. Address pattern for reply message.

argument::replyID

Integer ID (similar to link::Classes/SendTrig::).

INSTANCEMETHODS::
private:: numOutputs, writeOutputSpecs


EXAMPLES::

code::
(
{
	SendPeakRMS.kr(Dust.ar(20), 20, 3, "/replyAddress")
}.play;
)

(
o = OSCFunc({ |msg|
	"peak: %, rms: %".format(msg[3], msg[4]).postln
}, '/replyAddress');
)
o.free;
::



class:: SendReply
summary:: Send an array of values from the server to all notified clients
categories:: UGens>Triggers
related:: Classes/SendTrig, Classes/OSCFunc

description::
A message is sent to all notified clients. See link::Classes/Server::.

list::
## strong::cmdName::
	list::
	## int - node ID
	## int - reply ID
	## ... floats - values.
	::
::

classmethods::
method:: ar, kr

argument:: trig
a non-positive to positive transition triggers a message.
argument:: cmdName
a string or symbol, as a message name.
argument:: values
array of ugens, or valid ugen inputs.
argument:: replyID
integer id (similar to link::Classes/SendTrig::).

examples::
code::
(
{
	SendReply.kr(Impulse.kr(3), '/the_answer', [40, 41, 42, 43] + MouseX.kr, 1905);
}.play(s);
)

o = OSCFunc({ |msg| msg.postln }, '/the_answer');


// multichannel expansion
(
{
	SendReply.kr(Impulse.kr(3),
		'/the_answer',
		values: [[40, 80], [41, 56], 42, [43, 100, 200]],
		replyID: [1905, 1906, 1907, 1908]
	);
}.play(s);
)

o.free;

// Sending audio parameters over a network via OSC
// Since SendReply can only respond to the host, this shows how
// to send data to a separate target through sclang.
(
SynthDef(\amplitudeAnalysis, {|in=0, rate=60|
	var input = SoundIn.ar(in);
	var amp = Amplitude.kr(input);
	var freq = Pitch.kr(input);
	var trig = Impulse.kr(rate);
	SendReply.kr(trig, '/analysis', [amp, freq[0], freq[1]]);
}).add;
)

// example target address - insert your target host & port here
~testNetAddr = NetAddr("127.0.0.1", 5000);
~mySynth = Synth(\amplitudeAnalysis);

(
OSCdef(\listener, {|msg|
	var data = msg[3..];
	data.postln;
	~testNetAddr.sendMsg("data", data);
}, '/analysis');
)

~mySynth.set(\rate, 10); // slow it down...
::

subsection::Identitying the time a message was sent

Sometimes, we need to know when a message was sent. Because code::SendReply:: can send only messages (which have no timestamp) and no bundles (which have), we can't use the code::time:: argument of the link::Classes/OSCdef::'s function. Instead, you can send a time stamp with the data, by using the link::Classes/Sweep:: UGen.

code::
(
{ SendReply.ar(Impulse.ar(4), "/reply", [Sweep.ar, SinOsc.ar(0.3)]); 0 }.play;
OSCdef(\x, { |msg|
	var time, value;
	time = msg[3];
	value = msg[4];
	"value % occurred at time %".format(value, time).postln;
}, "/reply");
)
::











class:: SendTrig
summary:: Send a trigger message from the server back to the client.
categories::  UGens>Triggers
related:: Classes/OSCFunc, Classes/SendReply


Description::

On receiving a trigger (a non-positive to positive transition), send a
trigger message from the server back to the client.


The trigger message sent back to the client is this:

table::

## /tr || A trigger message.

## int: || Node ID.

## int: || Trigger ID.

## float: || Trigger value.

::


This command is the mechanism that synths can use to trigger events in
clients. The node ID is the node that is sending the trigger. The trigger
ID and value are determined by inputs to the SendTrig unit generator
which is the originator of this message.


classmethods::

method::ar, kr

argument::in

The trigger.


argument::id

An integer that will be passed with the trigger message. This is
useful if you have more than one SendTrig in a SynthDef.


argument::value

A UGen or float that will be polled at the time of trigger, and
its value passed with the trigger message.


Examples::

code::

s.boot;

(
SynthDef("help-SendTrig",{
	SendTrig.kr(Dust.kr(1.0),0,0.9);
}).add;

// register to receive this message
o = OSCFunc({ arg msg, time;
	[time, msg].postln;
},'/tr', s.addr);
)

Synth("help-SendTrig");

o.free;
::


CLASS::SequenceableCollection
summary::Abstract superclass of integer indexable collections
categories::Collections>Ordered

DESCRIPTION::
SequenceableCollection is a subclass of Collection whose elements can be indexed by an Integer. It has many useful subclasses; link::Classes/Array:: and link::Classes/List:: are amongst the most commonly used.

CLASSMETHODS::

copymethod:: Collection *fill

method::series
Fill a SequenceableCollection with an arithmetic series.
code::
Array.series(5, 10, 2);
::

method::geom
Fill a SequenceableCollection with a geometric series.
code::
Array.geom(5, 1, 3);
::

method::fib
Fill a SequenceableCollection with a fibonacci series.
code::
Array.fib(5);
Array.fib(5, 2, 32); // start from 32 with step 2.
::
argument::size
the number of values in the collection
argument::a
the starting step value
argument::b
the starting value

method::rand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal::.
code::
Array.rand(8, 1, 100);
::

method::rand2
Fill a SequenceableCollection with random values in the range -strong::val:: to +strong::val::.
code::
Array.rand2(8, 100);
::

method::linrand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal:: with a linear distribution.
code::
Array.linrand(8, 1, 100);
::

method::exprand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal:: with exponential distribution.
code::
Array.exprand(8, 1, 100);
::

method::interpolation
Fill a SequenceableCollection with the interpolated values between the strong::start:: and strong::end:: values.
code::
Array.interpolation(5, 3.2, 20.5);
::



INSTANCEMETHODS::


method::|@|
synonym for link::Classes/ArrayedCollection#-clipAt::.
code::
[3, 4, 5]|@|6;
::

method::@@
synonym for link::Classes/ArrayedCollection#-wrapAt::.
code::
[3, 4, 5]@@6;
[3, 4, 5]@@ -1;
[3, 4, 5]@@[6, 8]
::

method::@|@
synonym for link::Classes/ArrayedCollection#-foldAt::.
code::
[3, 4, 5]@|@[6, 8];
::

method::first
Return the first element of the collection.
code::
[3, 4, 5].first;
::

method::last
Return the last element of the collection.
code::
[3, 4, 5].last;
::

method::putFirst, putLast
Place strong::item:: at the first / last index in the collection. Note that if the collection is empty (and therefore has no indexed slots) the item will not be added.
code::
[3, 4, 5].putFirst(100);
[3, 4, 5].putLast(100);
::

method::indexOf
Return the index of an strong::item:: in the collection, or nil if not found. Elements are checked for identity (not for equality).
code::
[3, 4, 100, 5].indexOf(100);
[3, 4, \foo, \bar].indexOf(\foo);
::

method::indexOfEqual
Return the index of something in the collection that equals the strong::item::, or nil if not found.
code::
[3, 4, "foo", "bar"].indexOfEqual("foo");
::

method::indicesOfEqual
Return an array of indices of things in the collection that equal the strong::item::, or nil if not found.
code::
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.indicesOfEqual(7);
y.indicesOfEqual(5);
::

method::indexOfGreaterThan
Return the first index containing an strong::item:: which is greater than strong::item::.
code::
y = List[ 10, 5, 77, 55, 12, 123];
y.indexOfGreaterThan(70);
::

method::selectIndices
Return a new collection of same type as receiver which consists of all indices of those elements of the receiver for which function answers code::true::. The function is passed two arguments, the item and an integer index.

code::
#[a, b, c, g, h, h, j, h].selectIndices({|item, i| item === \h})
::

If you want to control what type of collection is returned, use link::#-selectIndicesAs::

method::selectIndicesAs
Return a new collection of type emphasis::class:: which consists of all indices of those elements of the receiver for which function answers code::true::. The function is passed two arguments, the item and an integer index.

code::
#[a, b, c, g, h, h, j, h].selectIndicesAs({|item, i| item === \h}, Set)
::


method::rejectIndices
Return a new collection of same type as receiver which consists of all indices of those elements of the receiver for which function answers code::false::. The function is passed two arguments, the item and an integer index.

code::
#[a, b, c, g, h, h, j, h].rejectIndices({|item, i| item === \h})
::

If you want to control what type of collection is returned, use link::#-rejectIndicesAs::

method::rejectIndicesAs
Return a new collection of type emphasis::class:: which consists of all indices of those elements of the receiver for which function answers code::false::. The function is passed two arguments, the item and an integer index.

code::
#[a, b, c, g, h, h, j, h].rejectIndicesAs({|item, i| item === \h}, Set)
::

copymethod:: Collection -maxIndex

copymethod:: Collection -minIndex


method::find
If the strong::sublist:: exists in the receiver (in the specified order), at an offset greater than or equal to the initial strong::offset::, then return the starting index.  The sublist must be of the same kind (class) as the list to search in.
Elements are checked for equality (not for identity).
code::
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.find([7, 6, 5]);
::

method::findAll
Similar to link::#-find:: but returns an array of all the indices at which the sequence is found.
code::
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.findAll([7, 6]);
::

method::indexIn
Returns the closest index of the value in the collection (collection must be sorted).
code::
[2, 3, 5, 6].indexIn(5.2);
::

method::indexInBetween
Returns a linearly interpolated float index for the value (collection must be sorted). Inverse operation is link::#-blendAt::.
code::
x = [2, 3, 5, 6].indexInBetween(5.2);
[2, 3, 5, 6].blendAt(x);
::

method::blendAt
Returns a linearly interpolated value between the two closest indices. Inverse operation is link::#-indexInBetween::.
code::
x = [2, 5, 6].blendAt(0.4);
::

method::copyRange
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from strong::start:: to strong::end::. If strong::end:: < strong::start::, an empty collection is returned.
code::
(
var y, z;
z = [1, 2, 3, 4, 5];
y = z.copyRange(1, 3);
z.postln;
y.postln;
)
::
warning:: code::x.copyRange(a, b):: is strong::not:: equivalent to code::x[a..b]::. The latter compiles to link::Classes/ArrayedCollection#-copySeries::, which has different behavior when strong::end:: < strong::start::. ::

method::copyToEnd
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from strong::start:: to the end of the collection.
code::x.copyToEnd(a):: can also be written as code::x[a..]::

method::copyFromStart
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from the start of the collection to strong::end::.
code::x.copyFromStart(a):: can also be written as code::x[..a]::

method::remove
Remove strong::item:: from collection. Elements are checked for identity (not for equality).

method::take
Remove and return strong::item:: from collection. The last item in the collection will move to occupy the vacated slot (and the collection size decreases by one). See also takeAt, defined for link::Classes/ArrayedCollection#-takeAt::. Elements are checked for identity (not for equality).
warning:: code::take(item):: works on Arrays but not on Lists, because the internally called method code::takeAt(item):: is not defined for Lists. ::
code::
a = [11, 12, 13, 14, 15];
a.take(12);
a;
::

method::obtain
Retrieve an element from a given index (like link::Classes/SequenceableCollection#-at::). This method is also implemented in link::Classes/Object::, so that you can use it in situations where you don't want to know if the receiver is a collection or not. See also: link::Classes/SequenceableCollection#-instill::

argument::index
The index at which to look for an element

argument::default
If index exceeds collection size, or receiver is nil, return this instead

code::
(
a = [10, 20, 30];
b = [10, 20];
c = 7;
);

 // obtain third element, if outside bounds return 1
a.obtain(2, 1);
b.obtain(2, 1);
c.obtain(2, 1);
::

method::instill
Put an element at a given index (like link::Classes/SequenceableCollection#-put::). This method is also implemented in link::Classes/Object::, so that you can use it in situations where you don't want to know if the receiver is a collection or not. It will always return a new collection. See also: link::Classes/SequenceableCollection#-obtain::

argument::index
The index at which to put the item

argument::item
The object to put into the new collection

argument::default
If the index exceeds the current collection's size, extend the collection with this element

code::
(
a = [10, 20, 30, 40];
b = [10, 20];
c = 7;
);

a.instill(2, -1);
b.instill(2, -1);
c.instill(2, -1);
// providing a default value
c.instill(2, -1, 0);
::

method::keep
Keep the first strong::n:: items of the array. If strong::n:: is negative, keep the last -strong::n:: items.
code::
a = [1, 2, 3, 4, 5];
a.keep(3);
a.keep(-3);
::

method::drop
Drop the first strong::n:: items of the array. If strong::n:: is negative, drop the last -strong::n:: items.
code::
a = [1, 2, 3, 4, 5];
a.drop(3);
a.drop(-3);
::

method::join
Returns a link::Classes/String:: formed by connecting all the elements of the receiver, with strong::joiner:: inbetween. See also link::Classes/String#-split:: as the complementary operation.
code::
["m", "ss", "ss", "pp", ""].join("i").postcs;
"mississippi".split("i").postcs;
::

method::flat
Returns a collection from which all nesting has been flattened.
code::
[[1, 2, 3], [[4, 5], [[6]]]].flat; // [ 1, 2, 3, 4, 5, 6 ]
[1, 2, [3, 4, [5, 6, [7, 8, [9, 0]]]]].flat; // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]
::

method::flatten
Returns a collection from which strong::numLevels:: of nesting has been flattened.

argument::numLevels
Specifies how many levels downward (inward) to flatten. Zero returns the original.

code::
a = [1, 2, [3, 4, [5, 6, [7, 8, [9, 0]]]]];
a.flatten(1); // [ 1, 2, [ 3, 4, [ 5, 6, [ 7, 8, [ 9, 0 ] ] ] ] ]
a.flatten(2); // [ 1, 2, 3, 4, 5, 6, [ 7, 8, [ 9, 0 ] ] ]
a.flatten(3); // [ 1, 2, 3, 4, 5, 6, 7, 8, [ 9, 0 ] ]
a.flatten(4); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]
::


method::flatten2
A symmetric version of link::#-flatten::. For a negative code::numLevels::, it flattens starting from the innermost arrays.

argument::numLevels
Specifies how many levels downward (inward) or upward (outward) to flatten.

code::
a = [1, 2, [3, 4, [5, 6, [7, 8, [9, 0]]]]];
a.flatten2(4);  // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]
a.flatten2(3);  // [ 1, 2, 3, 4, 5, 6, 7, 8, [ 9, 0 ] ]
a.flatten2(2);  // [ 1, 2, 3, 4, 5, 6, [ 7, 8, [ 9, 0 ] ] ]
a.flatten2(1);  // [ 1, 2, 3, 4, [ 5, 6, [ 7, 8, [ 9, 0 ] ] ] ]
a.flatten2(0);  // [ 1, 2, [ 3, 4, [ 5, 6, [ 7, 8, [ 9, 0 ] ] ] ] ]
a.flatten2(-1); // [ 1, 2, [ 3, 4, [ 5, 6, [ 7, 8, 9, 0 ] ] ] ]
a.flatten2(-2); // [ 1, 2, [ 3, 4, [ 5, 6, 7, 8, 9, 0 ] ] ]
a.flatten2(-3); // [ 1, 2, [ 3, 4, 5, 6, 7, 8, 9, 0 ] ]
a.flatten2(-4); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]
::



method::flatBelow
Flatten all subarrays deeper than strong::level::.

argument::level
Specifies from what level onward to flatten.
level 0 is outermost, so flatBelow(0) is like flat.

code::
a = [1, 2, [3, 4, [5, 6, [7, 8, [9, 0]]]]];
a.flatBelow(0); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]
a.flatBelow(1); // [ 1, 2, [ 3, 4, 5, 6, 7, 8, 9, 0 ] ]
a.flatBelow(2); // [ 1, 2, [ 3, 4, [ 5, 6, 7, 8, 9, 0 ] ] ]

// to set the level below which to flatten from the deepest level up,
// one can use coll.maxDepth. E.g. to flatten only the innermost level:
a.flatBelow( (a.maxDepth - 1) - 1);
// for lowest two levels:
a.flatBelow( (a.maxDepth - 1) - 2);
::



method::flop
Invert rows and columns in a two dimensional Collection (turn inside out). See also: link::Classes/Function::.
code::
[[1, 2, 3], [4, 5, 6]].flop;
[[1, 2, 3], [4, 5, 6], [7, 8]].flop; // shorter array wraps
[].flop; // result is always 2-d.
::
Note that the innermost arrays are not copied:
code::
a = [1, 2];
x = [[[a, 5], [a, 10]], [[a, 50, 60]]].flop;
a[0] = pi;
x // pi is everywhere
::


method::flopWith
Flop with a user defined function. Can be used to collect over several collections in parallel.
code::
[[1, 2, 3], [4, 5, 6]].flopWith(_+_);
[[1, 2, 3], 1, [7, 8]].flopWith{ |a,b,c| a+b+c }; // shorter array wraps

// typical use case (pseudocode)
[synths, buffers].flopWith{ |a,b| a.set(\buf, b) }
::
argument::func
A function taking as many arguments as elements in the array.

method::flopTogether
Invert rows and columns in a an array of dimensional Collections (turn inside out), so that they all match up in size, but remain separated.
code::
(
a = flopTogether(
	[[1, 2, 3], [4, 5, 6, 7, 8]] * 100,
	[[1, 2, 3], [4, 5, 6], [7, 8]],
	[1000]
)
);

a.collect(_.size); // sizes are the same
a.collect(_.shape) // shapes can be different
::


method::flopDeep
Fold dimensions in a multi-dimensional Collection (turn inside out).

argument::rank
The depth (dimension) from which the array is inverted inside-out.

code::
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(2);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(1);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(0);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep; // without argument, flop from the deepest level

[[[10, 100, 1000], 2, 3], [[41, 52], 5, 6]].flopDeep(2); // shorter array wraps
[].flopDeep(1); // result is always one dimension higher.
[[]].flopDeep(4);
::

note::Note that, just like in flop, the innermost arrays (deeper than rank) are not copied.::

code::
a = [1, 2];
x = [[[a, 5], [a, 10]], [[a, 50, 60]]].flopDeep(1);
a[0] = pi;
x // pi is everywhere
::

method::maxSizeAtDepth
Returns the maximum size of all subarrays at a certain depth (dimension)

argument::rank
The depth at which the size of the arrays is measured

code::
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(2);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(1);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(0);
[].maxSizeAtDepth(0);
[[]].maxSizeAtDepth(0);
[[]].maxSizeAtDepth(1);
::

method::maxDepth
Returns the maximum depth of all subarrays.

argument::max
Internally used only.

code::
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxDepth
::

method::isSeries
Returns true if the collection is an arithmetic series.

argument::step
Step size to look for. If none is given, any step size will match.

code::
[ 0, 1, 2, 3, 4, 5 ].isSeries; // true
[ 1.5, 2.5, 3.5, 4.5, 5.5, 6.5 ].isSeries; // true
[ 0, 1, 4, 5 ].isSeries; // false
[ 0, 3, 6, 9, 12, 15 ].isSeries; // true
[ 0, 3, 6, 9, 12, 15 ].isSeries(1); // false
[ 2 ] // true
[ ] // true (empty sequence)
::

method::resamp0
Returns a new Collection of the desired length, with values resampled evenly-spaced from the receiver without interpolation.
code::
[1, 2, 3, 4].resamp0(12);
[1, 2, 3, 4].resamp0(2);
::

method::resamp1
Returns a new Collection of the desired length, with values resampled evenly-spaced from the receiver with linear interpolation.
code::
[1, 2, 3, 4].resamp1(12);
[1, 2, 3, 4].resamp1(3);
::

method::choose
Choose an element from the collection at random.
code::
[1, 2, 3, 4].choose;
::

method::wchoose
Choose an element from the collection at random using a list of probabilities or weights. The weights must sum to 1.0.
code::
[1, 2, 3, 4].wchoose([0.1, 0.2, 0.3, 0.4]);
::

method::sort
Sort the contents of the collection using the comparison function argument. The function should take two elements as arguments and return true if the first argument should be sorted before the second argument. If the function is nil, the following default function is used. { arg a, b; a < b }
code::
[6, 2, 1, 7, 5].sort;
[6, 2, 1, 7, 5].sort({ arg a, b; a > b }); // reverse sort
::

method::sortBy
Sort the contents of the collection using the key strong::key::, which is assumed to be found inside each element of the receiver.
code::
(
a = [
	Dictionary[\a->5, \b->1, \c->62],
	Dictionary[\a->2, \b->9, \c->65],
	Dictionary[\a->8, \b->5, \c->68],
	Dictionary[\a->1, \b->3, \c->61],
	Dictionary[\a->6, \b->7, \c->63]
]
)
a.sortBy(\b);
a.sortBy(\c);
::

method::order
Return an array of indices that would sort the collection into order. strong::function:: is treated the same way as for the link::#-sort:: method.
code::
[6, 2, 1, 7, 5].order;
::

method::swap
Swap two elements in the collection at indices strong::i:: and strong::j::.

method::pairsDo
Calls function for each subsequent pair of elements in the SequentialCollection. The function is passed the two elements and an index.
code::
[1, 2, 3, 4, 5].pairsDo({ arg a, b; [a, b].postln; });
::

method::doAdjacentPairs
Calls function for every adjacent pair of elements in the SequenceableCollection. The function is passed the two adjacent elements and an index.
code::
[1, 2, 3, 4, 5].doAdjacentPairs({ arg a, b; [a, b].postln; });
::

method::separate
Separates the collection into sub-collections by calling the function for each adjacent pair of elements. If the function returns true, then a separation is made between the elements.
code::
[1, 2, 3, 5, 6, 8, 10].separate({ arg a, b; (b - a) > 1 }).postcs;
::

method::clump
Separates the collection into sub-collections by separating every groupSize elements.
code::
[1, 2, 3, 4, 5, 6, 7, 8].clump(3).postcs;
::

method::clumps
Separates the collection into sub-collections by separating elements into groupings whose size is given by integers in the groupSizeList.
code::
[1, 2, 3, 4, 5, 6, 7, 8].clumps([1, 2]).postcs;
::

method::curdle
Separates the collection into sub-collections by randomly separating elements according to the given probability.
code::
[1, 2, 3, 4, 5, 6, 7, 8].curdle(0.3).postcs;
::

method::integrate
Returns a collection with the incremental sums of all elements.
code::
[3, 4, 1, 1].integrate;
::

method::differentiate
Returns a collection with the pairwise difference between all elements.
code::
[3, 4, 1, 1].differentiate;
::

method::reduce
Applies the method named by operator to the first and second elements of the collection, and then applies the method to the result and to the third element of the collection, then applies the method to the result and to the fourth element of the collection, and so on, until the end of the array.

If the collection contains only one element, it is returned as the result. If the collection is empty, returns code::nil::.

argument::operator
May be a link::Classes/Function:: (taking two or three arguments) or a link::Classes/Symbol:: (method selector).


code::
[3, 4, 5, 6].reduce('*'); // this is the same as [3, 4, 5, 6].product
[3, 4, 5, 6].reduce(\lcm); // Lowest common multiple of the whole set of numbers
["d", "e", (0..9), "h"].reduce('++'); // concatenation
[3, 4, 5, 6].reduce({ |a, b| sin(a) * sin(b) }); // product of sines
::


argument::adverb
An optional adverb to be used together with the operator (see link::Reference/Adverbs::). If the operator is a functions, the adverb is passed as a third argument.

code::
// compare:
[1, 2] *.x [10, 20, 30]
[[1, 2], [10, 20, 30]].reduce('*', 'x')
[[1, 2], [10, 20, 30], [1000, 2000]].reduce('+', 'x') // but you can combine more
::

method::convertDigits
Returns an integer resulting from interpreting the elements as digits to a given base (default 10). See also asDigits in link::Classes/Integer#-asDigits:: for the complementary method.
code::
[1, 0, 0, 0].convertDigits;
[1, 0, 0, 0].convertDigits(2);
[1, 0, 0, 0].convertDigits(3);
::

method::hammingDistance
Returns the count of array elements that are not equal in identical positions. http://en.wikipedia.org/wiki/Hamming_distance

The collections are not wrapped - if one array is shorter than the other, the difference in size should be included in the count.

code::
[0, 0, 0, 1, 1, 1, 0, 1, 0, 0].hammingDistance([0, 0, 1, 1, 0, 0, 0, 0, 1, 1]);
"SuperMan".hammingDistance("SuperCollider");
::

subsection:: Fuzzy comparisons
With fuzzy comparisons, the arrays do not need to match exactly. We can check how similar they are, and make decisions based on that. This is the magic behind autocorrection.

method::editDistance
Returns the minimum number of changes to modify this teletype::SequenceableCollection:: into the other teletype::SequenceableCollection::.
A change can be: an addition, a deletion, or a substitution.
This is known as the Levenshtein Distance and is implemented in SuperCollider using the Wagner–Fischer algorithm.

The default comparison uses strong::identity:: - see link::Classes/Object#-==:: and link::Classes/Object#-===::

Where both arrays are raw arrays (String, Int16Array, Int32Array, FloatArray etc., or any derived classes), like comparing two strings, a faster primitive will be used to calculate the distance.

code::
"hello".editDistance("hallo"); // 1 (substitution)
"hello".editDistance("hell"); // 1 (deletion)
"hello".editDistance("helloo"); // 1 (addition)
"hello".editDistance("hllo"); // 1 (removal)
"hello".editDistance("haldo"); // 2 (substitutions)
::

In cases where the arrays are of different types, it will fall back to a slower, non-primitive implementation.

code::
// String vs Array
"hello".editDistance([$h, $e, $l, $l, $o]);
::

For cases that require comparisons other than identity, the optional teletype::compareFunc:: can be given to compare elements. This function will be passed two arguments, representing a single element from each array to compare, and this function must return a boolean as to whether or not the elements are equal.

code::
// Using compareFunc for case insensitive comparisons
"HeLLO".editDistance("HELLO", { |a, b|
	a.toLower == b.toLower;
});
::

note::
Specifying a teletype::compareFunc:: will bypass the primitive and may take significantly longer to execute for larger arrays.
::

argument::other
The teletype::SequenceableCollection:: to compare against

argument::compareFunc
An optional comparison function to use for each element. It will be provided two arguments, and the function must return a boolean as to whether or not they are the same. Default value is teletype::nil::, which will use strong::identity:: (not equality) to compare elements.

code::
[1,2,3,4].editDistance([2,3,4,5], { | a, b |
	a == b;
});
::

method::similarity
Returns a value between 0 and 1 representing the percentage similarity between this teletype::SequenceableCollection:: and the other teletype::SequenceableCollection::.

A value of 1 means they are exactly the same, a value of 0 means they are completely different.
This is calculated based on the link::#-editDistance::
code::
"hello".similarity("hello"); // 1
"hello".similarity("asdf"); // 0
"word".similarity("wodr"); // 0.5
::

argument::other
The code::SequenceableCollection:: to compare against

argument::compareFunc
An optional compareFunc to be used to calculate the edit distance (see link::#-editDistance::)

private::prEditDistance
private::prLevenshteinDistance

subsection::Math Support - Unary Messages

All of the following messages send the message link::#-performUnaryOp:: to the receiver with the unary message selector as an argument.

method::neg, reciprocal, bitNot, abs, asFloat, ceil, floor, frac, sign, squared, cubed, sqrt, exp, midicps, cpsmidi, midiratio, ratiomidi, ampdb, dbamp, octcps, cpsoct, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, rand, rand2, linrand, bilinrand, sum3rand, distort, softclip, coin, even, odd, isPositive, isNegative, isStrictlyPositive, real, imag, magnitude, magnitudeApx, phase, angle, rho, theta, asFloat, asInteger

method::performUnaryOp
Creates a new collection of the results of applying the selector to all elements in the receiver.
code::
[1, 2, 3, 4].neg;
[1, 2, 3, 4].reciprocal;
::

subsection::Math Support - Binary Messages

All of the following messages send the message link::#-performBinaryOp:: to the receiver with the binary message selector and the second operand as arguments.

method:: +, -, *, /, div, min, max, <, <=, >, >=, bitXor, lcm, gcd, round, trunc, atan2, hypot, ring1, ring2, ring3, ring4, difsqr, sumsqr, sqrdif, absdif, amclip, scaleneg, clip2, excess, rrand, exprand

method:: %, **, &, |, >>, +>>, <!

method::performBinaryOp
Creates a new collection of the results of applying the selector with the operand to all elements in the receiver. If the operand is a collection then elements of that collection are paired with elements of the receiver.
code::
([1, 2, 3, 4] * 10);
([1, 2, 3, 4] * [4, 5, 6, 7]);
::

subsection::Math Support - Special Functions

A variety of Special Functions are supplied by the Boost C++ library. The library's
link::http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/special.html##online documentation::
 serves as the primary reference for the following functions. The methods
here match closely with those found in the source library, as do argument names.

Below you'll find descriptions of the functions and their bounds, but for
visualizing the functions, have a look in link::Guides/Tour-of-Special-Functions::.

note::The following methods are documented slightly clearer in
link::Classes/SimpleNumber#Special Functions:: using functional notation.
As of this writing, a bug in the help file formatting misleadingly documents
the methods in receiver notation (methods preceded by code::.::), but should
be read to suggests the usage: code::foo([a], [b])::. The equivalent receiver
notation is: code::[a].foo([b])::. Note that those methods with only one argument erroneously omit that
argument from the argument list; each element in the collection is implicitly
passed as the method's argument, e.g. code::foo([a]):: or code::[a].foo::::

warning::Many of the functions are only valid in certain numerical ranges. For the most part, error handling
happens in the underlying boost functions. While these errors are often obtuse, you'll usually find
a useful message at the end of the error regarding proper ranges and the erroneous value supplied.
Refer to the online documentation for more detailed descriptions, and the
link::Guides/Tour-of-Special-Functions:: for plots showing ranges and asymptotes.::

copymethod:: SimpleNumber -bernouliB2n
copymethod:: SimpleNumber -tangentT2n
copymethod:: SimpleNumber -tgamma
copymethod:: SimpleNumber -tgamma1pm1
copymethod:: SimpleNumber -lgamma
copymethod:: SimpleNumber -digamma
copymethod:: SimpleNumber -trigamma
copymethod:: SimpleNumber -polygamma
copymethod:: SimpleNumber -tgammaRatio
copymethod:: SimpleNumber -tgammaDeltaRatio
copymethod:: SimpleNumber -gammaP
copymethod:: SimpleNumber -gammaQ
copymethod:: SimpleNumber -tgammaLower
copymethod:: SimpleNumber -tgammaUpper
copymethod:: SimpleNumber -gammaPInv
copymethod:: SimpleNumber -gammaQInv
copymethod:: SimpleNumber -gammaPInvA
copymethod:: SimpleNumber -gammaQInvA
copymethod:: SimpleNumber -gammaPDerivative
copymethod:: SimpleNumber -gammaQDerivative
copymethod:: SimpleNumber -factorial
copymethod:: SimpleNumber -doubleFactorial
copymethod:: SimpleNumber -risingFactorial
copymethod:: SimpleNumber -fallingFactorial
copymethod:: SimpleNumber -binomialCoefficient
copymethod:: SimpleNumber -beta
copymethod:: SimpleNumber -ibeta
copymethod:: SimpleNumber -ibetaC
copymethod:: SimpleNumber -betaFull
copymethod:: SimpleNumber -betaFullC
copymethod:: SimpleNumber -ibetaInv
copymethod:: SimpleNumber -ibetaCInv
copymethod:: SimpleNumber -ibetaInvA
copymethod:: SimpleNumber -ibetaCInvA
copymethod:: SimpleNumber -ibetaInvB
copymethod:: SimpleNumber -ibetaCInvB
copymethod:: SimpleNumber -ibetaDerivative
copymethod:: SimpleNumber -erf
copymethod:: SimpleNumber -erfC
copymethod:: SimpleNumber -erfInv
copymethod:: SimpleNumber -erfCInv
copymethod:: SimpleNumber -legendreP
copymethod:: SimpleNumber -legendrePPrime
copymethod:: SimpleNumber -legendrePZeros
copymethod:: SimpleNumber -legendrePAssoc
copymethod:: SimpleNumber -legendreQ
copymethod:: SimpleNumber -laguerre
copymethod:: SimpleNumber -laguerreAssoc
copymethod:: SimpleNumber -hermite
copymethod:: SimpleNumber -chebyshevT
copymethod:: SimpleNumber -chebyshevU
copymethod:: SimpleNumber -chebyshevTPrime
copymethod:: SimpleNumber -chebyshevTZeros
copymethod:: SimpleNumber -sphericalHarmonic
copymethod:: SimpleNumber -sphericalHarmonicR
copymethod:: SimpleNumber -sphericalHarmonicI
copymethod:: SimpleNumber -cylBesselJ
copymethod:: SimpleNumber -cylNeumann
copymethod:: SimpleNumber -cylBesselJZero
copymethod:: SimpleNumber -cylNeumannZero
copymethod:: SimpleNumber -cylBesselI
copymethod:: SimpleNumber -cylBesselK
copymethod:: SimpleNumber -sphBessel
copymethod:: SimpleNumber -sphNeumann
copymethod:: SimpleNumber -cylBesselJPrime
copymethod:: SimpleNumber -cylNeumannPrime
copymethod:: SimpleNumber -cylBesselIPrime
copymethod:: SimpleNumber -cylBesselKPrime
copymethod:: SimpleNumber -sphBesselPrime
copymethod:: SimpleNumber -sphNeumannPrime
copymethod:: SimpleNumber -cylHankel1
copymethod:: SimpleNumber -cylHankel2
copymethod:: SimpleNumber -sphHankel1
copymethod:: SimpleNumber -sphHankel2
copymethod:: SimpleNumber -airyAi
copymethod:: SimpleNumber -airyBi
copymethod:: SimpleNumber -airyAiPrime
copymethod:: SimpleNumber -airyBiPrime
copymethod:: SimpleNumber -airyAiZero
copymethod:: SimpleNumber -airyBiZero
copymethod:: SimpleNumber -ellintRf
copymethod:: SimpleNumber -ellintRd
copymethod:: SimpleNumber -ellintRj
copymethod:: SimpleNumber -ellintRc
copymethod:: SimpleNumber -ellintRg
copymethod:: SimpleNumber -ellint1
copymethod:: SimpleNumber -ellint1C
copymethod:: SimpleNumber -ellint2
copymethod:: SimpleNumber -ellint2C
copymethod:: SimpleNumber -ellint3
copymethod:: SimpleNumber -ellint3C
copymethod:: SimpleNumber -ellintD
copymethod:: SimpleNumber -ellintDC
copymethod:: SimpleNumber -jacobiZeta
copymethod:: SimpleNumber -heumanLambda
copymethod:: SimpleNumber -jacobiCd
copymethod:: SimpleNumber -jacobiCn
copymethod:: SimpleNumber -jacobiCs
copymethod:: SimpleNumber -jacobiDc
copymethod:: SimpleNumber -jacobiDn
copymethod:: SimpleNumber -jacobiDs
copymethod:: SimpleNumber -jacobiNc
copymethod:: SimpleNumber -jacobiNd
copymethod:: SimpleNumber -jacobiNs
copymethod:: SimpleNumber -jacobiSc
copymethod:: SimpleNumber -jacobiSd
copymethod:: SimpleNumber -jacobiSn
copymethod:: SimpleNumber -zeta
copymethod:: SimpleNumber -expintEn
copymethod:: SimpleNumber -expintEi
copymethod:: SimpleNumber -sinPi
copymethod:: SimpleNumber -cosPi
copymethod:: SimpleNumber -log1p
copymethod:: SimpleNumber -expm1
copymethod:: SimpleNumber -cbrt
copymethod:: SimpleNumber -sqrt1pm1
copymethod:: SimpleNumber -powm1
copymethod:: SimpleNumber -sincPi
copymethod:: SimpleNumber -sinhcPi
copymethod:: SimpleNumber -asinh
copymethod:: SimpleNumber -acosh
copymethod:: SimpleNumber -atanh
copymethod:: SimpleNumber -owensT


subsection::Multichannel wrappers
All of the following messages are performed on the elements of this collection, using link::Classes/Object#-multiChannelPerform::.

The result depends on the objects in the collection, but the main use case is for link::Classes/UGen::s.

See also link::Guides/Multichannel-Expansion::

method::clip, wrap, fold, prune, linlin, linexp, explin, expexp, lincurve, curvelin, bilin, biexp, range, exprange, unipolar, bipolar, lag, lag2, lag3, lagud, lag2ud, lag3ud, varlag, slew, blend, checkBadValues
Calls code:: this.multiChannelPerform(selector, *args) :: where selector is the name of the message.

method::multichannelExpandRef
This method is called internally on inputs to UGens that take multidimensional arrays, like link::Classes/Klank:: and it allows proper multichannel expansion even in those cases. For SequenceableCollection, this returns the collection itself, assuming that it contains already a number of Refs. See link::Classes/Ref:: for the corresponding method implementation.
argument::rank
The depth at which the list is expanded. For instance the Klank spec has a rank of 2. For more examples, see link::Classes/SequenceableCollection#-flopDeep::
code::
`([[[100, 200], 500], nil, [[[0.01, 0.3], 0.8]]]).multichannelExpandRef(2);
[`[[100, 200], nil, [0.2, 0.8]], `[[130, 202], nil, [0.2, 0.5]]].multichannelExpandRef(2);
::

subsection:: Rhythm-lists
method:: convertRhythm
Convert a rhythm-list to durations.
discussion::
supports a variation of Mikael Laurson's rhythm list RTM-notation. footnote::
see Laurson and Kuuskankare's 2003, "From RTM-notation to ENP-score-notation"
http://jim2003.agglo-montbeliard.fr/articles/laurson.pdf
::

The method converts a collection of the form code:: [beat-count, [rtm-list], repeats] :: to a link::Classes/List:: of link::Classes/Float::s. A negative integer within the rtm-list equates to a value tied over to the duration following. The method is recursive in that any subdivision within the rtm-list can itself be a nested convertRhythm collection (see example below). The repeats integer has a default value of 1.

If the divisions in the rtm-list are events, the event durations are interpreted as relative durations, and a list of events is returned.
code::
// using numbers as score
[3, [1, 2, 1], 1].convertRhythm; // List[ 0.75, 1.5, 0.75 ]
[2, [1, 3, [1, [2, 1, 1, 1]], 1, 3], 1].convertRhythm;
[2, [1, [1, [2, 1, 1, 1]]], 1].convertRhythm;
[2, [1, [1, [2, 1, 1, 1]]], 2].convertRhythm; // repeat
[2, [1, [1, [2, 1, 1, -1]]], 2].convertRhythm; // negative value is tied over.

// sound example
Pbind(\degree, Pseries(0, 1, inf), \dur, Pseq([2, [1, [1, [2, 1, 1, -1]]], 2].convertRhythm)).play;
::

subsection:: Starting UNIX processes

private::prUnixCmd

method::unixCmd
Execute a UNIX command strong::asynchronously::. This object should be an array of strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.
argument:: action
A link::Classes/Function:: that is called when the process has exited. It is passed two arguments: the exit code and pid of the exited process.
argument:: postOutput
A link::Classes/Boolean:: that controls whether or not the output of the process is displayed in the post window.
returns::
An link::Classes/Integer:: - the pid of the newly created process. Use link::Classes/Integer#-pidRunning:: to test if a process is alive.
discussion::
Example:
code::
["ls","/"].unixCmd;
::

method::unixCmdGetStdOut
Similar to link::#-unixCmd:: except that the stdout of the process is returned (strong::synchronously::) rather than sent to the post window. This object should be an array of strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.
code::
~listing = ["ls","/"].unixCmdGetStdOut; // Grab
~listing.reverse.as(Array).dupEach.join.postln; // Mangle
::

private:: acosh, airyAi, airyAiPrime, airyAiZero, acosh, airyAi, airyAiPrime, airyAiZero, airyBi, airyBiPrime, airyBiZero, asinh, atanh, bernouliB2n, beta, betaFull, betaFullC, binomialCoefficient, cbrt, chebyshevT, chebyshevTPrime, chebyshevTZeros, chebyshevU, cosPi, cylBesselI, cylBesselIPrime, cylBesselJ, cylBesselJPrime, cylBesselJZero, cylBesselK, cylBesselKPrime, cylHankel1, cylHankel2, cylNeumann, cylNeumannPrime, cylNeumannZero, digamma, doubleFactorial, ellint1, ellint1C, ellint2, ellint2C, ellint3, ellint3C, ellintD, ellintDC, ellintRc, ellintRd, ellintRf, ellintRg, ellintRj, erf, erfC, erfCInv, erfInv, expintEi, expintEn, expm1, factorial, fallingFactorial, gammaP, gammaPDerivative, gammaPInv, gammaPInvA, gammaQ, gammaQDerivative, gammaQInv, gammaQInvA, hermite, heumanLambda, ibeta, ibetaC, ibetaCInv, ibetaCInvA, ibetaCInvB, ibetaDerivative, ibetaInv, ibetaInvA, ibetaInvB, jacobiCd, jacobiCn, jacobiCs, jacobiDc, jacobiDn, jacobiDs, jacobiNc, jacobiNd, jacobiNs, jacobiSc, jacobiSd, jacobiSn, jacobiZeta, laguerre, laguerreAssoc, legendreP, legendrePAssoc, legendrePPrime, legendrePZeros, legendreQ, lgamma, log1p, owensT, polygamma, pow, powm1, prHermite, prLaguerreAssoc, prLegendreQ, risingFactorial, sinPi, sincPi, sinhcPi, sphBessel, sphBesselPrime, sphHankel1, sphHankel2, sphNeumann, sphNeumannPrime, sphericalHarmonic, sphericalHarmonicI, sphericalHarmonicR, sqrt1pm1, tangentT2n, tgamma, tgamma1pm1, tgammaDeltaRatio, tgammaLower, tgammaRatio, tgammaUpper, trigamma, zeta


class:: SerialPort
summary:: serial port interface
categories:: External Control

This class provides basic support for serial port communication. Ports are opened with link::#*new:: and closed with link::#-close::.

Each SerialPort object uses an 8KB internal buffer and reads data as soon as it is available. If the data is not read out of the buffer and the buffer fills up, incoming bytes will be dropped. Use link::#-rxErrors:: to get a count of the number of bytes dropped.

Since it is constantly polling the port for available data, a SerialPort object knows almost immediately when the port has been lost. When this happens, it will call the link::#-doneAction:: callback and mark itself as closed.

ClassMethods::

private::initClass

method::new
Creates and opens the port. Throws if creation fails; this may be because the port does not exist,
the port could not be opened, or the settings were invalid.

argument::port
A link::Classes/String:: representing the port to be opened. (An link::Classes/Integer:: index into link::#*devices:: is allowed, but this is deprecated.)

argument::baudrate
Integer baud rate, typically in the range code::[4800..230400]::.

argument::databits
Bits per character. Typically 8, but can be any integer.

argument::stopbit
A link::Classes/Boolean:: indicating whether to use two stop bits (code::true::) or one stop bit
(code::false::).

argument::parity
Whether the port uses even, odd, or no parity. Pass code::'even'::, code::'odd'::, or code::nil::
 (for none).

argument::crtscts
A link::Classes/Boolean:: indicating whether to use hardware flow control (RTS/CTS signals).

argument::xonxoff
A link::Classes/Boolean:: indicating whether to use software flow control (XON/XOFF signals).

argument::exclusive
A link::Classes/Boolean:: indicating whether to open the device exclusively. This option is not
implemented on Windows.

discussion::
code::crtscts:: and code::xonxoff:: cannot both be true; code::*new:: will throw an error if both
are set.

method::devices
Retrieve an array of available devices represented as link::Classes/String##Strings::. On macOS and Linux, this list is obtained using a number of regular expression rules on files in the code::/dev/:: directory. On Windows, this is obtained using a registry key. The matching rules are designed to be identical to that of the Arduino IDE.

For backward compatibility, if code::SerialPort.devicePattern:: is not nil, code::SerialPort.devicePattern.pathMatch:: is returned instead of the default behavior.

code::
SerialPort.devices;
::

method::listDevices
Prints the list of available devices, one per line. Shorthand for
code::SerialPort.devices.do(_.postln)::.
code::
SerialPort.listDevices;
::

method::devicePattern
If set to a non-nil value, code::SerialPort.devicePattern:: instead returns code::SerialPort.devicePattern.patchMatch::. That is, the value of this class variable is used as a file glob.

This is a legacy feature and no longer recommended. File globbing alone is not powerful enough to capture a general set of possible serial port paths, and this level of customization was not necessary for code::SerialPort.devices::. If you need to refine the results returned by code::SerialPort.devices::, it is better to do your own matching or filtering.

method::closeAll
Calls link::#-close:: on all ports.

method::cleanupAll
Deprecated; use link::#*closeAll:: instead.

InstanceMethods::

private::prInit, prOpen, prClose, primCleanup, prCleanup, prPut, prDataAvailable, prDoneAction

method::isOpen
Whether this object represents a valid serial port connection.

method::next
Read a byte from the device. Non-blocking read.

method::read
Read a byte from the device. Blocking read.

method::rxErrors
RX (receive) errors since last query. An RX error occurs when the internal buffer is completely
full. This count is reset to 0 every time this method is called.

method::put
Write a byte to the device. Always blocks.

argument::byte
An link::Classes/Integer:: or link::Classes/Char::. Only values in the range from 0 to
code::2**databits - 1:: may be written. If a value out of that range is passed to code::put::, only
the lowest bits will be used.

argument::timeout
Unused, deprecated.

returns::
A link::Classes/Boolean:: indicating whether the write was successful.

method::putAll
Write multiple bytes to the device.

argument::bytes
Collection may be link::Classes/Int8Array:: or link::Classes/String::.

argument::timeout
Unused, deprecated.

method::doneAction
A link::Classes/Function:: which will be evaluated if the port gets closed (maybe unexpectedly so,
due to hardware failure or accidental disconnection). This allows you to for example to make a
backup solution and activate it (like using fake input data for your algorithm, or trying to reopen
the device). By default it will post a message reading "SerialPort X was closed".

method::close
Closes the port.

Examples::

code::
(
p = SerialPort(
	"/dev/tty.usbserial-181",
	baudrate: 9600,
	crtscts: true);
)

// read a byte from the device

p.next; // doesn't block
fork { p.read.postln }; // may suspend thisThread - should be called within a routine

// write a byte to the device

fork {p.put(42) }; // may suspend thisThread - should be called within a routine

// write multiple bytes to the device

fork { p.putAll("whaddayawant") };
fork { p.putAll(Int8Array[13, 10]) };

p.doneAction = { "my serial port got closed".postln; }

p.close; // close the port

SerialPort.closeAll; // close all ports
::

subsection::Arduino write example

First load the sketch Examples/Communication/Dimmer. See
link::http://www.arduino.cc/en/Tutorial/Dimmer::.

note::
Always make sure the serial monitor is closed in the Arduino application before opening the port in SuperCollider.
::

code::
(
p = SerialPort(
	"/dev/tty.usbserial-A800crTT",	//edit to match your port. SerialPort.listDevices
	baudrate: 9600,	//check that baudrate is the same as in arduino sketch
	crtscts: true);
)

//send serial data - slow pulsating
(
r = Routine({
	inf.do{|i|
		p.put(i.fold(0, 100).linexp(0, 100, 1, 255).asInteger.postln);
		0.02.wait;
	};
}).play;
)

r.stop;
p.close;
::

subsection::Arduino read example

First load the sketch Examples/Communication/Graph. See
link::http://www.arduino.cc/en/Tutorial/Graph::.

note::
Always make sure the serial monitor is closed in the Arduino application before opening the port in SuperCollider.
::

code::
(
p = SerialPort(
	"/dev/tty.usbserial-A800crTT",	//edit to match your port. SerialPort.listDevices
	baudrate: 9600,	//check that baudrate is the same as in arduino sketch
	crtscts: true);
)

//read 10bit serial data sent from Arduino's Serial.println
(
r= Routine({
	var byte, str, res;
	99999.do{|i|
		if(p.read==10, {
			str = "";
			while({byte = p.read; byte !=13 }, {
				str= str++byte.asAscii;
			});
			res= str.asInteger;
			("read value:"+res).postln;
		});
	};
}).play;
)

r.stop;
p.close;
::


class:: Server
summary:: Object representing a server application
categories:: Server>Abstractions
related:: Guides/Server-Guide, Guides/MultiClient_Setups, Classes/ServerOptions, Reference/Server-Architecture, Reference/Server-Command-Reference, Classes/ServerStatusWatcher, Reference/AudioDeviceSelection

description::

A Server object is a representation of a server application. It is used to control scsynth (or supernova) from the SuperCollider language. (See link::Guides/Server-Guide::, as well as link::Guides/ClientVsServer:: for more details on the distinction.) It forwards OSC messages and has a number of allocators that keep track of IDs for nodes, buses, and buffers.

The server application represented by a Server object might be running on the same machine as the sclang, or it may be running on a remote machine.

Most of a Server's options are controlled through its instance of ServerOptions. See the link::Classes/ServerOptions:: helpfile for more detail.

A server also holds an instance of a link::Classes/Recorder:: (for recording output into a file) and a link::Classes/Volume:: (main output level).

note::
By default, there is always one default server, which is stored in the interpreter variable 's'. E.g. you can boot the default server by calling code::s.boot::
::

code::
s.boot;
{ SinOsc.ar * 0.1 }.play(s); // play a synth on the server
::

The server application may be in three different states: running, not running, or unresponsive (for example while loading large files from disk).

code::
s.serverRunning // returns true if it is true
::

note::
If you get the message code::"Mismatched sample rates are not supported.":: it may be helpful to follow these steps:
code::
1. set your device to the sample rate you want
2. check the device name in the boot posting of the server
3. set both sample rate and device (s.options.sampleRate = …; s.options.device = "…")
4. reboot the server: "s.reboot"
::
::
Some insights about common Server issues can be found on the FAQ link::Guides/UserFAQ#Server Issues#Server Issues::


ClassMethods::
private:: initClass

method:: new
Create a new Server instance.

argument:: name
a symbol;  each Server object is stored in one global classvariable under its name.

argument:: addr
an optional instance of link::Classes/NetAddr::, providing host and port.
The default is the localhost address using port 57110; the same as the local server.

argument:: options
an optional instance of link::Classes/ServerOptions::. If code::nil::, an instance of ServerOptions will be created, using the default values.

argument:: clientID
an integer. In multi-client situations, every client can be given separate ranges for link::Classes/Node##Nodes::, link::Classes/Buffer##Buffers::, or link::Classes/Bus##Busses::. In normal usage, the server will supply an ID automatically when a client registers for the link::#-notify#notifications:: so you should not need to supply one here. N.B. In multi-client situations, you will need to set the link::Classes/ServerOptions#-maxLogins:: to at least the number of clients you wish to allow. This must be the same in the Server instances on every client.

method:: remote
Create a new Server instance corresponding to a server app running on a separate machine. This method assumes the remote app has been booted and starts listening immediately. You should not call link::#-boot:: on an instance created using this method. link::Guides/Server-Guide:: and link::Guides/MultiClient_Setups:: contain further information on this and multiclient usage.

argument:: name
a symbol;  each Server object is stored in one global classvariable under its name.

argument:: addr
an optional instance of link::Classes/NetAddr::, providing IP address of the remote machine and port the app is listening on.

argument:: options
an optional instance of link::Classes/ServerOptions::. If code::nil::, an instance of ServerOptions will be created, using the default values. note::To enable remote connections you will need to change the option link::Classes/ServerOptions#-bindAddress:: as the default value only allows connections from the local machine. code::s.options.bindAddress = "0.0.0.0":: will allow connections from any address.::

argument:: clientID
an integer. In multi-client situations, every client can be given separate ranges for link::Classes/Node##Nodes::, link::Classes/Buffer##Buffers::, or link::Classes/Bus##Busses::. In normal usage, the server will supply an ID automatically when a client registers for the link::#-notify#notifications:: so you should not need to supply one here. N.B. In multi-client situations, you will need to set the link::Classes/ServerOptions#-maxLogins:: to at least the number of clients you wish to allow. This must be the same in the Server instances on every client.

code::
// example usage:
// on machine running the server
(
s.options.bindAddress = "0.0.0.0"; // allow connections from any address
s.options.maxLogins = 2; // set to correct number of clients
s.boot;
)

// on remote machine connecting to server
(
o = ServerOptions.new;
o.maxLogins = 2;
t = Server.remote(\remote, NetAddr("192.168.0.130", 57110), o); // set to correct address and port
// info about returned client ID should be posted in the post window
t.makeWindow; // make a window for monitoring
)
::


method:: local
get/set the local server, stored in classvar code::local:: (created already on initClass)

method:: internal
get/set the internal server, stored in classvar code::internal:: (created already on initClass)
See: link::Guides/Server-Guide::

method:: default
Get or set the default server. By default this is the local server (see above).
discussion::
Setting this will also assign it to the link::Classes/Interpreter:: variable 's'.
code::
// set the internal Server to be the default Server
Server.default = Server.internal;
s.postln; // internal
::

subsection::Accessing all servers

method:: all
returns:: a link::Classes/Set:: containing all servers.

code::
Server.all
::

method:: allRunningServers
returns:: a Set containing all running servers, according to the definition of link::#-serverRunning::.

code::
Server.allRunningServers
::

method:: allBootedServers
returns:: a Set containing all booted servers, according to the definition of link::#-hasBooted::.

method:: named
returns:: An link::Classes/IdentityDictionary:: of all servers listed by their name

code::
Server.named.at(\default)
::


method:: quitAll
quit all registered servers

method:: killAll
kill all the processes called "scsynth" and "supernova" in the system

method:: freeAll
free all nodes in all registered servers

method:: hardFreeAll
try to free all nodes in all registered servers, even if the server seems not to be running

method::sync_s
If kept true (default), when the default server is changed, also the interpreter variable s is changed.
code::
Server.default = Server(\alice, NetAddr("127.0.0.1", 57130));
s.postln; // see: it is alice.
::

subsection::Switching the server application

method:: supernova

Switches the server program to supernova. Check link::Classes/ParGroup:: how to make use of multicore hardware with the supernova server.

method:: scsynth

Switches the server program to scsynth. This is the default server.


InstanceMethods::

private:: doSend, prHandleClientLoginInfoFromServer, prHandleNotifyFailString, prPingApp, prOnServerProcessExit, prWaitForPidRelease

method:: sendMsg
send an OSC-message to the server.
discussion::
code::
s.sendMsg("/s_new", "default", s.nextNodeID, 0, 1);
::

method:: sendBundle
send an OSC-bundle to the server.
discussion::
Since the network may have irregular performance, time allows for the bundle to be evaluated at a specified point in the future.
Thus all messages are synchronous relative to each other, but delayed by a constant offset.
If such a bundle arrives late, the server replies with a late message but still evaluates it.
code::
s.sendBundle(0.2, ["/s_new", "default", x = s.nextNodeID, 0, 1], ["/n_set", x, "freq", 500]);
::

method:: sendRaw

method:: listSendMsg
as sendMsg, but takes an array as argument.

method:: listSendBundle
as sendBundle, but takes an array as argument.
discussion::
This allows you to collect messages in an array and then send them.
code::
s.listSendBundle(0.2, [["/s_new", "default", x = s.nextNodeID, 0, 1],
	["/n_set", x, "freq", 600]]);
::

method:: sendSynthDef
send a synthDef to the server that was written in a local directory

method:: loadSynthDef
load a synthDef that resides in the remote directory

method:: loadDirectory
load all the SynthDefs in the directory dir.
argument:: dir
a link::Classes/String:: which is a valid path.
argument:: completionMsg

method:: nextNodeID
get a unique nodeID.

method:: nextPermNodeID
get a permanent node ID. This node ID is in a reserved range and will be held until you explicitly free it.

method:: freePermNodeID
free a permanent node ID for later reuse.

method:: wait
this can be used within a link::Classes/Routine:: to wait for a server reply

method:: waitForBoot
Evaluate "onComplete" as soon as the server has booted. This method will boot the server for you if it is not already running or booting. If the server is already running, "onComplete" is executed immediately.
argument:: onComplete
A function to evaluate after the server has booted successfully.
argument:: limit
The number of times to check for a successful boot. (5 times/sec)
argument:: onFailure
A function to evaluate after the server fails to boot. If onFailure is not given, an error message is posted. Providing a function suppresses the error message. If you want to supply a function and print the normal error message, make sure that your function returns "false," e.g. code::s.waitForBoot(onFailure: { ... custom action...; false })::.

method:: doWhenBooted
Evaluate "onComplete" as soon as the server has booted. This method assumes the server is being booted explicitly through a separate code::boot:: call. If the server is already running, "onComplete" is executed immediately.
argument:: onComplete
A function to evaluate after the server has booted successfully.
argument:: limit
The number of times to check for a successful boot.
argument:: onFailure
A function to evaluate after the server fails to boot. If onFailure is not given, an error message is posted. Providing a function suppresses the error message. If you want to supply a function and print the normal error message, make sure that your function returns "false," e.g. code::s.doWhenBooted(onFailure: { ... custom action...; false })::.

method:: boot
boot the remote server, create new allocators.
argument:: startAliveThread
If true, start a Routine to send a /status message to the server every so often. The interval between the messages is set by code::theServer.aliveThreadPeriod = (seconds)::. The default period is 0.7. If false, /status will not be sent and the server's window will not update.
argument:: recover
If true, create a new node ID allocator for the server, but use the old buffer and bus allocators. This is useful if the server process did not actually stop. In normal use, the default value "false" should be used.
argument:: onFailure
In this method, the onFailure argument is for internal use only. If you wish to take specific actions when the server boots or fails to boot, it is recommended to use link::#-waitForBoot:: or link::#-doWhenBooted::.

discussion::
You cannot boot a server app on a remote machine, but you can initialize the allocators by calling this message.

method:: quit
quit the server application

note:: If the server is unresponsive at the time of calling this method, it will be forced to quit immediately.::

argument::onComplete
A function that is called when quit has completed.

argument::onFailure
A function that is called when quit has failed.

argument::watchShutDown
a boolean to tell the server whether to watch status during shutdown.

method:: reboot
quit and restart the server application

argument::func
a function that is called between quit and (re-)boot.

argument::onFailure
A function that is called when quit has failed.

method:: freeAll
free all nodes in this server

method:: status
query the server status

method:: notify
The server sends notifications, for example, if a node was created, a 'tr' message from a link::Classes/SendTrig::, or a strong::/done:: action. If code::flag:: is set to false, these messages will not be sent to this client. The default is true. If true the server will respond with a clientID (scsynth only) which can be useful in multi-client situations. If this is different from any previously received ID new allocators will be created. See link::#Local vs. Remote Servers, Multi-client Configurations:: for more information.

method:: ping
measure the time between server and client, which may vary. the code::func:: is
evaluated after code::n:: number of times and is passed the resulting maximum.

method:: options
Get or set this Server's link::Classes/ServerOptions:: object. Changes to options only take effect when the server is rebooted.

method:: defaultGroup
Return the default group on this Server for this client ID. This will be the
same object as code::server.defaultGroups[server.clientID]::.

method:: defaultGroups
Return an array mapping client IDs to their associated default groups as
link::Classes/Group:: objects.

method:: volume
Get an instance of Volume that runs after the default group, or sets the Volume of the Server's output to level. Level is in db.

method:: mute
mute the server's output. This can also be toggled from the Server window with the 'm' key.

method:: unmute
unmute the server. This can also be toggled from the Server window with the 'm' key.

method:: reorder
Move the nodes in code::nodeList:: to the location specified by code::target:: and code::addAction::, placing them there in the order indicated by nodeList.
discussion::
Any nodes which have already been freed will be skipped. Passing nil for target and addAction will result in the location being the head of the default group.
code::
g = Group.new;
x = Array.fill(5, {Synth(\default)});
s.queryAllNodes;
s.reorder(x, g, \addToTail);
s.queryAllNodes;
::

method:: inputBus
Return a link::Classes/Bus:: object that represents the input audio bus.

method:: outputBus
Return a link::Classes/Bus:: object that represents the output audio bus.


subsection:: Information and debugging

method:: dumpOSC
argument:: code
table::
## 0 || turn dumping OFF.
## 1 || print the parsed contents of the message.
## 2 || print the contents in hexadecimal.
## 3 || print both the parsed and hexadecimal representations of the contents.
::

note:: teletype::/status:: messages won't be posted, when dumping is enabled::

method:: queryAllNodes
Post a representation of this Server's current node tree to the post window. See link::#-plotTree:: for a graphical variant.
discussion::
Very helpful for debugging. For local servers, this uses g_dumpTree and for remote g_queryTree. See link::Classes/Group:: and link::Reference/Server-Command-Reference:: for more info.
code::
s.boot;
s.queryAllNodes; // note the root node (ID 0) and the default group (ID 1)
s.quit;
::

method:: peakCPU, avgCPU
Get peak and average CPU usage.

method:: latency
The current latency of the server. See link::Guides/ServerTiming:: for details.

method:: sampleRate
An integer representing the nominal sample rate of the server; in other words, the sample rate that was requested of the server when it was booted.

method:: actualSampleRate
A floating-point number representing the current hardware sample rate, which may drift.

method:: numSynths
Get number of running link::Classes/Synth::s.

method:: numGroups
Get the number of link::Classes/Group::s.

method:: numUGens
Get the number of running link::Classes/UGen::s.

method:: numSynthDefs
Get number of loaded link::Classes/SynthDef::initions.

method:: pid
Get process ID of the running server (if not internal).

method:: addr
The network address of the server as a link::Classes/NetAddr::.

method:: maxNumClients
If known, the maximum number of clients allowed on the server. Otherwise, the value of link::Classes/ServerOptions#-maxLogins::, which is what will be requested after the server boots. This number is not guaranteed to be correct until link::#-serverRunning:: is code::true::.

method:: clientID
The getter returns the client ID of this client on the remote process. code::nil:: until the server is running.

The setter attempts to set the client ID of this client for the remote server process. Fails on invalid input or if the server is running. Valid inputs are in the range code::[0..(this.maxNumClients-1)]::.

method:: hasShmInterface
Returns true if a link::Classes/ServerShmInterface:: is available. See also link::Classes/Bus#Synchronous Control Bus Methods::.
The shared memory interface is initialized after first server boot.

warning::
Currently, the shared memory interface treats server port as an unique identifier. In the rare case when there are multiple servers running on the same machine and listening on the same port, this leads to the shared memory interface of one of the servers being overwritten by the other.
::

method:: serverBooting
code::true:: if the server is booting, code::false:: otherwise.

method:: hasBooted
code::true:: if the server has booted. The server is not guaranteed to have a correct clientID, nor is it guaranteed that actions in link::Classes/ServerTree:: will have run yet.

method:: serverRunning
code::true:: only if the server is fully ready. A server is fully ready once it has booted, received a reply to a code::/notify:: command, been given a client ID, and after the link::Classes/ServerTree:: has run.

method:: unresponsive
code::true:: if the server is unresponsive (specifically, if it has failed to respond after link::Classes/ServerOptions#-pingsBeforeConsideredDead:: ping attempts); code::false:: otherwise.

method:: isLocal
code::true:: if the server is running on the same machine as sclang, code::false:: otherwise.

method:: remoteControlled
code::true:: if the server is not being controlled by the machine on which it is running, code::false:: otherwise. This value is the same as code::isLocal:: unless explicitly set.

method:: userSpecifiedClientID
Deprecated in 3.9. Returns code::false::. Server:clientID can now be set while a server is off, and is locked while the server is running. Thus, userSpecifiedClientID is no longer needed internally, and meaningless.

subsection:: Message Bundling

The server provides support for automatically bundling messages. This is quite convenient in object style and ensures synchronous execution. See also link::Guides/Bundled-Messages::

method:: makeBundle
The Function code::func:: is evaluated, and all OSC messages generated by it are deferred and added to a bundle.
argument:: time
If set to nil or a number the bundle will be automatically sent and executed after the corresponding delay in seconds. If code::time:: is set to false the bundle will not be sent.
argument:: func
The function to evaluate.
argument:: bundle
allows you to pass in a preexisting bundle and continue adding to it.
returns:: The bundle so that it can be further used if needed.
discussion::
Calling code::sync:: inside func will split the bundle and wait for asynchronous actions to complete before continuing.

If an error is encountered while evaluating code::func:: this method will throw an link::Classes/Error:: and stop message deferral.
code::
s.boot;
(
// send a synth def to server
SynthDef("tpulse", { arg out=0,freq=700,sawFreq=440.0;
	Out.ar(out, SyncSaw.ar(freq,  sawFreq,0.1) )
}).add;
)

// all OSC-commands generated in the function contained below will be added to a bundle
// and executed simultaneously after 2 seconds.
(
s.makeBundle(2.0, {
	x = Synth.new("tpulse");
	a = Bus.control.set(440);
	x.map(\freq, a);
});
)
x.free;

// don't send
(
b = s.makeBundle(false, {
	x = { PinkNoise.ar(0.1) * In.kr(0, 1); }.play;
});
)
// now pass b as a pre-existing bundle, and start both synths synchronously
(
s.makeBundle(nil, { // nil executes ASAP
	y = { SinOsc.kr(0.2).abs }.play(x, 0, 0, \addBefore); // sine envelope
}, b);
)
x.free; y.free;

// Throw an Error
(
try {
	s.makeBundle(nil, {
		s.farkermartin;
	});
} { |error|
	("Look Ma, normal operations resume even though:\n" + error.errorString).postln;
	x = { FSinOsc.ar(440, 0, 0.2) }.play; // This works fine
}
)
x.free;

// use sync
(
s.makeBundle(nil, {
	b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
	s.sync; // wait until load is done and then send the rest of the bundle
	x = { PlayBuf.ar(1, b) * 0.5 }.play;
});
)
x.free; b.free;
::

method:: bind
Just as in code::makeBundle::, the Function code::func:: is evaluated, and all OSC messages generated by it are deferred and added to a bundle, which is sent to the server, using the server default latency.
discussion::
code::
(
s.bind {
	a = { |freq=100| SinOsc.ar(freq, LFTri.ar(freq)) * 0.2 }.play;
	s.sync;
	a.set(\freq, 400);
}
)
::

subsection:: Shared Controls

The internal server has a number of shared control buses. Their values can be set or polled using the methods below.

method:: getSharedControl
get the current value of a shared control bus. num is the index of the bus to poll. This command is synchronous and only works with the internal server.

method:: setSharedControl
set the current value of a shared control bus to value. num is the index of the bus to set. This command is synchronous and only works with the internal server.

method:: allocSharedControls
set the number of shared control buses. Must be done before the internal server is booted. The default is 1024.

subsection:: Persistent Node Trees

The class link::Classes/ServerTree:: can be used to store functions which will be evaluated after the server is booted, after all nodes are freed, and after cmd-. is pressed.
This allows, for example, for one to create a persistent basic node structure. ServerTree is evaluated in the method initTree after the default group is created, so its existence can be relied upon.

method:: initTree
This method initializes the link::Reference/default_group:: and runs link::Classes/ServerTree::.
discussion::
This method is called automatically when you boot a Server from the language. N.B. If you started a server app from the command line you will have to call initTree manually if you need this functionality.
code::
s.quit;
f = {Group.new(s.defaultGroup); "Other code can be evaluated too".postln;};
ServerTree.add(f);
s.boot;
s.queryAllNodes; // note the group within the default group
ServerTree.remove(f);
::
link::Classes/ServerBoot:: and link::Classes/ServerQuit:: provide similar functionality at boot and quit times.

subsection:: GUI methods

method:: makeGui
Create and show the server window. The window responds to a number of keyboard shortcuts:
table::
## strong::key:: || strong::action::
## teletype::n:: || Post a representation of this Server's current node tree to the post window. (See link::#-queryAllNodes::)
## teletype::N:: || As 'n' above but include controls.
## teletype::l:: || Show input/output level meters. (See link::#-meter::)
## teletype::p:: || Show graphical view of the node tree. (See link::#-plotTree::)
## (space) || Boot server if not already booted. (See link::#-boot::)
## teletype::s:: || Show scope window. (See link::#-scope::)
## teletype::f:: || Show frequency analyzer window. (See link::#-freqscope::)
## teletype::d:: || Toggle dumping of OSC messages.
## teletype::m:: || Toggle mute.
## teletype::0:: || Reset volume to 0 db.
::

method:: makeWindow
On most platforms, this is equivalent to code::makeGui::.
If you are running SuperCollider on Emacs, it makes a server view composed of Emacs widgets.

method:: scope
Open a scope window showing the output of the Server.
see link::Classes/Stethoscope:: for further details.

argument:: numChannels
the number of channels to be scoped out. The default is this server's options' numOutputBusChannels.
argument:: index
the first channel to be output. The default is 0.
argument:: bufsize
the size of the buffer for the ScopeView. The default is 4096.
argument:: zoom
a zoom value for the scope's X-axis. Larger values show more. The default is 1.
argument:: rate
whether to display audio or control rate buses (either \audio or \control)

method:: freqscope
Show frequency analyzer window.

method:: meter
Show input/output level meters.

method:: plotTree
Plot the node/group tree. As link::#-queryAllNodes:: but graphical.

argument:: interval
Polling interval.

method:: plotTreeView
Plot the node/group tree graphically on a given view.

argument:: interval
Polling interval.

argument:: parent
Parent view.

argument:: actionIfFail
Function to be evaluated in case communication with the server cannot be established.

returns:: Function to be evaluated in order to clean up all actions performed inside the method. To be called for instance by the onClose method of the enclosing window.

subsection:: Recording Support

The following methods are for convenience use. For recording with sample-accurate start and stop times you should make your own nodes. See the link::Classes/DiskOut:: helpfile for more info. For non-realtime recording, see the link::Guides/Non-Realtime-Synthesis:: helpfile.

This functionality is also available through the recording button on the server windows.
Pressing it once calls record, and pressing it again calls stopRecording (see below). When doing so the file created will be in your recordings folder and be named for the current date and time.
The default location of the recordings folder varies from platform to platform but is always stored in code::thisProcess.platform.recordingsDir::. Setting this variable allows you to change the default.

NOTE::
record creates the recording synth after the Server's default group and uses In.ar. Thus if you add nodes after the recording synth their output will not be captured.
To avoid this, either use Node objects (which use the default node as their target) or (when using messaging style) use a target nodeID of 1.
code::
s.sendMsg("/s_new", "default", s.nextNodeID, 1,1);
::
::

For more detail on this subject see link::Guides/Order-of-execution::, link::Reference/default_group::, and link::Guides/NodeMessaging::.

See link::Classes/SoundFile:: for information on the various sample and header formats.
Not all sample and header formats are compatible. Note that the sampling rate of the output file will be the same as that of the server app. This can be set using the Server's link::Classes/ServerOptions::.

Example:
code::
s.boot; // start the server

// something to record
(
SynthDef("bubbles", { |out|
	var f, sound;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps; // glissando function
	sound = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(out, sound);
}).add;
)

x = Synth.new("bubbles");

s.prepareForRecord; // if you want to start recording at a precise moment in time, you have to call this first.

s.record;

s.pauseRecording; // pausable

s.record // start again

s.stopRecording; // this closes the file and deallocates the buffer recording node, etc.

x.free; // stop the synths

// look in your recordings folder and you'll find a file named for this date and time
::

The recording is done via an of link::Classes/Recorder:: - a server holds one instance implicitly.

method:: prepareForRecord
Allocates the necessary buffer, etc. for recording the server's output. (See code::record:: below.)
argument:: path
a link::Classes/String:: representing the path and name of the output file. If the directory does not exist, it will be created for you. (Note, however, that if this fails for any reason, the recording will also fail.)
argument:: numChannels
a link::Classes/String:: the number of output channels to record.

discussion::
If you do not specify a path than a file will be created in your recordings folder (see the note above on this) called SC_thisDateAndTime. Changes to the header or sample format, or to the number of channels must be made strong::before:: calling this.

method:: record
Starts or resumes recording the output.
argument:: path
this is optional, and is passed to code::prepareForRecord:: (above).
argument:: bus
the bus to record - defaults to 0
argument:: numChannels
the number of channels to record - defaults to 2
argument:: node
the node to record - defaults to server rootnode
argument:: duration
duration to record - defaults to inf

discussion::
If you have not called prepareForRecord first (see above) then it will be invoked for you (but that adds a slight delay before recording starts for real).

method:: pauseRecording
Pauses recording. Can be resumed by executing record again.

method:: stopRecording
Stops recording, closes the file, and frees the associated resources.
discussion::
You must call this when finished recording or the output file will be unusable. Cmd-. while recording has the same effect.


method:: recChannels
Get/set the number of channels (int) to record. By default this is set to 2 (stereo) but can be increased to record soundfiles with many more channels. Must be called strong::before:: prepareForRecord.

method:: recHeaderFormat
Get/set the header format (string) of the output file. The default is "wav". Must be called strong::before:: prepareForRecord.

method:: recSampleFormat
Get/set the sample format (string) of the output file. The default is "float" (32-bit). Common options include "int24" for 24-bit audio and "int16" for 16-bit audio. Must be called strong::before:: prepareForRecord.

method::recBufSize
Get/set the size of the link::Classes/Buffer:: to use with the link::Classes/DiskOut:: UGen. This must be a power of two. The default is the code::sampleRate.nextPowerOfTwo:: or the first power of two number of samples longer than one second. Must be called strong::before:: prepareForRecord.

subsection:: Asynchronous Commands

The server provides support for waiting on the completion of asynchronous OSC-commands such as reading or writing sound files. N.B. The following methods must be called from within a running link::Classes/Routine::. Explicitly passing in a link::Classes/Condition:: allows multiple elements to depend on different conditions. The examples below should make clear how all this works.

method:: bootSync
Boot the Server and wait until it has completed before resuming the thread.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.

method:: sendMsgSync
Send the following message to the server and wait until it has completed before resuming the thread.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.
argument:: ... args
one or more valid OSC messages.

method:: sync
Send a code::/sync:: message to the server, which will reply with the message code::/synced:: when all pending asynchronous commands have been completed.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.
argument:: bundles
one or more OSC messages which will be bundled before the sync message (thus ensuring that they will arrive before the /sync message). argument:: latency
allows for the message to be evaluated at a specific point in the future.

discussion::
This may be slightly less safe than sendMsgSync under UDP on a wide area network, as packets may arrive out of order, but on a local network should be okay. Under TCP this should always be safe.
code::
(
Routine.run {
	var c;

	// create a condition variable to control execution of the Routine
	c = Condition.new;

	s.bootSync(c);
	\BOOTED.postln;

	s.sendMsgSync(c, "/b_alloc", 0, 44100, 2);
	s.sendMsgSync(c, "/b_alloc", 1, 44100, 2);
	s.sendMsgSync(c, "/b_alloc", 2, 44100, 2);
	\b_alloc_DONE.postln;
};
)

(
Routine.run {
	var c;

	// create a condition variable to control execution of the Routine
	c = Condition.new;

	s.bootSync(c);
	\BOOTED.postln;

	s.sendMsg("/b_alloc", 0, 44100, 2);
	s.sendMsg("/b_alloc", 1, 44100, 2);
	s.sendMsg("/b_alloc", 2, 44100, 2);
	s.sync(c);
	\b_alloc_DONE.postln;
};
)
::

subsection:: Bela

method:: belaScope
Scope a number of channels from a Bus on this Server, to Bela's Oscilloscope (see link::Classes/BelaScope:: for required setup).
It is required that this Server is running on a Bela, and that it is thus capable of using BelaScope.

argument:: scopeChannel
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument:: index
This server's bus index to scope. Defaults to 0.

argument:: numChannels
Number of channels to send to BelaScope, starting from the index supplied. Defaults to 2, or to link::Classes/ServerOptions#-numOutputBusChannels:: if index is 0.

returns:: A link::Classes/Synth::, linking this Server's desired bus channels to BelaScope's bus.


class:: ServerBoot
summary:: register actions to be taken when a server has booted
related:: Classes/Server, Classes/ServerQuit, Classes/ServerTree, Classes/StartUp
categories:: Control

description::
The singleton ServerBoot provides a place for registering functions and objects for events that should happen when a given server has booted.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass


TITLE:: ServerMeter
summary:: Graphical feedback window showing input/output levels
categories:: GUI>Interfaces
related:: Classes/Stethoscope, Classes/FreqScope, Classes/ServerMeterView

DESCRIPTION::
A ServerMeter is a simple graphical display showing the volume levels of inputs and outputs on the server.

Also see:
link::Classes/Server#-meter::

CLASSMETHODS::

METHOD:: new
Create a new ServerMeter.

ARGUMENT:: server
The link::Classes/Server:: whose inputs and outputs you wish to visualize.

ARGUMENT:: numIns
The number of inputs you want to display (starts counting at the first input bus, similar to link::Classes/SoundIn::)

ARGUMENT:: numOuts
The number of outputs you want to display (starts counting at bus 0)

returns:: A reference to the newly created ServerMeter


INSTANCEMETHODS::

METHOD:: window
Get a reference to the link::Classes/Window:: of this ServerView

returns:: a link::Classes/Window:: reference

METHOD:: meterView
Get a reference to the link::Classes/ServerMeterView:: of this ServerView

returns:: a link::Classes/ServerMeterView:: reference

note::
A ServerMeter encapsulates both a link::Classes/Window:: and a link::Classes/ServerMeterView:: within that Window. For more information about Windows and views see link::Guides/GUI-Introduction#Basic elements: Windows, views and containers::
::


EXAMPLES::

code::

s = Server.internal; // use the internal server
s.boot;
// display 4 input channels & main stereo output
m = ServerMeter.new(s, 4, 2);
::


TITLE:: ServerMeterView
summary:: A GUI widget that displays input/output levels
categories:: GUI>Views
related:: Classes/ScopeView, Classes/FreqScopeView, Classes/ServerMeter

DESCRIPTION::
A link::Classes/ServerMeterView:: is a modular widget for showing the volume levels of inputs/outputs on the server. link::Classes/ServerMeterView:: can be embedded inside of your custom graphical user interfaces just like a button or slider.

note::
If you are looking for a quick input/output levels display without having to build your own GUI from scratch, see link::Classes/ServerMeter:: and link::Classes/Server#-meter::
::



CLASSMETHODS::

METHOD:: height
Get the height in pixels of the standard link::Classes/ServerMeterView:: widget

returns:: an link::Classes/Integer::

METHOD:: getWidth
Get the width in pixels of a link::Classes/ServerMeterView:: widget with the given number of inputs and outputs

ARGUMENT:: numIns
number of inputs used to calculate the width

ARGUMENT:: numOuts
number of outputs used to calculate the width

ARGUMENT:: server
the server

returns:: an link::Classes/Integer::

METHOD:: new
Create a new link::Classes/ServerMeterView:: instance

ARGUMENT:: aserver
The link::Classes/Server:: whose inputs/outputs will be monitored

ARGUMENT:: parent
The parent link::Classes/View:: or link::Classes/Window:: where the new link::Classes/ServerMeterView:: will be embedded.

ARGUMENT:: leftUp
Where to position the new link::Classes/ServerMeterView:: inside the parent. strong::leftUp:: must be a link::Classes/Point::, describing where to place the upper left corner of the new link::Classes/ServerMeterView::.

ARGUMENT:: numIns
The number of inputs to monitor

ARGUMENT:: numOuts
The number of outputs to monitor

returns:: A new link::Classes/ServerMeterView::


INSTANCEMETHODS::

METHOD:: view
get the link::Classes/CompositeView:: used to construct the various elements of the link::Classes/ServerMeterView:: widget

returns:: a link::Classes/CompositeView::

METHOD:: remove
Removes this link::Classes/ServerMeterView:: from its parent view (if any) and then destroys it. Once this method is called you can no longer use this link::Classes/ServerMeterView::.

METHOD:: start
Enable the monitoring of input/outputs

returns:: this link::Classes/ServerMeterView::

METHOD:: stop
Disable the monitoring of input/outputs

returns:: this link::Classes/ServerMeterView::


PRIVATE:: setSynthFunc, startResponders, init


EXAMPLES::

subsection::Simple Usage

code::
// make a window and embed a ServerMeterView inside of it.
w = Window.new("Server Levels");
ServerMeterView.new(s, w, 0@0, 2, 2);
w.front; // show the window
::

subsection::A More Complex Example

code::
// make a GUI to monitor two servers running simultaneously
s = Server.local;
q = Server.internal;
s.boot; q.boot; // wait a moment for the servers to boot

// make a window big enough to hold 2 ServerMeterViews
r = Rect(0, 0, ServerMeterView.getWidth(2, 2) * 2, ServerMeterView.height)
w = Window.new("Local | Internal", r);

// make one ServerMeterView to monitor the input/output of each server
ServerMeterView.new(s, w, Point(0,0), 2, 2);
ServerMeterView.new(q, w, Point(ServerMeterView.getWidth(2,2), 0), 2, 2);
w.front; // show the window
::


class:: ServerOptions
summary:: Encapsulates commandline and other options for a Server
categories:: Server
related:: Classes/Server, Reference/Server-Architecture, Reference/Server-Command-Reference, Reference/AudioDeviceSelection

description::

ServerOptions encapsulates various options for a server app within an object. This makes it convenient to launch multiple servers with the same options, or to archive different sets of options, etc.
Every link::Classes/Server:: has an instance of ServerOptions created for it if one is not passed as the options argument when the Server object is created. (This is the case for example with the local and internal Servers which are created at startup.)

A Server's instance of ServerOptions is stored in its options instance variable, which can be accessed through corresponding getter and setter methods.

N.B. A ServerOptions' instance variables are translated into commandline arguments when a server app is booted. Thus a running Server must be rebooted before changes will take effect. There are also a few commandline options which are not currently encapsulated in ServerOptions. See link::Reference/Server-Architecture:: for more details.

ClassMethods::
private:: prListDevices

method:: new
Create and return a new instance of ServerOptions.

method:: devices
Return an Array of Strings listing the audio devices currently available on the system.

method:: inDevices
Return an Array of Strings listing the audio devices currently available on the system which have input channels.

method:: outDevices
Return an Array of Strings listing the audio devices currently available on the system which have output channels.

note:: The above three methods are not available if SuperCollider is built with JACK backend (by default on Linux). Also see link::Reference/AudioDeviceSelection:: for more information on selecting audio device.::

instancemethods::
subsection:: The Options

method:: blockSize
The number of samples in one control period. The default is 64.

method:: device
A String that allows you to choose a sound device to use as input and output. The default, code::nil::, will use the system's default input and output device(s). See link::Reference/AudioDeviceSelection:: for more details.

method:: inDevice
A String that allows you to choose an input sound device. The default, code::nil::, will use the system's default input device. See link::Reference/AudioDeviceSelection:: for more details.

method:: outDevice
A String that allows you to choose an output sound device. The default, code::nil::, will use the system's default output device. See link::Reference/AudioDeviceSelection:: for more details.

method:: hardwareBufferSize
The preferred hardware buffer size. If non-nil the server app will attempt to set the hardware buffer frame size. Not all sizes are valid. See the documentation of your audio hardware for details. Default value is nil.

method:: initialNodeID
By default, the Server object in the client begins allocating node IDs at 1000, reserving 0-999 for "permanent" nodes. You may change this default here.

method:: inputStreamsEnabled
A String which allows turning off input streams that you are not interested in on the audio device. If the string is "01100", for example, then only the second and third input streams on the device will be enabled. Turning off streams can reduce CPU load. The default value is nil.

method:: loadDefs
A Boolean indicating whether or not to load the synth definitions in synthdefs/ (or anywhere set in the environment variable SC_SYNTHDEF_PATH) at startup. The default is true.

method:: maxNodes
The maximum number of nodes. The default is 1024.

method:: maxSynthDefs
The maximum number of synthdefs. The default is 1024.

method:: memSize
The number of kilobytes of real time memory allocated to the server. This memory is used to allocate synths and any memory that unit generators themselves allocate (for instance in the case of delay ugens which do not use buffers, such as CombN), and is separate from the memory used for buffers. Setting this too low is a common cause of 'exception in real time: alloc failed' errors. The default is 8192.

method:: numAudioBusChannels
The number of audio rate busses, which includes input and output busses. The default is 1024.

method:: numBuffers
The number of global sample buffers available. (See Buffer.) The default is 1024.

method:: numControlBusChannels
The number of internal control rate busses. The default is 16384.

method:: numInputBusChannels
The number of audio input bus channels. This need not correspond to the number of hardware inputs. The default is 2.

method:: numOutputBusChannels
The number of audio output bus channels. This need not correspond to the number of hardware outputs (this can be useful for instance in the case of recording). The default is 2.

method:: numRGens
The number of seedable random number generators. The default is 64.

method:: numWireBufs
The maximum number of buffers that are allocated to interconnect unit generators. (Not to be confused with the global sample buffers represented by Buffer.) This sets the limit of complexity of SynthDefs that can be loaded at runtime. This value will be automatically increased if a more complex def is loaded at startup, but it cannot be increased thereafter without rebooting. The default is 64.

method:: outputStreamsEnabled
A String which allows turning off output streams that you are not interested in on the  audio device. If the string is "11000", for example, then only the first two output streams on the device will be enabled. Turning off streams can reduce CPU load.

method:: protocol
A Symbol representing the communications protocol. Either code::\udp:: or code::\tcp::. The default is code::\udp::.

method:: bindAddress
The IP address that the server's TCP or UDP socket is listening on. The default value is code::"127.0.0.1"::, meaning only listen to OSC messages on the host.

warning::
Until SuperCollider 3.10.3, this was set to code::"0.0.0.0":: (listen on all network interfaces). However, this is a dangerous default configuration — for most users working on laptops connected to WiFi, this means that anyone on your local network can send OSC messages to the server. code::"0.0.0.0":: is only useful if you are running networked server/client, and only safe if your networking is properly configured.

Before SuperCollider 3.12 supernova listened to all network interfaces and ignored the code::bindAddress:: option. In later versions the behavior is identical to scsynth. 
::

method:: remoteControlVolume
A Boolean indicating whether this server should allow its volume to be set remotely. The default value is code::false::.

method:: sampleRate
The preferred sample rate. If non-nil the server app will attempt to set the sample rate of the hardware. The hardware has to support the sample rate that you choose.

note:: On Windows, leaving the code::sampleRate:: as code::nil:: for an code::ASIO:: device will likely result in setting the hardware to run at 44100 Hz.::

method:: verbosity
Controls the verbosity of server messages. A value of 0 is normal behaviour. -1 suppresses informational messages. -2 suppresses informational and many error messages, as well as messages from Poll. The default is 0.

method:: zeroConf
A Boolean indication whether or not the server should publish its port using zero configuration networking, to facilitate network interaction. This is true by default; if you find unacceptable delays (beachballing) upon server boot, you can try setting this to false.

method:: ugenPluginsPath
A path or an Array of paths. If non-nil, the standard paths are NOT searched for plugins. This corresponds with the option "-U".

method:: restrictedPath
Allows you to restrict the system paths in which the server is allowed to read/write files during running. A nil value (the default) means no restriction. Otherwise, set it as a string representing a single path.

method:: threads
Number of audio threads that are spawned by supernova. For scsynth this value is ignored. If it is code::nil::or 0, it
uses the one thread per CPU. Default is code::nil::.

method:: useSystemClock
Tells supernova whether to sync to the driver's sample clock, or to the system clock.
note:: scsynth always uses system clock and this value is ignored.::
list::
## code::true:: (default) -- Use the system clock. Timestamped messages will maintain consistent
latency over long sessions, but may not be perfectly sample-accurate.
## code::false:: -- Use the sample clock. This helps to
support sample-accurate scheduling; however, messaging latency from
the SuperCollider language will drift over long periods of time.
::

method:: memoryLocking
A Boolean indicating whether the server should try to lock its memory into physical RAM. Default is code::false::.

method:: maxLogins
An Integer indicating the maximum number of clients which can simultaneously receive notifications from the server. When using TCP this is also the maximum number of simultaneous connections. This is also used by the language to split ranges of link::Classes/Node##Nodes::, link::Classes/Buffer##Buffers::, or link::Classes/Bus##Busses::. In multi-client situations you will need to set this to at least the number of clients you wish to allow. This must be the same in the Server instances on every client. The default is 1. The maximum is 32.

method:: safetyClipThreshold
note:: MacOS only::
A Float indicating a safety threshold for output values to be clipped to. This is necessary on macOS because setting a low system volume doesn't prevent output values greater than +/- 1 from sounding extremely loud, which can happen by mistake, e.g. when sending a negative coefficient to a filter. With this threshold, values are clipped just before being written to hardware output busses, which does not affect the recording. However, the signal will be affected if it's above the threshold and the sound is routed to other apps using 3rd-party software.
Defaults to a threshold of 1.26 (ca. 2 dB), to save some ears and still allow some headroom. Setting safetyClipThreshold to code::inf::, code::0::, or a negative value, disables clipping altogether.

subsection:: Other Instance Methods
method:: asOptionsString
argument:: port
The port number for the resulting server app. Default value is 57110.
Returns:: a String specifying the options in the format required by the command-line server app (scsynth or supernova).

method:: firstPrivateBus
Returns:: the index of the first audio bus on this server which is not used by the input and output hardware.

method:: pingsBeforeConsideredDead
Number of failed pings (attempts to contact server process) before server is considered dead.
Default value is 5.



Examples::
code::
// Get the default server's options

o = Server.default.options;

// Post the number of output channels

o.numOutputBusChannels.postln;

// Set them to a new number

o.numOutputBusChannels = 6; // The next time it boots, this will take effect

// specify a device

o.device ="MOTU Traveler"; 	// use a specific soundcard
o.device = nil;			// use the system default soundcard

// finally, boot the server

Server.default.boot;
// or, if the server was already running, reboot it
Server.default.reboot;


// ServerOptions and multiple servers

// Create a new instance of ServerOptions for

p = ServerOptions.new;

// Set the memory size to twice the default

p.memSize = 4096;

// Create a new Server on the local machine using o for its options

t = Server(\Local2, NetAddr("127.0.0.1", 57111), p);
t.makeWindow;
t.boot;
t.quit;
::


class:: ServerQuit
summary:: register actions to be taken when a server quits
related:: Classes/Server, Classes/ServerBoot, Classes/ServerTree, Classes/ShutDown
categories:: Control

description::
The singleton ServerQuit provides a place for registering functions and objects for events that should happen when a given server quits.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass


TITLE:: ServerStatusWatcher
summary:: Observes and updates Server status
categories:: Server
related:: Classes/Server

DESCRIPTION::
An object that observes a link::Classes/Server:: object by managing status requests and updates.
ServerStatusWatcher is a client-side server implementation detail, and users are not expected to
need to use it directly. A Server's status watcher can be accessed via
link::Classes/Server#-statusWatcher::.

CLASSMETHODS::

METHOD:: new
Creates a new ServerStatusWatcher.

ARGUMENT:: server
An instance of Server.

returns:: The constructed ServerStatusWatcher.


INSTANCEMETHODS::
private:: prSendNotifyRequest, prFinalizeBoot


class:: ServerTree
summary:: register actions to be taken to initialise a basic tree of groups on the server
related:: Classes/Server, Classes/ServerQuit, Classes/ServerBoot, Classes/CmdPeriod
categories:: Control

description::
The singleton ServerTree provides a place for registering functions and objects for events that should happen when a given server has booted and when all synths are freed. This is to initialise a basic tree of groups on the server.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass


CLASS::Set
summary::a set according to equality
related::Classes/IdentitySet, Classes/List, Classes/Dictionary
categories::Collections>Unordered

DESCRIPTION::
A Set is s collection of objects, no two of which are equal. Most of its methods are inherited from Collection. The contents of a Set are unordered. You must not depend on the order of items in a set. For an ordered set, see link::Classes/OrderedIdentitySet::.

INSTANCEMETHODS::

private::initSet, putCheck, fullCheck, grow, noCheckAdd

subsection::Adding and Removing

method::add
Add an Object to the Set. An object which is equal to an object already in the Set will not be added.
code::
Set[1, 2, 3].add(4).postln;
Set[1, 2, 3].add(3).postln;
Set["abc", "def", "ghi"].add("jkl").postln;
Set["abc", "def", "ghi"].add("def").postln;
::

method::remove
Remove an Object from the Set. Element is checked for equality (not for identity).
code::
Set[1, 2, 3].remove(3).postln;
::

subsection::Testing

method::includes
Returns true if the specified item is present in the Set. Elements are checked for equality (not for identity).
code::
Set[1, 2, 3].includes(2).postln;
::

method::findMatch
Returns the item, if it is present in the set. Otherwise returns nil. Element is checked for equality (not for identity).
code::
Set[1, 2, 3].findMatch(3).postln;
::

subsection::Iteration

method::do
Evaluates function for each item in the Set. The function is passed two arguments, the item and an integer index.
code::
Set[1, 2, 3, 300].do({ arg item, i; item.postln });
::

method::keyAt
Returns the object at the internal strong::index::. This index is not deterministic.

subsection::Set specific operations

method::sect, &
Return the set theoretical intersection of this and strong::that::. The function will search for objects occurring in both sets and return a new set containing those.
Elements are checked for equality (not for identity).
code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
sect(a, b);
a & b // shorter syntax
::

method::union, |
Return the set theoretical union of this and strong::that::. The function combines the two sets into one without duplicates.
Elements are checked for equality (not for identity).
code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
union(a, b);
a | b // shorter syntax
::

method::difference, -
Return the set of all items which are elements of this, but not of strong::that::. Elements are checked for equality (not for identity).
code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
difference(a, b);
a - b // shorter syntax
::

method::symmetricDifference, --
Return the set of all items which are not elements of both this and strong::that::.
Elements are checked for equality (not for identity).
code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
symmetricDifference(a, b);
a -- b // shorter syntax
::

method::isSubsetOf
Returns true if all elements of this are also elements of strong::that::. Elements are checked for equality (not for identity).
Since Set is an unordered collection, order doesn't matter in this comparison.
code::
a = Set[1, 2, 3, 4];
Set[1, 2].isSubsetOf(a); // true
Set[1, 5].isSubsetOf(a); // false
::

EXAMPLES::

code::
a = Set[1, 2, 3, 4];
b = a.powerset; // set of all parts
a.isSubsetOf(b); // false: no set is ever part of itself.
b.asArray.reduce(\union) == a; // true parts may not contain other elements that original
b.asArray.reduce(\difference).isEmpty; // true.
::

code::
// you can use Set to efficiently remove duplicates from an array:

a = [1, 2, 3, 4, 3, 5, 5, 2, 2, 1];
a.as(Set);		// convert to set
a.as(Set).as(Array);	// and convert back
::


class:: SetResetFF
summary:: Set-reset flip flop.
related:: Classes/ToggleFF
categories::  UGens>Triggers


Description::

Output is set to 1.0 upon receiving a trigger in the trig input, and to
0.0 upon receiving a trigger in the reset input. Once the flip flop is
set to zero or one further triggers in the same input are have no effect.
One use of this is to have some precipitating event cause something to
happen until you reset it.

If both inputs receive a trigger at the same time, the teletype::reset:: input takes precedence. The output will be 0. See the examples below.

classmethods::

method::ar, kr

argument::trig

The trigger that sets output to 1. Trigger can be any signal.
A trigger happens when the signal changes from non-positive to
positive.


argument::reset

The trigger that sets output to 0. Trigger can be any signal.
A trigger happens when the signal changes from non-positive to
positive.


Examples::

code::

(
play({
	a = Dust.ar(5); // the set trigger
	b = Dust.ar(5); // the reset trigger
	SetResetFF.ar(a,b) * BrownNoise.ar(0.2);

}))

::

subsection::Simultaneous triggers

Here, 'reset' is triggered twice as often as 'trig'. Since 'trig' is always matched by a 'reset', the output is 0. (If 'trig' took precedence, you would have a 50%-duty-cycle pulse wave.)

code::
a = { SetResetFF.kr(Impulse.kr(50), Impulse.kr(100)) }.plot(duration: 0.1);
::

You can reverse this behavior, by reversing the inputs so that SetResetFF is triggered twice as often as resetting. This results in a signal that is 0 initially and switches to 1 halfway through the cycle: emphasis::reset, then trigger::. To make it emphasis::trigger, then reset::, invert the phase: code::1 - SetResetFF::.

code::
a = { 1 - SetResetFF.kr(Impulse.kr(100), Impulse.kr(50)) }.plot(duration: 0.1);
::



class:: Shaper
summary:: Wave shaper.
related:: Classes/Index, Classes/WrapIndex, Classes/Wavetable
categories::  UGens>Buffer

Description::
Performs waveshaping on the input signal by indexing into the table.

classmethods::
method::ar, kr

argument::bufnum
The number of a buffer filled in wavetable format containing the
transfer function.

argument::in
The input signal.


Examples::
code::
s.boot;

b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])});

(
{
	Shaper.ar(
		b,
		SinOsc.ar(300, 0, Line.kr(0,1,6)),
		0.5
	)
}.scope;
)

b.free;
::

image::chebyshevpolynomials.png::

Wave shaping transfer functions are typically designed by using Chebyshev polynomials to control which harmonics are generated when a cosine wave is passed in. The implementation in SuperCollider compensates for the DC offset due to even polynomial terms, making sure that when 0 is put into the transfer function, you get 0 out. By default, normalization is set to true, which avoids output overload. If you want to construct a transfer function without this, you need to be careful with the final output scaling, since it could easily overload the -1 to 1 range for audio.
code::
// I want the first harmonic at 0.25 amplitude, second at 0.5, third at 0.25
b = Buffer.alloc(s, 512, 1, {arg buf; buf.chebyMsg([0.25,0.5,0.25], false)});

(
{
	Shaper.ar(
		b,
		SinOsc.ar(440, 0.5pi, Line.kr(0,1,6)), //input cosine wave
		0.5 //scale output down because otherwise it goes between -1.05 and 0.5, distorting...
	)
}.scope;
)

b.free;
::

For those who like to make their own wavetables for arbitrary shapers, your buffer must be in wavetable format to have a valid transfer function. Wavetable format is a special representation to make linear interpolation faster (see at the bottom of this file). You don't have to worry about this directly, because there are two straight forward ways to get wavetables into a server buffer. First, the server can generate them (see the Buffer help file for the methods sine1, sine2, sine3 and cheby):
code::
b = Buffer.alloc(s, 1024, 1);
b.cheby([1, 0.5, 1, 0.125]);

(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)

b.free;
::
Or, you can calculate the transfer function in a client-side array (Signal class) then convert it to a wavetable and send the data over.
code::
b = Buffer.alloc(s, 1024, 1);

//size must be power of two plus 1
t = Signal.chebyFill(513,[1, 0.5, 1, 0.125]);

// linear function
t.plot

// t.asWavetableNoWrap will convert it to the official Wavetable format at next power of two size
b.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here

b.plot

(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)

b.free;
::

This way of working then allows you to get creative with your transfer functions!
code::
b = Buffer.alloc(s, 1024, 1);

// or, for an arbitrary transfer function, create the data at 1/2 buffer size + 1
t = Signal.fill(513, { |i| i.linlin(0.0, 512.0, -1.0, 1.0) });

// linear function
t.plot

// t.asWavetable will convert it to the official Wavetable format at twice the size
b.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here

// shaper has no effect because of the linear transfer function
(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)


// now for a twist
(
a = Signal.fill(256, { |i|
	var t = i/255.0;
	t + (0.1 * (max(t, 0.1) - 0.1) * sin(2pi * t * 80 + sin(2pi * 25.6 * t)))
})
);

a.plot

d = (a.copy.reverse.neg) ++(Signal[0])++ a;

d.plot

d.size	//must be buffer size/2 + 1, so 513 is fine

b.sendCollection(d.asWavetableNoWrap);  // may also use loadCollection here

b.plot // wavetable format!

// test shaper
(
{
	Shaper.ar(
		b,
		SinOsc.ar(440, 0.5, Line.kr(0,0.9,6))
	)
}.scope
)
::




class:: SharedIn
summary:: Read from a shared control bus.
related:: Classes/SharedOut
categories::  UGens>InOut


Description::

warning::
SharedIn has been deprecated. Synchronous access to busses on local servers is possible via
link::Classes/Bus#-getSynchronous:: and link::Classes/Bus#-setSynchronous::
::

Reads from a control bus shared between the internal server and the SC
client. Control rate only. Writing to a shared control bus from the
client is synchronous. When not using the internal server use node
arguments or the set method of Bus (or /c_set in messaging style).


classmethods::

method::kr

argument::bus

The index of the shared control bus to read from.


argument::numChannels

the number of channels (i.e. adjacent buses) to read in. The
default is 1. You cannot modulate this number by assigning it to
an argument in a SynthDef.


Examples::

code::

(
// only works with the internal server
s = Server.internal;
s.boot;
)

(
SynthDef("help-SharedIn1", {
	Out.ar(0, SinOsc.ar(Lag.kr(SharedIn.kr(0, 1), 0.01), 0, 0.2));
}).add;
SynthDef("help-SharedIn2", {
	Out.ar(1, SinOsc.ar(Lag.kr(SharedIn.kr(0, 1), 0.01, 1.5), 0, 0.2));
}).add;
)

(
s.setSharedControl(0, 300); // an initial value
s.sendMsg(\s_new, "help-SharedIn1", x = s.nextNodeID, 0, 1);
s.sendMsg(\s_new, "help-SharedIn2", y = s.nextNodeID, 0, 1);

Routine({
	30.do({
		s.setSharedControl(0, 300 * (10.rand + 1));
		0.2.wait;
	});
	s.sendMsg(\n_free, x);
	s.sendMsg(\n_free, y);
}).play;
)


s.quit;

::



class:: SharedOut
summary:: Write to a shared control bus.
related:: Classes/SharedIn
categories::  UGens>InOut


Description::

warning::
SharedIn has been deprecated. Synchronous access to busses on local servers is possible via
link::Classes/Bus#-getSynchronous:: and link::Classes/Bus#-setSynchronous::
::


Reads from a control bus shared between the internal server and the SC
client. Control rate only. Reading from a shared control bus on the
client is synchronous. When not using the internal server use the get
method of Bus (or /c_get in messaging style) or
link::Classes/SendTrig:: with an link::Classes/OSCFunc::.


classmethods::

method::kr

argument::bus

The index of the shared control bus to write to.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
// only works with the internal server
s = Server.internal;
s.boot;
)

(
SynthDef("help-SharedOut", {
	SharedOut.kr(0, SinOsc.kr(0.2));
}).add;
)

(
s.sendMsg(\s_new, "help-SharedOut", x = s.nextNodeID, 0, 1);
s.sendMsg(\n_trace, x);

// poll the shared control bus
Routine({
	30.do({
		s.getSharedControl(0).postln;
		0.2.wait;
	});
}).play;
)


s.quit;

::



class:: ShutDown
summary:: register functions to be evaluated before system shuts down
related:: Classes/StartUp, Classes/ServerQuit, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
ShutDown registers functions to perform an action before system shut down.

ClassMethods::

method::run
Call the object in order.


CLASS::Signal
summary::Sampled audio buffer
related::Classes/Wavetable
categories:: Collections>Ordered

DESCRIPTION::
A Signal is a FloatArray that represents a sampled function of time buffer.  Signals support math operations.

CLASSMETHODS::

method::sineFill
Fill a Signal of the given size with a sum of sines at the given amplitudes and phases. The Signal will be normalized.
code::
Signal.sineFill(1000, 1.0/[1, 2, 3, 4, 5, 6]).plot;
::
argument::size
the number of samples in the Signal.
argument::amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.
argument::phases
an Array of phases in radians for each harmonic beginning with the fundamental.

method::chebyFill
Fill a Signal of the given size with a sum of Chebyshev polynomials at the given amplitudes. For eventual use in waveshaping by the Shaper ugen; see link::Classes/Shaper:: helpfile and link::Classes/Buffer#-cheby#Buffer:cheby:: too.
argument::size
the number of samples in the Signal.
argument::amplitudes
an link::Classes/Array:: of amplitudes for each Chebyshev polynomial beginning with order 1.
argument::normalize
a link::Classes/Boolean:: indicating whether to normalize the resulting Signal. If the zeroOffset argument is true, the normalization is done for use as a transfer function, using link::Classes/Signal#-normalizeTransfer#normalizeTransfer::, otherwise it just uses link::Classes/Signal#-normalize#normalize:: to make the absolute peak value 1.  Default is true.
argument::zeroOffset
a link::Classes/Boolean:: indicating whether to offset the middle of each polynomial to zero. If true, then a zero input will always result in a zero output when used as a link::Classes/Shaper##waveshaper::. If false, then the "raw" (unshifted) Chebyshev polynomials are used. Default is false.
discussion::
note::
In previous versions, chebyFill always offset the curves to ensure the center value was zero. The zeroOffset argument was added in version 3.7, and the default behavior was changed, so that it no longer offsets.
::
code::
Signal.chebyFill(1000, [1]).plot;

// shifted to avoid DC offset when waveshaping a zero signal
Signal.chebyFill(1000, [0, 1], zeroOffset: true).plot;

// normalized sum of (unshifted) Chebyshev polynomials (the default)
Signal.chebyFill(1000, [0, 1, 0, 0, 0, 1], normalize: true, zeroOffset: false).plot;

Signal.chebyFill(1000, [0, 0, 1]).plot;
Signal.chebyFill(1000, [0.3, -0.8, 1.1]).plot;


// This waveshaping example uses two buffers, one with zero offset and
// the other not.
//
// 1. The offset version gives zero output (DC free) when waveshaping an
// input signal with amplitude of zero (e.g. DC.ar(0)).
//
// 2. The non-offset version makes better use of the full (-1 to 1) range
// when waveshaping a varying signal with amplitude near 1, but (if even
// Chebyshev polynomial degrees are used) will have a DC offset when
// waveshaping a signal with amplitude of zero.
//
// 3. Wrapping the non-offset Shaper in a LeakDC (the third signal in the
// example) cancels out any DC offsets (third version), while making full use
// of the -1 to 1 range.
(
s.waitForBoot({
	var amplitudes = [0, 1, 1, -2, 1];
	var sigs = [
		Signal.chebyFill(256+1, amplitudes, normalize: true, zeroOffset: true),
		Signal.chebyFill(256+1, amplitudes, normalize: true, zeroOffset: false)
	];
	b = sigs.collect{ arg sig; Buffer.loadCollection(s, sig.asWavetableNoWrap) };
	s.sync;
	x = {
		var in = SinOsc.ar(100, 0, SinOsc.kr(0.1, 0, 0.5, 0.5));
		Shaper.ar(b, in ) ++ LeakDC.ar(Shaper.ar(b[1], in))
	}.scope;
})
)
x.free; b.do(_.free); b = nil
::

method::hanningWindow
Fill a Signal of the given size with a Hanning window.
code::
Signal.hanningWindow(1024).plot;
Signal.hanningWindow(1024, 512).plot;
::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::hammingWindow
Fill a Signal of the given size with a Hamming window.

warning::
In versions of SuperCollider before 3.11, the implementation of code:: Signal.hammingWindow :: had incorrect coefficients. To get the old behavior back, use code:: Signal.hammingWindow_old ::.
::

code::
Signal.hammingWindow(1024).plot;
Signal.hammingWindow(1024, 512).plot;
::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::welchWindow
Fill a Signal of the given size with a Welch window.
code::
Signal.welchWindow(1024).plot;
Signal.welchWindow(1024, 512).plot;
::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::rectWindow
Fill a Signal of the given size with a rectangular window.
code::
Signal.rectWindow(1024).plot;
Signal.rectWindow(1024, 512).plot;
::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::fftCosTable
Fourier Transform: Fill a Signal with the cosine table needed by the FFT methods. See also the instance methods link::#-fft:: and link::#-ifft::.
code::
Signal.fftCosTable(512).plot;
::

method::hammingWindow_old

This used to be code:: Signal.hammingWindow ::, but the coefficients were incorrect (making it a different window in the generalized Hamming window family). It is provided to assist in porting code to 3.11 and later.

INSTANCEMETHODS::

private::performBinaryOpOnSignal, performBinaryOpOnComplex, performBinaryOpOnSimpleNumber

method::plot
Plot the Signal in a window. The arguments are not required and if not given defaults will be used.
code::
Signal.sineFill(512, [1]).plot;
Signal.sineFill(512, [1]).plot("Signal 1", Rect(50, 50, 150, 450));
::
For details, see link::Reference/plot::

method::play
Loads the signal into a buffer on the server and plays it. Returns the buffer so you can free it again.
code::
b = Signal.sineFill(512, [1]).play(true, 0.2);
b.free;	// free the buffer again.
::
argument::loop
A link::Classes/Boolean:: whether to loop the entire signal or play it once. Default is false.
argument::mul
volume at which to play it, 0.2 by default.
argument::numChannels
if the signal is an interleaved multichannel file, number of channels, default is 1.
argument::server
the server on which to load the signal into a buffer.

method::waveFill
Fill the Signal with a function evaluated over an interval.

argument::function
a function that should calculate the value of a sample.
code::
(
a = Signal.newClear(256);
a.waveFill({ arg x, old, i; sin(x)}, 0, 3pi);
a.waveFill({ arg x, old, i; old * sin(11 * x + 0.3) }, 0, 3pi);
a.waveFill({ arg x, old, i; old * (x % 4) }, 0, 3pi);

a.plot;
)
::


The function is called with three arguments:
definitionList::
## x || the value along the interval.
## old || the old value (if the signal is overwritten)
## i || the sample index.
::
As arguments, three values are passed to the function: the current input value (abscissa), the old value (if the signal is overwritten), and the index.
code::
(
a = Signal.newClear(16);
a.waveFill({ arg x, prev, i; [x, prev, i].postln; sin(x).max(0) }, 0, 3pi);
a.plot;
)
::



argument::start
the starting value of the interval.
argument::end
the ending value of the interval.

method::asWavetable
Convert the Signal into a Wavetable.
code::
Signal.sineFill(512, [1]).asWavetable.plot;
::

method::fill
Fill the Signal with a value.
code::
Signal.newClear(512).fill(0.2).plot;
::

method::scale
Scale the Signal by a factor strong::in place::.
code::
a = Signal[1, 2, 3, 4];
a.scale(0.5); a;
::

method::offset
Offset the Signal by a value strong::in place::.
code::
a = Signal[1, 2, 3, 4];
a.offset(0.5); a;
::

method::peak
Return the peak absolute value of a Signal.
code::
Signal[1, 2, -3, 2.5].peak;
::

method::normalize
Normalize the Signal strong::in place:: such that the maximum absolute peak value is 1.
code::
Signal[1, 2, -4, 2.5].normalize;
Signal[1, 2, -4, 2.5].normalize(0, 1);	// normalize only a range
::

method::normalizeTransfer
Normalizes a transfer function so that the center value of the table is offset to zero and the absolute peak value is 1. Transfer functions are meant to be used in the link::Classes/Shaper:: ugen.
code::
Signal[1, 2, 3, 2.5, 1].normalizeTransfer;
::

method::invert
Invert the Signal strong::in place::.
code::
a = Signal[1, 2, 3, 4];
a.invert(0.5); a;
::

method::reverse
Reverse a subrange of the Signal strong::in place::.
code::
a = Signal[1, 2, 3, 4];
a.reverse(1, 2); a;
::

method::fade
Fade a subrange of the Signal strong::in place::.
code::
a = Signal.fill(10, 1);
a.fade(0, 3);		// fade in
a.fade(6, 9, 1, 0);	// fade out
::

method::integral
Return the integral of a signal.
code::
Signal[1, 2, 3, 4].integral;
::

method::overDub
Add a signal to myself starting at the index. If the other signal is too long only the first part is overdubbed.
code::
a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], 3);

		// run out of range
a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], 8);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -4);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -1);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -2);

a = Signal.fill(4, 100);
a.overDub(Signal[1, 2, 3, 4, 5, 6, 7, 8], -2);
::

method::overWrite
Write a signal to myself starting at the index. If the other signal is too long only the first part is overdubbed.
code::
a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], 3);

		// run out of range
a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], 8);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -4);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -1);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -2);

a = Signal.fill(4, 100);
a.overWrite(Signal[1, 2, 3, 4, 5, 6, 7, 8], -2);
::

method::blend
Blend two signals by some proportion.
code::
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0.2);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0.4);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 1);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 2);
::

subsection::Fourier Transform

method::fft
Perform an FFT on a real and imaginary signal in place. See also the class method link::#*fftCosTable::.
code::
(
var size = 512;
var real, imag, cosTable, frqAmpPhs, complex;

// Create a signal of sine partials:
// partial freqs, amps, and phases
frqAmpPhs = [
	// 0 Hz (DC), amp: 1, phase pi/2 (cosine)
	[0, 1, 0.5pi],
	// other partials, various amp and phase
	[8], [13, 0.25], [21, 0.25], [55, 0.5, 0.5pi],
	// nyquist, amp: 1, phase pi/2 (cosine)
	[size/2, 1, 0.5pi]
];
real = Signal.newClear(size);
real.sineFill2(frqAmpPhs);

imag = Signal.newClear(size); // zeros
cosTable = Signal.fftCosTable(size);

// Perform fft
complex = fft(real, imag, cosTable);

// Plot signals and spectrum
[
	real,
	imag,
	(complex.magnitude) / size
]
.plot("fft", Window.screenBounds.insetBy(*200!2))
.axisLabelX_(["Signal (real, samples)", "Signal (imaginary, samples)", "FFT spectrum (bins)"])
.axisLabelY_(["Amplitude", "Amplitude", "Magnitude"])
.plotMode_([\linear, \linear, \steps]);
)
::

method::ifft
Perform an inverse FFT on a real and imaginary signal in place. See also the class method link::#*fftCosTable::.
code::
(
var real, imag, cosTable, complex, ifft;
var size = 512;

// Create a signal of sine partials, add noise
real = Signal.newClear(size);
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size); // zeros
cosTable = Signal.fftCosTable(size);

// Perform fft & ifft
complex = fft(real, imag, cosTable).postln;
ifft = complex.real.ifft(complex.imag, cosTable);

// Plot input and output
[
	real,
	ifft.real
]
.plot("fft -> ifft", Window.screenBounds.insetBy(*200!2))
.axisLabelX_(["Real signal (samples)", "Restored signal (samples)"])
.axisLabelY_("Amplitude");
)
::

subsection::Unary Messages

Signal will respond to unary operators by returning a new Signal.
code::
x = Signal.sineFill(512, [0, 0, 0, 1]);
[x, x.neg, x.abs, x.sign, x.squared, x.cubed, x.asin.normalize, x.exp.normalize, x.distort].flop.flat
	.plot(numChannels: 9);
::

method::neg, abs, sign, squared, cubed, sqrt, exp, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, distort, softclip, isPositive, isNegative, isStrictlyPositive

subsection::Binary Messages

Signal will respond to binary operators by returning a new Signal.
code::
(
x = Signal.fill(512, { rrand(0.0, 1.0) });
y = Signal.fill(512, { |i| (i * pi / 64).sin });
[x, y, (x + y) * 0.5, x * y, min(x, y), max(x, y) ].flop.flat
	.plot(numChannels: 6);
)
::
method::thresh
Thresholding replaces every value < threshold with 0.
note::
Before SuperCollider 3.13 this function was implemented incorrectly, evaluating the square of provided threshold. This behavior is now fixed, but note that older code might give different results.
::
method::+, -, *, /, div, pow, mod, min, max, ring1, ring2, ring3, ring4, difsqr, sumsqr, sqrdif, absdif, amclip, scaleneg, clip2, wrap2, excess
method:: %, **
method:: <!

code::
// these fail for Signal but work for FloatArray:
Signal[0, 0.5, 1] pow: 2;
Signal[0, 0.5, 1] ** 2;
Signal[0, 0.5, 1] mod: 0.15;
Signal[0, 0.5, 1] % 0.15;

FloatArray[0, 0.5, 1] % 0.15;
::


class:: Silent
summary:: Output silence.
categories::  UGens>Generators>Single-value


Description::

Output silence.


classmethods::

method::ar

argument::numChannels

Number of channels to output.



CLASS:: SimpleController
summary:: Controller according to the model-view-controller (M-V-C) paradigm
categories:: Core
related:: Classes/Object

DESCRIPTION::

SimpleController can be used as a controller according to the model-view-controller (M-V-C) paradigm. It provides an
link::Classes/IdentityDictionary:: of actions, which are called whenever the attached model sends a notification by
calling changed.


CLASSMETHODS::

METHOD:: new
Creates a SimpleController instance with the model to be observed.

argument:: model
An object of any class


INSTANCEMETHODS::

private:: init, update

METHOD:: put

argument:: what
Register an action, which is called when the model invokes changed(what, moreArgs).

argument:: action

Action to register.


METHOD:: remove

Remove a registered action.

argument:: action

Action to remove

EXAMPLES::

code::
(
var controller, model, view;

model = Ref(0.5);
controller = SimpleController(model);
controller.put(\value,
	{|theChanger, what, moreArgs|
		view.value_(theChanger.value);
	});

view = Slider(Window("slider", Rect(100, 100, 330, 38)).front, Rect(5, 5, 320, 20));
view.onClose_{controller.remove};

// run a routine to change the model's value:
r{
	100.do{
		model.value_(1.0.rand.postln).changed(\value);
		0.5.wait;
	}
}.play(AppClock)
)
::


CLASS:: SimpleNumber
summary:: one-dimensional value
categories:: Math
related::Classes/Polar, Classes/Complex, Classes/Float, Classes/Integer, Classes/UnaryOpUGen, Classes/BinaryOpUGen, Guides/Tour-of-Special-Functions

DESCRIPTION::
Base class for numbers which can be represented by a single one dimensional value.

Most of the Unary and Binary operations are also implemented by link::Classes/UnaryOpUGen:: and link::Classes/BinaryOpUGen::, so you can get more examples by looking at the help for those.

CLASSMETHODS::

method:: new
allocates a new SimpleNumber.



INSTANCEMETHODS::

private:: prSimpleNumberSeries

subsection:: math support

method:: +
Addition


method:: -
Subtraction

method:: *
Multiplication

method:: /
Division

method:: %
Modulo

method:: mod
Modulo

method:: div
Integer Division

method:: **
Exponentiation

method:: !=
Is not

method:: >
greater than

method:: <
greater than

method:: >=
greater or equal than

method:: <=
smaller or equal than

method:: lcm
Least common multiple

method:: gcd
Greatest common divisor

method:: round
Round to multiple of aNumber

method:: roundUp
Round up to a multiple of aNumber. For roundDown use Link::Classes/SimpleNumber#-trunc#trunc::.

method:: smallButNotZero
Check if the value is closer to zero than a threshold, but not zero.

argument::thresh
The threshold to use for comparison.

method:: trunc
Truncate to multiple of aNumber (e.g. it rounds numbers down to a multiple of aNumber).

method:: softRound
Rounds the value to a multiple of strong::resolution::. By using strong::margin:: and strong::strength:: you can control which values will be rounded, and by how much.

Conceptually this is the equivalent of MIDI quantization in a DAW/MIDI sequencer. In particular it allows a certain sloppiness close to the strong::resolution:: value.

Note: this method expects values >= 0.

argument::resolution
Round this value to a multiple of resolution. E.g. if you chose 1, then all values would be rounded to the nearest integer.
argument::margin
Values that are within ±strong::margin:: from a multiple of strong::resolution:: will be left as they are.

E.g. if you chose a resolution value of 0.5 and a margin of 0.01, then the values 0.501 and 0.499 would be left as they are, but the value 0.502 would become 0.5.

This should be a value between 0 and strong::resolution::.
argument::strength
Determines the degree to which this number will be changed.

If strength is 1, then this function will return the nearest resolution. If it is 0, then value of this number will be left unchanged.

E.g. If the resolution was 1 and strength was 0.5, then the value 0.6 would become 0.8.
discussion::
code::
((0..10) / 5).collect { |num| [num, num.softRound(1, 0, 1)] };
((0..10) / 5).collect { |num| [num, num.softRound(1, 0.3, 1)] };
((0..10) / 5).collect { |num| [num, num.softRound(1, 0, 0.5)] };
::

method:: snap
Rounds the values strong::margin:: distance from resolution to a multiple of resolution. By using strong::margin:: and strong::strength:: you can control when values will be rounded, and by how much.

Conceptually this is the equivalent of 'snap' in a graphics program. Values within a certain distance (strong::margin::) from a grid line are snapped to it. All other values are unchanged.

Note: this method expects values >= 0.

argument::resolution
Snap this value to a multiple of resolution. E.g. if you chose 1, then all values would be rounded to the nearest integer.

argument::margin
Only values that are greater ±strong::margin:: from a multiple of strong::resolution:: value will be changed. Values that are less than strong::margin:: will be unchanged.

E.g. if you chose a resolution value of 0.5 and a margin of 0.01, then the values 0.501 and 0.499 would be snapped to 0.5, but the value 0.502 would be unchanged.

This should be a value between 0 and strong::resolution::.

argument::strength
Determines the degree to which this number will be changed.

If strength is 1, then this function will return the nearest resolution. If it is 0, then value of this number will be left unchanged.

E.g. If the resolution was 1 and strength was 0.5, then the value 0.6 would become 0.8.
discussion::
code::
((0..10) / 5).collect { |num| [num, num.snap(1, 0, 1)] };
((0..10) / 5).collect { |num| [num, num.snap(1, 0.3, 1)] };
((0..10) / 5).collect { |num| [num, num.snap(1, 0, 0.5)] };
::

method:: thresh

method:: min
Minimum

method:: max
Maximum

method:: wrap2

method:: atan2
Arctangent of (this/aNumber)

method:: hypot
Square root of the sum of the squares.


method:: log
returns:: Base e logarithm.

method:: log2
returns:: Base 2 logarithm.

method:: log10
returns:: Base 10 logarithm.

method:: neg
returns:: negation

method:: abs
returns:: absolute value.

method:: sign
returns:: Answer -1 if negative, +1 if positive or 0 if zero.

method:: ceil
returns:: next larger integer.

method:: floor
returns:: next smaller integer

method:: sin
Sine

method:: cos
Cosine

method:: tan
Tangent

method:: asin
Arcsine

method:: acos
Arccosine

method:: atan
Arctangent

method:: sinh
Hyperbolic sine

method:: cosh
Hyperbolic cosine

method:: tanh
Hyperbolic tangent

method:: frac
fractional part

method:: squared
the square of the number

method:: cubed
the cube of the number

method:: sqrt
the square root of the number.

method:: exp
e to the power of the receiver.

method:: reciprocal
1 / this

method:: pow
this to the power of aNumber

method:: fold2
the folded value, a bitwise or with aNumber

method:: previousPowerOf
the number relative to this that is the previous power of aNumber

method:: nextPowerOf
the next power of aNumber

method:: nextPowerOfTwo
returns:: the number relative to this that is the next power of 2

method:: nextPowerOfThree
the next power of three

method:: hash
returns:: a hash value

method:: <!
returns:: the receiver. aNumber is ignored.

method:: &
Bitwise And

method::|
Bitwise Or

method:: bitXor
Bitwise Exclusive Or

method:: bitHammingDistance
Binary Hamming distance: the count of bits that are not the same in the two numbers

method:: bitTest
returns:: true if bit at index aNumber is set.

method:: bitNot
returns:: ones complement

method:: <<
Binary shift left.

method:: >>
Binary shift right.

method:: +>>
Unsigned binary shift right.

method:: rightShift
returns:: performs a binary right shift

method:: unsignedRightShift
returns:: performs an unsigned right shift

method:: leftShift
returns:: performs a binary left shift

method:: bitOr
returns:: performs a bitwise or with aNumber

method:: bitAnd
returns:: performs a bitwise and with aNumber

method:: ring1
(a * b) + a

method:: ring2
((a*b) + a + b)

method:: ring3
(a * a *b)

method:: ring4
((a*a *b) - (a*b*b))

method:: difsqr
(a*a) - (b*b)

method:: sumsqr
(a*a) + (b*b)

method:: sqrdif
(a - b) ** 2

method:: sqrsum
(a + b) ** 2

method:: absdif
(a - b).abs

method:: moddif
On a circle, there are two distances between two points. This operator returns the smaller value of the two.
code::
moddif(0.75, 0, 1)
::

method:: amclip
0  when  b <= 0,  a*b  when  b > 0

method:: scaleneg
a * b when a < 0, otherwise a.

method:: clip2
clips receiver to +/- aNumber

method:: excess
Returns the difference of the receiver and its clipped form.
discussion::
code::
(a - clip2(a,b))
::

method:: madd
code::
this * a + b
::

subsection:: testing
method:: isPositive
Answer if the number is >= 0.

method:: isNegative
Answer if the number is < 0.

method:: isStrictlyPositive
Answer if the number is > 0.

method:: booleanValue
returns:: true, if strictly positive ( > 0), otherwise false (see link::Classes/Boolean::)

method:: isNaN
method:: ==

subsection:: conversion

method:: asFraction
argument::denominator
argument::fasterBetter
if true, asFraction may find a much closer approximation and do it faster.
returns:: an array of denominator and divisor of the nearest and smallest fraction

method:: asAudioRateInput
Converts this into an audiorate input.

method:: asTimeString
Produces a time string in the clock format inspired by ISO 8601 time interval display (truncated representation) code::(ddd:)hh:mm:ss(.z)::, interpreting the receiver as time in seconds. See link::Classes/String#-asSecs:: for the inverse function.
argument:: precision
accuracy of the fraction of seconds; since the number of decimal places is also an argument, code::precision:: is clamped to code::10.pow(decimalPlaces.neg)::, i.e. code::0.001:: for code::decimalPlaces = 3::
argument::maxDays
maximum number of days
argument::dropDaysIfPossible
a link::Classes/Boolean::. If set to code::true::, and the number of days in the formatted string
would be 0, that section of the resulting string is omitted
argument::decimalPlaces
number of decimal places representing fraction of seconds, clamped to code::0::; if code::0::, the string is formatted as code::(ddd:)hh:mm:ss::
discussion::
code::
(
var start;
start = Main.elapsedTime;
{
	loop {
		(Main.elapsedTime - start).asTimeString.postln;
		0.05.wait
	}
}.fork;
)
::

method:: asPoint
returns:: this as link::Classes/Point::. x = y = this.

method:: asComplex
returns:: this as link::Classes/Point::. x = y = this.

method:: asWarp
argument::spec
a link::Classes/ControlSpec::
returns:: this as link::Classes/CurveWarp:: according to spec.

method:: asFloat
returns:: this as link::Classes/Float::

method:: asRect
returns:: a link::Classes/Rect:: with x = y = w = h = this.

method:: asBoolean
returns:: this as a link::Classes/Boolean::.  this > 0

method:: asQuant
returns:: the values as link::Classes/Quant::

method:: asInteger
returns:: this as link::Classes/Integer::

subsection:: timing

method::wait
within a routine, yield the number so that the clock can wait for this many beats. Outside a Routine, this trows an error (see also Routine for details).

discussion::
Create a routine by a function fork
code::
(
fork {
	1.wait;
	"I did wait".postln;
	1.0.rand.wait;
	"No you didn't".postln;
	2.wait;
	(1..).do { |i|
		"yes I did".postln;
		i.asFloat.rand.wait;
		"no you didn't".postln;
		i.wait
	}
}
)
::

method:: waitUntil
like wait, only specify a time (measured in beats of the current thread's clock). Outside a Routine, this throws an error (see also Routine for details).

method:: sleep
make the current thread sleep, until woken up by re-scheduling. Outside a Routine, this trows an error (see also Routine for details).

method:: nextTimeOnGrid
argument::clock
returns:: the next possible multiple of the clock's beats.

method:: schedBundleArrayOnClock



subsection:: series and arrays

method:: nearestInList
returns:: the value in the list closest to this

discussion::
code::
(
l = [0, 0.5, 0.9, 1];
(0, 0.05..1).collect { |i| i.nearestInList(l) }
)
::

method:: nearestInScale
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 by default
returns:: the value in the collection closest to this, assuming an octave repeating table of note values.

discussion::
code::
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..76).collect { |i| i.nearestInScale(l, 12) }
)
::

method:: series
Generate an arithmetic series from teletype::this:: over strong::second:: to strong::last::.

If strong::second:: is teletype::nil::, it is one magnitude step towards last (1 or -1).
code::
series(5, 7, 10);
series(5, nil, 10);
(5, 7 .. 10)
::
This is used in the shortcuts:
code::
(0..100);
(1, 3 .. 17)
::

returns::
An link::Classes/Array::.

discussion::
The last value may not be included in the result if the step size does not divide evenly into the range of the series.

method:: seriesIter
Create a link::Classes/Routine:: that iterates over an arithmetic series from teletype::this:: over strong::second:: to strong::last::.

Since this is a lazy operation, strong::last:: can be code::inf::, generating an endless series. If unspecified, strong::last:: is code::inf:: or code::-inf:: depending on the step direction.
code::
r = seriesIter(0, 5, 52);
r.nextN(8);
r.nextN(8); // reaches 'last', then nils

r = seriesIter(0, 5); // last = inf
r.nextN(8); // run repeatedly
::
See also link::#-series:: and link::Guides/ListComprehensions::.

returns::
A link::Classes/Routine::.


subsection:: windowing

method:: rectWindow
returns:: a value for a rectangular window function between 0 and 1.

method:: hanWindow
returns:: a value for a hanning window function between 0 and 1.

method:: welWindow
returns:: a value for a welsh window function between 0 and 1.

method:: triWindow
returns:: a value for a triangle window function between 0 and 1.

subsection:: mapping

method:: distort
A nonlinear distortion function.

Implements:
teletype::
this / (1.0 - abs(this))
::
Visualize:
code::
(
{ var saw = LFSaw.ar(2 * 0.01.reciprocal);
	[saw, saw.distort]
}.plot.superpose_(true)
)
::

method:: softclip
Distortion with a perfectly linear region from -0.5 to +0.5.

Implements:
teletype::
if (abs(this) < 0.5) { this } { (abs(this) - 0.25) / this };
::
Visualize:
code::
(
{ var saw = LFSaw.ar(2 * 0.01.reciprocal);
	[saw, saw.softclip]
}.plot.superpose_(true)
)
::

method:: scurve
Map receiver in the onto an S-curve bound to [0,1].
Implements:
teletype::
this * this * (3.0 - (2.0 * this))
::
with teletype::this:: clipped to [0,1].
code::
((-100..200) / 100 ).collect(_.scurve).plot
::

method:: ramp
Map the receiver onto a ramp starting at code::0.0::, ending at code::1.0::, effectively clipping the receiver at [0,1].
discussion::
code::
(
	var vals = (-100..200) / 100;
	vals.collect(_.ramp).plot
	.domainSpecs_(
		[vals.minItem, vals.maxItem].asSpec
	)
	.axisLabelX_("input").axisLabelY_("output")
)
::

method::magnitude
returns:: The absolute value.

Alternatively conceived of as the link::Classes/Polar#-magnitude:: or link::Classes/Complex#-magnitude::, wherein the receiver is the real part and the imaginary part is code::0.0::.

method::angle
returns:: Angle of receiver (in radians) conceived as link::Classes/Polar:: or link::Classes/Complex:: number, wherein the receiver is the real part and the imaginary part is code::0.0::. I.e. teletype::if (this.isPositive) { 0.0 } { pi }::.


method:: degreeToKey
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 is the standard chromatic scale.
discussion::
the value is truncated to an integer and used as an index into an octave repeating table of note values. Indices wrap around the table and shift octaves as they do.

code::
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(1, 2..15).collect{|i|
	i.degreeToKey(l, 12)
};
)
::

method:: keyToDegree
inverse of degreeToKey.
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 is the standard chromatic scale.
discussion::
code::
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..75).collect { |i| i.keyToDegree(l, 12) }
)
::
code::
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..75).postln.collect { |i| i.keyToDegree(l, 12).degreeToKey(l) }
)
::


method::gaussCurve
Map the receiver onto a gauss function.

Uses the formula:
teletype::
a * -exp((this - b).squared / (2 * c.squared))
::
where code::a:: is the distribution amplitude, code::b:: is the mean (typically denoted emphasis::mu::), and the variance is code::c.squared:: (emphasis::sigma::^2).

The method defaults to a "standard normal distribution": a zero mean and both the peak amplitude and variance are code::1.0:: (code::a = 1.0, b = 0.0, c = 1.0::).
code::
(0..1000).normalize(-10, 10).collect { |num| num.gaussCurve }.plot;
::


method:: equalWithPrecision

argument::that
the number to compare with within precision

argument::precision
The absolute precision, independent of the value compared

argument::relativePrecision
The precision relative to the larger absolute of the values compared.


returns:: true if receiver is closer to that than precision.

discussion::
code::
3.1.equalWithPrecision(3.0, 0.05); // false
3.1.equalWithPrecision(3.0, 0.1); // false
3.1.equalWithPrecision(3.0, 0.11); // true
3000.1.equalWithPrecision(3000.0, 0, 0.01); // true
3.1.equalWithPrecision(3.0, 0, 0.01); // false

::

method:: quantize
Deprecated. Round the receiver to the quantum. If you're looking for MIDI quantization type features use CODE::SimpleNumber#-softRound::
argument::quantum
amount.
argument::tolerance
allowed tolerance.
argument::strength
Determines how much the value is allowed to differ in the tolerance range.
discussion::
code::
((0..10) / 10).collect { |num| num.quantize(1, 0.3, 0.5) }.postcs.plot;
((0..10) / 10).collect { |num| num.quantize(1, 0.6, 0.5) }.postcs.plot;
((0..10) / 10).collect { |num| num.quantize(1, 1.0, 0.5) }.postcs.plot;
::

method:: linlin
map the receiver from an assumed linear input range to a linear output range. If the input exceeds the assumed input range, the behaviour is specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
(0..10).collect { |num| num.linlin(0, 10, -4.3, 100) };
(0..10).linlin(0, 10, -4.3, 100); // equivalent.
::

method::linexp
map the receiver from an assumed linear input range (inMin..inMax) to an exponential output range (outMin..outMax). The output range must not include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
(0..10).collect { |num| num.linexp(0, 10, 4.3, 100) };
(0..10).linexp(0, 10, 4.3, 100); // equivalent.
::

method::explin
map the receiver from an assumed exponential input range (inMin..inMax) to a linear output range (outMin..outMax). If the input exceeds the assumed input range. The input range must not include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
(1..10).collect { |num| num.explin(0.1, 10, -4.3, 100) };
(1..10).explin(0.1, 10, -4.3, 100); // equivalent.
::

method::expexp
map the receiver from an assumed exponential input range (inMin..inMax) to an exponential output range (outMin..outMax). If the input exceeds the assumed input range. Both input range and output range must not include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
(1..10).collect { |num| num.expexp(0.1, 10, 4.3, 100) };
(1..10).expexp(0.1, 10, 4.3, 100); // equivalent.
::

method::lincurve
map the receiver from an assumed linear input range (inMin..inMax) to an exponential curve output range (outMin..outMax). A curve is like the curve parameter in Env. Unlike with linexp, the output range may include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::curve
0 (linear) <0 (concave, negatively curved) >0 (convex, positively curved)
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
(0..10).collect { |num| num.lincurve(0, 10, -4.3, 100, -3) };
(0..10).lincurve(0, 10, -4.3, 100, -3); // equivalent.
::
code::
// different curves:
(-4..4).do { |val|
	(0..100).collect(_.lincurve(0, 100, 0, 1, val)).plot
}
::

method::curvelin
map the receiver from an assumed curve-exponential input range (inMin..inMax) to a linear output range (outMin..outMax). If the input exceeds the assumed input range. A curve is like the curve parameter in Env. Unlike with explin, the input range may include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::curve
0 (linear) <0 (concave, negatively curved) >0 (convex, positively curved)
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
(1..10).collect { |num| num.curvelin(0, 10, -4.3, 100, -3) };
(1..10).curvelin(0, 10, -4.3, 100, -3); // equivalent.
::
code::
// different curves:
(-4..4).do { |val|
	(0..100).collect(_.curvelin(0, 100, 0, 1, val)).plot
}
::

method::bilin
map the receiver from two assumed linear input ranges (inMin..inCenter) and (inCenter..inMax) to two linear output ranges (outMin..outCenter) and (outCenter..outMax). If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inCenter
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outCenter
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
var center = 0.5, ctlCenter;
w = Window("bilin", Rect(100, 100, 200, 100)).front;
a = Slider(w, Rect(20, 20, 150, 20)).value_(0.5);
b = Slider(w, Rect(20, 45, 150, 20)).value_(0.5);
b.action = { center = b.value };
a.mouseDownAction = { ctlCenter = a.value };
a.action = {
	b.value = a.value.bilin(ctlCenter, 0, 1, center, 0, 1);
};
::


method::biexp
map the receiver from two assumed exponential input ranges (inMin..inCenter) and (inCenter..inMax) to two linear output ranges (outMin..outCenter) and (outCenter..outMax). The input range must not include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inCenter
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outCenter
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
// doesn't properly work yet.
(
var center = 0.5, ctlCenter;
w = Window("biexp", Rect(100, 100, 200, 100)).front;
a = Slider(w, Rect(20, 20, 150, 20)).value_(0.5);
b = Slider(w, Rect(20, 45, 150, 20)).value_(0.5);
b.action = { center = b.value };
a.mouseDownAction = { ctlCenter = a.value + 0.05 };
a.action = {
	b.value = (a.value + 0.1).biexp(ctlCenter, 0.1, 1.1, center, 0, 1);
};
)
::

method::lcurve
map the receiver onto an L-curve.

discussion::
Uses the formula
code::
a * (m * exp(x) * rTau + 1) / (n * exp(x) * rTau + 1)
::
This is used for smoothing values and limiting them to a range.
code::
(0..1000).normalize(-10, 10).collect { |num| num.lcurve }.plot;
::


method:: degrad
returns:: converts degree to radian

method:: raddeg
returns:: converts radian to degree

method:: midicps
Convert MIDI note to cycles per second
returns:: cycles per second

method:: cpsmidi
Convert cycles per second to MIDI note.
returns:: midi note


method:: midiratio
Convert an interval in semitones to a ratio.
returns:: a ratio

method:: ratiomidi
Convert a ratio to an interval in semitones.
returns:: an interval in semitones

method:: ampdb
Convert a linear amplitude to decibels.


method:: dbamp
Convert a decibels to a linear amplitude.

method:: octcps
Convert decimal octaves to cycles per second.

method:: cpsoct
Convert cycles per second to decimal octaves.


subsection:: streams

method:: storeOn
stores this on the given stream
method:: printOn
prints this on the given stream

subsection:: random

method:: coin
Let emphasis::x:: be the receiver clipped to the range [0, 1]. With probability emphasis::x::, return true. With probability 1 - emphasis::x::, return false.

method:: rand
returns:: Random number from zero up to the receiver, exclusive.

method:: rand2
returns:: a random number from -this to +this.

method:: rrand
argument::aNumber
the upper limit
argument::adverb
returns:: a random number in the interval ]a, b[.
discussion::
If both a and b are link::Classes/Integer:: then the result will be an link::Classes/Integer::.

method:: linrand
returns:: a linearly distributed random number from zero to this.

method:: bilinrand
returns:: Bilateral linearly distributed random number from -this to +this.

method:: sum3rand
This was suggested by Larry Polansky as a loose approximation of gaussian.
returns:: A random number from -this to +this that is the result of summing three uniform random generators to yield a bell-like distribution.

method:: exprand
an exponentially distributed random number in the interval ]a, b[. This is always a link::Classes/Float::.
(Note that the distribution of numbers is not exactly an EMPHASIS::exponential distribution::, since that would be unbounded: we might call it a EMPHASIS::logarithmic uniform distribution::.)
argument::aNumber
the upper limit
argument::adverb

method:: gauss
a gaussian distributed random number.
argument::standardDeviation
the upper limit
discussion::
Always returns a link::Classes/Float::.
code::
(0..1000).collect { |num| gauss(0.0, num) }.plot;
::

method:: partition
randomly partition a number into parts of at least min size.
argument:: parts
number of parts
argument:: min
the minimum size

discussion::
code::
75.partition(8, 3);
75.partition(75, 1);
::


subsection:: UGen Compatibility Methods

Some methods to ease the development of generic ugen code.

method:: lag, lag2, lag3, lagud, lag2ud, lag3ud, slew, varlag

returns:: code::this::


subsection:: misc

method:: isValidUGenInput
returns:: false if receiver cannot be used in UGen.


subsection::Special Functions

A variety of Special Functions are supplied by the Boost C++ library. The library's
link::http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/special.html##online documentation::
 serves as the primary reference for the following functions. The methods
here match closely with those found in the source library, as do argument names.

Below you'll find descriptions of the functions and their bounds, but for
visualizing the functions, have a look in link::Guides/Tour-of-Special-Functions::.

warning::Many of the functions are only valid in certain numerical ranges. For the most part, error handling
happens in the underlying boost functions. While these errors are often obtuse, you'll usually find
a useful message at the end of the error regarding proper ranges and the erroneous value supplied.
Refer to the online documentation for more detailed descriptions, and the
link::Guides/Tour-of-Special-Functions:: for plots showing ranges and asymptotes.::


subsection:: Number Series
Take a tour of link::Guides/Tour-of-Special-Functions#Number Series#Number Series::.

method:: bernouliB2n
Returns the (2*code::n::)th Bernoulli number.

Because all odd numbered Bernoulli numbers are zero
(apart from B(1) which is -1/2) the interface will only
return the even numbered Bernoulli numbers.

method:: tangentT2n
Returns a single tangent number at code::i::. Also called a zag function.


subsection:: Gamma Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Gamma Functions#Gamma Functions::.

method:: tgamma
Returns the "true gamma" of value code::z::.

method:: tgamma1pm1
Returns code::gamma(dz + 1) - 1::.

method:: lgamma
Returns the natural logarithm of the gamma function.

method:: digamma
Returns the digamma or psi function of code::z::.

Digamma is defined as the logarithmic derivative of the gamma function.

method:: trigamma
Returns the trigamma function of code::z::.

Trigamma is defined as the derivative of the digamma function.

method:: polygamma
Returns the polygamma function of code::z::.

Polygamma is defined as the code::n::'th derivative of the digamma function.

method:: tgammaRatio
Returns the ratio of gamma functions code::tgamma(a) / tgamma(b)::.

method:: tgammaDeltaRatio
Returns the ratio of gamma functions code::tgamma(a) / tgamma(a+delta)::.

method:: gammaP
Returns the normalised lower incomplete gamma function.

Requires code::a:: > 0 and code::z:: >= 0.

method:: gammaQ
Returns the normalised upper incomplete gamma function.

Requires code::a:: > 0 and code::z:: >= 0.

method:: tgammaLower
Returns the full (non-normalised) lower incomplete gamma function.

Requires code::a:: > 0 and code::z:: >= 0.

method:: tgammaUpper
Returns the full (non-normalised) upper incomplete gamma function.

Requires code::a:: > 0 and code::z:: >= 0.

method:: gammaPInv
Returns a value such that code::p = gamma_p(a, x)::.

Requires code::a:: > 0 and 1 >= code::p,q:: >= 0.

method:: gammaQInv
Returns a value x such that code::q = gamma_q(a, x)::.

Requires code::a:: > 0 and 1 >= code::p,q:: >= 0.

method:: gammaPInvA
Returns a value such that code::p = gamma_p(a, x)::.

Requires code::x:: > 0 and 1 >= code::p,q:: >= 0.

method:: gammaQInvA
Returns a value x such that code::q = gamma_q(a, x)::.

Requires code::x:: > 0 and 1 >= code::p,q:: >= 0.

method:: gammaPDerivative
Implements the partial derivative with respect to x of the incomplete gamma function (lower).

method:: gammaQDerivative
Implements the partial derivative with respect to x of the incomplete gamma function (upper).


subsection:: Factorials and Binomial Coefficients
Take a tour of link::Guides/Tour-of-Special-Functions#Factorials and Binomial Coefficients#Factorials and Binomial Coefficients::.

method:: factorial
Returns code::i!::.

warning::code::factorial:: will overflow if code::i > 170::::

method:: doubleFactorial
Returns code::i!!::.

For strong::even:: code::i::, code::i !! = i(i-2)(i-4)(i-6) ... (4)(2)::.

For strong::odd:: code::i::, code::i !! = i(i-2)(i-4)(i-6) ... (3)(1)::.

method:: risingFactorial
Returns the rising factorial of code::x:: and code::i:::

code::x(x+1)(x+2)(x+3)...(x+i-1)::

Both code::x:: and code::i:: can be negative as well as positive.

method:: fallingFactorial
Returns the falling factorial of code::x:: and code::i:::

code::x(x-1)(x-2)(x-3)...(x-i+1)::

This function is only defined for positive code::i::. Argument code::x:: can be either positive or negative.

method:: binomialCoefficient
Requires code::k:: <= code::n::.


subsection:: Beta Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Beta Functions#Beta Functions::.

method:: beta
The beta function is defined by: code::tgamma(a)*tgamma(b) / tgamma(a+b)::.

method:: ibeta
Returns the normalised incomplete beta function of code::a::, code::b:: and code::x::.

Require 0 <= code::x:: <= 1, code::a,b:: >= 0, and in addition that not both code::a:: and code::b:: are zero.

method:: ibetaC
Returns the normalised complement of the incomplete beta function of code::a::, code::b:: and code::x::.

Require 0 <= code::x:: <= 1, code::a,b:: >= 0, and in addition that not both code::a:: and code::b:: are zero.

method:: betaFull
Returns the full (non-normalised) incomplete beta function of code::a::, code::b:: and code::x::.

Require 0 <= code::x:: <= 1, and code::a,b:: > 0.

method:: betaFullC
Returns the full (non-normalised) complement of the incomplete beta function of code::a::, code::b:: and code::x::.

Require 0 <= code::x:: <= 1, and code::a,b:: > 0.

method:: ibetaInv
Returns a value code::x:: such that: code::p = ibeta(a, b, x)::.

Requires code::a,b:: > 0 and 0 <= code::p:: <= 1.

method:: ibetaCInv
Returns a value code::x:: such that: code::q = ibetaC(a, b, x)::.

Requires code::a,b:: > 0 and 0 <= code::q:: <= 1.

method:: ibetaInvA
Returns a value code::a:: such that: code::p = ibeta(a, b, x)::.

Requires code::b:: > 0, 0 < code::x:: < 1, and 0 <= code::p:: <= 1.

method:: ibetaCInvA
Returns a value code::a:: such that: code::q = ibetaC(a, b, x)::.

Requires code::b:: > 0, 0 < code::x:: < 1, and 0 <= code::q:: <= 1.

method:: ibetaInvB
Returns a value code::b:: such that: code::p = ibeta(a, b, x)::.

Requires code::a:: > 0, 0 < code::x:: < 1, and 0 <= code::p:: <= 1.

method:: ibetaCInvB
Returns a value code::b:: such that: code::q = ibetaC(a, b, x)::.

Requires code::a:: > 0, 0 < code::x:: < 1, and 0 <= code::q:: <= 1.

method:: ibetaDerivative
Returns the partial derivative with respect to code::x:: of the incomplete
beta function code::ibeta(a,b,x)::.


subsection:: Error Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Error Functions#Error Functions::.

method:: erf
Returns the error function of code::z::.

method:: erfC
Returns the complement of the error function of code::z::.

method:: erfInv
Returns the inverse error function of code::z::, that is a value code::x:: such that:

code::p = erf(x)::.

method:: erfCInv
Returns the inverse of the complement of the error function of code::z::,
that is a value code::x:: such that:

code::p = erfC(x)::


subsection:: Polynomials
Take a tour of link::Guides/Tour-of-Special-Functions#Polynomials#Polynomials::.

method:: legendreP
Returns the Legendre Polynomial of the first kind.

Requires -1 <= code::x:: <= 1.

method:: legendrePPrime
Returns the derivatives of the Legendre polynomials.

method:: legendrePZeros
Since the Legendre polynomials are alternatively even and odd, only the
non-negative zeros are returned. For the odd Legendre polynomials, the
first zero is always zero. The rest of the zeros are returned in increasing order.

method:: legendrePAssoc
Returns the associated Legendre polynomial of the first kind.

Requires -1 <= code::x:: <= 1.

method:: legendreQ
Returns the value of the Legendre polynomial that is the
second solution to the Legendre differential equation.

Requires -1 <= code::x:: <= 1.

method:: laguerre
Returns the value of the Laguerre Polynomial of order code::n:: at point code::x::.

method:: laguerreAssoc
Returns the Associated Laguerre polynomial of degree of dgree code::n:: and order code::m:: at point code::x::.

method:: hermite
Returns the value of the Hermite Polynomial of order code::n:: at point code::x::.

method:: chebyshevT
Returns the Chebyshev polynomials of the first kind.

method:: chebyshevU
Returns the Chebyshev polynomials of the second kind.

method:: chebyshevTPrime
Returns the derivatives of the Chebyshev polynomials of the first kind.

method:: chebyshevTZeros
Returns the roots (zeros) of the code::n::-th Chebyshev polynomial of the first kind.

method:: sphericalHarmonic
Returns the (code::Complex::) value of the Spherical Harmonic.

code::theta:: is taken as the polar (colatitudinal) coordinate within code::[0, pi]::,
and code::phi:: as the azimuthal (longitudinal) coordinate within code::[0,2pi]::.

See boost documentation for further information, including a note about the
Condon-Shortley phase term of code::(-1)^m::.

method:: sphericalHarmonicR
Returns the real part of the Spherical Harmonic.

method:: sphericalHarmonicI
Returns the imaginary part of the Spherical Harmonic.


subsection:: Bessel Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Bessel Functions#Bessel Functions::.

method:: cylBesselJ
Returns the result of the Bessel functions of the first kind.

The functions return the result of code::domain_error:: whenever the result is
undefined or complex. This occurs when code::x < 0:: and code::v:: is
not an integer, or when code::x == 0:: and code::v != 0::.

method:: cylNeumann
Returns the result of the Bessel functions of the second kind.

The functions return the result of code::domain_error:: whenever the result is
undefined or complex. This occurs when code::x <= 0::.

method:: cylBesselJZero
Returns a single zero or root of the Bessel function of the first kind.

code::index:: is a 1-based index of zero of the cylindrical Bessel function of order code::v::.

method:: cylNeumannZero
Returns a single zero or root of the Neumann function (Bessel function of the second kind).

code::index:: is a 1-based index of zero of the cylindrical Neumann function of order code::v::.

method:: cylBesselI
Returns the result of the modified Bessel functions of the first kind.

method:: cylBesselK
Returns the result of the modified Bessel functions of the second kind.

Requires code::x > 0::.

method:: sphBessel
Returns the result of the spherical Bessel functions of the first kind.

Requires code::x:: > 0.

method:: sphNeumann
Returns the result of the spherical Bessel functions of the first kind.

Requires code::x:: > 0.

method:: cylBesselJPrime
Returns the first derivative with respect to x of the corresponding Bessel function.

method:: cylNeumannPrime
Returns the first derivative with respect to x of the corresponding Neumann function.

Requires code:: x > 0::.

method:: cylBesselIPrime
Returns the first derivative with respect to x of the corresponding Bessel function.

method:: cylBesselKPrime
Returns the first derivative with respect to x of the corresponding Bessel function.

Requires code:: x > 0::.

method:: sphBesselPrime
Returns the first derivative with respect to x of the corresponding Bessel function.

Requires code:: x > 0::.

method:: sphNeumannPrime
Returns the first derivative with respect to x of the corresponding Neumann function.

Requires code:: x > 0::.


subsection:: Hankel Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Hankel Functions#Hankel Functions::.

method:: cylHankel1
Returns the result of the Hankel functions of the first kind.

method:: cylHankel2
Returns the result of the Hankel functions of the second kind.

method:: sphHankel1
Returns the result of the spherical Hankel functions of the first kind.

method:: sphHankel2
Returns the result of the spherical Hankel functions of the second kind.


subsection:: Airy Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Airy Functions#Airy Functions::.

method:: airyAi
Returns the result of the Airy function Ai at code::x::.

method:: airyBi
Returns the result of the Airy function Bi at code::x::.

method:: airyAiPrime
Returns the derivative of the Airy function Ai at code::x::.

method:: airyBiPrime
Returns the derivative of the Airy function Bi at code::x::.

method:: airyAiZero
Returns the code::m::th zero or root of the Airy Ai function. The Airy Ai
function has an infinite number of zeros on the negative real axis.

code::m:: is 1-based.

method:: airyBiZero
Returns the code::m::th zero or root (1-based) of the Airy Bi function. The Airy Bi
function has an infinite number of zeros on the negative real axis.

code::m:: is 1-based.


subsection:: Elliptic Integrals
Take a tour of link::Guides/Tour-of-Special-Functions#Elliptic Integrals#Elliptic Integrals::.

method:: ellintRf
Returns Carlson's Elliptic Integral RF.

Requires that code::x,y >= 0::, with at most one of them zero, and that code::z >= 0::.

method:: ellintRd
Returns Carlson's Elliptic Integral RD.

Requires that code::x,y >= 0::, with at most one of them zero, and that code::z >= 0::.

method:: ellintRj
Returns Carlson's Elliptic Integral RJ.

Requires that code::x,y,z >= 0::, with at most one of them zero, and that code::p != 0::.

method:: ellintRc
Returns Carlson's Elliptic Integral RC.

Requires that code::x >= 0::, with at most one of them zero, and that code::y != 0::.

method:: ellintRg
Returns Carlson's Elliptic Integral RG.

Requires that code::x,y >= 0::.

method:: ellint1
Returns the incomplete elliptic integral of the first kind, Legendre form.

Requires code::-1 <= k <= 1::.

method:: ellint1C
Returns the complete elliptic integral of the first kind, Legendre form.

Requires code::-1 <= k <= 1::.

method:: ellint2
Returns the incomplete elliptic integral of the second kind, Legendre form.

Requires code::-1 <= k <= 1::.

method:: ellint2C
Returns the complete elliptic integral of the second kind, Legendre form.

Requires code::-1 <= k <= 1::.

method:: ellint3
Returns the incomplete elliptic integral of the third kind, Legendre form.

Requires code::-1 <= k <= 1:: and code::n < 1/sin^2(phi)::.

method:: ellint3C
Returns the complete elliptic integral of the third kind, Legendre form.

Requires code::-1 <= k <= 1:: and code::n < 1::.

method:: ellintD
Returns the incomplete elliptic integral strong::D(phi, k)::, Legendre form.

Requires code::-1 <= k <= 1::.

method:: ellintDC
Returns the complete elliptic integral strong::D(phi, k)::, Legendre form.

Requires code::-1 <= k <= 1::.

method:: jacobiZeta
Returns the result of the Jacobi Zeta Function.

Requires code::-1 <= k <= 1::.

method:: heumanLambda
Returns the result of the Heuman Lambda Function.

Requires code::-1 <= k <= 1::.


subsection:: Jacobi Elliptic Functions

Like all elliptic functions, these can be parameterised in a number of ways:

LIST::
##In terms of a parameter code::m::.
##In terms of the elliptic modulus code::k:: where code::m = k^2::.
##In terms of the modular angle code::α::, where code::m = sin2α::.
::
This implementation takes the elliptic modulus code::k:: as the parameter.
In addition the variable code::u:: is used to express an amplitude strong::φ::.
All take the elliptic modulus as the first argument - this is for alignment with the link::#Elliptic Integrals::.

Take a tour of link::Guides/Tour-of-Special-Functions#Jacobi Elliptic Functions#Jacobi Elliptic Functions::.

method:: jacobiCd

method:: jacobiCn

method:: jacobiCs

method:: jacobiDc

method:: jacobiDn

method:: jacobiDs

method:: jacobiNc

method:: jacobiNd

method:: jacobiNs

method:: jacobiSc

method:: jacobiSd

method:: jacobiSn


subsection:: Zeta Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Zeta Functions#Zeta Functions::.

method:: zeta
Returns the zeta function of code::z::.

Requires code::z != 1::.


subsection:: Exponential Integrals
Take a tour of link::Guides/Tour-of-Special-Functions#Exponential Integrals#Exponential Integrals::.

method:: expintEn
Returns the exponential integral En of code::z::.

Requires that when code::n == 1::, code::z !=0::.

method:: expintEi
Returns the exponential integral of code::z::.

Requires code::z != 0::.


subsection:: Basic Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Basic Functions#Basic Functions::.

method:: sinPi
Returns code::sin(x * π)::.

method:: cosPi
Returns code::cos(x * π)::.

method:: log1p
Returns the natural logarithm of code::x+1::.

method:: expm1
Returns code::e^x - 1::.

method:: cbrt
Returns the cube root of code::x::.

method:: sqrt1pm1
Returns code::sqrt(1+x) - 1::.

method:: powm1
Returns code::x^y - 1::.


subsection:: Sinus Cardinal (Sinc) and Hyperbolic Sinus Cardinal Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Sinus Cardinal (Sinc) and Hyperbolic Sinus Cardinal Functions, Inverse Hyperbolic Functions#Sinus Cardinal (Sinc) and Hyperbolic Sinus Cardinal Functions::.

method:: sincPi
Returns the Sinus Cardinal of code::x::. Also known as the "sinc" function.

code::sincPi(x) = sin(x) / x::

method:: sinhcPi
Returns the Hyperbolic Sinus Cardinal of code::x::.

code::sinhcPi(x) = sinh(x) / x::


subsection:: Inverse Hyperbolic Functions
Take a tour of link::Guides/Tour-of-Special-Functions#Sinus Cardinal (Sinc) and Hyperbolic Sinus Cardinal Functions, Inverse Hyperbolic Functions#Inverse Hyperbolic Functions::.

method:: asinh
Returns the reciprocal of the hyperbolic sine function at code::x::.

method:: acosh
Returns the reciprocal of the hyperbolic cosine function at code::x::.

Requires code::x >= 1::.

method:: atanh
Returns the reciprocal of the hyperbolic sine function at code::x::.

Requires code::-1 < x < 1::.


subsection:: Owen's T Function
Take a tour of link::Guides/Tour-of-Special-Functions#Owen#Owen's T Function::.

method:: owensT
Returns the Owens T function of code::h:: and code::a::.


private:: acosh, airyAi, airyAiPrime, airyAiZero, acosh, airyAi, airyAiPrime, airyAiZero, airyBi, airyBiPrime, airyBiZero, asinh, atanh, bernouliB2n, beta, betaFull, betaFullC, binomialCoefficient, cbrt, chebyshevT, chebyshevTPrime, chebyshevTZeros, chebyshevU, cosPi, cylBesselI, cylBesselIPrime, cylBesselJ, cylBesselJPrime, cylBesselJZero, cylBesselK, cylBesselKPrime, cylHankel1, cylHankel2, cylNeumann, cylNeumannPrime, cylNeumannZero, digamma, doubleFactorial, ellint1, ellint1C, ellint2, ellint2C, ellint3, ellint3C, ellintD, ellintDC, ellintRc, ellintRd, ellintRf, ellintRg, ellintRj, erf, erfC, erfCInv, erfInv, expintEi, expintEn, expm1, factorial, fallingFactorial, gammaP, gammaPDerivative, gammaPInv, gammaPInvA, gammaQ, gammaQDerivative, gammaQInv, gammaQInvA, hermite, heumanLambda, ibeta, ibetaC, ibetaCInv, ibetaCInvA, ibetaCInvB, ibetaDerivative, ibetaInv, ibetaInvA, ibetaInvB, jacobiCd, jacobiCn, jacobiCs, jacobiDc, jacobiDn, jacobiDs, jacobiNc, jacobiNd, jacobiNs, jacobiSc, jacobiSd, jacobiSn, jacobiZeta, laguerre, laguerreAssoc, legendreP, legendrePAssoc, legendrePPrime, legendrePZeros, legendreQ, lgamma, log1p, owensT, polygamma, pow, powm1, prHermite, prLaguerreAssoc, prLegendreQ, risingFactorial, sinPi, sincPi, sinhcPi, sphBessel, sphBesselPrime, sphHankel1, sphHankel2, sphNeumann, sphNeumannPrime, sphericalHarmonic, sphericalHarmonicI, sphericalHarmonicR, sqrt1pm1, tangentT2n, tgamma, tgamma1pm1, tgammaDeltaRatio, tgammaLower, tgammaRatio, tgammaUpper, trigamma, zeta


class:: SinOsc
summary:: Interpolating sine wavetable oscillator.
related:: Classes/Osc, Classes/FSinOsc, Classes/SinOscFB, Classes/PMOsc, Classes/Klang
categories::  UGens>Generators>Deterministic


Description::

Generates a sine wave.
Uses a wavetable lookup oscillator with linear interpolation.
Frequency and phase modulation are provided for audio-rate modulation.
Technically, code::SinOsc:: uses the same implementation as  link::Classes/Osc::  except that its table is fixed to be a sine wave made of code::8192:: samples.

subsection:: Other sinewaves oscillators

LIST::
## link::Classes/FSinOsc:: – fast sinewave oscillator
## link::Classes/SinOscFB:: – sinewave with phase feedback
## link::Classes/PMOsc:: – phase modulation sine oscillator
## link::Classes/Klang:: – bank of sinewave oscillators
## link::Classes/DynKlang:: – modulable bank of sinewave oscillators
::


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.
Sampled at audio-rate.

argument::phase
Phase in radians.
Sampled at audio-rate.
note::phase values should be within the range +-8pi. If your phase values are larger then simply use code::.mod(2pi):: to wrap them.::

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.


Examples::

code::

// create an audio-rate sine wave at 200 Hz,
// starting with phase 0 and an amplitude of 0.5
{ SinOsc.ar(200, 0, 0.5) }.play;

// modulate the frequency with an exponential ramp
{ SinOsc.ar(XLine.kr(2000, 200), 0, 0.5) }.play;

// more complex frequency modulation
{ SinOsc.ar(SinOsc.ar(XLine.kr(1, 1000, 9), 0, 200, 800), 0, 0.25) }.play;

// phase modulation (see also PMOsc)
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(1, 1000, 9), 0, 2pi), 0.25) }.play;

::



class:: SinOscFB
summary:: Feedback FM oscillator
related:: Classes/SinOsc, Classes/FSinOsc, Classes/PMOsc
categories::  UGens>Generators>Deterministic, UGens>Generators>Chaotic


Description::

SinOscFB is a sine oscillator that has phase modulation feedback; its output plugs back into the phase input.
Basically this allows a modulation between a sine wave and a sawtooth like wave. Overmodulation causes chaotic oscillation. It may be useful if you want to simulate feedback FM synths.

Please note: The frequency of SinOscFB can be modulated at control rate. When trying to modulate the frequency of SinOscFB at audio rate, you will notice audible artefacts at higher frequency modulation frequencies. This is due to SinOscFB updating incoming frequency modulation values only once every control period (which is 64 samples long per default), instead of updating on every sample (like e.g. SinOsc).




classmethods::

method::ar, kr

argument::freq

The base frequency of the sine oscillator in Hertz.

argument::feedback

The second argument is the amplitude of phase feedback in radians.

argument::mul

Output will be multiplied by this value.

argument::add

This value will be added to the output after any multiplication.


Examples::

code::


{SinOscFB.ar(440,MouseX.kr(0,4))*0.1}.play


{SinOscFB.ar(MouseY.kr(10,1000,'exponential'),MouseX.kr(0.5pi,pi))*0.1}.play


{SinOscFB.ar(100*SinOscFB.ar(MouseY.kr(1,1000,'exponential'))+200,MouseX.kr(0.5pi,pi))*0.1}.play


// Scope the wave form
{ SinOscFB.ar([400,301], MouseX.kr(0,4),0.3); }.scope;

::


class:: SkipJack
summary:: A utility for background tasks that survive cmd-period
categories:: Scheduling, JITLib>GUI
related:: Classes/CmdPeriod

Description::
SkipJack is a utility to run a function in the background repeatedly, that survive cmd-period.

A typical use is with a window displaying the state of some objects every now and then. (This is better in some cases than
updating the GUI at every change. If the changes happen fast, you don't choke your CPU on gui updating.)

But SkipJack is useful whenever you need a periodic function to run in the background and not go away if the user hits cmd-period.

ClassMethods::

private::initClass

method::new

argument::updateFunc
A link::Classes/Function:: to repeat in the background.

argument::dt
The time interval at which to repeat. It can also be a stream or a function that returns a number.

argument::stopTest
A test whether to stop the task now. Usually a Function.

argument::name
A name for this skipjack. Used for posting information and in the link::#*stop:: classmethod.

argument::clock
The clock that plays the task. Default is link::Classes/AppClock::, so SkipJack can call GUI primitives. If you need more precise timing, you can supply your own clock, and use defer only where necessary.

argument::autostart
When true (default) SkipJack starts automatically as it is created.

method:: stop
Stop a skipjack by name.

method:: stopAll
Stop all skipjacks.

method:: defaultClock
The default clock (AppClock)

method:: verbose
When true, SkipJack posts messages when it starts, stops or restarts.

method:: all
The global set of all skipjacks.

Instancemethods::
private:: cmdPeriod

method:: dt
Get or set the time interval.

method:: task
The internal Routine that wraps updateFunc.

method:: name
The name of this skipjack.

method:: stopTest
The current stopTest. (see argument in link::#*new:: )

method:: start
Start this skipjack.

method:: play
Same as code::start::

method:: stop
Stop this skipjack.

method:: clock
Get or set the clock used. This will only be updated when the skipjack restarts.

method:: updateFunc
The updateFunc set by the argument to link::#*new::

Examples::
Simple example:
code::
w = SkipJack({ "watch...".postln; }, 0.5, name: "test");
SkipJack.verbose = true;    // post stop/wakeup logs

w.stop;
w.start;

// 	now try to stop with cmd-. : SkipJack always restarts itself.
thisProcess.stop;

w.stop;
::

Using stopTest:
code::
a = 5;
w = SkipJack({ "watch...".postln; }, 0.5, { a == 10 }, "test");
a = 10;	// fulfill stopTest
::

Typical use: SkipJack updates a window displaying the state of some objects every now and then.
code::
(
d = (a: 12, b: 24);
d.win = Window("dict", Rect(0,0,200,60)).front;
d.views = [\a, \b].collect { |name, i|
    StaticText(d.win, Rect(i * 100,0,96,20))
        .background_(Color.yellow).align_(0).string_(name);
};
w = SkipJack({
        "...".postln;
        [\a, \b].do { |name, i|
            d.views[i].string_(name ++ ":" + d[name])
        }
    },
    0.5,
    { d.win.isClosed },
    "showdict"
);
)

d.a = 123;      // updates should be displayed
d.b = \otto;
d.win.close;    // when window closes, SkipJack stops.
::

If you need to get rid of an unreachable skipjack:
code::
SkipJack({ "unreachable, unkillable...".postln }, name: "jack");

SkipJack.stopAll        // do this to stop all;

SkipJack.stop("jack");  // reach it by name and stop
::



class:: Slew
summary:: Slew rate limiter.
related:: Classes/Slope, Classes/Ramp, Classes/Lag, Classes/VarLag
categories::  UGens>Filters>Nonlinear


Description::

Limits the slope of an input signal. The slope is expressed in units per
second.

For smoothing out control signals, take a look at link::Classes/Lag:: and link::Classes/VarLag::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::up

Maximum upward slope in units per second.


argument::dn

Maximum downward slope in units per second.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

(
{
	z = LFPulse.ar(800);
	[z, Slew.ar(z, 4000, 4000)]
}.plot)



Has the effect of removing transients and higher frequencies.
(
{

	z = Saw.ar(800,mul:0.2);
	Slew.ar(z,400,400)

}.play
)

::



CLASS:: Slider
summary:: A view consisting of a sliding handle.
categories:: GUI>Views

DESCRIPTION::

A view that allows setting a numerical value by means of moving a sliding handle. It can have horizontal or vertical orientation, meaning the direction in which the handle moves.




CLASSMETHODS::

PRIVATE:: key

METHOD:: new

	When a new Slider is created, its link::#-orientation:: is determined by the initial size: if it is wider than high, the orientation will be horizontal, otherwise it will be vertical.





INSTANCEMETHODS::

PRIVATE:: initSlider


SUBSECTION:: Data

METHOD:: value
	Numerical value between 0 and 1, represented by the handle position within the groove.

	argument::
		A Float.

METHOD:: valueAction
	Sets link::#-value:: and triggers link::#-action::.

METHOD:: increment
	Increments the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: decrement
	Decrements the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.




SUBSECTION:: Appearance

METHOD:: orientation
	The orientation of the Slider - the direction in which the handle moves. The default value depends on the size of the view when created.

	argument::
		One of the two Symbols: \horizontal or \vertical.

METHOD:: thumbSize
	The size of the handle - its width or height, depending on link::#-orientation::.

	argument::
		An Integer amount of pixels.

METHOD:: background
	The color of the background.

	argument::
		A Color.

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: step
	The amount by which the value will changed when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStep
	The absolute amount by which the value would change if the handle moved by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Alt key is pressed.

	argument::
		A Float.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user moves the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## r               || valueAction_(1.0.rand)
	## n               || valueAction_(0)
	## x               || valueAction_(1)
	## c               || valueAction_(0.5)
	## ]               || increment
	## [               || decrement
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::
subsection:: Show the slider value in a NumberBox
code::
(
w = Window.new.front;
c = NumberBox(w, Rect(20, 20, 150, 20));
a = Slider(w, Rect(20, 60, 150, 20))
	.action_({
		c.value_(a.value)
		});
a.action.value;
)

( // change the bounds to become vertical
w = Window.new.front;
c = NumberBox(w, Rect(20, 20, 150, 20));
a = Slider(w, Rect(200, 60, 20, 150))
	.action_({
		c.value_(a.value)
	});
a.action.value;
)
::

subsection:: Use a Spec to round and map the output range
code::
(
w = Window.new.front;
b = ControlSpec(-50, 50, \linear, 0.01); // min, max, mapping, step
c = StaticText(w, Rect(20, 20, 150, 20)).align_(\center).background_(Color.rand);
a = Slider(w, Rect(20, 50, 150, 20))
	.focusColor_(Color.red(alpha:0.2))
	.background_(Color.rand)
	.value_(0.5)
	.action_({
		c.string_(b.map(a.value).asString)
		// round the float so it will fit in the NumberBox
		});
a.action.value;
)
::

subsection:: Change the stepsize of the slider, selected via a PopUpMenu
code::
(
w = Window.new.front;
a = ["0", "0.0625", "0.125", "0.25", "0.5", "1"];
b = Slider(w, Rect(20, 100, 100, 20))
	.action_({
		c.value_(b.value)
		}).background_(Color.rand);
d = PopUpMenu(w, Rect(20, 60, 100, 20))
	.items_(a)
	.action_({
		b.step_((a.at(d.value)).asFloat);
	});
StaticText(w, Rect(130, 60, 100, 20)).string_("change step");
c = NumberBox(w, Rect(20, 20, 100, 20));
)
::

subsection:: Use the slider view to accept key actions
code::
( // select the slider, type something and watch the post window
w = Window.new;
c = Slider(w, Rect(0,0,100,30));
c.keyDownAction = { |view, char, modifiers, unicode, keycode|
	[char, modifiers, unicode, keycode].postln
};
w.front;
)
::

subsection:: Adding functionality to a view by the method addAction
This is useful for adding things to existing frameworks that have action functions already.
code::
(
w = Window.new("A Slider");
a = Slider.new(w, Rect(40, 10, 300, 30));
w.front
);

// now incrementally add some action to the slider
a.addAction({ |sl| sl.value.postln });
a.addAction({ |sl| w.view.background = Color.green(sl.value) });
a.addAction({ |sl| sl.background = Color.red(1 - sl.value) });

// adding and removing an action:
f = { |sl| "--------*******-------".postln; };
a.addAction(f);
a.removeAction(f);

// or remove all, of course
a.action = nil;
::

subsection:: Use Slider for triggering sounds
code::

(
s.waitForBoot({

	SynthDef(\pluck, { |out, freq=55|
		Out.ar(out,
			Pluck.ar(WhiteNoise.ar(0.06),
				EnvGen.kr(Env.perc(0,4), 1.0, doneAction: Done.freeSelf),
				freq.reciprocal,
				freq.reciprocal,
				10,
				coef:0.1)
		);
	}).add;


	w = Window.new("Hold arrow keys to trigger sound",
		Rect(300, Window.screenBounds.height - 300, 400, 100)).front;
	a = Slider(w, Rect(50, 20, 300, 40)).value_(0.5).step_(0.05).focus
	.action_({
		// trigger a synth with varying frequencies
		Synth(\pluck, [\freq, 55 + (1100 * a.value)]);
		w.view.background_(Gradient(Color.rand,Color.rand));
	})
});
)
::

subsection:: Change background color of Window
code::
(
w = Window("RGB fader", Rect(100, 500, 400, 400))
	.front;
f = { w.view.background_(Color.new(r.value, g.value, b.value, 1)) };
r = Slider(w, Rect(100, 140, 200, 20))
	.value_(0.5)
	.action_({ f.value });
g = Slider(w, Rect(100, 170, 200, 20))
	.value_(0.5)
	.action_({ f.value });
b = Slider(w, Rect(100, 200, 200, 20))
	.value_(0.5)
	.action_({ f.value });
f.value;
);
::


class:: Slider2D
summary:: A view with a handle movable in two dimensions.
categories:: GUI>Views

DESCRIPTION::

A view that allows setting two numerical values represented by the horizontal and vertical position of a handle movable in two dimensions.

The values are always within the range between 0 and 1. Scaling the output and input values to your needs can easily be achieved by using a link::Classes/ControlSpec:: with its link::Classes/ControlSpec#-map#-map:: and link::Classes/ControlSpec#-unmap#-unmap:: methods.

The link::#-step:: variable determines the amount by which the values will change when the handle is controlled using the keyboard. By default, holding down the Shift, Ctrl, or Alt key will multiply this amount by 100, 10, or 0.1 respectively, though you can customize this by setting link::#-shift_scale::, link::#-ctrl_scale::, or link::#-alt_scale::.

Drag and drop gives and accepts a link::Classes/Point:: of which the two coordinates represent the two values of the Slider2D.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: x
	The value represented by the horizontal position of the handle. It will always be clipped to the range between 0 and 1.

	argument::
		A Float.

METHOD:: y
	The value represented by the vertical position of the handle. It will always be clipped to the range between 0 and 1.

	argument::
		A Float.

METHOD:: activex
	Sets link::#-x:: and triggers the link::#-action::.


METHOD:: activey
	Sets link::#-y:: and triggers the link::#-action::.

METHOD:: setXY
	Sets link::#-x:: and link::#-y:: to the two arguments.

METHOD:: setXYActive
	Sets link::#-x:: and link::#-y:: to the two arguments, and triggers the link::#-action::.

METHOD:: incrementX
	Increments link::#-x:: by link::#-step:: multiplied by code::factor::.

METHOD:: decrementX
	Decrements link::#-x:: by link::#-step:: multiplied by code::factor::.

METHOD:: incrementY
	Increments link::#-y:: by link::#-step:: multiplied by code::factor::.

METHOD:: decrementY
	Decrements link::#-y:: by link::#-step:: multiplied by code::factor::.




SUBSECTION:: Appearance

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: step
	The amount by which link::#-x:: or link::#-y:: will change when incremented or decremented, either by calling relevant methods, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStepX
	The absolute amount by which link::#-x:: would change if the handle moved horizontally by one pixel.

	returns::
		A Float.

METHOD:: pixelStepY
	The absolute amount by which link::#-y:: would change if the handle moved vertically by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the position or size of the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## r               || x_(1.rand), y_(1.rand), and triggers action
	## n               || x_(0), y_(0), and triggers action
	## x               || x_(1), y_(1), and triggers action
	## c               || x_(0.5), y_(0.5), and triggers action
	## up arrow        || incrementY
	## down arrow      || decrementY
	## right arrow     || incrementX
	## left arrow      || decrementX
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		A Point of which the x and y coordinates are set to link::#-x:: and link::#-y::, respectively.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Point.

METHOD:: defaultReceiveDrag
	Sets link::#-x:: and link::#-y:: to the two coordinates of the Point stored as the current drag data, respectively, and triggers the link::#-action::.




EXAMPLES::

code::
(
w = Window("Slider2D", Rect(100, 100, 140, 140));
t = Slider2D(w, Rect(20, 20, 80, 80))
		.x_(0.5) // initial location of x
		.y_(1)   // initial location of y
		.action_({|sl|
			[\sliderX, sl.x, \sliderY, sl.y].postln;
		});
w.front;
)

t.x        // get the x loc
t.x_(0.25) // set the x loc
::

Drag an drop Points
code::
(
w = Window("Slider2D", Rect(100, 100, 500, 300));
w.view.decorator = FlowLayout(w.view.bounds);
t = Slider2D(w, Rect(20, 20, 280, 280))
		.x_(0.5) // initial location of x
		.y_(1)   // initial location of y
		.background_(Color.rand)
		.action_({|sl|
			[\sliderX, sl.x, \sliderY, sl.y].postln;
		});
t.step_(0.01);

n = CompositeView.new(w, 200@300);
n.decorator = FlowLayout(n.bounds);

v = { |i| DragBoth.new(n, Rect(0, i * 20, 200, 20)).background_(Color.rand).align_(\center) }.dup(5);

StaticText.new(n, 200@150).string_("hold down cmd and drag points from the slider to the drag slots, or reverse").stringColor_(Color.white);

w.front;
)
::

Shape a Sound
code::
(
s.waitForBoot({
	a = {arg mod = 0.05, index = 0.05;
			var r,out, out2;
			r = Saw.ar(8, 0.03);
			out = PMOsc.ar(
				440,
				660 * mod, 3 * index, 0,
				Lag.ar(r,0.01,1));
			[out,Delay1.ar(out)];
	}.play;

	w = Window("Slider2D", Rect(100,Window.screenBounds.height - 400, 300, 300));
	w.view.decorator = FlowLayout(w.view.bounds);
	t = Slider2D(w, Rect(0, 0,292, 292))
			.y_(0.05)
			.x_(0.05)
			.background_(Color.rand)
			.knobColor_(Color.rand)
			.action_({|sl|
				a.set(\mod,sl.x,\index,sl.y);
			});
	w.front;
	CmdPeriod.doOnce({w.close});
})
)
::


class:: Slope
summary:: Slope of signal
categories:: UGens>Analysis, UGens>Filters>Linear, UGens>Maths

description::
Measures the rate of change per second of a signal.
Formula implemented is:

code::
out[i] = (in[i] - in[i-1]) * sampling_rate
::

classmethods::
method:: ar, kr
argument::in
Input signal to measure.
argument::mul
argument::add

examples::
code::
(
{
    var a, b, c, scale;
    a = LFNoise2.ar(2000);  // quadratic noise
    b = Slope.ar(a);        // first derivative produces line segments
    c = Slope.ar(b);        // second derivative produces constant segments
    scale = 0.0002; // needed to scale back to +/- 1.0
    [a, b * scale, c * scale.squared]
}.plot
)
::

For another example of Slope see link::Classes/AbstractFunction#-hypot::.



CLASS::SortedList
summary::a Collection whose items are kept in a sorted order.
categories::Collections>Ordered

CLASSMETHODS::

method::new
Creates a SortedList with the initial capacity given by strong::size:: and a comparison strong::function::. The SortedList can contain equal / identical elements more than once.

INSTANCEMETHODS::

private::indexForInserting

method::add
Adds an item in the SortedList at the correct position.
code::
SortedList[1, 2, 5, 6].add(4).postln;
::

method::addAll
Adds all the items in the collection into the SortedList.
code::
SortedList[1, 2, 5, 6].addAll([0, 3, 4, 7]).postln;
::


class:: SoundFile
summary:: sclang soundfile data
related:: Classes/File, Classes/Buffer
categories:: Files

description::
The SoundFile class is used to check the size, format, channels etc. when the sclang client needs this information about a SoundFile. Soundfile data can be read and modified. Soundfile data can also be read and written incrementally, so with properly designed code, there is no restriction on the file size.

In most cases you will wish to send commands to the server to get it to load SoundFiles directly into Buffers. You will not need to use this class for this. See the link::Classes/Buffer:: helpfile.

code::
(
f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
f.inspect;
f.close;
)
::

When reading a sound file, the headerFormat, sampleFormat, numChannels and numFrames variables will be set according to the file on disk.

When creating a new SoundFile, the format will be monophonic, 44.1 kHz, AIFF, floating-point by default. Users may override the defaults by passing the desired format strings to link::Classes/SoundFile#*openWrite::, or by using link::Classes/SoundFile#-headerFormat::, link::Classes/SoundFile#-sampleFormat::, link::Classes/SoundFile#-numChannels:: and link::Classes/SoundFile#-sampleRate:: emphasis::before:: calling link::Classes/SoundFile#-openWrite::.

ClassMethods::

method::new
Creates a new SoundFile instance.

method:: openRead
Try to open the audio file at the given path.

argument:: pathName
Full path to the sound file. Use link::Classes/String#-standardizePath:: to resolve home-folder shortcuts such as teletype::~::.

returns:: A new SoundFile instance if successful, or code::nil:: if file open failed. User code should check for code::nil:: before doing anything with the SoundFile object.

method:: openWrite
Try to create an audio file at the given path. Note that there is no code::numFrames:: argument: the number of frames is counted after writing data into the file.

argument:: pathName
Full path to the sound file. Use link::Classes/String#-standardizePath:: to resolve home-folder shortcuts such as teletype::~::.

argument:: headerFormat
A string for the sound file format. Valid strings are listed at link::Classes/SoundFile#-headerFormat::. If not given, the default code::"AIFF":: is used.

argument:: sampleFormat
A string for the sample format. Valid strings are listed at link::Classes/SoundFile#-sampleFormat::. If not given, the default code::"float":: is used.

argument:: numChannels
An integer number of channels (1 by default).

argument:: sampleRate
An integer sample rate (44100 by default).

returns:: A new SoundFile instance if successful, or code::nil:: if file open failed. User code should check for code::nil:: before doing anything with the SoundFile object.

method::collect
Returns an link::Classes/Array:: of SoundFile objects whose paths match the pattern. (The associated files are closed. These objects can be used to cue playback buffers)
code::
SoundFile.collect("sounds/*").do { |f| f.path.postln };
::

method::use
Reads the data of a SoundFile, evaluates the function (passing the file as argument) and closes it again.
code::
SoundFile.use(Platform.resourceDir +/+ "sounds/a11wlk01.wav", { |f| f.inspect });
::

method::normalize
Normalizes a soundfile to a level set by the user. The normalized audio will be written into a second file.

Using this class method (SoundFile.normalize) will automatically open the source file for you. You may also link::#-openRead:: the SoundFile yourself and call link::#-normalize:: on it. In that case, the source path is omitted because the file is already open.

See instance method link::#-normalize:: for more information.

InstanceMethods::

private::prOpenRead, prOpenWrite

subsection::Playback

method::cue
Allocates a buffer and cues the SoundFile for playback. Returns an event parameterized to play that buffer. (See link::Reference/NodeEvent:: for a description of how events can be used to control running synths.) The event responds to strong::play::, strong::stop::, strong::pause::, strong::resume::, keeping the buffer open. The buffer is closed when the event is sent a strong::close:: message.

argument::ev
An link::Classes/Event:: can passed as an argument allowing playback to be customized using the following keys:
table::
## strong::key:: || strong::default value:: || strong::what it does::
## bufferSize || 65536 || Must be a power of two (65536, 131072 or 262144 recommended)
## firstFrame || 0 || first frame to play
## lastFrame || nil || last frame to play (nil plays to end of file)
## out: || 0 || sets output bus
## server: || Server.default || which server
## group: || 1 || what target
## addAction: || 0 || head/tail/before/after
## amp: || 1 || amplitude
## instrument: || nil || if nil SoundFile:cue determines the SynthDef (one of diskIn1, diskIn2, ...diskIn16)
::
Where strong::bufferSize::, strong::firstFrame::, strong::lastFrame:: are for buffer and playback position, and strong::out::, strong::server::, strong::group::, strong::addAction::, strong::amp:: are synth parameters. Here is the default SynthDef used for stereo files:
code::
SynthDef(\diskIn2, { |out, amp=1, bufnum, sustainTime, atk=0, rel=0, gate=1|
	var sig = VDiskIn.ar(2, bufnum, BufRateScale.kr(bufnum));
	var gateEnv = EnvGen.kr(Env([1, 1, 0], [sustainTime-rel, 0]));
	var env = EnvGen.kr(Env.asr(atk, 1, rel), gate * gateEnv, doneAction: Done.freeSelf);
	Out.ar(out, sig * env * amp)
});
::
The control strong::sustainTime:: determines playback duration based on the firstFrame and lastFrame. The control strong::gate:: allows early termination of the playback

argument::playNow
This is a link::Classes/Boolean:: that determines whether the file is to be played immediately after cueing.
code::
f = SoundFile.collect("sounds/*");
e = f[1].cue;

e = f[1].cue( (addAction: 2, group: 1) );	// synth will play ahead of the default group
::

argument:: closeWhenDone

A flag to indicate whether the buffer will be closed after playback is finished. Default is False.

subsection::Read/Write

method::openRead
Read the header of a file. Answers a link::Classes/Boolean:: whether the read was successful. Sets the link::#-numFrames::, link::#-numChannels:: and link::#-sampleRate::. Does strong::not:: set the link::#-headerFormat:: and link::#-sampleFormat::.

argument::pathName
a link::Classes/String:: specifying the path name of the file to read.

method::readData
Reads the sample data of the file into the raw array you supply. You must have already called link::#-openRead::.

When you reach EOF, the array's size will be 0. Checking the array size is an effective termination condition when looping through a sound file. See the method link::#-channelPeaks:: for example.

argument::rawArray
The raw array must be a link::Classes/FloatArray::. Regardless of the sample format of the file, the array will be populated with floating point values. For integer formats, the floats will all be in the range -1..1.

The size of the FloatArray determines the maximum number of single samples (not sample frames) that will be read. If there are not enough samples left in the file, the size of the array after the readData call will be less than the original size.

method::openWrite
Write the header of a file. Answers a link::Classes/Boolean:: whether the write was successful.

argument::pathName
a link::Classes/String:: specifying the path name of the file to write.

method::writeData
Writes the rawArray to the sample data of the file. You must have already called link::#-openWrite::.

argument::rawArray
The raw array must be a link::Classes/FloatArray:: or link::Classes/Signal::, with all values between -1 and 1 to avoid clipping during playback.
code::
(
f = SoundFile.new.headerFormat_("AIFF").sampleFormat_("int16").numChannels_(1);
f.openWrite("sounds/sfwrite.aiff");
	// sawtooth
b = Signal.sineFill(100, (1..20).reciprocal);
	// write multiple cycles (441 * 100 = 1 sec worth)
441.do({ f.writeData(b) });
f.close;
)
::

method::isOpen
answers if the file is open.

method::close
closes the file.

method::duration
the duration in seconds of the file.

subsection::Normalizing

method::normalize
Normalizes a soundfile to a level set by the user. The normalized audio will be written into a second file.

The normalizer may be used to convert a soundfile from one sample format to another (e.g., to take a floating point soundfile produced by SuperCollider and produce an int16 or int24 soundfile suitable for use in other applications).

note::
While the normalizer is working, there is no feedback to the user. It will look like SuperCollider is hung, but it will eventually complete the operation. You can set code::threaded:true:: to get feedback but it will take slightly longer to complete.
::

argument::outPath
a path to the destination file.

argument::newHeaderFormat
the desired header format of the new file; if not specified, the header format of the source file will be used.

argument::newSampleFormat
the desired sample format of the new file; if not specified, the sample format of the source file will be used.

argument::startFrame
an index to the sample frame to start normalizing.

argument::numFrames
the number of sample frames to copy into the destination file (default nil, or entire soundfile).

argument::maxAmp
the desired maximum amplitude. Provide a floating point number or, if desired, an array to specify a different level for each channel.

argument::linkChannels
a link::Classes/Boolean:: specifying whether all channels should be scaled by the same amount. The default is strong::true::, meaning that the peak calculation will be based on the largest sample in any channel. If false, each channel's peak will be calculated independently and all channels will be scaled to maxAmp (this would alter the relative loudness of each channel).

argument::chunkSize
how many samples to read at once (default is 4194304, or 16 MB).

argument::threaded
if true, the normalization runs in a routine so that SC can respond (intermittently) while processing. Prevents macOS beachballing.

subsection::Instance Variables

method::path
Get the pathname of the file. This variable is set via the link::#-openRead:: or link::#-openWrite:: calls.

method::headerFormat
This is a link::Classes/String:: indicating the header format which was read by openRead and will be written by openWrite. In order to write a file with a certain header format you set this variable.

definitionList::
## read/write header formats: ||
table::
## strong:: header :: || strong:: description:: || strong:: filename extensions:: || strong::notes::
## "AIFF" || Apple/SGI AIFF format || .aif, .aiff ||
## "WAV","WAVE", "RIFF" || Microsoft WAV format || .wav, .wave ||
## "Sun", "NeXT" || Sun/NeXT AU format || .au, .snd ||
## "SD2" || Sound Designer 2 || .sd2 ||
## "IRCAM" || Berkeley/IRCAM/CARL || .sf ||
## "raw" || no header = raw data || ||
## "MAT4" || Matlab (tm) V4.2 / GNU Octave 2.0 || .mat4 ||
## "MAT5" || Matlab (tm) V5.0 / GNU Octave 2.1 || .mat5 ||
## "PAF" || Ensoniq PARIS file format || .paf ||
## "SVX" || Amiga IFF / SVX8 / SV16 format || .svx ||
## "NIST" || Sphere NIST format || .nist, .sph ||
## "VOC" || VOC files || .voc ||
## "W64" || Sonic Foundry's 64 bit RIFF/WAV || .w64 || supports files larger than 4GB
## "PVF" || Portable Voice Format || .pvf ||
## "XI" || Fasttracker 2 Extended Instrument || .xm ||
## "HTK" || HMM Tool Kit format || .htk ||
## "SDS" || Midi Sample Dump Standard || .sds ||
## "AVR" || Audio Visual Research || .avr ||
## "FLAC" || FLAC lossless file format || .flac ||
## "CAF" || Core Audio File format || .caf || supports files larger than 4GB
## "RF64" || RF64 WAV format || .wav || supports files larger than 4GB
## "OGG" || Xiph OGG container || .ogg || use .ogg extension for the "vorbis" format (see below)
## "MPEG" || MPEG container || .mp1, .mp2, .mp3 || file extension depends on the format (see below)
::
::
Additionally, a huge number of other formats are supported read only. Please note that WAV file support is limited to 4GB. For output of multiple channels or very long recordings we suggest to use RF64, W64, or CAF (on macOS).


method::sampleFormat
A link::Classes/String:: indicating the format of the sample data which was read by link::#-openRead:: and will be written by link::#-openWrite::. libsndfile determines which header formats support which sample formats. This information is detailed at http://www.mega-nerd.com/libsndfile . The possible sample formats are:
definitionList::
## sample formats: ||
table::
## strong:: format :: || strong:: notes:: || strong::supported headers:: (partial list) 
## "int8", "int16", "int24", "int32" || integer formats || "AIFF", "WAV", "RF64", "W64", "CAF", "FLAC" 
## "float" || floating-point format (won't clip above 0dB) || "AIFF", "WAV", "RF64", "W64", "CAF" 
## "mulaw", "alaw" || U-law and A-law encoding|| "WAV", "W64" 
## "vorbis" || "Vorbis" compressed format || "OGG" 
## "mp1", "mp2", "mp3" ||  MPEG Layer I, II, and III compressed formats || "MPEG" (see strong::NOTE:: below)
::
::
Not all header formats support all sample formats.

Note::
Support for code::MPEG:: formats requires code::libsndfile:: library that supports it. This library is included in SuperCollider's macOS and Windows release builds version teletype::3.13:: and up. However, on platforms where system installation of libsndfile is used (e.g. Linux), or when building SC locally, MPEG support requires code::libsndfile:: version teletype::1.1.0:: or higher and that the library was built with the MPEG functionality enabled.
::

Currently there's no way to control the quality (bitrate) when writing OGG vorbis and MPEG files - the default bitrate set in libsndfile is used.


method::numFrames
The number of sample frames in the file.

method::numChannels
The number of channels in the file.

method::sampleRate
The sample rate of the file.

examples::
code::
// Writing a sound file, long form:
// Set the format variables before calling 'openWrite'
// The Boolean answer from 'openWrite' tells you if it's safe to proceed
(
f = SoundFile(PathName.tmp +/+ "sf-help.wav");
f.headerFormat = "WAV";
f.sampleFormat = "int16";
if(f.openWrite) {
	f.writeData(Signal.sineFill(1024, [1]));
	f.close;
} {
	"Failed to open %".format(f.path).warn;
};
)

// Or, short form: Class method 'openWrite'
// f is nil if the file couldn't be opened
(
var p = PathName.tmp +/+ "sf-help.wav";
f = SoundFile.openWrite(p, "WAV", "int16");
if(f.notNil) {
	f.writeData(Signal.sineFill(1024, [1]));
	f.close;
} {
	"Failed to open %".format(p).warn;
};
)

// Reading the file
f = SoundFile.openRead(PathName.tmp +/+ "sf-help.wav");
f.sampleFormat;

// To get data, create a FloatArray or Signal first
d = FloatArray.newClear(f.numFrames);
f.readData(d);
d.plot;
f.close;

s.boot;

// It's a proper audio file -- server can load it
b = Buffer.read(s, PathName.tmp +/+ "sf-help.wav");

// It's a sinewave...
a = { (PlayBuf.ar(1, b, rate: 440 * 1024/44100, loop: 1) * 0.1).dup }.play;
a.free;

b.free;
File.delete(PathName.tmp +/+ "sf-help.wav");
::


class:: SoundFileView
summary:: Sound file display
categories:: GUI>Views
related:: Classes/SoundFile


DESCRIPTION::

A sound file viewer with numerous options.

Zoom in and out using Shift + right-click + mouse-up/down;

Scroll using right-click + mouse-left/right.

CLASSMETHODS::

PRIVATE:: key


INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: soundfile

    argument::
        An Instance of SoundFile to display.


METHOD:: read

    Reads a section of the link::#-soundfile:: and displays it in the view. For large files, you may want to use readWithTask instead.

    The 'block' argument has no effect; the display resolution is infinite.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.

    argument:: doneAction
        A Function called when the file reading has completed.


METHOD:: readFile

    Reads a section of an open instance of SoundFile, and displays it in the view. For large files, you may want to use the method readWithTask instead.

   The 'block' argument has no effect; the display resolution is infinite.

    argument:: aSoundFile
        An open instance of SoundFile.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.
    argument:: doneAction
        A Function called when the file reading has completed.

METHOD:: readWithTask

    Reads a section of the link::#-soundfile:: asynchronously (in the background), updating the link::#-readProgress:: along the way. If the code::showProgress:: argument is code::true::, a SoundFileViewProgressWindow opens to show the progress.

   The 'block' argument has no effect; the display resolution is infinite. The 'showProgress' argument has no effect; the view always displays reading progress within itself.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: doneAction
        An optional function to be evaluated on completion.

    argument:: showProgress
        Whether to open a progress window. Defaults to code::true::.


METHOD:: readFileWithTask

    Reads a section of an open instance of SoundFile asynchronously (in the background), updating the link::#-readProgress:: along the way. If the code::showProgress:: argument is code::true::, a SoundFileViewProgressWindow opens to show the progress.

        The 'block' argument has no effect; the display resolution is infinite.
        The 'showProgress' argument has no effect; the view always displays reading progress within itself.

    argument:: soundFile
        An open instance of SoundFile.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: doneAction
        An optional function to be evaluated on completion.

    argument:: showProgress
        Whether to open a progress window. Defaults to code::true::.

METHOD:: data

    Sets custom data instead of a sound file. This is a setter only; it is not possible to get the data. If you need access to the data, you must keep it in your own variable.

   Setting this property assumes 1 channel and sample rate of 44100 Hz. Use link::#-setData:: instead if you want more control.

    argument::
        An Array of Floats; multiple channel data should be interleaved.

METHOD:: setData

    Sets custom display data instead of a sound file, interpreting it using specified number of channels and sample rate.


    argument:: data
        An Array of Floats; multiple channel data should be interleaved.

    argument:: block
The block size - visual resolution of the display. An Integer of the form 2**n. (since the port to QT, the 'block' argument has no effect; the display resolution is infinite).

    argument:: startFrame
        An integer.

    argument:: channels
        An integer.

    argument:: samplerate
        An integer.

METHOD:: alloc

Allocates a desired amount of display channels and frames; all frames have initial value of 0.

    argument:: frames
        An Integer.
    argument:: channels
        An Integer.
    argument:: samplerate
        An Integer.

METHOD:: set

Overwrites a range of display data with another data. This method can be used after link::#-alloc:: or link::#-setData:: has been called, but not while the view is displaying a sound file.

    argument:: offset
        The frame at which to start overwriting; an Integer.
    argument:: data
        The new data; an Array of Floats; multiple channel data should be interleaved.

METHOD:: startFrame

    The beginning of the read section of the soundfile, or 0 if link::#-alloc:: or link::#-setData:: has been used.

METHOD:: numFrames

    The total amount of frames in the view; this is unrelated to link::#-zoom#zooming:: and link::#-scroll#scrolling::.

METHOD:: readProgress

     The reading progress, updated periodically when reading a soundfile using link::#-readWithTask:: or link::#-readFileWithTask::.

SUBSECTION:: Navigation

METHOD:: viewFrames

    The amount of currently visible frames in the view.

METHOD:: zoom

    Zooms by a factor relative to current zoom.

    argument::
        A Float.

METHOD:: zoomToFrac

    Zooms to a specific scale.

    argument::
        A Float.

METHOD:: zoomAllOut

    Zooms to the link::#-currentSelection#current selection::.

METHOD:: zoomSelection

    Zooms to a specific selection.

    argument::
        The index of the selection; an Integer between 0 an 63.

METHOD:: xZoom
    The number of seconds of audio to display in the view. E.g., to zoom out by a factor of 2, code::view.xZoom = dataDuration / 2::. (You are responsible for keeping track of the data duration.)

    returns:: A Float, in seconds of audio displayed.

METHOD:: yZoom
    Vertical scaling. The default code::yZoom = 1:: sets ±1.0 to the top and bottom of the view. If code::yZoom = 2::, the view covers ±0.5 of the value range.

    returns:: A Float scaling factor.

METHOD:: yOffset
    Vertical offset. The default code::yOffset = 0:: sets value of 0.0 in the middle of the channel's view, while code::yOffset = 1::, sets 0.0 at the top and code::yOffset = -1:: sets 0.0 at the bottom of the view. This is performed after (and thus is not scaled by) the link::#-yZoom:: factor.

    returns:: A Float offset.

METHOD:: spacing
    A ratio between vertical space outside of the ±1.0 value range and channel's full height. The default code::spacing = 0.1:: makes top and bottom spaces add up to code::0.1 * height:: (each of them occupying half of that), while ±1.0 value range occupies code::0.9 * height::. The value is clipped in the range from code::0.0:: to  code:: 1.0::.

    returns:: A Float scaling factor.

METHOD:: scrollPos

    The scrolling position of the view, as a fraction of the total scrolling range. The total scrolling range is code::totalDuration - xZoom::.

    returns::
        A Float in the range of 0.0 to 1.0.

METHOD:: scrollTo

    Scrolls to a fraction of the total scrolling range. The total scrolling range is code::totalDuration - xZoom::.

    argument::
        A Float in the range of 0.0 to 1.0.

METHOD:: scroll

    Scrolls by a fraction of the visible range.

    argument::
        A Float.

METHOD:: scrollToStart

    Scrolls to the beginning.

METHOD:: scrollToEnd

    Scrolls to the end.

SUBSECTION:: Selection

METHOD:: selections

    All the selections.

    returns:: An array of 64 arrays of start frames and sizes: [ [ start0, size0 ] , [ start1, size1 ], ... ].

METHOD:: selection

    The selection at index.

    returns::
        An Array of the form code::[start, size]::, where start and size denote frames.

METHOD:: setSelection

    Sets the selection at index.

    argument:: index
        An Integer between 0 an 63.

    argument:: selection
        An Array of the form code::[start, size]::, where start and size are Integers and denote frames.

METHOD:: currentSelection

    The index of the current selection

    argument::
        An integer between 0 an 63.

METHOD:: selectionStart

    The start frame of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        An Integer.

METHOD:: setSelectionStart

    Sets the start frame of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: frame
        The starting frame of the selection, an Integer.

METHOD:: selectionSize

    The size of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        An Integer.

METHOD:: setSelectionSize

    Sets the size of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: frames
        The size in frames of the selection, an Integer.

METHOD:: selectionStartTime

    The start of a selection in seconds.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        A Float.

METHOD:: selectionDuration

    The size of a selection in seconds.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        A Float.

METHOD:: selectAll

    Sets a selection to span the whole data range.

    argument:: index
        The index of the selection; an Integer between 0 an 63.


METHOD:: selectNone

    Sets the size of a selection to 0.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

METHOD:: setSelectionColor

    Sets the color of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: color
        A Color.

METHOD:: setEditableSelectionStart

    Sets whether the start point of a selection can be edited.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: editable
        A Boolean.

METHOD:: setEditableSelectionSize

    Whether the end point of a selection can be edited.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: editable
        A Boolean.

METHOD:: readSelection

    note:: Not implemented ::

    Read the data within a selection.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.

METHOD:: readSelectionWithTask

    note:: Not implemented ::

    Read the data within the current selection asynchronously (in the background), showing the progress in a separate window.


SUBSECTION:: Display

METHOD:: peakColor

    The color of the peak-to-peak data. This can be overridden by link::#-waveColors::. Defaults to code::Color(0.95, 0.7)::.

    argument::
        A code::Color::.

METHOD:: rmsColor

    The color of the RMS data. Defaults to code::Color(1.0, 1.0)::.

    argument::
        A code::Color::.

METHOD:: waveColors

    An array of colors for the peak-to-peak data for each channel, allowing each channel to be represented by a different color. Defaults to code::[ ]::. Once set, it overrides link::#-peakColor::. In order to revert to using code::.peakColor::, set code::.waveColors:: back to an empty array: code::.waveColors_([])::.

    note::link::#-rmsColor:: stays the same for all channels. However, using alpha blending, it is possible to display RMS data using either a lighter (e.g. code::.rmsColor_(Color.grey(1, 0.3))::) or a darker (e.g. code::.rmsColor_(Color.grey(0, 0.3))::) shade of the peak-to-peak color.::

    argument::
        And array of code::[Color]::.

METHOD:: gridOn

    Whether the grid is displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: gridResolution

    The resolution of the grid.

    argument::
        An instance of Float.

METHOD:: gridOffset

    Sets the grid offset.

    argument::
        Grid blocks are offset by this value (in seconds).

METHOD:: gridColor

    The color of the grid.

    argument::
        A Color.

METHOD:: drawsWaveForm

    Whether the data is displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: drawsRMS

    Whether the RMS data for the waveform is displayed. Defaults to code::true::.

METHOD:: drawsCenterLine

    Whether the center line (at value 0.0) is displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: drawsBoundingLines

    Whether the bounding lines (at values ±1.0) are displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: timeCursorOn

    Whether the time cursor is displayed. Defaults to code::false::.

    argument::
        A Boolean.

METHOD:: timeCursorPosition

    The position of the time cursor in frames.

    argument::
        An Integer.

METHOD:: timeCursorColor

    The color of the time cursor.

    argument::
        A Color.

METHOD:: elasticMode

    Not operational, for compatibility only.

SUBSECTION:: Actions

METHOD:: action

    The object to be evaluated whenever the user interacts with the view.

METHOD:: metaAction

    The object to be evaluated on Ctrl + click.


EXAMPLES::

SUBSECTION:: Basic example

code::

// To zoom in/out: Shift + right-click + mouse-up/down
// To scroll: right-click + mouse-left/right
(
w = Window.new("soundfile test", Rect(200, 300, 740, 100));
a = SoundFileView.new(w, Rect(20,20, 700, 60));

f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
f.inspect;

a.soundfile = f;
a.read(0, f.numFrames);

a.timeCursorOn = true;
a.timeCursorColor = Color.red;
a.timeCursorPosition = 2050;
a.drawsWaveForm = true;
a.gridOn = true;
a.gridResolution = 0.2;

w.front;
)
::

SUBSECTION:: Step by step examples

code::
( // make a simple SoundFileView
y = Window.screenBounds.height - 120;
w = Window.new("soundfile test", Rect(200, y, 740, 100)).alwaysOnTop_(true);
w.front;
a = SoundFileView.new(w, Rect(20,20, 700, 60));

f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// f.inspect;

a.soundfile = f;            // set soundfile
a.read(0, f.numFrames);     // read in the entire file.
a.refresh;                  // refresh to display the file.
)

// To zoom in/out: Shift + right-click + mouse-up/down
// To scroll: right-click + mouse-left/right

// reading file
a.read(0, f.numFrames / 2).refresh; // read first half
a.read.refresh;                     // read entire file by default
a.read(f.numFrames / 2).refresh;    // read second half
a.read(0, -1).refresh;              // -1 also reads entire file, like buffer.

// the resolution of the view is always infinite;
// you can always zoom in until you see a single sample.

a.read(0, -1).refresh;

// for longer files, you can use:
a.readWithTask;

// zoom is relative
a.zoom(0.2).refresh;
a.zoom(2).refresh;
a.zoom(2).refresh;
a.zoomToFrac(0.5); // zoom to half file size
a.zoomAllOut;

a.gridOn = true;            // time grid, 1 second by default,
a.gridResolution = 0.2;     // or set resolution in seconds
a.gridColor = Color.cyan;   // color is changeable.
a.gridOffset_(0.1);         // not sure if this is working?

a.timeCursorOn = true;          // a settable cursor
a.timeCursorPosition = 2050;    // position is in frames.
a.timeCursorColor = Color.white;

// toggle drawing on/off
a.drawsWaveForm = false;
a.drawsWaveForm = true;

// these methods should return view properties:
a.gridOn
a.gridResolution
a.gridColor
a.timeCursorOn
a.timeCursorPosition
a.timeCursorColor

// Selections: multiple selections are supported.
// e.g. use selection 0:
a.setSelectionColor(0, Color.red);  // set...( index, value )
a.selectionStart(0);                // at index
a.setSelectionStart(0, 12345);
a.setSelectionSize(0, 12345);

a.setSelectionStart(0, 1234);
a.selectionStart(0);

// now selection 1
a.setSelectionColor(1, Color.white);
a.setSelectionStart(1, 1234).setSelectionSize(1, 1234 * 2);
a.selectionStart(1);
a.setSelectionStart(0, 12345);

// the current selection gets changed when click/dragging in view.
a.currentSelection;     // index of current selection;
a.currentSelection_(1); // switch current selection - try click/drag white now.
a.currentSelection;

a.selections.size;      // 64 selections
a.selections[0];
a.selections[1];
a.selections;

// setSelection (index, selection);
a.setSelection(0, [234, 2345]);
a.selection(1); // returns [start, size].

(       // mouseUpAction
a.mouseUpAction = {
    ("mouseUp, current selection is now:"
        + a.selections[a.currentSelection]).postln;
};
)
// lock selection 0:
a.currentSelection_(0);
a.setEditableSelectionStart(0, false);
a.setEditableSelectionSize(0, false);


// unlock selection 0:
a.setEditableSelectionStart(0, true);
a.setEditableSelectionSize(0, true);

a.selectionStartTime(0);
a.selectionDuration(0);


a.setSelectionStart(0, 12345);
a.setSelectionSize(0, 12345);
a.readSelection.refresh;
a.readSelection(16).refresh;    // in higher resolution
a.read.refresh;                 // go back to entire file.


a.dataNumSamples;   // visual data have this many points
a.data.plot;
a.setData(a.data.reverse);


a.zoom(0.25);       // scrolling is normalized
a.scrollTo(0.5);    //
a.scrollTo(0.6);    //
a.scroll(12);       // scroll is in viewFrames.

a.zoom(4);

w.close;

::

SUBSECTION:: Adding a scroll bar

Zooming and scrolling by mouse, directly in a SoundFileView, may not be immediately intuitive. (Most users wouldn't guess to shift-right-click!) You can add a link::Classes/RangeSlider:: to act as a scrollbar.

Notes:

list::
## If the user shift-right-clicks, the only way to track the SoundFileView's display changes is by using mouse actions: link::Classes/View#-mouseDownAction:: and link::Classes/View#-mouseUpAction:: to know which button is pressed, and link::Classes/View#-mouseMoveAction:: to read the new scrolling and zooming values.
## link::Classes/SoundFileView#-xZoom:: is in seconds, while the range slider is normalized to a 0-1 range. So code::xZoom == slider.range * duration::, and code::slider.range == xZoom / duration::.
## link::Classes/SoundFileView#-scrollPos:: is normalized to the "total scrolling range," where 1.0 is scrolled fully to the right. We have to subtract the displayed area: code::slider.lo = sfv.scrollPos / (1 - slider.size)::, with some refinements to avoid division by 0.
::

code::

f = SoundFile.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
f.readData(d = Signal.newClear(f.numFrames * f.numChannels));
f.close;

(
var w = Window("test", Rect(700, 200, 600, 300)),
sfv, sfZoom, mouseButton,
dur = d.size / f.sampleRate / f.numChannels;

w.layout = VLayout(
	sfv = SoundFileView(),
	sfZoom = RangeSlider().orientation_(\horizontal)
);

sfZoom.lo_(0).range_(1)
.action_({ |view|
	var divisor, rangeStart;
	rangeStart = view.lo;
	divisor = 1 - sfZoom.range;
	if(divisor < 0.0001) {
		rangeStart = 0;
		divisor = 1;
	};
	sfv.xZoom_(sfZoom.range * dur)
	.scrollTo(rangeStart / divisor)
});

sfv.setData(d, startFrame: 0, channels: f.numChannels, samplerate: f.sampleRate);

sfv.mouseDownAction_({ |view, x, y, mod, buttonNumber|
	mouseButton = buttonNumber;
})
.mouseUpAction_({ |view, x, y, mod|
	mouseButton = nil;
})
.mouseMoveAction_({ |view, x, y, mod|
	var rangeSize, rangeStart;
	if(mouseButton == 1) {
		rangeSize = view.xZoom / dur;
		rangeStart = view.scrollPos * (1 - rangeSize);
		sfZoom.lo_(rangeStart).range_(rangeSize);
	};
});

w.front;
)
::


class:: SoundIn
summary:: Read audio from hardware inputs
categories:: UGens>InOut
related:: Classes/In, Classes/ServerOptions

description::
SoundIn is a convenience UGen to read audio from the input of your computer or soundcard. It is a wrapper link::Classes/UGen:: based on link::Classes/In::, which offsets the index such that 0 will always correspond to the first input regardless of the number of inputs present.

note::
On Intel based Macs, reading the built-in microphone or input may require creating an aggregate device in AudioMIDI Setup.

code::"open -a 'Audio MIDI Setup'".unixCmd; // execute this to launch it::
::

classmethods::
method:: ar

argument:: bus
the channel (or array of channels) to read in. These start at 0, which will correspond to the first audio input.

argument:: mul

argument:: add

examples::
code::
// world's most expensive patchcord (use headphones to avoid feedback)
{ SoundIn.ar(0) }.play;

// stereo version
{ SoundIn.ar([0, 1]) }.play;

// scope input; silent output
{ Amplitude.kr(SoundIn.ar(0)); }.scope;
::


CLASS::SparseArray
categories::Collections>Ordered
summary:: Array that stores duplicated values more efficiently

DESCRIPTION::
A sparse array is a data structure that acts in exactly the same manner as an Array. However, data is represented differently in memory, in a way that makes it much more efficient to store very large arrays in which many values are the same.

Take for example an array consisting of a million zeroes, with a 1 appended to the end; SparseArray would compress this array by storing zero as a default value, and only explicitly storing the single value that differs, therefore offering a much more economical use of memory.

The benefits of using SparseArray typically arise when creating collections containing many millions of slots.

CLASSMETHODS::

method::newClear
Create a new SparseArray of the specified strong::size::, with each slot's value being strong::default::.
code::
g = SparseArray.newClear(20, 3);
g.postcs;
::
argument::size
Number of slots in the desired array. Note that slots are not explicitly created, so the speed of creation is not related to the array size.
argument::default
The default value, i.e. the value that all slots should take at first.

method::reduceArray
Create a new SparseArray holding the same data as strong::array::.
code::
a = [4, 7, 4, 4, 4, 4, 4, 4, 9, 9, 8];
g = SparseArray.reduceArray(a, 4);
g.postcs;
::
argument::array
Any link::Classes/ArrayedCollection::.
argument::default
The default value, i.e. the value that all slots should take at first. For best memory efficiency, you should supply the most common value found in the collection.

INSTANCEMETHODS::

private::prPutSlot

method::put
Put a value at the desired index. This works just like all ArrayedCollection types. Behind the scenes the class will ensure the compact representation (deciding whether to store the value explicitly or implicitly).
code::
g = SparseArray.newClear(10, 3);
g.put(4, \horse);
g.put(6, [4,5,6]);
g[1] = \hello; // Common compact notation
::

method::at
Retrieve the value at index.
code::
g = SparseArray.newClear(20, 3);
g.put(4, \horse);
g.at(4);
g[4];
::

method::asArray
Convert to an ordinary link::Classes/Array::.
code::
g = SparseArray.newClear(20, 3);
g.postcs;
g.asArray;
::

EXAMPLES::

Here we compare speed of Array vs SparseArray.

code::
// Let's create a standard array, big but with only a couple of unusual values hidden in there
(
{
	a = {10}.dup(1000000);
	a[551] = 77;
	a[8722] = \foo;
}.bench
)
// Now a SparseArray made out of exactly the same data
(
{
	b = SparseArray.newClear(a.size, 10);
	b[551] = 77;
	b[8722] = \foo;
}.bench
)

// Alternatively you could make the SparseArray out of the existing array,
// although this is typically not as efficient as starting from scratch
// since the Array needs to be scanned directly.
(
{
	b = SparseArray.reduceArray(a, 10);
}.bench
)

// accessing:
{1000.do{ a[a.size.rand] == 60.rand }}.bench
{1000.do{ b[b.size.rand] == 60.rand }}.bench
// setting:
{1000.do{ a[a.size.rand] = 60.rand }}.bench
{1000.do{ b[b.size.rand] = 60.rand }}.bench
::


TITLE:: Spawner
summary:: A Spawner
categories:: Streams-Patterns-Events>Composition
related:: Classes/Pspawner

DESCRIPTION::
Can start subpatterns. Used as an argument inside link::Classes/Pspawner::. Tracks subpatterns in a link::Classes/PriorityQueue::.


CLASSMETHODS::

METHOD:: new

ARGUMENT:: func

ARGUMENT:: stackSize


INSTANCEMETHODS::

METHOD:: par
Begin an event stream in parallel to the routine.
If delta is non-zero, the pattern will begin that many beats after strong::now::, provided that strong::now + delta:: is later than the next event that the Spawner will generate.

ARGUMENT:: pattern
A link::Classes/Pattern::.

ARGUMENT:: delta
A number of beats.

returns:: The stream from strong::pattern::.

METHOD:: seq
Begin an event stream. Do not return until the event is finished.

ARGUMENT:: pattern
A link::Classes/Pattern::.

METHOD:: wait
Wait a number of seconds, then return.

ARGUMENT:: dur
A number of seconds.

METHOD:: suspend
Stops a stream.

ARGUMENT:: stream
An index of the underlying link::Classes/PriorityQueue::.

returns:: The stopped stream, or nil if the stream is not found.

METHOD:: suspendAll
Stop all substreams.

Examples::
See link::Classes/Pspawner::

class:: Spec
summary:: input datatype specification
related:: Classes/ControlSpec, Classes/Warp
categories:: Control, Spec

description::
Specs specify what kind of input is required or permissible, and what the range of those parameters are. This is an abstract class - the most common subclass is: link::Classes/ControlSpec::.

ControlSpec is used by GUI sliders and knobs to specify the range and curve of the controls. Input datatypes are of interest to functions, to gui interface objects (sliders etc.) and can also be used for introspection.

The class Spec itself holds a global link::Classes/IdentityDictionary:: of common specifications. The name that the spec was stored as can then be used as a shorthand to refer to specs:
code::
\freq.asSpec
::

Some common mappings are initialized in code::ControlSpec.initClass::. You may add or overwrite mappings as you wish. The crucial library (available as a quark, see link::Classes/Quarks::) defines a number of additional subclasses. See the file quarks/cruciallib/Instr/MoreSpecs.sc

ClassMethods::

private::initClass

method::add
Add a spec to the global spec dictionary. The item will be converted to a spec using .asSpec.

Examples::

code::
Spec.add(\helpExp, ControlSpec( 0.01, 1.0, \exp) );

// the array will be converted to a control spec
Spec.add(\helpLin, [0, 1, \lin, 0.011, 0.01]);

// a symbol will be looked up converteuse the existing \freq spec for \helpLin2
Spec.add(\helpLin2, \freq);

// existing spec:
Spec.add(\helpLin, ControlSpec(0.ampdb, 1.ampdb, \db, units: " dB"));


// List of default specs:

\unipolar -> ControlSpec(0, 1),
\bipolar -> ControlSpec(-1, 1, default: 0),

\freq -> ControlSpec(20, 20000, \exp, 0, 440, units: " Hz"),
\lofreq -> ControlSpec(0.1, 100, \exp, 0, 6, units: " Hz"),
\midfreq -> ControlSpec(25, 4200, \exp, 0, 440, units: " Hz"),
\widefreq -> ControlSpec(0.1, 20000, \exp, 0, 440, units: " Hz"),
\phase -> ControlSpec(0, 2pi),
\rq -> ControlSpec(0.001, 2, \exp, 0, 0.707),

\audiobus -> ControlSpec(0, Server.default.options.numAudioBusChannels-1, step: 1),
\controlbus -> ControlSpec(0, Server.default.options.numControlBusChannels-1, step: 1),

\midi -> ControlSpec(0, 127, default: 64),
\midinote -> ControlSpec(0, 127, default: 60),
\midivelocity -> ControlSpec(1, 127, default: 64),

\db -> ControlSpec(0.ampdb, 1.ampdb, \db, units: " dB"),
\amp -> ControlSpec(0, 1, \amp, 0, 0),
\boostcut -> ControlSpec(-20, 20, units: " dB",default: 0),

\pan -> ControlSpec(-1, 1, default: 0),
\detune -> ControlSpec(-20, 20, default: 0, units: " Hz"),
\rate -> ControlSpec(0.125, 8, \exp, 0, 1),
\beats -> ControlSpec(0, 20, units: " Hz"),

\delay -> ControlSpec(0.0001, 1, \exp, 0, 0.3, units: " secs")
::


class:: SpecCentroid
summary:: Spectral centroid
categories:: UGens>FFT
related:: Classes/SpecFlatness, Classes/SpecPcile

description::
Given an link::Classes/FFT:: strong::chain::, this measures the emphasis::spectral:: centroid, which is the weighted mean frequency, or the "centre of mass" of the spectrum. (DC is ignored.)

This can be a useful indicator of the perceptual emphasis::brightness:: of a signal.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.

examples::

A link::Classes/Blip:: oscillator is ideal for demonstrating this because the number of harmonics is directly manipulated: as the number of harmonics increases, the centroid is pushed higher. In the example, left-to-right changes the number of harmonics, but up-to-down changes the fundamental pitch; note the different effects of these two on the centroid.

code::
s.boot;
b = Buffer.alloc(s, 2048, 1);
(
x = {
	var in, chain, freq, rq, centroid;

	//freq = LFPar.kr(0.3).exprange(100, 1000);
	freq = MouseY.kr(1000, 100, 1);
	in = Blip.ar(freq, MouseX.kr(1, 100, 1));
	chain = FFT(LocalBuf(2048), in);
	centroid = SpecCentroid.kr(chain);
	centroid.poll(10);
	in.dup * 0.1

}.play
)

x.free;
::


class:: SpecFlatness
summary:: Spectral Flatness measure
categories:: UGens>FFT
related:: Classes/SpecCentroid, Classes/SpecPcile

description::
Given an link::Classes/FFT:: strong::chain:: this calculates the emphasis::Spectral Flatness:: measure, defined as a power spectrum's geometric mean divided by its arithmetic mean. This gives a measure which ranges from approx 0 for a pure sinusoid, to approx 1 for white noise.

The measure is calculated linearly. For some applications you may wish to convert the value to a decibel scale - an example of such conversion is shown below.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.

examples::

code::
s.boot;

(
{ // Example - vary mixture of white noise and pure tone with the mouse
	var in, chain, flat, flatdb, flatdbsquish;

	in = XFade2.ar(WhiteNoise.ar, SinOsc.ar, MouseX.kr(-1,1));
	chain = FFT(LocalBuf(2048), in);
	Out.ar(0, in * 0.1);

	flat = SpecFlatness.kr(chain);

	flatdb = 10 * flat.log; // Convert to decibels
	flatdbsquish = LinLin.kr(flatdb, -45, -1.6, 0, 1).max(-10); // Rescale db roughly to 0...1.

	flat.poll(10, "flatness: ");
	flatdb.poll(10, "flatness (db): ");

	[flat, flatdbsquish]
}.scope;
)

(
{ // Now try with your own voice
	var in, chain;
	in = SoundIn.ar([0,1]).mean;
	chain = FFT(LocalBuf(2048), in);
	Out.kr(0, [in, SpecFlatness.kr(chain).poll(1, "flatness: ")]);
}.scope;
)
::


class:: SpecPcile
summary:: Find a percentile of FFT magnitude spectrum
categories:: UGens>FFT
related:: Classes/SpecCentroid, Classes/SpecFlatness

description::
Given an link::Classes/FFT:: chain this calculates the cumulative distribution of the frequency spectrum, and outputs the frequency value which corresponds to the desired percentile.

For example, to find the frequency at which 90% of the spectral energy lies below that frequency, you want the 90-percentile, which means the value of emphasis::fraction:: should be 0.9. The 90-percentile or 95-percentile is often used as a measure of strong::spectral roll-off::.

The optional third argument strong::interpolate:: (code::ir::) specifies whether interpolation should be used to try and make the percentile frequency estimate more accurate, at the cost of a little higher CPU usage. Set it to 1 to enable this.

Optional fourth argument is strong::binout:: (code::ir::) specifies whether to output the bin number instead of the frequency (default 0, set to 1 to enable). If interpolate is enabled, linear interpolation on the bin number is performed.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.
argument:: fraction
argument:: interpolate
argument:: binout

examples::

code::

// Simple demo with filtering white noise, and trying to infer the cutoff freq.
// Move the mouse.
(
{
	var in, chain, realcutoff, estcutoff;
	realcutoff = MouseX.kr(0.00001,22050);
	in = LPF.ar(WhiteNoise.ar, realcutoff);
	chain = FFT(LocalBuf(2048), in);
	estcutoff = Lag.kr(SpecPcile.kr(chain, 0.9), 1);
	realcutoff.poll(Impulse.kr(1), "real cutoff");
	estcutoff.poll(Impulse.kr(1), "estimated cutoff");
	Out.kr(0, estcutoff * 22050.0.reciprocal);
	Out.ar(0, in);
}.scope;
)

// Audio input - try different vowel/long-consonant sounds and see what comes out.
// Specifically, change from "ssss" through to "aaaa" through to "wwww".
(
{
	var in, chain, perc;
	in = SoundIn.ar([0,1]).mean;
	chain = FFT(LocalBuf(2048), in);
	//Out.ar(0, in * 0.1);
	perc = SpecPcile.kr(chain, 0.5);
	Out.kr(0, perc * 22050.0.reciprocal);
	Out.ar(1, LPF.ar(WhiteNoise.ar, perc)); // outputting to right channel
}.scope;
)
::


class:: Splay
summary:: Splay spreads an array of channels across the stereo field
categories:: UGens>Multichannel>Panners
related:: Classes/SplayAz, Classes/SplayZ

description::
Splay spreads an array of channels across the stereo field.
Optional arguments are spread and center, and equal power levelCompensation.
The formula for the stereo position is ((0 .. (n - 1)) * (2 / (n - 1)) - 1) * spread + center

classmethods::
method:: ar, kr
argument:: inArray
The array of channels to be distributed over the two stereo pairs
argument:: spread
For spread = 0, all channels end up in the centre, for 1, they have maximum distribution
argument:: level
An amplitude multiplier for all channels
argument:: center
Shift the centre of the distribution.
argument:: levelComp


method:: arFill
In analogy to Mix:arFill, this method takes a function that produces the channels. The counting index is passed to it.
argument:: n
Number of channels
argument:: function
Function to return each channel
argument:: spread
For spread = 0, all channels end up in the centre, for 1, they have maximum distribution
argument:: level
An amplitude multiplier for all channels
argument:: center
Shift the centre of the distribution.
argument:: levelComp

examples::

code::
(
x = { arg spread=1, level=0.2, center=0.0;
 Splay.ar(
  SinOsc.ar( { |i| LFNoise2.kr(1).exprange(200, 4000) } ! 10),
  spread,
  level,
  center
 );
}.play;
)

x.set(\spread, 1,   \center, 0);  // full stereo
x.set(\spread, 0.5, \center, 0);  // less wide
x.set(\spread, 0,   \center, 0);  // mono center
x.set(\spread, 0.5, \center, 0.5);
// spread from center to right
x.set(\spread, 0,   \center, -1); // all left
x.set(\spread, 1,   \center, 0);  // full stereo


 // the a similar example written with arFill:
(
x = { arg spread=1, level=0.2, center=0.0;
 Splay.arFill(10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100))  },
  spread,
  level,
  center
 );
}.play;
)


 // with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10);
 Splay.ar(src, MouseY.kr(1, 0), 0.2, MouseX.kr(-1, 1));
}.play;
)
::


class:: SplayAz
summary:: Spreads an array of channels across a ring of channels
categories:: UGens>Multichannel>Panners
related:: Classes/Splay, Classes/PanAz, Classes/SelectXFocus

description::
SplayAz spreads an array of channels across a ring of channels.
Optional spread and center controls, and equal power levelCompensation.
numChans and orientation are as in link::Classes/PanAz::.

code::
{ SplayAz.ar(5, [SinOsc.ar, Saw.ar], 0, 1) }.plot;
::

classmethods::

method:: ar, kr

Each of the inputs is evenly spaced over a cyclic period of
2.0 in pos with 0.0 equal to channel zero and 2.0/numChans equal
to channel 1, 4.0/numChans equal to channel 2, etc.

The distance between the input signals in the output range is determined by the spread argument.

argument:: numChans
Number of output channels of the UGen
argument:: inArray
Input signals (can be a single UGen or an array)
argument:: spread
How far the input signals  are apart in the output. If zero, everything is mixed on center position (see below).
code::
{ SplayAz.ar(6, [SinOsc.ar, Saw.ar(800)], spread: MouseX.kr(0, 1).poll) * 0.3 }.scope;
::

argument:: level
Scaling for all signals
argument:: width
Over how much of the channels each signal is distributed.
argument:: center
Which of the channels will be the first channel
argument:: orientation
Should be zero if the front is a vertex of the polygon. The first
speaker will be directly in front. Should be 0.5 if the front
bisects a side of the polygon. Then the first speaker will be the
one left of center.
argument:: levelComp
If true, the signal level is adjusted to maintain overall loudness the same (n.reciprocal.sqrt).

method:: arFill
argument:: numChans
Number of output channels
argument:: n
Number of input channels
argument:: function
A function that returns a UGen (the channel index is passed as an argument)
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

examples::
code::
(
x = { arg spread=1, level=0.2, width=2, center=0.0;
 SplayAz.ar(
  4,
  SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10),
  spread,
  level,
  width,
  center
 );
}.scope;
)

x.set(\spread, 1,   \center, 0);  // full n chans
x.set(\spread, 0.5, \center, -0.25); // less wide
x.set(\spread, 0, \center, 0);  // mono center (depends on orientation, see PanAz)
x.set(\spread, 0, \center, -0.25); //
x.set(\spread, 0.0, \center, 0.5); // mono, but rotate 1 toward the higher channels
x.set(\spread, 0.5, \center, 0.5); // spread over the higher channels
x.set(\spread, 0,   \center, -0.25); // all on first channel
x.set(\spread, 1,   \center, 0);  // full n chans

x.free;

 // the same example written with arFill:
(
x = { arg spread=1, level=0.5, width=2, center=0.0;
 SplayAz.arFill(
  4,
  10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) ) },
  spread,
  level,
  width,
  center
 );
}.scope;
)

 // or with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i * 100 + 400) } ! 10);
 SplayAz.ar(4, src, MouseY.kr(1, 0), 0.2, center: MouseX.kr(-1, 1));
}.scope;
)

// test for correct behavior:
	// only on chan 0
{ SplayAz.ar(4, SinOsc.ar * 0.2, orientation: 0) }.scope;

	//  on chan 0, 3, i.e. equally around the ring
{ SplayAz.ar(6, SinOsc.ar([2, 3] * 200) * 0.2, orientation: 0) }.scope;

	// equal spread on 0, 2, 4
{ SplayAz.ar(6, SinOsc.ar([2, 3, 5] * 200) * 0.2, orientation: 0) }.scope;


	// wrong behavior of SplayZ:
		// plays on chan 2, but should play on 0
{ SplayZ.ar(4, SinOsc.ar * 0.2, orientation: 0) }.scope;

	//  wrong: mixes both to chan 2,
	// because pan values [-1, 1] are the same pos on the ring
{ SplayZ.ar(6, SinOsc.ar([2, 3] * 200) * 0.2, orientation: 0) }.scope;

	// wrong equal spread to pan values [-1, 0, 1], which outputs to chans 2, 0, 2
{ SplayZ.ar(6, SinOsc.ar([2, 3, 5] * 200) * 0.2, orientation: 0) }.scope;
::


class:: SplayZ
summary:: Spreads an array of channels across a ring of channels
categories:: UGens>Multichannel>Panners
related:: Classes/PanAz, Classes/SplayAz

description::
SplayZ spreads an array of channels across a ring of channels.
Optional spread and center controls, and levelComp(ensation) (equal power).
numChans and orientation are as in PanAz.

warning::
ATTENTION - SplayZ is deprecated because its geometry is wrong. It is only kept for backwards compatibility - please adapt your patches to link::Classes/SplayAz::! See link::Classes/SplayAz:: help file for the comparison in behavior.
::

classmethods::

method:: ar
argument:: numChans
argument:: inArray
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

method:: arFill
argument:: numChans
argument:: n
argument:: function
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

examples::
code::
(
x = { arg spread=1, level=0.2, width=2, center=0.0;
 SplayZ.ar(
  4,
  SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10),
  spread,
  level,
  width,
  center
 );
}.scope;
)

x.set(\spread, 1,   \center, 0);  // full n chans
x.set(\spread, 0.5, \center, -0.25); // less wide
x.set(\spread, 0, \center, 0);  // mono center (depends on orientation, see PanAz)
x.set(\spread, 0, \center, -0.25); //
x.set(\spread, 0.0, \center, 0.5); // mono, but rotate 1 toward the higher channels
x.set(\spread, 0.5, \center, 0.5); // spread over the higher channels
x.set(\spread, 0,   \center, -0.25); // all first
x.set(\spread, 1,   \center, 0);  // full n chans

x.free;

 // the same example written with arFill:
(
x = { arg spread=1, level=0.5, width=2, center=0.0;
 SplayZ.arFill(
  4,
  10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) ) },
  spread,
  level,
  width,
  center
 );
}.scope;
)

 // or with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i * 100 + 400) } ! 10);
 SplayZ.ar(4, src, MouseY.kr(1, 0), 0.2, center: MouseX.kr(-1, 1));
}.scope;
)
::


class:: Spring
summary:: physical model of resonating spring
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/Ball, Classes/TBall

description::
models the force of a resonating spring

classmethods::

method:: ar, kr

argument::in
modulated input force

argument::spring
spring constant (incl. mass)

argument::damp
damping


examples::
code::
// trigger gate is mouse button
// spring constant is mouse x
// mouse y controls damping
(
{
	var inforce, outforce, freq, k, d;
	inforce = K2A.ar(MouseButton.kr(0,1,0)) > 0;
	k = MouseY.kr(0.1, 20, 1);
	d = MouseX.kr(0.00001, 0.1, 1);
	outforce = Spring.ar(inforce, k, d);
	freq = outforce * 400 + 500; // modulate frequency with the force
	SinOsc.ar(freq, 0, 0.2)
}.play;
)


// several springs in series.
// trigger gate is mouse button
// spring constant is mouse x
// mouse y controls damping
(
{ 	var m0, m1, m2, m3, d, k, inforce;
	d = MouseY.kr(0.00001, 0.01, 1);
	k = MouseX.kr(0.1, 20, 1);
	inforce = K2A.ar(MouseButton.kr(0,1,0)) > 0;
	m0 = Spring.ar(inforce, k, 0.01);
	m1 = Spring.ar(m0, 0.5 * k, d);
	m2 = Spring.ar(m0, 0.6 * k + 0.2, d);
	m3 = Spring.ar(m1 - m2, 0.4, d);
	SinOsc.ar(m3 * 200 + 500, 0, 0.2) // modulate frequency with the force

}.play;
)

// modulating a resonating string with the force
// spring constant is mouse x
// mouse y controls damping
(
{ 	var m0, m1, m2, m3, m4, d, k, t;
	k = MouseX.kr(0.5, 100, 1);
	d = MouseY.kr(0.0001, 0.01, 1);
	t = Dust.ar(2);
	m0 = Spring.ar(ToggleFF.ar(t), 1 * k, 0.01);
	m1 = Spring.ar(m0, 0.5 * k, d);
	m2 = Spring.ar(m0, 0.6 * k, d);
	m3 = Spring.ar([m1,m2], 0.4 * k, d);
	m4 = Spring.ar(m3 - m1 + m2, 0.1 * k, d);
	CombL.ar(t, 0.1, LinLin.ar(m4, -10, 10, 1/8000, 1/100), 12)

}.play;
)
::


CLASS:: StackLayout
summary:: A layout that stacks views on top of each other
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Guides/GUI-Layout-Management

DESCRIPTION::

StackLayout manages several views stacked into the same space. It has two modes: it can either switch the view that is visible, hiding the others, or it can keep all of them visible, switching the one that is on top.

The second mode is useful for example for overlaying a view with a link::Classes/UserView::, on which you can then draw additional information. If you still want to be able to interact with the view below using the mouse, you can make the one above ignore the mouse using link::Classes/View#-acceptsMouse::. See the link::#examples#example:: below.

Views can be added to the layout immediately at link::#*new#construction::, or you can link::#-add#add:: or link::#-insert#insert:: them after. To remove a view, you simply call link::Classes/View#-remove::.

You can change the current view (the one visible / on top) using link::#-index::, while link::#-count:: tells you how many views are managed by the layout.

To switch between the two modes use link::#-mode::.

note::
Unlike other layouts, StackLayout can not contain another layout, but only subclasses of View.
::


CLASSMETHODS::

PRIVATE:: key
PRIVATE:: qtClass

METHOD:: new

    Creates a StackLayout and fills it with the items given as arguments. The first view becomes the current one, i.e. visible and on top of others.

    argument:: ... views
    A sequence of strong::views::. Unlike other layouts, StackLayout can not contain another layout.

    discussion::

    In the example below, the button will switch between the three text editing areas:
code::
(
var stack;
w = Window().layout_( VLayout(
    Button().states_([["One"],["Two"],["Three"]]).action_({ |b| stack.index = b.value }),
    stack = StackLayout(
        TextView().string_("This is a chunk of text..."),
        TextView().string_("...and this is another..."),
        TextView().string_("...and another.")
    );
)).front;
)
::

INSTANCEMETHODS::

METHOD:: add
    Adds a view at the last index. This does not affect the current link::#-index::.

    argument:: view
    A View.

METHOD:: insert
    Inserts a view at the specific index. This does not affect the current link::#-index::.

    argument:: view
    A View.

    argument:: index
    An integer. If it is less than 0 or more than link::#-count::, the view will always be inserted as last.

METHOD:: count
    The number of views managed by the layout.

METHOD:: index
    Sets or gets the index of the current view. The current view is placed on top of others, and if link::#-mode:: is 0, all the others are hidden.

METHOD:: mode
    Sets or gets the current mode: in mode 0, the layout only displays the current view; in mode 1, the layout displays all the views. In both modes, the current view will be placed on top of others.

    See also: link::#-index::.

    argument:: value
        0 or 1. Instead of an integer you can also use symbols \stackOne or \stackAll.
    returns::
        0 or 1.

EXAMPLES::

Overlaying a TextView with a UserView to do additional drawing on top, while still allowing the interaction with the text:

code::
(
var text, canvas;
text = TextView().string_("Hello world!").keyDownAction_({canvas.refresh});
canvas = UserView().acceptsMouse_(false).drawFunc_({
    var b = canvas.bounds();
    var str = text.string;
    Pen.translate( b.center.x, b.center.y );
    Pen.fillColor = text.palette.baseText.alpha_(0.1);
    str.do { |c|
        var x = 40.0.rand + 10.0;
        var r = c.asString.bounds.center_(0@0);
        Pen.push;
        Pen.rotate( 1.0.rand );
        Pen.translate( rand2(-0.3,0.3) * b.width, rand2(-0.3,0.3) * b.width );
        Pen.scale( x, x );
        Pen.stringCenteredIn(c.asString, r);
        Pen.pop;
    }
}).refresh;
w=Window().layout_( StackLayout( canvas, text ).mode_(\stackAll) ).front;
)
::


class:: StandardL
summary:: Standard map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/StandardN

description::
A linear-interpolating sound generator based on the difference equations:

teletype::
	x(n+1) = (x(n) + y(n+1)) % 2pi
	y(n+1) = (y(n) + k * sin(x(n))) % 2pi
::

The standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.

sclang code translation:

code::
(
var k = 1, xi = 0.5, yi = 0, size = 64;
plot(size.collect { yi = yi + (k * sin(xi)) % 2pi; xi = (xi + yi) % 2pi; xi - pi * 0.3183098861837907 });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: k
Perturbation amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// vary frequency
{ StandardL.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
::

code::
// mouse-controlled param
{ StandardL.ar(SampleRate.ir/2, MouseX.kr(0.9,4)) * 0.3 }.play(s);
::

code::
// as a frequency control
{ SinOsc.ar(StandardL.ar(40, MouseX.kr(0.9,4))*800+900)*0.4 }.play(s);
::


class:: StandardN
summary:: Standard map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/StandardL

description::
A non-interpolating sound generator based on the difference equations:

teletype::
        x(n+1) = (x(n) + y(n+1)) % 2pi
        y(n+1) = (y(n) + k * sin(x(n))) % 2pi
::

The standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.

sclang code translation:

code::
(
var k = 1, xi = 0.5, yi = 0, size = 64;
plot(size.collect { yi = yi + (k * sin(xi)) % 2pi; xi = (xi + yi) % 2pi; xi - pi * 0.3183098861837907 });
)
::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: k
Perturbation amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// vary frequency
{ StandardN.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
::

code::
// mouse-controlled param
{ StandardN.ar(SampleRate.ir/2, MouseX.kr(0.9,4)) * 0.3 }.play(s);
::

code::
// as a frequency control
{ SinOsc.ar(StandardN.ar(40, MouseX.kr(0.9,4))*800+900)*0.4 }.play(s);
::


class:: StartUp
summary:: register functions to be evaluated after the startup is finished
related:: Classes/ShutDown, Classes/ServerBoot, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
StartUp registers functions to perform an action after the library has been compiled, and after the startup file has run. For instance this is used for creating link::Classes/SynthDef:: in the strong::initClass:: function of class files in order to be able to make the synthdef directory customizable by the startup script.

If an object is registered, strong::doOnStartUp:: must be implemented. Otherwise a function can be used.

ClassMethods::

method::add
Registers an object or function to be evaluated after startup is finished.

method::defer
Registers an object or function to be evaluated after startup is finished, or immediately, if this has happened already.

method::remove
Removes an object that was previously registered.

method::run
Call the object in order.

Examples::

code::
*initClass {
	StartUp.add {
		// something to do...
	}
}
::


CLASS:: StaticText
summary:: A view displaying non-editable text
categories:: GUI>Views

DESCRIPTION::
A view displaying non-editable text


CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: string
	The text displayed by the view.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.

SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed text. See link::Reference/gui_alignments:: for possible values.

METHOD:: font
	The font used to display the text.

	argument::
		A Font.

METHOD:: stringColor
	The color used to display the text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the whole area occupied by the view under the text with the given color.

	argument::
		A Color.


EXAMPLES::

subsection:: Basic Example

code::
(
w = Window.new.front;
a = StaticText(w, Rect(10, 10, 200, 20));
a.string = "Rolof's Rolex";
)

// adjust look , alignment and content
a.background=Color.grey;
a.align = \center;
a.font = Font("Monaco", 11);
a.string = "Your Rolex";
::


subsection:: Monitoring Values in a Synth

code::
(
var w, a, r, b, q;
w = Window("Frequency Monitor", Rect(200, Window.screenBounds.height - 200, 300, 150)).front;

a = StaticText(w, Rect(45, 10, 200, 20)).background_(Color.rand);
a.string = " Current Frequency ";

Button.new(w, Rect(45, 70, 200, 20)).states_([[ "close", Color.black, Color.rand ]]).action_({ w.close });

s.waitForBoot({

    b = Bus.new(\control, 0, 1);

    q = SynthDef(\Docs_FreqMonitor, {
		var freq, snd;
        freq = LFNoise0.ar(2, 400, 650);
        snd = SinOsc.ar(freq, 0, 0.2);
        Out.ar(0, snd);
        Out.kr(b.index, freq); // output the frequency to a control bus
    }).play;

    r = Routine {
		{
			// Set the value of the StaticText to the value in the control bus.
			// Setting GUI values is asynchronous, so you must use .defer in the system clock.
			// Also you must check if the window is still open, since Routine will continue for at least
			// one step after you close the window.
			b.get({ |v|
				{
					if(w.isClosed.not) {
						a.string = " Current Frequency: " ++ v.round(0.01)
					}
				}.defer
			});

			0.01.wait;
		}.loop

    }.play
});

CmdPeriod.doOnce({ w.close });
w.onClose = { r.stop; q.free; b.free }; // clean up if the window closes
)
::


subsection:: Dynamic Text

code::
(
w = Window.new.front;
w.view.background=Color.white;
a = Array.fill(20, { StaticText(w, Rect(w.bounds.extent.x.rand, w.bounds.extent.y.rand, 160, 16))
	.string_("Rolof's Rolex".scramble)
	.align_(\center)
	.stringColor_(Color.rand)
	.font_(Font([
		"Helvetica-Bold",
		"Helvetica",
		"Monaco",
		"Arial",
		"Gadget",
		"MarkerFelt-Thin"
	].choose, 11))
});

r = {
	inf.do { |i|
		thisThread.randSeed_(1284);
		a.do { |item|
			// setting GUI values is asynchronous, so you must use .defer
			{
				item.bounds = Rect(
					5 + w.bounds.extent.x.rand * abs(cos(i * 0.01)),
					w.bounds.extent.y.rand * sin(i * 0.01),
					160,
					20
				)
			}.defer;
		};
		0.15.wait;
	}
}.fork;
CmdPeriod.doOnce({ w.close });
w.onClose_({ r.stop });
)
::


class:: Stepper
summary:: Pulse counter.
related:: Classes/PulseCount
categories::  UGens>Triggers


Description::

Each trigger increments a counter which is output as a signal. The
counter wraps between  code::min::  and
code::max:: .


classmethods::

method::ar, kr

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::reset

Resets the counter to
code::resetval::  when
triggered.


argument::min

Minimum value of the counter.


argument::max

Maximum value of the counter.


argument::step

Step value each trigger. May be negative.


argument::resetval

Value to which the counter is reset when it receives a reset
trigger. If nil, then this is patched to

code::min:: .


Examples::

code::

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, 1) * 100,
			0, 0.05
		)
	)
}).play;

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, -3) * 100,
			0, 0.05
		)
	)
}).play;

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, 4) * 100,
			0, 0.05
		)
	)
}).play;


///////////////////////////////////////////////////////////////////////////////////
//
// Using Stepper and BufRd for sequencing
//

s.boot;

s.sendMsg(\b_alloc, 10, 128);

m = #[0,3,5,7,10];

a = ({rrand(0,15)}.dup(16).degreeToKey(m) + 36).midicps;
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);

(
SynthDef(\stepper, { |out|
	var rate, clock, index, freq, ffreq, env, out, rev, lfo;

	rate = MouseX.kr(1,5,1);
	clock = Impulse.kr(rate);
	env = Decay2.kr(clock, 0.002, 2.5);
	index = Stepper.kr(clock, 0, 0, 15, 1, 0);
	freq = BufRd.kr(1, 10, index, 1, 1);
	freq = Lag2.kr(freq) + [0,0.3];
	ffreq = MouseY.kr(80,1600,1) * (env * 4 + 2);
	out = Mix.ar(LFPulse.ar(freq * [1, 3/2, 2], 0, 0.3));
	out = RLPF.ar(out, ffreq, 0.3, env);
	out = RLPF.ar(out, ffreq, 0.3, env);
	out = out * 0.02;

	// echo
	out = CombL.ar(out, 1, 0.66/rate, 2, 0.8, out);

	// reverb
	rev = out;
	5.do { rev = AllpassN.ar(rev, 0.05, { 0.05.rand }.dup, rrand(1.5,2.0)) };
	out = out + (0.3 * rev);

	out = LeakDC.ar(out);

	// flanger
	lfo = SinOsc.kr(0.2, [0,0.5pi], 0.0024, 0.0025);
	1.do { out = DelayL.ar(out, 0.1, lfo, 1, out) };

	// slight bass emphasis
	out = OnePole.ar(out, 0.9);

	Out.ar(out, out);

}).add;
)

s.sendMsg(\s_new, \stepper, 1000, 0, 0);

a = ({rrand(0,15)}.dup(16).degreeToKey(m) + 38).midicps;
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);

a = a * 2.midiratio; // transpose up 2 semitones
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);


(
a = [ 97.999, 195.998, 523.251, 466.164, 195.998, 233.082, 87.307, 391.995, 87.307, 261.626, 195.998, 77.782, 233.082, 195.998, 97.999, 155.563 ];
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);
)

s.sendMsg(\n_free, 1000);

::



class:: StereoConvolution2L
summary:: Stereo real-time convolver with linear interpolation
categories:: UGens>FFT, UGens>Convolution
related:: Classes/Convolution, Classes/Convolution2L

description::
Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.

Like link::Classes/Convolution2L::, but convolves with two buffers and outputs a stereo signal. This saves one FFT transformation per period, as compared to using two copies of link::Classes/Convolution2L::.

Useful applications could include stereo reverberation or HRTF convolution.

See Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing, chapter 18: link::http://www.dspguide.com/ch18.htm::

classmethods::
method:: ar

argument:: in
processing target.
argument:: kernelL
buffer index for the fixed kernel of the left channel, may be modulated in combination with the trigger.
argument:: kernelR
buffer index for the fixed kernel of the right channel, may be modulated in combination with the trigger.
argument:: trigger
update the kernel on a change from <= 0 to > 0.
argument:: framesize
size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).
Convolution uses twice this number internally.
Note that the convolution gets progressively more expensive to run for higher powers!
The maximum value you can use is 2^16=16384.
(This upper limit is half of "SC_FFT_MAXSIZE" defined in the SC source code.)
Larger convolutions than this can be done using link::Classes/PartConv::.
argument:: crossfade
The number of periods over which a crossfade is made. The default is 1. This must be an integer.
argument:: mul
argument:: add

examples::
code::
(
//allocate three buffers
b = Buffer.alloc(s, 2048);
c = Buffer.alloc(s, 2048);
d = Buffer.alloc(s, 2048);

b.zero;
c.zero;
d.zero;
)

(
50.do({ |it| c.set(20 * it + 10, 1.0.rand); });
3.do({ |it| b.set(400 * it + 100, 1); });
20.do({ |it| d.set(40 * it + 20, 1); });
)


(
SynthDef(\conv_test, { |out, kernel1, kernel2, t_trig = 0|
	var input, result, framesize;
	framesize = 2048; // must be a power of two
	input = Impulse.ar(1);
	result = StereoConvolution2L.ar(input, kernel1, kernel2, t_trig, framesize, 1, 0.5);
	Out.ar(out, result);
}).add
)


x = Synth(\conv_test, [\kernel1, b, \kernel2, c]);

// changing the buffer number:
x.set(\kernel1, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.
x.set(\kernel2, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20 * it + 10, 1); }); // changing the buffers' contents
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel1, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
::


CLASS:: Stethoscope
summary:: An oscilloscope
categories:: GUI>Interfaces
related:: Classes/ScopeView, Classes/FreqScope

DESCRIPTION::

Stethoscope provides a complete oscilloscope GUI. It displays a window containing a bus-plotting link::Classes/ScopeView:: and an interface to configure the plotting and choose among the buses.

SUBSECTION:: Creation by message .scope

Several classes provide a convenient 'scope' method that creates a Stethoscope to display their data. See for example: link::Classes/Server#-scope::, link::Classes/Bus#-scope::, link::Classes/Function#-scope::.

SUBSECTION:: Keyboard shortcuts

The following keyboard shortcuts may be used when focused on the Stethoscope display:

table::
## strong::Shortcut:: || strong::Action::
## J || one channel back
## K || switch rate (audio vs. control)
## L || one channel forward
## O || jump to first hardware output channel and adjust numChannels to hardware
## I || jump to first hardware input channel and adjust numChannels to hardware
## space || run, if not running already
## . (period) || stop
## M || toggle screen size
## + / - || zoom horizontally
## * / _ || zoom vertically
## S || change style between parallel and overlay
## Shift+S || change style to lissajou
## Shift+A || allocate buffer size so it fills the screen (to next power of two) (this can be dangerous, might crash)
::

CLASSMETHODS::

PRIVATE:: key

METHOD:: new

    Create a Stethoscope, either as a window, or placed on a given parent view.

    argument:: server
        A valid Server (either a local or the internal server), or code::nil::, in which case the code::Server.default:: is used.
    argument:: numChannels
        An integer. Default value is 2.
    argument:: index
        The offset index. An Integer. Default is nil.
    argument:: bufsize
        The size of the analysis buffer. Default is 4096. See also link::#-bufsize::.
    argument:: zoom
        Horizontal magnification of the displayed wave. Default is 1. See also link::#-xZoom::.
    argument:: rate
        \audio or \control. Default is \audio.
    argument:: view
        The optional parent view. Default is nil. If nil, then it will open in its own Window.
    argument:: bufnum
        The id number of the Buffer to analyze. Default value is nil. If nil, then a Buffer of size bufSize is allocated.

    discussion:
    Example:
code::
s.boot
{SinOsc.ar([330,440], 0, 0.4)}.play;
Stethoscope(s,2);
::


METHOD:: isValidServer

    Tests whether Stethoscope can operate on the given server (any local server. See link::Classes/Server#-isLocal::).

    argument::
        A link::Classes/Server::.
    returns::
        A Boolean.

METHOD:: ugenScopes

    Returns an array of the running ugen scopes.

code::
s.boot
{[SinOsc.ar.scope,WhiteNoise.ar(0.5).scope]*0.1}.scope(2);
Stethoscope.ugenScopes; // returns the ugen scopes
::

METHOD:: tileBounds

    A utility method used by link::Classes/UGen#-scope:: to tile scope windows.

    returns::
        A Rect.



INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: server
    The server on which the scope operates.

METHOD:: rate
    Whether to operate on audio or control busses.
    argument::
        One of the two symbols: code::\audio:: or code::\control::.

METHOD:: index
    The starting index of the busses to scope.
    argument::
        An Integer.

METHOD:: numChannels
    The amount of adjacent busses to scope (from link::#-index:: on).
    argument::
        An Integer.

METHOD:: bufsize
   Defines the maximum allowed link::#-cycle::.

METHOD:: cycle
    note:: Only available in Qt GUI ::

    The exact scoping period, in signal frames. Reciprocal to what is also known as emphasis::sweep speed:: in analog oscilloscopes. It is dynamically adjustable while the scope is running.

    Data from scoped signals will be accumulated into a buffer until it reaches code::cycle:: amount frames, at which point the buffering will immediately restart. The view will repeatedly display the entire buffer; it may skip a cycle if the drawing is too slow to keep up with the speed of incoming data, but the cycle boundaries will never shift with respect to signals.

    If you are scoping a periodic signal, setting code::cycle:: to match the signal's period will keep the waveform locked in place.

SUBSECTION:: Display

METHOD:: window
    The (parent) Window of the scope.

METHOD:: size
    Sets the width and the height of the scope window.
    argument::
        An Integer (the window is square).

METHOD:: toggleSize

    Toggle between small and large size.

METHOD:: zoom
    A synonym for link::#-xZoom::.

METHOD:: xZoom
    Magnifies the displayed wave horizontally to the given factor.

    This sets link::#-cycle:: to code::1024 * xZoom.reciprocal::.

    argument::
        A Float.

METHOD:: yZoom
    Magnifies the displayed wave vertically to the given factor.

    argument::
        A Float.

METHOD:: style
    The plotting style:
    list::
    ## 0 = the channels are vertically spaced
    ## 1 = the channels are overlaid
    ## 2 = lissajou; the first two channels are used for 2D plotting (as streams of x and y coordinates).
    ::

    argument::
        One of the above Integers.


SUBSECTION:: Operation

METHOD:: run

    Starts the scope, if not already running.

METHOD:: quit

    Closes the window, and cleans up any used synths and buffers.

SUBSECTION:: Convenience

METHOD:: setProperties

    Sets several properties at once: link::#-numChannels::, link::#-index::, link::#-bufsize::, link::#-zoom::, and link::#-rate::.



EXAMPLES::

SUBSECTION:: A step-by-step example
code::
s.boot;
(
{
    SinOsc.ar([225, 450, 900], 0, 0.2)
    + LPF.ar(
        LFPulse.ar(226 * [1, 2, 5],[0,0.1,0.1],0.2, 0.2),
        MouseX.kr(20, 10000, 1)
        )
}.scope;
)

// server.scope only changes the properies explicitly given:

s.scope(numChannels:5);
s.scope(index:12);
s.scope(zoom:4);
s.scope(index:0);

s.scopeWindow.size = 600;
s.scopeWindow.size = 222;

// scoping buses:

a = Bus.audio(s, 4);
{ WhiteNoise.ar(0.2.dup(4)) }.play(s, a);

a.scope;

c = Bus.control(s, 3);
{ WhiteNoise.kr(1.dup(4) * MouseX.kr) }.play(s, c);

c.scope;

// note that scoping control rate buses shows block size interpolation (this is due to the
// fact that ScopeOut.kr doesn't work yet.)
::

SUBSECTION:: Embedded use
You can pass your own view in to add a stethoscope to it:

code::
w = Window.new("my own scope", Rect(20, 20, 400, 500));
w.view.decorator = FlowLayout(w.view.bounds);
c = Stethoscope.new(s, view:w.view);
w.onClose = { c.free }; // don't forget this
w.front;
::


class:: Stream
summary:: Stream is the base class for classes that define streams
related:: Classes/Routine, Classes/FuncStream, Classes/EventStreamPlayer
categories:: Streams-Patterns-Events

description::

Stream is an abstract class that is not used directly. The following attempts to document some aspects of the use of Streams for music generation.

subsection::Overview

A Stream represents a sequence of values that are obtained incrementally by repeated strong::next:: messages. A Stream can be restarted with a strong::reset:: message. (Not all streams actually implement reset semantics.)

The class link::Classes/Object:: defines strong::next:: to return the object itself. Thus every object can be viewed as a stream and most simply stream themselves.

In SuperCollider, Streams are primarily used for handling text and for generating music.

subsection::FuncStream(nextFunction, resetFunction)

A link::Classes/Function:: defines a stream consisting of the Function itself, a link::Classes/FuncStream:: defines a stream that consists of emphasis::evaluations:: of its nextFunction.

code::
// Example 1: a Function vs. a FuncStream
(
	f = { 33.rand };
	x = FuncStream(f);
	10.do({ [f.next, x.next].postln });
)
::

code::
// Example 2: the reset function
(
	f = { 33.rand };
	x = FuncStream(f, {thisThread.randSeed_(345)});
	x.reset;
	10.do({ [f.next, x.next].postln });
	x.reset;
	10.do({ [f.next, x.next].postln });
)
::

subsection::Routine(nextFunction, stacksize)

In a link::Classes/FuncStream::, the nextFunction runs through to completion for each element of the stream. In a link::Classes/Routine::, the nextFunction returns values with strong::yield:: and resumes execution (when it receives a strong::next:: message) at the expression following the yield. This allows a sequence of expressions in the function definition to represent a sequence of distinct events, like a musical score.

code::
// example
(
	x = Routine({
		1.yield;
		2.yield;
		3.yield;
	});
	4.do({ x.next.postln });
)
::

Once the nextFunction completes execution, the Routine simply yields nil repeatedly. Control structures (such as strong::do:: or strong::while::) can be used within the nextFunction in a manner analogous to repeat marks in a score.

code::
// example
(
	x = Routine({
		4.do({
			[1,2,3,4].do({ arg i; i.yield; });
		});
	});
	17.do({ x.next.postln });
)
::

subsection::Playing streams

Because streams respond like functions to the value message, they can be used as a scheduling task.

code::
// compare:
// a function, returning 0.5
(
SystemClock.sched(0.0,
	{ "***".postln; 0.5 }
);
)

// a stream, returning 0.5 and 0.1
(
SystemClock.sched(0.0,
	Routine({ loop {
		"***".postln; 0.5.yield;
		"_*_".postln; 0.1.yield;
	} });
);
)

// this is the reason why 'wait' works the same (for numbers) like 'yield'
(
SystemClock.sched(0.0,
	Routine({ loop {
		"***".postln; 0.5.wait;
		"_*_".postln; 0.1.wait;
	} });
);
)
::

Streams that return strong::numbers:: can be played directly with the strong::play:: message.

code::
// play at the next beat, with offset 0.4
(
Routine({ loop {
	"***".postln; 0.5.wait;
	"_*_".postln; 0.1.wait;
} }).play(quant:[1, 0.4]);
)
::

Streams that return strong::Events:: need to be wrapped in an link::Classes/EventStreamPlayer::. The Event's strong::delta:: (can also be set by strong::dur::) is used as a scheduling beats value:

code::
// play at the next beat, with offset 0.4
(
Routine({ loop {
	"///".postln; (delta:0.5).yield;
	"_/_".postln; (delta: 0.1).wait;
} }).asEventStreamPlayer.play;
)
::

subsection::Iteration

The method link::#-do:: effectively 'plays' a stream by iterating all of its contents.

And the following messages create a stream by filtering another stream in some way: link::#-collect::, link::#-reject::, link::#-select::, link::#-dot::, link::#-interlace::, link::#-appendStream::, link::#-embedInStream::, link::#-trace::.

subsection::Composite Streams

Routines can be strong::embedded:: in each other, using link::#-embedInStream:: :

code::
// example
(
x = Routine({
	2.do({
		[1,2,3,4].do({ arg i; i.yield; });
	});
});
y = Routine({
	100.yield;
	30.yield;
	x.embedInStream;
	440.yield;
	1910.yield;
});
17.do({ y.next.postln });
)
::

Routines can be strong::concatenated:: just like Streams:

code::
(
x = Routine({
	2.do({
		[1,2,3,4].do({ arg i; i.yield; });
	});
});
y = Routine({
	100.yield;
	30.yield;
});
z = x ++ y;
17.do({ z.next.postln });
)
::

Routines can be strong::combined:: with the composition operator <>

code::
(
x = Routine({ arg inval;
	2.do({
		[1,2,3,4].do({ arg i;
			if(inval.isNil) { nil.alwaysYield };
			inval = (i * inval).yield;
		});
	});
});
y = Routine({
	100.yield;
	30.yield;
	4.do { 1.0.rand.yield };
});
z = x <> y;
17.do({ z.value.postln }); // call .value here, as this is a function.
)
::

Composite Streams can be defined as combinations of Streams using the unary and binary messages.

subsection::Unary messages

Streams support most of the unary messages defined in link::Classes/AbstractFunction:: :

code::
(
a = Routine({ 20.do({ 33.rand.yield }) });
b = Routine({ [-100,00,300,400].do({ arg v; v.yield}) });

c = b.neg; // define a composite stream

// enumerate and perform all of the unary messages:
[
	\neg, \reciprocal, \bitNot, \abs, \asFloat, \asInteger, \ceil,
	\floor, \frac, \sign, \squared, \cubed, \sqrt, \exp, \midicps,
	\cpsmidi, \midiratio, \ratiomidi, \ampdb, \dbamp, \octcps,
	\cpsoct, \log, \log2, \log10, \sin, \cos, \tan, \asin, \acos, \atan,
	\sinh, \cosh, \tanh, \rand, \rand2, \linrand, \bilinrand, \sum3rand,
	\distort, \softclip, \coin, \even, \odd, \isPositive, \isNegative,
	\isStrictlyPositive
]
.do({ arg msg;
	postf("\n msg: % \n", msg);
	b.reset.perform(msg).do({arg v; v.post; " ".post;});
});
nil;
)
::

subsection::Binary messages

Streams support the following binary messages defined in link::Classes/AbstractFunction:: :

code::
(
a = Routine({ 20.do({ 33.rand.yield }) });
b = Routine({ [-100,00,300,400].do({ arg v; v.yield}) });
[
	'+' , '-' , '*', '/', \div, '%', '**', \min, \max, '<', '<=', '>', '>=', '&', '|',
	\bitXor, \lcm, \gcd, \round, \trunc, \atan2,
	\hypot, '>>', '+>>', \ring1, \ring2, \ring3, \ring4,
	\difsqr, \sumsqr, \sqrdif, \absdif, \amclip,
	\scaleneg, \clip2, \excess, '<!', \rrand, \exprand
]
.do({ arg msg;
	postf("\n msg: % \n", msg);
	b.reset.perform(msg).do({ arg v; v.post; " ".post; });
});
nil;
)
::

InstanceMethods::

method::play
Streams that return strong::numbers:: can be played directly with the strong::play:: message. Streams that return strong::events:: need to be wrapped in an link::Classes/EventStreamPlayer::. See link::#-asEventStreamPlayer::.

argument::clock
a clock. link::Classes/TempoClock:: by default.

argument::quant
either a number strong::n:: (quantize to strong::n:: beats), or an array strong::[n, m]:: (quantize to n beats, with offset m).

method::do
iterate until a nil is encountered.
warning::
Applying do to an endless stream will lock up the interpreter!
::

method::collect
iterate indefinitely.

method::reject
return only those elements for which function.value(element) is false.

method::select
return only those elements for which function.value(element) is true.

method::dot
return function.value(this.next, stream.next) for each element.

method::interlace
iterate all of stream for each element of this. Combine the values using function.

method::appendStream
append stream after this returns nil. The same like ++

method::embedInStream
iterate all of this from within whatever Stream definition it is called.

method::trace
print out the results of a stream while returning the original values.

argument::key
when streaming events, post only this key.

argument::printStream
printOn this stream (default: link::Classes/Post::).

argument::prefix
string added to the printout to separate different streams.


class:: StreamClutch
summary:: buffers a streamed value
related:: Classes/Routine, Classes/FuncStream, Classes/EventStreamPlayer
categories:: Streams-Patterns-Events


ClassMethods::

method::new

argument::pattern
a pattern or stream to be buffered.

argument::connected
if true it will call the next stream value for each time next is called. if false it returns the last value.

Examples::

code::
a = Pseq([1, 2, 3], inf);
b = StreamClutch(a);

6.do({ b.next.postln });
b.connected = false;
6.do({ b.next.postln });


//statistical clutch
a = Pseq([1, 2, 3], inf);
b = StreamClutch(a, { 0.5.coin });
12.do({ b.next.postln });
::

code::
s.boot;
//sound example:
(
var clutch, pat, decision;
decision = Pseq([Pn(true,10), Prand([true, false], 10)], inf).asStream;
pat = Pbind(\freq, Pseq([200, [300, 302], 400, 450], inf), \dur, 0.3);
clutch = StreamClutch(pat, decision);
clutch.asEventStreamPlayer.play;
)
::

code::
// independant stepping
(
var clutch, pat, decision;
pat = Pbind(\freq, Pseq([200, [300, 302], 400, 450], inf), \dur, 0.3);
b = StreamClutch(pat);
b.connected = false;
b.asEventStreamPlayer.play;
)

b.step;
::


instancemethods::

subsection:: Extensions by SCDoc

method:: stripWhiteSpace
Strips whitespace at the beginning and end of the string.
returns:: The stripped string

method:: unixCmdGetStdOutLines
Like link::#-unixCmdGetStdOut:: but returns the lines in an Array instead.
returns:: an link::Classes/Array:: of each line of output



CLASS::String
summary::array of Chars
related::Classes/Char
categories:: Collections>Ordered

DESCRIPTION::
String represents an array of link::Classes/Char##Chars::.

Strings can be written literally using double quotes:
code::
"my string".class
::
A sequence of string literals will be concatenated together:
code::
x = "hel" "lo";
y = "this is a\n"
    "multiline\n"
    "string";
::

Backslash is the escape character. See link::Reference/Literals#Characters::.

subsection:: Character encodings

Note that, while Char does not support encodings aside from ASCII—such as
multi-byte encodings like UTF-8 and UTF-16, or the full Latin-1 (ISO 8859-1)
character set—Chars with negative values are perfectly legal, and may be strung
together in strings that use these encodings.

The SuperCollider IDE uses UTF-8 (a superset of ASCII) to decode and display
strings, which means that the string code::"🎹🙄🎻😂🎚️🎛️🎤😍":: can be written in
the editor, posted in the post window, and treated for the most part like any
other string.
However, because non-ASCII UTF-8 characters consist of two or more bytes,
and a SuperCollider String's members are one-bit Chars, concepts of size and
indexing may not behave intuitively.
For instance, the "code::size::" of the string above is 38, not 8, and the value
of its first index is code::-16::, which is not a valid ASCII value at all but
rather the signed 8-bit representation of the first byte of the UTF-8 value of
the piano keyboard emoji (🎹), code::0xF09F8EB9::.

CLASSMETHODS::

private::initClass
private::doUnixCmdAction
private::unixCmdActions

method::readNew
Read the entire contents of a link::Classes/File:: and return them as a new String.

method::scDir
Deprecated alias for code::Platform.resourceDir::. Please use link::Classes/Platform#*resourceDir:: instead.

INSTANCEMETHODS::

private::prUnixCmd, prFormat, prCat, prBounds, hash, species, getSCDir, prDrawInRect, prDrawAtPoint, openTextFile

subsection:: Accessing characters

method::@, at
Strings respond to .at in a manner similar to other indexed collections. Each element is a link::Classes/Char::.
code::
"ABCDEFG".at(2)
::

method::ascii
Returns an Array of ASCII values of the Strings's characters.
code::
"wertvoll".ascii // [ 119, 101, 114, 116, 118, 111, 108, 108 ]
::

Note that if a string contains multi-byte UTF-8 characters, this array will not
be of the same length as the number of visible characters, nor will it
necessarily be an array of valid 7-bit ASCII values.

code::
// "face with tears of joy" is Unicode codepoint U+1F602, which is encoded in UTF-8 as hex value 0xF09F9882
a = "😂";

// although this is one UTF-8 character, it must be stored as 4 Chars because Chars can only hold 1 byte each
a.size // 4 (!)
a.ascii // [ -16, -97, -104, -126 ]

// "wrap(0, 255)" converts these numbers to their unsigned 8-bit values
b = a.ascii.wrap(0, 255) // [ 240, 159, 152, 130 ]

// if we represent these values in hexidecmial, it's the same as the UTF-8 above: 0xF09F9882
b.collect(_.asHexString(2)) // [ F0, 9F, 98, 82 ]
::

subsection:: Comparing strings

method::compare
Returns an integer less than, equal to or greater than zero, depending on whether the receiver should be sorted before the argument, is equal to the argument or should be sorted after the argument. This is a case sensitive compare.

method::<
Returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument.
code::
"same" < "samf"
::

method::>
Returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument.
code::
"same" > "samf"
::
method::<=
Returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument, including the same string.
code::
"same" <= "same"
"same" <= "samf"
::

method::>=
Returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument, including the same string.
code::
"same" >= "same"
"same" >= "samf"
::

method::==
Returns a link::Classes/Boolean:: whether the two Strings are equal.
note::
This method is (now) case sensitive!
::
code::
"same" == "same"
"same" == "Same"; // false
::

method::!=
Returns a link::Classes/Boolean:: whether the two Strings are not equal.
code::
"same" != "same"; // false
"same" != "Same";
::

subsection:: Fuzzy string comparison
With fuzzy comparison, the strings don't need to match exactly - we can work out how similar they are, and make decisions based on that.
This behaviour is inherited from the link::Classes/SequenceableCollection#-editDistance::, and is documented fully there, but to provide an example:
code::
"hello".editDistance("hallo"); // 1 (substitution)
"hello".editDistance("hell"); // 1 (deletion)
"hello".editDistance("helloo"); // 1 (addition)
"hello".editDistance("hllo"); // 1 (removal)
"hello".editDistance("haldo"); // 2 (substitutions)
::

subsection:: Posting strings

method::post
Prints the string to the current post window.
code::
"One".post; "Two".post;"";
::

method::postln
Prints the string and a carriage return to the current post window.
code::
"One".postln; "Two".postln;"";
::

method::postc, postcln
As link::#-post:: and link::#-postln::, but formatted as a comment.
code::
"This is a comment.".postcln;
::

method::postf
Prints a formatted string with arguments to the current post window. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .
code::
postf("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [ 1, 2, 3, 4 ]
::

method::postcs
As link::#-postln::, but posts the link::#-asCompileString#compileString:: of the receiver.
code::
List[1, 2, ["comment", [3, 2]], { 1.0.rand }].postcs;
::

method::error
Prepends an error banner and posts the string.
code::
"Do not press this button again".error;
::

method::warn
Prepends a warning banner and posts the string.
code::
"Do not press this button again".warn;
::

method::inform
Legacy method (although due to widespread use, it will not be removed). This is identical to code::postln::.

subsection:: Interpreting strings as code

method::compile
Compiles a String containing legal SuperCollider code and returns a Function.
code::
(
var f;
f = "2 + 1".compile.postln;
f.value.postln;
)
::

method::interpret
Compile and execute a String containing legal SuperCollider code, returning the result.
code::
"2 + 1".interpret.postln;
::

method::interpretPrint
Compile, execute and print the result of a String containing legal SuperCollider code.
code::
"2 + 1".interpretPrint;
::

subsection:: Converting strings

method::asCompileString
Returns a String formatted for compiling.
code::
(
var f;
f = "myString";
f.postln;
f.asCompileString.postln;
)
::

method::asSymbol
Return a link::Classes/Symbol:: derived from the String.
code::
(
var z;
z = "myString".asSymbol.postln;
z.class.postln;
)
::

method::asInteger
Return an link::Classes/Integer:: derived from the String. Strings beginning with non-numeric characters return 0.
code::
"4".asInteger.postln;
::

method::asFloat
Return a link::Classes/Float:: derived from the String. Strings beginning with non-numeric characters return 0.
code::
"4.3".asFloat.postln;
::

method::asSecs
Return a link::Classes/Float:: based on converting a time string in format code::(ddd:)hh:mm:ss(.z)::, where code::z:: is any sequence of digits. This is the inverse method to link::Classes/SimpleNumber#-asTimeString::.
code::
"00:00:59.900".asSecs; // hh:mm:ss.zzz
"1:1:1.1".asSecs; // h:m:s.z
"001:00:00:00.001".asSecs; // ddd:hh:mm:ss.zzz
"32.1".asSecs;
"32.".asSecs; // trailing period
"32.12345678".asSecs; // any number of decimal places
"62.1".asSecs; // warns
"-1".asSecs; // neg sign supported
"-12:34:56".asSecs; // neg sign always at the beginning
"-23:12.346".asSecs;
"-1:00:00:00".asSecs; // neg with days
"12:-34:56".asSecs; // warns
(45296.789.asTimeString).asSecs; // inverse of aNumber.asTimeString
::

subsection:: Concatenate strings

method::++
Return a concatenation of the two strings.
code::
"hello" ++ "word"
::

method::+
Return a concatenation of the two strings with a space between them.
code::
"hello" + "word"
::

method::+/+
Concatenates code::this:: and code::path::, as components of a filesystem path on the host operating
system. The strings are joined to avoid duplicate path separators.

If code::this:: ends with a path separator and code::path:: begins with one, then the separator
in code::path:: is dropped. If there is a path separator on either side, this has the same effect as
using code::++::. If neither side has a path separator, the platform's preferred separator
('\' on Windows, '/' otherwise) is added.

Returns code::this:: and code::path:: concatenated. If code::path:: was a PathName, the result is a
PathName; otherwise, it is a String.

argument::path

Any object that can be converted to a string. Typically, either a String, link::Classes/Symbol::, or
link::Classes/PathName::.

code::
// On Windows, this produces "foo\\bar"; on other platforms, "foo/bar"
"foo" +/+ "bar"

// On all platforms, this produces "foo/bar": +/+ prefers using an existing separator
"foo/" +/+ "bar"
"foo" +/+ "/bar"
"foo/" +/+ "/bar"

// On Windows, this produces "foo\\bar"; on other platforms, "foo/\\bar"
"foo" +/+ "\\bar"

// Concatenating a symbol is also OK
"foo" +/+ 'bar'
::

method::catArgs
Concatenate this string with the following args.
code::
"These are some args: ".catArgs(\fish, SinOsc.ar, {4 + 3}).postln;
::

method::scatArgs
Same as link::#-catArgs::, but with spaces in between.
code::
"These are some args: ".scatArgs(\fish, SinOsc.ar, {4 + 3}).postln;
::

method::ccatArgs
Same as link::#-catArgs::, but with commas in between.
code::
"a String".ccatArgs(\fish, SinOsc.ar, {4 + 3}).postln;
::

method::catList, scatList, ccatList
As link::#-catArgs::, link::#-scatArgs:: and link::#-ccatArgs:: above, but takes a Collection (usually a link::Classes/List:: or an link::Classes/Array::) as an argument.
code::
"a String".ccatList([\fish, SinOsc.ar, {4 + 3}]).postln;
::



subsection:: Regular expressions

The String class provides access to the boost library's regular expression functions. Boost's default uses Perl settings. (Currently, there is no hook to override the regex style.) Syntax details may be found at link::https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html::.

Note carefully the argument order:

List::
## Code::regexp.matchRegexp(stringToSearch)::
## Code::stringToSearch.findRegexp(regexp):: (and similar for code::findAllRegexp:: and code::findRegexpAt::).
::

Code::findRegexp:: follows the pattern established by link::Classes/String#-find::, where the receiver is the string to be searched. Code::matchRegexp:: follows the pattern of link::Reference/matchItem::, where the receiver is the pattern to match and the first argument is the object to be tested. This is a common source of confusion, but it is based on this precedent.

method::matchRegexp
Perl regular expression matching (see link::Classes/String#Regular expressions::). Returns true if the receiver (a regular expression pattern) matches the string passed to it. The strong::start:: is an offset where to start searching in the string (default: 0), strong::end:: where to stop.

note::This is code::regexp.matchRegexp(stringToSearch):: and not the other way around! See above: link::Classes/String#Regular expressions::.::

code::
"c".matchRegexp("abcdefg", 2, 5); // true: substring exists
"c".matchRegexp("abcdefg", 4, 5); // false: substring doesn't exist

"behaviou?r".matchRegexp("behavior"); // true: character may or may not exist
"behaviou?r".matchRegexp("behaviour"); // true: character may or may not exist
"behaviou?r".matchRegexp("behavir"); // false: but the rest does not match
"behavi(ou)?r".matchRegexp("behavir"); // true: the substring in parens may or may not exist
"b.h.v.r".matchRegexp("behavor"); // true
"b.h.v.r".matchRegexp("behaviiiiir"); // false: dot stands for exactly one char
"b.h.vi*r".matchRegexp("behaviiiiir"); // true: (kleene) star stands for any number of chars preceding, or none
"b.h.vi*r".matchRegexp("behavuuuur"); // false
"(a|u)nd".matchRegexp("und"); // true
"(a|u)nd".matchRegexp("and"); // true
"[a-c]nd".matchRegexp("ind"); // false
"[a-c]nd".matchRegexp("bnd"); // true: anything between a and c
"[a-c]*nd".matchRegexp("accacaccacand"); //  true: any combination of a, b, c, or none.
"[xtz]+nd".matchRegexp("xnd"); // true: any combination of x, t, z
::

method::findRegexp
Perl regular expression search (see link::Classes/String#Regular expressions::). This method searches exhaustively for matches and collects them into an array of pairs, in the format code::[character index, matching string]::.

"Leftmost largest match": As in most flavors of regular expressions, code::*:: and code::+:: are greedy; if it is possible to have more than one overlapping match for a part of the regular expression, the match list will include only the leftmost and largest of them. In code::"foobar".findRegexp("o+")::, code::"o+":: may potentially have three matches: code::"o":: at index 1 (second character), code::"o":: at index 2, and code::"oo":: at index 1. code::findRegexp:: will return only the last of these (code::"oo"::), because it begins in the leftmost-possible matching position, and it is the longest possible match at that position.

Note, though, that parentheses for grouping (a "marked sub-expression" or "capturing group") will produce a separate result: code::"aaa".findRegexp("(a+)");:: appears to produce duplicated results code::[ [ 0, aaa ], [ 0, aaa ] ]::, but this is because the first match is for the parentheses and the second is for code::a+::.

To see the marked sub-expression results more clearly, consider:

code::
"foobar".findRegexp("(o*)(bar)");
-> [ [ 1, oobar ], [ 1, oo ], [ 3, bar ] ]
::

code::"oobar":: matches the entire regular expression. code::"oo":: and code::"bar":: match the first and second parenthesized sub-expressions, respectively.

code::
"foobar".findRegexp("o*bar");
"32424 334 /**aaaaaa*/".findRegexp("/\\*\\*a*\\*/");
"aaaabaaa".findRegexp("a+");
::

Returns:: A nested array, where each sub-array is a pair, code::[character index, matching string]::. If there are no matches, an empty array.

method::findAllRegexp
Like link::#-findAll::, but use regular expressions (see link::Classes/String#Regular expressions::). Unlike findRegexp, it returns only the indices of the matches: code::string.findAllRegexp(regexp):: returns the same as code::string.findRegexp(regexp).flop.at(0)::.

code::
"foobar".findAllRegexp("o*bar");
"32424 334 /**aaaaaa*/".findAllRegexp("/\\*\\*a*\\*/");
"foobar".findAllRegexp("(o*)(bar)");
"aaaabaaa".findAllRegexp("a+");
::

Returns:: An array of integer character indices pointing to all the possible matches.

method::findRegexpAt
Match a regular expression (see link::Classes/String#Regular expressions::) at the given offset, returning the match and the length of the match in an Array, or nil if it doesn't match.
The match must begin right at the offset.

code::
"foobaroob".findRegexpAt("o*b+", 0); // nil
"foobaroob".findRegexpAt("o*b+", 1); // [ oob, 3 ]
"foobaroob".findRegexpAt("o*b+", 2); // [ ob,  2 ]
"foobaroob".findRegexpAt("o*b+", 3); // [ b,   1 ]
"foobaroob".findRegexpAt("o*b+", 4); // nil
"foobaroob".findRegexpAt("o*b+", 5); // nil
"foobaroob".findRegexpAt("o*b+", 6); // [ oob, 3 ]
"foobaroob".findRegexpAt("o*b+", 7); // [ ob,  2 ]
::

Returns:: An array code::[matching string, length]:: if a match is found at the specified offset; code::nil:: if the offset doesn't match.

subsection:: Searching strings

method::find
Returns the index of the string in the receiver, or nil if not found. If strong::ignoreCase:: is true, find makes no difference between uppercase and lowercase letters. The strong::offset:: is the point in the string where the search begins. string may be a String or a link::Classes/Char::.
code::
"These are several words".find("are").postln;
"These are several words".find("fish").postln;
::

method::findBackwards
Same like link::#-find::, but starts at the end of the string.
code::
// compare:
"These words are several words".find("words"); // 6
"These words are several words".findBackwards("words"); // 24
::

method::findAll
Returns the indices of the string in the receiver, or nil if not found.
code::
"These are several words which are fish".findAll("are").postln;
"These are several words which are fish".findAll("fish").postln;
::

method::contains
Returns a link::Classes/Boolean:: indicating if the String contains string.
code::
"These are several words".contains("are").postln;
"These are several words".contains("fish").postln;
::

method::containsi
Same as link::#-contains::, but case insensitive.
code::
"These are several words".containsi("ArE").postln;
::

method::containsStringAt
Returns a link::Classes/Boolean:: indicating if the String contains string beginning at the specified index.
code::
"These are several words".containsStringAt(6, "are").postln;
::

method::icontainsStringAt
Same as link::#-containsStringAt::, but case insensitive.

method::beginsWith
method::endsWith
Returns true if this string begins/ends with the specified other string.
argument:: string
The other string
returns::
A link::Classes/Boolean::

subsection:: Manipulating strings

method::rotate
Rotate the string by n steps.
code::
"hello word".rotate(1)
::

method::scramble
Randomize the order of characters in the string.
code::
"hello word".scramble
::


method::replace
Like link::#-tr::, but with Strings as well as Chars as arguments.
code::
"Here are several words which are fish".replace("are", "were");
::

method::format
Returns a formatted string with arguments. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .
code::
format("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [ 1, 2, 3, 4 ]
::

method::escapeChar
Add the escape character (\) before any character of your choice.
code::
// escape spaces:
"This will become a Unix friendly string".escapeChar($ ).postln;
::

method::quote
Return this string enclosed in double-quote ( teletype::":: ) characters.
code::
"tell your" + "friends".quote + "not to tread onto the lawn"
::

method::zeroPad
Return this string enclosed in space characters.
code::
"spaces".zeroPad.postcs;
::

method::underlined
Return this string followed by dashes in the next line ( teletype::-:: ).
code::
"underlined".underlined;
"underlined".underlined($~);
::

method::tr
Transliteration. Replace all instances of strong::from:: with strong::to::.
code::
":-(:-(:-(".tr($(, $)); //turn the frowns upside down
::


method::padLeft
method::padRight
Pad this string with strong::string:: so it fills strong::size:: character.
argument:: size
Number of characters to fill
argument:: string
Padding string
code::
"this sentence has thirty-nine letters".padRight(39, "-+");
"this sentence has thirty-nine letters".padLeft(39, "-+");
"this sentence more than thirteen letters".padRight(13, "-+"); // nothing to pad.
::

method::toUpper
Return this string with uppercase letters.
code::
"Please, don't be impolite".toUpper;
::

method::toLower
Return this string with lowercase letters.
code::
"SINOSC".toLower;
::

method::stripRTF
Returns a new String with all RTF formatting removed.
code::
(
// same as File-readAllStringRTF
g = File("/code/SuperCollider3/build/Help/UGens/Chaos/HenonC.help.rtf","r");
g.readAllString.stripRTF.postln;
g.close;
)
::

method::split
Returns an Array of Strings split at the separator. The separator is a link::Classes/Char::, and is strong::not:: included in the output array.
code::
"These are several words".split($ );

// The default separator $/ is handy for Unix paths.
"This/could/be/a/Unix/path".split;
::

subsection:: Stream support

method::printOn
Print the String on stream.
code::
"Print this on Post".printOn(Post);

// equivalent to:
Post << "Print this on Post";
::

method::storeOn
Same as link::#-printOn::, but formatted link::#-asCompileString::.
code::
"Store this on Post".storeOn(Post);

// equivalent to:
Post <<< "Store this on Post";
::



subsection::Unix Support

Where relevant, the current working directory is the same as the location of the SuperCollider app and the shell is the Bourne shell (sh). Note that the cwd, and indeed the shell itself, does not persist:
code::
"echo $0".unixCmd; // print the shell (sh)
"pwd".unixCmd;
"cd Help/".unixCmd;
"pwd".unixCmd;

"export FISH=mackerel".unixCmd;
"echo $FISH".unixCmd;
::
It is however possible to execute complex commands:
code::
"pwd; cd Help/; pwd".unixCmd;
"export FISH=mackerel; echo $FISH".unixCmd;
::
Also on os x applescript can be called via osascript:
code::
"osascript -e 'tell application \"Safari\" to activate'".unixCmd;
::
Should you need an environment variable to persist you can use link::#-setenv::.

note::
Despite the fact that the method is called 'unixCmd', strong::it does work in Windows::. The string must be a DOS command, however: "dir" rather than "ls" for instance.
::

method::unixCmd
Execute a UNIX command strong::asynchronously:: using the standard shell (sh).
argument:: action
A link::Classes/Function:: that is called when the process has exited. It is passed two arguments: the exit code and pid of the exited process.
argument:: postOutput
A link::Classes/Boolean:: that controls whether or not the output of the process is displayed in the post window.
returns::
An link::Classes/Integer:: - the pid of the newly created process. Use link::Classes/Integer#-pidRunning:: to test if a process is alive.
discussion::
Example:
code::
"ls Help".unixCmd;
"echo one; sleep 1; echo two; sleep 1".unixCmd { |res, pid| [\done, res, pid].postln };
::

method::unixCmdGetStdOut
Similar to link::#-unixCmd:: except that the stdout of the process is returned (strong::synchronously::) rather than sent to the post window.
code::
~listing = "ls Help".unixCmdGetStdOut; // Grab
~listing.reverse.as(Array).dupEach.join.postln; // Mangle
::

method::systemCmd
Executes a UNIX command strong::synchronously:: using the standard shell (sh).

returns:: Error code of the UNIX command

method::runInTerminal
Execute the String in a new terminal window (strong::asynchronously::).
argument::shell
The shell used to execute the string.
discussion::
note:: On macOS and Linux, the string is incorporated into a temporary script file and executed using the shell. ::
note:: On Linux, it is possible to choose a specific terminal emulator to be used, otherwise sclang tries to find one by itself. See link::Classes/LinuxPlatform#*runInTerminalCmd::. ::
Example:
code::
"echo ---------Hello delightful SuperCollider user----------".runInTerminal;
::

method::setenv
Set the environment variable indicated in the string to equal the String strong::value::. This value will persist until it is changed or SC is quit. Note that if strong::value:: is a path you may need to call link::#-standardizePath:: on it.
code::
// all defs in this directory will be loaded when a local server boots
"SC_SYNTHDEF_PATH".setenv("~/scwork/".standardizePath);
"echo $SC_SYNTHDEF_PATH".unixCmd;
::

method::getenv
Returns the value contained in the environment variable indicated by the String.
code::
"USER".getenv;
::

method::unsetenv
Set the environment variable to nil.

method::mkdir
Make a directory from the given path location.

method::pathMatch
Returns an link::Classes/Array:: containing all paths matching this String. Wildcards apply, non-recursive.
code::
Post << "Help/*".pathMatch;
::

method::load
Load and execute the file at the path represented by the receiver.

method::loadPaths
Perform link::#-pathMatch:: on this String, then load and execute all paths in the resultant link::Classes/Array::.


code::
//first prepare a file with some code...
(
File.use("/tmp/loadPaths_example.scd", "w", { |file|
	file << "\"This text is the result of a postln command which was loaded and executed by loadPaths\".postln;";
	file <<	"\"I will now throw a dice for you: \".post; 7.rand;"
})
)

// then load the file...
 // ... it posts some text, and the return value pf loadPaths is an array of the return values of each file
"/tmp/loadPaths_example.scd".loadPaths;
::

argument::warn
Post a warning if path doesn't point to any file.

argument::action
If a function is passed, it is called with each path as argument.



method::loadRelative
Load and execute the file at the path represented by the receiver, interpreting the path as relative to the current document or text file. Requires that the file has been saved. This can be used e.g. to load initialization code from files in the same folder.

argument::warn
Warn if a file is not found.

argument::action
A function that is called for each file path that is found.

method::resolveRelative
Convert the receiver from a relative path to an absolute path, relative to the current document or text file. Requires that the current text file has been saved. Absolute paths are left untransformed.

method::standardizePath
Expand ~ to your home directory, and resolve aliases on macOS. See link::Classes/PathName:: for more complex needs. See link::Classes/File#*realpath:: if you want to resolve symlinks.
code::
"~/".standardizePath; //This will print your home directory
::


method::openOS
Open file, directory or URL via the operating system. On macOS this is implemented via teletype::open::, on Linux via
teletype::xdg-open:: and on Windows via teletype::start::.
code::
Platform.userConfigDir.openOS;
"http://supercollider.sf.net".openOS;
::

subsection::Pathname Support

Also see link::#-+/+:: for path concatenation.

The term "path separator" is a platform-independent term for the character(s) that can be used to
separate components of a path. On Windows, both forward slash "/" and backward slash "\\" are path
separators. On POSIX-based systems like macOS and Linux, only forward slash is allowed.

method::shellQuote
Return a new string suitable for use as a filename in a shell command, by enclosing it in single quotes ( teletype::':: ).
If the string contains any single quotes they will be escaped.
discussion::
You should use this method on a path before embedding it in a string executed by link::#-unixCmd:: or link::#-systemCmd::.
code::
unixCmd("ls " + Platform.userExtensionDir.shellQuote)
::
note::
This works well with shells such as strong::bash::, other shells might need different quotation/escaping.
Apart from usage in the construction of shell commands, strong::escaping is not needed:: for paths passed to methods like pathMatch(path) or File.open(path).
::

method::absolutePath
method::asAbsolutePath
Return this path as an absolute path by prefixing it with link::Classes/File#*getcwd:: if necessary.

method::asRelativePath
Return this path as relative to the specified path.
argument::relativeTo
The path to make this path relative to.

method::withTrailingSlash
Appends a path separator if one is not already present.

method::withoutTrailingSlash
Removes a trailing path separator if one is present.

method::basename
Return the filename from a Unix path.
code::
"Imaginary/Directory/fish.rtf".basename;
::

method::dirname
Return the directory name from a Unix path.
code::
"Imaginary/Directory/fish.rtf".dirname;
::

method::splitext
Split off the extension from a filename or path and return both in an link::Classes/Array:: as [path or filename, extension].
code::
"fish.rtf".splitext;
"Imaginary/Directory/fish.rtf".splitext;
::

subsection::YAML and JSON parsing

method::parseYAML
Parse this string as YAML/JSON.
returns::
A nested structure of link::Classes/Array::s (for sequences), link::Classes/Dictionary##Dictionaries:: (for maps) and link::Classes/String::s (for scalars).

method::parseYAMLFile
Same as code::parseYAML:: but parse a file directly instead of a string. This is faster than reading a file into a string and then parse it.

method::parseJSON
This method is currently just an alias for link::#-parseYAML::, in the future it will only accept valid JSON.
returns::
A nested structure of link::Classes/Array::s (for sequences), link::Classes/Dictionary##Dictionaries:: (for maps) and link::Classes/String::s (for scalars).

code::
"{\"a\": 1}".parseYAML;
"{\"a\": 1}".parseJSON;
::

method::parseJSONFile
This method is currently just an alias for link::#-parseYAMLFile::, in the future it will only accept valid JSON files.

subsection::Document Support

method::newTextWindow
Create a new link::Classes/Document:: with this.
code::
"Here is a new Document".newTextWindow;
::

method::openDocument
Create a new link::Classes/Document:: from the path corresponding to this. The selection arguments will preselect the indicated range in the new window. Returns this.
code::
(
String.filenameSymbol.asString.openDocument(10, 20)
)
::

method::findHelpFile
Returns the path for the helpfile named this, if it exists, else returns nil.
code::
"Document".findHelpFile;
"foobar".findHelpFile;
::

method::help
Performs link::#-findHelpFile:: on this, and opens the file it if it exists, otherwise opens the main helpfile.
code::
"Document".help;
"foobar".help;
::

subsection::Misc methods

method::inspectorClass
Returns class link::Classes/StringInspector::.


subsection::Drawing Support

The following methods must be called within an Window-drawFunc or a SCUserView-drawFunc function, and will only be visible once the window or the view is refreshed. Each call to Window-refresh SCUserView-refresh will 'overwrite' all previous drawing by executing the currently defined function.

See also: link::Classes/Window::, link::Classes/UserView::, link::Classes/Color::, and link::Classes/Pen::.

note::
for cross-platform GUIs, use code::Pen.stringAtPoint, Pen.stringInRect, Pen.stringCenteredIn, Pen.stringLeftJustIn, Pen.stringRightJustIn:: instead.
::

method::draw
Draws the String at the current 0@0 link::Classes/Point::. If not transformations of the graphics state have taken place this will be the upper left corner of the window. See also link::Classes/Pen::.
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.draw
};
w.refresh
)
::

method::drawAtPoint
Draws the String at the given link::Classes/Point:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawAtPoint(
		100@100,
		Font("Courier", 30),
		Color.blue(0.3, 0.5))
};
w.refresh;
)
::

method::drawInRect
Draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
(
w = Window.new.front;
r = Rect(100, 100, 100, 100);
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawInRect(r, Font("Courier", 12), Color.blue(0.3, 0.5));
	Pen.strokeRect(r);
};
w.refresh;
)
::

method::drawCenteredIn
Draws the String into the given Rect using the Font and Color specified.
code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawCenteredIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::

method::drawLeftJustIn
Draws the String into the given Rect using the Font and Color specified.
code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawLeftJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::

method::drawRightJustIn
Draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawRightJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::

method::bounds
Tries to return a link::Classes/Rect:: with the size needed to fit this string if drawn with given font.
argument:: font
A link::Classes/Font::



class:: SubsampleOffset
summary:: Offset from synth start within one sample.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleDur, Classes/SampleRate, Classes/OffsetOut
categories::  UGens>Info


Description::

When a synth is created from a time stamped osc-bundle, it starts
calculation at the next possible block (normally 64 samples). Using an
OffsetOut UGen, one can delay the audio so that it matches sample
accurately.


For some synthesis methods, one needs subsample accuracy. SubsampleOffset
provides the information where, within the current sample, the synth was
scheduled. It can be used to offset envelopes or resample the audio
output.


classmethods::

method::ir

Examples::

code::

// example: demonstrate cubic subsample interpolation


// impulse train that can be moved between samples
(
SynthDef(\Help_SubsampleOffset, { |out, addOffset|
	var in, dt, sampDur, extraSamples, sampleOffset, resampledSignal;
	in = Impulse.ar(2000, 0, 0.3); // some input.
	sampDur = SampleDur.ir; 	// duration of one sample
	extraSamples = 4;			// DelayC needs at least 4 samples buffer
	sampleOffset = 1 - SubsampleOffset.ir; // balance out subsample offset
	sampleOffset = sampleOffset + MouseX.kr(0, addOffset); // add a mouse dependent offset
	// cubic resampling:
	resampledSignal = DelayC.ar(in,
							maxdelaytime: sampDur * (1 + extraSamples),
							delaytime: sampDur * (sampleOffset + extraSamples)
					);
	OffsetOut.ar(out, resampledSignal)
}).add;
)

// create 2 pulse trains 1 sample apart, move one relatively to the other.
// when cursor is at the left, the impulses are adjacent, on the right, they are
// exactly 1 sample apart.

(
var dt = s.sampleRate.reciprocal; // 1 sample delay
s.sendBundle(0.2, [9, \Help_SubsampleOffset, s.nextNodeID, 1, 1, \out, 40, \addOffset, 3]);
s.sendBundle(0.2 + dt, [9, \Help_SubsampleOffset, s.nextNodeID, 1, 1, \out, 40, \addOffset, 0]);
)

s.scope(1, 40, zoom: 0.2);





// example of a subsample accurate sine grain:
// (I don't hear a difference to normal sample accurate grains, but maybe
// someone could add an example that shows the effect)

(
SynthDef("Help_Subsample_Grain",
	{ arg out=0, freq=440, sustain=0.005, attack=0.001;
		var env, offset, sig, sd;

		sd = SampleDur.ir;
		offset = (1 - SubsampleOffset.ir) * sd;
		// free synth after delay:
		Line.ar(1,0, attack + sustain + offset, doneAction: Done.freeSelf);
		env = EnvGen.kr(Env.perc(attack, sustain, 0.2));
		sig = SinOsc.ar(freq, 0, env);

		sig = DelayC.ar(sig, sd * 4, offset);
		OffsetOut.ar(out, sig);
	}, [\ir, \ir, \ir, \ir]).add;
)

(
	Routine {
		loop {
			s.sendBundle(0.2, [9, \Help_Subsample_Grain, -1, 1, 1, \freq, 1000]);
			rrand(0.001, 0.002).wait;
		}
	}.play;
)

::



CLASS:: Sum3
summary:: Sum three signals
categories:: UGens>Algebraic
related:: Classes/Mix

DESCRIPTION::
Sum three signals. Internal ugen to efficiently mix three signals. Should be used via link::Classes/Mix::.

CLASSMETHODS::
private:: new1

METHOD:: new

Construct UGen.


CLASS:: Sum4
summary:: Sum four signals
categories:: UGens>Algebraic
related:: Classes/Mix

DESCRIPTION::
Sum four signals. Internal ugen to efficiently mix four signals. Should be used via link::Classes/Mix::.

CLASSMETHODS::
private:: new1

METHOD:: new

Construct UGen.


class:: Sweep
summary:: Triggered linear ramp
categories::  UGens>Triggers

Description::

Starts a linear raise by rate/sec from zero when trig input crosses from
non-positive to positive.

When rate == 1, Sweep may be used to get a continually-updating measurement
of the time (in seconds) since the last trigger.


classmethods::
private:: categories

method::ar, kr

argument::trig

triggers when trig input crosses from non-positive to positive.


argument::rate

rate/sec raise rate


Examples::

code::
// using sweep to modulate sine frequency
(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 20, 1));
	SinOsc.ar(Sweep.kr(trig, 700) + 500, 0, 0.2)
}.play;
)


// using sweep to index into a buffer
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	BufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0)))
}.play;
)

// backwards, variable offset
(
{ var trig, pos, rate;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	rate = BufSampleRate.ir(0);
	pos = Sweep.ar(trig, rate.neg) + (BufFrames.ir(0) * LFNoise0.kr(0.2));
	BufRd.ar(1, b, pos)
}.play;
)

// raising rate
(
{ var trig, rate;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	rate = Sweep.kr(trig, 2) + 0.5;
	BufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0) * rate))
}.play;
)

b.free

::

Sweep can be used as a resettable link::Classes/Phasor:: or link::Classes/Line:: - one that can start, pause, resume and stop. To get a resettable link::Classes/XLine:: behavior change the code::linlin:: to code::linexp:: in the SynthDef below.
code::
(
SynthDef(\lineReset, { |out, start= 0, end= 1, dur= 1, t_trig= 1, run= 1|
	var phasor = Sweep.ar(t_trig, run / dur).linlin(0, 1, start, end, \minmax);
	phasor.poll;
	Out.ar(out, SinOsc.ar(phasor, 0, 0.2));
}).add;
)
a = Synth(\lineReset, [\start, 400, \end, 800, \dur, 2])
a.set(\t_trig, 1)
a.set(\run, 0)
a.set(\run, 1)
a.set(\t_trig, 1)
a.free

//shorter duration and downwards...
a= Synth(\lineReset, [\start, 1000, \end, 500, \dur, 0.5])
a.set(\t_trig, 1)
a.set(\run, 0)
a.set(\run, 1)
a.set(\t_trig, 1)
a.free
::


class::Symbol
summary::a unique name for something
categories::Core

description::
A symbol, like a link::Classes/String::, is a sequence of characters. Unlike strings, two symbols
with exactly the same characters will be the exact same object. Symbols are optimized for recreating
the same symbol over and over again. In practice, this means that symbols are best used for
identifiers or tags that are only meaningful within your program, whereas you should use a string
when your characters are really processed as text data. Use symbols to name things, use strings for
input and output.

Good uses of symbols include symbolic constant values and link::Classes/Dictionary:: keys.

Symbols are represented syntactically as literals which are described in link::Reference/Literals#Symbols::.

subsection::Creating a Symbol

A symbol can be written by surrounding characters by single quotes (may include whitespace):

code::'foo bar'::

Or by a preceding backslash (then it may not include whitespace):

code::\foo::

A String can be converted into a symbol:

code::"arbeit".scramble.asSymbol;::

classmethods::
private::new

instancemethods::

subsection::Testing

method::isClassName

Answer whether the symbol can be a class name. This does not say if the class exists.

code::
\Array.isClassName;
\Bauxite.isClassName;
::

method::isMetaClassName

Answer whether the symbol can be meta class name. This does not say if the class exists.

code::
\Meta_Array.isMetaClassName;
::

method::isSetter

Answer whether the symbol has a trailing underscore.

code::
'action_'.isSetter;
::

method::isPrimitiveName

Answer whether the symbol is a valid primitive name

code::
'_SymbolIsClassName'.isPrimitiveName;
::

method::isPrefix

Answer whether the symbol is a prefix of another one

code::
'a'.isPrefix('all'); // true
'z'.isPrefix('all');  // false
::

method::isIdentifier

Return true if the symbol is a valid variable name, or equivalently a valid method name in the two
most common method call syntaxes (code::foo.bar():: and code::bar(foo)::). A valid identifier
contains only alphanumeric characters and underscores, and the first character must be a lowercase
letter.

method::isBinaryOp

Return true if the symbol is a valid binary operator. A valid binary operator contains only the
symbols code::!@%&*-+=|<>?/::, does not start with 'code:://::' or 'code::/*::', and is not the
string 'code::=::'.

subsection::Conversion

method::asString

Convert to a String

method::asInteger

Convert to an Integer

method::asClass

Answer the Class named by the receiver.

method::asSetter

Return a symbol with a trailing underscore added.

method::asGetter

Return a symbol with a trailing underscore removed.

method::ascii

return the ascii codes as an array

method::asSpec

Convert to a ControlSpec

method::asTuning

Convert to a Tuning

method::asScale

Convert to a Scale

subsection::Environments

Symbols are used as keys to look up objects in dictionaries and environments, but also in arrays.
See link::Classes/IdentityDictionary::, link::Classes/Environment::, link::Classes/Event::

code::
a = ();
a.put(\commune, 1871);
a.at(\commune);
::

method::envirPut

put a value to the current environment using receiver as key

method::envirGet

return a value from the current environment using receiver as key
discussion::
code::
\foo.envirPut(100);
\foo.envirGet;
\foo.envirPut(nil);
::

subsection::Math

Symbols respond to all unary and binary math operations by returning themselves. The result of any math operation between a Number or other math object and a Symbol is to return the Symbol. This allows for example operations on lists of notes which contain 'rest's to preserve the rests.

code::Pseq([1, 3, \rest, 2, 4] + 8);::

method::applyTo

Use the symbol as a method selector and perform the message on firstArg, with args as arguments. This is used for mixing functions with method selectors (see also: Function).
discussion::
code::
'%'.applyTo(2553, 345);
['+', '-', '*', { |a, b| a.rand + b.rand } ].choose.applyTo(2, 3);
::


subsection::Synthesis

Inside SynthDefs and UGen functions, symbols can be used to conveniently specify control inputs of different rates and with lags (see:  NamedControl, ControlName, and Control).


method::kr

Return a control rate NamedControl input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.
A link::Classes/ControlSpec:: provided to the code::spec:: parameter will be written into the spec metadata for the current synth.

discussion::
code::
a = { SinOsc.ar(\freq.kr(440, 1.2)) }.play;
a.set(\freq, 330);
a.release;
a = { SinOsc.ar(\freq.kr([440, 460], 1.2)) }.play;
a.setn(\freq, [330, 367]);
a.release;
::

method::ar

Return an audio rate NamedControl input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.

method::ir

Return an initialization rate NamedControl input with a default value (val). If val is an array, the control will be multichannel.

method::tr

Return a TrigControl input with a default value (val). If val is an array, the control will be multichannel.
discussion::
code::
a = { Ringz.ar(T2A.ar(\trig.tr), \freq.kr(500, 1), 0.8) }.play;
a.set(\freq, 330, \trig, 1);
a.set(\freq, 830, \trig, 1);
a.release;
::



CLASS::SymbolArray
summary::an array whose indexed slots are all of the same type
related::Classes/Int8Array, Classes/Int16Array, Classes/Int32Array, Classes/FloatArray, Classes/DoubleArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream


class:: SyncSaw
summary:: Hard sync sawtooth wave.
related:: Classes/Saw, Classes/VarSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

A sawtooth wave that is hard synched to a fundamental pitch. This
produces an effect similar to  moving formants or pulse width modulation.
The sawtooth oscillator has its phase reset when the sync oscillator
completes a cycle. This is not a band limited waveform, so it may alias.


classmethods::

method::ar, kr

argument::syncFreq

Frequency of the fundamental.


argument::sawFreq

Frequency of the synched sawtooth wave. Should always be
greater than
code::syncFreq:: .


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ SyncSaw.ar(100, Line.kr(100, 800, 12), 0.1) }.play;


(
plot { [
	SyncSaw.ar(800, 1200),
	Impulse.ar(800) // to show sync rate
] }
)

(
plot { [
	SyncSaw.ar(800, Line.kr(800, 1600, 0.01)), // modulate saw freq
	Impulse.ar(800) // to show sync rate
] }
)

// scoping the saw: hit 's' when focused on the scope window to compare the channels
(
scope {
	var freq = 400;
	[
	SyncSaw.ar(freq, freq * MouseX.kr(1, 3)), // modulate saw freq
	Impulse.ar(freq) // to show sync rate
] * 0.3 }
)

::



class:: Synth
summary:: Client-side representation of a synth node on the server
categories:: Server>Nodes, Server>Abstractions
related:: Classes/Node, Classes/SynthDef

description::

A Synth is the client-side representation of a synth node on the server. A Synth represents a single sound producing unit.  What it does is defined in a link::Classes/SynthDef::, which specifies what link::Classes/UGen::s are used and how they are patched together.
It also specifies what inputs and outputs the Synth will have. A SynthDef is thus a kind of fixed pattern, upon which Synths are be based. (Despite this, a given SynthDef can provide a surprising amount of variation.) For more detail on SynthDefs, their construction, and how to send them to a server, see the link::Classes/SynthDef:: help file.

For more on the important distinction between client objects and server nodes, see link::Guides/ClientVsServer::. For information on creating nodes without using objects, see link::Guides/NodeMessaging::.

subsection:: Order of Execution
Order of execution is a crucial issue when creating Synths which interact with each other.
code::
	sound ->  filter
::
If a sound is to be passed through a filter, the synth that does the filtering must be later in the order of execution than the synth which is its input.  The computer must calculate a buffer's worth of sound, and then the computer moves on to calculate a buffer's worth of the filtered version of that sound.

The actual interconnection between synth nodes is accomplished with buses. See link::Classes/Bus:: and link::Reference/Server-Architecture:: for details.

See the link::Guides/Order-of-execution:: help file for a more detailed discussion of this important topic.

subsection:: Bundling

Some of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

classmethods::
Synth is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file.

private:: stop, play, sampleRate

subsection:: Creation with Immediate Instantiation on the Server
method:: new
Create and return a new Synth object, and immediately start the corresponding synth node on the server.

argument:: defName
A String or Symbol specifying the name of the SynthDef to use in creating the Synth.

argument:: args
An optional link::Classes/Array:: specifying initial values for the link::Classes/SynthDef::'s arguments (controls). These are specified in pairs of control name or index and value. If names are used they can be specified with either link::Classes/String::s or link::Classes/Symbol::s. e.g. code:: [\frequency, 440, \amplitude, 1, ...] ::.
Values that are arrays are sent using OSC array type-tags ($[ and $]).  These values will be assigned to subsequent controls.

argument:: target
A target for this Synth. If target is not a link::Classes/Group:: or Synth, it will be converted as follows: If it is a link::Classes/Server::, it will be converted to the link::Reference/default_group:: of that server. If it is nil, to the default_group of the default Server. If it is an integer, it is created relative to a group with that id.

argument:: addAction
one of the following Symbols:
definitionlist::
## \addToHead || (the default) add at the head of the group specified by target
## \addToTail || add at the tail of the group specified by target
## \addAfter || add immediately after target in its server's node order
## \addBefore || add immediately before target in its server's node order
## \addReplace || replace target and take its place in its server's node order
::
Note: A Synth is not a valid target for \addToHead and \addToTail.

discussion::
code::
s.boot;
// create a Synth at the head of the default Server's default group
// based on the SynthDef "default"
x = Synth.new("default");
s.queryAllNodes; // note the default group (ID 1)
x.free;

// Using an arrayed control
// run this block first to make the SynthDef
(
SynthDef("help-synth", {| freq = #[440, 450, 460], out = 0 |
	Out.ar(out, Mix(SinOsc.ar(freq, 0, 0.1)));
}).add;
)

// then this a short while later
x = Synth("help-synth", [freq: [500,501,510] ]);

x = Synth("help-synth", [freq: [500,501,510] ]);
x.set(\freq, [1,2,3] * 400 + [1,2,3], \out, 1);
x.set(\freq, [3] * 400 + [1,2,3], \out, 1);
x.free;
::

method:: newPaused
As code::new:: above, but creates a node which is paused. This can be started by calling code::run:: on it.
code::
s.boot;
x = Synth.newPaused("default");
s.queryAllNodes; // see I'm here
x.run; // true is the default
x.run(false); // pause me again
x.free;
::

method:: grain
A convenience method which will create a synth node with an node ID of -1. Such a node cannot be messaged after creation. As such this method does not create an object, and returns nil. For details of its arguments see code::new:: above.
returns:: nil

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions of code::Synth.new:: :

method:: after
Create and return a Synth and add it immediately after aNode.

method:: before
Create and return a Synth and add it immediately before aNode.

method:: head
Create and return a Synth. If code::aGroup:: is a link::Classes/Group:: add it at the head of that group. If it is a link::Classes/Server::, add it at the head of the link::Reference/default_group:: of that server. If it is nil, add it at the head of the default_group of the default server. If it is an integer, it is created relative to a group with that id.

method:: tail
Create and return a Synth. If code::aGroup:: is a link::Classes/Group:: add it at the tail of that group. If it is a link::Classes/Server::, add it at the tail of the link::Reference/default_group:: of that server. If it is nil, add it at the tail of the default_group of the default server. If it is an integer, it is created relative to a group with that id.

method:: replace
Create and return a Synth and use it to replace code::nodeToReplace::, taking its place in its server's node order.

subsection:: Creation without Instantiation on the Server

For use in message bundles it is also possible to create a Synth object in the client app without immediately creating a synth node on the server. Once done one can call methods which create messages to add to a bundle, which when sent to the server will instantiate the synth.

method:: basicNew
Create and return a Synth object without creating a synth node on the server.
argument:: defName
A String or Symbol specifying the name of the SynthDef to use in creating the Synth.
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.
discussion::
code::
s.boot;
x = Synth.basicNew("default", s); // Create without sending
s.sendBundle(nil, x.newMsg;); // Now send a message; create at the head of s' default group
s.queryAllNodes;
x.free;
::

After creation, use instance methods code::newMsg, addToHeadMsg, addToTailMsg, addBeforeMsg, addAfterMsg, addReplaceMsg:: to instantiate this synth on the server. See link::#instancemethods#Instance Methods:: below.



instancemethods::
Synth is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file.

private:: prepareForProxySynthDef, play

method:: defName
Returns:: the name of this Synth's SynthDef.

subsection:: Creation without Instantiation on the Server
Use class method code::basicNew:: to create a Synth without instantiating it on the server. Then use the following instance methods:
method:: newMsg
See *new above for details of addActions and args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If target is nil, it will default to the default_group of the Server specified in *basicNew when this Synth was created. The default addAction is \addToHead.

method:: addToHeadMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If aGroup is a Group it will be added at the head of that group. If it is nil, it will be added at the head of the default_group of this Synth's server (as specified when *basicNew was called).

method:: addToTailMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If aGroup is a Group it will be added at the tail of that group. If it is nil, it will be added at the tail of the default_group of this Synth's server (as specified when *basicNew was called).

method:: addBeforeMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, immediately before aNode.

method:: addAfterMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, immediately after aNode.

method:: addReplaceMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, replacing nodeToReplace in the server's node order.

subsection:: Control
For further methods of controlling Synths (set, map, etc.), see the link::Classes/Node:: helpfile.

method:: get, getMsg
Query the server for the current value of a link::Classes/Control:: (argument).
argument:: index
a control name or index
argument:: action
a Function which will be evaluated with the value passed as an argument when the reply is received.
discussion::
code::
s.boot;
(
SynthDef("help-Synth-get", { | out, freq = 440|
	Out.ar(out, SinOsc.ar(freq, 0, 0.1));
}).add;
)
x = Synth("help-Synth-get");
x.set(\freq, 220 + 440.rand);
x.get(\freq, { arg value; ("freq is now:" + value + "Hz").postln; });
x.free;
::

method:: getn, getnMsg
Query the server for the current values of a sequential range of link::Classes/Control::s (arguments).
argument:: index
a control name or index
argument:: count
the number of sequential controls to query, starting at index.
argument:: action
a Function which will be evaluated with an link::Classes/Array:: containing the values passed as an argument when the reply is received.

method:: set
Set the values of one or more link::Classes/Control::s.
discussion::
Example:
code::
x.set(\freq, 440, \amp, 0.5)
::

method:: seti
Set part of an arrayed control.
argument:: ... args
A sequence of strong:: name, index, value :: triplets.

definitionlist::
## name || The name of the arrayed control
## index || The index into the array
## value || The new value to set, can be an array to set a range of elements.
::

discussion::
note::
The synthdef has to be .add'ed, so that it is stored in the link::Classes/SynthDescLib::.
::
Example:
code::
(
s.waitForBoot({
    SynthDef(\helpSeti, { |out, freqs = #[100,150,200,250]|
        Out.ar(out, SinOsc.ar(freqs.poll,0,0.1).sum ! 2)
    }).add;
    s.sync;
    x = Synth(\helpSeti);
})
)
x.seti(\freqs,2,600); // set only the third element
x.seti(\freqs,1,[400,410]); // set second and third element
x.free;
::

Examples::
code::
s.boot;
(
// send a synth def to server
SynthDef("tpulse", { arg out = 0,freq = 700, sawFreq = 440.0;
	Out.ar(out, SyncSaw.ar(freq, sawFreq, 0.1));
}).add;
)

// Here the defaults for *new will result in a Synth at the head of the default group
// of the default Server. This will use the SynthDef's default arguments;
y = Synth.new("tpulse");
y.free;

// The same done explicitly
y = Synth.new("tpulse", nil, s, \addToHead);
y.free;

// With some arguments
y = Synth.new("tpulse", [\freq, 350, \sawFreq, 220]);
y.free;

// make a new synth
y = Synth("tpulse");

// pause
y.run(false);

y.run(true);

// set a control by argument name
y.set("freq", 200);

// or by index
y.set(2, 100.0);

// modulate out to bus number 1 (the right speaker)
y.set(0, 1);

//  multiple set commands in one message
y.set("out", 0, "freq",300);

// free the synth from the server
y.free;
::

subsection:: Filtering
code::
(
// first collect some things to play with
SynthDef("moto-rev", { arg out=0;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
		100, 0.1).clip2(0.4);
	Out.ar(out, x);
}).add;

SynthDef("bubbles", { arg out=0;
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps;
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(out, zout);
}).add;


SynthDef("rlpf",{ arg out=0,ffreq=600,rq=0.1;
	ReplaceOut.ar( out, RLPF.ar( In.ar(out), ffreq,rq) )
}).add;


SynthDef("wah", { arg out, rate = 1.5, cfreq = 1400, mfreq = 1200, rq=0.1;
	var zin, zout;

	zin = In.ar(out, 2);
	cfreq = Lag3.kr(cfreq, 0.1);
	mfreq = Lag3.kr(mfreq, 0.1);
	rq   = Ramp.kr(rq, 0.1);
	zout = RLPF.ar(zin, LFNoise1.kr(rate, mfreq, cfreq), rq, 10).distort
					* 0.15;

	// replace the incoming bus with the effected version
	ReplaceOut.ar( out , zout );

}).add;

SynthDef("modulate",{ arg out = 0, freq = 1, center = 440, plusMinus = 110;
	Out.kr(out, SinOsc.kr(freq, 0, plusMinus, center));
}).add;
)

// execute these one at a time

// y is playing on bus 0
y = Synth("moto-rev",["out",0]);

// z is reading from bus 0 and replacing that; It must be *after* y
z = Synth.after(y,"wah",["out",0]);

// stop the wah-ing
z.run(false);

// resume the wah-ing
z.run(true);

// add a rlpf after that, reading and writing to the same buss
x = Synth.after(z,"rlpf",["out",0]);

// create another rlpf after x
t = Synth.after(x,"rlpf",["out",0]);

x.set("ffreq", 400);

x.set(\ffreq, 800); // Symbols work for control names too

// Now let's modulate x's ffreq arg
// First get a control Bus
b = Bus.control(s, 1);

// now the modulator, *before* x
m = Synth.before(x, "modulate", [\out, b]);

// now map x's ffreq to b
x.map("ffreq", b);

m.set("freq", 4, "plusMinus", 20);

x.free;
z.free;
m.free;

// now place another synth after y, on the same bus
// they both write to the buss, adding their outputs
r = Synth.after(y,"bubbles",["out",0]);

y.free;

r.free;

// look at the Server window
// still see 4 Ugens and 1 synth?
// you can't hear me, but don't forget to free me
t.free;
::



class:: SynthDef
summary:: Client-side representation of a synth definition
categories:: Server>Abstractions
related:: Classes/Synth, Reference/Synth-Definition-File-Format, Classes/SynthDesc

description::

The server application uses synth definitions as templates for creating link::Classes/Synth:: nodes.
(Methods such as link::Classes/Function#-play::, etc. are simply conveniences which automatically create such a def.)
The SynthDef class encapsulates the client-side representation of a given def, and provides methods for creating new defs, writing them to disk, and streaming them to a server.

SynthDef is one of the more complicated classes in SC and an exhaustive explanation of it is beyond the scope of this document. As such, the examples at the bottom of this document and those found in the various tutorials accessible from link::Help:: may be necessary to make some aspects of its use clear.

Some insights about common SynthDef issues can be found on the FAQ link::Guides/UserFAQ#SynthDef Issues#SynthDef Issues::

subsection:: UGen Graph Functions and Special Argument Forms

The core of a def is its link::Classes/UGen##unit generator:: graph function.
This is an instance of link::Classes/Function:: which details how the def's unit generators are interconnected, its inputs and outputs, and what parameters are available for external control.
In a synth based on the def, arguments to the function will become instances of link::Classes/Control::.
These can have default values, or can be set at the time the synth is created.
After creation they will be controllable through link::Classes/Node::'s code::set:: and code::setn:: methods, or the n_set and n_setn link::Guides/NodeMessaging##OSC:: messages.

There are four special types of arguments, which are treated differently:
definitionlist::
## audio rate
|| Arguments that begin with "a_" (e.g. code::a_input::), or that are specified as code::\ar:: in the def's rates argument (see below), will be able to read an audio rate bus when mapped to it with code::/n_mapa::.
## initial rate
|| Arguments that begin with "i_" (e.g. code::i_freq::), or that are specified as code::\ir:: in the def's rates argument (see below), will be static and non-modulatable. They will not respond to code::/n_set:: or code::/n_map::. This is slightly more efficient in terms of CPU than a regular arg.
## trigger rate
|| Arguments that begin with "t_" (e.g. code::t_trig::), or that are specified as code::\tr:: in the def's rates argument (see below), will be made as a link::Classes/TrigControl::. Setting the argument will create a control-rate impulse at the set value. This is useful for triggers.
## literal arrays
|| Arguments which have literal arrays as default values (see link::Reference/Literals::) result in multichannel controls, which can be set as a group with link::Classes/Node#-setn:: or code::/n_setn::.
::

See the examples below for more detail on how this works.

Certain argument names (such as 'out' to specify an out bus) are in such common use that adopting them might be said to constitute 'good style'.
One of these, 'gate' when used to control the gate input of an link::Classes/EnvGen::, deserves special mention, as it allows one to use Node's release method. See link::Classes/Node:: for an example and more detail.

subsection:: Arrayed controls

In some cases, it is useful to send a group of values to a single control name, for instance, code::aSynth.set(\freqs, [300, 400, 500])::, or for passing envelopes at Synth instantiation. This requires an emphasis::arrayed control:: to be defined in the SynthDef.

There are two ways to define arrayed controls:

numberedlist::
## link::Classes/NamedControl:: -- recommended for flexibility and clarity.
## Literal arrays (as noted above).
::

NamedControl can accept default values determined in code. For example, passing an envelope requires four values per breakpoint. It is easy to create a template for the arrayed control by writing code::NamedControl.kr(\env, Env.newClear(numSegments: 8).asArray)::.

Literal arrays may be more convenient for very small arrays where all of the default values are known in advance.

In general, it is likely to be simpler in most cases to use NamedControl for arrayed controls.

See the example under link::#Array Arguments::.

subsection:: Static versus Dynamic Elements

It is important to understand that although a single def can provide a great deal of flexibility through its arguments, etc., it is nevertheless a static entity.
A def's link::Classes/UGen:: graph function (and the SC code within it) is evaluated only when the def is created.
Thus statements like while, do, collect etc. will have no further effect at the time the def is used to create a Synth, and it is important to understand that a UGen graph function should not be designed in the same way as functions in the language, where multiple evaluations can yield different results. It will be evaluated once and only once.
note:: code::if:: is implemented as a linear signal crossfade when the receiver is an UGen ::

There are other ways of achieving similar results, however, often using UGens such as Rand. For example, the following def will have a single randomly generated frequency, which will be the same for every Synth based on it:
code::
(
SynthDef(\help_notRand, { |out|
	Out.ar(out,
		SinOsc.ar(rrand(400, 800), 0, 0.2) * Line.kr(1, 0, 1, doneAction: Done.freeSelf)
	)
}).add;
)
a = Synth(\help_notRand);
b = Synth(\help_notRand); // the same freq as a
::
This one on the other hand will have a different random freq for each Synth created:
code::
(
SynthDef(\help_isRand, { |out|
	Out.ar(out,
		SinOsc.ar(Rand(400, 800), 0, 0.2) * Line.kr(1, 0, 1, doneAction: Done.freeSelf)
	)
}).add;
)
a = Synth(\help_isRand);
b = Synth(\help_isRand); // a different randomly selected freq
::


ClassMethods::
private:: initClass, prNew

method:: new
Create a SynthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.
argument:: name
A link::Classes/String:: or link::Classes/Symbol:: (i.e. "name" or \name). This name will be used to refer to the SynthDef when creating a Synth based upon it, and should be unique.
argument:: ugenGraphFunc
An instance of Function specifying how the def's UGens are interconnected. See the discussion above for information on how the Function's arguments are specified.
argument:: rates
An optional Array of specifications for the ugenGraphFunc's arguments. The order corresponds to the order of arguments. See the examples below to see how these are used.

A specification can be:
definitionlist::
## nil/zero || A standard control rate link::Classes/Control:: is created.
## \ar || An audio rate link::Classes/AudioControl:: is created.
## a float || the Control will have a lag of the specified time. This can be used to create
smooth transitions between different values. t_ and i_ args cannot be lagged.
## \ir || The Control can be set only at creation ('initial rate'). See discussion above.
## \tr || The Control is used as a trigger. See discussion above.
::

argument:: prependArgs
An optional link::Classes/Array:: of objects which will be passed as the first arguments to the ugenGraphFunc when it is evaluated. Arguments which receive values in this way will not be converted to instances of link::Classes/Control::. See the code::wrap:: example below for an example of how this can be used.

argument:: variants
An optional link::Classes/Event:: containing default argument settings. These can override the defaults specified in the ugenGraphFunc. When creating a Synth a variant can be requested by appending the defName argument in the form  'name.variant' or "name.variant". See example below.

argument:: metadata
An optional link::Classes/Event:: containing additional, user-defined information that is relevant to the use of the SynthDef in the client. The SynthDef itself is sent to the server for audio rendering; metadata are strictly client-side descriptive information. Currently the 'specs' key in the event is reserved for link::Classes/ControlSpec::s to be associated with SynthDef arguments (this is useful for automatic GUI construction). Metadata can be persisted to disk and loaded automatically as part of a SynthDesc. See the link::Classes/SynthDesc:: help file for more details.


method:: wrap
Wraps a function within an enclosing synthdef.
discussion::
Arguments to the wrapped function are automatically promoted to be SynthDef controls, using the same rules applied to arguments of the main UGen function. For a very simple example:
code::
d = SynthDef(\demoWrapping, { |out|
	Out.ar(out, SynthDef.wrap({ |freq| SinOsc.ar(freq) }))
});

d.allControlNames;
::
Prints: code:: [ ControlName  P 0 out control 0, ControlName  P 1 freq control 0 ] ::.

The outer function declares the argument 'out', and the wrapped function has 'freq' as its argument. The resulting SynthDef has both arguments as controls, exactly as if the outer function included both as arguments.

The rates array behaves as described earlier. code::PrependArgs:: allows values or unit generators to be passed into the inner function from the enclosing SynthDef context. Any inner function argument that receives a prependArg value (including nil) will use that value, suppressing creation of a control for that argument. The longer example below demonstrates this technique.

This is very useful for mass-producing SynthDefs that have a common "shell" defining features such as enveloping or triggering mechanisms that apply to different subgraphs of unit generators. The common features need be written only once; the UGens that differ between the SynthDefs are plugged into the supporting architecture.

method:: synthDefDir
Get or set the default directory to which defs are written.

method:: removeAt
Remove the synthdef code::name:: from the SynthDescLib named code::libname:: and from its servers.

method:: writeOnce
Create a new SynthDef. It is written to disk only if a def file with this name does not already exist. Note that this will not check for differences, so you will need to delete the defFile to get it to rebuild. Default for dir is to use the path specified by code::SynthDef.synthDefDir::.

warning:: code::SynthDef.writeOnce:: is a legacy method. Its main use was to improve the efficiency of SynthDefs in quarks, but this is superseded by link::Classes/SynthDescLib::. Being completely impervious to changes, it can cause difficult-to-diagnose bugs (such as having version 1.1 of a quark but with a SynthDef stuck in version 1.0). Quark developers should now use link::#-add:: instead.

The exception is very large SynthDefs, where you have a choice between link::#-writeDefFile:: and this method. Even then, the efficiency savings of code::writeOnce:: are only in disk I/O -- both methods build the SynthDef every time they run. ::


method::warnAboutLargeSynthDefs
When a SynthDef is too large to be sent to a local server in a standard OSC message, it is written to disk and the server loads it from there instead. If code::warnAboutLargeSynthDefs:: is set to true, it will warn that this is happening. There will always be a warning for remote servers.

InstanceMethods::

method:: add
Adds the synthdef to the link::Classes/SynthDescLib:: specified by libname, and sends it to the library's servers. No defFile is written; all operations take place in memory.

discussion::
After using this method, the synthdef can be used with event streams as in code::store()::, but without the permanent artifact of a file on disk. Calling this method triggers an update message with the key code::\synthDescAdded:: for any dependants the library may have. This can be used to trigger additional behaviour every time a def/desc is added. See link::Classes/Object#Dependancy::.

A server can be added by code:: SynthDescLib.global.addServer(server) ::.

Note that the "dir" and "mdPlugin" arguments do not exist for this method. Because no file is written, there is no need to specify a directory or write a metadata file.

code::
(
SynthDef(\help_synth, { |out, freq = 800, sustain = 1, amp = 0.1|
	Out.ar(out,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(amp, 0, sustain, doneAction: Done.freeSelf)
	)
}).add;
)
::

method:: name
Return this def's name.

method:: func
Return this def's ugenGraphFunc.

method:: variants
Return an Event containing this def's variants.

method:: allControlNames
An array of link::Classes/ControlName::'s for the controls.

method:: specs
A link::Classes/Dictionary:: of link::Classes/ControlSpec::s for a SynthDef. Equivalent to: code::d.metadata[\specs]::

subsection:: Special purpose methods
(for most purposes, the method add is recommended)

method:: writeDefFile
Writes the def as a file called name.scsyndef in a form readable by a server. Default for dir is synthdefs/. Defs stored in the default directory will be automatically loaded by the local and internal Servers when they are booted.

method:: load
Write the defFile and send a message to server to load this file. When this asynchronous command is completed, the completionMessage (a valid OSC message) is immediately executed by the server. Default for dir is synthdefs/.

method:: send
Compile the def and send it to server without writing to disk (thus avoiding that annoying SynthDef buildup). When this asynchronous command is completed, the completionMessage (a valid OSC message) is immediately executed by the server.

method:: store
Write the defFile and store it in the SynthDescLib specified by libname, and send a message to the library's server to load this file. When this asynchronous command is completed, the completionMessage (a valid OSC  message) is immediately executed by the server. Default for libname is \global, for dir is synthdefs/. This is needed to use defs with the event stream system. See Streams and Pattern.
argument:: libname
name of the link::Classes/SynthDescLib::
argument:: dir
argument:: completionMsg
argument:: mdPlugin
(optional) The metadata plug-in class that will be used to persist metadata. If not supplied, the default plug-in is used. See the SynthDesc help file for details.


method:: play
A convenience method which compiles the def and sends it to target's server. When this asynchronous command is completed, it creates one synth from this definition, using the argument values specified in the Array args.  For a list of valid addActions see link::Classes/Synth::. The default is code::\addToHead::.
Returns:: a corresponding Synth object.




Examples::

subsection:: Basic
code::
// Note that constructions like SynthDef(...) and Synth(...) are short for SynthDef.new(...), etc.
// With SynthDef it is common to chain this with calls on the resulting instance,
// e.g. SynthDef(...).add or SynthDef(...).play

// make a simple def and send it to the server

s.boot;
SynthDef(\SimpleSine, {|freq = 440, out| Out.ar(out, SinOsc.ar(freq, 0, 0.2)) }).add;

// the above is essentially the same as the following:
d = SynthDef(\SimpleSine, {|freq = 440, out| Out.ar(out, SinOsc.ar(freq, 0, 0.2)) });
d.add;

// now make a synth from it, using the default value for freq, then another with a different value
x = Synth(\SimpleSine);
y = Synth(\SimpleSine, [\freq, 660]);

// now change the freq value for x
x.set(\freq, 880);

x.free; y.free;

// using the play convenience method
x = SynthDef(\SimpleSine, {|freq = 440, out| Out.ar(out, SinOsc.ar(freq, 0, 0.2)) }).play
x.free;
::

subsection:: Argument Rates
code::
(
SynthDef(\trigTest1, { |out, t_trig=0, freq=440| // t_trig creates a TrigControl
	Out.ar(out, SinOsc.ar(freq+[0,1], 0, Decay2.kr(t_trig, 0.005, 1.0)));
}, [0, 0, 4]		// lag the freq by 4 seconds (the second arg), but not t_trig (won't work anyway)
).add;
)

y = Synth(\trigTest1);
y.set(\t_trig, 1); // you can do this multiple times
y.set(\t_trig, 1, \freq, 220); // hear how the freq lags
y.free;

// Pbind with the default \note event type, and Pmono, use an automatically-generated
// function to look up argument values. This function translates \trig in the
// event to \t_trig in the synth.
(
Pmono(\trigTest1, *[
	trig: Prand([0, 1], inf),  // for random trigger, use trig, not t_trig
	freq: Pwhite(lo: 220, hi: 440, length: 10),
	dur: 1
]).play;
)

// Note that With event type \set, there is no automatic translation so you
// should use t_trig in that case.
y = Synth(\trigTest1);
(
Pbind(*[
	type: \set,
	id: y.nodeID,
  args: #[\t_trig],
	t_trig: Prand([0, 1], 8)
]).play;
)
y.free;

// This second version makes trig a \tr arg by specifying it in the rates array.
(
SynthDef(\trigTest2, { |out, trig=0, freq=440|
	Out.ar(out, SinOsc.ar(freq+[0,1], 0, Decay2.kr(trig, 0.005, 1.0)));
	}, [0, \tr, 4]		// lag the freq (lagtime: 4s), \tr creates a TrigControl for trig
).add;
)

// There is a different way of writing the same thing using NamedControls
(
SynthDef(\trigTest2, { |out|
	Out.ar(out, SinOsc.ar(\freq.kr(440, 4) + [0,1], 0, Decay2.kr(\trig.tr, 0.005, 1.0)));
}).add;
)

// Using the second version, create a synth
z = Synth(\trigTest2);

// Now trigger the decay envelope
z.set(\trig, 1); 				// you can do this multiple times
z.set(\trig, 1, \freq, 220); 	// hear how the freq lags
z.set(\trig, 1, \freq, 880);
z.free; //free the synth

// Use trig in Pbind and Pmono
(
Pmono(\trigTest2, *[
	trig: Prand([0, 1], inf),  // for random trigger, use trig, not t_trig
	freq: Pwhite(lo: 220, hi: 440, length: 10),
	dur: 1
]).play;
)
::

subsection:: Variants
code::
// create a def with some variants
(
SynthDef(\vartest, { |out, freq = 440, amp = 0.2, a = 0.01, r = 1|
	// the EnvGen with doneAction: Done.freeSelf frees the synth automatically when done
	Out.ar(out, SinOsc.ar(freq, 0, EnvGen.kr(Env.perc(a, r, amp), doneAction: Done.freeSelf)));
}, variants: (alpha: [a: 0.5, r: 0.5], beta: [a: 3, r: 0.01], gamma: [a: 0.01, r: 4])
).add;
)

// now make some synths. First using the arg defaults
Synth(\vartest);

// now the variant defaults
Synth('vartest.alpha');
Synth('vartest.beta');
Synth('vartest.gamma');

// override a variant
Synth('vartest.alpha', [\release, 3, \freq, 660]);
::

subsection:: Array Arguments
code::
// freqs is defined as an arrayed control. This makes a multichannel Control of the same size.
(
SynthDef(\arrayarg, { |out, amp = 0.1, gate = 1|
	var env, sines;
	var freqs = NamedControl.kr(\freqs, [300, 400, 500, 600]);
	env = Linen.kr(gate, 0.1, 1, 1, 2) * amp;
	sines = SinOsc.ar(freqs +.t [0,0.5]).cubed.sum; // A mix of 4 oscillators
	Out.ar(out, sines * env);
}, [0, 0.1, 0]).add;
)

x = Synth(\arrayarg);
x.setn(\freqs, [440, 441, 442, 443]);

// Values outside of the array bounds are ignored --
// 0 is dropped
x.setn(\freqs, [300, 400, 500, 600, 0]);

x.release;

// Mr. McCartney's more complex example
(
fork {
	z = Synth(\arrayarg);

	2.wait;
	10.do {
		z.setn(\freqs, {exprand(200,800.0)} ! 4);
		(2 ** (0..3).choose * 0.2).wait;
	};

	z.set(\amp, -40.dbamp);

	10.do {
		z.setn(\freqs, {exprand(200,800.0)} ! 4);
		(2 ** (0..3).choose * 0.2).wait;
	};
	2.wait;

	z.release;
};
)
::

subsection:: Wrapping Example: 'factory' production of effects defs
code::
// The makeEffect function below wraps a simpler function within itself and provides
// a crossfade into the effect (so you can add it without clicks), control over wet
// and dry mix, etc.
// Such functionality is useful for a variety of effects, and SynthDef-wrap
// lets you reuse the common code.
(
// the basic wrapper
~makeEffect = { |name, func, lags, numChannels = 2|

	SynthDef(name, { | i_bus = 0, gate = 1, wet = 1|
		var in, sound, env, lfo;
		in = In.ar(i_bus, numChannels);
		env = Linen.kr(gate, 2, 1, 2, 2); // fade in the effect

		// call the wrapped function. The in and env arguments are passed to the function
		// as the first two arguments (prependArgs).
		// Any other arguments of the wrapped function will be Controls.
		sound = SynthDef.wrap(func, lags, [in, env]);

		XOut.ar(i_bus, wet * env, sound);
	}, [0, 0, 0.1] ).add;

};
)

// now make a wah
(
~makeEffect.value(\wah, { |in, env, rate = 0.7, ffreq = 1200, depth = 0.8, rq = 0.1|
	// in and env come from the wrapper. The rest are controls
 	var lfo;
	lfo = LFNoise1.kr(rate, depth * ffreq, ffreq);
	RLPF.ar(in, lfo, rq, 10).distort * 0.15;
},
[0.1, 0.1, 0.1, 0.1],  // lags for rate ffreq, depth and rq
2	// numChannels
);
)

// now make a simple reverb
(
~makeEffect.value(\reverb, {|in, env|
	// in and env come from the wrapper.
	var input;
	input = in;
	16.do({ input = AllpassC.ar(input, 0.04, Rand(0.001,0.04), 3)});
	input
},
nil,  // no lags
2	// numChannels
);
)

// something to process
x = { { Decay2.ar(Dust2.ar(3), mul: PinkNoise.ar(0.2)) } ! 2}.play;

y = Synth.tail(s, \wah);
z = Synth.tail(s, \reverb, [\wet, 0.5]);

// we used an arg named gate, so Node-release can crossfade out the effects
y.release;

// setting gate to zero has the same result
z.set(\gate, 0);

x.free;
::

subsection:: common argument names: out and gate
code::
// arguments named 'out' and 'gate' are commonly used to specify an output bus and
// EnvGen gate respectively. Although not required, using them can help with consistency
// and interchangeability. 'gate' is particularly useful, as it allows for Node's release
// method.
(
SynthDef(\synthDefTest, {|out, gate=1, freq=440|
	// doneAction: Done.freeSelf frees the synth when EnvGen is done
	Out.ar(out, SinOsc.ar(freq) * EnvGen.kr(Env.asr(0.1, 0.3, 1.3), gate, doneAction: Done.freeSelf));
}).store; // use store for compatibility with pattern example below
)

x = Synth(\synthDefTest, [\out, 0]); // play out through hardware output bus 0 (see Out.help)
x.release; // releases and frees the synth (if doneAction is > 2; see EnvGen)

//equivalent:

x = Synth(\synthDefTest); // out defaults to zero, if no default arg is given.
x.set(\gate, 0);

// if value is negative, it overrides the release time, to -1 - gate
x = Synth(\synthDefTest);
x.set(\gate, -5); // 4 second release

//equivalent:
x = Synth(\synthDefTest);
x.release(4);

// if the out arg is used in a standard way, it can always be changed without knowing the synth def
x = Synth(\synthDefTest, [\out, 0]);
x.set(\out, 1); //play through channel 1
x.release;

// Another good example of this is with patterns, which can use gate to release notes
(
Pbind(
	\instrument, \synthDefTest,
	\freq, Pseq([500, 600, Prand([200, 456, 345],1)], inf),
	\legato, Pseq([1.5, 0.2], inf),
	\dur, 0.4,
	\out, Pseq([0, 1], inf)
).play;
)
::


subsection:: Inline ControlSpec definitions
Sometimes, it can be clearer to specify a link::Classes/ControlSpec:: for a parameter at the point of its usage in a SynthDef, rather than elsewhere.
Specs can be set either when contructing a link::Classes/NamedControl:: or as a property of a SynthDef argument.
code::
(
~def = SynthDef(\argumentExample, { |freq, amp|
	var sig;
	freq.spec = ControlSpec(20, 20000, \exp);
	amp.spec = ControlSpec(0, 1);
	sig = SinOsc.ar(freq, 0, amp);
	Out.ar(0, sig);
});
~def.specs.freq.postln;
~def.specs.amp.postln;
)

(
~def = SynthDef(\argumentExample, {
	var sig;
	sig = SinOsc.ar(
		\freq.kr(spec:ControlSpec(20, 20000)),
		0,
		\amp.kr(spec:ControlSpec(0, 1));
	);
	Out.ar(0, sig);
});
~def.specs.freq.postln;
~def.specs.amp.postln;
)
::


class:: SynthDesc
summary:: Description of a synth definition
categories:: Server>Nodes
related:: Classes/SynthDef, Classes/Synth

description::
Contains a description of a link::Classes/SynthDef::, including its name, control names and default values.
Information is also stored on its outputs and inputs and whether it has a gate control.

SynthDescs are needed by the event stream system, so when using link::Classes/Pbind::, the instruments' default parameters are derived from the SynthDesc.

subsection:: Creation
SynthDescs are created by link::Classes/SynthDescLib::, by reading a compiled synth def file.
code::
SynthDescLib.global.read("synthdefs/default.scsyndef");
SynthDescLib.global.synthDescs.at(\default)
SynthDescLib.global.at(\default) // shortcut, same as line above
::

code::aSynthDef.store:: and code::aSynthDef.add:: also create a synthDesc in the global library.
definitionlist::
## .store || saves a synthdef file on disk (like .load);
## .add || creates the synthDesc wholly in memory and sends the synthdef to registered servers.
::
code::
(
SynthDef("test", { arg out, freq, xFade;
	XOut.ar(out, xFade, SinOsc.ar(freq))
}).store
);
::

Browse the properties of SynthDescs:
code::
SynthDescLib.global.browse;
::

section:: SynthDescs and SynthDef metadata

Metadata associated with a link::Classes/SynthDef:: consists of an link::Classes/Event:: (a syntactically shorter form of an identity dictionary) containing information about the SynthDef that is useful to the client, and which cannot be inferred from the binary .scsyndef stream.

For example, by listing argument names and link::Classes/ControlSpec::s under the 'specs' key in the event, the client can use the specs to build a link::Classes/GUI:: allowing control over all the SynthDef's inputs, with sensible range mappings. (The "window" button in the SynthDescLib browser does exactly this -- any ControlSpecs listed in the metadata will be used for the corresponding synth input's slider.)

Currently only the 'specs' key is reserved. Other keys may be used as needed for specific applications. As the use of SynthDef metadata evolves, other keys may be standardized.

subsection:: Creation and access
Metadata are specified when creating a link::Classes/SynthDef::. If the SynthDef is .store'd (or .add'd) into a SynthDescLib, the metadata become part of the SynthDesc as well. Thereafter, the metadata can be accessed through SynthDescLib:
code::
SynthDescLib.global[\synthDefName].metadata
::

subsection:: Persistence and metadata plug-ins
Storing a SynthDef into the library with .store persists the SynthDef on disk. Metadata may also be persisted at the same time by using the appropriate metadata plug-in class. The plug-in is responsible for writing a separate metadata file into the synthdefs directory, and reading the file back at the same time that a SynthDesc is created for a .scsyndef file using SynthDesc.read or SynthDescLib.global.read.

The currently available plug-ins are:
definitionlist::
## AbstractMDPlugin || A dummy plug-in, which writes no metadata. , so that users who are not interested in metadata will not find extra files in the synthdefs directory.
## TextArchiveMDPlugin || Writes the metadata as a SuperCollider text archive -- metadata.writeArchive(path). This is the default. Metadata are written only if the SynthDef contains metadata.
::
Other plug-ins may be written at a later date, to support sharing metadata with applications in other languages using formats like JSON (JavaScript Object Notation) or XML.

You may specify a global default metadata plug-in as follows:
code::
SynthDesc.mdPlugin = ... plug-in class name ...;
::
Metadata are not written when using code::SynthDef().load(server)::. This is because SynthDesc exists to describe a SynthDef to the client, whereas SynthDef is really just an abstraction to create a link::Classes/UGen:: graph for the server. Metadata are also not written for code::SynthDef().add::, because in the normal case, nothing is persisted to disk. (If the SynthDef is very large and a disk file is required, then the metadata will persist along with the .scsyndef file.)

subsection:: Automatic population
You may write a function to populate entries into the metadata automatically, based on the SynthDesc object. This function executes when reading a SynthDesc from disk, when using .add, and before writing a metadata file (in .store).
code::
SynthDesc.populateMetadataFunc = { |synthdesc|
	... do work here ...
};
::

subsection:: Synchronization
Whenever a .scsyndef file is written, any existing metadata files will be deleted so that a new .scsyndef file will not exist on disk with out-of-date metadata.

subsection:: Reading
When reading a SynthDesc, metadata files will be checked and one will be read, regardless of format. (Even if the default SynthDesc.mdPlugin is different from the file format on disk, the disk file will be read using the appropriate plug-in anyway.)

There should be only one metadata file at a time. However, in the case of conflicts, the default SynthDesc.mdPlugin will be preferred. The file extension identifies the format.

subsection:: Metadata Examples
code::
s.boot;

d = SynthDef(\mdDemo, { |out, freq, cutoff, volume, gate = 1|
	var	sig = LPF.ar(Saw.ar(freq, volume), cutoff),
		env = EnvGen.kr(Env.adsr, gate, doneAction: Done.freeSelf);
	Out.ar(out, (sig * env) ! 2)
}).add;

SynthDescLib.global[\mdDemo].makeWindow;

// Note in the resulting window that Freq has a slider, but Cutoff and Volume do not.
// This is because there are no global specs for the argument names 'cutoff' and 'volume'.


// Same SynthDef, but adding metadata
// \freq and \amp exist in the global ControlSpec collection -- Spec.specs
// They are converted to real ControlSpecs using .asSpec

d = SynthDef(\mdDemo, { |out, freq, cutoff, volume, gate = 1|
	var	sig = LPF.ar(Saw.ar(freq, volume), cutoff),
		env = EnvGen.kr(Env.adsr, gate, doneAction: Done.freeSelf);
	Out.ar(out, (sig * env) ! 2)
}, metadata: (specs: (cutoff: \freq, volume: \amp))).add;

SynthDescLib.global[\mdDemo].makeWindow;

// Now cutoff has a slider for frequency and volume has amplitude scaling


// Store the SynthDef along with metadata
d.store(mdPlugin: TextArchiveMDPlugin);

"ls %mdDemo.*".format(SynthDef.synthDefDir.escapeChar($ )).unixCmd;

// In addition to .scsyndef, there's also .txarcmeta - "text archive metadata"

// Load a fresh SynthDesc from disk for it
// The SynthDesc.read interface is a bit weird - e will be a dictionary holding the SynthDesc
e = SynthDesc.read(SynthDef.synthDefDir ++ "mdDemo.scsyndef");

// Metadata have been successfully read from disk!
// You could even do the above after recompiling and the MD would be there
e[\mdDemo].metadata

e[\mdDemo].makeWindow;
::

classmethods::
private:: initClass

method:: read
Adds all synthDescs in a path to a dict. You should not use this method or *readFile to read SynthDescs into a SynthDescLib. Use link::Classes/SynthDescLib#read:: or link::Classes/SynthDescLib#readStream:: instead.

instancemethods::

method:: name
returns:: the name of the SynthDef

method:: controls
returns:: an array of instances of link::Classes/ControlName::, each of which
have the following fields: name, index, rate, defaultValue
discussion::
code::
SynthDescLib.global.at(\default).controlNames.postln;
::

method:: controlDict
An link::Classes/IdentityDictionary:: of the link::Classes/ControlName::'s, indexed by name.
This can be used for fast lookup of control index by name, for example to set a specific element of a multichannel control.

method:: controlNames
returns:: an array of Strings with the names of controls

method:: outputs
returns:: an array of link::Classes/IODesc:: that describes the available outputs.

method:: inputs
returns:: an array of link::Classes/IODesc:: that describes the available inputs.

copymethod:: SynthDef -specs

method:: hasGate
is true if the Synthdef has a gate input

method:: canFreeSynth
is true if the link::Classes/Synth:: can free itself (via some means, usually a doneAction)
discussion::
This can be used to decide if to remove a Synth directly via free-message.
code::
SynthDescLib.global.at(\default).canFreeSynth;
::

method:: outputData

Returns an array of events with information about any UGens that write to a bus (such as link::Classes/Out:: etc.). This includes the rate and number of channels of the UGen. If its first input is a control, also the corresponding control name is provided.

code::
a = SynthDef(\x, { |out, freq = 440| Out.ar(out, SinOsc.ar(freq)) }).add;
a.desc.outputData;
a = SynthDef(\x, { |out, freq = 440| Out.ar(out + 7, SinOsc.ar(freq)) }).add; // no controlName in this case
a.desc.outputData;
::

method:: msgFunc
the function which is used to create an array of arguments for
playing a synth def in patterns
discussion::
code::
SynthDescLib.global.synthDescs.at(\default).msgFunc.postcs;
::



class:: SynthDescLib
summary:: SynthDesc library
categories:: Server>Nodes
related:: Classes/SynthDesc

description::
See link::Classes/SynthDesc::

INSTANCEMETHODS::

method:: add
Add a SynthDesc to this SynthDescLib. Doing this triggers an update message with the key code::\synthDescAdded:: for any dependants this lib may have. See link::Classes/Object#Dependancy::.
ARGUMENT:: synthdesc 
The link::Classes/SynthDesc:: to be added.


CLASS::SystemClock
categories::Scheduling>Clocks
summary:: Clock running on separate accurately timed thread
related::Classes/AppClock, Classes/TempoClock

DESCRIPTION::

SystemClock is more accurate than AppClock, but cannot call GUI primitives.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

private::prClear

method::sched
The float you return specifies the delta to resched the function for. Returning nil will stop the task from being rescheduled.
code::
(
SystemClock.sched(0.0,{ arg time;
	time.postln;
	rrand(0.1,0.9);
});
)
::
code::
(
SystemClock.sched(2.0,{
	"2.0 seconds later".postln;
	nil;
});
)
::

method::clear
Clear the SystemClock's scheduler to stop it.
code::
SystemClock.clear;
::

method::schedAbs
code::
(
SystemClock.schedAbs( (thisThread.seconds + 4.0).round(1.0),{ arg time;
	("the time is exactly " ++ time.asString
		++ " seconds since starting SuperCollider").postln;
});
)
::

method::play
Calls to the GUI may not be made directly from actions triggered by SystemClock or incoming socket messages (OSCFunc).

To get around this, use code::{ }.defer ::. This will execute the function using the AppClock and is equivalent to code::AppClock.sched(0, function)::

code::
(
var w, r;
w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;
r = Routine({ arg time;
	60.do({ arg i;
		0.05.yield;
		{
			w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
			w.alpha = cos(i*0.1pi)*0.5+0.5;
		}.defer;
	});
	1.yield;
	w.close;
});
SystemClock.play(r);
)
::
This example is only to show how to make calls to Cocoa/GUI when scheduling with the SystemClock. If you only wish to control the GUI, use AppClock.


class:: T2A
summary:: Control rate trigger to audio rate trigger converter
categories:: UGens>Conversion, UGens>Triggers
related:: Classes/T2K, Classes/K2A, Classes/A2K

description::
Converts control rate trigger into audio rate trigger (maximally one per control period).

classmethods::
method:: ar

argument:: in
input signal.
argument:: offset
sample offset within control period.

examples::
code::
// example
(
{
	var trig = Impulse.kr(MouseX.kr(1, 100, 1));
	Ringz.ar(T2A.ar(trig), 800, 0.01) * 0.4
}.play;
)

// compare with K2A
(
{
	var trig = Impulse.kr(200);
	[T2A.ar(trig), K2A.ar(trig)].lag(0.001)
}.plot(10/200);
)

// removing jitter by randomising offset
(
{
	var trig = Impulse.kr(MouseX.kr(1, 100, 1));
	Ringz.ar(T2A.ar(trig, WhiteNoise.kr.range(0, s.options.blockSize - 1)), 800, 0.01) * 0.4
}.play;
)
::


class:: T2K
summary:: Audio rate trigger to control rate trigger converter
categories:: UGens>Conversion, UGens>Triggers
related:: Classes/T2A, Classes/K2A, Classes/A2K

description::
Converts audio rate trigger into control rate trigger, using the maximum trigger in the input during each control period.

classmethods::
method:: kr

argument:: in
input signal.

examples::
code::
// this does not work:
(
{
	var trig = Dust.ar(4);
	Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
}.play;
)

// this works:
(
{
	var trig = T2K.kr(Dust.ar(4));
	Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
}.play;
)
::


class:: TBall
summary:: physical model of bouncing object
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/Ball, Classes/Spring

description::
models the impacts of a bouncing object that is reflected by a vibrating surface

classmethods::

method:: ar, kr

argument::in
modulated surface level

argument::g
gravity

argument::damp
damping on impact

argument::friction
proximity from which on attraction to surface starts

examples::
code::
// mouse x controls switch of level
// mouse y controls gravity
(
{
	var t, sf;
	sf = K2A.ar(MouseX.kr > 0.5) > 0;
	t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01);
	Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1));
}.play;
)


// mouse x controls step noise modulation rate
// mouse y controls gravity
(
{
	var t, sf, g;
	sf = LFNoise0.ar(MouseX.kr(0.5, 100, 1));
	g = MouseY.kr(0.01, 10, 1);
	t = TBall.ar(sf, g, 0.01, 0.002);
	Ringz.ar(t * 4, [600, 645], 0.3);
}.play;
)

// mouse x controls sine modulation rate
// mouse y controls friction
// gravity changes slowly
(
{
	var f, g, h, fr;
	fr = MouseX.kr(1, 1000, 1);
	h = MouseY.kr(0.0001, 0.001, 1);
	g = LFNoise1.kr(0.1, 3, 5);
	f = TBall.ar(SinOsc.ar(fr), g, 0.1, h);
	Pan2.ar(Ringz.ar(f, 1400, 0.04),0,5)
}.play;
)

// sine frequency rate is modulated with a slow sine
// mouse y controls friction
// mouse x controls gravity
(
{
	var f, g, h, fr;
	fr = LinExp.kr(SinOsc.kr(0.1), -1, 1, 1, 600);
	h = MouseY.kr(0.0001, 0.001, 1);
	g = MouseX.kr(1, 10);
	f = TBall.ar(SinOsc.ar(fr), g, 0.1, h);
	Pan2.ar(Ringz.ar(f, 1400, 0.04),0,5)
}.play;
)

// this is no mbira: vibrations of a bank of resonators that are
// triggered by some bouncing things that bounce one on each resonator

// mouse y controls friction
// mouse x controls gravity
(
	{
	var sc, g, d, z, lfo, rate;
	g = MouseX.kr(0.01, 100, 1);
	d = MouseY.kr(0.00001, 0.2);
	sc = #[451, 495.5, 595, 676, 734.5]; //azande harp tuning by B. Guinahui
	lfo = LFNoise1.kr(1, 0.005, 1);
	rate = 2.4;
	rate = rate * sc.size.reciprocal;
	z = sc.collect { |u,i|
		var f, in;
		in = Decay.ar(
				Mix(Impulse.ar(rate, [1.0, LFNoise0.kr(rate / 12)].rand, 0.1)), 					0.001
			);
		in = Ringz.ar(in,
					Array.fill(4, { |i| (i+1) + 0.1.rand2 }) / 2
					* Decay.ar(in,0.02,rand(0.5,1), lfo)						* u,
					Array.exprand(4, 0.2, 1).sort
					);
		in = Mix(in);
		f = TBall.ar(in * 10, g, d, 0.001);

		in + Mix(Ringz.ar(f, u * Array.fill(4, { |i| (i+1) + 0.3.rand2 }) * 2, 0.1))
	};
	Splay.ar(z) * 0.8
	}.play;
)
::



class:: TChoose
summary:: Randomly select one of several inputs
categories:: UGens>Triggers, UGens>Random
related:: Classes/TWChoose

description::
An output is selected randomly on receiving a trigger from an array of inputs.

TChoose returns a combination of link::Classes/Select:: and link::Classes/TIRand::.

classmethods::
method:: ar, kr

argument:: trig
argument:: array

examples::
code::
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	TChoose.ar(Dust.ar(MouseX.kr(1, 1000, 1)), a) * 0.2

}.play;
)
::

note:: all the ugens are continuously running. This may not be the most efficient way if each input is  cpu-expensive.::


class:: TDelay
summary:: Trigger delay.
categories::  UGens>Triggers, UGens>Delays


Description::

Delays a trigger by a given time. Any triggers which arrive in the time
between an input trigger and its delayed output, are ignored.


classmethods::

method::ar, kr

argument::in

Input trigger signal.


argument::dur

Delay time in seconds.


Examples::

code::

(
{
	z = Impulse.ar(2);
	[z * 0.1, ToggleFF.ar(TDelay.ar(z, 0.5)) * SinOsc.ar(mul: 0.1)]
}.scope)

::


class:: TDuty
summary:: Demand results as trigger from demand rate UGens.
related:: Classes/Demand, Classes/Duty
categories::  UGens>Demand


Description::

A value is demanded each UGen in the list and output as a trigger
according to a stream of duration values. The unit generators in the list
should be 'demand' rate.


When there is a trigger at the reset input, the demand rate UGens in the
list and the duration are reset. The reset input may also be a demand
UGen, providing a stream of reset times.


classmethods::

method::ar, kr

argument::dur

Time values. Can be a demand UGen or any signal. The next trigger
value is acquired after duration.


argument::reset

Trigger or reset time values. Resets the list of UGens and the
duration UGen when triggered. The reset input may also be a
demand UGen, providing a stream of reset times.


argument::level

Demand UGen providing the output values.


argument::doneAction

A doneAction that is evaluated when the duration stream ends. See

link::Classes/Done::  for more detail.


argument::gapFirst
when 0 (default), the UGen does the first level poll immediately and then waits for the first durational value. When this is 1, the UGen initially polls the first durational value, waits for that duration, and then polls the first level (along with polling the next durational value).

Examples::

code::

// examples

s.boot;


// play a little rhythm

{ TDuty.ar(Dseq([0.1, 0.2, 0.4, 0.3], inf)) }.play; // demand ugen as durations



// amplitude changes
(
	{
		var trig;
		trig = TDuty.ar(
				Dseq([0.1, 0.2, 0.4, 0.3], inf), // demand ugen as durations
				0,
				Dseq([0.1, 0.4, 0.01, 0.5, 1.0], inf) // demand ugen as amplitude
			);
		Ringz.ar(trig, 1000, 0.1)

	}.play;
)

(
	{
		var trig;
		trig = TDuty.ar(
				MouseX.kr(0.001, 2, 1), // control rate ugen as durations
				0,
				Dseq([0.1, 0.4, 0.01, 0.5, 1.0], inf)
			);
		Ringz.ar(trig, 1000, 0.1)

	}.play;
)




// demand ugen as audio oscillator

(
	{
		var a, trig, n=5, m=64;
		a = {
			var x;
			x = { 0.2.rand2 } ! m;
			x = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);
			Dseq(x.scramble, inf)
		} ! n;
		trig = TDuty.ar(
				MouseX.kr(1, 2048, 1) * SampleDur.ir * [1, 1.02],
				0,
				Dswitch1(a, MouseY.kr(0, n-1))
			);
		Ringz.ar(trig, 1000, 0.01)

	}.play;
)


// single impulses

(
SynthDef("delta_demand", { arg amp=0.5, out;
	OffsetOut.ar(out,
		TDuty.ar(Dseq([0]), 0, amp, 2)
	)
}).add;
)

fork { 10.do { s.sendBundle(0.2, ["/s_new", "delta_demand", -1]); 1.0.rand.wait } };


// chain of impulses
(
SynthDef("delta_demand2", {
	OffsetOut.ar(0,
		TDuty.ar(Dgeom(0.05, 0.9, 20), 0, 0.5, 2)
	)
}).add;
)

fork { 10.do { s.sendBundle(0.2, ["/s_new", "delta_demand2", -1]); 1.0.rand.wait } };



// multichannel expansion

(
	{
		var t;
		t = TDuty.ar(
				Drand([Dgeom(0.1, 0.8, 20), 1, 2], inf) ! 2,
				0,
				[Drand({ 1.0.rand } ! 8, inf), Dseq({ 1.0.rand } ! 8, inf)] * 2
			);
		x = Ringz.ar(t, [400, 700], 0.1) * 0.1;

	}.play;
)

::



class:: TExpRand
summary:: Triggered exponential random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TIRand, Classes/TRand
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random float value in exponential distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values
code::lo::  and  code::hi::  must both have
the same sign and be non-zero.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TExpRand.kr(300.0, 3000.0, trig)
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TExpRand.ar(300.0, 3000.0, trig)
		) * 0.1
}.play;
)

::



class:: TGrains
summary:: Buffer granulator.
categories::  UGens>Buffer, UGens>Generators>Granular
related:: Classes/GrainBuf

Description::
Triggers generate grains from a buffer. Each grain has a Hanning envelope
code::
(sin2(x) for x from 0 to π)
::
and can be panned over multichannel output.

classmethods::

method::ar

argument::numChannels
The number of output channels.

argument::trigger
At each trigger, the following arguments are sampled and used as
the arguments of a new grain. A trigger occurs when a signal
changes from non-positive to a positive value.

If the trigger is audio rate then the grains will start with
sample accuracy.

argument::bufnum
The index of the buffer to use. It must be a one channel (mono)
buffer.

argument::rate
1.0 is normal, 2.0 is one octave up, 0.5 is one octave down -1.0
is backward normal rate… etc.

argument::centerPos
The position in the buffer in seconds at which the grain envelope
will reach maximum amplitude.

argument::dur
Duration of the grain in seconds.

argument::pan
determines where to pan the output.
list::
## If numChannels = 1, the pan argument is ignored.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, panning is the same as PanAz.
::

argument::amp
Amplitude of the grain.

argument::interp
1, 2, or 4. Determines whether the grain uses (1) no
interpolation, (2) linear interpolation, or (4) cubic
interpolation.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var trate, dur, rate;
	trate = MouseY.kr(2,200,1);
	dur = 4 / trate;
	rate = Dseq([10, 1, 1, 0.5, 0.5, 0.2, 0.1], inf);
	TGrains.ar(2, Impulse.ar(trate), b, rate, MouseX.kr(0,BufDur.kr(b)), dur, Dseq([-1, 1], inf), 0.1, 2);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

// 4 channels
(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1);
}.scope(4, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 4 / trate;
	clk = Dust.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120);
	dur = 12 / trate;
	clk = Impulse.ar(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = 12;
	dur = MouseY.kr(0.2,24,1) / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = 100;
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = Integrator.kr(BrownNoise.kr(0.001));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(1,400,1);
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.8);
	TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur;
	trate = MouseY.kr(2,120,1);
	dur = 1.2 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1);
}.scope(zoom: 4);
)

// demand ugens as inputs
(
{
	var trate, dur, z, d;
	trate = MouseX.kr(1, 100, 1);
	d = { Dwhite(0.1, 0.2, 1) };
	z = {
		Drand([Dgeom(0.1, 1 + d.value, Diwhite(20, 40)), Dgeom(1, 1 - d.value, Diwhite(20, 40))])
	};
	TGrains.ar(2,
		Impulse.ar(trate),
		bufnum: 10,
		rate: Dseq([1, 1, z.value, 0.5, 0.5, 0.2, 0.1, 0.1, 0.1, 0.1], inf) * 2 + 1,
		centerPos: Dseq(z.dup(8), inf),
		dur: Dseq([1, d.value, 1, z.value, 0.5, 0.5, 0.1, z.value] * 2, inf) / trate,
		pan: Dseq([1, 1, 1, 0.5, 0.2, 0.1, 0, 0, 0], inf) * 2 - 1,
		amp: Dseq([1, 0, z.value, 0, 2, 1.0, 1, 0.1, 0.1], inf)
	);
}.scope(zoom: 4);
)

b.free

::


class:: TIRand
summary:: Triggered integer random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TRand, Classes/TChoose
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random integer value in uniform distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::

(
SynthDef("help-TIRand", {
	var trig, outBus;
	trig = Dust.kr(10);
	outBus = TIRand.kr(0, 1, trig); //play on random channel between 0 and 1
	Out.ar(outBus, PinkNoise.ar(0.2))

}).play;
)

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TIRand.kr(4, 12, trig) * 100
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TIRand.ar(4, 12, trig) * 100
		) * 0.1
}.play;
)

::



class:: TRand
summary:: Triggered random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random float value in uniform distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TRand.kr(300, 3000, trig)
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TRand.ar(300, 3000, trig)
		) * 0.1
}.play;
)

::



class:: TWChoose
summary:: Randomly select one of several inputs
categories:: UGens>Triggers, UGens>Random
related:: Classes/TChoose

description::
An output is selected randomly on receiving a trigger from an array of inputs.

the code::weights:: of this choice are determined from the weights array.

If code::normalize:: is set to 1 the weights are continuously normalized (this is an extra overhead) when using fixed values the code::normalizeSum:: method can be used to normalize the values.

TWChoose is a composite of link::Classes/TWindex:: and link::Classes/Select::.

classmethods::
method:: ar, kr

argument:: trig
argument:: array
argument:: weights
argument:: normalize

examples::
code::
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	TWChoose.ar(Dust.ar(MouseX.kr(1, 1000, 1)), a, [0.99, 0.05, 0.05].normalizeSum) * 0.2

}.play;
)
::

note:: all the ugens are continuously running. This may not be the most efficient way if each input is  cpu-expensive.::


class:: TWindex
summary:: Triggered windex.
categories:: UGens>Random, UGens>Triggers


Description::

When triggered, returns a random index value based on array as a list of
probabilities. By default the list of probabilities should sum to 1.0,
when the normalize flag is set to 1, the values get normalized
by the UGen (less efficient).


classmethods::

method::ar, kr

argument::in

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::array
The list of probabilities. (Note: These should be control rate only.)

argument::normalize
Controls whether to normalize the probability values. (Control rate only.)

Examples::

code::

//assuming normalized values
(
a = SynthDef("help-TWindex", { |out, w1=0.0, w2=0.5, w3=0.5|
	var trig = Impulse.kr(6);
	var index = TWindex.kr(trig, [w1, w2, w3]);
	Out.ar(out,
		SinOsc.ar(
			Select.kr(index,[400, 500, 600]),
			0, 0.2
		)
	)
}).play;
)

a.setn(0, [0,0,1].normalizeSum);
a.setn(0, [1,1,1].normalizeSum);
a.setn(0, [1,0,1].normalizeSum);


//modulating probability values
(

a = SynthDef("help-TWindex", { |out, w1=0.0, w2=0.5|
	var trig = Impulse.kr(6);
	var index = TWindex.kr(
		trig,
		[w1, w2, SinOsc.kr(0.3, 0, 0.5, 0.5)],//modulate probability
		1 //do normalisation
	);

	Out.ar(out,
		SinOsc.ar(
			Select.kr(index,[400, 500, 600]),
			0, 0.2
		)
	)
}).play;

)

a.setn(0, [0,0]);
a.setn(0, [1,1]);
a.setn(0, [1,0]);
a.setn(0, [0,1]);

::


class:: TabFileReader
summary:: file reader for tab separated data
related:: Classes/File
categories:: Files

description::
TabFileReader reads tab/return delimited files into 2D arrays.

For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For comma-separated files use link::Classes/CSVFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
(
// write a test file:
f = File("TabDelTest.sc", "w");
f.write(
"Some	tab-	delimited	items	in	line	1

and	then	some	more	in	line	3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = TabFileReader.read("TabDelTest.sc").postcs;

	// can skip empty lines:
x = TabFileReader.read("TabDelTest.sc", true).postcs;

	// do file open/close by hand if you prefer:
f = File("TabDelTest.sc", "r"); f.isOpen;
t = TabFileReader(f);
t.read;
f.close;

(
// write a test file with numbers:
f = File("TabDelTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ Char.tab); };
f.close;
)

x = TabFileReader.read("TabDelTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or you can do it immediately:
x = TabFileReader.readInterpret("TabDelTestNum.sc").postcs;

(
// write a test file with numbers:
f = File("TabDelTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, Char.tab, Char.nl)); };
f.close;
)


x = TabFileReader.readInterpret("TabDelTestNum.sc").postln;
::


class:: Tap
summary:: Single tap into a delay line
related:: Classes/MultiTap, Classes/PlayBuf
categories::  UGens>Buffer, UGens>Delays>Buffer

Description::

The Tap UGen allows a single tap at a delay into a buffer.

Tap uses the link::Classes/PlayBuf:: UGen internally

classmethods::
private:: categories

method::ar

argument::bufnum
The index of the buffer to use

argument::numChannels
Number of channels of the buffer

argument::delaytime
Tap delay; cannot be modulated

examples::
code::
// Create a buffer.
b = Buffer.alloc(s, s.sampleRate, 1); // enough space for one second of mono audio

// Write to the Buffer with BufWr, read using two Taps, one for each ear!
(
SynthDef(\helpTap, { |out, bufnum|
	var source, capture;

	source= SoundIn.ar(0); // use headphones to avoid feedback
	capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));

	Out.ar(out, Tap.ar(bufnum, 1, [0.1,0.9])); // multichannel expansion, so one tap each ear
}).add;
)

x = Synth(\helpTap, [\bufnum, b]);

x.free;
::



CLASS::Task
categories::Scheduling
summary::a pauseable process
related::Classes/Routine

DESCRIPTION::
Task is a pauseable process. It is implemented by wrapping a link::Classes/PauseStream:: around a link::Classes/Routine::. Most of its methods (start, stop, reset) are inherited from PauseStream.

The purpose of a Task is to separate a Routine's state of execution from its running state (that is, its state of being scheduled on a clock or not, or paused in a link::Classes/CondVar:: or not). Use Task if you expect the process to need to start, stop or resume multiple times while maintaining the execution flow. (This means that Tasks are not 100% interchangeable with Routines -- for many uses, Tasks should be preferred over Routines.)

Note that stopping a task and restarting it quickly may yield surprising results (see example below), but this is necessary to prevent tasks from becoming unstable if they are started and/or stopped in rapid succession. (Routines do allow a quick stop-reset-play cycle, but they have no mechanism to prevent timing from being broken in this case, i.e. Routine is more brittle here.) If you need to start and stop quickly while maintaining timing, a better approach would be to swap the child Routine over to a new instance of PauseStream.

CLASSMETHODS::

method::new
argument::func
A Function to be evaluated.
argument::clock
A Clock in which to play the link::Classes/Routine::. If you do not provide a Clock the default is an instance of link::Classes/TempoClock::. Remember that methods which call Cocoa primitives (i.e. GUI functions) must be played in link::Classes/AppClock::.

INSTANCEMETHODS::

method::play
argument::argClock
(optional) Override the clock assigned in Task.new.
argument::doReset
If true, the task will start over from the beginning. Default is false (task will resume where it was when it was last stopped).
argument::quant
See the link::Classes/Quant:: helpfile.


subsection::Other control methods

method::start
Restart the task from the beginning.

method::resume
Resume the task where it left off.

method::pause
Stop playing now.

method::stop
Stop playing now. (Pause and stop have the same implementation.)

method::reset
Set the stream to restart from the beginning the next time it's played.

method::reschedule

Switch the Task to a different clock, or a different time, without stopping. See link::Classes/Routine#-reschedule:: for complete documentation.

NOTE:: If you want to reschedule a Task from within the Task itself, code::thisThread.reschedule(...):: will not work, because code::thisThread:: refers to the Routine under control of the Task, not to the Task itself (whereas a Routine is playing on the clock directly). You must write code::thisThread.threadPlayer.reschedule(...):: instead.
::

subsection::Notifications

Other objects might need to be aware of changes in the state of a task. The following notifications are broadcast to dependents registered with the Task object.

list::
## strong::\userPlayed:: - Sent at the time the user calls play, start or resume.
## strong::\playing:: - Sent at the time the task begins playing on the clock (corresponding to quant).
## strong::\userStopped:: - Sent at the time the user calls pause or stop.
## strong::\stopped:: - Sent at the time the task is finally removed from the clock (this is the time when the next event would have occurred if the task had not been stopped). If the task function completes on its own, this notification is sent without 'userStopped' being sent previously.
::

EXAMPLES::

subsection::What happens if you stop and start the task too quickly?
code::
(
t = Task({
	50.do({ arg i;
		i.squared.postln;
		0.5.wait;
	});
});
)

t.start;
t.pause;
t.resume;
t.reset;
t.stop;

// unexpected behavior here
(
t = Task({
	["go", thisThread.clock.beats].postln;
	inf.do({ arg i;
		2.wait;
		[ "wake up", i ].postln;
	});
});

fork {
	t.start;
	0.1.wait;
	t.stop;
	0.1.wait;
	t.start;
	6.wait;
	t.stop;
};
)

[ go, 1702.114411906 ]
[ go, 1704.114411906 ]
::

Based on the forked thread, you would expect the second "go" line of output to occur 0.2 seconds after the first, but in fact it happens two seconds later (the same amount of time the task waits between iterations). This is because the task must not schedule itself on the clock more than once. When the task is stopped, it remains scheduled until it wakes up again (based on its wait time). If, during this interval, the task were restarted, there would be two references to the task in the scheduler queue -- a situation that is irrecoverable short of stopping everything with command-period.

For the above case, you can get completely stable timing by manually wrapping the Routine in a PauseStream. Note that code::start:: implicitly resets the routine to the beginning; using code::play:: instead only alters the timing, without interrupting the routine's flow.

code::
(
r = Routine({
	["go", thisThread.clock.beats].postln;
	inf.do({ arg i;
		2.wait;
		[ "wake up", i ].postln;
	});
});

fork {
	t = PauseStream(r);
	t.start;  // prints "go..."
	0.1.wait;
	t.stop;   // but stop before the loop prints
	0.1.wait;
	t = PauseStream(r);
	t.start;  // prints "go..."
	6.wait;   // loop is allowed to run 2 cycles
	t.stop;
};
)
::

class:: TaskProxy
summary:: event stream reference
categories:: JITLib>Patterns, Live Coding
related:: Classes/Tdef

description::
Keeps a reference to a task (time pattern) that can be replaced while playing. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

ClassMethods::

method::new
create a new instance with a function (the source). the source should be a strong::routine function:: (see link::Classes/Tdef::) or a strong::pattern:: of time values.

method::default
a default source, if none is given. the default is a loop that does nothing with a 1.0 beat wait time.

method::defaultQuant
set the default quantization value for the class. (default: 1.0). can be a pair [quant, offset]

InstanceMethods::

method::source
set the source. If a quantization is given, schedule this change to the next beat the object is a strong::routine function::, which is evaluated in a protected way, so that failure will notify the proxy that it has stopped. The object can also be a strong::pattern:: of time values.

method::clear
set the source to nil

method::clock
get or set the instance's default clock, used by link::#-play:: if no other clock is specified. Defaults to TempoClock.default.

method::quant
get or set the quantization value. can be a pair [quant, offset]

method::condition
provide a condition under which the pattern is switched when a new one is inserted. the stream value and a count is passed into the function. the methods strong::count_(n):: simply counts up to n and switches the pattern then

method::reset
switch the pattern immediately. (stuck conditions can be subverted by this)

method::envir
provide a default environment for the proxy. If given, it is used as an environment for the routine function. When set for the first time, the routine pattern is rebuilt.

method::set
set arguments in the environment. If there is none, it is created and the routine pattern is rebuilt.

method::endless
returns a link::Classes/Prout:: that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (1 s. wait time). This allows to create streams that idle on until a new pattern is inserted.

subsection::a) using it as stream reference

method::source
set the routine function / pattern (internally done by *new(key, obj)

method::embedInStream
just like any stream, embeds itself in stream

subsection::b) using it as EventStreamPlayer

method::play
starts the TaskProxy and creates a player. if you want to play multiple instances, use strong::.playOnce(clock, protoEvent, quant)::

argument::argClock
which clock to use. if nil then use this instance's link::#-clock::, which in turn defaults to TempoClock.default.

argument::doReset
A link::Classes/Boolean::

argument::quant
can be an array of [quant, phase]

method::stop
stops the player

method::player
the current player (if the TaskProxy is simply used in other streams this is nil)

method::pause, resume, reset
perform player method

method::isPlaying
returns true if TaskProxy is running. if a TaskProxy is playing and its stream ends, it will schedule a stream for playing as soon as a new one is assigned to it.

Examples::

subsection::a) using TaskProxy as a player

code::
// create an empty Tdef and play it.
x = TaskProxy.new;
x.play;


x.source = { loop { "ggggggggggggggggg9999ggg999ggg999gg".scramble.postln; 0.5.wait; } };


x.source = { loop { "---------////----------------------".scramble.postln; 0.25.wait; } };
x.source = { loop { thisThread.seconds.postln; 1.wait; } };
x.source = { loop { thisThread.seconds.postln; 1.01.wait; } };

TempoClock.default.tempo = 2;

x.source = { "the end".postln };
x.source = { "one more".postln };
x.source = { 10.do { "ten more".scramble.postln; 0.25.wait; } };
x.source = { loop { "many more".scramble.postln; 0.25.wait; } };

TempoClock.default.tempo = 1;

x.stop;
x.play;
x.stop;
::


code::
// sound example

(
// load a synthdef
s.boot;
SynthDef("pdef_grainlet",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)
x.play;

(
x.source = {
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, rrand(600, 640));
		0.1.wait;
	}
}
)

(
x.source = {
	var x;
	x = Pseries(300, 20, 100).loop.asStream;
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	}
}
)

(
x.source = {
	var x;
	x = Plazy { Pseries(300 + 300.rand, 10 + 30.rand, 10 + 30.rand) }.loop.asStream;
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	}
}
)

// metronome
(
y = TaskProxy {
	loop { s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, 1500); 1.wait; }
};
y.play;
)

// play ending stream once
(
x.source = {
	var x, dt;
	dt = [0.1, 0.125, 0.05].choose;
	x = Plazy { Pseries(1300 + 300.rand, 110 + 130.rand, 16) }.asStream;
	x.do { arg item;
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, item);
		dt.wait;
	}
}
)

... and so on ...

x.stop;
y.stop;
::

subsection::b) embedding TaskProxy into other Tasks / Routines

code::
(
#a, c = { TaskProxy.new } ! 2;
a.source = { "one".postln; 1.wait; "two".postln };
c.source = { var z; z = Synth(\default); 0.5.wait; z.release };
r = Task {
	"counting...".postln;
	2.wait;
	a.embedInStream;
	1.wait;
	c.embedInStream;
	"done.".postln;
};
)

r.play; // play a stream

c.source = { var z; z = Synth(\default, [\freq, 300]); 1.5.wait; z.release }; // change the def

r.reset;
r.play;

// of course TaskProxies can be used in other Tdefs:
(
b = TaskProxy.new;
b.source = {
	"counting...".postln;
	2.wait;
	a.embedInStream;
	1.wait;
	c.embedInStream;
	"done.".postln;
};
)
b.playOnce;

// if one wants to branch off a stream in a separate thread, asStream is used.
(
Routine {
	c.asStream.play;
	0.1.wait;
	c.asStream.play;
	0.1.wait;
	a.asStream.play;

}.play;
)
::


class:: TaskProxyGui
summary:: a superclass for Guis for PatternProxies
categories:: JITLib>GUI, Live Coding
related:: Classes/TdefGui, Classes/PdefGui

description::

Please see link::Classes/TdefGui:: and link::Classes/PdefGui:: for examples!


class:: Tdef
summary:: task reference definition
categories:: JITLib>Patterns
related:: Classes/TaskProxy, Classes/Task, Classes/Routine

description::
Tdef registers tasks by key. All accesses to the registered tasks go through the Tdef class via that key. Registered tasks can be replaced with other tasks while playing. The old task and its replacement can automatically crossfade and the replacement time can be quantized.

Tdef provides an interface to its superclass TaskProxy. Tdef keeps a reference to a task ( strong::time pattern:: ) that can be replaced while playing. It continues playing when the old stream ended and a new stream is set and schedules the changes to the beat. One Tdef may be used in many tasks in different places. A change in the task definition Tdef propagates through all tasks.

code::
Tdef(key)	//returns the instance
Tdef(key, func)	//defines the task and returns the instance, like Pdef and Ndef.
::

Graphical overview over all current Tdefs: link::Classes/TdefAllGui::. Overview: link::Overviews/JITLib::

subsection::First Example

code::
Tdef(\x, { loop { 0.5.wait; "aaaaaaaaaaaaaazz".scramble.postln } }).play;
Tdef(\x, { loop { 0.125.wait; "aazz".scramble.postln } });
Tdef(\x, { loop { 0.5.wait; (note: 14.rand).play } });
Tdef(\x, { loop { 0.5.wait; (note: 14.rand + [0, 3, 6, 7].keep(4.rand)).play } });
Tdef(\x).stop;
Tdef(\x).play;
Tdef(\x).clear;
::

ClassMethods::

method::all
A global link::Classes/IdentityDictionary:: with all proxies.


private::initClass

subsection::Creation

method::new
Store the task in a global dictionary under key, replacing its routine function with the new one.

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default task is created)

argument::key
An identifier for the proxy. Usually, it is a link::Classes/Symbol::. The key transparently accesses the global link::Classes/IdentityDictionary::.

argument::item
An object for (re)defining the source of the proxy. If code::nil::, the proxy is returned unmodified.

method::default
Default source, if none is given. The default task has a function that waits in 1.0 beat steps and does nothing.

method::removeAll
Remove all proxies from the global dictionary ( link::#*all:: )

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all instances.

method::defaultQuant
Set the default quantisation for new instances (default: 1.0). This can be an array [quant, phase, timingOffset, outset]

InstanceMethods::

subsection::Changing the definition / setting the source

One Tdef may have many tasks in different places. A change in the task definition Tdef propagates through all tasks. The change does not have to be immediate - there is a scheme to schedule when the change becomes effective: a strong::quant:: and strong::clock:: (like elsewhere) and a strong::condition::.

method::quant
Set the quantisation time for beat accurate scheduling.

method::clock
get or set the instance's default clock, used by link::#-play:: if no other clock is specified. Defaults to TempoClock.default.

argument::val
can be an array strong::[quant, phase, timingOffset, outset] ::, or just strong::[quant, phase]:: etc.

method::condition
Provide a condition under which the pattern is switched when a new one is inserted. The stream value and a count value is passed into the function.

method::count
Create and update condition that simply counts up to n and switches the pattern then

method::reset
Switch the task immediately (stuck conditions can be subverted by this).

method::envir
Set the environment (an link::Classes/Event::) for the Tdef. strong::It is passed as first argument into the Task function::.

method::set
Set arguments in the default event. If there is none, it is created and the task routine is rebuilt.

method::clear
Set the source to nil

method::endless
Returns a link::Classes/Prout:: that plays the task endlessly, replacing strong::nil:: with a strong::default:: value 1. This allows to create streams that idle on until a new pattern is inserted.

subsection::Tdef as stream reference

A single Tdef may serve as a definition for multiple tasks. These methods show how to fork off separate routines from one instance. Even if they run in different contexts, their definition may still be changed.

method::fork
Play an independent task in parallel.

argument::clock
the clock on which to play the forked task

argument::quant
can be an array of [quant, phase, offset], or a link::Classes/Quant:: value.

argument::event
an event to pass into the forked task

method::embed
Pass a value (typically an link::Classes/Event::) into the task function, and embed the Tdef in the stream.

method::embedInStream
just like any pattern, embeds itself in stream

subsection::Tdef as EventStreamPlayer

For live coding, each Tdef also may control one instance that plays one task. This is a link::Classes/PauseStream::, accessible in the instance variable link::#-player::.

method::play
Starts the Tdef and creates a player.

argument::argClock
a clock on which to play the Tdef. If nil, uses the instance's link::#-clock::, which in turn defaults to TempoClock.default.
argument::doReset
a flag whether to reset the task if already playing
argument::quant
can be an array of [quant, phase, offset] or a link::Classes/Quant:: value.

method::stop
Stops the player

method::player
Return the current player (if the Tdef is simply used in other streams this is nil)

method::pause, resume, reset
Perform this method on the player.

method::isPlaying
Returns true if player is running. If a Tdef is playing and its stream ends, it will schedule a stream for playing strong::as soon as a new one is assigned to it::. If it is stopped by strong::stop::, it won't.

Examples::

subsection::Tdef as a Task player

code::
Tdef(\x).play; // create an empty Tdef and play it.

Tdef(\x, { loop({ "ggggggggggggggggg9999ggg999ggg999gg".scramble.postln; 0.5.wait; }) });


Tdef(\x, { loop({ "---------////----------------------".scramble.postln; 0.25.wait; }) });
Tdef(\x, { loop({ thisThread.seconds.postln; 1.wait; }) });
Tdef(\x, { loop({ thisThread.seconds.postln; 1.01.wait; }) });

TempoClock.default.tempo = 2;

Tdef(\x, { "the end".postln });
Tdef(\x, { "one more".postln });
Tdef(\x, { 10.do({ "ten more".scramble.postln; 0.25.wait; }) });
Tdef(\x, { loop({ "lots more".scramble.postln; 0.25.wait; }) });

TempoClock.default.tempo = 1;

Tdef(\x).stop;
Tdef(\x).play;

Tdef(\x).clear;
::

code::
// sound example

(
// load a synthdef
s.boot;
SynthDef(\pdef_grainlet,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)
Tdef(\x).play;

(
Tdef(\x, {
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, rrand(600, 640));
		0.1.wait;
	})
})
)

(
Tdef(\x, {
	var x;
	x = Pseries(300, 20, 100).loop.asStream;
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	})
})
)

(
Tdef(\x, {
	var x;
	x = Plazy({ Pseries(300 + 300.rand, 10 + 30.rand, 10 + 30.rand) }).loop.asStream;
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	})
})
)

// metronome
Tdef(\y, { loop({ s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, 1500); 1.wait; }) }).play;

// play ending stream once
(
Tdef(\x, {
	var x, dt;
	dt = [0.1, 0.125, 0.05].choose;
	x = Plazy({ Pseries(1300 + 300.rand, 110 + 130.rand, 16) }).asStream;
	x.do({ arg item;
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, item);
		dt.wait;
	})
})
)

// ... and so on ...

Tdef(\x).stop;
Tdef.removeAll;
::

subsection::Embed and fork: Tdef within other Tasks / Routines

code::
// embed plays tdefs in sequence within a task.
(
Tdef(\a, { "one".postln; 1.wait; "two".postln });
Tdef(\c, { var z; z = Synth(\default); 0.5.wait; z.release });
r = Task({
	"counting...".postln;
	2.wait;
	Tdef(\a).embed;
	1.wait;
	Tdef(\c).embed;
	"done.".postln;
});
)

r.play; // play a stream

Tdef(\c, { var z; z = Synth(\default, [\freq, 300]); 1.5.wait; z.release }); // change the def

r.reset;
r.play;

// of course Tdefs can be used in other Tdefs:
(
Tdef(\a, { 10.do { |i| (" a: " + i).postln; 0.3.wait; } });
Tdef(\b, { 15.do { |i| ("\t\t b: " + i).postln; 0.2.wait; } });
Tdef(\c, { 5.do { |i| ("\t\t\t\t c: " + i).postln; 0.5.wait; } });

Tdef(\d, {
	"embed - sequence.".postln;
	1.wait;
	Tdef(\a).embed;
	1.wait;
	Tdef(\b).embed;
	1.wait;
	Tdef(\c).embed;

	"done.".postln;
});
)
Tdef(\d).play;

// to start a tdef in its own separate thread, thus branching into parallel threads,
// one can use .fork, or .playOnce
(
Tdef(\a, { 10.do { |i| (" a: " + i).postln; 0.3.wait; } });
Tdef(\b, { 15.do { |i| ("\t\t b: " + i).postln; 0.2.wait; } });
Tdef(\c, { 5.do { |i| ("\t\t\t\t c: " + i).postln; 0.5.wait; } });

Tdef(\d, {
	"fork - parallel.".postln;
	1.wait;
	Tdef(\a).fork;
	1.wait;
	Tdef(\b).fork;
	1.wait;
	Tdef(\c).fork;

	"done.".postln;
});
)
::

subsection::Tdef as a time pattern

Instead of using a link::Classes/Pdefn:: for time values, it can be useful to use a Tdef. When changing its source, it keeps the stream of values synchronized to its clock.

code::
(
// load a synthdef
s.boot;
SynthDef("pdef_grainlet",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction: Done.freeSelf);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)



Tdef(\z, Pseq([1, 1, 1, 0.5, 0.5], inf));

(
Pset(\instrument, \pdef_grainlet,
	Ppar([
		Pbind(
			\dur, Tdef(\z),
			\note, Pseq([1, 3, 2, 1, 0], inf),
			\x, Pfunc { TempoClock.default.elapsedBeats.postln } // posts the onset times
		),
		Pbind(
			\dur, 4, // reference beat
			\sustain, 0.1,
			\note, 8
		)
	])
).play(quant:1);
)


Tdef(\z, Prand([1, 1, 0.23, 0.5, 0.5], inf)); // exchange time pattern
Tdef(\z, Pseq([1, 1, 1, 1], inf)); // pattern stays in sync.
Tdef(\z, Pseq([1, 1, 1, 0.5, 0.5], inf)); // but might be in different order.
					// to avoid this, set quant to an appropriate value.
::


class:: TdefAllGui
summary:: see all Tdefs and their state
categories:: JITLib>GUI, Live Coding
related:: Classes/TdefGui, Classes/PdefGui, Classes/PdefAllGui

description::

TdefAllGui uses link::Classes/TdefGui:: views to display all Tdefs, or a selection.

Overview: link::Overviews/JITLib::

ClassMethods::

subsection::Creation

method::new

argument::numItems
the maximum number of Pdefs that can be shown.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
///// Not Done Yet, but on the list

A flag whether to make a skipjack.

argument::options
///// Not Done Yet, but on the list

the only option for PdefAllGui will be [\makeEdit]. adding a "front" PdefGui that also shows the front Pdef's envir.

Examples::

code::
(
Tdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
Tdef(\b, { |e| 100.do { |i| Tdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
t = TdefAllGui(8);
)

	// if you have too many Tdefs, an ezscroller lets you select
"abcdefghijk".do { |ch| Tdef(ch.asSymbol) };

	// you can also filter which ones you see:
Tdef(\a_otti);
Tdef(\a_hannerl);
Tdef(\a_dede);

	// or better from gui
t.filtering_(true);
t.prefix_("a_");

	// if prefix is "", it will filter anything with "_" in it.
t.prefix_("");
t.filtering_(false);
::


class:: TdefEditor
summary:: will be replaced - please use TdefGui now!
categories:: JITLib>GUI, Live Coding
related:: Classes/TdefGui

description::

warning::
has been rewritten and renamed link::Classes/TdefGui::, which has largely the same functionality, but is more consistent and more flexible. There are some changes to the *new method:

definitionList::
## instead of || *new(px, nVars, height, width, parent, makeWatcher)
## TdefGui uses || *new (object, numItems, parent, bounds, extras)
::

strong::px:: is now strong::object::, strong::nVars:: is now strong::numItems::, strong::width & height:: can be put as strong::bounds: height @ width ::, strong::parent:: is still strong::parent::, strong::makeWatcher:: is now strong::makeSkip:: .

Please see link::Classes/TdefGui:: for more details.
::


class:: TdefGui
summary:: a line of editing controls for a Tdef, and optionally its envir
categories:: JITLib>GUI, Live Coding
related:: Classes/TdefAllGui, Classes/PdefGui, Classes/PdefAllGui, Classes/EnvirGui

description::

A gui showing the link::Classes/Tdef::'s name, playing state, source state, and envir state. Optionally, its envir can also be edited.

subsection::First example

code::
g = TdefGui();			// make a TdefGui
g.object = Tdef(\a);		// show when a Tdef is put in
Tdef(\a, { "boing".postln }); 	// show whether it has a source
Tdef(\a).play; 			// show whether playing, stopped, or ended, and pausable
Tdef(\a).set(\abc, 123); 	// show whether the tdef has an envir

g = TdefGui(Tdef(\a), 3);	// with an envirgui for 3 items
Tdef(\a).set(\a, 12, \lofreq, [1, 10], \str, "someString", \oops, \oneSymbolTooMany);

(				// put it in an existing window - margin becomes 0@0
w = Window().front; w.addFlowLayout;
TdefGui(Tdef(\a), 0, w);
TdefGui(Tdef(\a), 3, w);
)
::

subsection::Details on the GUI elements

definitionList::
## name button
|| when selected, typing the delete key will delete its Tdef.
## play/stop button
|| indicates whether the tdef is playing:
table::
## " >" || if stopped,
## " _" || if playing and active,
## " |" || if it is playing, but the stream has ended.
::
## pause/resume button
|| only visible if one can pause or resume the Tdef, i.e. while it is playing.
table::
## "paus" || shown when you can pause it,
## "rsum" || shown when you can resume it.
::
## src button
|| opens a document to edit the source (function) of the Tdef.
table::
## green || a source exists,
## white || the source is nil.
::
## env button
|| strong::click:: opens a document to edit the envir of the Tdef, strong::option-click:: opens a new TdefGui with a big enough link::Classes/EnvirGui:: for the Tdef's envir.
table::
## green || the Tdef has an envir,
## white || the envir is nil.
::
::

ClassMethods::

subsection::Creation Methods

method::new
Create a new link::Classes/JITGui:: that will be watching an object and display its state.

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize

argument::makeSkip
A flag whether to make a skipjack. If one uses a TdefGui as part of a larger gui ensemble, one may want to call checkUpdate on all of them together, not with separate skipJacks.

argument::options
a list of additional information, e.g. flags about optional buttons. (this is used is some subclasses)

InstanceMethods::

method::object
a link::Classes/Tdef::, or nil

method::numItems
the number of items in the envirGui

method::parent
the parent view

method::bounds
the bounds of the link::#-zone::

method::zone
the link::Classes/CompositeView:: within which the TdfGui is shown


method::nameBut, playBut, pauseBut, srcBut, envBut
the buttons

method::envirGui
the gui for the Tdef's envir - if numItems > 0.

method::object
put an object in the gui.

method::moveTo
(if the jitGui is in its own window)

move it to some specific location.

method::clear
(if the jitGui is in its own window)

set the TdefGui's object to nil

method::close
(if the jitGui is in its own window)

and close its window.

subsection::Internal methods

method::srcString
a compileString that recreates the Tdef.

code::
// assume g from above is still there
g.srcString;
::

method::editString
a compileString that recreates the Tdef's envir at edKey.

method::editStrings
a compileString that recreates the Tdef's envir at edKeys.

argument::edKeys
Default value is nil.

code::
// assume g from above is still there
g.editString;
Tdef(\a).set(\foo, \bar);
g.editString(\foo);

g.editStrings;
::

method::getUsedKeys
the keys in use in the envir

code::
g.getUsedKeys;
::

method::openDoc
open a document with some strings at some location. used with src button, env button.

code::
g.openDoc(g.editStrings);
::

method::makeEnvirGui
make an envirGui within zone.

Examples::

code::
(
Tdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
t = TdefGui(Tdef(\a), 4);
Tdef(\a).set(\freq, 200, \dur, 0.1, \otto, 12, \ann, 1234);
)

Tdef(\a).stop;
Tdef(\a).play;
Tdef(\a).pause;
Tdef(\a).resume;

t.object_(nil);
t.object_(Tdef(\a));

(
w = Window("put it in a selfmade window").front;
w.addFlowLayout;
w.view.decorator.shift(50, 50);
TdefGui(Tdef(\a), 12, w)
)

Tdef(\b, { |e| 100.do { |i| Tdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
Tdef(\b).play;
TdefGui(Tdef(\b));

	// see all Tdefs:
TdefAllGui(16);
::


class:: TempoBusClock
summary:: a clock that synchronizes its tempo with the server
categories:: JITLib>NodeProxy, Live Coding
related:: Classes/TempoClock

ClassMethods::

method::new
return a new instance.

argument::control
can be anything that responds to the message code::set(key, val, ...):: e.g. a link::Classes/Synth:: or a link::Classes/NodeProxy::. The control key set is "tempo". otherwise TempoBusClock works just like a link::Classes/TempoClock::.
argument::tempo
see link::Classes/TempoClock::
argument::beats
see link::Classes/TempoClock::
argument::seconds
see link::Classes/TempoClock::


Examples::

code::
(
a = { |tempo=1| Ringz.ar(Impulse.ar(tempo), [501, 500], 1/tempo) }.play;
t = TempoBusClock(a);
Task { loop { "klink".postln; 1.wait } }.play(t);
);

t.tempo = 1.3;
t.tempo = 0.5;
t.tempo = 1.0;


// in ProxySpace, a TempoBusClock can be added together with a ~tempo NodeProxy:

p = ProxySpace.push(s);
p.makeTempoClock;
p.clock; // now the ProxySpace's clock is a TempoBusClock

~out.play;
~out = { Ringz.ar(Impulse.ar(~tempo.kr), [501, 500], 1/~tempo.kr) * 0.3 };
p.clock.tempo = 1.3;

// patterns and tasks are synchronized:

~out2.play;
~out2 = Pbind(\dur, 1, \note, Pwhite(0, 7, inf));

p.clock.tempo = 3;
p.clock.tempo = 1;
::


CLASS::TempoClock
categories::Scheduling>Clocks
summary::tempo based scheduler
related::Classes/AppClock, Classes/SystemClock

DESCRIPTION::

TempoClock is a scheduler like link::Classes/SystemClock::, but it schedules relative to a
strong::tempo:: in beats per second.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

private::initClass

method::new
Creates a new instance of TempoClock.

argument:: tempo
The initial link::#-tempo#tempo::. Defaults to code::1::.

argument:: beats
The time in beats, corresponding to the reference time given with the code::seconds:: argument.
Defaults to code::0::.

argument:: seconds
The reference time in seconds, to which the code::beats:: argument corresponds.
Defaults to the current Thread's logical time
(see link::Classes/Thread#-seconds::).

argument:: queueSize
The storage size of the scheduling queue. Each scheduled item takes 2 counts of space, so this size
divided by 2 gives the amount of items that can be scheduled at a time. See also link::#-queue::.

discussion::
The TempoClock will be created strong::as if:: it started counting beats at the time given in the
code::seconds:: argument with the starting amount given in the code::beats:: argument. The current
count of beats will thus be equal to that starting amount plus the amount of beats that would be
counted since the given reference time in seconds, according to the given tempo.

The default arguments create a TempoClock that starts counting beats with code::0:: at the current
logical time.

code::
// Create a TempoClock that starts counting beats with 5 now.
(
t = TempoClock.new(2, 5);
"current beats:" + t.beats;
)

// Create a TempoClock, as if it started counting beats 5 seconds ago with 0.
(
t = TempoClock.new(2, 0, thisThread.seconds - 5);
"current beats:" + t.beats;
)
::

method::default
Sets or gets the permanent default TempoClock instantiated at startup.
code::
TempoClock.default.beats // beats since default TempoClock was started
::

subsection:: Forwarding to the default instance

The following methods only forward to the link::#*default#default instance::, allowing you to use
the TempoClock class itself in place of code::TempoClock.default::.

method::stop
method::play
method::sched
method::schedAbs
method::clear
method::tempo
method::etempo
method:: beats
method:: beats2secs
method:: secs2beats
method:: nextTimeOnGrid
method:: timeToNextBeat
method:: setTempoAtBeat
method:: setTempoAtSec
method:: setMeterAtBeat
method:: beatsPerBar
method:: baseBarBeat
method:: baseBar
method:: playNextBar
method:: beatDur
method:: elapsedBeats
method:: beats2bars
method:: bars2beats
method:: bar
method:: nextBar
method:: beatInBar
method:: isRunning

INSTANCEMETHODS::

private::prDump, prStart, prStop, prClear

method::stop
Destroys the scheduler and releases the OS thread running the scheduler.

method::clear
Removes all tasks from the scheduling queue.

method::isRunning
returns:: A Boolean, true if the clock is active or false if the clock has been stopped.

method::tempo
Sets or gets the current tempo in beats per second at the current strong::logical time::.
code::
t= TempoClock.new;
t.tempo_(2.0); // equivalent to t.tempo = 2.0;
t.tempo;
t.tempo_(72/60) // 72 beats per minute
t.tempo;
::

method::etempo
Sets or gets the current tempo at the current strong::elapsed time::.

method::permanent
Sets or gets a link::Classes/Boolean:: value indicating whether the clock will survive cmd-period. If false the clock is stopped (and thus removed) on cmd-period. If true the clock survives cmd-period. It is false by default.

method::beats

Gets or sets the current logical time in beats according to this clock.

When strong::getting:: code::beats::, if this clock is the current Thread's
link::Classes/Thread#-clock#associated clock::, the Thread's own
link::Classes/Thread#-beats#time in beats:: is returned, otherwise the Thread's
link::Classes/Thread#-seconds#time in seconds:: converted to beats according to this
clock is returned.

After strong::changing:: code::beats:: towards the strong::future::, the clock will
immediately perform all tasks scheduled until the new time. Likewise, when changing
code::beats:: towards the strong::past::, already scheduled tasks will be postponed, so
they will still be performed at the scheduled time in beats.

note::
When changing code::beats::, you are only changing the clocks's notion of time, and not
the current Thread's link::Classes/Thread#-beats#logical time::, which will stay the
same until the Thread is called again. Hence, if this clock is the current Thread's
link::Classes/Thread#-clock#associated clock::, and you ask the clock for time in beats
just after changing it, you will see no effect. Nevertheless, the effect will be visible
immediately on a different Thread.
::

code::
(
t = TempoClock.new;

t.sched(3, {
    t.beats = 100;
    t.beats.postln; // still 3
    nil
});
)

(
c = TempoClock.new;
fork {
    loop {
		c.beats.postln; // updates, because ".wait" calls the thread
        1.wait;
    }
};
)

c.beats = 100;

::


method::schedAbs

Schedules a task to be performed at a particular time in strong::beats::.

When the scheduling time is up, the task's code::awake:: method is called. If the method
returns a number, the task will be rescheduled for the time equal to the last scheduling
time plus the returned value.

See also: link::Classes/Clock#Scheduling::, link::Classes/Object#-awake::.


method::sched

Schedules a task to be performed code::delta:: amount of strong::beats:: after the
current Thread's logical time. If this clock is the current Thread's
link::Classes/Thread#-clock#associated clock::, the Thread's
link::Classes/Thread#-beats#time in beats:: is used, otherwise the Thread's
link::Classes/Thread#-seconds#time in seconds:: is converted to beats according to this
clock's tempo and time of origin.

When the scheduling time is up, the task's code::awake:: method is called. If the method
returns a number, the task will be rescheduled for the time equal to the last scheduling
time plus the returned value.

See also: link::Classes/Clock#Scheduling::, link::Classes/Object#-awake::.


method::play

Plays task (a function) at the next beat, where strong::quant:: is 1 by default. Shortcut for link::#-schedAbs::; see link::#-seconds:: and link::#-nextTimeOnGrid:: for further details on time and quant.
code::
t= TempoClock.default;
t.play({arg beats, time, clock; [beats, time, clock].postln});
::

method::playNextBar
Plays task (a function) at the next bar using link::#-schedAbs::.

method::queue
Returns the scheduling queue Array in the form [beat, function]. The maximum number of items is determined by the clock's queueSize argument upon instantiation. The default queueSize of 256 allows 128 functions to be in the queue at any time.

method::beatDur
Returns the duration in seconds of a current whole beat.

method::beatsPerBar
Gets or sets the number of beats per bar. The default is 4. Setting the meter must be done from within the same clock's scheduling thread. Scheduled functions and playing Routines (or Tasks) are running on the clock's thread, so both of these are valid.

Setting beatsPerBar also updates the barline reference (baseBarBeat). Be careful to call code::beatsPerBar_:: emphasis::only:: on a barline (link::#-nextBar:: below).

code::thisThread.clock:: is always the current clock -- so, writing code::thisThread.clock.beatsPerBar = /* number */:: as a matter of habit will guarantee that the meter change only ever applies to the current clock.

code::
t = TempoClock.new;

t.beatsPerBar = 3;  // error! wrong thread

t.schedAbs(t.nextBar, { t.beatsPerBar_(3) });  // OK

t.beatsPerBar;  // will be reflected after the barline

t.schedAbs(t.nextBar, { thisThread.clock.beatsPerBar_(4) });  // OK

(
r = Routine {
	// by addressing "this" clock,
	// we are always changing meter in the right place
	var clock = thisThread.clock;
	
	clock.beats.debug("start time");
	clock.timeToNextBeat(-1).wait;
	clock.beats.debug("barline");

	// no need to 'sched'
	// because the Routine is already on this clock
	// flip 3/4 -> 4/4 or 4/4 -> 3/4
	clock.beatsPerBar = 7 - clock.beatsPerBar;
	clock.beatsPerBar.debug("set meter to");

	0.01.wait;  // must be after barline for 'timeToNextBeat'
	clock.timeToNextBeat(-1).wait;
	clock.beats.debug("next barline");
}.play;
)
::

method::bar
Returns the current bar. See link::#-bars2beats:: for returning beat of current bar.

method::nextBar
Returns the number of beats at the next bar line relative to the beat argument. If strong::beat:: is not supplied, returns the beat at which the next bar begins.

method::beatInBar
Returns the current bar beat (as a link::Classes/Float::) in relation to link::#-beatsPerBar::. Values range from 0 to < beatsPerBar.

method::baseBar
Returns bar at which link::#-beatsPerBar:: was last changed. If beatsPerBar has not been changed since the clock was created, returns 0.

method::baseBarBeat
Returns beat at which the link::#-beatsPerBar:: was last changed. If beatsPerBar has not been changed since the clock was created, returns 0.

method::beats2bars
Returns a bar as a float relative to link::#-baseBarBeat::.

method::bars2beats
Returns a beat relative to link::#-baseBar::.
code::
t= TempoClock.default;
t.bars2beats(t.bar) // downbeat of the current bar
::

method::timeToNextBeat
Returns the logical time to next beat. strong::quant:: is 1 by default, relative to baseBarBeat, see link::#-nextTimeOnGrid::.

method::nextTimeOnGrid
With default values, returns the next whole beat. strong::quant:: is 1 by default, strong::phase:: is 0. quant is relative to link::#-baseBarBeat::, such that
code::
t= TempoClock.default;
t.nextTimeOnGrid(t.beatsPerBar) == t.nextBar // => true
::
Together strong::quant:: and strong::phase:: are useful for finding the next n beat in a bar, e.g. code::nextTimeOnGrid(4, 2):: will return the next 3rd beat of a bar (of 4 beats), whereas code::nextBar-2:: may return an elapsed beat.

code::referenceBeat:: may be used to evaluate the quant and phase relative to an arbitrary beat. Normally, no reference beat will be specified (code::nil::) and the clock's current beats will be used.

method::elapsedBeats
Returns the current elapsed time in beats. This is equivalent to code::tempoClock.secs2beats(Main.elapsedTime)::. It is often preferable to use link::#-beats:: instead of elapsedBeats because beats uses a thread's logical time.

method::seconds
Returns the current elapsed time. (This method is inherited from link::Classes/Clock::.)

method::beats2secs
Converts absolute strong::beats:: to absolute strong::seconds::, returning the elapsed time of the clock at the given strong::beats::. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.
code::
t= TempoClock.default;
t.beats2secs(t.beats) // equivalent to t.seconds
t.beats2secs(0) // how many seconds after startup did beat 0 occur?
::

method::secs2beats
Converts absolute strong::seconds:: to absolute beats. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.

EXAMPLES::

code::
t = TempoClock(1); // create a TempoClock

// schedule an event at next whole beat
t.schedAbs(t.beats.ceil, { arg beat, sec; [beat, sec].postln; 1 });

t.tempo = 2;
t.tempo = 4;
t.tempo = 0.5;
t.tempo = 1;

t.clear;

t.schedAbs(t.beats.ceil, { arg beat, sec; [beat, sec].postln; 1 });

t.stop;
::
code::
(
// get elapsed time, round up to next second
v = Main.elapsedTime.ceil;

// create two clocks in a 5:2 relation, starting at time v.
t = TempoClock(1, 0, v);
u = TempoClock(0.4, 0, v);

// start two functions at beat zero in each clock.
t.schedAbs(0, { arg beat, sec; [\t, beat, sec].postln; 1 });
u.schedAbs(0, { arg beat, sec; [\u, beat, sec].postln; 1 });
)

(
u.tempo = u.tempo * 3;
t.tempo = t.tempo * 3;
)

(
u.tempo = u.tempo * 1/4;
t.tempo = t.tempo * 1/4;
)

(
t.stop;
u.stop;
)
::
code::
(
// get elapsed time, round up to next second
v = Main.elapsedTime.ceil;

// create two clocks, starting at time v.
t = TempoClock(1, 0, v);
u = TempoClock(1, 0, v);

// start two functions at beat zero in each clock.
// t controls u's tempo. They should stay in sync.
t.schedAbs(0, { arg beat, sec; u.tempo = t.tempo * [1,2,3,4,5].choose; [\t, beat, sec].postln; 1 });
u.schedAbs(0, { arg beat, sec; [\u, beat, sec].postln; 1 });
)

(
u.tempo = u.tempo * 3;
t.tempo = t.tempo * 3;
)

(
u.tempo = u.tempo * 1/4;
t.tempo = t.tempo * 1/4;
)

(
t.stop;
u.stop;
)
::


CLASS:: TextField
summary:: A view displaying editable text
categories:: GUI>Views

DESCRIPTION::
A view displaying editable text.


CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: string
	The text displayed in the view.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.

METHOD:: value
	Gets the same as link::#-string::, but when setting also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String:: regardless of the link::#-setBoth:: flag.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: valueAction
	Sets link::#-value:: and triggers link::#-action::.


SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed text. See link::Reference/gui_alignments:: for possible values.

METHOD:: font
	The font used to display the text.

	argument::
		A Font.

METHOD:: stringColor
	The color used to display the text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the inside of the field under the text with the given color.

	argument::
		A Color.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the text.


SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The displayed link::#-string::.

METHOD:: defaultCanReceiveDrag
	returns::
		Always true.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.


EXAMPLES::
code::
(
w = Window.new.front;
a = TextField(w, Rect(10, 10, 150, 20));
a.string = "hi there";
a.action = {arg field; field.value.postln; };
)

// does not do the action
a.value = "yo";
a.string = "oy";

a.valueAction_("this is not a pipe"); //does the action, if the value has changed
a.doAction; //evaluates the action with the content of the text field as an argument

a.background_(Color.grey);
a.stringColor_(Color.white);
a.align_(\center);
::



CLASS:: TextView
summary:: A view displaying editable formatted text
categories:: GUI>Views

DESCRIPTION::

TextView consists of an area where strong::multi-line text:: can be typed in and edited.

Using the view's methods, the text can be formatted: different strong::font:: and strong::text color:: can be applied to parts of the text. Text can also be inserted, removed, and selected programmatically.

The view can strong::open text documents:: and load from them both strong::plain text::, as well as formatted text in strong::HTML::, although it can not save the text back to files. However, you can get the contents of the view using the link::#-string:: method and then implement saving on your own, but the -string method will only return plain text, regardless of how the contents of the view are formatted.


CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Text and Formatting

METHOD:: open
	Opens a file at code::path:: and loads text from it.

	The file can be in plain text or HTML (or RTF, in Cocoa GUI) format. Note however that saving formatted text in the view is not supported.

	If loading the text from the file succeeds, it will replace any current contents of the view.

	argument:: path
		A String.

METHOD:: string
	The entire displayed contents of the view, as plain text.

	Setting this variable will replace any current contents of the view.

	argument::
		A String.

METHOD:: setString
	Inserts the code::string:: at code::start:: position, replacing code::size:: amount of following characters. If code::size:: is 0, the text will be inserted without any characters being removed.

	argument:: string
		A String - the text to insert.
	argument:: start
		An Integer position within the text, in characters.
	argument:: size
		An Integer amount of characters to be replaced.

METHOD:: currentLine
	The plain text of the line at text cursor.


SUBSECTION:: Formatting

TextView supports text font and color, and can syntax colorize sclang code.

note::The formatting is reset when the string changes.::


code::
(
var text = "Tous ces nombres paraissent bien concrets";
t = TextView(bounds: Rect(300, 400));
t.string = text;
t.front;
fork {
	loop {
		2.0.rand.wait;
		defer {
			t.setFont(Font("Times", rrand(12, 48)), rand(text.size - 1), rrand(3, 17));
			t.setStringColor(Color.rand, rand(text.size - 1), rrand(3, 17));

		}
	}
};
)
::


METHOD:: setFont
	Applies the code::font:: to code::size:: amount of characters following the code::start:: position.

	argument:: font
		A Font to apply to the desired range of text.
	argument:: start
		An Integer position within the text, in characters.
	argument:: size
		An Integer amount of characters.

METHOD:: setStringColor
	Applies the code::color:: to code::size:: amount of characters following the code::start:: position.

	argument:: color
		A Color to apply to the desired range of text.
	argument:: start
		An Integer position within the text, in characters.
	argument:: size
		An Integer amount of characters.



METHOD:: syntaxColorize
	Applies colors to text throughout the entire contents of the view, according to the SuperCollider language syntax highlighting scheme.

code::
(
t = TextView(bounds: Rect(300, 400));
t.string = this.cmdLine;
t.syntaxColorize;
t.front;
)
::



SUBSECTION:: Text Selection

METHOD:: selectedString
	The plain text contained in the current selection.

	When getting this variable and there is no selection, the entire line at text cursor is returned (equivalent to link::#-currentLine::).

	Setting this variable will replace text in the selection with the argument, or do nothing if there is no selection.

	argument::
		A String.
	returns::
		A String.

METHOD:: selectionStart
	The starting position of the selection. If no text is selected this variable represents the cursor position.

	returns::
		An Integer position within the text, in characters.

METHOD:: selectionSize
	The size of the current selection.

	returns::
		An Integer amount of characters - 0 if no text is selected.

METHOD:: select

	note:: Not available in strong::Cocoa GUI::. ::

	Selects code::size:: amount of characters following the code::start:: position. The cursor will remain at the end of the new selection.

	argument:: start
		An Integer position within the text, in characters.
	argument:: size
		An Integer amount of characters.




SUBSECTION:: Appearance

METHOD:: font
	The default font of the entire text. This font applies to any text to which a font has not been applied using link::#-setFont::.

	argument::
		A Font.

METHOD:: stringColor
	The default color of the entire text. This color applies to any text to which a color has not been applied using link::#-setStringColor::.

note::
Calling code::stringColor_:: does emphasis::not:: affect the cursor's color. Setting a dark background, using code::background_::, and a light text color will leave the cursor as a dark color. It is recommended to set the background and string colors by setting the TextView's palette to an instance of link::Classes/QPalette::.

code::
(
t = TextView(nil, Rect(800, 50, 500, 400))
.string_("Some text")
.palette_(QPalette.dark)  // set all colors here
.front;
)
::
::


METHOD:: tabWidth
	The width of tab characters as they are displayed.




SUBSECTION:: Interaction

METHOD:: editable
	Whether the contents of the view are editable, i.e. the text can be typed in and deleted by the user.

	argument::
		A Boolean.

METHOD:: enterInterpretsSelection
	Whether the selection will be interpreted and invoked as SuperCollider code when Ctrl/Cmd/Shift + Enter key combination is pressed.

	Defaults to code::false::.

	argument::
		A Boolean.

METHOD:: usesTabToFocusNextView
	Whether the tab key will - instead of inserting a tab character into the text - switch focus to the next view (as usual for other views).

	Defaults to code::false::.

	argument::
		A Boolean.

METHOD:: hasHorizontalScroller
	Whether the horizontal scroller is shown.

	Note that if link::#-autohidesScrollers:: is code::true:: the scroller may be hidden despite this variable being set to code::true::. Since the TextView typically wraps text into the next line when a line reaches the edge of the view, the horizontal scroller may never be shown, unless link::#-autohidesScrollers:: is code::false::.

	Defaults to code::true::.

	argument::
		A Boolean.

METHOD:: hasVerticalScroller
	Whether the vertical scroller is shown.

	Note that if link::#-autohidesScrollers:: is code::true:: the scroller may be hidden despite this variable being set to code::true::.

	Defaults to code::true::.

	argument::
		A Boolean.

METHOD:: autohidesScrollers
	Whether each of the scrollers will be automatically hidden if there is no use for it, i.e. the content is not scrollable in the direction of the scroller.

	If link::#-hasHorizontalScroller:: or link::#-hasVerticalScroller:: is code::false::, the respective scroller will always be hidden, regardless of this variable.

	Defaults to code::true::.

	argument::
		A Boolean.



SUBSECTION:: Drag and Drop

note:: Default drag-and-drop behavior of TextView is not defined in standard SC methods, but in the view implementation instead (except for link::#-defaultGetDrag::). It may or may not be overridable by adding your own handlers (see link::Classes/View#Drag and drop::), depending on the GUI kit in use.
::

Dragging from TextView will give the selected text in a String as drag data, while dropping will accept any object and insert it link::Classes/Object#-asString#as String:: at the drop location.

You can also drag files from outside SuperCollider onto a TextView, and it will insert their URLs at the drop location.

METHOD:: defaultGetDrag

	returns::
		The link::#-selectedString::.



EXAMPLES::

code::
(
w = Window.new("Text View Example",Rect(100,Window.screenBounds.height-400, 520,300)).front;
t = TextView(w.asView,Rect(10,10, 500,200))
    .focus(true);
)

// Using the Window you just created, try these in succession, and test how the text view responds
t.mouseUpAction_{|it, x, y, modifiers, buttonNumber| [x, y].postln};
t.autohidesScrollers_(false);
t.hasVerticalScroller_(false);
t.hasVerticalScroller_(true);
t.hasHorizontalScroller_(false);
t.hasHorizontalScroller_(true);
t.autohidesScrollers_(true);

t.open("Help/GUI/Main-GUI/Button.html"); // load an html file

// selective editing and formatting
t.setStringColor (Color.red, 5, 5);
t.setFont (Font("Courier",12), 5, 10);
t.setString ("\nA replacement String\n", 12, 6);

// compare with these methods, which change everything
t.font_(Font("Courier",14));
t.stringColor_(Color.blue);
::


class::Thread
summary::The context of code evaluation
categories::Core>Kernel
related:: Classes/Routine

description::

note:: A SuperCollider Thread is strong::not an operating system thread::. Although they
have some conceptual similarities, they do not correspond.
::

A Thread represents the strong::context:: within which code runs. It is also said that
code runs "emphasis::on:: a Thread". A Thread records the strong::state:: of code
execution, and thus provides support for code to be suspended at any time, and then
resumed where it left off. It is then said that the Thread itself is strong::suspended and
resumed::.

There is always one link::Classes/Process#-mainThread#main Thread:: belonging to the
link::Classes/Process:: - it is the Thread on which the top-level code runs. Another
Thread may be started using an instance of the Thread's subclass link::Classes/Routine::
 which will run a link::Classes/Function:: in the context of its own (there is no use in
instantiating the Thread class itself).

When code on a Thread starts or resumes another Thread (Routine), the former Thread
becomes the latter's strong::parent::, and the latter its strong::child::. The parent
Thread's execution is strong::blocked:: until the child Thread finishes or is suspended,
at which point the parent Thread continues execution. The strong::current:: Thread may be
accessed using link::#thisThread::, while a Thread's parent may be accessed
using link::#-parent::.

A Thread has
list::
## associated link::#-beats#logical time::
## an associated link::#-clock#Clock::
## own link::#-randSeed#random number seed::
## own link::#-exceptionHandler#exception handler::
::

method:: thisThread

The global pseudo-variable code::thisThread:: always represents the current Thread, i.e.
the context in which the current code is running. It can be either the
link::Classes/Process#-mainThread#main Thread:: or the link::Classes/Routine:: running the
current code.

See also: link::Classes/Clock#Scheduling and Threads::.

code::
// example
thisThread.beats;
thisThread.seconds;
thisThread.clock;
::

classMethods::

method::new

Creates an instance of Thread, passing it the Function with code to run.

note:: There is no good use in instantiating a Thread, because this class offers no method
of starting the given Function. Instead, use the Thread's subclass
link::Classes/Routine::. The only purpose of this constructor is for Routine to call it
within its own constructor.
::


argument::func
A Function with code for the Thread to run.

argument::stackSize
Call stack size (an Integer).

instanceMethods::

method:: parent
The parent Thread that started or resumed this Thread.

discussion::

The parent Thread's execution is blocked until the child Thread finishes or is suspended.

When a child Thread is started or resumed, it inherits certain aspects from its parent:
list::
## associated link::#-clock#Clock::
## associated link::#-beats#logical time::
::


method::beats
Get or set the current logical time of the Thread in beats. This will be the same
as the time in seconds, unless this Thread's link::#-clock#clock:: is
link::Classes/TempoClock::, and the clock's link::Classes/TempoClock#-tempo#tempo::
 is other than code::1::.

Setting code::beats:: also sets link::#-seconds:: to
code:: thisThread.clock.beats2secs(beats) ::.

discussion::

There are several sources of logical time:
list::
## When code is run from the code editor, the command line, or in response to OSC
and MIDI messages, the link::Classes/Process#-mainThread#main Thread::'s logical time is
set to the current strong::physical time:: (see link::Classes/Process#*elapsedTime::).

## When code strong::scheduled:: on a link::Classes/Clock:: is run, the
link::Classes/Process#-mainThread#main Thread::'s logical time is set to the time the code
was scheduled for.

## Child Threads strong::inherit:: logical time from their link::#-parent#parents::
 - whenever a Thread (Routine) is started or resumed, its logical time is set to
that of the parent Thread.
::

However, a Thread's logical time may also be set strong::manually:: (using this
method or link::#-seconds::). It may be useful to change the strong::current:: Thread's
time in order to manipulate behavior of streams that use the current logical time for
their operation (e.g. streams created by link::Classes/Pstep:: and
link::Classes/Pseg:: patterns). This will affect all code running within the current
Thread, as well as any child Threads, due to logical time inheritance. Note however
that changing strong::another:: Thread's time will have no effect, because the time
will be overridden by inheritance as soon as the Thread is run; likewise, any changes
to the current Thread's time only have effect until the Thread is suspended
(it link::Classes/Object#-yield#yields::) and resumed again.

See also: link::Classes/Clock#Scheduling and Threads::.

method::seconds
Get or set the current logical time of the Thread in seconds.

Setting code::seconds:: also sets link::#-beats:: to
code::thisThread.clock.secs2beats(seconds)::.

See link::#-beats:: for general discussion on Threads and logical time.

method::clock
Get or set the Thread's associated link::Classes/Clock::.

discussion::

There are several ways a Clock becomes associated with a Thread:
list::
## When code is run from the code editor, the command line, or in response to OSC and
MIDI messages, the link::Classes/Process#-mainThread#main Thread::'s clock is set to
link::Classes/SystemClock::.

## When code strong::scheduled:: on a Clock is run, that clock becomes the
link::Classes/Process#-mainThread#main Thread::'s clock.

## Child Threads strong::inherit:: the associated clock from their
link::#-parent#parents::.
::

A Thread's associated clock may also be set strong::manually:: using this method. Setting
the strong::current:: Thread's clock is useful to manipulate further behavior of the
Thread or its child Threads, but the clock will be reset the next time the Thread
is resumed, due to clock inheritance. For the same reason, setting
strong::another:: Thread's clock will have no effect on code running on it.

See also: link::Classes/Clock#Scheduling and Threads::.

method:: deferAwayFrom
Executes a given function, guaranteeing that it will not execute on the same thread as code::this::. That is:

list::
## If code::delta > 0:: (the function should evaluate later), defer to link::Classes/AppClock::.
## If code::delta <= 0:: (execute right now), defer to link::Classes/AppClock:: if code::thisThread:: matches the thread receiving this method call. Otherwise, directly link::Classes/Function#-value:: the function.
::

This method interface is designed to be used with function-call syntax, e.g. code::deferAwayFrom(aThread) { ... function body ... }::.

argument:: func
The function to evaluate. It will not be passed any argument values.

argument:: delta
A time delta in seconds. Normally, the default 0 will be used.

method::isPlaying
Returns:: true if it is playing.

method::state

The internal state values for a Thread instance can be polled:
table::
## 0 || not started
## 7 || running
## 8 || stopped
::

subsection::Seeding the random number generator

see also: link::Reference/randomSeed::

method::randSeed
Set the random number generator seed using a single integer.
discussion::
Example:
code::
g = thisThread.randSeed = 4;
10.do{1.0.rand2.postln};
::

method::randData

Get or set the three integer array which defines the internal basis for the random number generator.  You can use this to get back the exact same random number sequence, and it provides a mechanism for automatic replay for generative music.
discussion::
Example:
code::
g = thisThread.randData;
10.do{1.0.rand2.postln};
::
code::
// each time the seed is reset, the random number generation should give the same sequence
thisThread.randData_(Int32Array[ -662787342, 1546785953, 1661466823 ]);
10.do{1.0.rand2.postln};
::



class::Thunk
summary::unevaluated value
categories::Core>Kernel

description::

Thunk, "past tense of think", can be used 	when a calculation may, or may not have to be performed at a later point in time, and its value is needed several times. This is an example of lazy evaluation, and can be used to avoid unnecessary calculations and to make state immutable.

classMethods::

method::new

argument::function
some function that returns the desired value

instanceMethods::

method::value

return the value. If calculation is done, use previous value, otherwise do calculation.

examples::

code::
// so for example, random values will result in a single instance:
a = Thunk({ \done.postln; rrand(2.0, 8.0) });
a.value; // posts "done"
a.value;
::

code::
// it is an AbstractFunction, so one can use it for math operations:

a = Thunk({ rrand(2.0, 8.0) });
b = a * 5 / (a - 1);
b.value;
::

code::
// lazy evaluation

a = Thunk({ \done1.postln; Array.fill(10000, { |i| i + 6 % 5 * i / 2 }) }); // some calculation.
b = Thunk({ \done2.postln;Array.fill(10000, { |i| i + 5 % 6 * i / 3 }) });// some other calculation.
c = [a, b].choose + 700;
(c * c * c).value; // calculation happens here, and only once.

// compare to a function:

a = { \done1.postln; Array.fill(10000, { |i| i + 6 % 5 * i / 2 }) }; // some calculation.
b = { \done2.postln;Array.fill(10000, { |i| i + 5 % 6 * i / 3 }) };// some other calculation.
c = [a, b].choose + 700;
(c * c * c).value; // calculation happens here, but 3 times (for each c)
::



class:: Timer
summary:: Returns time since last triggered.
categories::  UGens>Triggers

Description::
When triggered, Timer measures the time (in seconds) elapsed since the previous trigger, and outputs this time value as a constant. Its output will not change until the next trigger. The initial value is 0.

If you need the time since the last trigger, where the time is continually updated, see link::Classes/Sweep::.

classmethods::
private:: categories

method::ar, kr

argument::trig

A trigger occurs when trig signal crosses from non-positive to positive.


Examples::

code::

// using timer to modulate sine frequency: the slower the trigger is the higher the frequency
(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 20, 1));
	SinOsc.ar(Timer.kr(trig) * 500 + 500, 0, 0.2)
}.play;
)

::



class:: ToggleFF
summary:: Toggle flip flop.
related:: Classes/SetResetFF
categories::  UGens>Triggers


Description::

Toggles between 0 and 1 upon receiving a trigger.


classmethods::

method::ar, kr

argument::trig

Trigger input.


Examples::

code::

(
play({
	SinOsc.ar((ToggleFF.ar(Dust.ar(XLine.kr(1,1000,60))) * 400) + 800, 0, 0.1)
}))

::



TITLE:: ToolBar
summary:: An inline button bar populated by MenuActions
categories:: GUI
related:: Classes/Menu, Classes/MenuAction, Classes/MainMenu

DESCRIPTION::
A ToolBar is similar to a link::Classes/Menu::, with several key differences:
LIST::
	## ToolBars act as regular link::Classes/View::s, and can be placed in layouts or in other views.
	## MenuActions on a toolbar appear as buttons instead of being listed menu-style
	## By default, MenuActions that have icons show ONLY the icon. MenuActions with text will appear as a text button. This can be changed using the toolButtonStyle property.
::

code::
(
View().fixedWidth_(300).layout_(HLayout(
	ToolBar(
		MenuAction("Option A", { "Option A".postln }),
		MenuAction("Option B", { "Option B".postln }),
		MenuAction("Option C", { "Option C".postln })
	)
)).front
)
::

CLASSMETHODS::

METHOD:: new
	Create a new ToolBar containing one or more actions.

	ARGUMENT::
		One or more link::Classes/MenuAction::

INSTANCEMETHODS::

METHOD:: orientation
	The horizontal or vertical orientation of the ToolBar
	ARGUMENT::
		A link::Classes/QOrientation::

METHOD:: toolButtonStyle
	Controls whether the toolbar shows icons, text, or both.
	ARGUMENT::
		An integer; one of the values of link::Classes/QToolButtonStyle::.
	DISCUSSION::
		CODE::
(
~icon = Image(64).draw({ Pen.fillOval(Rect(0, 0, 64, 64)) });
~styles = QToolButtonStyle.classVarNames;

~tool = ToolBar(
	MenuAction("Text")
		.icon_(~icon)
		.action_({
			~tool.toolButtonStyle = (~tool.toolButtonStyle + 1) % ~styles.size;
			~styles[~tool.toolButtonStyle].postln;
		})
).front;
)
		::

EXAMPLES::

code::
(
s.waitForBoot {
	~synth = nil;
	~freq = 300;

	~startIcon = Image(40).draw({
		Pen.fillColor = Color.green;
		Pen.moveTo(5@5);
		Pen.lineTo(35@20);
		Pen.lineTo(5@35);
		Pen.lineTo(5@5);
		Pen.fill;
	});

	~stopIcon = Image(40).draw({
		Pen.fillColor = Color.red;
		Pen.fillRect(Rect(10, 10, 20, 20));
	});

	~freqMenu = Menu(
		MenuAction("100"),
		MenuAction("200"),
		MenuAction("300"),
		MenuAction("400"),
		MenuAction("500"),
	).title_(~freq);

	~updateFunc = {
		|obj, what, action|
		if (what == \triggered) {
			~freq = action.string.asInteger;
			~freqMenu.title = ~freq;
			~synth !? { ~synth.set(\f, ~freq) };
		}
	};

	~freqMenu.addDependant(~updateFunc);

	~play = MenuAction("play")
		.icon_(~startIcon)
		.action_({
			if (~synth.isNil) {
				~synth = { |f| SinOsc.ar(f) * 0.1 }.play(args:[\f, ~freq]);
				~synth.onFree { ~synth = nil };
				~play.icon = ~stopIcon;
			} {
				~synth.free;
				~play.icon = ~startIcon;
			}
		});

	~toolBar = ToolBar(~play, ~freqMenu).minWidth_(200).front;
	~toolBar.onClose_({ ~freqMenu.removeDependant(~updateFunc) })
}
)
::


class:: TouchResponder
summary:: allow functions to be registered to respond to MIDI aftertouch events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They also provide support for all MIDI message types.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::value
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next aftertouch message, reset self to match src, chan.
code::
(
c = TouchResponder({ |src,chan,value|
		[src,chan,value].postln;
	});
	c.learn; // wait for the first touch message
)
TouchResponder.removeAll
::


Examples::

code::
(
	c = TouchResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
::

code::
(
	c = TouchResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		(50..90) // values within this range
	)
)

c.remove
::


CLASS:: TreeView
summary:: A view displaying a tree of items with columns
categories:: GUI>Views

DESCRIPTION::

A view that displays a hierarchy of items. It is divided into rows and column: each row represents an item, and each column represents a different data field of the items.

The items are represented in code by instances of link::Classes/TreeViewItem::, returned by the various TreeView methods. Top level items are added via the TreeView interface, while child items are added via the TreeViewItem interface, which also allows to manipulate items in more detail after their creation.

Items can be visually sorted with link::#-sort::, or by clicking on one of the column headers, if link::#-canSort:: is enabled.

Each item can hold other views in each of its data fields, which allows for rich graphical interaction. See link::Classes/TreeViewItem#-setView::.


CLASSMETHODS::

PRIVATE:: key

INSTANCEMETHODS::

PRIVATE:: prForEachColumnDataPair
PRIVATE:: prValidItem


SUBSECTION:: Data

METHOD:: columns
	Gets or sets the number of columns (data fields) and their names. When setting a smaller number of columns than the current the extra columns will be removed, and hence all the data stored stored in those columns.

	ARGUMENT::
		An array of Strings for column names.

METHOD:: numColumns
	The total number of columns (data fields).

METHOD:: addItem
	Append a new top-level item.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of TreeViewItem representing the new item.

METHOD:: insertItem
	Insert a new top-level item at code::index::.

	ARGUMENT:: index
		The position at which to insert the item.
	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of TreeViewItem representing the new item.

METHOD:: removeItem
	Remove the given code::item::. After the item is removed, any usage of the related TreeViewItems will have no effect.

	ARGUMENT::
		An instance of TreeViewItem.

METHOD:: numItems
	The total number of items.

METHOD:: clear
    Removes all items.

METHOD:: currentItem
	Gets or sets the currently selected item.

	ARGUMENT::
		An instance of TreeViewItem.
	RETURNS::
		An instance of TreeViewItem or nil, if no current item.

METHOD:: itemAt
	The item at code::index::.

METHOD:: childAt
	Alias for link::#-itemAt::, provided for compatibility with TreeViewItem.

METHOD:: addChild
	Alias for link::#-addItem::, provided for compatibility with TreeViewItem.

METHOD:: insertChild
	Alias for link::#-addChild::, provided for compatibility with TreeViewItem.

SUBSECTION:: Appearance

METHOD:: sort
	Sort items by data in code::column::. This works regardless of link::#-canSort::.

	NOTE:: Sorting has no effect on the logical order of the items, it only affects how they are displayed. ::

	ARGUMENT:: column
		The integer column index to sort by.
	ARGUMENT:: descending
		Whether to sort in descending or ascending fashion. The default is ascending.

METHOD:: columnWidth

	ARGUMENT:: column
		The integer index of a column
	RETURNS::
		Integer width of column in pixels. If code::column:: is not in the range
		code::0..(numColumns-1)::, returns code::-1::.

METHOD:: setColumnWidth

Sets the width of a column. The rightmost column must extend at least to the right bound of the
TreeView.

	ARGUMENT:: column
		The integer index of the column to modify
	ARGUMENT:: width
		Integer width in pixels

PRIVATE:: background


SUBSECTION:: Interaction

METHOD:: canSort
	Whether the user can sort the items by clicking on a column header.

	When setting to code::true::, the items will be sorted immediately according to the current sorting column. While code::true::, the view will also automatically sort new items.

	The default is code::false::.

	See also: link::#-sort::.




SUBSECTION:: Actions

METHOD:: itemPressedAction
	The object to be evaluated when a mouse button is pressed on an item, passing this view as the argument.

METHOD:: onItemChanged
	The object to be evaluated whenever the current item changes, passing this view as the argument.


EXAMPLES::

CODE::

(
var t = TreeView().front;
t.columns_(["a", "b", "c", "d"]);
t.addItem(["A1", "B1", "C1", "D1"]);
t.addItem(["A2", "B2", "C2"]);
t.addItem(["A3", "B3"]);
t.addItem(["A4"]);
)


//sorting example
(
var names = ["black", "white", "red", "green", "blue", "cyan", "magenta", "yellow"];
var colors = names.collect{|str| Color.perform(str.asSymbol)};
var window, tree, popup;
window = Window.new("TreeView example - RGBA colors").front;
window.view.layout_(VLayout(
	tree = TreeView()
));
tree.columns_(["Index", "Name", "Int", "Hex"]);
tree.font = Font.defaultMonoFace;
tree.setColumnWidth(0, 60);
tree.setColumnWidth(2, 130);
names.do{|str, i|
	var intString = "% % % %".format(*(colors[i].asArray*255).asInteger);
	tree.addItem([i, str, intString, colors[i].hexString]);
};
tree.numItems.do{|i|
	var c = [Color.clear, colors[i], Color.clear, Color.clear];
	tree.itemAt(i).colors_(c).textColors_(Color.grey);
};
tree.onItemChanged_({|view|
	view.currentItem.strings.postln;
});
tree.canSort = true;
)
::


CLASS:: TreeViewItem
summary:: An item in TreeView
categories:: GUI>Views

DESCRIPTION::

An instance of TreeViewItem represents an item in TreeView. There may be multiple instances representing the same item, e.g. after calling link::Classes/TreeView#-currentItem:: multiple times.

INSTANCEMETHODS::

PRIVATE:: prValidItem

METHOD:: index
	RETURNS:: An integer position of this item among its siblings.

METHOD:: parent
	RETURNS:: An new instance of TreeViewItem representing the parent item.

METHOD:: childAt
	RETURNS:: A new instance of TreeViewItem representing the child item at code::index::.

METHOD:: addChild
	Appends a new child to this item.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of TreeViewItem representing the new item.

METHOD:: insertChild
	Inserts a new child to this item at code::index::.

	ARGUMENT:: index
		The position at which to insert the child.
	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of TreeViewItem representing the new item.

METHOD:: strings
	The text in the data fields.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.

METHOD:: setString
	Sets the text in the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: string
		A String or nil.

METHOD:: colors
	The background colors of the data fields.

	ARGUMENT:: colors
		An array of Colors, each for the color of one data field.

METHOD:: setColor
	Sets the background color of the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: color
		A Color.

METHOD:: textColors
	The text colors of the data fields.

	ARGUMENT:: textColors
		An array of Colors, each for the color of one data field.

METHOD:: setTextColor
	Sets the text color of the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: color
		A Color.

METHOD:: setView
	Places another view into the given data field. Only one view can be placed into a data field at once. If a view is already present, it will be removed and destroyed.

	If the number of data fields decreases due to a call to link::Classes/TreeView#-columns::, the views contained in removed data fields will also be removed and destroyed.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: view
		A View.

METHOD:: removeView
	Removes the view from the given data field, if any.

	ARGUMENT:: column
		An integer index of a data field.

METHOD:: view
	The view in the given data field.

	ARGUMENT:: column
		An integer index of a data field.

METHOD:: ==
	Implements equality comparison between two TreeViewItem instances. Two instances are equal if they represent the same item in TreeView.

	RETURNS:: A Boolean.

METHOD:: isNull
	Whether the item is invalid. After an item is removed, all related TreeViewItem instances become invalid.

	RETURNS:: A Boolean.


EXAMPLES::

CODE::

(
t = TreeView().front;
t.columns_(["one", "two", "three"]);
t.addItem(["Alice", "Anna", "Anders"]);
t.addItem(["Bob", "Beatrice", "Benny"]);
t.addItem(["Cleo", "Conrad", "Cecilia"]);
)

i = t.itemAt(1);  //get an item

i.setString(1, "Hans");
i.setColor(1, Color.red);
i.setTextColor(1, Color.white);

i.addChild(["Bengt", "Bodil", "Ben"]);
i.strings;
i.childAt(0).strings;
::


class:: Trig
summary:: Timed trigger.
related:: Classes/Trig1
categories::  UGens>Triggers


Description::

When a nonpositive to positive transition occurs at the input, Trig
outputs the level of the triggering input for the specified duration,
otherwise it outputs zero.


classmethods::

method::ar, kr

argument::in

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::dur

Duration of the trigger output.


Examples::

code::

{ Trig.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play

{ Trig.ar(Dust.ar(4), 0.1) }.play

::



class:: Trig1
summary:: Timed trigger.
related:: Classes/Trig
categories::  UGens>Triggers


Description::

When a nonpositive to positive transition occurs at the input, Trig1
outputs 1 for the specified duration, otherwise outputs 0.


classmethods::

method::ar, kr

argument::in

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::dur

Duration of the trigger output.


Examples::

code::

{ Trig1.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play


To create a fixed duration gate
(

SynthDef("trig1",{ arg dur=0.125;
	var gate;
	gate = Trig1.kr(1.0,dur);
	OffsetOut.ar(0,
		SinOsc.ar(800, 0.3)
		* EnvGen.kr(
			Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
			gate,
			doneAction: Done.freeSelf)
	)
}).add;

Routine({
	1.0.wait;
	100.do({
		s.sendBundle(0.05,["s_new", "trig1" ,-1,0,0,0,rrand(0.02,0.25)]);
		0.25.wait
	})
}).play(SystemClock)

)

This should sound like a continuous sine wave, although it is actually a series of 0.25 second synths.
(
SynthDef("trig1",{
	var gate;
	gate = Trig1.kr(1.0,0.25);
	OffsetOut.ar(0,
		SinOsc.ar(800, 0.3)
		* EnvGen.kr(
			Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
			gate,
			doneAction: Done.freeSelf)
	)
}).add;

Routine({
	1.0.wait;
	100.do({
		s.sendBundle(0.05,["s_new", "trig1" ,-1]);
		0.25.wait
	})
}).play(SystemClock)

)

::



class:: TrigControl
summary:: FIXME: TrigControl purpose.
related:: Classes/Control, Classes/LagControl
categories::  UGens>Synth control, UGens>Undocumented


Description::

FIXME: TrigControl description.


classmethods::

method::kr, ir

argument::values

FIXME: explain parameter values.


method::names

argument::names

FIXME: explain parameter names.


returns:: Returns:

A newly created
link::Classes/UGen:: .




class::True
categories::Core
summary::true logical value

description::
see link::Classes/Boolean::


CLASS::Tuning
summary::represents a musical tuning
related::Classes/Scale
categories:: Tuning

DESCRIPTION::
Represents a musical tuning (e.g. equal temperament, just intonation, etc.). Used in conjunction with link::Classes/Scale:: to generate pitch information.

code::
t = Tuning.et12;
t.semitones;		// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ]
t.ratios;		// [ 1, 1.0594630943591, 1.1224620483089, 1.1892071150019, etc. ]

Pbind(\scale, Scale.major(t), \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;

// use non-standard tuning
t = Tuning.just;
t.semitones;		// [ 0, 1.1173128526978, 2.0391000173077, 3.1564128700055, etc. ]
t.ratios.collect(_.round(0.001));	// [ 1, 1.067, 1.125, 1.2, 1.25, 1.333, 1.406, 1.5, etc. ]

Pbind(\scale, Scale.major(t), \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;
::

subsection::Creation

strong::just, pythagorean, werckmeister, johnston, partch, wcAlpha, bp, etc.::

Creates a tuning from the library stored in code::Tuning.all::. For a complete list of available tunings, execute
code::
Tuning.directory
::

CLASSMETHODS::

method::et
Creates an equal-tempered scale based on pitchesPerOctave.

method::choose
Creates a random tuning from the library, constrained by size (which defaults to 12).
code::
Scale.major(Tuning.choose).tuning.name;
::

method::new
Creates a Tuning using some or all of the parameters as follows: strong::tuning:: can be the name of a library tuning (in which case that tuning is returned); an array of floats representing the semitone values of the tuning (in which case pitchesPerOctave will be set to the size of the array regardless of the second parameter); or nil (in which case the default tuning for strong::pitchesPerOctave:: will be returned). strong::octaveRatio:: defaults to 2.0, but can be set differently for stretched or compressed tunings.
code::
Tuning.new(\et12);	// standard equal temperament
// custom tuning
Tuning.new(#[ 0, 0.795, 2.251, 3.251, 4.036, 4.680, 5.915, 7.221, 8.013, 9.29, 9.930, 11.032 ]);
Tuning.new((0..11).collect(_ * (2.08 ** (1/12))), 2.08, "Stretched ET12");
::

INSTANCEMETHODS::

private::storeOn, storedKey, storeArgs, printOn

method::semitones
Returns an array of semitone values for the pitch set. link::#-as::(Array) is equivalent; link::#-as::(List) returns it as a list, etc.

method::cents
Returns a array of cent values for the pitch set.

method::ratios
Returns a tuned array of ratios for the pitch set.

EXAMPLES::

For examples of use, see the link::Classes/Scale:: help file.


class:: TwoPole
summary:: Two pole filter.
related:: Classes/TwoZero
categories::  UGens>Filters>Linear


Description::

A two pole filter. This provides lower level access to setting of pole
location. For general purposes  link::Classes/Resonz::  is better.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Frequency of pole angle.


argument::radius

Radius of pole. Should be between 0 and +1.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ TwoPole.ar(WhiteNoise.ar(0.005), 2000, 0.95) }.play

{ TwoPole.ar(WhiteNoise.ar(0.005), XLine.kr(800,8000,8), 0.95) }.play

{ TwoPole.ar(WhiteNoise.ar(0.005), MouseX.kr(800,8000,1), 0.95) }.play

::



CLASS::TwoWayIdentityDictionary
summary::associative collection mapping keys to values and back
related::Classes/IdentityDictionary
categories::Collections>Unordered

DESCRIPTION::
Similar to link::Classes/IdentityDictionary::, but allows to go efficiently from element to key and back. The contents of a TwoWayIdentityDictionary are strong::unordered::. You must not depend on the order of items.

INSTANCEMETHODS::

private::init

method::getID
Find the key for a given object. If object is not element of the dictionary, it returns nil.

EXAMPLES::

code::
a = TwoWayIdentityDictionary.new;
a.put(\test, 999);
a.put(["some", "strings"], 1200);
a.at(\test);
a.getID(999);
a.getID(1200);
a.getID(888); // nil
::


class:: TwoZero
summary:: Two zero filter.
related:: Classes/TwoPole
categories::  UGens>Filters>Linear


Description::

A two zero filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Frequency of zero angle.


argument::radius

Radius of zero.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ TwoZero.ar(WhiteNoise.ar(0.125), XLine.kr(20,20000,8), 1) }.play

::



class:: UGen
summary:: Abstract superclass of all unit generators
categories:: UGens, Server>Abstractions
related:: Browse#UGens, Guides/Tour_of_UGens, Guides/UGens-and-Synths

description::

UGens represent calculations with signals. They are the basic building blocks of synth definitions on the server, and are used to generate or process both audio and control signals. The many subclasses of UGen are the client-side representations of unit generators, and are used to specify their parameters when constructing synth definitions (see link::Classes/SynthDef::).

subsection:: Interface
All UGens respond to one or more of the following class methods:
list::
## code:: ar(arg1, arg2, ... ) ::
## code:: kr(arg1, arg2, ... ) ::
## code:: ir(arg1, arg2, ... ) ::
::

They return a new instance of UGen that calculates at audio/control rate or at initialization only (ir). Some UGens, like link::Classes/Rand::, use the code::*new:: method instead. These methods are implemented in subclasses, where argument names and their meaning depend on the case.

If any argument is an array, they return an array of UGens ( see: link::Guides/Multichannel-Expansion:: ). If the combination of rates between arguments and ugen are not allowed, calling the methods will throw an error. This method adds the UGen to the current SynthDef, so it only fully works inside a UGen function.
code::
{ Blip.ar(Blip.kr(4, 5, 500, 60), 59, 0.1) }.play;
::

subsection:: Documentation of mul and add arguments

A great number of UGens take arguments for code::mul:: and code::add:: in their code::*ar:: and code::*kr:: methods. Because these arguments are so ubiquitous, they are not general documented in the individual help files.
Mul and add simply refer to a constant or signal by which to multiply the output of the UGen, and a constant or signal to add to the output of the UGen. (mul happens before add.) They thus correspond in many cases to scaling the amplitude of the UGen signal in the case of mul, and adding a constant or DC offset in the case of add.
In most cases the defaults for mul and add are 1 and 0 respectively, and they are commonly implemented using a automatically generated link::Classes/MulAdd:: UGen for efficiency. See also the code::range:: and code::madd:: methods below.

classmethods::
private:: categories

method:: buildSynthDef
Returns:: the SynthDef in which the UGen is situated.
Discussion::
code::
{ UGen.buildSynthDef.dump; Silent.ar }.play;
::

subsection:: Internally used class methods

method:: multiNew
These methods are responsible for multichannel expansion. They call code::*new1(rate, ...args):: for each parallel combination. Most code::*ar/*kr:: methods delegate to link::#*multiNewList::.
argument:: ... args
The first argument is rate, then the rest of the arguments. code::(rate, ...args)::

method:: multiNewList
See link::#*multiNew::.
argument:: args
An array where the first argument is rate, then the rest of the arguments. code::([rate, ...args])::

method:: new1
This method returns a single instance of the UGen, not multichannel expanded. It is called inside multiNewList, whenever a new single instance is needed.

method:: methodSelectorForRate
argument:: rate
A link::Classes/Symbol::, code:: \audio, \control, \scalar ::
Returns::
An appropriate message selector ( link::Classes/Symbol:: like code:: \ar, \kr, \ir :: ) for the given rate.

method:: replaceZeroesWithSilence
Returns::
A new link::Classes/Array::, where every zero is replaced by a link::Classes/Silent:: UGen.
discussion::
This is required internally sometimes for UGens like link::Classes/Out::.

instancemethods::

subsection:: Convenience Methods

method:: scope

Displays the output of this UGen in an individual link::Classes/Stethoscope:: window.
argument::name
The name of the window
argument::bufsize
Buffer size
argument::zoom
Zoom factor

discussion::
code::
s.boot

{ Ringz.ar(PinkNoise.ar([0.1, 0.2]).scope(\pink), 2000, 1, 0.25) }.play; // multichannel works
s.scope; // can still separately scope the output of the server
::

method:: poll

Polls the output of this UGen every interval seconds, and posts the result.

argument::trig
Trig frequency
argument::label
A symbol to label the output
argument::trigid
Numerical ID
discussion::
The default trig is 10, which converts to 10 triggers per second (or every 0.1 seconds). See link::Classes/Poll:: for more info on polling.
code::
{ SinOsc.ar(LFNoise0.ar(2).range(420, 460).poll(label: \LFNoise), 0, 0.2) }.play;

// multichannel polling:
(
{
    var freqs = SinOsc.ar([0.2, 0.3]).range(420, 460);
    freqs.poll(label: [\freq1, \freq2]);
    SinOsc.ar(freqs, 0, 0.2);
}.play;
)
::


method:: dpoll

Like code::poll::, only that code::dpoll:: is used for Demand ugens. See link::Classes/Poll:: for more info on polling.

method:: range

Scales the output of this UGen to be within the range of code::lo:: and code::hi::.
discussion::
Note that code::range:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
{ SinOsc.ar(SinOsc.ar(0.3).range(440, 660), 0, 0.5) * 0.1 }.play;
::

method:: exprange

Maps the output of this UGen exponentially to be within the range of code::lo:: and code::hi:: using a link::Classes/LinExp:: UGen.
discussion::
code::lo:: and code::hi:: should both be non-zero and have the same sign. Note that code::exprange:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
{ SinOsc.ar(SinOsc.ar(0.3).exprange(440, 6600), 0, 0.5) * 0.1 }.play;
::

method:: curverange

Scales the output of this UGen to be within the range of code::lo:: and code::hi:: using a curve factor of code::curve::.
discussion::
Note that code::curverange:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
{ SinOsc.ar(SinOsc.ar(0.3).curverange(440, 660, -3), 0, 0.5) * 0.1 }.play;
::



method:: unipolar

Scales the output of this UGen to be between code::(0..mul):: range (default 1).
discussion::
Note that code::unipolar:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
{ SinOsc.ar(300, 0, 0.5) * SinOsc.kr(2).unipolar * 0.1 }.play;
::

method:: bipolar

Scales the output of this UGen to be between code::(-mul..mul):: range (default 1).
discussion::
Note that code::bipolar:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
{ SinOsc.ar(500 + LFPulse.ar(4).bipolar(40), 0, 0.5) * 0.1 }.play;
::

method:: degrad
Converts degrees to radians. This method multiplies the receiver's output by code::pi/180::.

method:: raddeg
Converts radians to degrees. This method multiplies the receiver's output by code::180/pi::.

method:: clip
Wraps the receiver in a link::Classes/Clip:: UGen, clipping its output at code::lo:: and code::hi::.

method:: fold
Wraps the receiver in a link::Classes/Fold:: UGen, folding its output at code::lo:: and code::hi::.

method:: wrap
Wraps the receiver in a link::Classes/Wrap:: UGen, wrapping its output at code::lo:: and code::hi::.

method:: blend
Blends code::this:: with code::that:: by wrapping the receiver in an link::Classes/XFade2:: (if code::this:: or code::that:: are audio-rate UGens) or link::Classes/LinXFade2:: UGen.
note:: The code::blendFrac:: argument is between 0 and 1::


method:: lag
Wraps the receiver in a link::Classes/Lag:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/LagUD:: UGen.

method:: lag2
Wraps the receiver in a link::Classes/Lag2:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/Lag2UD:: UGen.

method:: lag3
Wraps the receiver in a link::Classes/Lag3:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/Lag3UD:: UGen.

method:: lagud
Wraps the receiver in a link::Classes/LagUD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: lag2ud
Wraps the receiver in a link::Classes/Lag2UD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: lag3ud
Wraps the receiver in a link::Classes/Lag3UD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: varlag
Wraps the receiver in a link::Classes/VarLag:: UGen, smoothing its output by code::time:: seconds.

method:: slew
Wraps the receiver in a link::Classes/Slew:: UGen, limiting the slope of its output.

method:: degreeToKey

Wraps the receiver in a link::Classes/DegreeToKey:: UGen.

method:: minNyquist

Wraps the receiver in a code::min:: link::Classes/BinaryOpUGen::, such that the lesser of the receiver's output and the Nyquist frequency is output. This can be useful to prevent aliasing.

method:: snap

Wraps the receiver so that its values are rounded within code::margin:: distance from a multiple of code::resolution:: to a multiple of resolution. By using code::margin:: and code::strength:: you can control when values will be rounded, and by how much. See link::Classes/SimpleNumber#-snap:: for more details.

This can be used to make control signals (e.g. from sensors) "snap" to defined resolution. Example:
code::
s.boot;
x = {SinOsc.ar((Line.kr(0, 10, 10).snap(1, 0.3, 1) + 60).poll.midicps, 0, -24.dbamp)}.play
::

method:: softRound

Wraps the receiver so that its values are rounded outside of code::margin:: distance from a multiple of code::resolution:: to a multiple of resolution. By using code::margin:: and code::strength:: you can control when values will be rounded, and by how much. See link::Classes/SimpleNumber#-softRound:: for more details.

method:: linlin
Wraps the receiver so that a linear input range is mapped to a linear output range.

discussion::
The clip argument can be one of the four:
table::
## code::nil:: || do not clip at outMin or outMax
## code::\minmax:: || clip at outMin or outMax
## code::\min:: || clip at outMin
## code::\max:: || clip at outMax
::
Example:
code::
{ Line.ar(-1, 5, 0.1).linlin(0, 3, -1, 1) }.plot(0.1);

// modulate some values
(
{ Line.ar(-1, 5, 0.1).lincurve(SinOsc.ar(100), SinOsc.ar(130) + 3, -1, 1, clip: nil) }
    .plot(0.1, minval: -15, maxval: 5)
)
::

method:: linexp

Wraps the receiver so that a linear inputrange is mapped to an exponential output range.
discussion::
outMin and outMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
{ Line.ar(-1, 5, 0.1).linexp(0, 3, 0.01, 1) }.plot(0.1);
::

method:: explin

Wraps the receiver so that an exponential inputrange is mapped to a linear output range.
discussion::
inMin and inMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
{ Line.ar(1, 5, 0.1).explin(1, 3, -1, 1) }.plot(0.1);
::

method:: expexp

Wraps the receiver so that an exponential inputrange is mapped to an exponential output range.
discussion::
outMin, outMax, inMin and inMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
{ Line.ar(1, 5, 0.1).expexp(1, 3, 0.01, 1) }.plot(0.1);
::

method:: lincurve

Wraps the receiver so that a linear inputrange is mapped to a curve-like exponential output range.
discussion::
outMin and outMax may be zero and of the different sign. For clip argument, see code::linlin:: above.
code::
{ Line.ar(-1, 5, 0.1).lincurve(0, 3, -1, 1, curve: -4) }.plot(0.1);

// modulate the curve. Unlike with numbers and CurveSpec, the curve absolute value
// should not be much smaller than 0.5.
{ SinOsc.ar(100).lincurve(-1, 1, -1, 1, XLine.kr(-3, -100, 0.1)) * 0.1 }.plot(0.1);
::

method:: curvelin
Wraps the receiver so that a  curve-like exponential inputrange is mapped to a linear output range.
discussion::
inMin and inMax may be zero and of the different sign. For clip argument, see code::linlin:: above.
code::
{ Line.ar(-1, 5, 0.1).curvelin(0, 3, -1, 1, curve: -4) }.plot(0.1);
::


method:: bilin
Map the receiver from two assumed linear input ranges (inMin..inCenter) and (inCenter..inMax) to two linear output ranges (outMin..outCenter) and (outCenter..outMax). If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inCenter
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outCenter
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
{Line.kr(0, 10, 0.1).bilin(1, 0, 10, 0.6, 0, 1)}.plot(0.1)
::


method:: prune
Limits the receiver range to one of the four clip modes, see code::linlin:: above.

method:: checkBadValues
Wraps the receiver in a link::Classes/CheckBadValues:: UGen with the corresponding code::id:: and code::post:: flag.

method:: if
Outputs trueUGen when the receiver outputs 1, falseUGen when the receiver outputs 0. If the receiver outputs a value between 0 and 1, a mixture of both will be played.
discussion::
This is implemented as: code::(this * (trueUGen - falseUGen)) + falseUGen)::

Note that both trueUGen and falseUGen will be calculated regardless of whether they are output, so this may not be the most efficient approach.
code::
// note different syntax in these two examples
{ if( LFNoise1.kr(1.0, 0.5, 0.5) , SinOsc.ar, Saw.ar ) * 0.1 }.play;

{ Trig1.ar(Dust.ar(3), 0.2).lag(0.1).if(FSinOsc.ar(440), FSinOsc.ar(880)) * 0.1 }.play;
::

method:: @
Dynamic geometry support. Returns code::Point(this, y)::.
discussion::
code::
{ (SinOsc.ar(1001) @ SinOsc.ar(1207)).rho }.scope;
::

method:: asComplex
Complex math support. Returns code::Complex(this, 0.0)::.

method:: dumpArgs
Posts a list of the arguments for this UGen and their values.


subsection:: Other Instance Methods

The following methods and instance variables are largely used in the construction of synth definitions, synth descriptions (see link::Classes/SynthDesc::), UGen class definitions, etc., and are usually not needed for general use.
Users should not attempt to set any of these values in general code.

method:: synthDef
The SynthDef which contains the UGen.

method:: inputs
The array of inputs to the UGen.

method:: rate
The output rate of the UGen which is one of the link::Classes/Symbol::s code::\audio::, or code::\control::.

method:: signalRange
Returns:: A symbol indicating the signal range of the receiver. Either code::\bipolar:: or code::\unipolar::.

method:: numChannels
Returns:: The number of output channels.
discussion::
For a UGen, this will always be 1, but link::Classes/Array:: also implements this method, so multichannel expansion is supported. See link::Guides/Multichannel-Expansion::.

method:: numInputs
Returns:: The number of inputs for this UGen.

method:: numOutputs
Returns:: The number of outputs for this UGen.

method:: name
Returns:: The Class name of the receiver as a link::Classes/String::.

method:: madd
Wraps the receiver in a link::Classes/MulAdd:: UGen.
discussion::
This is for the most part only used in UGen class definitions in order to allow efficient implementation of code::mul:: and code::add:: arguments.

method:: isValidUGenInput
Returns:: true

method:: asUGenInput
Returns:: the receiver
discussion::
This method is implemented in a number of classes in order to allow objects like link::Classes/Node::s, link::Classes/Bus::ses, and link::Classes/Buffer::s to be passed directly as UGen inputs and link::Classes/Synth:: args.

method:: copy
Returns:: the receiver.
discussion::
Thus UGen-dup effectively returns a reference to the original and is a convenient way to copy a mono signal to multiple channels.
code::
{ SinOsc.ar(Rand(200, 4000), 0, 0.2).dup }.plot // this is the same UGen
::
Function-dup evaluates that function multiple times, thus potentially returning distinct UGens.
code::
{ { SinOsc.ar(Rand(200, 4000), 0, 0.2) }.dup }.plot // these are different UGens
::


subsection:: Internally used instance methods

method:: methodSelectorForRate
See link::#*methodSelectorForRate::

method:: init
By default, this method stores the inputs (e.g. the arguments to code::*ar:: and code::*kr::) in the UGen.
discussion::
This may be overridden to do other initialisations, as long as the inputs are set correctly.

subsection:: Bela

method:: belaScope
Send this UGen's output to Bela's Oscilloscope (see link::Classes/BelaScope:: for required setup)
argument:: channelOffset
Bela's oscilloscope channel to start scoping on. This has to be a non-negative number, and can't be changed after scoping starts.

argument:: server
The server on which BelaScope is running. If not specified, it looks for the first server for which BelaScope was already initialized. If none is found, it attempts to initialize a link::Classes/BelaScope:: instance on link::Classes/Server#*default::.
returns:: This UGen.


class::UnaryOpFunction
summary::represent a unary operation on a function
related:: Classes/UnaryOpStream, Classes/Punop, Classes/BinaryOpFunction, Classes/NAryOpFunction, Overviews/Operators
categories::Core

description::
Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

examples::

code::
a = 2.sqrt; // result is square root of two (approximate floating point).
a = { b }.sqrt; // result is  a UnaryOpFunction
b = 2;
a.value; // now it is evaluated, and the result is calculated
b = 9;
a.value; // again, with a different value.
::

code::
// sound example
(
var a = { 19.rand };
var b = a.sqrt;
fork {
	15.do {
		(instrument: \default, note: [a.value, b.value]).play;
		0.3.wait;
	}
}
)
::


class:: UnaryOpStream
summary:: stream modified by a unary operator
related:: Classes/BinaryOpStream, Classes/NAryOpStream
categories:: Streams-Patterns-Events

description::

A UnaryOpStream is created as a result of a unary math operation on a Stream. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from the stream. It responds to strong::reset:: by resetting the Stream.

Examples::

code::
x = Routine { 6.do { arg i; i.yield; } }.squared;
x.dump;
::

code::
(
x = Routine { 6.do { arg i; i.yield; } }.squared;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
::


class:: UnaryOpUGen
summary:: Apply a unary operation to the values of an input ugen
categories:: UGens>Algebraic
related:: Classes/BinaryOpUGen, Classes/UnaryOpFunction, Classes/Punop, Overviews/Operators

description::
UnaryOpUGens are created as the result of a unary operator applied to a link::Classes/UGen::.
code::
(SinOsc.ar(200).abs).dump;
(LFSaw.ar(200).sin).dump;
::
As in the examples given here, you don't usually need to instantiate UnaryOpUGen yourself.

The unary and binary operators are defined in link::Classes/UGen::'s superclass link::Classes/AbstractFunction::, which creates the
BinaryOpUGen as a result of the operation.

See link::Overviews/Operators:: for an overview of common operators.

classmethods::

method::new
return a new instance that applies the operator code::selector:: to the ugen code::a::

argument:: selector
The selector symbol for the unary operator
argument:: a
operand

examples::
code::
a = WhiteNoise.ar; // a WhiteNoise
b = a.squared; // a UnaryOpUGen.
b.operator; // squared

// sound example

{ var a = LFSaw.ar(300).range(0, 2pi); a.sin * 0.1 }.play;

// Plotting the "abs" unary operator (via the server):

{ SinOsc.ar(300).abs }.plot
::


class::UniqueID
summary::source for unique numbers
categories::Core

classmethods::

method::initClass

initialize the starting id.

method::next

get next id, which is unique to the system

examples::

code::
// example
UniqueID.next;
UniqueID.next;
UniqueID.next;
::


TITLE:: UnitTest
summary:: a class for programmatic testing of classes
categories:: Testing
related:: Classes/UnitTestResult, Classes/UnitTestScript

DESCRIPTION::
In order to make sure a method works correctly, a test can be implemented that assures the correct behavior.

It is a common practice to write tests to clarify how an object should respond, and it may avoid inconsistencies on the long run. A test is always a subclass of code::UnitTest::, implementing at least one method starting with code::test_::.

When running all tests of one class (see link::#run::), each test method is called in a separate instance of this class. Test methods, therefore, do not interfere with each other.

note::
UnitTests for the Common library classes are kept in the code::testsuite/classlibrary:: directory of the SuperCollider sources.

To install, link::https://github.com/supercollider/supercollider##download the sources:: and add the directory to your code::sclang_conf.yaml::, either by editing it or via the ScIDE preferences.
::


CLASSMETHODS::

PRIVATE:: allTestClasses, classesWithTests, classesWithoutTests, failures, findTestClass, findTestClasses, findTestMethods, findTestedClass, forkIfNeeded, listUntestedMethods, passes, report, reset, run, untestedMethods

METHOD:: gui
A graphical interface to run and browse all tests

code::
UnitTest.gui
::

METHOD:: reportPasses
Accessor controlling whether passing tests should be reported.
Defaults to code::true::.  See also link::#*passVerbosity:: which
controls how much detail is reported from passing tests
when this is set to true.

ARGUMENT:: value
Should be code::true:: or code::false::.

METHOD:: passVerbosity
Accessor controlling whether extra details should be reported for
passing tests.

Defaults to code::UnitTest.full:: so that all details are reported;
however this behaviour may be too verbose for some, for whom it is
sufficient to see that a test is passing without needing to see the
detail.  If set to code::UnitTest.brief::, and link::#*reportPasses::
is true, passes will be reported, but without any extra details which
may be provided by assertions.

ARGUMENT:: value
Should be code::UnitTest.full:: or code::UnitTest.brief::.

METHOD:: run
Run all methods whose names begin with code::test_::.

code::
TestUnitTest.new.run;
::

ARGUMENT:: reset
If code::true::, first runs link::#*reset:: on the class.

ARGUMENT:: report
If code::true::, outputs the test results.

METHOD:: runTest
Run a single test method.

code::
UnitTest.reset;
UnitTest.runTest("TestUnitTest:test_assert");
::

ARGUMENT:: methodName
A link::Classes/String:: referring to the class and test method
within it, e.g. code::"TestPolyPlayerPool:test_prepareChildrenToBundle"::.


METHOD:: runAll
Run the entire test suite. As this method addresses the entire test suite, it should be called only on code::UnitTest::. Calling it on any of its subclasses will result in throwing an code::Error::.

code::
UnitTest.reset;
UnitTest.runAll;
::


INSTANCEMETHODS::

METHOD:: runTestMethod
Run a single test method of this class

code::
TestUnitTest.new.runTestMethod(TestUnitTest.findMethod(\test_assert));
::

ARGUMENT:: method
the method to run

ARGUMENT:: report
Reports the result of the test if code::true:: (default is code::true::)

returns:: (describe returnvalue here)

PRIVATE:: s, run, findTestMethods, setUp, tearDown


METHOD:: assert

Asserts that an expression must be true.

code::
this.assert(2 == 2, "passes");
this.assert(2 == 2.00001, "fails");
::

argument:: boolean
A boolean, where code::true:: means that the test is passed.

argument:: message
A message describing the purpose of the assertion, e.g. code::"foo
should be less than bar"::.
Posted if code::report:: is true.

argument:: report
Reports the result of the test if code::true::.

argument:: onFailure
If not code::nil::, a failure stops the tests and evaluates this function.

argument:: details
Some optional extra details which will be passed to the reporting framework
for display unless brief reporting is requested (see link::#*passVerbosity::).

METHOD:: assertEquals

Asserts that an expression code::a:: is equal to the value code::b::,
where equality is determined according to code::a::'s implementation
of code::==::.

Automatically passes details of the equality check to the reporting
framework, which will be displayed if the assertion fails, and also if
it passes and link::#*reportPasses:: is code::true:: and
link::#*passVerbosity:: is not set to code::UnitTest.brief::.

code::
this.assertEquals(2 + 2, 4, "passes");
this.assertEquals(2 + 2, 5, "fails");
::

argument:: a
the experimentally produced value

argument:: b
the expected value

argument:: message
A message describing the purpose of the assertion, e.g.
code::"Adding two numbers should return their sum."::.
Posted if code::report:: is true.

argument:: report
Reports the result of the test if code::true:: (default is code::true::)

argument:: onFailure
If not code::nil::, a failure stops the tests and evaluates this function.

METHOD:: assertFloatEquals

Asserts that an expression code::a:: returning a float is within a
given range (code::within::) of being equal to code::b::.

Automatically passes details of the equality check to the reporting
framework, which will be displayed if the assertion fails, and also if
it passes and link::#*reportPasses:: is code::true:: and
link::#*passVerbosity:: is not set to code::UnitTest.brief::.

code::
this.assertFloatEquals(2, 2.0001, "Pass since 2 is close enough to 2.0001.", 0.001);
this.assertFloatEquals(2, 2.0001, "Fail since 2 isn't close enough to 2.0001.", 0.0001);
::

argument:: a
the experimentally produced float value

argument:: b
the expected float value

argument:: message
A message describing the purpose of the assertion, e.g.
code::"Adding two numbers should return their sum."::.
Posted if code::report:: is true.

argument:: within
The range within which code::a:: must be of code::b:: in
order for the test to pass.

argument:: report
Reports the result of the test if code::true:: (default is code::true::)

argument:: onFailure
If not code::nil::, a failure stops the tests and evaluates this function.


METHOD:: assertArrayFloatEquals
Make sure that the two arrays of floats code::a:: and code::b:: equal within a given range (code::within::).

code::
this.assertArrayFloatEquals([2, 3] + 0.0001, [2, 3], "Pass since pairs of floats are close enough", 0.001);
this.assertArrayFloatEquals([2, 3.0001], [2, 3], "Fail since pairs of floats aren't both close enough", 0.0001);
::

argument:: a
the experimentally produced value, which is an code::Array:: of floats

argument:: b
the code::Array:: of float values expected

argument:: message
A message describing the purpose of the assertion, e.g.
code::"Arrays foo and bar should be equal."::.
Posted if code::report:: is true.

argument:: within
The range within which each item of code::a:: must be of the
corresponding item in code::b:: in order for the test to pass.

argument:: report
Reports the result of the test if code::true:: (default is code::true::)

argument:: onFailure
If not code::nil::, a failure stops the tests and evaluates this function.


METHOD:: ifAsserts
Make a further assertion only if it passed, or only if it failed.

code::
(
a = UnitTest.new;
a.ifAsserts(2 == 3, "yes", { a.assert(2 == 4) }, { a.assert(1 == 1, "but this is correct") });
)
::

method::assertException
Make sure that a specific link::Classes/Exception:: or link::Classes/Error:: is thrown.

argument:: func
Pass the code that is expected to throw an error in this function.

argument:: errorClass
The class or class name which the error should be kind of.

argument:: message
A message describing the purpose of the assertion.

argument:: report
Reports the result of the test if code::true:: (default is code::true::)

argument:: onFailure
If not code::nil::, a failure stops the tests and evaluates this function.

argument:: details
Some optional extra details which will be passed to the reporting framework
for display unless brief reporting is requested (see link::#*passVerbosity::).

method::assertNoException
Make sure that a specific link::Classes/Exception:: or link::Classes/Error:: is strong::not:: thrown.
For arguments, see link::#-assertException::.


method::wait
Wait for a predicate function to return code::true::. Considers the test failed after code::maxTime::. Only valid within a test (or a routine).

note:: It's best to avoid using this method in tests. See link::Classes/CondVar#-waitFor:: for a better option.::

code::
(
{
	s.reboot;
	UnitTest.new.wait({ s.serverRunning }, "server failed to boot in time", 2);
}.fork
)
::

METHOD:: bootServer
Wait for server boot until continued. Only valid within a test (or a routine).

If already booted, then freeAll and create new allocators.

code::
(
{
	UnitTest.new.bootServer(s);
}.fork
)
::

METHOD:: debug
Supply some debugging information relevant to the currently running
test case.  This will be displayed immediately preceding any details
which may be displayed through use of the code::details:: argument of
link::#-passed:: and link::#-failed::.

ARGUMENT:: text
The debugging text.

DISCUSSION::
code::
test_myMethod {
    var obj = MyClass.new;
    this.debug("obj has color" + obj.color);
    this.assert(2 + 2, 5);
}
::

will result in:

code::
FAIL: a TestMyClass: test_myMethod
obj has color red
Is:
         4
Should be:
         5
::

METHOD:: passed
Register a passed test.

ARGUMENT:: method
Name of the method in which the test is passing.

ARGUMENT:: message
A message describing the purpose of the assertion, e.g. code::"foo
should be less than bar"::.
Posted if neither code::report:: nor link::#*reportPasses:: are false.

argument:: report
Reports the result of the test if true and link::#*reportPasses:: is true.

argument:: details
Some optional extra details which will be displayed if
link::#*reportPasses:: is true and link::#*passVerbosity:: is
not set to code::UnitTest.brief::.

DISCUSSION::
code::
this.passed(message: "this passed");
::

METHOD:: failed
Register a test failure.

ARGUMENT:: method
Name of the method in which the test is failing.

ARGUMENT:: message
A message describing the purpose of the assertion, e.g. code::"foo
should be less than bar"::.
Posted if code::report:: is true.

argument:: report
Reports the result of the test if true.

argument:: details
Some optional extra details which will be displayed if code::report::
is true.

DISCUSSION::
code::
this.failed(message: "this failed");
::

EXAMPLES::

Write tests by subclassing UnitTest, and defining methods whose names
begins code::test_::.  Each test method will be called from a fresh
instance of the subclass.

If you implement the methods code::setUp:: and code::tearDown:: in
your test class, they will be called before and after every test.
This can help to eliminate repetitive code, and makes it easier to
maintain your tests by ensuring that they all run under the same set
of conditions.

code::
TestYourClass : UnitTest {
	setUp {
		// this will be called before each test
	}
	tearDown {
		// this will be called after each test
	}

	test_yourMethod {
		// every method whose name begins with "test_" will be run
		var synth;

		this.assert( 6 == 6, "6 should equal 6");

		this.assertEquals( 9, 9, "9 should equal 9");

		this.assertFloatEquals( 4.0, 1.0 * 4.0 / 4.0 * 4.0,
			"floating point math should be close to equal");

		// we are inside a Routine, you may wait
		1.0.wait;

		// this will wait until the server is booted
		// if the server is already booted it will free all nodes
		// and create new allocators, giving you a clean slate
		this.bootServer;

		synth = { SinOsc.ar / 10 }.play;
		synth.register; 

		// will wait until the condition is true
		// will be considered a failure after 10 seconds
		this.wait({ synth.isPlaying }, "waiting for synth to play", 10);
	}
}
::


TITLE:: UnitTestScript
summary:: run test scripts
categories:: Testing
related:: Classes/UnitTest, Classes/UnitTestResult

DESCRIPTION::
In order to make sure a method works correctly, a test can be implemented that assures the correct behavior.

It is a common practice to write tests to clarify how an object should respond, and it may avoid inconsistencies on the long run.

Test scripts are simply plain text files ending with TELETYPE::_unittest.scd::, which are interpreted.
Scripts may be located next to a class in the classpath or one folder below.
If they return a function, the code::UnitTestScript:: is passed in, allowing to call methods like assert etc. (see link::Classes/UnitTest::)

code::UnitTestScript:: mimics some of the behavior of link::Classes/Method::, to be compatible with link::Classes/UnitTest::.






CLASSMETHODS::
PRIVATE:: initClass, findTestScripts, new, findTestMethods, allScripts, runTest

INSTANCEMETHODS::

PRIVATE:: name, path, init, runScript

EXAMPLES::

An example script

NOTE::
This should be in a file TELETYPE::myUnitTest_unittest.scd::
::

code::
{ |test|
	"Kant test".postln;
	"5 + 7 = ".post;
	(5 + 7).postln;
	test.assertEquals(5 + 7, 12, "five plus seven should always be twelve");
}
::

To run only the test scripts:

code::
UnitTestScript.run;
::

The scripts are to be found under the class UnitTestScript in the GUI:

code::
UnitTest.gui
::


class:: UnixFILE
summary:: An abstract class
related:: Classes/File, Classes/Pipe
categories:: Files

InstanceMethods::

private::prGetLine, addOpenFile

method::isOpen
Returns whether the file is open. An open request can fail if a file cannot be found for example. This method lets you test that the open call succeeded.

method::pos
Answer the current file position

argument::offset
an offset in bytes.

argument::origin
one of the following link::Classes/Integer::s:
definitionList::
## 0 || seek from beginning of file.
## 1 || seek from current position in file.
## 2 || seek from end of file.
::

method::write
Writes an item to the file.

argument::item
one of the following:
definitionList::
## link::Classes/Float:: ||
## link::Classes/Integer:: ||
## link::Classes/Char:: ||
## link::Classes/Color:: ||
## link::Classes/Symbol:: || writes the name of the Symbol as a C string.
## link::Classes/RawArray:: || write the bytes from any RawArray in big endian.
::

method::getLine
reads and returns a link::Classes/String:: up to lesser of next newline or 1023 chars.

method::getChar
read one byte and return as a link::Classes/Char::.

method::getInt8
read one byte and return as a link::Classes/Integer::.

method::getInt16
read two bytes and return as an link::Classes/Integer::.

method::getInt32
read four bytes and return as an link::Classes/Integer::.

method::getFloat
read four bytes and return as a link::Classes/Float::.

method::getDouble
read eight bytes and return as a link::Classes/Float::.

method::getPascalString
Reads the next byte as an unsigned integer N, then reads the following N bytes and returns them as a link::Classes/String::.

method::putChar
write a link::Classes/Char:: as one byte.

method::putInt8
write an link::Classes/Integer:: as one byte. That is a signed link::Classes/Integer:: value between -128 and 127.

method::putInt16
write an link::Classes/Integer:: as two bytes.

method::putInt32
write an link::Classes/Integer:: as four bytes.

method::putFloat
write a link::Classes/Float:: as four bytes.

method::putDouble
write a link::Classes/Float:: as eight bytes.

method::putString
write a null terminated link::Classes/String::.

method::putPascalString
Writes code::aString:: preceded by its length represented as a single byte.
Throws an error if code::aString:: is longer than 255 characters.

method::putString0
Writes code::aString:: followed by a zero byte, like a null-terminated C string.


class:: Unpack1FFT
summary:: Unpack a single value (magnitude or phase) from an FFT chain
categories:: UGens>FFT, UGens>Demand
related:: Classes/PackFFT, Classes/UnpackFFT, Guides/FFT-Overview


Unpack1FFT(chain, bufsize, binindex, whichmeasure=0)

description::
Takes an FFT chain and extracts a single scalar value as a demand-rate stream. To call it, a "demander" is needed, which fires whenever the FFT chain fires - this is normally achieved using link::Classes/PackFFT:: but can also be done using link::Classes/Demand::.

Note::
This UGen is commonly not used directly. Its main purpose is as a component in link::Classes/PV_ChainUGen#-pvcollect::, link::Classes/PV_ChainUGen#-pvcalc::, and link::Classes/PV_ChainUGen#-pvcalc2:: processes. You're welcome to use it on its own - the example below shows how.
::

classmethods::
private:: categories

method:: new

argument:: chain
an FFT chain
argument:: bufsize
the size of the expected input FFT frames
argument:: binindex
the integer index of the bin you want to query
argument:: whichmeasure
0 for magnitude and 1 for phase. None of these arguments can be modulated.

discussion::
code::

// Let's extract the DC component - i.e. the magnitude at binindex zero.
(
{
	var sig, chain, stream, windowStarts, demand;
	var fftsize = 1024;

	sig = SinOsc.ar(LFDNoise3.kr(LFNoise0.kr(1) * 40 + 60) * 700 + 800);

	chain = FFT(LocalBuf(fftsize), sig);
	stream = Unpack1FFT(chain, bufsize: fftsize, binindex: 0, whichmeasure: 0);

	// each time an FFT window starts, the unpacker returns a new value
	windowStarts = chain > -1;
	demand = Demand.kr(windowStarts, 0, stream);
	demand.poll(windowStarts);

	sig * 0.05
}.play
)
::


class:: UnpackFFT
summary:: Unpack an FFT chain into separate demand-rate FFT bin streams
categories:: UGens>FFT, UGens>Demand
related:: Classes/PackFFT, Classes/Unpack1FFT

description::
Takes an FFT chain and separates the magnitude and phase data into separate demand-rate streams, for arithmetic manipulation etc.

This is technically a demand-rate UGen. The actual "demand" is usually created by PackFFT later on in the graph, which requests the values in order to re-pack the data. This allows for processing to occur in between.

See also link::Classes/PV_ChainUGen#-pvcollect::, link::Classes/PV_ChainUGen#-pvcalc::, and link::Classes/PV_ChainUGen#-pvcalc2::, which provide convenient ways to process audio in the frequency domain. The help for pvcollect includes notes on efficiency considerations.

classmethods::
private:: categories

method:: new
argument:: chain
FFT chain
argument:: bufsize
FFT buffer size
argument:: frombin
limiting analysis to the bins of interest
argument:: tobin
limiting analysis to the bins of interest
returns::
A list from DC up to Nyquist of code:: [mag[0], phase[0], mag[1], phase[1], ... mag[nyquist], phase[nyquist]]. ::
discussion::
Note that you do have to decide your FFT buffer size in advance, since this determines how many values the UGen will output.
code::
#magsphases = UnpackFFT(chain, bufsize)
::

examples::
code::

// This one just drags out various the values and posts them - a little bit pointless!
(
{
	var sig, chain, stream, windowStarts, fftSize;
	fftSize = 1024;

	sig = SinOsc.ar(LFDNoise3.kr(LFNoise0.kr(1) * 40 + 60) * 700 + 800);
	chain = FFT(LocalBuf(1, fftSize), sig);

	// a window start is indicated by a signal leaving the -1 bottom line
	windowStarts = chain > -1;

	// Using the frombin & tobin args makes it much more efficient, limiting analysis to the bins of interest
	stream = UnpackFFT(chain, fftSize, frombin: 0, tobin: 4);

	// Demand some data from the unpacker.
	// NOTE: At present, Demand.kr is unable to handle more than 32 inputs,
	// so using frombin & tobin to limit the number of bins is compulsory.

	Demand.kr(windowStarts, 0, stream).collect { |anunp, index|
		var label = if(index.even) { "Magnitude" } { "Phase" };
		label = label + (index / 2).floor;
		anunp.poll(windowStarts, label)
	};

	sig * 0.05
}.play
)

// simple frequency-domain manipulation, square-rooting the magnitudes AND phases.
(
x = {
	var sig, chain, magsphases, b;
	b = LocalBuf(1, 1024);
	sig = SinOsc.ar(LFDNoise3.kr(LFNoise0.kr(1) * 40 + 60) * 700 + 800);
	chain = FFT(b, sig);
	magsphases = UnpackFFT(chain, b.numFrames);
	magsphases = magsphases.collect(_.sqrt);
	chain = PackFFT(chain, b.numFrames, magsphases);
	IFFT(chain) * 0.1
}.play
)
::



CLASS:: UserView
summary:: A custom drawn view using Pen
categories:: GUI>Views
related:: Classes/Pen

DESCRIPTION::
An empty view on which you can draw using the link::Classes/Pen:: class.

This view displays and does nothing by itself, but allows you to define how it will be drawn, and expects you to define its entire mode of interaction using mouse, key, and drag and drop actions.

To define how the view is drawn you set the link::#-drawFunc:: variable to a link::Classes/Function:: within which you can use the link::Classes/Pen:: class to draw graphical primitives, such as lines, rectangles, ellipses, curves, and also text.

This class offers convenient mechanisms for creating animations, that is, to automatically redraw itself in regular time intervals. See the link::#Animation:: section of this document.

For a guide to using this view, see link::Guides/GUI-Introduction#Custom views::.

note:: Older tutorials might recommend subclassing UserView. Don't do that. Use composition, not inheritance. Make the UserView a property of your custom view class. ::

CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Drawing

METHOD:: drawFunc

	Sets the Function to evaluate whenever the view is asked to redraw itself. This may be, for example, due to being hidden and shown again, being resized, another view moving on top of it, or after the link::Classes/View#-refresh:: method has been called.

	Within that Function you are allowed to use the link::Classes/Pen:: class to draw within the bounds of the view. All the coordinates given to the methods of Pen are relative to the top-left corner of the view. Usage of Pen is not allowed outside of that Function.

	The Function will be passed this view as the argument when evaluated.

argument::
	A Function.


METHOD:: background
	Sets the color used to fill the whole area occupied by the view below the drawing done in link::#-drawFunc::. You can set the background at any moment, even within the code::drawFunc::, but any drawing done in that Function will always be displayed on top of the background.

	argument::
		A Color.

METHOD:: drawingEnabled
	Whether the link::#-drawFunc:: will be called when the view is redrawing itself. Note that link::#-background:: will be painted regardless of this variable.

	The default value is code::true::.

	argument::
		A Boolean.

METHOD:: clearOnRefresh
	Whether the view shall clear the last drawing done in link::#-drawFunc:: before being redrawn.

	If this is code::false::, the view will continuously draw on top of all the previous drawing whenever it is redrawn, until link::#-clearDrawing:: is called.

	The default value is code::true::.

	argument::
		A Boolean.

METHOD:: clearDrawing
	If link::#-clearOnRefresh:: is code::false::, you can call this method to manually clear any drawing done in link::#-drawFunc:: so far.



SUBSECTION:: Animation

METHOD:: animate
	Whether the view shall redraw itself internally at a regular time interval (frame rate). See link::#-frameRate:: for the way to adjust that interval.

	The default value is code::false::.

	argument::
		A Boolean.

METHOD:: frameRate
	The interval at which the view regularly redraws itself, if link::#-animate:: is code::true::. You can change the desired frame rate by setting this variable.


	The default frame rate is 60fps.

	note:: Getting the value of this variable will return the average actual frame rate. If it is lower than the desired frame rate set as described above, that implies that the view tries but does not manage to redraw itself at that frame rate. The reason may typically be that the drawing defined in link::#-drawFunc:: is computationally too demanding for the system.
	::

argument:: fps
	A Float defining the interval between frames of animation, in frames per second.

METHOD:: frame

	The count of frames drawn while link::#-animate:: is code::true::; it will increase by 1 every time the view is redrawn.

	If animation is stopped and started again (by setting code::animate:: to code::false:: and then code::true:: again), the frame count is restarted.

	returns:: An Integer.



SUBSECTION:: Actions

	The UserView by itself does not respond to any interaction by the user. You can define the modes of interaction entirely on your own using mouse and keyboard actions. See link::Guides/GUI-Introduction#Actions and hooks: Make that button do something!#Actions and Hooks:: for detailed explanation.

	Note that there is no default mode of interaction with the UserView, so link::Classes/View#-action:: will never be triggered, if you don't implement that yourself.

EXAMPLES::

'Introduction to GUI' contains an link::Guides/GUI-Introduction#Custom views#example:: with elaborate explanation on how to use UserView. Below are further examples.

SUBSECTION:: Basic Usage

Resize the window or click on the UserView to refresh the drawing:

code::
(
w=Window.new;
v=UserView(w, w.view.bounds.insetBy(50,50));
v.resize = 5;
v.background_(Color.rand);
v.drawFunc={|uview|
		Pen.moveTo(0@uview.bounds.height.rand);
		Pen.lineTo(uview.bounds.width@uview.bounds.height.rand);
		Pen.stroke;
	};
v.mouseDownAction={v.refresh};
w.front;
)
::

Coordinates are relative to the UserView. Try resizing the window:

code::
(
var func;

func = {|me|
	Pen.use{
		10.do{
			Color.red(rrand(0.0, 1), rrand(0.0, 0.5)).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 100), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

w = Window.new("DrawFunc Examples").front;
w.view.background_(Color.white);

3.do{|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100))
		.drawFunc_(func);
	v.resize=3; // the func coordinates ar valid even though the view move on resize
	v.background_(Color.rand);
};

w.refresh;
)
::

SUBSECTION:: Responding to mouse clicks and movement

Using link::Classes/View#Mouse actions#mouse actions:: you can make UserView change the way it is drawn in response to mouse interaction. The sequence of examples below will guide you through the various possibilities.

Clicking and moving the mouse on each of the painted squares in the following example will redraw them differently. See interpreter output for posted information that you can use in the mouse actions.

code::
// drag some circles
(
var w, r, u;
var clicked, relativeWhere;
r = { Rect(300.rand, 300.rand, 110, 110) } ! 4;

w = Window.new.front;
u = UserView(w, Rect(0, 0, 400, 400));
u.drawFunc = {
	r.do { |x, i|
		Pen.addOval(x); // wie addRect
		Pen.color = Color.hsv(0.9 * (1/(i+1)), 0.6, 1);
		Pen.draw;
	};
};
u.mouseDownAction = { |v, x, y|
	r.do { |rect, i|
		if(rect.contains(Point(x, y))) {
			clicked = i;
			relativeWhere = Point(x, y) - rect.origin;
		};
	};
};

u.mouseMoveAction = { |v, x, y|
	var rect;
	if(clicked.notNil) {
		rect = r.at(clicked);
		r.put(clicked, rect.origin = Point(x, y) - relativeWhere);
		w.refresh;
	}
};

u.mouseUpAction = {
	clicked = nil;
}
)


::

code::
// draw some random shapes
(
var drawFunc, mouseDownFunc, mouseUpFunc, mouseMoveFunc, sat = 0, startX;

drawFunc = {|me|
	Pen.use{
		10.do{
			Color.red(rrand(0.0, 1), rrand(0.3, 0.8)).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 50), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

mouseDownFunc = {|me, x, y, mod|
	startX = x;
	postf("begin path: x=% realtive mouse coordinates:%\n",startX, x@y);
};

mouseUpFunc = {|me, x, y, mod|
	postf("end path: (startX-x)==% mouse coordinates:%\n",(startX-x), x@y);
};

mouseMoveFunc = {|me, x, y, mod|
	sat = ((startX-x)/100);
	(x@y).postln;
	me.refresh;
};

w = Window.new.front;
w.view.background_(Color.white);
3.do{|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100));
	v.background_(Color.rand);
	v.drawFunc = drawFunc;
	v.mouseDownAction = mouseDownFunc;
	v.mouseUpAction = mouseUpFunc;
	v.mouseMoveAction = mouseMoveFunc;
};
w.refresh;
)
::

The following example uses the link::#-clearOnRefresh:: option to prevent the UserView from clearing its contents when redrawn. Clicking and moving the mouse within each square will draw ever more arcs on top of each other.

code::
(
var func, views;

func = {|me|
	Pen.use{
		1.do{
			Color(
				rrand(0.0, 1),
				rrand(0.0,0.2),
				rrand(0.0, 0.8),
				rrand(0.4, 0.8)
			).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 50), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

w = Window.new("DrawFunc Examples").front;
w.view.background_(Color.white);
views = {|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100));
	v.background = Color.rand;
	v.drawFunc = func;
	v.mouseMoveAction = {|me| me.refresh };
	v.clearOnRefresh_(false);
} ! 3;
w.refresh;
)
::

The following example uses the link::#-clearOnRefresh:: option to keep the old contents when redrawn, allowing you to draw a line which follows the mouse cursor by clicking and dragging on the view.

It also uses the mouse position to compute the color of the line.

code::
(
var w, txt, lines, points, drawLine;

drawLine = { |points, bounds|
	var p0;
	points.do { |p,i|
		if(i == 0){
			p0 = p;
		}{
			Pen.moveTo(p0);
			Pen.lineTo(p);
			Color(
				(p.x/bounds.width).clip(0,1),
				1.0-(p.x/bounds.width).clip(0,1),
				(p.y/bounds.height).clip(0,1)
			).set;
			Pen.stroke;
			p0 = p;
		}
	};
};

w = Window("draw on me", Rect(128, 64, 340, 360));

v = UserView(w,w.view.bounds)
	.clearOnRefresh_(false)
	.mouseDownAction_({|v,x,y|
		points = [x@y];
	})
	.mouseMoveAction_({|v,x,y|
		points = points.add(x@y);
		v.refresh;
	})
	.mouseUpAction_({|v,x,y|
		points = points.add(x@y);
		lines = lines.add(points);
		points = nil;
		v.refresh;
	})
	.background_(Color.white)
	.drawFunc_{|me|
		var r = me.bounds;

		Pen.use {
			Pen.width = 1;
			Color.black.set;

			lines.do { |linePoints|
				drawLine.value(linePoints, r);
			};
			lines = nil;

			drawLine.value(points, r);
			if( points.size > 0 ) { points = [points.last] };
		};
	};

w.front;
)
::

SUBSECTION:: Animation

The following is an animation with mouse interaction. Click and drag in the view to move the center of the rotating object.

code::
(
var width = 400, height = 400, mx = 0, my = 0, pt, r;

w = Window("animation and mouse interaction", Rect(100, 200, width, height), false);

u = UserView(w, Rect(0, 0, width, height));
u.background = Color.black;
u.animate = true; //animate this view

// allocate data in advance, for optimization:
pt = Point();
r = Rect();

u.drawFunc = {
	Pen.fillColor = Color.green;
	Pen.stringAtPoint(u.frameRate.asString, Point(10, 10)); // display frame rate
	Pen.stringAtPoint(u.frame.asString, Point(10, 30)); // display frame counter
	Pen.color = Color.white;
	pt.x=mx;
	pt.y=my;
	100.do{|i|
		Pen.moveTo(pt);
		pt.x = sin(u.frame*0.04.neg+i)*(5*i)+mx; //use .frame to drive animation
		pt.y = cos(u.frame*0.05+i)*(5*i)+my;
		r.left=pt.x;
		r.top=pt.y;
		r.width=i;
		r.height=i;
		Pen.lineTo(pt);
		Pen.fillStroke;
		Pen.addOval(r);
		Pen.fillStroke;
	};
};
u.mouseDownAction = {|v, x, y|
	mx = x;
	my = y;
};
u.mouseMoveAction = u.mouseDownAction;
w.front;
)

u.animate = false; //animation can be paused and resumed
u.animate = true;
w.close; //stops animation
::

A simple ball animation:

code::
(
var width = 400, height = 400, xspeed = 3, yspeed = 2, x = width*0.5, y = height*0.5;
w = Window("ball", Rect(100, 200, width, height));
u = UserView(w, Rect(0, 0, width, height));
u.background = Color.black;
u.animate = true;
u.drawFunc = {
	if(x<0 or:{x>width}, {xspeed = 0-xspeed});
	if(y<0 or:{y>height}, {yspeed = 0-yspeed});
	x = x+xspeed;
	y = y+yspeed;
	Pen.fillColor = Color.white;
	Pen.fillOval(Rect.aboutPoint(Point(x, y), 8, 8));
};
w.front;
)

( //replace the drawFunc above while running
u.drawFunc = {
	Pen.fillColor = Color.red;
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.031)*200, sin(u.frame*0.044)*200));
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.052)*200, sin(u.frame*0.065)*200));
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.073)*200, sin(u.frame*0.086)*200));
}
)

//close the window to stop
w.close;
::

An animation that makes a good use of the link::#-clearOnRefresh:: option to keep the old contents when redrawing.

code::
(
var width = 640, height = 480, w, theta = 0, drawFunc;
w = Window( "trails", Rect( 128, 64, width, height ), false );
drawFunc = { arg view;
	var x = 20 * sin( theta ), y = 42 * cos( theta );
	theta = theta + 0.01;
	//draw a semitransparent rect filling the screen:
	Pen.fillColor_( Color.red( 0.2, 0.1 ));
	Pen.fillRect( Rect( 0, 0, width, height ));
	Pen.strokeColor_( Color.white );
	Pen.translate( width * 0.5, height * 0.5 );
	6.do { arg i;
		Pen.rotate( theta * (1 - (i / 6)) );
		Pen.scale( 0.7 + (i * 0.4), 0.4 + (i * 0.5) );
		Pen.strokeOval( Rect.aboutPoint( Point( x, y ), 60, 40 ));
	};
};
x = UserView( w, Rect( 10, 10, width - 20, height - 20 ))
	.canFocus_( false )
	.drawFunc_( drawFunc )
	.clearOnRefresh_( false );

w.front;
x.animate = true
)
::

SUBSECTION:: Usage of refreshInRect(aRect)

note:: This functionality is only available in strong::Cocoa GUI:: ::

The code::refreshInRect:: method constrains the receiver's refresh area to the rectangle passed in aRect. You may use Quartz Debug's flash screen updates to see the refresh area of the view

code::
(
var userView, win, blob = Rect(0, 0, 50, 50), trackblob=false, pmouse;

a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");

win = SCWindow.new("refreshInRect Test", Rect(400, 400, 600, 200), scroll:true).front;
win.onClose_({ a.free; });

userView = SCUserView(win, Rect(10,10,2000,800))
	.backgroundImage_(a, 5)
	.drawFunc_({|me|
		Color.blue.setFill;
		Pen.fillRect(blob);
	})
	.mouseDownAction_({|v, x, y, mod|
		pmouse = x@y;
		trackblob = blob.containsPoint(pmouse);
	})
	.mouseUpAction_({|v, x, y, mod|
		trackblob = false;
	})
	.mouseMoveAction_({|v, x, y, mod|
		var refresh, mouse, delta;
		mouse = x@y;

		if(trackblob, {
			refresh = blob.copy;
			delta = mouse-pmouse;
			blob = blob.moveBy(delta.x, delta.y);
			refresh = refresh.union(blob);
			v.refreshInRect(refresh);
		});
		pmouse = mouse;
	});

blob = blob.moveBy(userView.bounds.left, userView.bounds.top);
userView.bounds.postln;
)
::


class:: VDiskIn
summary:: Stream in audio from a file, with variable rate
categories:: UGens>InOut, UGens>Buffer
related:: Classes/PlayBuf, Classes/BufRd, Classes/DiskIn

description::
Continuously play a longer soundfile from disk. This requires a buffer to be preloaded with one buffer size of sound.

classmethods::
method:: ar

argument:: numChannels
number of channels

argument:: bufnum
buffer number
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument:: rate
controls the rate of playback. Values below 4 are probably fine, but the higher the value, the more disk activity there is, and the more likelihood there will be a problem.

warning::
the rate does have a practical limit. The following must be true: rate < Buffer's size / ( 2 * s.options.blockSize) e.g with typical default values, this will be 32768 / (2 * 64) = 256.
::

If the rate is too high, the UGen will not execute, posting a warning.

argument:: loop
If loop is set to 1, the soundfile will loop.

argument:: sendID
If a sendID is given, the UGen sends an OSC message with this ID and the frame index emphasis::relative to the onset of the Synth:: each time it reloads the buffer: code::['/diskin', nodeID, sendID, frame]::.
The true frame index into the file is determined by the code::startFrame:: given when reading the initial buffer's worth of data, using link::Classes/Buffer#-cueSoundFile:: or link::Classes/Buffer#-read::.
VDiskIn does not have access to the frame index used to cue the buffer. So, the frame index sent by OSC is always 0 at the start of the synth node.
The user is responsible for adding the cue point: code::cueStartFrame + msg[3]::.

discussion::
This UGen will set the link::Classes/Done##'done' flag:: when finished playing.

examples::
code::
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);

x = { VDiskIn.ar(1, b, LFNoise2.kr(0.2).range(0.5, 2), loop:1) }.play;

b.close;

// again
// note the like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0);

x.free; b.close; b.free;


// cue and play right away
(
SynthDef("help-VDiskin", { |out, bufnum = 0|
	Out.ar(out, VDiskIn.ar(1, bufnum, MouseX.kr(0.5, 2.0)));
}).add;
)
(
x = Synth.basicNew("help-VDiskin");
m = { arg buf; x.addToHeadMsg(nil, [\bufnum, buf])};

b = Buffer.cueSoundFile(s,Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff",0,1, completionMessage: m);
)

x.free; b.close; b.free;	// clean up



// sending back the file position.
// note:
// the ugen knows nothing of the loop (apply a modulo).
// if you load another file, you need to free the buffer and re-allocate it (see below)

b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1, bufferSize: 4096);
c = SoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff").info;
x = { VDiskIn.ar(1, b, LFNoise2.kr(0.2).range(0.2, 0.9), 1, sendID: 14) }.play;

// register to receive this message

(
o = OSCFunc({ arg msg;
	var sendID = msg[2];
	var index = msg[3];
	msg.postln;
	"id: % pos: % frames (% sec)\n"
		.postf(sendID, index % c.numFrames, (index % c.numFrames / c.sampleRate));
},'/diskin', s.addr)
);

x.free; b.close; b.free; o.free; // clean up eventually
::

The same example in OSC Messaging style, see link::Guides/NodeMessaging::
code::
// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 1);

// open an input file for this buffer, leave it open
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 65536, 0, 1);

// create a diskin node
s.sendMsg("/s_new", "help-VDiskin", x = s.nextNodeID, 1, 1);

s.sendMsg("/b_close", 0); // close the file (very important!)


// again
// don't need to reallocate and Synth is still reading
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 0, 0, 1);

s.sendMsg("/n_free", x); // stop reading

s.sendMsg("/b_close", 0); // close the file.

s.sendMsg("/b_free", 0); // frees the buffer
::


CLASS:: VLayout
summary:: A layout that distributes views in a vertical line
categories:: GUI>Layout
related:: Classes/HLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

DESCRIPTION::
See documentation of superclass link::Classes/LineLayout:: for details.

CLASSMETHODS::

PRIVATE:: key
PRIVATE:: layoutClass


class:: VLayoutView
summary:: A container view that arranges its children vertically
categories:: GUI>Views
related:: Classes/HLayoutView, Classes/CompositeView

DESCRIPTION::

note::
In Qt GUI, this class has been rendered strong::obsolete:: by a special set of layout classes; they are easier to use and more flexible. See link::Classes/VLayout:: for an equivalent to this class, and link::Guides/GUI-Layout-Management:: for a general description of the Qt layout system.
::

VLayoutView can be a parent to other views, and it automatically arranges its child views in vertical order, expanding their width to its own bounds. Only the height of the children is relevant.

When arranging its children, VLayoutView takes the values of their 'minHeight' and 'maxHeight' properties into account. This is useful when a child's link::Classes/View#-resize#resize:: mode is set to 4, 5, or 6. See link::#examples:: below.

VLayoutView inherits some useful formatting methods from its superclasses.

note::
VLayoutView is designed mainly for grouping and placing widgets. While you can set it to accept key presses, it does not accept mouse clicks or drags.
::

CLASSMETHODS::
PRIVATE:: key

EXAMPLES::

code::
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));

Array.fill(q,{ arg i;
    Slider(v,Rect(0,0,75,20)).value_(i / q)
});

w.front
)

// show the area of the view.
v.background_(Color.rand) // The sliders automatically expand to the optimal width
::


Stretching the layout view; Slider height is fixed:

code::
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.background_(Color.rand);
v.resize = 5; // elastic
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,55,20));// The bounds.width are irrelevant here. They expand to the optimal width
    s.value = i / q;
    s
});
StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);
w.front
)
::

Stretching the layout view and the contents; if all the contents are elastic, the heights of the contents are perfectly divided up. In this example, the StaticText is not elastic in order to preserve its height.

code::
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.background_(Color.rand);
v.resize = 5; // elastic
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20));
    s.resize = 5; // elastic
    s.value = i / q;
    s
});
StaticText(v, Rect(0,0,55,40))
    .background_(Color.rand).string_("Some Example Text")
    .align_(\center);

w.front
)
::

Mixed stretching modes:
code::
(
q = 5;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.resize = 5; // elastic
v.background_(Color.grey);
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20)).background_(Color.rand);
    s.value = i / 5;
    if(i < 2,{
        s.resize = 5; // some elastic
        s.setProperty(\minHeight,20);
    },{
        s.resize = 1; // some not elastic
    });
    s
});
StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);

w.front
)
::

Set minimum heights; beware that if the layout view height is smaller than the combined height of all the contents, things might disappear when you try to handle them with the mouse:

code::
(
q = 5;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.resize = 5; // elastic
v.background_(Color.grey);
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20)).background_(Color.blue.alpha_(0.2));
    s.value = i / 5;
    s.resize = 5;
    s.setProperty(\minHeight,20);
    s.setProperty(\maxHeight,40);
    s
});
w.front
)
::

Spacing:

code::
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.setProperty(\spacing,0);

Array.fill(q,{
    Slider(v,Rect(0,0,75,20))
});

w.front
)
::


Nesting: use VLayoutView and HLayoutView in combination:
code::
(
q = 10;
w = Window.new("nesting",Rect(30,30,400,700));

v = VLayoutView(w,Rect(10,10,300,600));

v.background = Color.rand;

Array.fill(q,{ arg i;
    Slider(v,Rect(0,0,75,20)).value_(i / q)
});

StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);

h = HLayoutView(v,Rect(10,10,300,300));

Array.fill(q,{ arg i;
    Slider(h,Rect(0,0,20,70)).value_(i / q)
});
h.background = Color.rand;

w.front
)
::


class:: VOsc
summary:: Variable wavetable oscillator.
related:: Classes/COsc, Classes/Osc, Classes/OscN, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

A wavetable lookup oscillator which can be swept smoothly across
wavetables. Fractional values of table will interpolate between two adjacent tables.


This oscillator requires at least two buffers to be filled with a wavetable format
signal. This preprocesses the signal into a form which can be used efficiently by
the oscillator. All the wavetables must be allocated to the same size, and the size
must be a power of two.

subsection:: Setting your tables with Buffers
The wavetable can be generated by filling a buffer via the
link::Classes/Buffer#Buffer Fill Commands:: (e.g. link::Classes/Buffer#-sine1::).
Set code::wavetable: true:: to ensure the proper data formatting.

Identically, you can create a link::Classes/Buffer:: object by sending one of the
code::\b_gen:: messages code::\sine1::, code::\sine2::,
code::\sine3:: (see
link::Reference/Server-Command-Reference#Wave Fill Commands:: and examples below),
again remembering to enable the wavetable format.

You can use link::Classes/Buffer#*allocConsecutive:: to ensure a contiguous buffers
numbers to be interpolated.

subsection:: Setting your tables with Signals
This can also be achieved by creating a link::Classes/Signal:: object and sending
it the link::Classes/Signal#-asWavetable:: message, saving it to disk, and having
the server load it from there.


classmethods::

method::ar, kr

argument::bufpos

Buffer index. Can be swept continuously among adjacent wavetable
buffers of the same size.


argument::freq

Frequency in Hertz. (non-interpolated control-rate)


argument::phase

Phase offset or modulator in radians.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
// allocate and fill the buffers to be used by VOsc
(
s.waitForBoot({

	var numBufs = 8;

	// allocate table of consecutive buffers
	~bufs = Buffer.allocConsecutive(numBufs, s, 1024, 1);
	s.sync;

	~bufs.do({ arg buf, i;
		var n, a;

		// generate array of harmonic amplitudes
		n = (i+1)**2;
		a = Array.fill(n, { arg j; ((n-j)/n).squared.round(0.001) });

		// fill table
		// argument '7': flag for the \sine1 wave fill method
		// see "Wave Fill Commands" in the Server Command Reference
		s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);

		s.sync;
	});
	"Buffers prepared.".postln;
})
)

// play the synth, indexing into the buffers with MouseX
(
x = SynthDef("help-VOsc",{ arg out = 0, bufoffset = 0;
	// mouse x controls the wavetable position
	var bufindex = MouseX.kr(0, ~bufs.size - 1) + bufoffset;

	Out.ar(out,
		VOsc.ar(bufindex, [120, 121], 0, 0.3)
	)
}).play(s,[\out, 0, \bufoffset, ~bufs.first.bufnum]);
)

// fill the buffers with new harmonics on-the-fly
(
~bufs.do({ arg buf, i;
	var a;
	a = Array.fill(i, 0) ++ [0.5, 1, 0.5];
	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// new harmonics...
(
~bufs.do({ arg buf, i;
	var a = Array.fill(32,0);
	12.do({ arg i; a.put(32.rand, 1) });
	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// new harmonics...
(
~bufs.do({ arg buf, i;
	var a = Array.fill((i+1)**2, { arg j; 1.0.rand2 });
	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// cleanup
(
x.free;
~bufs.do(_.free);
)

::


class:: VOsc3
summary:: Three variable wavetable oscillators.
related:: Classes/COsc, Classes/Osc, Classes/OscN, Classes/VOsc
categories::  UGens>Generators>Deterministic


Description::

A wavetable lookup oscillator which can be swept smoothly across
wavetables. Fractional values of table will interpolate between two adjacent tables.
While link::Classes/VOsc:: cycles through its wavetable at one frequency,
this unit generator contains three oscillators at different frequencies,
mixed together.


This oscillator requires at least two buffers to be filled with a wavetable format
signal. This preprocesses the signal into a form which can be used efficiently by
the oscillator. All the wavetables must be allocated to the same size, and the size
must be a power of two.

subsection:: Setting your tables with Buffers
The wavetable can be generated by filling a buffer via the
link::Classes/Buffer#Buffer Fill Commands:: (e.g. link::Classes/Buffer#-sine1::).
Set code::wavetable: true:: to ensure the proper data formatting.

Identically, you can create a link::Classes/Buffer:: object by sending one of the
code::\b_gen:: messages code::\sine1::, code::\sine2::,
code::\sine3:: (see
link::Reference/Server-Command-Reference#Wave Fill Commands:: and examples below),
again remembering to enable the wavetable format.

You can use link::Classes/Buffer#*allocConsecutive:: to ensure a contiguous buffers
numbers to be interpolated.

subsection:: Setting your tables with Signals
This can also be achieved by creating a link::Classes/Signal:: object and sending
it the link::Classes/Signal#-asWavetable:: message, saving it to disk, and having
the server load it from there.

classmethods::

method::ar, kr

argument::bufpos

Buffer index. Can be swept continuously among adjacent wavetable
buffers of the same size.


argument::freq1

Frequency in Hertz of the 1st oscillator. (non-interpolated control-rate)


argument::freq2

Frequency in Hertz of the 2nd oscillator. (non-interpolated control-rate)


argument::freq3

Frequency in Hertz of the 3rd oscillator. (non-interpolated control-rate)


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// allocate and fill the buffers to be used by VOsc3
(
s.waitForBoot({

	var numBufs = 8;

	// allocate table of consecutive buffers
	~bufs = Buffer.allocConsecutive(numBufs, s, 1024, 1);
	s.sync;

	~bufs.do({ arg buf, i;
		var n, a;

		// generate array of harmonic amplitudes
		n = (i+1)**2;
		a = Array.fill(n, { arg j; ((n-j)/n).squared.round(0.001) });

		// fill table
		// argument '7': flag for the \sine1 wave fill method
		// see "Wave Fill Commands" in the Server Command Reference
		s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);

		s.sync;
	});
	"Buffers prepared.".postln;
})
)

// play the synth, indexing into the buffers with MouseX
(
x = SynthDef("help-VOsc", { arg out = 0, bufoffset = 0, freq = 240;
	// mouse x controls the wavetable position
	var bufindex = MouseX.kr(0, ~bufs.size - 1) + bufoffset;

	Out.ar(out,
		VOsc3.ar(
			bufindex,
			freq + [0,1],
			freq + [0.37, 1.1],
			freq + [0.43, -0.29],
			0.3
		)
	)
}).play(s,[\out, 0, \bufoffset, ~bufs.first.bufnum, \freq, 240]);
)

// fill the buffers with new harmonics on-the-fly
(
~bufs.do({ arg buf, i;
	var a;
	a = Array.fill(i, 0) ++ [0.5, 1, 0.5];
	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// new harmonics...
(
~bufs.do({ arg buf, i;
	var a, n;
	n = (i+1)*8;
	a = Array.fill(n,0);
	(n>>1).do({ arg i; a.put(n.rand, 1) });

	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// new harmonics...
(
~bufs.do({ arg buf, i;
	var a, n;
	n = (i+1)**2;
	a = Array.fill(n, { 1.0.rand2 });

	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a);
});
)

// new harmonics...
(
var a = Array.fill(64, { 1.0.rand2 });
var n = [1, a.size].interpolate(~bufs.size-1);
~bufs.do({ arg buf, i;
	n[i].postln;
	s.performList(\sendMsg, \b_gen, buf.bufnum, \sine1, 7, a.keep(n[i].asInteger).postln);
});
)

// cleanup
(
x.free;
~bufs.do(_.free);
)

::


class:: VarLag
summary:: Variable shaped lag
related:: Classes/Lag, Classes/Ramp, Classes/Slew
categories::  UGens>Filters>Linear


Description::
Similar to link::Classes/Lag:: but with other curve shapes than exponential.
A change on the input will take the specified time to reach the new value.
Useful for smoothing out control (not audio) signals.

warning:: code::VarLag.ar:: currently accepts audio-rate input, but the underlying implementation treats the input as control rate. Effectively, then, the "sampling rate" of VarLag's input is code::ControlRate.ir:: or code::server.sampleRate / server.options.blockSize::, and the maximum safe frequency to feed into VarLag is half of this. VarLag does not currently yield correct results for full-bandwidth audio-rate signals. Use code::VarLag.ar:: at your own risk.::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::time

Lag time in seconds.

argument::curvature
Control curvature if strong::warp:: input is 5 (default).
0 means linear, positive and negative numbers curve the segment up and down.

argument::warp
Determines the shape. The possible values are:
table::
## code::\step:: || || flat segment
## code::\linear:: || code::\lin:: || linear segment, the default
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segment.
## code::\welch:: || code::\wel:: || sinusoidal segment shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment
## code::\cubed:: || code::\cub:: || cubed segment
::

All values above will ignore strong::curvature:: input.

note::
When controlling this from the outside, use code::Env.shapeNumber(symbol):: to get the numeric value for each shape.
::

argument::start
Initial value. If not specified, same as the input signal.

argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
    SinOsc.ar(                              // sine wave
        VarLag.kr(                            // lag the modulator
            LFPulse.kr(1).range(100,400),   // frequency modulator
            0.2,                            // lag time
            Line.kr(-8, 8, 15, doneAction: Done.freeSelf) // modulate shape
        ),
        0,                                  // sine phase
        0.3                                 // sine amplitude
    )
}.play
)
::

code::
(
x = play { |amp=0, time=0, curve=0, warp=5|
    PinkNoise.ar(VarLag.kr(amp, time, curve, warp) ! 2)
}
)

x.set(\amp, 1, \time, 5, \warp, Env.shapeNumber(\sin)) // s-shaped curve up
x.set(\amp, 0, \time, 1, \warp, Env.shapeNumber(\lin)) // linear down

x.set(\amp, 1, \time, 2, \warp, 5, \curve, 7); // slow curvature
x.set(\amp, 0, \time, 0);

x.set(\amp, 1, \time, 2, \warp, 5, \curve, -7); // fast curvature
x.set(\amp, 0, \time, 0);

x.free;
::



class:: VarSaw
summary:: Variable duty saw
related:: Classes/Saw, Classes/SyncSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

Sawtooth-triangle oscillator with variable duty.


classmethods::
private:: categories

method::ar, kr

argument::freq
frequency in Hertz

argument::iphase
initial phase offset in cycles ( 0..1 )

argument::width
duty cycle from zero to one.

argument::mul

argument::add

Examples::

code::

play({
	VarSaw.ar(
		LFPulse.kr(3, 0, 0.3, 200, 200),
		0,
		LFTri.kr(1.0).range(0,1), //width
		0.1)
});


play({ VarSaw.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) });

// compare:

play({ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) });

::



class:: Vibrato
summary:: The Vibrato oscillator models a slow frequency modulation.
categories::  UGens>Generators>Deterministic, UGens>Generators>Stochastic, UGens>Filters>Pitch

Description::

Vibrato is a slow frequency modulation. Consider the systematic deviation in pitch of a singer around a fundamental frequency, or a violinist whose finger wobbles in position on the fingerboard, slightly tightening and loosening the string to add shimmer to the pitch. There is often also a delay before vibrato is established on a note. This UGen models these processes; by setting more extreme settings, you can get back to the timbres of FM synthesis. You can also add in some noise to the vibrato rate and vibrato size (modulation depth) to make for a more realistic motor pattern.

The vibrato output is a waveform based on a squared envelope shape with four stages marking out 0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, and -1.0 back to 0.0. Vibrato rate determines how quickly you move through these stages.


classmethods::

method::ar, kr

argument::freq

Fundamental frequency in Hertz. If the Vibrato UGen is running at audio rate, this must not be a constant, but an actual audio rate UGen (see example below)

argument::rate

Vibrato rate, speed of wobble in Hertz. Note that if this is set to a low value (and definitely with 0.0), you may never get vibrato back, since the rate input is only checked at the end of a cycle.

argument::depth

Size of vibrato frequency deviation around the fundamental, as a proportion of the fundamental. 0.02 = 2% of the fundamental.

argument::delay

Delay before vibrato is established in seconds (a singer tends to attack a note and then stabilise with vibrato, for instance).

argument::onset

Transition time in seconds from no vibrato to full vibrato after the initial delay time.

argument::rateVariation

Noise on the rate, expressed as a proportion of the rate; can change once per cycle of vibrato.

argument::depthVariation

Noise on the depth of modulation, expressed as a proportion of the depth; can change once per cycle of vibrato. The noise affects independently the up and the down part of vibrato shape within a cycle.

argument::iphase

Initial phase of vibrato modulation, allowing starting above or below the fundamental rather than on it.

argument::trig

Start again if transition from trig <= 0 to trig > 0.
Examples::

code::

//vibrato at 1 Hz, note the use of DC.ar UGen; a constant of 400.0 doesn't work
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),1,0.02) )}.play

//compare: k-rate freq input can be a constant
{SinOsc.ar(Vibrato.kr(400.0,1,0.02))}.play

//control rate and rateVariation
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),MouseX.kr(2.0,100.0),0.1,1.0,1.0,MouseY.kr(0.0,1.0),0.1) )}.play

//control depth and depthVariation
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),LFNoise1.kr(1,3,7),MouseX.kr(0.0,1.0),1.0,1.0,MouseY.kr(0.0,1.0),0.1) )}.play


::







CLASS:: View
summary:: The basic visible element of GUI
categories:: GUI>Views

DESCRIPTION::
The View class is the superclass of all view classes.

The view is the basic visible element of which the graphical user interface is composed. It occupies a rectangular space on screen within which it draws itself to display some data or to indicate a mode of interaction between the user and the program. Views receive keyboard and mouse events generated by the user and respond to them by controlling the behavior of the program. They also display information about the state of the program and the data on which it operates.



CLASSMETHODS::

PRIVATE:: key

METHOD:: new

Creates a new instance of View and makes it a child of another View or Window, effectively placing it within the parent's visual space. If there is a link::#-decorator#decorator:: installed on the parent, it will manage the position of the new View.

note::

The 'parent' argument may be omitted, in which case the view will be displayed as a window on its own, when link::Classes/View#-front#shown::.

The 'bounds' argument may be omitted, in which case the view will be created with its preferred size at position (0,0).

If a parent is given and there is a layout installed on it, the layout will manage the position and size of this view and the 'bounds' argument will have no effect.
::

argument:: parent
The instance of View or Window that the new View will become a child of.

argument:: bounds
A Rect or a Point describing size and position of the new View. If a Point is given, its coordinates will denote the view's size, while the view's position will be (0,0). Position is measured relative to the parent's top-left corner.



METHOD:: globalKeyDownAction

	A settable class variable containing an object (e.g. an instance of Function or FunctionList) which is evaluated (i.e. link::Classes/Object#-value#value:: method is called on it) whenever a key is pressed, independently of keyboard focus. See also link::#-addAction::.

	When the action object is evaluated, it is passed the following arguments: view, char, modifiers, unicode, keycode, key.

METHOD:: globalKeyUpAction

	A settable class variable containing an object (e.g. an instance of Function or FunctionList) which is evaluated (i.e. link::Classes/Object#-value#value:: method is called on it) whenever a key is released, independently of keyboard focus. See also link::#-addAction::.

	When the action object is evaluated, it is passed the following arguments: view, char, modifiers, unicode, keycode.


METHOD:: currentDrag

	A class variable holding the content of the current drag. It is set by beginDrag.


METHOD:: currentDragString

	A class variable holding the content of the current drag as link::Classes/Object#-asCompileString#"compile string"::. It is set by beginDrag.




INSTANCEMETHODS::

SUBSECTION:: Hierarchy and existence

METHOD:: parent
	returns:: The view's parent view, or nil if the view is a top view.

METHOD:: parents
	returns:: An array of all the parents, grandparents, etc., of the view.

METHOD:: getParents
	returns:: Same as link::#-parents#parents::.

METHOD:: children
	returns:: An array of all immediate children of the view.

METHOD:: remove
	Removes the view from its parent view (if any) and destroys the view. After this method is called, the view is not usable anymore.

METHOD:: removeAll
	Removes all the children of the view and destroys them. After this method is called, the former child views are not usable anymore.

METHOD:: close

	If link::#-deleteOnClose:: is true, this method has the same effect as link::#-remove::, otherwise makes the view invisible.

METHOD:: isClosed
	returns:: A Boolean stating whether the view has been destroyed.

METHOD:: notClosed
	returns:: A Boolean, the opposite of 'isClosed'.

METHOD:: asView
	Method that allows compatibility with Window and other classes that are not real subclasses of View, but implement a part of its interface.

	returns:: This view.

SUBSECTION:: Visibility

METHOD:: visible
	Gets or sets whether the view is visible.

	Making a child view invisible means it does not occupy any space from the standpoint of the layout that contains it, so the layout will distribute the space the view occupied when visible among other views. When the view becomes visible again it is given back the same space.

	If the view has no parent, setting this to true has the same effect as link::#-front::, and setting it to false closes the window without destroying it.

	argument::
		A Boolean stating the visibility of the view.

METHOD:: front

	If the view does not have a parent, displays it on the screen as a window (it has the same effect as setting link::#-visible:: to true), otherwise it has no effect.

METHOD:: minimize

	If the view is a window, hides it (only keep it present in the dock/taskbar/etc.).

METHOD:: unminimize

	If the view is a window, restores the its previous state after being minimized.

METHOD:: fullScreen

	If the view is a window, displays it full-screen.

METHOD:: endFullScreen

	If the view is a window, restores its previous state after being displayed full-screen.

METHOD:: alwaysOnTop


	If the view is a window, gets or sets whether it should always stay on top of other windows.

	argument:: boolean
		A Boolean stating whether the view should always stay on top.




SUBSECTION:: Size and position

METHOD:: bounds

	Gets or sets both the position and the size of the view. The position is relative to the parent view's top-left corner. Some containers, such as HLayoutView and VLayoutView, will use only the width and height of a child view's bounds.

	The setter takes a Rect or a Point interpreted link::Classes/Point#-asRect#as Rect::. The getter always returns a Rect.

METHOD:: absoluteBounds

	returns:: A Rect describing the absolute position and the size of the view on the screen.

METHOD:: sizeHint

	returns:: A Size describing the preferred size of the view to comfortably display its contents and allow useful interaction.

METHOD:: minSizeHint


	returns:: A Size describing the minimum size of the view to be able to display its contents and allow any interaction.

METHOD:: maxSize

	Set maximum allowed size of the view. The view will not be able to grow larger than this size, neither by user interaction nor programmatically.

	argument:: size
		A Size.

METHOD:: minSize

	Set minimum allowed size of the view. The view will not be able to shrink smaller than this size, neither by user interaction nor programmatically.

	argument:: size
		A Size.


METHOD:: fixedSize

	Set both minimum and maximum allowed size of the view, thus making it non-resizable.

	argument:: size
		A Size.

METHOD:: fixedWidth

	Set both minimum and maximum allowed width of the view, thus making it non-resizable.

	argument:: width
		An Int.

METHOD:: fixedHeight

	Set both minimum and maximum allowed height of the view, thus making it non-resizable.

	argument:: height
		An Int.

METHOD:: maxWidth

	Set maximum allowed width of the view, the view will not be able to grow larger in width, neither by user interaction nor programmatically.

	argument:: width
		An Int.


METHOD:: minWidth

	Set minimum allowed width of the view, the view will not be able to shrink smaller in width, neither by user interaction nor programmatically.

	argument:: width
		An Int.


METHOD:: maxHeight

	Set maximum allowed height of the view, the view will not be able to grow larger in height, neither by user interaction nor programmatically.

	argument:: height
		An Int.



METHOD:: minHeight

	Set minimum allowed height of the view, the view will not be able to shrink smaller in height, neither by user interaction nor programmatically.

	argument:: height
		An Int.

METHOD:: moveTo

	Move the view to new position, preserving its size.

	argument:: x
		An Int: the horizontal position of the new position.

	argument:: y
			An Int: the vertical position of the new position.

METHOD:: resizeTo

	Resize the view, preserving its position.

	argument:: width
		An Int: the new horizontal size of the view.

	argument:: height
		An Int: the new vertical size of the view.

METHOD:: resizeToBounds

	argument:: rect
		A Rect: the bounds to which the view will be resized.

METHOD:: resizeToHint

	Resizes view to the bounds returned by link::#-sizeHint::.

METHOD:: resize
	Determines what happens with the view's position and size when its parent is resized. See link::Guides/GUI-Introduction#view:: for further explanation.

	argument::
		An Int (1 to 9) defining the auto-resize behavior. See link::Reference/Resize:: for a list of valid resize modes.

METHOD:: decorator


	Get or set the decorator object, that automatically manages the positioning of new children of the view when they are created. See link::Guides/GUI-Introduction#decorators:: for further explanation.

	argument::
		An instance of a decorator class (e.g. FlowLayout).

METHOD:: addFlowLayout


	A convenience method which sets decorator to a new instance of FlowLayout. See link::Classes/FlowLayout:: for examples.

	argument:: margin
		A Point describing the link::Classes/FlowLayout#-margin#margin:: of the FlowLayout.

	argument:: gap
		A Point describing the link::Classes/FlowLayout#-gap#gap:: of the FlowLayout.

	returns:: The new FlowLayout instance.

METHOD:: flow


	Creates a FlowView as a child of the view, and then evaluates the object given in the 'func' argument. It is most common to pass a Function for 'func' in which the FlowView is filled with other child views.

	argument:: func
		The object that will be evaluated after the creation of the FlowView, passing the new FlowView instance as an argument.

	argument:: bounds
		A Rect to set as the bounds of the FlowView, or nil, implying the size of this view and position (0,0).

		After 'func' is evaluated, the FlowView will be resized to fit its contents and cast away any extra space it occupies.

	returns:: The new FlowView instance.

METHOD:: layout


	Get or set the layout object, that automatically manages the position and the size of the children of the view dynamically, in relation to the view's size. See link::Guides/GUI-Introduction#layouts:: for further explanation.

	argument::
		An instance of a subclass of Layout.




METHOD:: mapToGlobal


	Map a point relative to this view's top-left to absolute position on screen.

	argument::
		A Point describing a position relative to the view.

	returns::
		A Point describing the same position, but relative to the screen.


SUBSECTION:: Appearance

METHOD:: name


	If the view is a window, sets its title

	argument::
		A String containing text for the window title.


METHOD:: alpha

	If the view is a window, this controls its transparency.

	argument:: aFloat
		A Float between 0.0 (invisible) and 1.0 (opaque).

METHOD:: font
	note:: Every view has this method.::
	The font used by the view to display text (if any).

	argument::
		A Font.


METHOD:: background
	Get or set the color of whatever is considered the background of the view.

	argument::
		A Color.


METHOD:: backgroundImage
Sets an Image as the view background. If you need more functionality, use link::#-setBackgroundImage::.

	argument:: image
	the Image to use. It will be fixed to the top left corner of the view.

	discussion::

code::
(
	~bounds = Rect(10, 10, 150, 18);
	~image = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
	~window = Window.new("Image background");
	~slider = Slider.new(~window, ~bounds)
		.backgroundImage_(~image);
	~window.front;
	~image.free;
)
::

METHOD:: setBackgroundImage
Sets an Image as a valid view background, with 16 different drawing modes and opacity support.

	argument:: image
	the Image to use. 

	argument:: tileMode
	the mode to use. By default 1 (fixed to left, fixed to top).

table::
## 1 || fixed to left, fixed to top
## 2 || horizontally tile, fixed to top
## 3 || fixed to right, fixed to top
## 4 || fixed to left, vertically tile
## 5 || horizontally tile, vertically tile
## 6 || fixed to right, vertically tile
## 7 || fixed to left, fixed to bottom
## 8 || horizontally tile, fixed to bottom
## 9 || fixed to right, fixed to bottom
## 10 || fit
## 11 || center, center (scale)
## 12 || center , fixed to top
## 13 || center , fixed to bottom
## 14 || fixed to left, center
## 15 || fixed to right, center
## 16 || center, center (no scale)
::

	argument:: alpha
	opacity of the image. 0 <= alpha <= 1, and values outside of that range will be clipped

	argument:: fromRect
	the portion of the image to use. If nil, use the full image.

	discussion::

code::
(
	~alpha = 1.0;
	~image = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
	~bounds = Rect(20, 3, 40, 40);
	~window = Window.new("Image background");
	~window.view.background_(Color.gray);
	~window.view.setBackgroundImage(~image, 5, ~alpha, ~bounds);
	~window.front;
)

// monte carlo :) exec every line to test
~window.view.setBackgroundImage(~image, 1, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 2, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 3, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 4, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 5, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 6, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 7, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 8, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 9, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 10, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 11, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 12, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 13, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 14, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 15, ~alpha, ~bounds);
~window.view.setBackgroundImage(~image, 16, ~alpha, ~bounds);

// this is safe even if window is still open because Background object holds the Image
~image.free;

~window.close;

(
	~image = Image.new(SCDoc.helpSourceDir +/+ "images/Swamp.png");
	~window = Window.new("Image background");
	~slider = Slider2D.new(~window, Rect(10, 10, 200, 200))
		.setBackgroundImage(~image, 5, 1, Rect(0, 0, 100, 100) );
	~window.front;
)
::

METHOD:: focusColor
	Get or set the color used to display keyboard focus on the view.

	argument::
		A Color.

METHOD:: palette

	Get or set the palette to be used by the view.

	When setting a palette, only those colors that have been set on the palette will take effect, other colors will be inherited from the parent view's palette. See also link::Classes/QPalette#-hasColor::.

	When getting a palette, it will return a new copy of the view's palette every time. Therefore, if you wish to change the view's palette, you have to set the changed palette back on the view:

code::
	w = Window().front.layout_( HLayout( a = Slider() ) );
	a.action = { |a|
		a.palette = a.palette.buttonText_( if(a.value > 0.5){Color.red}{Color.green} );
	};
	a.valueAction = 0.0;
::

	To dynamically modify the view's palette, it is thus more efficient, if possible, to keep a palette instance to operate on. Note that this is also more efficient than using methods like link::Classes/Slider#-knobColor::, since internally they use the above approach:

code::
	w = Window().front.layout_( HLayout( a = Slider() ) );
	p = QPalette();
	a.action = { |a|
		a.palette = p.buttonText_( if(a.value > 0.5){Color.red}{Color.green} );
	};
	a.valueAction = 0.0;
::

	See link::Classes/QPalette:: for detailed explanation of how palettes work.

	argument::
		A QPalette.

METHOD:: refresh
	Redraws the view and all its children.


SUBSECTION:: Common behavior


METHOD:: userCanClose


	If the view is a window, sets or gets whether the user can close it via mouse or key actions.

	argument::
		A Boolean.


METHOD:: deleteOnClose


	Sets or gets whether the view should be destroyed when closed.

	argument::
		A Boolean.

METHOD:: enabled
	Sets or gets whether the view allows the user to interact with it. Usually, when a view is disabled it will be displayed differently (typically it will be greyed out).

	argument::
		A Boolean.


METHOD:: canFocus
	Sets or gets whether the view can receive keyboard focus.

	argument::
		A Boolean.

METHOD:: focus
	If 'flag' is true, gives keyboard focus to the view (if possible), otherwise removes the keyboard focus from it.

	argument:: flag
		A Boolean.

METHOD:: hasFocus

	returns:: A Boolean, stating whether the view currently has the keyboard focus.

METHOD:: acceptsMouse


    Sets or gets whether the view responds to mouse interaction. If code::false::, the view will be completely transparent for mouse and interaction will be possible with any view under.

    Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: acceptsMouseOver
	If this is a top view, this variable defines whether the view and all its children receive mouse-over events. The default is code::false::.

	See also: link::#-mouseOverAction::.

	argument::
		A Boolean.


SUBSECTION:: Actions in general

METHOD:: action
	Gets or sets the default action of the view, i.e. the object to be evaluated when the user interacts with the view in an essential way (e.g. a Button is clicked, a ListView item is selected, etc.).

	argument:: func
		Any object to set as default action, usually a Function or a FunctionList. When evaluated, it will be passed the view as an argument.


METHOD:: doAction
	Evaluates the default link::#-action#action::.


METHOD:: addAction
METHOD:: removeAction

	Adds/removes 'func' to or from the list of objects in the variable determined by 'selector'. If 'selector' is not an Array or a List, it will become one, containing the previous object plus 'func'.

	This is useful for adding functionality to existing frameworks that have action functions already.

	argument:: func
		Any object to add as an action, usually a Function.

	argument:: selector
		A Symbol containing the name of the action variable to which 'func' will be added. In other words, 'add' method will be invoked on that variable; by default that is \action, but any other (sensible) instance or class variable of the view could work (e.g. \globalKeyDownAction or \mouseUpAction or \onClose, etc.). See the other action variables below.

SUBSECTION:: Key and mouse event processing

Both mouse and key events can propagate to the parent view. Event processing works differently: by default, after a mouse or key action is evaluated, the control returns to the C++ implementation of the view, and if no response to the particular mouse or key event is implemented there, it propagates to the parent.

If you wish to control whether the event will be propagated or not, return code::true:: or code::false:: from the action. True means you have responded to the event, and the propagation will be stopped; false means you are not interested in the event, and the event will propagate. However, returning either code::true:: or code::false:: will completely bypass the view's C++ implementation, so it will not get a chance at responding to the event with its standard behavior. Use this feature with care.

SUBSECTION:: Mouse actions

Use the methods below to set or get the view's actions in response to mouse interaction with the view. A view must be enabled for the mouse actions to work.

note::
Mouse actions are subject to emphasis::event propagation::. See link::#Key and mouse event processing:: for details.
::

When the mouse action object is evaluated, it is passed one or more arguments from the following list (in that order):

list::
## strong::view:: - the view
## strong::x:: - the x coordinate
## strong::y:: - the y coordinate
## strong::modifiers:: - A bitwise or of integers indicating the modifier keys in effect. For a list of these, see link::Reference/Modifiers::.
## strong::buttonNumber:: - 0-left, 1-right, 2-middle, etc.
## strong::clickCount:: - the number of clicks within the system click time limit. At least 1.
::

METHOD:: mouseDownAction
    The object to be evaluated when a mouse button is pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers, buttonNumber, clickCount::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseUpAction
    The object to be evaluated when a mouse button is released after it was pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers, buttonNumber::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseMoveAction
    The object to be evaluated whenever the mouse pointer moves after a mouse button was pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseOverAction
    The object to be evaluated when the mouse pointer moves over the view with no mouse buttons pressed.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.

    The object is evaluated only when link::Classes/Window#-acceptsMouseOver:: of the containing Window (or link::#-acceptsMouseOver:: of the top View) is code::true::.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseWheelAction

    The object to be evaluated when the mouse wheel is used while the mouse is pointing onto the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers, xDelta, yDelta::. See link::#Mouse actions:: for explanation of arguments.

    The xDelta and yDelta arguments express rotation in horizontal and vertical direction, respectively. The value is in degrees (typically, an event occurs every 15 degrees), and can be positive or negative, depending on the direction of rotation.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseEnterAction

    The object to be evaluated when the mouse pointer enters the view.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseLeaveAction

    The object to be evaluated when the mouse pointer leaves the view.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.


SUBSECTION:: Key actions

Use the methods below to set or get the view's actions in response to keyboard interaction when the view has the keyboard focus.

note::
Key actions are subject to emphasis::event propagation::. See link::#Key and mouse event processing:: for details.
::

When the key action object is evaluated, it is passed one or more arguments from the following list (in that order):

list::
## strong::view:: - The view.

## strong::char:: - The character (link::Classes/Char::) associated with the key, possibly unprintable. Character sequences (for example é) get passed as two characters, the first one blank ( ), the second one is the unmodified character (e). This will also vary depending on the nationality the keyboard is set to.
note:: Only characters with an ASCII code are passed. Non-ASCII keys (Ctrl/Alt/Cmd/Shift modifiers, arrow keys and other control sequences) will pass a link::Classes/Char:: with ASCII code 0. (Ctrl-characters emphasis::do:: have ASCII codes, and are passed as a Char. The Ctrl key by itself also triggers the key action, but with ASCII code 0.) A useful test is link::Classes/Char#-isPrint::.::

## strong::modifiers:: - A bitwise or of integers indicating the modifier keys in effect. You can examine individual flag settings using the C bitwise AND operator. For a list of these, see link::Reference/Modifiers::.

## strong::unicode:: - The Integer unicode number associated with the 'char' passed.

## strong::keycode:: - The hardware dependent keycode indicating the physical key. This will vary from machine to machine, but is useful for building musical interfaces using the computer keyboard. warning::Function key modifier in combination with another key may change the latter's keycode.::

## strong::key:: - An Integer denoting a key, corresponding to the "Key" enum of the Qt C++ API. Comparing this value is the most reliable way to check which key was pressed. For a list of possible values, see: link::http://qt-project.org/doc/qt-4.8/qt.html#Key-enum::.
::

METHOD:: keyDownAction
    The object to be evaluated when a key is pressed.

    The following arguments are passed at evaluation: strong::view, char, modifiers, unicode, keycode, key::. See link::#Key actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

    If no code::keyDownAction:: is set, link::#-defaultKeyDownAction:: is called instead, and its return value controls the event propagation.

CODE::
// open a new document that posts the parameters passed into the keydownAction function.
(
Document("test arguments").keyDownAction = { |doc, char, mod, unicode, keycode, key|
	[doc, char, mod, unicode, keycode, key].postln
};
)
::

METHOD:: keyUpAction
    The object to be evaluated when a key is released.

    The following arguments are passed at evaluation: strong::view, char, modifiers, unicode, keycode, key::. See link::#Key actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

    If no code::keyUpAction:: is set, link::#-defaultKeyUpAction:: is called instead, and its return value controls the event propagation.

METHOD:: keyModifiersChangedAction
    The object to be evaluated when a modifier key is pressed or released.

    The following arguments are passed at evaluation: strong::view, modifiers::.


SUBSECTION:: Drag and drop

Use the methods below to define or override how the view handles drag&drop operations.

METHOD:: beginDragAction
	Sets or gets the object evaluated when a drag&drop operation is initiated.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The view expects an object to be returned which will become the data subject to the drag&drop operation. Returning nil will prevent the drag&drop operation to begin.

	If this variable is nil (the default) the view's link::#-defaultGetDrag:: method is called instead.

METHOD:: canReceiveDragHandler
	Sets or gets the object evaluated when the mouse pointer moves over the view while a drag&drop operation is taking place.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The view expects the link::#*currentDrag#drag&drop data:: to be examined, and a Boolean returned stating whether the view can make use of that data. If true is returned, the data may be dropped on the view, otherwise the drop event will not be handled by this view.

	If this variable is nil (the default) the view's link::#-defaultCanReceiveDrag:: method is called instead.

METHOD:: receiveDragHandler
	Sets or gets the object evaluated when a drag&drop operation finishes on this view.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The link::#*currentDrag#drag&drop data:: is expected to be applied to the view in some way.

	If this variable is nil (the default) the view's link::#-defaultReceiveDrag:: method is called instead.


METHOD:: dragLabel
	Sets or gets the text displayed by the mouse pointer during the drag&drop operation. It is expected to be set while handling the beginning of the operation, i.e. in link::#-beginDragAction:: or link::#-defaultGetDrag::.

	argument::
		A String containing the text to be displayed.

SUBSECTION:: Context Menus

These methods are used to add context menu and shortcut key support to a View.

CODE::
(
View().layout_(HLayout(
	~text = StaticText().string_("Right-click me").minWidth_(100)
)).front;

~text.setContextMenuActions(
	MenuAction("Red", { ~text.background = Color.red }),
	MenuAction("Green", { ~text.background = Color.green }),
	MenuAction("Blue", { ~text.background = Color.blue })
)
)
::

METHOD:: setContextMenuActions
	Set the link::Classes/MenuAction::s that should appear in the context menu for this view. This implicitly calls link::Classes/View#-enableContextMenu::.

	argument::
		A list of one or more link::Classes/MenuAction::s. These will be shown when the context menu for this View is invoked by right-clicking.
		In addition, the shortcut keys for these actions will be active in the context of this View. Calling this method with no actions will remove all context menus.

METHOD:: enableContextMenu
	Enablement of context menu support for this View. If true and actions are attached, a right click will show the context menu. This property can enable and disable context menu support for a View without removing the attached actions.

	argument::
		A Boolean

METHOD:: insertMenuAction
	Insert a link::Classes/MenuAction:: into the list of attached actions.

	argument:: action
		A link::Classes/MenuAction:: to add.

	argument:: addBefore
		A link::Classes/MenuAction:: or integer index value. The action will be inserted strong::before:: this item in the list. By default, actions are inserted at the end of the list.

METHOD:: removeMenuAction
	Remove a link::Classes/MenuAction:: from the list of attached actions.

	argument:: action
		A link::Classes/MenuAction:: to add.

METHOD:: removeAllMenuActions
	Remove all link::Classes/MenuAction::s from the view.

METHOD:: enableContextMenu
	Enablement of context menu support for this View. If true and actions are attached, a right click will show the context menu. This property can enable and disable context menu support for a View without removing the attached actions.

	argument::
		A Boolean




SUBSECTION:: Other actions and hooks

METHOD:: focusGainedAction

	Sets or gets the object to be evaluated when the view gains the keyboard focus. It is passed the view as an argument.

METHOD:: focusLostAction


	Sets or gets the object to be evaluated when the view looses the keyboard focus. It is passed the view as an argument.

METHOD:: toFrontAction


	Sets or gets the object to be evaluated when the view becomes the active window. It is passed the view as an argument.

METHOD:: endFrontAction


	Sets or gets the object to be evaluated when the view becomes the active window. It is passed the view as an argument.

METHOD:: onResize


	Sets or gets the object to be evaluated when the view changes its size. It is passed the view as an argument.

METHOD:: onMove


	Sets or gets the object to be evaluated when the view changes position relatively to its parent. It is passed the view as an argument.

METHOD:: onClose

	Sets or gets the object to be evaluated when the view is destroyed (i.e. link::#-close#closed:: or link::#-remove#removed::). It is passed the view as an argument.




SUBSECTION:: Handlers

note:: Older tutorials might recommend subclassing View to override these methods. Don't do that. Use composition, not inheritance. Make the View a property of your custom view class. ::

The following methods are the default handlers of key press and release events.

METHOD:: defaultKeyDownAction

	The method called when a key is pressed and link::#-keyDownAction:: is nil. Subclass it to define your own functionality on key presses.

	See link::#Key actions:: for explanation of arguments.

    The return value controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: defaultKeyUpAction

	The method called when a key is released and link::#-keyUpAction:: is nil.  Subclass it to define your own functionality on key-release.

	See link::#Key actions:: for explanation of arguments.

	The return value controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.


METHOD:: keyDown
	Handles response to a key press event. First evaluates link::#*globalKeyDownAction::.

	note::
	This method directly triggers the action and returns, forwarding the action's return value. See link::#Key actions:: for detailed explanation.
	::

	See link::#Key actions:: for explanation of arguments.

	returns:: A Boolean, stating whether the event was handled or not (and will not or will propagate to the parent view, respectively), or the view, in which case it lets the Qt view implementation handle the event.

METHOD:: keyUp

	Handles response to a key release event. Sets link::#-keyTyped:: to 'char', evaluates link::#*globalKeyUpAction::, and then calls link::#-handleKeyUpBubbling::.

	note::
	This method directly triggers the action and returns, forwarding the action's return value. See link::#Key actions:: for detailed explanation.
	::

	See link::#Key actions:: for explanation of arguments.

	returns:: A Boolean, stating whether the event was handled or not (and will not or will propagate to the parent view, respectively), or the view, in which case it lets the Qt view implementation handle the event.

METHOD:: keyModifiersChanged
	Handles response to a modifier key press or release event. Calls link::#-handleKeyModifiersChangedBubbling::.

	note::
	Instead of calling link::#-handleKeyModifiersChangedBubbling::, a modifier key press or release event also produces a normal key press or release event, and it is the handling of those events that will determine propagation to the parent.
	::

	See link::#Key actions:: for explanation of arguments.

METHOD:: keyTyped

	An instance variable containing the key just typed (after it is released).



METHOD:: mouseDown
	Handles response to a mouse button press event. Evaluates link::#-mouseDownAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseUp
	Handles response to a mouse button release event. Evaluates link::#-mouseDownAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseMove
	Handles response to mouse pointer moving after a mouse button has been pressed on the view. Evaluates link::#-mouseMoveAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseOver
	Handles response to mouse pointer moving over the view with no mouse buttons pressed. Evaluates link::#-mouseOverAction::.

	This method is called only if link::Classes/Window#-acceptsMouseOver:: of the containing Window (or, link::#-acceptsMouseOver:: of the top View) is code::true::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseEnter

	Handles response to mouse pointer entering the view. Evaluates link::#-mouseEnterAction::.

METHOD:: mouseLeave

	Handles response to mouse pointer leaving the view. Evaluates link::#-mouseLeaveAction::.



METHOD:: defaultGetDrag

note::Not yet implemented::

	The view's default method to determine the content of the drag&drop operation just initiated.

	returns:: The object to be set as link::#*currentDrag::. If nil is returned, the drag&drop operation will not begin.

METHOD:: defaultCanReceiveDrag

note::Not yet implemented::

	The view's default evaluation whether the content of the ongoing drag&drop operation can be accepted.

	returns:: A Boolean stating whether link::#*currentDrag:: is useful. If false is returned, the drop will not be handled by this view.

METHOD:: defaultReceiveDrag

note::Not yet implemented::

	The view's default handling of the data dropped on it (stored in link::#*currentDrag::).

METHOD:: beginDrag
	Handles initiation of a drag&drop operation. Evaluates link::#-beginDragAction:: or calls link::#-defaultGetDrag:: if the former is nil, then stores the object returned into link::#*currentDrag::, and the object interpreted as link::Classes/Object#-asCompileString#"compile string":: into link::#*currentDragString::. Returns whether link::#*currentDrag:: is not nil.


	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.

	returns:: A Boolean stating whether the drag&drop operation shall begin.

METHOD:: canReceiveDrag
	Handles evaluation whether the view can accept the current drag&drop data. Evaluates link::#-canReceiveDragHandler:: or calls link::#-defaultCanReceiveDrag:: if the former is nil, then forwards the return value.

	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.

	returns:: A Boolean stating whether the current drag&drop content can be dropped on the view.

METHOD:: receiveDrag
	Handles the end of the drag&drop operation. Evaluates link::#-receiveDragHandler:: or calls link::#-defaultReceiveDrag:: if the former is nil, then sets link::#*currentDrag:: and link::#*currentDragString:: to nil.

	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.


class:: Volume
summary:: Model for the global volume of the synthesis server
categories:: Server

description::
Internally used by Server. When volume value != 0 dB or muted, a server's volume object will create a synth for controlling the volume on the main outputs for the number of channels given.

classmethods::
method:: new
Create and return a new instance of Volume for a given server,
ranging from code::startBus:: over code::numChans:: (usually the server's number of output bus channels).
argument:: server
a server
argument:: startBus
start bus
argument:: numChannels
number of channels
argument:: min
minimum volume in decibel
argument:: max
minimum volume in decibel
argument:: persist
whether to persist a reset

instancemethods::

method:: mute
mute output

method:: unmute
unmute output

method:: volume
set the volume (in db)

method:: lag
set the lag time that dampens volume changes

method:: setVolumeRange
set the volume range

method:: gui
create a volume gui.

examples::
code::
v = s.volume;

v.min;
v.max;
v.volume = rrand(-50, 5);
v.setVolumeRange(-90, 8);
v.mute;
v.unmute;

// separate window
v.gui;
::



class:: Warp
summary:: specification of a shape for a mapping of numerical input
related:: Classes/ControlSpec, Classes/Spec
categories:: Control, Spec

description::
The subclasses of Warp specify translations from input (a number) to an output (another number). This is an abstract class - already available shapes are emphasis::linear, exponential, sine, cosine, decibel, curve:: (this is similar to the curves in envelopes, see also link::Classes/Env::).

Warps are internally created by link::Classes/ControlSpec::. Usually they are created by the message strong::asWarp::, understood by symbols and numbers. A warp has a link::Classes/Spec:: to specify a certain range of input and output values.

code::
// create a new warp:
a = \exp.asWarp;
a = -4.asWarp; // a curve warp;
::

ClassMethods::

private::initClass

InstanceMethods::

method::map
Maps and constrains a strong::value:: between 0 and 1 to the output domain.

method::unmap
in the output domain to a value in the range between 0 and 1.

code::
g = -3.asWarp;
g.map(0.5);
g.unmap(0.9);

// fore and back translation should be identical:
g.unmap(g.map(0.5));
::


class:: Warp1
summary:: Warp a buffer with a time pointer
categories:: UGens>Buffer, UGens>Generators>Granular

description::
Inspired by Chad Kirby's SuperCollider2 Warp1 class, which was inspired by Richard Karpen's sndwarp for CSound. A granular time stretcher and pitchshifter.

classmethods::
private:: categories

method:: ar
argument::numChannels
the number of channels in the soundfile used in bufnum.

argument::bufnum
the buffer number of a mono soundfile.

argument::pointer
the position in the buffer.  The value should be between 0 and 1, with 0 being the beginning
of the buffer, and 1 the end.

argument::freqScale
the amount of frequency shift. 1.0 is normal, 0.5 is one octave down, 2.0 is one octave up.
Negative values play the soundfile backwards.

argument::windowSize
the size of each grain window.

argument::envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in
Hanning envelope.

argument::overlaps
the number of overlapping windows.

argument::windowRandRatio
the amount of randomness to the windowing function.  Must be between 0 (no
randomness) to 1.0 (probably too random actually)

argument::interp
the interpolation method used for pitchshifting grains. 1 = no interpolation. 2 = linear.
		4 = cubic interpolation (more computationally intensive).

argument::mul

argument::add

Examples::
code::
s.boot;

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
x = { |envbuf = -1|
	var pointer, pitch;
	// pointer - move from beginning to end of soundfile over 15 seconds
	pointer = LFSaw.ar(1/15).range(0, 1);
	// control pitch with MouseX
	pitch = MouseX.kr(0.5, 2);
	Warp1.ar(
		numChannels:1,
		bufnum:b,
		pointer:pointer,
		freqScale:pitch,
		windowSize:0.1,
		envbufnum:envbuf,
		overlaps:8,
		windowRandRatio:0.1,
		interp:2
	)
}.play

)


(
// a custom envelope - not a very good one, but you can hear the difference
// between this and the default
var winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);
x.set(\envbuf, z);
)

// the default is -1
x.set(\envbuf, -1);

// relase and end
x.relase; z.free;

::

code::
(
b.free;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
{
	var pointer = Phasor.ar(0, SampleDur.ir / BufDur.ir(b) * XLine.kr(1, 0.25, 20));
	var sound = Warp1.ar(1, b, pointer, 1, 0.3, -1, 16, Line.kr(0, 1, 40), 4);
	Pan2.ar(sound, pointer * 2 - 1, 0.25)
}.play
)
b.free;
::



CLASS::Wavetable
summary::sampled audio buffer in wavetable format
related::Classes/Signal
categories:: Collections>Ordered

DESCRIPTION::
A Wavetable is a FloatArray in a special format used by SuperCollider's interpolating oscillators. Wavetables cannot be created by strong::new::.

CLASSMETHODS::

method::sineFill
Fill a Wavetable of the given size with a sum of sines at the given amplitudes and phases. The Wavetable will be normalized.
code::
Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]).plot;
::
argument::size
must be a power of 2.
argument::amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.
argument::phases
an Array of phases in radians for each harmonic beginning with the fundamental.

method::chebyFill
Fill a Wavetable of the given size with a sum of Chebyshev polynomials at the given amplitudes for use in waveshaping by the link::Classes/Shaper:: ugen.
argument::size
must be a power of 2 plus 1, eventual wavetable is next power of two size up.
argument::amplitudes
an link::Classes/Array:: of amplitudes for each Chebyshev polynomial beginning with order 1.
argument::normalize
a link::Classes/Boolean:: indicating whether to normalize the resulting Wavetable. If the zeroOffset argument is true, the normalization is done for use as a transfer function, using link::Classes/Signal#-normalizeTransfer#normalizeTransfer::, otherwise it just uses link::Classes/Signal#-normalize#normalize:: to make the absolute peak value 1.  Default is true.
argument::zeroOffset
a link::Classes/Boolean:: indicating whether to offset the middle of each polynomial to zero. If true, then a zero input will always result in a zero output when used as a link::Classes/Shaper##waveshaper::. If false, then the "raw" (unshifted) Chebyshev polynomials are used. Default is false.
discussion::
note::
In previous versions, chebyFill always offset the curves to ensure the center value was zero. The zeroOffset argument was added in version 3.7, and the default behavior was changed, so that it no longer offsets.
::
code::
Wavetable.chebyFill(513, [1]).plot;

// shifted to avoid DC offset when waveshaping a zero signal
Wavetable.chebyFill(513, [0, 1], zeroOffset: true).plot;

// normalized sum of (unshifted) Chebyshev polynomials (the default)
Wavetable.chebyFill(513, [0, 1, 0, 0, 0, 1], normalize: true, zeroOffset: false).plot;

Wavetable.chebyFill(513, [0, 0, 1]).plot;
Wavetable.chebyFill(513, [0.3, -0.8, 1.1]).plot;


// This waveshaping example uses two buffers, one with zero offset and
// the other not.
//
// 1. The offset version gives zero output (DC free) when waveshaping an
// input signal with amplitude of zero (e.g. DC.ar(0)).
//
// 2. The non-offset version makes better use of the full (-1 to 1) range
// when waveshaping a varying signal with amplitude near 1, but (if even
// Chebyshev polynomial degrees are used) will have a DC offset when
// waveshaping a signal with amplitude of zero.
//
// 3. Wrapping the non-offset Shaper in a LeakDC (the third signal in the
// example) cancels out any DC offsets (third version), while making full use
// of the -1 to 1 range.
(
s.waitForBoot({
	var amplitudes = [0, 1, 1, -2, 1];
	var wavs = [
		Wavetable.chebyFill(256+1, amplitudes, normalize: true, zeroOffset: true),
		Wavetable.chebyFill(256+1, amplitudes, normalize: true, zeroOffset: false)
	];
	b = wavs.collect{ arg wav; Buffer.loadCollection(s, wav) };
	s.sync;
	x = {
		var in = SinOsc.ar(100, 0, SinOsc.kr(0.1, 0, 0.5, 0.5));
		Shaper.ar(b, in ) ++ LeakDC.ar(Shaper.ar(b[1], in))
	}.scope;
})
)
x.free; b.do(_.free); b = nil;
::

INSTANCEMETHODS::

method::plot
Plot the Wavetable in a window. The arguments are not required and if not given defaults will be used.
code::
Wavetable.sineFill(512, [0.5]).plot;
Wavetable.sineFill(512, [1]).plot("Table 1", Rect(50, 50, 150, 450));
::
argument::name
a String, the name of the window.
argument::bounds
a Rect giving the bounds of the window.
argument::minval
the minimum value in the plot. Defaults to the highest value in the data.
argument::maxval
the maximum value in the plot. Defaults to the lowest value in the data.

method::asSignal
Convert the Wavetable into a Signal.
code::
Wavetable.sineFill(512, [1]).asSignal.plot;
::



subsection:: Advanced notes: wavetable format
code::
Signal: [a0, a1, a2...]
Wavetable: [2*a0-a1, a1-a0, 2*a1-a2, a2-a1, 2*a2-a3, a3-a2...]
::
This strange format is not a standard linear interpolation (integer + frac), but for (integer part -1) and (1+frac))  due to some efficient maths for integer to float conversion in the underlying C code.






class:: WebView
summary:: Web page display and browser
categories:: GUI>Views

DESCRIPTION::

WebView displays web pages and provides all the standard browsing functionality.

Since the Qt WebEngine dependency is hefty and difficult to install on some systems, it is possible for sclang to have been built without WebView support (using the CMake flag code:: -DSC_USE_QTWEBENGINE=OFF :: at compile). If so, attempting to invoke this class will throw an error.

CLASSMETHODS::

PRIVATE:: key

METHOD:: clearCache

  Clears the cache for all browser instances.

METHOD:: setUrlHandler

    Set or clear a function to handle a specific URL prefix (e.g. mail://)

    Argument:: prefix
        URL prefix. For mail:///, use the string "mail" (do not append "://")

    Argument:: function
        Function to execute when any WebView loads a URL with this prefix. First argument is the URL.


INSTANCEMETHODS::

SUBSECTION:: Navigation

METHOD:: url
    Gets the current URL, or navigates to a new one. This is equivalent to entering a URL in a browser's URL box.

METHOD:: navigate
    Navigate to a url. This is equivalent to clicking a link on a page - after a navigate call, back will return you to the previous page.

METHOD:: back
    Navigates to the previous page in history.

METHOD:: forward
    Navigates to the next page in history.

METHOD:: findText
    Finds and selects the next instance of given text on the current page. When the given text changes, the search starts anew.

    Argument::
        The text to find; a String.
    Argument::
        Whether to search in reverse direction; a Boolean.
    Argument::
        A function, called when the operation is finished. If the text was found this function is passed code::true::, otherwise code::false::.

METHOD:: triggerPageAction
    Trigger an action on the current page. Possible actions include: reload, select all, copy, undo, redo (see link::Classes/QWebPageAction::)

    Argument::
        A QWebPageAction.
    Argument::
        A Boolean to enable or disable the action (applies to only some actions).

SUBSECTION:: Data

METHOD:: setHtml
    Set the HTML displayed in the view.

    Argument::
        A String.
    Argument::
        A url. The browser will interpret this to be the current page location.

METHOD:: setContent
    Set the raw content of a web view. This can be used to display binary data such as image / movie files.

    Argument::
        An Int8Array containing data.
    Argument::
        A mime type, of the form e.g. "image/jpeg"
    Argument::
        A url. The browser will interpret this to be the current page location.

METHOD:: setAttribute
    Set a QWebAttribute for the view. Attributes can affect behavior such as caching, auto-loading images, file url access, etc.

    Argument::
        A QWebAttribute.
    Argument::
        A Boolean.

METHOD:: testAttribute
    Check the enablement state of a QWebAttribute.

    Argument::
        A QWebAttribute.
    Returns::
        A Boolean.

METHOD:: resetAttribute
    Reset the enablement state of a QWebAttribute.

    Argument::
        A QWebAttribute.

METHOD:: toPlainText
    Convert the page to plain text.
    Argument::
        A callback function. Called with the resulting plain text string when the operation is finished.

METHOD:: toHtml
    Fetch the HTML of the current page.
    Argument::
        A callback function. Called with the resulting HTML string when the operation is finished.

METHOD:: title
    The title of the current page.
    Returns:: A String.

METHOD:: requestedUrl
    The requested url for the current page.
    Returns:: A String.

METHOD:: selectedText
    The currently selected text.
    Returns:: A String.

SUBSECTION:: Behavior and appearance

METHOD:: audioMuted
    Get or set audio mute setting for the view;
    Argument::
        A Boolean.

METHOD:: contentsSize
    Get the size of the current content.
    Returns::
        A Point

METHOD:: scrollPosition
    Get or sets the scroll position of the current page.
    Returns::
        A Point

METHOD:: hasSelection
    Returns whether the page has a text selection.
    Returns::
        A Boolean.

METHOD:: enterInterpretsSelection
    Whether pressing Ctrl+Return or Ctrl+Enter while some text is selected should evaluate the selection as SuperCollider code.
    Argument::
        A Boolean.

METHOD:: setFontFamily
    Sets a specific font family to be used in place of a CSS-specified generic font family.
    Argument::
        The CSS generic font family to assign a font to; one of link::Classes/QWebFontFamily::
    Argument::
        A font family name to be assigned to the generic family; a String.

METHOD:: zoom
    Gets or sets the zoom level on a page.
    Argument::
        A Number, where 1.0 is the default zoom.

METHOD:: editable
    Get or set whether the entire web page is editable.
    Argument::
        A Boolean.

METHOD:: pageBackgroundColor
    Get or set the default background color of web pages.
    Argument::
        A Color.

SUBSECTION:: Actions

METHOD:: onAudioMutedChanged
    Sets the object to be evaluated when the mute setting of the view has changed.

METHOD:: onRecentlyAudibleChanged
    Sets the object to be evaluated when the page has started or stopped playing audio.

METHOD:: onContentsSizeChanged
    Sets the object to be evaluated when the contents size of the view has changed

METHOD:: onScrollPositionChanged
    Sets the object to be evaluated when the scroll position on a page has changed.

METHOD:: onSelectionChanged
    Sets the object to be evaluated when the text selection on a page has changed.

METHOD:: onJavaScriptMsg
    Sets the object to be evaluated when a javascript console message is posted.

METHOD:: onLinkHovered
    Sets the object to be evaluated when a the mouse rolls over a link.

METHOD:: onTitleChanged
    Sets the object to be evaluated when the title of the displayed page changes.

METHOD:: onUrlChanged
    Sets the object to be evaluated when the url of the displayed page changes.

METHOD:: onLoadProgress
    Sets the object to be evaluated with load progress updates.

METHOD:: onLoadStarted
    Sets the object to be evaluated when a page load begins.

METHOD:: onLoadFinished
    Sets the object to be evaluated when a page has loaded successfully, passing the view as the argument.

METHOD:: onLoadFailed
    Sets the object to be evaluated when a page has failed to load, passing the view as the argument.

METHOD:: overrideNavigation
    When true, page navigation requests will not be handled. Use in combination with onLinkActivated to provide custom navigation behavior.

METHOD:: onLinkActivated
    Sets the object to be evaluated when the user triggers a link. Arguments are: a URL, a QWebPageNavigationType, a bool (page is opening in current view).

    When this is set to other than nil, WebView will stop handling clicked links altogether. Setting this to nil will restore WebView link handling again.
    Note: for specialty behavior when clicking on links, it is much better to use setUrlHandler in most cases.

METHOD:: onReloadTriggered
    Sets the object to be evaluated whenever a page reload is requested, passing the view and the URL to be reloaded (as String) as the arguments.

SUBSECTION:: JavaScript

METHOD:: runJavaScript
    Evaluates the given JavaScript code in the context of the current page.
    Argument::
        A String.
    Argument::
        A function to be called when execution is complete, with the result as first argument.
        NOTE:: javascript code can correctly return Numbers, Strings and Arrays, but it can't currently pass javascript Objects to sclang. It is possible however to use JSON serialization to acheive this: ::
        CODE::
// passing a nested object from javascript to sclang:
WebView().runJavaScript("JSON.stringify({a: [1,2,3], b: {ba: 1, bb: 'yeah'}})"){ |res| res.parseJSON.postln }
::

EXAMPLES::
CODE::
// A simple web browser
(
var browser, webview, reloadStop, prev, next, urlBox, go;

webview = WebView()
	.minSize_(300@200);
reloadStop = Button()
	.states_([["※"], ["◙"]])
	.fixedSize_(36@28);
prev = Button()
	.states_([["⇦"]])
	.fixedSize_(36@28);
next = Button()
	.states_([["⇨"]])
	.fixedSize_(36@28);
urlBox = TextField()
	.minWidth_(100);
go = Button()
	.states_([["⌘"]])
	.fixedSize_(36@28);

reloadStop.action = {
	|v|
	if (v.value == 1) {
		webview.reload(true);
	} {
		webview.stop;
	}
};

prev.action = { webview.back };
next.action = { webview.forward };
urlBox.action = { webview.url = urlBox.string };
go.action = { webview.url = urlBox.string };

webview.onUrlChanged = {
	|view, url|
	urlBox.string = url;
};

webview.onLoadStarted = {
	reloadStop.value = 1;
	urlBox.background = Color.grey(0.4);
};

webview.onLoadFinished = {
	reloadStop.value = 0;
	urlBox.background = Color.grey(0.2);
};

webview.onLoadFailed = {
	reloadStop.value = 0;
	urlBox.background = Color.red(1, 0.2);
};

browser = View(bounds:900@700).layout_(VLayout(
	HLayout(
		prev, reloadStop, next,
		urlBox,
		go
	),
	webview
));

browser.front;

urlBox.valueAction = "http://supercollider.github.io/"
)
::


class:: WhiteNoise
summary:: White noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/ClipNoise, Classes/PinkNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose spectrum has equal power at all frequencies.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-WhiteNoise", { arg out=0;
	Out.ar(out,
		WhiteNoise.ar(0.25)
	)
}).play;
)

::



CLASS:: Window
summary:: Top-level container of views
categories:: GUI>Views

DESCRIPTION::

The Window is the most fundamental element of the GUI. It occupies a rectangular space on the screen within which other GUI elements (Views) are displayed.

A child view is added into a window by passing the window to the view's constructor. See link::Classes/View#*new::.

note::
There is no distinction between windows, views, and containers; a View can be displayed directly on screen, and can contain other views. Therefore, visual descriptions of Window and most of the methods that are specific to Window in other GUI kits, also apply to and make part of View in Qt, and are thus shared by all its subclasses.

The Window class is provided in Qt GUI for compatibility as well as convenience: e.g. unlike View, Window will be created by default in the center of the screen, and various aspects can be conveniently controlled using its constructor arguments.
::

The Window is usually drawn with a bar on its top edge that displays the window's title which you can set in the link::#*new#constructor::, or using link::#-name::.



CLASSMETHODS::

PRIVATE:: key

METHOD:: new

	Creates a new Window instance. You will need to call link::#-front:: on it to become visible.

	argument:: name
		A String for the text that will be displayed in the title bar. The default is 'panel'.
	argument:: bounds
		A Rect specifying position and size of the window. The size does not include the border and title bar. Position is measured from the bottom-left corner of the screen (this is different than link::Classes/View#-bounds::). The default is size 400x400 at position 128x64, but in Qt the window is centered on the screen by default.
	argument:: resizable
		A Boolean indicating whether this window is resizable by the user. The default is code::true::.
	argument:: border
		A Boolean indicating whether this window has a border. Borderless windows have no title bar and thus can only be closed in code. The default is code::true::.
	argument:: scroll
		A Boolean indicating whether this window will add scrollbars if its contents exceed its bounds. If this is set to code::true::, then link::Classes/View#-resize:: settings will be ignored for contained views. The default is false.

METHOD:: allWindows

	An array of all existing Window instances.

METHOD:: closeAll

	Calls link::#-close:: an all existing Window instances.

METHOD:: initAction

	The default action object to be evaluated whenever a new Window is instantiated.

METHOD:: screenBounds

	Returns a Rect with the size of the screen in pixels

METHOD:: availableBounds

	Returns a Rect describing the area of the screen that windows can actually occupy (i.e. excluding the Mac dock, the task bar, or similar).




INSTANCEMETHODS::

SUBSECTION:: View hierarchy

METHOD:: view
	When a Window is created, it creates a container view, accessible using this method, that occupies the whole area of the window, and which will be used as the actual parent of the child widgets.

	returns::
		A View.

METHOD:: asView
	Equivalent to link::#-view::

METHOD:: currentSheet
	note:: Only in Cocoa GUI ::
	returns:
The current modal sheet attached to this window, if it exists. See code:: "SCModalSheet".help ::.



SUBSECTION:: Visibility

METHOD:: front
	Displays the window on the screen (This has the same effect as setting link::#-visible:: to true).

METHOD:: minimize
	Hides the window, only keeping its representation in the dock, taskbar, etc..

METHOD:: unminimize
	Restores the window's previous state after being minimized.

METHOD:: fullScreen
	Displays the window full-screen.

METHOD:: endFullScreen
	Restores the window's previous state after being displayed full-screen.

METHOD:: alwaysOnTop
	Whether the window should always stay on top of other windows, even when it is not the active one.

	argument::
		A Boolean.

METHOD:: visible

	Whether the window is visible.

	Setting this to code::true:: has the same effect as link::#-front::, and setting it to false closes the window without destroying it.

	argument::
		A Boolean.

METHOD:: close

	Closes and destroys the window.

METHOD:: isClosed
	returns:: A Boolean stating whether the view has been closed.




SUBSECTION:: Geometry

METHOD:: bounds

	The position and size of the window. The position is relative to the bottom-left corner of the screen.

	argument::
		A Rect or a Point interpreted link::Classes/Point#-asRect#as Rect::.
	returns::
		A Rect.

METHOD:: setTopLeftBounds

	A convenience method that, unlike link::#-bounds::, sets the bounds by measuring position from the top-left corner of the screen, and vertically offset by code::menuSpacer::.

	argument:: rect
		A Rect.
	argument:: menuSpacer
		An Integer amount of pixels.

METHOD:: setInnerExtent

	Resizes the window, keeping its position intact.

	This is equivalent to link::Classes/View#-resizeTo:: called on the link::#-view::.

	argument:: w
		An Integer width in pixels.
	argument:: h
		An Integer height in pixels.

METHOD:: sizeHint
	Redirects to link::Classes/View#-sizeHint:: of the link::#-view::.

METHOD:: minSizeHint
	Redirects to link::Classes/View#-minSizeHint:: of the link::#-view::.

METHOD:: addFlowLayout

	A convenience method which sets code::decorator:: of the link::#-view:: to a new instance of FlowLayout. See link::Classes/FlowLayout:: for examples.

	argument:: margin
		A Point describing the link::Classes/FlowLayout#-margin#margin:: of the FlowLayout.

	argument:: gap
		A Point describing the link::Classes/FlowLayout#-gap#gap:: of the FlowLayout.

	returns:: The new FlowLayout instance.

METHOD:: layout
	Redirects to link::Classes/View#-layout:: of the link::#-view::.



SUBSECTION:: Appearance

METHOD:: name
	The title of the window.

	argument::
		A String.

METHOD:: background
	The background color of the window.

	argument::
		A Color.

METHOD:: alpha
	The transparency of the window.

	argument::
		A Float between 0.0 (invisible) and 1.0 (opaque).

METHOD:: refresh
	Redraws the window and all its children.



SUBSECTION:: Interaction

METHOD:: userCanClose
	Whether the user can close the window. The default is code::true::.

	argument::
		A Boolean.

METHOD:: acceptsClickThrough
	Whether the window receives clicks when it is not front-most. The default is code::true::.

	argument::
		A Boolean.

METHOD:: acceptsMouseOver
	Whether the window and all its children receive mouse-over events. The default is code::false::.

	See also: link::Classes/View#-acceptsMouseOver:: and link::Classes/View#-mouseOverAction::.

	argument::
		A Boolean.



SUBSECTION:: Actions and hooks

METHOD:: drawFunc
	Just like the link::Classes/UserView::, the window can be given a Function to evaluate whenever it is asked to redraw itself, so you can use the link::Classes/Pen:: class to draw on the window. See link::Classes/UserView#-drawFunc:: for explanation.

	argument::
		A Function.

METHOD:: toFrontAction

	The action object to be evaluated whenever the window becomes the active one.

METHOD:: endFrontAction

	The action object to be evaluated whenever the window ceases to be the active one.

METHOD:: onClose

	The action object to be evaluated when the window is closed.

METHOD:: addToOnClose

	Adds an object to link::#-onClose::, wrapping the current value into an Array, if it is not yet.

METHOD:: removeFromOnClose

	Removes an object from link::#-onClose::, if the latter is an Array.



EXAMPLES::

subsection:: Adding Views

code::
(
var w;
w = Window("my name is... panel", Rect(128, 64, 340, 360));

32.do({ arg i;
    b = Button(w, Rect(rrand(20,300),rrand(20,300), 75, 24));
    b.states = [["Start "++i, Color.black, Color.rand],
        ["Stop "++i, Color.white, Color.red]];
});
w.front;
)
::


subsection:: Using Decorator

code::
(
var w;
w = Window("my name is... panel", Rect(128, 64, 340, 360));

w.view.decorator = FlowLayout(w.view.bounds);
// w.addFlowLayout; // you can als write this instead of the line above

w.view.background = Color(0.6,0.8,0.8);
32.do({ arg i;
    b = Button(w, Rect(rrand(20,300),rrand(20,300), 75, 24));
    b.states = [["Start "++i, Color.black, Color.rand],
        ["Stop "++i, Color.white, Color.red]];
});

w.front;
)
::


subsection:: Setting Bounds

code::
// use screenbounds for precise placement from the top
(
x = Window.new("test", Rect(100,Window.screenBounds.height-180,300,100));x.front;
)

// bounds.top refers to the bottom edge of the window,
// measured from the bottom of the screen. Different than in View.
x.bounds_(Rect(100,400,300,300));
::


subsection:: Borderless Window

code::
w = Window.new(border:false).front; // can't be manually closed
w.close; // so close it in code
::


subsection:: Window with Scrollers

code::
(
w = Window(scroll: true); // you must set this when the window is created
c = Slider2D(w, Rect(0, 0, 1500, 300));
d = Slider(w, Rect(0, 310, 20, 300));
c.background = Color.grey.alpha = 0.6;
d.background = Color.grey.alpha = 0.6;
w.front;
)
::


subsection::onClose

code::
(
x = Window.new.front;
x.alpha = 0.8;
x.onClose_({ y = Synth.new(\default) }); //close the window and the synth plays
)
x.close;
y.free;
::

subsection:: Using Layouts

Layouts are used to organize view sizes automatically. See: link::Guides/GUI-Layout-Management::.

note:: Only in Cocoa GUI ::

code::
// make a window and a layout
(
w = Window(bounds:Rect(700,200,200,200));
h = HLayout();
v = VLayout(h);
w.layout =  v;
w.front;
w.alwaysOnTop = true;
)

// add views step by step

v.add(k = Slider());
h.add(Slider());
h.add(Slider());
k.orientation = \horizontal;


h.add(g = VLayout(), 2, \left);
g.add(TextView());
g.add(TextView().string_("sand and hand"));

v.add(Button());
v.add(Button());
v.add(Button());
g.add(Button());

g.margins = [1, 1, 1, 1];
h.margins = [1, 1, 1, 1] * 23;
v.margins = [1, 1, 1, 1] * 5;

h.add(g = VLayout(), 1, \left);
g.add(g = HLayout(), 1, \left);
5.do { g.add(Slider().orientation_(\vertical)) };
::

subsection:: Drawing on Window with Pen

code::
(
var w, much = 0.02, string, synth;

w = Window.new("gui", Rect(100, 100, 300, 500)).front;
w.view.background_(Color.new255(153, 255, 102).vary);

string = "gui ".dup(24).join;

w.drawFunc = Routine {
    var i = 0;
    var size = 40;
    var func = { |i, j| sin(i * 0.07 + (j * 0.0023) + 1.5pi) * much + 1 };
    var scale;
    var font = Font("Helvetica", 40).boldVariant;
    loop {
        i = i + 1;
        Pen.font = font;
        string.do { |char, j|

            scale = func.value(i, j).dup(6);

            Pen.fillColor = Color.new255(0, 120, 120).vary;
            Pen.matrix = scale * #[1, 0, 0, 1, 1, 0];
            Pen.stringAtPoint(char.asString,
                ((size * (j % 9)) - 10) @ (size * (j div: 9))
            );
        };
        0.yield // stop here, return something unimportant
    }
};

{ while { w.isClosed.not } { w.refresh; 0.04.wait; } }.fork(AppClock);

w.front;

)
::


class:: Wrap
summary:: Wrap a signal outside given thresholds.
related:: Classes/Clip, Classes/Fold
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#wrap2#wrap2:: in that it
allows one to set both low and high thresholds.


classmethods::

method::ar, kr

argument::in

Signal to be wrapped.


argument::lo

Low threshold of wrapping.


argument::hi

High threshold of wrapping.


Examples::

code::

s.boot;

{ Wrap.ar(SinOsc.ar(440, 0, 0.2), -0.15, 0.15) }.scope;

::



class:: WrapIndex
summary:: Index into a table with a signal.
related:: Classes/Index, Classes/Shaper
categories::  UGens>Buffer


Description::

The input signal value is truncated to an integer value and used as an
index into the table. Out-of-range index values are wrapped cyclically to
the valid range.


classmethods::

method::ar, kr

argument::bufnum

Index of the buffer.


argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// indexing into a table
(
{
	var buf = LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]);
	var freq = WrapIndex.kr(buf, MouseX.kr(0, BufFrames.ir(buf) * 3));
	SinOsc.ar(freq) * 0.1
}.play;
)

// the same using a global buffer
(
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_Index, { |out=0, bufnum=0|
	Out.ar(out,
		SinOsc.ar(
			WrapIndex.kr(
				bufnum,
				MouseX.kr(0, BufFrames.ir(bufnum) * 3)
			),
			0,
			0.5
		)
	)
}).play(s, [\bufnum, b.bufnum]);
)

::



class:: XFade2
summary:: Equal power two channel cross fade.
related:: Classes/LinXFade2
categories::  UGens>Multichannel>Select


Description::

Two channel equal power crossfader.


classmethods::

method::ar, kr

argument::inA

Input signal A.


argument::inB

Input signal B.


argument::pan

Crossfade position from -1 to +1.


argument::level

A control rate level input.


Examples::

code::

{ XFade2.ar(Saw.ar, SinOsc.ar, LFTri.kr(0.1) ) }.play

::



TITLE:: XIn
summary:: Helper class used by InBus.
categories:: UGens>InOut
related:: Classes/InBus, Classes/In, Classes/InFeedback, Classes/XInFeedback

DESCRIPTION::
A private class used in the implementation of link::Classes/InBus::.
You should never need to use this UGen directly.





TITLE:: XInFeedback
summary:: Helper class used by InBus.
categories:: UGens>InOut
related:: Classes/InBus, Classes/In, Classes/InFeedback, Classes/XIn

DESCRIPTION::
A private class used in the implementation of link::Classes/InBus::.
You should never need to use this UGen directly.





class:: XLine
summary:: Exponential line generator.
related:: Classes/Line
categories::  UGens>Envelopes


Description::

Generates an exponential curve from the start value to the end value.
Both the start and end values must be non-zero and have the same sign.


classmethods::

method::ar, kr

argument::start

Starting value.


argument::end

Ending value.


argument::dur

Duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


argument::doneAction

A doneAction to be evaluated when the line is completed. See

link::Classes/Done::  for more detail.


Examples::

code::

play({ SinOsc.ar(XLine.kr(200,17000,10),0,0.1) });

::



class:: XOut
summary:: Send signal to a bus, crossfading with previous contents.
related:: Classes/OffsetOut, Classes/Out, Classes/ReplaceOut
categories::  UGens>InOut


Description::

Send signal to a bus, crossfading with previous contents.
code::xfade::  is a level for the crossfade between what
is on the bus and what you are sending. The algorithm is equivalent to this:

code::
bus_signal = (input_signal * xfade) + (bus_signal * (1 - xfade));
::


See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus
The index of the bus to write out to. The lowest numbers are written to the audio hardware.

argument::xfade
Crossfade level.

argument::channelsArray
An Array of channels or single output to write out. You cannot change the size of this once a SynthDef has been built.

Examples::

code::

(
SynthDef("help-SinOsc", { arg freq=440, out;
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).add;

SynthDef("help-XOut", { arg out=0, xFade=1;
	var source;
		source = PinkNoise.ar(0.05);

		// write to the bus, crossfading with previous contents
		XOut.ar(out, xFade, source);

}).add;
)

Synth("help-SinOsc", [\freq, 500]);
a = Synth.tail(s, "help-XOut");


a.set(\xFade, 0.7);
a.set(\xFade, 0.4);
a.set(\xFade, 0.0);

::



class:: ZeroCrossing
summary:: Zero crossing frequency follower
categories:: UGens>Analysis>Pitch

description::
Outputs a frequency based upon the distance between interceptions of the X axis. The X intercepts are determined via linear interpolation so this gives better than just integer wavelength resolution. This is a very crude pitch follower, but can be useful in some situations.

classmethods::
method:: ar, kr
argument::in
Input signal.

examples::

code::
s.boot;
(
{
    var a;
    a = SinOsc.ar(SinOsc.kr(1, 0, 600,700), 0, 0.1);
    [a, ZeroCrossing.ar(a) * 0.0005]
}.scope;
)
::


