title:: Backwards Compatibility
summary:: Classes and methods that improve backwards compatibility with SC2 code
categories:: Language>SC3 vs SC2

There are a number of classes and methods that have been added to allow for backwards compatibility with SC2 code. The most notable of these is code::Synth.play::, which is basically a wrapper for code::Function.play::.

code::
{ SinOsc.ar(440, 0, 0.5) }.play; // creates an arbitrarily named SynthDef and a Synth to play it
Synth.play({ SinOsc.ar(440, 0, 0.5) }); // in SC3 just a wrapper for Function.play with fewer args
::

Both of these will create synth nodes on the default server. Note that neither requires the use of an code::Out.ar:: link::Classes/UGen::; they simply output to the first audio bus. One can however add an link::Classes/Out:: to Function.play in order to specify.

code::
Synth.play({ Out.ar(1, SinOsc.ar(440, 0, 0.5)) });
::

In general, one should be aware of this distinction when using this code. When copying such code for reuse with other SC3 classes (for example in a reusable link::Classes/SynthDef::), it will usually be necessary to add an code::Out.ar::. Although useful for quick testing these methods are generally inferior to code::SynthDef.play::, as the latter is more direct, requires no modifications for general reuse, has greater general flexibility and has slightly less overhead. (Although this is insignificant in most cases, it could be relevant when large numbers of defs or nodes are being created.)

Like code::SynthDef.play::, code::Function.play:: returns a link::Classes/Synth:: object which can then be messaged, etc. However, since code::Function.play:: creates an arbitrarily named link::Classes/SynthDef::, one cannot reuse the resulting def, at least not without reading its name from the post window, or getting it from the link::Classes/Synth:: object.

code::
//The following examples are functionally equivalent
x = { arg freq = 440; Out.ar(1, SinOsc.ar(freq, 0, 0.5)) }.play(fadeTime: 0);
x.set(\freq, 880);		// you can set arguments
y = Synth.new(x.defName);	// get the arbitrary defname from x
x.free;
y.free;

x = SynthDef("backcompat-sine", { arg freq = 440; Out.ar(1, SinOsc.ar(freq, 0, 0.5)) }).play;
x.set(\freq, 880);
y = Synth.new("backcompat-sine");
x.free;
y.free;
::

code::Function.play:: is in general superior to both its SC2 equivalent and code::Synth.play::. It has a number of significant features such as the ability to specify the output bus and fade times as arguments. See the link::Classes/Function:: helpfile for a more in-depth discussion.

A number of other classes and methods have also been added to improve compatibility. These are listed below. In general there are equivalent or better ways of doing the same things in SC3.

table::
## Synth *play || use Function.play or SynthDef.play
## GetFileDialog || use link::Classes/Dialog::
## GetStringDialog ||
## Synth *stop || use Server.freeAll
## Synth *isPlaying || Server.numSynths (this will include non-running nodes)
## Mix *ar *arFill || use Mix *new and *fill
## SimpleNumber.rgb ||
## Rawarray.write ||
::



title:: Bundled Server Messages
summary:: Sending OSC message bundles
categories:: External Control>OSC, Server>Architecture
related:: Guides/ServerTiming

When using the Synth/Node/Group sclang objects there is often a need to construct bundles to send messages together. For example when you want to start a synth that should be mapped instantly to certain buses, or need to ensure that two synths start with precise synchronisation.

The simplest way to deal with this is through Server's automated bundling support. This allows you to open a bundle into which all osc messages will be collected until it is sent. See Server for details of makeBundle's arguments.
code::
s.boot;
(
// send a synth def to server
SynthDef("tpulse", { arg out=0,freq=700,sawFreq=440.0;
	Out.ar(out, SyncSaw.ar(freq,  sawFreq,0.1) )
}).send(s);
)

// all OSC commands generated in the function contained below will be added to a bundle
// and executed simultaneously after 2 seconds.
(
s.makeBundle(2.0, {
	x = Synth.new("tpulse");
	a = Bus.control.set(440);
	x.map(\freq, a);
});
)
x.free;

// don't send
(
b = s.makeBundle(false, {
	x = { PinkNoise.ar(0.1) * In.kr(0, 1); }.play;
});
)
// now pass b as a pre-existing bundle, and start both synths synchronously
(
s.makeBundle(nil, { // nil executes ASAP
	y = { SinOsc.kr(0.2).abs }.play(x, 0, 0, \addBefore); // sine envelope
}, b);
)
x.free; y.free;
::

To send a bundle with the default latency of the server, use the message bind:
code::
(
s.bind {
	SynthDef("tpulse2", { arg out=0, freq=700, sawFreq=440.0;
		Out.ar(out, Pan2.ar(SyncSaw.ar(freq,  sawFreq, 0.1), SinOsc.kr(8)) )
	}).send(s);
	s.sync; // wait until synthdef is loaded
	x = Synth.new("tpulse2");
	a = Bus.control.set(440);
	x.map(\freq, a);
};
)

a.free; x.free;
::

In addition to this there are a number of methods which return OSC messages which can be added to a bundle. These are detailed in the helpfiles for link::Classes/Node::, link::Classes/Synth::, and link::Classes/Group::.
code::
s.boot;
b = List.new;
c = Bus.control(s, 1).set(660);
x = Synth.basicNew("default", s); // Create without sending
b.add(x.newMsg);
b.add(x.mapMsg(\freq, c));
b.postln; // here's what it looks like
s.listSendBundle(1.0, b); // Execute after 1 second
c.set(440);
s.queryAllNodes;
x.free;
::



title:: Client vs Server
summary:: Client versus Server Architecture and Operations
categories:: Server>Architecture, External Control>OSC

The name "SuperCollider" is in fact used to indicate five different things (Figure 1):
numberedlist::
## an audio server
## an audio programming language
## an interpreter for the language, i.e. a program able to interpret it
## the interpreter program as a client for the server
## the application including the two programs and providing mentioned functionalities
::

image::structureEn.png#Figure 1. Structure of the SuperCollider application::

The SuperCollider application is thus made up of two distinct, autonomous, components, a server and a client. For the first we have a choice between scsynth (SC-synthesizer) and supernova, and for the second we have sclang (SC-language).

section:: Description

The SuperCollider application makes use of client/server architecture which separates two functions, respectively one providing and the other requesting services. The client and the server communicate through a network.

image::s8kfFC-clientServerEn.png#Figure 2. Client/Server architecture::

In Figure 2 a generic network architecture is depicted: A number of clients communicating with a server by exchanging messages through a network. In SuperCollider the client and the server make use of a specific subset of CNMAT's Open Sound Control (OSC) protocol in order to communicate (over TCP or UDP). As a consequence, you will see many references to "OSC messages" in the help files.

To avoid any possible confusion: The network is defined at an abstract level. This means that the client(s) and the server(s) can be in execution on the same physical machine. This is what normally happens when you use the SuperCollider application: two programs will run on your machine, scsynth (or supernova) and sclang.

The server app, emphasis::scsynth:: or emphasis::supernova::, is a lean and efficient command line program dedicated to audio synthesis and processing. It knows nothing about SC code, objects, Object Oriented Programming, or anything else to do with the SC language.

The client of this server is emphasis::sclang::. Sclang performs two distinct tasks:
definitionList::
## Client || it is the emphasis::client:: for the server, i.e. it sends OSC messages to the server.
In order to write a letter to server, you need a paper sheet and a mailer: sclang is both.
## Interpreter || it is the emphasis::interpreter:: for the SuperCollider programming language, i.e. it allows to the user to write code in the aforementioned language and interactively execute the resulting commands, e.g. to control the audio server. In particular OSC messages can be cumbersome to write, as they share with the server its low-level perspective. The SuperCollider language is a high-level, fully featured object oriented language, allowing the user to gain a much more expressive power than OSC messages. Typically, the interpreter translates the code in SuperCollider language in OSC messages for the server. The user writes poetry (so to speak) in the SuperCollider language which is then paraphrased in OSC prose by the sclang interpreter, to be sent to the server.
::

From inside sclang, starting a server app can be accomplished by:
code::
s = Server.default; // create a new Server object and assign it to variable s
s.boot;             // boot the server app, i.e. tell the server to be ready to work
::
The sclang interpreter can send OSC messages to the server in two fashions:
definitionList::
## directly || in this case, sclang offers a thin syntax layer which allows one to deal with raw OSC messages. All the server's functionality is in this case available "by hand" using the .sendMsg method of link::Classes/Server::, and other similar messages.
code::
n = s.nextNodeID;                   // get an available nodeID from the server and assign it to n
s.sendMsg("/s_new", "default", n);  // use the SynthDef "default" to create a synth with ID n
s.sendMsg("/n_free", n);            // release the synth n
::
## indirectly || the language app provides you with convenient OOP functionality to keep track of and manipulate things on the server. The high-level syntax is translated into low-level OSC messages by sclang and sent to the server (language wrapping).
code::
x = Synth("default");   // create a synth on the default server (s) and allocate an ID for it
x.free;                 // free the synth, its ID and resources
::
::
Working this way you have gained certain functionality. It provides a node ID for you automatically, it allows you to control the Synth in syntactically elegant and efficient ways (see the link::Classes/Synth:: and link::Classes/Node:: helpfiles), and to access all the advantages of object oriented programming while doing so.  Encapsulating the complexities and bookkeeping greatly reduces the chance of bugs in your own code.

image::scEn.png#Figure 3. Sclang as a high-level client::

Language wrapping allows the user to access complex behaviours from very little code. Figure 3 (ignore for the moment that sclang is represented as a client among other possible ones, see later) schematically represents what happens when you evaluate an audio function like this:
code::
// assuming the server is already booted
{SinOsc.ar}.play ;
::
In this case many server operations are hidden. To understand the  passages involved in the evaluation of this code see link::Tutorials/Getting-Started/04-Functions-and-Other-Functionality:: and link::Tutorials/Getting-Started/10-SynthDefs-and-Synths:: (part of Scott Wilson's tutorial).

The OOP-style also has a small amount of overhead. It requires clientside CPU cycles and memory to create and manipulate an object. Normally this is not significant, but there may be times when you would prefer to use the less elegant, and less expensive first method, for instance when creating large numbers of grains which will simply play and then deallocate themselves.

Thus it is possible to create synth nodes on the server without actually creating Synth objects, providing you are willing to do the required housekeeping yourself. The same is true of group nodes, buffers, and buses. A more detailed discussion of these concepts can be found in the link::Guides/NodeMessaging:: helpfile.

In conclusion, the crucial thing to remember is the distinction between things like nodes, busses, buffers, and servers and the objects that represent them in the language app (i.e. instances of link::Classes/Node::, link::Classes/Bus::, link::Classes/Buffer::, and link::Classes/Server::; these are referred to as 'Server Abstraction Objects'). Keeping these conceptually distinct will help avoid much confusion.


section:: Pros/Cons

The client/server architecture provides three main advantages:
definitionList::
## stability || if the client crashes, the server keeps on working, i.e. the audio does not stop. This is intuitively relevant for a live situation. Vice versa, the server can crash letting you still manage the situation from the client.
## modularity || synthesis is one thing, control another. Separating the two aspects allows one to (for example) control the server from applications other than sclang. The only important thing is that they are able to send the right OSC messages to the server.
## remote control || the client/server network can be external to your computer, e.g. over the Internet. This allows one to control an audio server in Alaska from a client (sclang or other) in India, for example.
::

There are two notable drawbacks:
definitionlist::
## latency || The messaging process introduces a small amount of latency. This should not be confused with audio latency which can be quite low. It only means that there is a small, usually insignificant delay between the one side sending a message and the other receiving it and acting upon it. (This can be minimized by using the 'internal' server. See link::Classes/Server:: for more detail.)
## asynchronous execution || In some cases the client might need to know that a task on the server (for instance processing a large sound file) has been completed before continuing with another task. Since some tasks take an arbitrary length of time to complete, a reply mechanism is necessary. This can add some complexity to your code, but is in principle not an issue. (See link::Classes/OSCFunc:: and link::Classes/OSCdef::.) Some server abstraction objects such as link::Classes/Buffer:: provide for this automatically through 'action' functions which wait for completion before executing.
::

section:: A final remark for the advanced reader

Apart from sclang, it is possible to control the server from any other client which provides for OSC messaging (e.g. from Java, Python, Max/MSP, etc.). For networking, see link::Reference/Server-Architecture::, link::Classes/NetAddr::, link::Classes/OSCFunc::.

In general however, sclang is the preferable way to communicate with the server for three reasons:
list::
## it gives you the expressive power of the SuperCollider language;
## the language is explicitly fitted to the server's needs (and, more importantly, to musician's ones)
## it allows one to create and load SynthDefs onto the server (see link::Classes/SynthDef::), which not all client apps are able to do
::



title:: Debugging tips
summary:: tips on debugging synthdefs, client code and more
categories:: Language, Debugging
related:: Guides/Understanding-Errors

section:: Debugging synthdefs

The challenge in debugging synthdefs is the invisibility of the server's operations. There are a handful of techniques to expose the output of various UGens.

subsection:: SendTrig / OSCFunc

SendTrig is originally intended to send a trigger message back to the client, so the client can take further action on the server. However, it can be used to send any numeric value back to the client, which can then be printed out.

To print out the values, you need to create an OSCFunc as follows:
code::
o = OSCFunc({ |msg| msg.postln }, '/tr', s.addr);
::
Each line of output is an array with four values: code:: ['/tr', defNode, id (from SendTrig), value (from SendTrig)] ::.

code::
{	var	freq;
	freq = LFNoise1.kr(2, 600, 800);
		// Impulse is needed to trigger the /tr message to be sent
	SendTrig.kr(Impulse.kr(4), 0, freq);
	SinOsc.ar(freq, 0, 0.3) ! 2
}.play;
[ /tr, 1000, 0, 1340.8098144531 ]
[ /tr, 1000, 0, 1153.9201660156 ]
[ /tr, 1000, 0, 966.35247802734 ]
[ /tr, 1000, 0, 629.31628417969 ]

o.free;  // when done, you need to clean up the OSCFunc
::

If you need to track multiple values, SendReply can send arrays of values back to the client.

code::
l = List.new;
o = OSCFunc({ |msg|
		// msg[3] is the first array value
		// [3..] means take everything in the array after that
	l.add(msg[3..]);
}, '/freqAmp', s.addr);

a = {
	var	freq, amp;
	freq = LFNoise0.kr(8, 600, 800);
	amp = LFNoise1.kr(10, 0.5, 0.5);
		// Impulse is needed to trigger the reply to be sent
	SendReply.kr(Impulse.kr(4), '/freqAmp', [freq, amp]);
	SinOsc.ar(freq, 0, amp) ! 2
}.play;

a.free;
o.free;  // when done, you need to clean up the OSCFunc

// plot as two channels: frequencies in the top graph, amps in the bottom
l.flat.plot(numChannels: 2);
::

subsection:: Polling

Polling allows you to debug a SynthDef by printing samples of a UGen's output to the post window. To do this, use the .poll method (a shorthand for the Poll UGen), which prints 10 times per second by default.

code::
{ LFNoise1.kr.poll; }.play;   // default poll
::

This can be too fast, so you can specify how many times per second the value should be printed.

code::
{ LFNoise1.kr.poll(3); }.play;  // poll more slowly
::

You can also poll arrays

code::
{ [LFNoise1.kr, LFNoise1.kr].poll; }.play;  // poll an array
::

For more than one value or array at once, poll can become unwieldy, because so many values are printed to the screen that it is difficult to tell which is which. Labels help with this.

code::
{ LFNoise1.kr.poll(3, "a value"); LFNoise1.kr.poll(5, "another value"); }.play;
::

Debugging triggers doesn't work with regular polling, because the trigger will mostly occur in between polling intervals. The output itself can be supplied instead of the number of polls per second. This way, the value is only printed when there is a trigger, rather than at a regular interval.

code::
{ var trig = Dust.kr; trig.poll(trig); }.play;
::

You can debug a value that changes infrequently in a similar way, using the Changed UGen. This only prints the value when it just changed.

Note that it will skip changes that occur immediately after a previous change, because any trigger needs to revert back to zero before triggering again.

code::
{ var steps = LFNoise0.kr; steps.poll(Changed.kr(steps); }.play;
::

You can also use a separate trigger. This is useful for having the most control over when a poll occurs.

code::
~synth={ arg t_trig; [LFNoise1.kr, LFNoise1.kr].poll(t_trig); }.play;

// the t_ in t_trig is shorthand to cause ~synth.set(\t_trig, 1) to trigger instead of set permanently
~synth.set(\t_trig, 1); // run this line a couple of times
::

All the examples above work the same for audio rate UGens.

code::
{ LFNoise1.ar.poll; }.play;
::

subsection:: Trace control signals using a control bus

Another technique to watch control values is to output the signal to a control-rate bus. Then you can access the bus using link::Classes/Bus#-get:: or link::Classes/Bus#-getSynchronous::. Saving the values into an Array or List is a little more straightforward with getSynchronous.

code::
b = Bus.control(s, 1);

a = {
	var	freq;
	freq = LFNoise1.kr(2, 600, 800);
	Out.kr(b, freq);		// no need for Impulse here
	SinOsc.ar(freq, 0, 0.3) ! 2
}.play;

l = List.new;
r = fork { loop { l.add(b.getSynchronous); 0.1.wait } };

r.stop;
a.free;

l.array.plot;  // to view the results graphically
::

This works only with internal or local servers. For remote servers, the routine may be rewritten as follows.

code::
r = fork { loop { b.get({ |value| l.add(value) }); 0.1.wait } };
::

note::This approach is not valid for audio buses, because the data move too quickly to support 'get'.::

subsection:: Server-side trace

The code::/n_trace:: message causes the server to print a list of all the UGens in the node as well as their input and output values.

It takes some practice to read a synthdef trace, but it's the ultimate source of information when a synthdef is not behaving as expected. Signal flow can be identified by looking at the numbers at inputs and outputs. When a UGen's output feeds into another's input, the values will be the same at both ends.

For a concrete example, let's look at a synthdef that doesn't work. The intent is to generate a detuned sawtooth wave and run it through a set of parallel resonant filters whose cut-off frequencies are modulating randomly.
We run the synth and generate the trace (reproduced below).
code::
SynthDef(\resonz, { |out, freq = 440|
	var	sig, ffreq;
	sig = Saw.ar([freq, freq+1], 0.2);
	ffreq = LFNoise1.kr(2, 1, 0.5);
	Out.ar(out, Resonz.ar(sig, (800, 1000..1800) * ffreq, 0.1))
}).send(s);

a = Synth(\resonz);
a.trace;
a.free;

		TRACE 1005  resonz    #units: 21
		  unit 0 Control
		    in
		    out 440
		  unit 1 BinaryOpUGen
		    in  440 1
		    out 441
		  unit 2 Saw
		    in  441
		    out 0.451348
		  unit 3 BinaryOpUGen
		    in  0.451348 0.2
		    out 0.0902696
		  unit 4 Saw
		    in  440
		    out -0.367307
		  unit 5 BinaryOpUGen
		    in  -0.367307 0.2
		    out -0.0734615
		  unit 6 LFNoise1
		    in  2
		    out -0.836168
		  unit 7 BinaryOpUGen
		    in  -0.836168 0.5
		    out -0.336168
		  unit 8 BinaryOpUGen
		    in  800 -0.336168
		    out -268.934
		  unit 9 Resonz
		    in  -0.0734615 -268.934 0.1
		    out 843934
		  unit 10 BinaryOpUGen
		    in  1000 -0.336168
		    out -336.168
		  unit 11 Resonz
		    in  0.0902696 -336.168 0.1
		    out 3.02999e+08
		  unit 12 BinaryOpUGen
		    in  1200 -0.336168
		    out -403.402
		  unit 13 Resonz
		    in  -0.0734615 -403.402 0.1
		    out 9.14995e+10
		  unit 14 BinaryOpUGen
		    in  1400 -0.336168
		    out -470.635
		  unit 15 Resonz
		    in  0.0902696 -470.635 0.1
		    out -5.42883
		  unit 16 BinaryOpUGen
		    in  1600 -0.336168
		    out -537.869
		  unit 17 Resonz
		    in  -0.0734615 -537.869 0.1
		    out 515.506
		  unit 18 BinaryOpUGen
		    in  1800 -0.336168
		    out -605.102
		  unit 19 Resonz
		    in  0.0902696 -605.102 0.1
		    out 32785.2
		  unit 20 Out
		    in  0 843934 3.02999e+08 9.14995e+10 -5.42883 515.506 32785.2
		    out
::

Two problems leap out from the trace: first, there are six channels of the output (there should be 1), and second, all the outputs are well outside the audio range -1..1. The first is because we use multichannel expansion to produce an array of Resonz filters, but we don't mix them down into a single channel.

Note that there are no out of range signals prior to each Resonz. Looking at the Resonz inputs, we see that the frequency input is negative, which will blow up most digital filters.

The resonance frequency derives from multiplying an array by a LFNoise1. Tracing back (the red, italicized numbers), the LFNoise1 is outputting a negative number, where we expected it to be 0.5..1.5. But, the mul and add inputs are reversed!

If you look very carefully at the trace, you will see another problem relating to multichannel expansion. The two components of the detuned sawtooth go into alternate Resonz'es, where we expected both to go, combined, into every Resonz. To fix it, the sawtooths need to be mixed as well.
code::
SynthDef(\resonz, { |out, freq = 440|
	var	sig, ffreq;
	sig = Mix.ar(Saw.ar([freq, freq+1], 0.2));
	ffreq = LFNoise1.kr(2, 0.5, 1);
	Out.ar(out, Mix.ar(Resonz.ar(sig, (800, 1000..1800) * ffreq, 0.1)))
}).send(s);

a = Synth(\resonz);
a.trace;
a.free;
::

section:: Debugging client-to-server communication

Some bugs result from OSC messages to the server being constructed incorrectly. Julian Rohrhuber's DebugNetAddr is a convenient way to capture messages. The class may be downloaded from: http://swiki.hfbk-hamburg.de:8888/MusicTechnology/710 .

To use it, you need to quit the currently running local server, then create a new server using a DebugNetAddr instead of a regular NetAddr. Messages will be dumped into a new document window.
code::
s.quit;

Server.default = s = Server.new('local-debug', DebugNetAddr("localhost", 57110));
s.boot;
s.makeWindow;		// optional

	latency nil		// these messages get sent on bootup
		[ "/notify", 1 ]

	latency nil
		[ "/g_new", 1 ]

a = { SinOsc.ar(440, 0, 0.4) ! 2 }.play;

	latency nil
		[ "/d_recv", "data[ 290 ]", [ 9, "-1589009783", 1001, 0, 1, 'i_out', 0, 'out', 0 ] ]

a.free;

	latency nil
		[ 11, 1001 ]
::

section:: Debugging client code

SuperCollider does not have a step trace function, which makes debugging on the client side tougher, but not impossible.

subsection:: Errors

Learning how to read SuperCollider error output is absolutely essential. Error dumps often (though not always) contain a great deal of information: what the action was, which objects are being acted upon, and how the flow of execution reached that point.

See the link::Guides/Understanding-Errors:: help file for a tutorial.

There's also a graphic Inspector for error dumps, which is enabled with the following command:
code::
Exception.debug = true;		// enable
Exception.debug = false;	// disable
::
In most cases, this will give you more information than a regular error dump. Usually the regular error dump is sufficient. If you are using Environments or prototype-style programming, the graphic inspector is indispensable.

subsection:: Debug output using post statements

The most common approach is to insert statements to print the values of variables and expressions. Since the normal printing methods don't change the value of an expression, they can be placed in the middle of the statement without altering the processing flow. There's no significant difference between:
code::
if(a > 0) { positive.value(a) };
::
and
code::
if((a > 0).postln) { positive.value(a) };
::

Common methods to use are:
code::
.postln
.postcs		// post the object as a compile string
.debug(caller)	// post the object along with a tag identifying the caller
::

code::
(
var	positiveFunc;
positiveFunc = { |a|
	a.debug('positiveFunc-arg a');
	a*10
};
a = 5;
if (a > 0) { positiveFunc.value(a) };
)

// output:
positiveFunc-arg a: 5
50
::

The caller argument is optional; however, it's very helpful for tracing the origin of erroneous values.

Another advantage of .debug is that it's easier to search for them in your source code and remove them later.

To print multiple values at one time, wrap them in an array before using .debug or .postcs. Note that if any of the array members are collections, postln will hide them behind the class name: "an Array, a Dictionary" etc. Use postcs if you expect to be posting collections.
code::
[val1, val2, val3].debug(\myMethod);
[\callerTag, val1, val2, val3].postcs;
::
By sprinkling these throughout your code, especially at the beginnings of functions or methods, the debugging output can give you a partial trace of which code blocks get visited in what order.

subsection:: dumpBackTrace

If you discover that a particular method or function is being entered but you don't know how it got there, you can use the code::.dumpBackTrace:: method on any object. You'll get what looks like an error dump, but without the error. Execution continues normally after the stack dump.
code::
(
var	positiveFunc;
positiveFunc = { |a|
	a.debug('positiveFunc-arg a');
	a.dumpBackTrace;
	a*10
};
a = 5;
if (a > 0) { positiveFunc.value(a) };
)

// output:
positiveFunc-arg a: 5
CALL STACK:
	< FunctionDef in closed FunctionDef >
		arg a = 5
	< closed FunctionDef >
		var positiveFunc = <instance of Function>
	Interpreter-interpretPrintCmdLine
		arg this = <instance of Interpreter>
		var res = nil
		var func = <instance of Function>
	Process-interpretPrintCmdLine
		arg this = <instance of Main>
50
::
This tells you that the function came from interpreting a closed FunctionDef (automatically created when evaluating a block of code).

In a method definition, it's recommended to use code::this.dumpBackTrace::; in a free-standing function, there is no "this" so you should pick some arbitrary object.

subsection:: Tracing streams

To see the results of a pattern, use the .trace method. Each output value from the pattern gets posted to the main output.
code::
s.boot;
SynthDescLib.global.read;

p = Pbind(\degree, Pwalk((0..14), Pdup(Pwhite(1, 4, inf), Prand(#[-2, -1, 1, 2], inf)), Pseq(#[-1, 1], inf), 0), \delta, 0.25, \sustain, 0.2, \instrument, \default).trace.play;

p.stop;
::

subsection:: Debugging infinite loops or recursion
code::
while(true);
::
This is a bad idea. It will lock up SuperCollider and you will have to force quit. Sometimes this happens in your code and the reason isn't obvious. Debugging these situations is very painful because you might have to force quit, relaunch SuperCollider, and reload your code just to try again.
code::
f = { |func| func.value(func) };
f.value(f);
::
Infinite recursion, on the other hand, is more likely to cause SuperCollider to quit unexpectedly when the execution stack runs out of space.

In macOS, inserting "post" or "debug" calls will not help with infinite loops or recursion, because posted output is held in a buffer until execution is complete. If execution never completes, you never see the output.

One useful approach is to insert statements that will cause execution to halt. The easiest is .halt, but it provides you with no information about where or how it stopped, or how it got there. If you want a more descriptive message, make up an error and throw it:
code::
Error("myFunction-halt").throw;
::
When debugging code that crashes, place a line like this somewhere in the code. If you get the error output, you know that the infinite loop is happening after the error--so move the error.throw later and try again.
If it crashes, you know the infinite loop is earlier. Eventually, after a lot of heartache, you can zero in on the location.

Here is a rogues' gallery of infinite loop gotchas--things that don't look like infinite loops, but they will kill your code quicker than you can wish you hadn't just pushed the enter key:
code::
i = 0;
while (i < 10) { i.postln; i = i+1 }; 	// crash
::
While loop syntax is different in SuperCollider from C. The above loop means to check whether i < 10 once, at the beginning of the loop, then loop if the value is true. Since the loop condition is evaluated only once, it never changes, so the loop never stops. The loop condition should be written inside a function, to wit:
code::
i = 0;
while { i < 10 } { i.postln; i = i+1 };
::
Routines and empty arrays:
code::
a = Array.new;
r = Routine({
	loop {
		a.do({ |item| item.yield });
	}
});
r.next;	// crash
::
This looks pretty innocent: iterate repeatedly over an array and yield each item successively. But, if the array is empty, the do loop never executes and yield never gets called. So, the outer loop{} runs forever, doing nothing.

Recursion is often used to walk through a tree structure. Tree structures are usually finite--no matter which branch you go down, eventually you will reach the end. If you have a data structure that is self-referential, you can easily get infinite recursion:
code::
a = (1..10);
a.put(5, a);	// now one of the items of a is a itself
a.postcs;		// crash--postcs has to walk through the entire collection, which loops on itself
::
Self-referential data structures are sometimes an indication of poor design. If this is the case, avoid them.
code::
a = 0;
SystemClock.sched(2, { a.postln });	// crashes when scheduler fires the function
::
When a scheduled function executes, if it returns a number, the function will be rescheduled for now + the number. If the number is 0, it is effectively the same as an infinite loop.

To fix it, make sure the function returns a non-number.
code::
a = 0;
SystemClock.sched(2, { a.postln; nil });
::

subsection:: Removing debugging statements

Use formatting to help your eye locate debugging statements when it's time to remove them. SuperCollider code is usually indented. If you write your debugging statements fully left-justified, they're much easier to see.
code::
a = Array.new;
r = Routine({
	loop {
		"debugging".postln;	// looks like regular code, doesn't stand out
		a.do({ |item| item.yield });
	}
});
r.next;	// crash

// vs:

a = Array.new;
r = Routine({
	loop {
"debugging".postln;	// this obviously sticks out
		a.do({ |item| item.yield });
	}
});
r.next;	// crash
::



title:: FFT Overview
summary:: Overview of the Fast Fourier Transform (FFT) UGens
categories:: UGens>FFT
related:: Classes/FFT, Classes/IFFT

section:: FFT and IFFT

SuperCollider implements a number of UGens supporting Fast Fourier Transform (FFT) based processing. The most basic of these are FFT and IFFT (inverse-FFT) which convert data between the time and frequency domains:
code::
chain = FFT(buffer, input)
::
code::
output = IFFT(chain)
::


FFT requires a link::Classes/Buffer:: or link::Classes/LocalBuf::. The buffer's size must correspond to a power of 2, and must also be a multiple of the server's current link::Classes/ServerOptions#-blockSize#block size::. The window size is equivalent to the buffer size, and the window link::Classes/FFT#*new#overlap defaults to 2 (hop = 0.5)::. Both link::Classes/FFT:: and link::Classes/IFFT:: use a sine window by default. Their combination  efficiently becomes a Hanning window (i.e. raised sine, that is, sine squared).



section::How FFT UGens communicate

link::Classes/FFT:: stores spectral data in the buffer, in the following format:

table::
## DC || nyquist || real 1f || imag 1f || real 2f || imag 2f ||  ... || real (N-1)f ||  imag (N-1)f
::

where code::f:: is the frequency corresponding to the window size, and code::N:: is the window size / 2.



The code::FFT:: UGen returns a signal (usually called strong::chain::) is constant at code::-1::, only when a new FFT window starts, the signal equals the buffer number. This is how subsequent FFT UGens can write to that buffer and know when to do this. The FFT information is not in the chain signal, but in the buffer.

code::
// the FFT return signal is -1, and for each starting window,
// it is the FFT buffer number

b = Buffer.alloc(s, 512); // allocate FFT buffer
b.bufnum; // note the buffer number

(
var dt = s.options.blockSize / s.sampleRate * 16; // plot 16 blocks
var min = -2, max = b.bufnum + 4;
// input is SoundIn, but we don't see this signal
{ FFT(b, SoundIn.ar) }.plot(dt, minval:min, maxval:max).plotMode_(\steps);
)

b.free; // free the buffer again
::

section:: Phase Vocoder UGens and Spectral Processing

In between an FFT and an IFFT one can chain together a number of Phase Vocoder UGens (i.e. code::PV_...::) to manipulate blocks of spectral data before reconversion. The process of buffering the appropriate amount of audio, windowing, conversion, overlap-add, etc. is handled automatically.

See link::#PV and FFT UGens in the Standard Library:: for a list of UGens.


code::
(
{
  var in, chain;
	in = WhiteNoise.ar(0.8);
	chain = FFT(LocalBuf(2048), in); // encode to frequency domain
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4)); // process
	IFFT(chain) // decode to time domain
}.play;
)
::

In order to expand PV UGens for a multichannel input signal, an appropriate array of buffers must be provided (not a multichannel buffer):

code::
(
{
  var in, chain;
	in = Ringz.ar(Impulse.ar([2, 3]), [700, 800], 0.1) * 5; // stereo input
	chain = FFT({ LocalBuf(2048) } ! 2, in); // array of two local buffers
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4));
	IFFT(chain) // returns a stereo out
}.play;
)
::

For more examples, see link::#Multichannel Expansion with FFT UGens::

subsection::Parallel FFT chains

PV UGens write their output data emphasis:: in place ::, i.e. back into the same buffer from which they read. PV UGens which require two buffers write their data into the first buffer, usually called 'bufferA'.
code::

(
{
  var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar(MouseY.kr(100, 1000, 1), 0, 0.2);
	inB = Ringz.ar(Impulse.ar(MouseX.kr(1, 100, 1)), 700, 0.5);
	// make two parallel chains
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB); // writes into bufferA
	IFFT(chain) * 0.1
}.play;
)

d.free;
::

A similar example using a soundfile:

code::
// read the soundfile into a buffer
d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
  var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar(100, 0, 0.2);
	inB = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB); // writes into bufferA
	IFFT(chain) * 0.1
}.play;
)

d.free;
::

subsection::Copying FFT chains

Because each PV UGen overwrites the output of the previous one, it is necessary to copy the data to an additional buffer at the desired point in the chain in order to do parallel processing of input without using multiple FFT UGens. link::Classes/PV_Copy:: allows for this.

note::As of SC 3.7 instances of PV_Copy are added automatically where necessary for parallel processing. Existing code explicitly using PV_Copy should continue to work.::

code::

(
{
	var in, in2, chainA, chainB, chainC;
	var mod = LFNoise2.kr(2);
	in = Blip.ar(mod.exprange(4000, 2), 231);
	in2 = SinOsc.ar(mod.exprange(200, 4000));
	chainA = FFT(LocalBuf(2048), in);
	chainB = FFT(LocalBuf(2048), in2);
	chainC = PV_Copy(chainA, LocalBuf(2048));
	chainB = PV_MagMul(chainB, chainC);
	XFade2.ar(
		IFFT(chainA) * 0.4,
		IFFT(chainB) * 0.1,
		MouseX.kr(-1, 1)
	);
}.play
)
::

PV processes can also share a single FFT UGen to process a signal in parallel. In the following example, 'chain0' and 'chain1' share the same FFT UGen. SuperCollider automatically copies the FFT data from 'chain' into hidden LocalBufs inside the Synth. In the following example, if the link::Classes/PV_PhaseShift:: UGen were operating directly on code::chainA::, then the two link::Classes/IFFT:: units would produce the same signal, which, when added together, would reinforce each other. Instead, the sound is nearly silent -- proving that code::chainB:: is in a different buffer, even though the function does not explicitly create it.

code::
(
x = { var inA, chainA, chainB;
	inA = LFClipNoise.ar(100);
	chainA = FFT(LocalBuf(2048, 1), inA);
	chainB = PV_PhaseShift(chainA, pi);
	// half-circle phase shift should result in an inverse signal
	// in practice, ultra-low frequencies sneak through
	// but you won't hear very much here
	IFFT(chainA) + IFFT(chainB);
}.play;
)
::


subsection::Plotting magnitudes

Note that PV UGens convert as needed between cartesian (complex) and polar representations, therefore when using multiple PV UGens it may be impossible to know in which form the values will be at any given time. FFT produces complex output (see above). The following, however, returns a reliable magnitude plot:

code::
c = Buffer.alloc(s,2048,1);

(
x = { var in, chain, chainB, chainC;
	in = WhiteNoise.ar;
	chain = FFT(c, in);
	0.01 * Pan2.ar(IFFT(chain));
}.play(s);
)

(
Routine({
	3.do{arg i;
		c.getToFloatArray(action: { arg array;
			var z, x;
			z = array.clump(2).flop;
			// Initially data is in complex form
			z = [Signal.newFrom(z[0]), Signal.newFrom(z[1])];
			x = Complex(z[0], z[1]);

			{ x.magnitude.plot('Initial', Rect(200, 600-(200*i), 700, 200)) }.defer
		});
		0.1.wait;
}}).play
)

x.free;
::


subsection::UGen access to FFT data

It is possible to manipulate the FFT data directly within a synth graph (if there doesn't already exist a PV UGen which will do what you want), using the methods pvcalc, pvcalc2, pvcollect. Here's an example which uses the  methods link::Classes/SequenceableCollection#-clump:: and link::Classes/SequenceableCollection#-flop:: to rearrange the order of the spectral bins:

code::
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
x = {
	var in, numFrames=2048, chain, v;
	in = PlayBuf.ar(1, c, loop: 1);
	chain = FFT(LocalBuf(numFrames), in);

	chain = chain.pvcalc(numFrames, {|mags, phases|
		/* Play with the mags and phases, then return them */
		[mags, phases].flop.clump(2).flop.flatten
	}, tobin: 250);

	0.5 * IFFT(chain).dup
}.play;
)
x.free; c.free;
::


section:: Multichannel Expansion with FFT UGens


Care must be taken when using multichannel expansion with FFT UGens, as they require separate buffers. Code such as this can be deceptive:
code::
chain = FFT(bufnum, { WhiteNoise.ar(0.2) }.dup);
::

The above may seem to work, but does not. It does result in two FFT UGens, but as they both write to the same buffer, the second simply overwrites the data from the first, thus wasting CPU and accomplishing nothing.

When using multichannel expansion with FFT UGens it is necessary to ensure that each one writes to a different buffer. Here's an example of one way to do this:

	code::
(
SynthDef("help-multichannel FFT", { |out=0| // bufnum is an array
	var in, chain;
	in = [SinOsc.ar(200, 0, 0.2), WhiteNoise.ar(0.2)];
	chain = FFT(LocalBuf([2048, 2048]), in); // each FFT has a different buffer
	// now we can multichannel expand as normal
	chain = PV_BrickWall(chain, SinOsc.kr(-0.1));

	Out.ar(out, IFFT(chain));
}).play;
)

// or using global buffers

b = { Buffer.alloc(s, 2048, 1) }.dup;

(
SynthDef("help-multichannel FFT", { |out=0, bufnum= #[0, 1]| // bufnum is an array
	var in, chain;
	in = [SinOsc.ar(200, 0, 0.2), WhiteNoise.ar(0.2)];
	chain = FFT(bufnum, in); // each FFT has a different buffer
	// now we can multichannel expand as normal
	chain = PV_BrickWall(chain, SinOsc.kr(-0.1));

	Out.ar(out, IFFT(chain));
}).play(s,[\bufnum, b]);
)

b.free;
::

Note that dup on a UGen just makes a reference to that UGen, because UGen defines -copy to simply return the receiver. (See link::Classes/UGen:: for more detail.)
code::
a = SinOsc.ar;
a.dup[1] === a

true
::
Code like code::IFFT(chain).dup:: is found throughout the PV help files , and is just a convenient way to copy a mono signal to stereo, without further computation.

See also link::Guides/Multichannel-Expansion::.

section:: PV and FFT UGens in the Standard Library

The following PV UGens are included in the standard SC distribution:
definitionlist::
## link::Classes/FFT:: || Fast Fourier Transform
## link::Classes/IFFT:: || Inverse Fast Fourier Transform
## link::Classes/PV_Add:: || complex addition
## link::Classes/PV_BinScramble:: || scramble bins
## link::Classes/PV_BinShift:: || shift and stretch bin position
## link::Classes/PV_BinWipe:: || combine low and high bins from two inputs
## link::Classes/PV_BrickWall:: || zero bins
## link::Classes/PV_ConformalMap:: || complex plane attack
## link::Classes/PV_CopyPhase:: || copy magnitudes and phases
## link::Classes/PV_Diffuser:: || random phase shifting
## link::Classes/PV_HainsworthFoote:: || onset detection
## link::Classes/PV_JensenAndersen:: || onset detection
## link::Classes/PV_LocalMax:: || pass bins which are a local maximum
## link::Classes/PV_MagAbove:: || pass bins above a threshold
## link::Classes/PV_MagBelow:: || pass bins below a threshold
## link::Classes/PV_MagClip:: || clip bins to a threshold
## link::Classes/PV_MagFreeze:: || freeze magnitudes
## link::Classes/PV_MagMul:: || multiply magnitudes
## link::Classes/PV_MagDiv:: || division of magnitudes
## link::Classes/PV_MagNoise:: || multiply magnitudes by noise
## link::Classes/PV_MagShift:: || shift and stretch magnitude bin position
## link::Classes/PV_MagSmear:: || average magnitudes across bins
## link::Classes/PV_MagSquared:: || square magnitudes
## link::Classes/PV_Max:: || maximum magnitude
## link::Classes/PV_Min:: || minimum magnitude
## link::Classes/PV_Mul:: || complex multiply
## link::Classes/PV_PhaseShift:: || shift phase of all bins
## link::Classes/PV_PhaseShift270:: || shift phase by 270 degrees
## link::Classes/PV_PhaseShift90:: || shift phase by 90 degrees
## link::Classes/PV_RandComb:: || pass random bins
## link::Classes/PV_RandWipe:: || crossfade in random bin order
## link::Classes/PV_RectComb:: || make gaps in spectrum
## link::Classes/PV_RectComb2:: || make gaps in spectrum
## link::Classes/UnpackFFT::, link::Classes/PackFFT::, link::Classes/Unpack1FFT:: || "unpacking" components used in pvcalc, pvcalc2, pvcollect (can also be used on their own)
::
For a full list of FFT UGens, see strong::UGens>FFT:: in the link::Browse#UGens>FFT:: page.



title:: Introduction to GUI
summary:: An introduction to writing graphical user interface code
categories:: GUI

note::
To avoid confusion, we start off with an important historical note. SuperCollider used to have a pretty nasty GUI class system that involved platform-dependent classes like SCWindow. This system is completely gone in 3.7 with a unified Qt GUI.

You will still see remnants of the old GUI classes in some SuperCollider help files and quarks. We're still working on updating all the help files. If you encounter such old classes in a quark, you can do a public service by informing the quark author.
::

SECTION:: Basic elements: Windows, views and containers

The most fundamental element of the GUI is the strong::Window::. It occupies a rectangular space on screen within which other GUI elements are displayed. It usually has a bar that displays the window's title and allows for moving it, resizing it and closing it with the controls it displays or through mouse and keyboard interaction. Some of these aspects may be controlled within SuperCollider GUI code, though it is largely platform-dependent how precisely interaction with a window happens and is visually indicated.

The GUI elements contained within a Window are called strong::views::. They all inherit from the basic View class. The view occupies a rectangular space of the window within which it draws itself to display some data or to indicate a mode of interaction between the user and the program. Views receive keyboard and mouse events generated by the user and respond to them by controlling the behavior of the program. They also display information about the state of the program and the data on which it operates.

There are also special types of views that can contain other views and are thus called strong::containers::, for example the CompositeView. They allow for structuring GUI in a hierarchical way. A container view is called a strong::parent:: of the views it contains, and they are called its strong::children::. Hierarchical organization allows to easily change aspects of all the views within a container: if the parent view is hidden, so are all the children; if the parent view is moved, so are they. Children are positioned with coordinates relative to their parent.

note::
In many aspects, a Window is also considered to be a parent of the views it contains, and can functionally take the same place in code as container views, although that is not true in all cases. When a Window is created it implicitly creates a container view occupying its entire space. When a view is created with a Window as its parent it will actually become a child of that container. See Window's link::Classes/Window#-view#view:: method and View's link::Classes/View#*new#constructor:: for details.
::

note::
In strong::Qt GUI:: there is no distinction between windows, views, and containers. An instance of the View class itself can be displayed directly on screen, and can contain other views, so the same applies to all its subclasses. Most of the methods that are specific to Window and containers in other GUI kits are shared by all views in Qt.
::

The following example shows a window containing a Button, a Slider and a group of StaticText views contained in a CompositeView. When the button is clicked the visibility of the CompositeView is toggled, while interacting with the Slider will move the CompositeView (and consequently all its contents) in horizontal direction.

code::
w = Window.new("GUI Introduction", Rect(200,200,255,100));
b = Button.new(w,Rect(10,0,80,30)).states_([["Hide"],["Show"]]);
l = Slider.new(w,Rect(95,0,150,30));
c = CompositeView.new(w,Rect(20,35,100,60));
StaticText.new(c,Rect(0,0,80,30)).string_("Hello");
StaticText.new(c,Rect(20,30,80,30)).string_("World!");
b.action = { c.visible = b.value.asBoolean.not };
l.action = { c.bounds = Rect( l.value * 150 + 20, 35, 100, 100 ) };
w.front;
::



SECTION:: Automatic positioning and resizing of views

As a handy alternative to specifying all the dimensions and positions of views explicitly in code, SuperCollider allows for automatic positioning and resizing of views in relation to each other and in relation to window size - at the view creation and dynamically, when window is resized. There is several mechanisms for this purpose.

subsection:: View's resize options

Views can automatically resize or move when their parent is resized, in one of the nine different ways that define how each of the view's edges will move along with the parent's edges. For documentation see the view's link::Classes/View#-resize#resize:: method and link::Reference/Resize:: document.

code::
w = Window.new("GUI Introduction", Rect(200,200,200,200));
TextField.new(w,Rect(0,0,200,30)).resize_(2);
Slider.new(w,Rect(0,30,30,170)).resize_(4);
TextView.new(w,Rect(30,30,170,170)).resize_(5);
w.front;
::

subsection:: Decorators

Decorators are objects that can be assigned to container views to carry the task of positioning the container's child views (currently there exists only one: FlowLayout). After a decorator is assigned to a container, the views created as its children will automatically be positioned in a specific pattern. See documentation of link::Classes/FlowLayout:: for details.

code::
w = Window.new("GUI Introduction", Rect(200,200,320,320)).front;
// notice that FlowLayout refers to w.view, which is the container view
// automatically created with the window and occupying its entire space
w.view.decorator = FlowLayout(w.view.bounds);
14.do{ Slider(w, 150@20) };
::

subsection:: Layouts

Layout classes make part of a complex system to manage both position and size of views. Using layouts, only relations of views within a pattern of organization need to be specified and their exact positions as well as sizes will automatically be deduced based on their type (the content they display and the type of interaction they offer) and in accord with principles of good GUI usability. Layouts also position and resize views dynamically, whenever their parent is resized or their contents change.

See the link::Guides/GUI-Layout-Management:: guide for detailed explanation.

note::
Layouts are currently implemented strong::only in Qt GUI::. The following example will not work in other GUI kits.
code::
w = Window.new("GUI Introduction").layout_(
	VLayout(
		HLayout( Button(), TextField(), Button() ),
		TextView()
	)
).front;
::
::

note::
Layouts are not compatible with decorators and will ignore view resize options. The effect of combining layouts and decorators is undefined.
::

SECTION:: Customizing appearance

Views offer various ways to customize their appearance. This ranges from decorative changing of colors they use to draw themselves to controlling how they display various kinds of data.

subsection:: Colors

Colors are represented in GUI code by the link::Classes/Color:: class.

A typical color that can be customized is background color - a color of choice can be applied to whatever is considered to be the background of a particular view. Views that display some text will typically also allow customizing its color as well.

Custom colors may be associated with different changing states of views or data they display, for example: Button allows to associate background and text colors with each one of its states, and will thus switch colors together with state when clicked; ListView allows to set a different background color for each of its items, as well as special background and text colors applied only to the item currently selected.

Whenever you execute the following example, random colors will be applied to different aspects of the views:

code::
(
w = Window("GUI Introduction").background_(Color.rand).front;
b = Button(w, Rect(10,10,100,30)).states_([
	["One",Color.rand,Color.rand],
	["Two",Color.rand,Color.rand],
	["Three",Color.rand,Color.rand]
]);
l = ListView.new(w, Rect(10,50,200,100))
	.items_(["One","Two","Three"])
	.colors_([Color.rand,Color.rand,Color.rand])
	.hiliteColor_(Color.blue)
	.selectedStringColor_(Color.white);
r = Slider(w, Rect(10, 160, 200, 20))
	.knobColor_(Color.rand)
	.background_(Color.rand);
)
::

subsection:: Palette

In Qt GUI, the complete set of colors used to draw the views is represented by a palette (see the link::Classes/QPalette:: class). Using a palette, you can define (most of) the appearance of the whole GUI in one go.

In the following example, clicking on the button will switch between two palettes. Note however, that the color assigned to the first Button state will beat the red color defined in the palette, and that colors of individual ListView items are not controlled by the palette.

code::
(
x = QPalette.auto(Color.red(0.8), Color.red(0.5));
y = QPalette.auto(Color.cyan(1.4), Color.cyan(1.8));
p = QtGUI.palette;
QtGUI.palette = x;
w = Window.new("GUI Introduction").front;
w.onClose = {QtGUI.palette = p};
Button.new(w, Rect(10,10,100,30)).states_([
	["Red", Color.black, Color.grey(0.7)],
	["Cyan"]
]).action_({ |b| QtGUI.palette = if(b.value == 0){x}{y} });
ListView.new(w, Rect(10,50,200,100))
	.items_(["One","Two","Three"])
	.colors_([Color.grey(0.4),Color.grey(0.5),Color.grey(0.6)]);
Slider(w, Rect(10, 160, 200, 20));
RangeSlider(w, Rect(10, 190, 200, 20));
)
::

subsection:: Fonts

Views that display some text will typically allow you to specify a custom font for it. Fonts are represented by the link::Classes/Font:: class, which can also be queried for the default font used in general, as well as the default font specifically for the "serif", "sans-serif" and "monospace" font types. It can also be queried for all available fonts on the system.

code::
(
w = Window.new("GUI Introduction",Rect(200,200,200,70)).front;
a = [Font.defaultMonoFace, Font.defaultSansFace, Font.defaultSerifFace];
b = Button.new(w,Rect(10,10,180,50))
	.states_([["Monospace"],["Sans serif"],["Serif"]])
	.font_(a[0])
	.action_({|b| b.font = a[b.value]});
)
::

subsection:: Other visual properties

Complex views may have many other ways to customize how they display the same data. link::Classes/MultiSliderView:: and link::Classes/EnvelopeView:: are good examples.






SECTION:: Actions and hooks: Make that button do something!

Views and windows can be assigned strong::actions:: that they will perform whenever a specific event occurs as a result of user's interaction. Technically, an action can be any Object, and when the relevant event occurs, it's link::Classes/Object#-value#value#:: method will be called. For example, it is useful to assign a Function as an action, which allows one to define an arbitrary chunk of code to be performed in response to a GUI event.

Objects can also be given to views and windows to evaluate on events that are not a direct result of user's interaction, but convey useful information about the view's operation and the state it moved in. In this case they are often differentiated from actions and called strong::hooks::.

Here, we will give an overview of different kinds of actions and hooks. See link::Classes/View#Actions in general:: and following sections for precise explanation of how to assign and make use of them.


subsection:: Default actions

Views can typically be assigned a default action with their link::Classes/View#-action#action:: setter method, which will be performed when the view's primary mode of interaction is invoked. The default action for a Button for example occurs when it is clicked, for a Slider when its handle is moved.

In the following example, pressing the button will open an exact same window but at different position.

code::
~makeWindow = { var w;
	w = Window.new("Evader",Rect(500.rand + 100, 500.rand + 100, 200,50)).front;
	Button.new(w,Rect(10,10,180,30)).states_([["Evade"]]).action_(~makeWindow);
};
~makeWindow.value;
::

subsection:: Keyboard and mouse actions

All the views can be assigned actions to specific mouse and keyboard events, no matter what other effects those events might have on the view or what other specialized actions or hooks the view might trigger on these events.

You can assign actions to strong::mouse events:: generated when the mouse pointer enters the space of a view, when it moves over them, and when a mouse button is pressed or released.

See link::Classes/View#Mouse actions:: for details.

In the following example the StaticText will report whether the Button is pressed or released.

code::
w = Window.new(bounds:Rect(200,200,200,50)).front;
b = Button.new(w,Rect(10,10,80,30)).states_([["Off"],["On"]]);
t = StaticText(w,Rect(100,10,90,30)).string_("Button released");
b.mouseDownAction = { t.string = "Button pressed" };
b.mouseUpAction = { t.string = "Button released" };
::

You can assign actions to strong::keyboard events:: generated whenever a key is pressed or released while the view has keyboard focus. Keyboard focus is a state of a view in which it has exclusive priority to respond to keyboard events. A view that has keyboard focus typically in a way visually indicates so. On most platforms, pressing the Tab key will switch the keyboard focus between views in the active window and clicking on a view will give it focus.

See link::Classes/View#Key actions:: for details.

Typing text into any of the TextFields in the following example will change the color of the rectangle bellow, for each TextField a different color.

code::
w = Window.new(bounds:Rect(200,200,200,100)).front;
x = TextField(w,Rect(10,10,80,30));
y = TextField(w,Rect(110,10,80,30));
t = StaticText(w,Rect(10,40,180,50));
~reset = {t.background = Color.red};
x.keyDownAction = {t.background = Color.green};
x.keyUpAction = ~reset;
y.keyDownAction = {t.background = Color.blue};
y.keyUpAction = ~reset;
~reset.value;
::

If a key or mouse event is not handled by the view on which it occurs, it may strong::propagate:: to the parent view, and trigger the parent's action. See link::Classes/View#Key and mouse event processing:: for detailed explanation.

subsection:: Drag and drop actions

When a mouse button is pressed on a view together with Cmd(macOS) or Ctrl(Other OS) key and the mouse pointer is moved while holding the button, a strong::drag-and-drop:: operation is initiated - in case the view supports it. Most views have a default object that they export when a drag is attempted. For a Slider it is its value, for a List it is the numeric index of the currently selected item, etc. It is said that the exported object is being strong::dragged::. When the dragging gesture ends on another view by releasing the mouse button on top of it, it is said that the dragged object was strong::dropped:: on another view. A view may respond to various objects dropped on it in different ways.

It is possible to customize what object a view exports when dragged from and how a view reacts to objects dropped by assigning custom drag and drop actions.

See link::Classes/View#Drag and drop:: for details.

code::
(
	w = Window.new.front;
	a = Button(w, Rect(10, 10, 200, 20)).states_([["Hi There!"]]);
	a.beginDragAction = { a.dragLabel ="I'm dragging: \""++ a.states[0][0]++"\""; a.states[0][0] };
	DragSink(w,Rect(10,40,200,20)).align_(\center).string="Cmd-drag from Button to here";
)
::

subsection:: Other specialized actions

Some views can be assigned actions on other events specific to their mode of interaction with the user which you are invited to discover by consulting their documentation.

subsection:: Hooks

Hooks are various events that signify important changes of state of GUI elements. Technically they are used the same way as actions, but are distinguished from them to denote events that are not a direct result of the user's interaction. Methods of GUI classes used to assign hooks are usually prefixed with "on". (You will also find this naming pattern in methods of other SuperCollider classes, that have hooks in the same sense).

For example, one hook that every view as well as Window has is onClose, which is triggered when the window is closed or the view is removed. Other hooks for example exist for the case when a Window becomes or ceases to be the active one.




SECTION:: Custom views

The UserView is a view that displays and does nothing on itself, but allows emphasis::you:: to define how it will be drawn, and for which you can  define the entire behavior using mouse, key, and drag and drop actions. For documentation on all of these aspects, see link::Classes/UserView::, link::Classes/View::, and link::Classes/Pen::. The explanation below, however, will demonstrate the basic techniques for designing a custom view.

You will be using the link::Classes/Pen:: class to draw the view. Pen is a powerful class that allows you to algorithmically draw using simple visual primitives like lines, arcs, curves, rectangles, ellipses, etc. and fill the shapes with colors and gradients.

note:: Older tutorials might recommend subclassing UserView. Don't do that. Use composition, not inheritance. Make the UserView a property of your custom view class. ::

Creating a custom view involves the following steps:

numberedList::
## create a User View
## define a draw function
## define the default action
## define mouse actions
## define key actions
## define drag and drop actions
::

You can omit steps which you don't need.

code::
(
var value = 0.5;
w = Window.new.front;

// (1) create a UserView
v = UserView(w,Rect(50,50,200,20));

// (2) define a drawing function using Pen
v.drawFunc = {
	// Draw the fill
	Pen.fillColor = Color.grey;
	Pen.addRect(Rect(0,0, v.bounds.width*value,v.bounds.height));
	Pen.fill;
	// Draw the triangle
	Pen.fillColor = Color.red;
	Pen.moveTo(((v.bounds.width*value)-5) @ v.bounds.height);
	Pen.lineTo(((v.bounds.width*value)+5) @ v.bounds.height);
	Pen.lineTo(((v.bounds.width*value)) @ (v.bounds.height/2));
	Pen.lineTo(((v.bounds.width*value)-5) @ v.bounds.height);
	Pen.fill;
	// Draw the frame
	Pen.strokeColor = Color.black;
	Pen.addRect(Rect(0,0, v.bounds.width,v.bounds.height));
	Pen.stroke;
};

// (3) set the default action
v.action = {value.postln; v.refresh};

// (4) define mouse actions
v.mouseDownAction = { arg view, x = 0.5,y, m;
	//m.postln;
	([256, 0].includes(m)).if{ // restrict to no modifier
	value = (x).linlin(0,v.bounds.width,0,1); v.doAction};
};

v.mouseMoveAction = v.mouseDownAction;

// (5) (optional) define key actions
v.keyDownAction = { arg view, char, modifiers, unicode,keycode;
	if (unicode == 16rF700, { value = (value+0.1).clip(0,1) });
	if (unicode == 16rF703, { value = (value+0.1).clip(0,1) });
	if (unicode == 16rF701, { value = (value-0.1).clip(0,1) });
	if (unicode == 16rF702, { value = (value-0.1).clip(0,1) });
	v.doAction;
};

// (6) (optional) define drag and drop behavior
v.beginDragAction = {value}; // what to drag
v.canReceiveDragHandler = {View.currentDrag.isNumber}; // what to receive
v.receiveDragHandler = {value = View.currentDrag; v.doAction }; // what to do on receiving


// just for testing drag and drop
Slider(w,Rect(50,100,200,20));

StaticText(w,Rect(50,150,350,50)).string_("To Test Drag and Drop,\nHold down Cmd (Ctl) Key");

)
::

SECTION:: Caution: GUI and timing

warning::
Executing code that uses the GUI system is restricted to main application context. There are many ways in SuperCollider for code to be executed in other contexts that run in parallel with the main one, and interacting with GUI objects is not allowed there. This includes:

list::
## Code scheduled on the SystemClock and the TempoClock
## Code executed in response to OSC messages
::

::

If you attempt to interact with a GUI object in the contexts listed above, an error will be thrown.

Therefore, if you want to use Functions, Routines, Tasks and other similar objects to schedule code that interacts with GUI elements, you must do so using the AppClock, since code scheduled on the AppClock is performed in the main application context. You can of course also reschedule GUI code to the AppClock from within code performed in other contexts, and the link::Classes/Function#-defer#'defer':: mechanism is a convenient shorthand for this.

An example of scheduling GUI code on the AppClock:

code::
w=Window.new.front;
Routine{
	20.do{
	w.bounds=Rect(200.rand, 200+200.rand, 300,300);
	0.1.wait;
	};
	w.close;
}.play(AppClock)
::

The same thing using the SystemClock in combination with the defer mechanism:

code::
w=Window.new.front;
Routine{
	20.do{
	{w.bounds=Rect(200.rand, 200+200.rand, 300,300) }.defer; // you must defer this
	0.1.wait;
	};
	{w.close}.defer; // you must defer this
}.play(SystemClock)
::

As mentioned above, using the GUI system is also not allowed in code performed directly in response to OSC messages (this includes functions given to all kinds of OSC responder classes). The same solutions as above apply.

Another example for addressing this issue can be found in the FAQ link::Guides/UserFAQ#Language (client) Issues#Language (client) Issues::


title:: Layout Management
summary:: Using layout classes to manage distribution of child views within parents
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Classes/StackLayout

The purpose of layouts is to distribute the amount of space given to the view on which they are installed among the children of that view. Each subclass of Layout has a specific pattern of space distribution (a line, a 2D grid, etc.). See their documentation for details.

A layout is installed on a view to manage the space the view occupies and distribute it among its child views. These child views can in turn have other layouts installed, managing the space given to them. But a layout can also manage other layouts directly - one layout can directly occupy a place in another layout's distribution pattern. A basic unit on which a layout operates is therefore abstractly called an item and can be a view or another layout.

note::
While layouts can form a hierarchy on their own, in terms of view hierarchy all views managed by those layouts are direct children of the view on which the top layout is installed.
::

The following is an example of a VLayout, organizing a series of TextFields in a vertical line, and its last item is a HLayout, organizing a series of Buttons in a horizontal line.

code::
(
w = Window(bounds:Rect(200,200,200,200)).layout_(
	VLayout(
		TextField(), TextField(), TextField(),
		HLayout( Button(), Button(), Button() )
	)
).front;
)
::


section:: How a layout does its job

A layout does its job by resizing and moving items within the parent view to form a specific distribution pattern, in accord with items' own size preferences and constraints, and with the common sense of what makes the GUI useful.

To explain how the layout operates, let's first take a look at intrinsic size preferences and constraints of views:


subsection:: Intrinsic view sizes

Every view intrinsically has a strong::preferred size:: and a strong::minimum size::, returned by link::Classes/View#-sizeHint:: and link::Classes/View#-minSizeHint::, respectively. The preferred size is a suitable size for the view to comfortably draw itself, display its contents and allow interaction, while the minimum size is the absolute minimum that the view needs to properly draw itself (including its contents). Both may change when the view's contents change; for example, most views that display some text will report a different code::sizeHint:: when the text changes (unless the text is scrollable).

A view takes on its preferred size at construction, if the 'bounds' argument is omitted. However, there is usually no way to set the text on a view at construction, so the size it automatically gets will not reflect the changes in text done after construction. You can remedy that by resizing the view to its code::sizeHint:: after the text has been set - but the strong::purpose of layouts:: (explained below) is exactly to do that automatically for you. Here is an example of manually using the code::sizeHint:::

code::
// Create a Window with a StaticText
(
w=Window().alwaysOnTop_(true);
t=StaticText(w);
w.front;
)

// There's no text set yet. Post the sizeHint of StaticText:
t.sizeHint

// Set the text, and post the sizeHint again:
t.string_("This is a looooooong text");
t.sizeHint

// Adjust the size to the sizeHint:
t.bounds = t.bounds.size_(t.sizeHint);

// Now you can see the whole text
::

As their names suggest, code::sizeHint:: and code::minSizeHint:: are only hints, and do not prevent one from setting a different size. You can, however, set a strong::hard limit:: on the size using link::Classes/View#-minSize::, link::Classes/View#-maxSize:: and similar methods:

code::
x=View(bounds:Rect(30,30,100,100)).alwaysOnTop_(true).front;

// Set the minimum size limit:
x.minSize = Size(200,200);

// The view automatically resized to the minimum size.
// Now try to shrink it back:
x.resizeTo(100,100);

// The view did not allow a smaller size than minSize.
::

subsection:: Automatic and dynamic space distribution

A layout strong::automatically:: distributes its space among its items, possibly in strong::unequal:: parts, based on the intrinsic preferences and constraints of views described above. Moreover, views also have intrinsic preferences as to whether they profit from being extended horizontally or vertically, or whether they prefer their size to be fixed in a certain direction. This is also taken into account by a layout.

A layout works strong::dynamically::, meaning that it redistributes the space whenever the amount of it changes (the view on which it is installed or the parent layout is resized), whenever items are added or removed, and whenever the size constraints and preferences of items change. The latter may happen for instance when a property of a view that affects its appearance is changed.

A layout will affect space distribution strong::up the layout hierarchy:: - it will define its own constraints and preferences according to its distribution pattern as well as the sum of constraints and preferences of its items. Ultimately, this means that the user's ability to resize a window will be limited by size constraints determined on the basis of window's contents.

For example: in a HLayout (a layout organizing items in a horizontal line) containing a Button and a TextField, the Button will be given a fixed amount of width according to the text it displays, while the TextField will be given all the width that is left. The other Button in the example code below will occupy all the width of the window, since there is no other item competing for that particular space. Note that both Button and TextField have an intrinsically fixed height and so their height never changes when resizing the window. The size constraints also limit the minimum size that the window can be resized to.

code::
(
w = Window.new(bounds:Rect(100,100,300,80)).layout_(
	VLayout (
		HLayout(
			Button().states_([["Super"]]),
			TextField().string_("Collider")
		),
		Button().states_([["SuperCollider"]])
	)
).front;
)
::

section:: User customization

subsection:: Stretch factors

Layouts typically allow the user to override their default distribution policy by assigning stretch factors to items or aspects of the layout's distribution pattern.

code::
(
w = Window.new(bounds:Rect(100,100,400,80)).layout_(
	HLayout(
		[Button().states_([["Super"]]), stretch:1],
		TextField().string_("Collider")
	)
).front;
)
::

subsection:: Size constraints

The user can override a view's intrinsic size constraints and preferences that the layout will take into account, by placing a hard-limit on a view's size, as described above.

code::
(
w = Window.new(bounds:Rect(100,100,300,300)).layout_(
	VLayout(
		TextField().string_("Super").minHeight_(80),
		TextField().string_("Collider").maxWidth_(150)
	)
).front;
)
::

The minimum size of a view is especially important for UserViews which doesn't have by default a minimum size. In the example the first UserView is invisible.

code::
(
w = Window.new(bounds:Rect(100,100,200,200)).layout_(
	VLayout(
		UserView.new.background_(Color.rand),
		TextField().string_("Super").maxWidth_(100),
		UserView.new.background_(Color.rand).minSize_(200@200),
		TextField().string_("Collider").maxWidth_(100)
	)
).front;
)
::

subsection:: Alignment

The combination of size constraints and preferences of all items in a layout hierarchy may result in a larger amount of space given to an item than its own constraints allow. In that case the item will only grow up to its maximum allowed size, and its position within its extra available space may be controlled by user by assigning alignment to an item.

code::
(
w = Window.new.layout_(
	HLayout(
		[Button.new.states_([["Super"]]), align:\bottom],
		TextView(),
		[Button.new.states_([["Collider"]]), align:\top]
	)
).front;
)
::


section:: View vs. layout hierarchies

A layout starts to operate on the space that a view occupies from the moment it is installed on that view on. However, it will not automatically affect child views that where created before the layout was. For views to be managed by a layout they have to be created as children of a view after the layout has been installed on it, or they have to be explicitly inserted into the layout via layout's constructor or its instance methods for this purpose.

subsection:: View constructed with a parent

When a view is created with another view as parent it will implicitly become subject to the management of the parent's layout - it will be inserted into the layout in some default way. However, layouts like link::Classes/GridLayout:: have a complex space distribution pattern and so you will need to use their dedicated methods to specify exactly what place in the layout's distribution pattern a view will occupy.

subsection:: View explicitly inserted into a layout

A view can also be constructed with no parent given; after it is explicitly inserted into a layout via the layout's constructor or an instance method, it will automatically become a child of the view on which the layout is or will be installed. In case the layout occupies place directly in another layout, the view will become a child of the view on which the topmost layout is installed.


title:: Glossary
summary:: Glossary of some relevant words
categories:: Help

definitionlist::
## buffer
keyword:: buffer
|| A server-side header and array of 32 bit floating point sample data. Buffers are used for sound files, delay lines, arrays of global controls, and arrays of inter-synth patch points. Represented by the client-side class link::Classes/Buffer::.

## class
keyword:: class
|| A description of the state and behaviour of a set of objects.

## client
keyword:: client
|| SC is divided into two separate applications: The client and the server. The client is where the SuperCollider language is implemented and where one executes code. The server actually synthesizes the audio, contains the node tree of synths and groups and responds to Open Sound Control messages from the client. See link::Guides/ClientVsServer:: for more information.

## group
keyword:: group
|| A linked list of nodes. Groups provide ways to control execution of many nodes at once. A group is a kind of node. Colloquially one can understand a group as an ordered grouping of other nodes, which may include both synths and other groups. Represented by the client-side class link::Classes/Group::.

## interface
keyword:: interface
|| The set of messages to which an object responds.

## instance
keyword:: instance
|| One of the objects described by a class.

## instance variable
keyword:: variable
|| A part of an object's internal state

## message
keyword:: message
|| A request for an object to perform an operation.

## method
keyword:: method
|| A description of the operations necessary to implement a message for a particular class.

## MIDI
keyword:: midi
|| A protocol for sending music control data between synthesizers.

## node
keyword:: node
|| One point in a tree of nodes executed in a depth first traversal order by the synth engine. There are two types of nodes, synths and groups. These are represented by the client-side classes link::Classes/Synth:: and link::Classes/Group::, and their abstract superclass link::Classes/Node::. The node tree defines the order of execution for synths.

## object
keyword:: object
|| Something that has data, representing the object's state, and a set of operations that can be performed on the object.

## Open Sound Control
keyword:: OSC, opensoundcontrol
|| a protocol defined by CNMAT at UCBerkeley for controlling synthesizers. See http://opensoundcontrol.org/. SuperCollider communicates between the client and server using OSC messages over UDP or TCP.

## OSC
|| See Open Sound Control.

## polymorphism
keyword:: polymorphism
|| The ability for different kinds of objects to respond differently to the same message.

## protocol
keyword:: protocol
|| A set of messages that implement a specific kind of behaviour.

## receiver
keyword:: receiver
|| The object to which a message is sent.

## server
keyword:: server
|| SC is divided into two separate applications: The client and the server. The client is where the SuperCollider language is implemented and where one executes code. The server actually synthesizes the audio, contains the node tree of synths and groups and responds to Open Sound Control messages from the client. See link::Guides/ClientVsServer:: for more information.

## synth
keyword:: synth
|| A sound processing module, based upon a particular synth definition. Similar to "voice " in other systems. Synths are referred to by a number. Represented by the client-side class link::Classes/Synth::.

## synth definition
keyword:: synthdef
|| A definition for creating new synths. Synth definitions are like a pattern or design for synths. Similar to "instrument" in other systems. Represented by the client-side class link::Classes/SynthDef::.

## TCP
keyword:: tcp
|| A protocol for streaming data over a network.

## UDP
keyword:: udp
|| A protocol for sending datagrams over a network.
::


title:: HID permissions
summary:: Details how to configure your computer to set the permissions to access HID's
categories:: External Control>HID
related:: Guides/Working_with_HID, Classes/HID

section:: On Linux

You will have to set the permissions with udev to be correct, create a file in the folder: code:: /etc/udev/rules.d/ ::, and name it (e.g.) code:: 90-hidraw-permissions.rules ::

In the file, you will need this line:

code:: KERNEL=="hidraw*", SUBSYSTEM=="hidraw", MODE="0664", GROUP="plugdev" ::

This will give read and write permissions to hidraw-devices to users that are in the code:: plugdev :: group on your system.

To check whether you belong to that group execute the command code:: groups :: in the terminal.

After you have added the udev rules file, you can access the device after plugging and replugging the device.

You can change the permission manually (as root) from the terminal with the command:
code::
sudo chmod 664 /dev/hidraw*
sudo chgrp plugdev /dev/hidraw*
::

Check the permissions with:

code::
"ls /dev/hidraw* -lah".unixCmd;
::


title:: How to Use the Interpreter
summary:: Basic tutorial on how to run code
categories:: Frontends, Tutorials

This document is macOS (SCapp) specific in key commands, though the principles extend to all platforms. See the helpfile link::Reference/KeyboardShortcuts:: for key commands in other editors. For the emacs sclang interface please also see link::Reference/EmacsEditor:: specific documentation.

You can execute any single line expression by clicking anywhere in that line and pressing the 'strong::Enter::' key.
strong::Note that the 'Enter' key is not the same key as 'Return' ::. If you don't have an enter key, then you can use ctrl-Return, Ctrl-c, fn-Return (on Some Macs), or Shift-Return.

You will need to start the default server before you can hear any examples. By convention the default server is assigned to the interpreter variable 's'. (At startup the default will be the localhost server.) You can start the server app by pressing the 'Boot' button on the localhost server window, or you can do it in code:

code::
// execute these lines one at a time by placing the cursor on the line and then pressing 'enter'

s.boot; // this boots the default Server. Watch the post window and server window for the result

// once that's done execute this to make a sound
{ FSinOsc.ar(800, 0, 0.1) }.play;
::

(Press and hold Cmd (the Apple key) and then press period to stop the sound started above.)

In the help files all executable fragments are written in the Monaco font.

If an expression has multiple lines you can select all of the lines before typing 'Enter'.

code::
// Select all 9 of the following lines and press 'Enter':
w = Window.new("Fading").front;
r = Routine({
	200.do({|i|
		w.view.background = Color.blue(val: 1, alpha: 1 - (i * 0.005));
		0.005.wait;
	});
	w.close;
});
AppClock.play(r);
::

Some examples do require lines to be executed one at a time, or certain lines to be executed first. By far the most common case of this is booting the server app, as we did at the top of the page. Until the server has completed booting, no sound producing code will work.

However, most of the examples included with the app have parentheses around lines of code which should be executed at the same time. (This is a convention which should be followed in your own code.) This allows you to double click to the right of the open paren and select the entire expression. Then press 'enter'.

code::
(
// ^^^^^^^^ double click above this line ^^^^^^^^
play({
// Three patches in one...
n = 5;	// number of strings
b = [	// array of possible impulse excitation behaviours
		{ Impulse.ar(2 + 0.2.rand, 0.3) }, // slow phasing
		{ Dust.ar(0.5, 0.3) },	// "wind chimes"
		{ Impulse.ar(SinOsc.kr(0.05+0.1.rand, 2pi.rand, 5, 5.2), 0.3) } // races
	].choose;	// choose one at random to use for all voices
Mix.new(
	Array.fill(n, {	// n strings tuned randomly to MIDI keys 60-90
		var delayTime;
		// calculate delay based on a random note
		delayTime = 1 / (60 + 30.rand).midicps;
		Pan2.ar(
			LeakDC.ar(	// removes DC buildup
				CombL.ar(	// used as a string resonator
					Decay.ar(	// decaying envelope for noise
						b.value,// instantiate an exciter
						0.04,	// decay time of excitation
						PinkNoise.ar(0.2)),// multiply noise by envelope
					delayTime, 	// max delay time
					delayTime,	// actual delay time
					4)), 		// decay time of string
			1.0.rand2 // random pan position
		)
	}))
})
)
::

Again, press Cmd-. to stop the sound. This will stop all audio (and free all nodes on the server) at any time.

When you're done you can quit the server app by pressing the 'Quit' button on the localhost server window, or do it by executing the following code:

code::
s.quit;
::


title:: Internal Snooping (Introspection)
summary:: Snooping around SuperCollider
categories:: Debugging, Internals

You can inspect much of the internal structure of the class library and other data structures.
This can be useful for research and debugging purposes.

note:: The keyboard shortcuts mentioned here only apply to the standard SuperCollider IDE.::

section:: Class Definitions, Implementations, and References

subsection::Look up Implementation
Selecting the name of any method (e.g. play) and then the menu item teletype::Language>Look up Implementation:: will open a window showing all implementations of that method and their arguments. Selecting one of those classes and methods (e.g. Sample:play) and typing enter will open the class definition at that method. Note that this only shows implementations, and does not indicate inheritance.

(see link::Reference/KeyboardShortcuts::)


subsection::Look up References
Selecting any text (e.g. Window or asStream) and then the menu item teletype::Language>Look up References:: will open a window showing all references to the selected text, i.e. each place it is used within the class library. Note that this will not find methods calls compiled with special byte codes like 'value'.

(see link::Reference/KeyboardShortcuts::)

subsection::Graphical Class browser
SC has a graphical Class browser which will show all methods, arguments, subclasses, instance variables and class variables. Using the browser's buttons you can easily navigate to the class' superclass, subclasses, class source, method source, helpfile (if there is one), check references or implementation of methods.

code::
SequenceableCollection.browse;
::



subsection:: Snooping in Classes

code::
// print all instance methods defined for this class
Collection.dumpInterface;

// print all class methods defined for this class
Collection.class.dumpInterface;



// print all instance methods that instances of this class respond to
Collection.methods.collect(_.name);

// print all class methods that this class responds to
// includes inherited methods
Collection.class.methods.collect(_.name);

// print all instance and class methods that this class responds to
// includes inherited methods
Collection.dumpFullInterface;

// print instance methods of this class and superclasses, in alpha order
// also shows from which class the method is inherited
// does not include Object or Class methods
// for class methods, do Meta_Collection.dumpMethodList
Collection.dumpMethodList;

// dump all subclasses of this class
Collection.dumpClassSubtree;

// dump all subclasses, in alphabetical order
Collection.dumpSubclassList;

// dump all instance variable names of this class
Server.instVarNames.dump;

// dump all class variable names of this class
Server.classVarNames.dump;

// the path to the file that defines this class
// Note that there might be extensions to this class in other files
Server.filenameSymbol.postln;

(
// print all classes whose names start with 'F'
Class.allClasses.do { | class |
	if (class.name.asString.beginsWith("F")) {
		class.name.postln
	}
}
)

(
// find and print all class variable names defined in the system
Class.allClasses.do { | class |
	if (class.classVarNames.notNil) {
		// classVarNames is an Array of Symbols
        class.classVarNames.do { | varname |
            (class.name.asString ++ " " ++ varname.asString).postln
        }
    }
}
)

(
// find and print all methods that contain "ascii"
Class.allClasses.do { | class |
   	class.methods.do { | sel |
   			if(sel.name.asString.find("ascii").notNil) {
            		(class.name.asString + "-" + sel.name).postln
            }
	}
}
)
::

subsection:: Snooping in Methods

code::
// does the class implement this method?
Collection.findMethod('select');
// -> Collection:select

// this class doesn't
Array.findMethod('select');
// -> nil

// but a superclass might implement it, so
// climb the class tree to check
Array.findRespondingMethodFor('select');
// -> Collection:select


// find a method object and dump its argument names and
// its local variable names
Collection.findMethod('select').dump;
Collection.findMethod('select').argNames.dump;
Collection.findMethod('select').varNames.dump;
// -> nil // doesn't have any varNames


// dump its code. mostly for debugging the compiler.
Collection.findMethod('select').dumpByteCodes;

// a shorter version of the above
Collection.dumpByteCodes('select');


{ 1 + 2 }.dump;              // this is a Function
{ 1 + 2 }.def.dump;          // dump its FunctionDef
{ 1 + 2 }.asCompileString;   // show its implementation
{ 1 + 2 }.def.dumpByteCodes; // dump its code.
::

subsection:: Snooping in GUI Windows

code::
(
// create some windows to snoop in
5.do { | i |
	var w, b;
	w = Window.new("snoop " ++ i.asString,
		Rect.new( 200 + 400.rand, 69 + 300.rand, 172, 90 ));
	w.front;
	b = Button.new( w, Rect.new( 23, 28, 127, 25 ));
	b.states = [["BLAM-O", Color.red]];
}
)

Window.allWindows.dump;	// dump a list of all open SCWindows

// a little more helpful, dump their names
Window.allWindows.collect { | w | w.name }.postln;

(
// change background colors of all open windows
Window.allWindows.do { | window |
	window.view.background = Color.new(0.5 + 0.5.rand, 0.5 + 0.5.rand, 0.5 + 0.5.rand);
}
)

Window.closeAll; // close all the windows
::

subsection:: Snooping in SynthDefs
code::
// a synthdef to snoop in
(
f = SynthDef(\snoop, { | out=0 |
		Out.ar(out, PinkNoise.ar(0.1))
});
)

// get the ugens, listed in order of execution, with rate,
// index and inputs
f.dumpUGens;
::

subsection:: Snooping on the Server

Lots of information on server-related snooping can be found in the link::Classes/Server:: helpfile under "Information and debugging".

Some examples code::
s.boot;

f = { PinkNoise.ar(0.1) * SinOsc.ar }; // a function
x = f.play;

// look at all the nodes on the server
s.queryAllNodes;

// parsed contents
s.dumpOSC(1);
x.free;
x = f.play;

// contents in hexadecimal
// status messages are not filtered
s.dumpOSC(2);
x.free;
x = f.play;

// turn off
s.dumpOSC(0);
::


subsection:: Snooping in the Interpreter

When evaluating text in the interpreter, the variable 'this' always refers to the interpreter.
code::
// display the values of all the interpreter variables a-z
this.dump;

// set all variables a-z to nil
this.clearAll;


// compile some text into a Function
g = this.compile("(1 + 2).postln");
g.postln;   // g is a Function
g.value;    // evaluate g

// interpret some text
this.interpret("(1 + 2).postln");

// interpret some text and print the result
this.interpretPrint("1 + 2");
::



title:: Introduction to Objects
summary:: Introduction to objects and messages
categories:: Language>OOP
related:: Reference/Classes, Classes/Class, Classes/Object, Reference/Messages, Guides/Polymorphism

section:: Objects and Messages

The SuperCollider language is an object oriented language. All entities in the language are objects.
An object is something that has data, representing the object's state, and a set of operations that can be performed on the object. All objects are instances of some class which describes the structure of the object and its operations.
Objects in SuperCollider include numbers, character strings, object collections, unit generators, wave samples, points, rectangles, graphical windows, graphical buttons, sliders and much more.

Operations upon objects are invoked by messages. A message is a request for an object, called the receiver, to perform one of its operations. The means by which the operation is performed is determined by the object's class.
Objects of different classes may implement the same message in different ways, each appropriate to the class of the object. For example all objects understand the code::value:: message.
Many objects simply return themselves in response to code::value::, but other objects such as functions and streams first evaluate themselves and return the result of that evaluation.
The ability for different objects to react differently to the same message is known as emphasis::polymorphism:: and is perhaps the most important concept in object oriented programming since it allows the object's behaviour to be abstract from the point of view of the user of the object (the client).

The set of messages to which an object responds to is known as its interface. A set of messages that implement a specific kind behaviour is known as a protocol.
An object's interface may include several protocols which allow the object to interact in several different contexts.
For example all objects implement the 'dependancy' protocol which allow the object to notify other dependant objects that the object has changed and that the dependant should do any necessary action to update itself.

An object's internal state may only be changed by sending it messages. This allows the implementation of the object to be hidden from the client.
The advantage to this is that the client does not depend on the object's implementation and that that implementation can be changed without having to change the client.

See link::Reference/Messages:: for more information about messages.

section:: Classes, Instance Variables, Methods

An object's class contains the description of the object's data and operations. A class also describes how to create an object which is an instance of that class.

An object's data is contained in its instance variables. These are named variables that describe the object's state.
The values of the instance variables are themselves objects. For example, instances of class link::Classes/Point:: have instance variables named 'x' and 'y' which contain the coordinate values of the Point.

An instance variable is only directly accessible from within the class itself. The author of a class may decide to expose instance variable access to clients by adding getter and/or setter messages to the class.

A method is a description of the operations necessary to implement a message for a particular class. The methods in a class tell how to implement messages sent to its instances.
A class contains a method definition for each message to which its instances respond. Methods generally  fall into several categories. Some methods inquire about some property of the receiver.
Others ask the receiver to make some change to its internal state. Still others may ask the receiver to return some computed value.

See link::Reference/Classes:: for more details about instance and class variables and methods.

section:: Summary of Terminology
definitionlist::
## object || something that has data, representing the object's state, and a set of operations that can be performed on the object.
## message || a request for an object to perform an operation.
## receiver || the object to which a message is sent.
## class || a description of the state and behaviour of a set of objects.
## interface || the set of messages to which an object responds.
## protocol || a set of messages that implement a specific kind of behaviour.
## polymorphism || the ability for different kinds of objects to respond differently to the same message.
## method || a description of the operations necessary to implement a message for a particular class.
## instance || one of the objects described by a class.
## instance variable || a part of an object's internal state
::



title:: J concepts in SC
summary:: An overview of concepts borrowed from J
categories:: Language

The J programming language is a successor of APL (see link::http://www.jsoftware.com::). These languages are made for processing arrays of data and are able to express
complex notions of iteration implicitly.

The following are some concepts borrowed from or inspired by J.
Thinking about multidimensional arrays can be both mind bending and mind expanding.
It may take some effort to grasp what is happening in these examples.

section:: Filling arrays
iota fills an array with a counter
code::
z = Array.iota(2, 3, 3);
z.rank; // 3 dimensions
z.shape; // gives the sizes of the dimensions
z = z.reshape(3, 2, 3); // reshape changes the dimensions of an array
z.rank; // 3 dimensions
z.shape;
::

fill a multidimensional array
code::
// 2 dimensions
Array.fill([3,3], { 1.0.rand.round(0.01) });
Array.fill([2,3], {|i,j| i@j });

// 3 dimensions
Array.fill([2, 2, 2], { 1.0.rand.round(0.01) });
Array.fill([2, 3, 4], {|i,j,k| [i, j, k].join });

// a shorter variant of the above:
{|i,j,k| [i, j, k].join } ! [2, 3, 4];

// more dimensions
Array.fill([2, 2, 4, 2], {|...args| args.join });
::


section:: Creating arrays
using dup to create arrays
code::
(1..4) dup: 3;
100.rand dup: 10;
{100.rand} dup: 10;
{100.rand} dup: 3 dup: 4;
{{100.rand} dup: 3} dup: 4;
{|i| i.squared} dup: 10;
{|i| i.nthPrime} dup: 10;
{ |i, j, k| i * j } dup: [5, 5]; // multidimensional dup
::
! is an abbreviation of dup
code::
(1..4) ! 3;
100.rand ! 10;
{100.rand} ! 10;
{100.rand} ! 3 ! 4;
{{100.rand} ! 3} ! 4;
{|i| i.squared} ! 10;
{|i| i.nthPrime} ! 10;
{ |i, j| i * j } ! [5, 5];
::

other ways to do the same thing:
code::
// partial application
_.squared ! 10;
_.nthPrime ! 10;

// operating on a list
(0..9).squared;
(0..9).nthPrime;
::

section:: Operator adverbs
Adverbs are a third argument passed to binary operators that modifies how they iterate over
SequenceableCollections or Streams. See the link::Reference/Adverbs:: help file for more information.
code::
[10, 20, 30, 40, 50] + [1, 2, 3]; // normal
[10, 20, 30, 40, 50] +.f [1, 2, 3]; // folded
[10, 20, 30, 40, 50] +.s [1, 2, 3]; // shorter
[10, 20, 30, 40, 50] +.x [1, 2, 3]; // cross
[10, 20, 30, 40, 50] +.t [1, 2, 3]; // table
::

section:: Operator depth
J has a concept called verb rank, which is probably too complex to understand and implement in SC, but operator depth is similar and simpler.
A binary operator can be given a depth at which to operate. Negative depths iterate the opposite operand.
These are better understood by example. It is not currently possible to combine adverb and depth.
code::
z = Array.iota(3,3);
y = [100, 200, 300];
z + y;
z +.0 y; // same as the above. y added to each row of z
z +.1 y; // y added to each column of z
z +.2 y; // y added to each element of z
z +.-1 y; // z added to each element of y
::

subsection:: deepCollect
deepCollect operates a function at different dimensions or depths in an array.
code::
z = Array.iota(3, 2, 3);
f = {|item| item.reverse };
z.deepCollect(0, f);
z.deepCollect(1, f);
z.deepCollect(2, f);

f = {|item| item.dupEach };
z.deepCollect(0, f);
z.deepCollect(1, f);
z.deepCollect(2, f);
::

section:: Sections of multidimensional arrays
slice can get sections of multidimensional arrays.
nil gets all the indices of a dimension.
code::
z = Array.iota(4, 5);
z.slice(nil, (1..3));
z.slice(2, (1..3));
z.slice((2..3), (0..2));
z.slice((1..3), 3);
z.slice(2, 3);

z = Array.iota(3, 3, 3);
z.slice([0,1], [1,2], [0,2]);
z.slice(nil, nil, [0,2]);
z.slice(1);
z.slice(nil, 1);
z.slice(nil, nil, 1);
z.slice(nil, 2, 1);
z.slice(nil, 1, (1..2));
z.slice(1, [0,1]);
z.flop;
::

section:: Sorting order
generate a random array:
code::
z = {100.rand}.dup(10);
::
order returns an array of indices representing what would be the sorted order of the array:
code::
o = z.order;
y = z[o]; // using the order as an index returns the sorted array
::
calling order on the order returns an array of indices that returns the sorted array to the
original scrambled order:
code::
p = o.order;
x = y[p];
::

section:: Bubbling
bubbling wraps an item in an array of one element. it takes the depth and levels as arguments.
code::
z = Array.iota(4,4);
z.bubble;
z.bubble(1);
z.bubble(2);
z.bubble(0,2);
z.bubble(1,2);
z.bubble(2,2);
::
similarly, unbubble unwraps an Array if it contains a single element.
code::
5.unbubble;
[5].unbubble;
[[5]].unbubble;
[[5]].unbubble(0,2);
[4,5].unbubble;
[[4],[5]].unbubble;
[[4],[5]].unbubble(1);
z.bubble.unbubble;
z.bubble(1).unbubble(1);
z.bubble(2).unbubble(2);
::

section:: Laminating with the +++ operator
the +++ operator takes each item from the second list and appends it to the corresponding item
in the first list. If the second list is shorter, it wraps.
code::
z = Array.iota(5,2);
z +++ [77,88,99];
z +++ [[77,88,99]];
z +++ [[[77,88,99]]];
z +++ [ [[77]],[[88]],[[99]] ];
// same as:
z +++ [77,88,99].bubble;
z +++ [77,88,99].bubble(0,2);
z +++ [77,88,99].bubble(1,2);

z +++ [11,22,33].pyramidg;
z +++ [11,22,33].pyramidg.bubble;
z +++ [[11,22,33].pyramidg];
z +++ [[[11,22,33].pyramidg]];


(
z = (1..4);
10.do {|i|
    z.pyramid(i+1).postln;
    z.pyramidg(i+1).postln;
    "".postln;
};
)
::

section:: reshapeLike
reshapeLike allows you to make one nested array be restructured in the same manner as another.
code::
a = [[10,20],[30, 40, 50], 60, 70, [80, 90]];
b = [[1, 2, [3, 4], [[5], 6], 7], 8, [[9]]];
a.reshapeLike(b);
b.reshapeLike(a);
::
If the lengths are different, the default behaviour is to wrap:
code::
a = [[10,20],[30, 40, 50]];
b = [[1, 2, [3, 4], [[5], 6], 7], 8, [[9]]];
a.reshapeLike(b);
::
but you can specify other index operators:
code::
a.reshapeLike(b, \foldAt);

a.reshapeLike(b, \clipAt);

a.reshapeLike(b, \at);
::

section:: measuring dimensionality and size
maxSizeAtDepth allows you to check the maximum array size at a given depth dimension
code::
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(2);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(1);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(0);
(0..3).collect([[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(_)) // max sizes for each dimension
::

section:: inverting dimensions
flopDeep allows you to to invert the outermost dimension with a dimension at any depth. This is analogous to flop, which does the same for 2-dimensional arrays.
code::
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(2);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(1);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(0);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep; // without argument, flop from the deepest level

[[[10, 100, 1000], 2, 3], [[41, 52], 5, 6]].flopDeep(2); // shorter array wraps
[].flopDeep(1); // result is always one dimension higher.
[[]].flopDeep(4);
::


section:: allTuples
allTuples will generate all combinations of the sub arrays
code::
[[1, 2, 3], [4, 5], 6].allTuples;
[[1, 2, 3], [4, 5, 6, 7], [8, 9]].allTuples;
::



title:: LID permissions
summary:: Details how to configure your computer to set the permissions to access LID's
categories:: External Control>HID
related:: Guides/HID_permissions, Classes/LID

section:: On Linux

You will have to set the permissions with udev to be correct, create a file in the folder: code:: /etc/udev/rules.d/ ::, and name it (e.g.) code:: 90-lid-permissions.rules ::

In the file, you will need this line:

code:: KERNEL=="event[0-9]*", NAME="input/%k", MODE="0664", GROUP="plugdev" ::

This will give read and write permissions to lid-devices to users that are in the code:: plugdev :: group on your system.

To check whether you belong to that group execute the command code:: groups :: in the terminal.

After you have added the udev rules file, you can access the device after plugging and replugging the device.

You can change the permission manually (as root) from the terminal with the command:
code::
sudo chmod 664 /dev/input/event*
sudo chgrp plugdev /dev/input/event*
::

Check the permissions with:

code::
"ls /dev/input/event* -lah".unixCmd;
::


title:: List Comprehensions
categories:: Language, Collections
summary:: list comprehensions and generator expressions

section:: Introduction

List comprehensions are a syntactic feature of functional programming languages like Miranda, Haskell, and Erlang which were later copied into Python.
You can search the web for "list comprehensions" or "generator expressions" to learn more.
Basically list comprehensions are for getting a series of solutions to a problem.

in SC these are just a syntax macro for a longer expression. read this as emphasis:: "all [x,y] for x in 1..5, y in 1..x, such that x+y is prime" :::
code::
all {:[x,y], x <- (1..5), y <- (1..x), (x+y).isPrime }
::
returns:
code::
[ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ], [ 4, 3 ], [ 5, 2 ] ]
::

the list comprehension above is equivalent to the following code:
code::
all(Routine.new({ (1..5).do {|x| (1..x).do {|y| if ((x+y).isPrime) {[x,y].yield} }}}));
::
..but much more concise and much easier to keep in your head than writing it out.

In the list comprehension compiler, simple series like code::(1..5):: and code::(1..x):: are treated as special cases and implemented as loops rather than making a collection.

A list comprehension in SC is really a link::Classes/Routine::. You can use the code::all:: message to collect all of the Routine's results into a list.

section:: A few examples
code::
all {: x/(x+1), x <- (1..5) }

[ 0.5, 0.66666666666667, 0.75, 0.8, 0.83333333333333 ]
::
code::
all {:[x,y], x <- (1..3), y <- [\a,\b,\c] }

[ [ 1, a ], [ 1, b ], [ 1, c ], [ 2, a ], [ 2, b ], [ 2, c ], [ 3, a ], [ 3, b ], [ 3, c ] ]
::
code::
all {:[x,y], x <- (0..3), y <- (x..0) }

[ [ 0, 0 ], [ 1, 1 ], [ 1, 0 ], [ 2, 2 ], [ 2, 1 ], [ 2, 0 ], [ 3, 3 ], [ 3, 2 ], [ 3, 1 ], [ 3, 0 ] ]
::
code::
all {:y, x <- (1..4), y <- (x..1) }

[ 1, 2, 1, 3, 2, 1, 4, 3, 2, 1 ]
::

code::
(
var intervals;
// a function to generate intervals between all pairs of notes in a chord voicing
intervals = {|chord|
	all {: chord[i+gap] - chord[i],
		gap <- (1 .. chord.lastIndex),
		i <- (0 .. chord.lastIndex - gap)
	}
};

intervals.([0,4,7,10]).postln;
intervals.([0,1,3,7]).postln;
)

[ 4, 3, 3, 7, 6, 10 ]
[ 1, 2, 4, 3, 6, 7 ]
::

code::
all {:[y, z], x<-(0..30), var y = x.nthPrime, var z = 2 ** y - 1, z.asInteger.isPrime.not  }
[ [ 11, 2047 ], [ 23, 8388607 ], [ 29, 536870911 ] ] // mersenne numbers which are no primes
::

section:: Qualifier Clauses

A list comprehension begins with code:: {: :: and contains a body followed by several qualifier clauses separated by commas.
code::
{: body , qualifiers }
::
There are several types of qualifier clauses that can appear after the body.

subsection:: generator clause

The basic clause is the generator clause. Its syntax is
code::
name <- expr
::
The expression should be something that can respond meaningfully to 'do' such as a collection or a stream.
The name takes on each value of the expression.
The name is a local variable whose scope extends to all clauses to the right. The name is also in scope in the body.
code::
all {: x, x <- (1..3) }

[ 1, 2, 3 ]
::
code::
all {: x, x <- [\a, \b, \c] }

[ a, b, c ]
::
code::
all {: x, x <- (1!3)++(2!2)++3 }

[ 1, 1, 1, 2, 2, 3 ]
::
multiple generators act like nested loops.
code::
all {: [x,y], x <- (1..2), y <- (10,20..30) }

[ [ 1, 10 ], [ 1, 20 ], [ 1, 30 ], [ 2, 10 ], [ 2, 20 ], [ 2, 30 ] ]
::
generators can depend on previous values.
code::
all {: x, x <- (1..3), y <- (1..x) }

[ 1, 2, 2, 3, 3, 3 ]
::
code::
all {: x, x <- (1..3), y <- (1..4-x) }

[ 1, 1, 1, 2, 2, 3 ]
::

subsection:: guard clause

A guard clause is simply an expression. It should return a boolean value.
code::
expr
::
The guard acts as a filter on the results and constrains the search.
code::
all {: x, x <- (0..10), x.odd }

[ 1, 3, 5, 7, 9 ]
::
code::x.odd:: is the guard and causes all even numbers to be skipped.
code::
all {: x, x <- (0..30), (x % 5 == 0) || x.isPowerOfTwo }

[ 0, 1, 2, 4, 5, 8, 10, 15, 16, 20, 25, 30 ]
::
you can have multiple guards.
code::
all {: [x,y], x <- (0..10), (x % 5 == 0) || x.isPowerOfTwo, y <- (1..2), (x+y).even }

[ [ 0, 2 ], [ 1, 1 ], [ 2, 2 ], [ 4, 2 ], [ 5, 1 ], [ 8, 2 ], [ 10, 2 ] ]
::

subsection:: var clause

A var clause lets you create a new variable binding that you can use in your expressions.
The scope of the name extends to all clauses to the right and in the body.
code::
var name = expr
::
Unlike the generator clause, the name is bound to a single value, it doesn't iterate.
code::
all {: z, x <- (1..20), var z = (x*x-x) div: 2, z.odd }

[ 1, 3, 15, 21, 45, 55, 91, 105, 153, 171 ]
::

subsection:: side effect clause

This clause lets you insert code to do some side effect like printing.
code::
\:: expr
::
code::
all {: z, x <- (1..20), var z = (x*x-x) div: 2, :: [x,z].postln, z.even }
::

subsection:: termination clause

The termination clause is for stopping further searching for results. Once the expression becomes false,
the routine halts.
code::
:while expr
::

using a guard
code::
all {: z, x <- (1..20), var z = (x*x-x) div: 2,  :: [x,z].postln, z < 50 }
::

using a termination clause. this one stops searching, so does less work than the above.
code::
all {: z, x <- (1..20), var z = (x*x-x) div: 2,  :: [x,z].postln, :while z < 50 }
::

section:: Constrained Search

list comprehensions can solve constrained combinatorial problems like this one:

Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.
Baker does not live on the top floor. Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper.
Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's.
Where does everyone live?
code::
(
z = {: [baker, cooper, fletcher, miller, smith] ,
    var floors = (1..5),
    baker <- floors,  baker != 5,  // Baker does not live on the top floor.
    // remove baker's floor from the list.
    // var creates a new scope, so the 'floors' on the left is a new binding.
    var floors = floors.removing(baker),
    cooper <- floors, cooper != 1, // Cooper does not live on the bottom floor.
    var floors = floors.removing(cooper), // remove cooper's floor from the list.
    fletcher <- floors, (fletcher != 5) && (fletcher != 1) // Fletcher does not live on either top or bottom floor.
        && (absdif(fletcher, cooper) > 1), // Fletcher does not live on a floor adjacent to Cooper's.
    var floors = floors.removing(fletcher), // remove fletcher's floor
    miller <- floors, miller > cooper, // Miller lives on a higher floor than does Cooper.
    var floors = floors.removing(miller), // remove miller's floor
    smith <- floors, absdif(fletcher, smith) > 1  // Smith does not live on a floor adjacent to Fletcher's.
};
)

z.next; // [3, 2, 4, 5, 1 ]
z.next; // nil.  only one solution
::

combinatorial problems can take a lot of time to run.
you can reorder the above tests to make it run faster. generally you want to search the most constrained variables first.
the most constrained person above is fletcher, so they should be searched first, then cooper, etc.


section:: Grammar

Here is the BNF grammar for list comprehensions in SC.
code::
[ ] - optional
{ } - zero or more

<list_compre> ::= "{:" <body> ',' <qualifiers> "}"

<body> ::= <exprseq>

<exprseq> ::= <expr> { ";" <expr> }

<qualifiers> ::= <qualifier> { ',' <qualifiers> }

<qualifier> ::= <generator> | <guard> | <binding> | <side_effect> | <termination>

<generator> ::= <name> "<-" <exprseq>

<guard> ::= <exprseq>

<binding> ::= "var" <name> "=" <exprseq>

<side_effect> ::= "::" <exprseq>

<termination> ::= ":while" <exprseq>
::

section:: Code Generation

For each of the above clauses, here is how the code is generated. The body acts as the innermost qualifier.
By understanding these translations, you can better understand how scoping and control flow work in list comprehensions.

definitionlist::
## generator || code::
expr.do {|name| ..next qualifier.. }
::

## guard || code::
if (expr) { ..next qualifier.. }
::

## binding || code::
{|name| ..next qualifier.. }.value(expr)
::

## side effect || code::
expr ; ..next qualifier..
::

## termination || code::
if (expr) { ..next qualifier.. }{ nil.alwaysYield }
::
::



title:: MIDI
summary:: about MIDI
related:: Guides/UsingMIDI, Classes/MIDIFunc, Classes/MIDIdef
categories:: External Control>MIDI

section:: Practical usage overview

Begin with the link::Guides/UsingMIDI:: help file.

subsection:: Receiving MIDI input

link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: are the standard, recommended way to receive MIDI note on/off, controller, pitch bend, aftertouch, poly-touch and program change messages.

note::
strong::IMPORTANT: :: Before MIDI can be received, SuperCollider needs to be told to connect to the MIDI subsystem and connect to the available devices.

code::
MIDIClient.init;
MIDIIn.connectAll;
::

You need to do this once after launching SuperCollider, or recompiling the class library.
::

There are some examples in the wild using the MIDIIn class directly to receive MIDI. This is not recommended for normal use. The exceptions are sysex (system exclusive) and sysrt (MIDI clock) messages, which are currently supported only by MIDIIn. See the example below.

subsection:: Sending MIDI output

See the link::Classes/MIDIOut:: help file for details.

section:: Summary of MIDI classes

definitionlist::
## link::Classes/MIDIClient:: || This class connects to the operating system's MIDI layer, and obtains the lists of available MIDI sources and destinations. The information about the hardware is stored in code::MIDIClient.sources:: and code::MIDIClient.destinations:: as link::Classes/MIDIEndPoint:: objects. MIDIClient must be initialized before MIDI can be received. See the note above.
## link::Classes/MIDIFunc:: || The optimal way to receive the most typical MIDI messages: note on/off, controller, pitch bend, aftertouch, poly-touch and program change.
## link::Classes/MIDIdef:: || Related to link::Classes/MIDIFunc::, this class keeps several MIDIFunc objects in global storage, by name. Especially helpful for live or interactive use.
## link::Classes/MIDIOut:: || Supports MIDI output to hardware ports or inter-application MIDI buses.
## link::Classes/MIDIEndPoint:: || Represents a MIDI port published by the operating system. It contains a device name, port name and unique identifier (uid).
## link::Classes/MIDIIn:: || The lowest-level MIDI input class. MIDIFunc and MIDIdef use this class so that you don't have to. It is strongly recommended to avoid using this class directly.
::


Examples::

MIDI input:

code::
(
MIDIClient.init;
MIDIIn.connectAll;
m = MIDIFunc.noteOn({ |vel, num|
	"note % @ velocity %\n".postf(num, vel);
});
)

// when finished
m.free;
::


MIDI output:

code::
(
MIDIClient.init;
m = MIDIOut(0, MIDIClient.destinations.at(0).uid);
m.noteOn(0, 60, 60);
)
::

Receiving system exclusive messages:

code::
~sysexFunc = { |uid, data|
	// 'data' holds the sysex packet as 8-bit integers
};
MIDIIn.addFuncTo(\sysex, ~sysexFunc);

// when finished
MIDIIn.removeFuncFrom(\sysex, ~sysexFunc);
::


title:: More on Getting Help
summary:: How to find more help
categories:: Help
related:: Search, Browse, Help

note:: This help file uses the key commands for macOS; on other systems, please substitute the Shortcuts as necessary ::

Listed below are a few techniques for tracking down documentation and functionality. Note: If some of the terms used below (e.g. class, method, inheritance, etc.) are unclear to you, you may wish to read the link::Guides/Glossary:: and link::Browse#Language:: helpfiles for detail on some of these concepts. Reading a general tutorial on Object Oriented Programming at some point could also be useful, as could reading a FAQ, etc. about Smalltalk. Smalltalk is the general purpose OOP language upon which the design of the SuperCollider language is based. Its syntax is different than SC's, but conceptually it has much in common.

NB: Be sure to check out the Further Info section at the bottom of this page.

section:: Basics

As you've probably already learned selecting any text and pressing Cmd-d will open the corresponding helpfile. Usually helpfiles are either concept related, or document particular classes. In the SC language classes begin with capital letters. Try Cmd-d on the following (double click on the first word; the stuff after the two slashes is a comment):
code::
Class // this is a class
::
Methods begin with lower-case letters, as do many other things in the language.
code::
play // Cmd-d on this will open a helpfile detailing different implementations of this method
::

In addition there are a many helpfiles which explain important concepts. See the link::Browse##category browser:: and the link::Search##search page::.

Much documentation contains hypertext links to other helpfiles. Click the link to open the corresponding helpfile.

Note that many helpful methods print information to the 'post window'. Unless you have explicitly changed it (see the Window menu) this is the window which opened when you launched. Pressing Cmd-\ will bring the current post window to the front.

section:: Tracking Down Information

Executing the following
code::
HelpBrowser.openBrowsePage;
::
will open a the "help browser" page which lists all helpfiles in thematic categories. (Equivalently, press Shift-Cmd-D)

The link::Browse#Undocumented classes:: contains a list of all classes which have no helpfiles. This can be a good place to start looking for functionality which may already be implemented. Even if a class has no written helpfile, it will have an automatically generated stub listing the methods and their arguments, and also a help template for writing a real helpfile.

Looking in class definitions (select any class and press Cmd-j to open its class definition file) can help you to figure out what undocumented methods do.
code::
Array // Try Cmd-j on this
::
Since many methods use other classes, you may need to continue your search in other class definitions or helpfiles.

Executing the method dumpInterface on any class will list its class and instance methods and their arguments (if any).
code::
Array.dumpInterface; // Look at the post window (the one that opened when you started SC)
::
Note that since the SuperCollider language is object-oriented many classes inherit methods from farther up the class hierarchy. (The many subclasses of Collection are a good example of this. See the Collections overview for more detail.) It would be impractical and redundant to document every inherited method that a class responds to, so it is important to be able to track down documentation and method definitions.

The method dumpFullInterface applied to any Class will list all class and instance methods that a class responds to, sorted by the class in which they are implemented. This will include inherited methods. Methods overridden in a subclass are listed under the subclass.
code::
Array.dumpFullInterface;
::
This can be a lot of information, so dumpAllMethods or class.dumpAllMethods will show only instance and class methods respectively.
code::
Array.class.dumpAllMethods; // Only class methods that this responds to (including inherited ones)
Array.dumpAllMethods; 		// Only instance methods (including inherited ones)
::
There is also a graphical Class browser which will show all methods, arguments, subclasses, instance variables and class variables. Using the browser's buttons you can easily navigate to the class' superclass, subclasses, class source, method source, helpfile (if there is one), check references or implementation of methods.
code::
SequenceableCollection.browse;
::
Selecting any method and pressing Cmd-y will open a window with a list of all the classes that implement that method. (See the link::Guides/Polymorphism:: helpfile for detail on why different classes might implement methods with the same name.)
code::
select // try it on this method
::
Similarly, selecting any text and typing shift-cmd-y will open a window showing all references to the selected text, i.e. each place it is used within the class library. (This will not find methods calls compiled with special byte codes like 'value'.)
code::
// try it on these
asStream
Window
::
In the resulting window selecting any class and method and pressing Cmd-j will take you to that method definition in that class definition. For example try selecting Pattern-select in the window resulting from the previous example. Note that SC supports defining methods in separate files, so a class' methods may be defined in more than one place. If you try Cmd-j on the following you will see that it will open a file called dumpFullInterface.sc rather than one called Class.sc (its main class definition file). The + Class {.... syntax indicates that these are additional methods.
code::
Class-dumpFullInterface
::
If you know that a class responds to a particular message, you can use findRespondingMethod to find out which class it inherits the corresponding method from.
code::
Array.findRespondingMethodFor('select'); // you can Cmd-j on the result in the post window
::
Similarly, helpFileForMethod will open the helpfile of the class in which the responding method is defined (if the helpfile exists). Note that this does not guarantee that the method is documented therein. As noted above, some documentation is incomplete, and some methods are 'private' or not intended for general use.
code::
Array.helpFileForMethod('select'); // this will open the Collection helpfile; scroll down for select
::
In general poking around can be a good way to learn about how things work. See link::Guides/Internal-Snooping:: for more advanced information about how to look 'under the hood.'

section:: For Further Info

http://supercollider.sourceforge.net/

A good starting place for figuring out how to do something are the numerous files in the Examples folder. The SuperCollider swiki is another good source of tips, examples, and information:

http://supercollider.sourceforge.net/wiki

Further help can be obtained by subscribing and sending questions to the sc-users mailing list:

http://www.beast.bham.ac.uk/research/sc_mailing_lists.shtml

An archive of the list can be searched from this page:

http://www.listarc.bham.ac.uk/lists/sc-users/search/

Requests for documentation of undocumented methods or classes, as well as reports of errata, omissions, etc. in helpfiles can be sent to the user's list above. Bugs or Feature Requests can be filed here:

https://github.com/supercollider/supercollider/issues


TITLE:: Multi-client Setups
SUMMARY:: How to set up and shared servers for multiple clients in SuperCollider
CATEGORIES:: Server>Architecture, Tutorials
related:: Classes/ServerOptions, Classes/Server
KEYWORD:: server, multi-client

section:: Multi client-server setups - discussion and tests

OSC communication between SC and its sound server offers many options for network music: Multiple computers can run both supercollider and associated sound servers.
For clarity, the "server process" refers to a running scsynth or supernova process. The "server object" AKA "client" is the server's representation in sclang, such as code::Server.local, s, Server(\elsewhere, NetAddr("163.234.56.78"))::.

subsection:: What are clientIDs, and how do servers get them?

When more than one user plays on a given server,
some resources need to be shared between users/clients:
list::
## permanent and temporary nodeIDs (handled by Server:nodeAllocator),
## private control and audio bus channels (handled by Server:audioBusAllocator, Server:controlBusAllocator)
## buffer numbers (handled by Server:bufferAllocator).
::

This sharing is handled by declaring how many clients/users are expected to login - code::server.options.maxLogins:: - and scsynth will automatically give a different clientID to each client when it logs in.

The most common case is that there is only a single user/client, who always gets clientID 0, and control of all available resources (i.e. the full number range of every allocator).

When multiple clients log in, this is what happens:
list::
## On startup, scsynth (the server process) is started with a fixed limit of maxLogins.
## When a local or remote server object/client has no user-specified clientID, scsynth sends back the next free clientID, and the client uses that clientID.
## When a local or remote server object/client was created with specific clientID, scsynth sends back that number if it was free, or the next free clientID if not; the client should use the free number in any case, as the other may clash with a client already logged in.
## In case the client was already registered and tries to register again (after a reboot or network problem), scsynth sends back a failed message AND the clientID this client had earlier, and the client will use that clientID.
## [After pull request #3181] scsynth also sends back the maxLogins value it was started with, so clients can also adjust their internal allocator settings to it.
::

subsection:: Code examples and tests

Recommended usage for multiple clients on the same server is to use identical options settings for all clients, and logging into the scsynth process from different sclang instances, which are typically on different laptops.

code::
// on the machine where scsynth runs, it can be the default server.
// set the maximum number of client logins expected:
s.options.maxLogins = 8;
// now reboot the server, so that it will have maxLogins
s.reboot;

// from another sclang instance, log into scsynth:
s.options.maxLogins = 8;
// example NetAddr of the machine that runs scsynth on standard port
s.addr = NetAddr("168.192.1.20", 57110);
::

When fixed clientIDs for multiclient setups are desired, the recommended usage is to set every clientID on creation.

code::
s.options.maxLogins = 8;

r = Server(
	\remote4,
	// example NetAddr of the machine that runs scsynth on standard port
	NetAddr("168.192.1.2", 57110),
	s.options,		// make sure all remote servers use the same options
	4				// and when desired, set fixed client by hand
);

// now s knows it can change clientID from server login response
// (because userSpecifiedClientID is false)
s.userSpecifiedClientID;
// and z knows to keep its clientID
r.userSpecifiedClientID;

::

subsection:: Separate defaultGroups

For info on what a default group is, see link::Reference/default_group::.

Every client registering with a server has its own defaultGroup. All nodes belonging to one client are in its defaultGroup and can be specifically addressed, so that a client can release only one's own nodes, and leave those of other clients on this server untouched.

A client also knows the defaultGroups of all other clients that may login, so it can reason about other clients, and be as sharing-friendly as desired, see below in subsection CmdPeriod behavior.

code::s.defaultGroups;::


subsection:: Easy-to-trace nodeIDs

For details on node allocation, see NodeIDAllocator and ReadableNodeIDAllocator class and help files.
The scheme from NodeIDAllocator is also followed by many non-sclang clients allocation ranges; in networks with these, NodeIDAllocator will be the safe choice.

code::

// NodeIDAllocator uses a fixed binary prefix of (2 ** 26) * clientID:
Server.nodeAllocClass = NodeIDAllocator;
s.newAllocators;
r.newAllocators;  // remake allocators
// clientID 0 has group 1:
s.clientID;		// 0
s.defaultGroup;  // Group(1)
s.defaultGroupID; // 1

// for server r:
r.clientID; 		// 4
r.nodeAllocator.idOffset; // lookup the offset: (2 ** 26 * 4)
r.defaultGroup;		// Group(268435457) : idOffset + 1

r.defaultGroupID; 	// 268435457
r.options.maxLogins	// 8

// calculate backwards to which clientID a node belongs
r.defaultGroupID mod: (2 ** 26); // 1 is the nodeID relative to idOffset relative ID
r.defaultGroupID >> 26;
r.nextNodeID ;   // begin at defaultGroupID + 1000
r.nextNodeID >> 26; // get clientID from a long nodeID


// ReadableNodeIDAllocator uses a decimal prefix - to demonstrate:
Server.nodeAllocClass = ReadableNodeIDAllocator;
s.newAllocators;
r.newAllocators;  // remake allocators

// for clientID 0, nothing changes:
s.clientID;       // 0
s.defaultGroup;   // Group(1)
s.defaultGroupID; // 1

// for server r:
r.clientID; 		// 4
r.nodeAllocator.idOffset;  // decimal offset so clientID is prefix
r.defaultGroupID; 	// 400000001 - easy to identify nodeID source
r.defaultGroup;		// Group(400000001)
r.options.maxLogins	// 8

// s.defaultGroup can be looked up in many ways:
r.defaultGroupID;  // 400000001
r.defaultGroup;    // Group(400000001)
r.asGroup;         // Group(400000001)
r.asTarget;        // Group(400000001)


// temp nodeIDs readably belong to clientID 4, starting with 4...1000
5.do { r.nextNodeID.postln };
5.do { s.nextNodeID.postln };


// For demonstration, switch addr of r to point to local scsynth,
// so we can test the allocator numbers on a single machine:
r.addr = s.addr;
// whenever an accessible sound process is created, it gets a nodeID;
// here are four different ways to create sounds, and see their nodeIDs:
r.reboot;
r.plotTree;
Server.default = r;

// Synth
x = Synth(\default, nil);
x.release;

x = { Dust.ar(10!2).lag(0.002) }.play(r);
x.release(2);

Pbind(\degree, Pseq((0..7).mirror), \dur, 0.15, \server, r).play;

// JITLib nodeproxies
Ndef(\x, { Dust.ar(10 ! 2) });
Ndef(\x).play;
Ndef(\x).filter(10, { |in| Ringz.ar(in, [600, 800], 0.03) }).play;
Ndef(\x).end(3);

::

subsection:: Bus channel and buffer numbers
The allocators for audio and control busses and for buffers split the full number range of scsynth evenly for the number of clients expected.

code::
// default value for clientID is 0 and maxLogins is 1
Server.default = Server.local;
s.clientID;   // 0
s.options.maxLogins; // default 1

// you can set maxLogins_ by hand - not recommended, only for testing here:
s.options.maxLogins_(1); // default 1

s.options.numAudioBusChannels;
// use newAllocators method to create allocator ranges accordingly
s.newBusAllocators;
s.audioBusAllocator.size;

// 1024 buses to allocate, starting past the hardware IO buses.
Bus.audio(s, 2);

//  set maxLogins_ to 8 by hand - not recommended, only for demonstration here:
s.options.maxLogins_(8);
s.newBusAllocators; // 128 = 1024 / 8 buses to allocate per client.
s.audioBusAllocator.size;
3.collect { Bus.audio(s, 2) };
// 1024 control buses to allocate, starting at 0
s.controlBusAllocator.size;
3.collect { Bus.control(s, 2) };

r.options.dump
r.newBusAllocators;
// audio bus range starts at 512 of 1024 total range
3.collect { Bus.audio(r, 2) }; // 512, 514, 516
// control bus range starts at 8192 of 16384 total range
3.collect { Bus.control(r, 2) };
::

Buffer allocation uses the same class, ContiguousBlockAllocator, and thus works the same way.

code::
// show buffer allocation
Server.default = Server.local;
s.bufferAllocator.size;
3.collect { Buffer(s) }; // starts at 0

r.bufferAllocator.size;
3.collect { Buffer(r) }; // starts at 256

// more buffer alloc examples desirable here?
::


subsection:: Configuring CmdPeriod behavior

In networked performances, it is useful that clients have well-chosen
emergency access to 'their' sounds on a remote server; and it may make sense to give the local client more emergency power. Both can be configured easily.

strong::Default behavior::

By default, the local client will kill all sounds, and only reconstruct its defaultGroup; on remote clients, CmdPeriod does not affect remoter servers at all.

code::
// default - single client:
s.options.maxLogins_(1);
s.reboot;
s.plotTree;		// watch to debug
s.defaultGroup; // Group(1)
s.defaultGroups; //  only one client, so this is [ Group(1) ]
(dur: inf).play;  // play a test sound
Group(0);   // make another group at root level
s.freeAll;  // sound and added group die, only Group(1) remains

// same with using CmdPeriod:
(dur: inf).play;  // play a test sound
Group(0);   // make another group at root level
CmdPeriod.run; // simulate CmdPeriod key action


// show behavior and support methods with a 4 client setup:
s.options.maxLogins_(4);
s.reboot;
s.defaultGroups; // 4 default groups, 1 for every possible client.
// send defaultGroups for specific clientIDs to scsynth : -> cf plotTree
s.sendDefaultGroupsForIDs([0, 1]); // adds second defaultGroup

// send all default groups
s.sendDefaultGroups; // four groups in plotTree

// s.tree gets evaluated after each CmdPeriod.
// make sure we have nothing in s.tree:
s.tree = nil;
s.freeAll; // <- by default, frees other client's defaultGroups too.
::

strong::Remote-friendly local parent setup::

Now, all sounds on the server are gone, as desired.
But the other clients cannot start new synths now,
because their defaultGroups are gone too!

Thus, the local client should reconstruct them,
so the other clients can pick up playing again:
code::
// - easiest option:
s.tree = { s.sendDefaultGroups; };
(dur: inf).play;  // test sound
Group(0);   // make second group at root level
CmdPeriod.run; // simulate CmdPeriod key action
// -> still stops all sounds, but then remakes all defaultGroups,
// so the other clients can continue.
::

strong::Give remote clients control of their sounds::

code::
// create a fake remote server
x = Server(\pseudoRem3, s.addr, s.options, 3);
// method to
~freeMyGroupX = { x.freeMyGroup };
CmdPeriod.add(~freeMyGroupX);
// fake playing a sound from it:
(dur: 10, group: x.defaultGroup).play;
(dur: 10, degree: 2).play; // and one on home client

~freeMyGroupX.value; // only frees the one in \pseudoRem3

CmdPeriod.remove(~freeMyGroupX);

strong::Symmetrical / democratic setups::

The home client on the machine where scsynth runs may want to be just like the others. It is simple to make the home client more polite:
code::
// first, disable general freeAll:
CmdPeriod.freeServers = false;
s.tree = nil;
s.sendDefaultGroups;
// and add a custom action to CmdPeriod:
~freeMyGroupS = { s.freeMyGroup };
CmdPeriod.add(~freeMyGroupS);
(dur: inf).play;  // test sound
// simulate second sound from a different client:
(dur: inf, degree: 2, group: s.defaultGroups[3]).play;

CmdPeriod.run; // simulate CmdPeriod key action
// -> only stops s.defaultGroup, others continue untouched

CmdPeriod.remove(~freeMyGroupS); // cleanup
s.freeAll;
::
strong::More power to all::

In a less polite symmetrical setup, CmdPeriod stops all sounds on all clients, but keeps all defaultGroups running.
code::
~myserver = s; // s on home machine, remote client on others
~myserver.sendDefaultGroups;
~freeDefaultGroups = { ~myserver.freeDefaultGroups };
CmdPeriod.add(~freeDefaultGroups);
(dur: inf).play;  // test sound
// fake sound from  client 1:
(dur: inf, degree: 2, group: s.defaultGroups[1].nodeID).play;

CmdPeriod.run; // simulate CmdPeriod key action
// -> all clients stop sound in all groups, groups remain.
::


title:: Multichannel Expansion
summary:: Explaining multichannel expansion and representation
categories:: Server>Nodes, UGens>Multichannel

section:: Multiple channels as Arrays
Multiple channels of audio are represented as link::Classes/Array::s.
code::
s.boot;
// one channel
{ Blip.ar(800,4,0.1) }.play;

// two channels
{ [ Blip.ar(800,4,0.1), WhiteNoise.ar(0.1) ] }.play;
::
Each channel of output will go out a different speaker, so your limit here is two for a stereo output. If you have a supported multi channel audio interface or card then you can output as many channels as the card supports.

All link::Classes/UGen::s have only a single output. This uniformity facilitates the use of array operations to perform manipulation of multi channel structures.

In order to implement multichannel output, UGens create a separate UGen known as an link::Classes/OutputProxy:: for each output. An OutputProxy is just a place holder for the output of a multichannel UGen. OutputProxies are created internally, you never need to create them yourself, but it is good to be aware that they exist so you'll know what they are when you run across them.
code::
// look at the outputs of Pan2:
Pan2.ar(PinkNoise.ar(0.1), FSinOsc.kr(3)).dump;

play({ Pan2.ar(PinkNoise.ar(0.1), FSinOsc.kr(1)); });
::

section:: Multichannel expansion
When an link::Classes/Array:: is given as an input to a unit generator it causes an array of multiple copies of that unit generator to be made, each with a different value from the input array. This is called multichannel expansion. All but a few special unit generators perform multichannel expansion. Only Arrays are expanded, no other type of Collection, not even subclasses of Array.
code::
{ Blip.ar(500,8,0.1) }.play // one channel

// the array in the freq input causes an Array of 2 Blips to be created :
{ Blip.ar([499,600],8,0.1) }.play // two channels

Blip.ar(500,8,0.1).postln // one unit generator created.

Blip.ar([500,601],8,0.1).postln // two unit generators created.
::
Multichannel expansion will propagate through the expression graph. When a unit generator constructor is called with an array of inputs, it returns an array of instances. If that array is the input to another constructor, then another array is created, and so on.
code::
{ RLPF.ar(Saw.ar([100,250],0.05), XLine.kr(8000,400,5), 0.05) }.play;

// the [100,250] array of frequency inputs to Saw causes Saw.ar to return
// an array of two Saws, that array causes RLPF.ar to create two RLPFs.
// Both RLPFs share a single instance of XLine.
::
When a constructor is parameterized by two or more arrays, then the number of channels created is equal to the longest array, with parameters being pulled from each array in parallel. The shorter arrays will wrap.

for example, the following:
code::
Pulse.ar([400, 500, 600],[0.5, 0.1], 0.2)
::
is equivalent to:
code::
[ Pulse.ar(400,0.5,0.2), Pulse.ar(500,0.1,0.2), Pulse.ar(600,0.5,0.2) ]
::
A more complex example based on the Saw example above is given below. In this example, the link::Classes/XLine:: is expanded to two instances, one going from 8000 Hz to 400 Hz and the other going in the opposite direction from 500 Hz to 7000 Hz.
These two XLines are 'married' to the two Saw oscillators and used to parameterize two copies of link::Classes/RLPF::. So on the left channel a 100 Hz Saw is filtered from 8000 Hz to 400 Hz and on the right channel a 250 Hz Saw is filtered from 500 Hz to 7000 Hz.
code::
{ RLPF.ar(Saw.ar([100,250],0.05), XLine.kr([8000,500],[400,7000],5), 0.05) }.play;
::

subsection:: Expanding methods and operators
Many operators and methods also multichannel expand. For example all common math operators:
code::
{ Saw.ar([100,250]) * [0.5,0.8] }.play;
{ Saw.ar(LFNoise1.kr(1).range(0,100) + [100,250]) }.play;
::
Also the various UGen convenience functions like code::.clip2::, code::.lag:: and code::.range:: :
code::
{ Saw.ar(LFNoise1.kr(1).range(100,[200,300])) }.play;
{ Saw.ar(LFPulse.kr(1).range(100,[200,300]).lag([0.1,0.2])) }.play;
::
The expansion is handled by wrapper-methods defined in link::Classes/SequenceableCollection::.

You can use link::Classes/Object#-multiChannelPerform:: to do multichannel expansion with any method on any kind of object:
code::
["foo","bar"].multiChannelPerform(\toUpper);
::
The shorter arrays wrap:
code::
["foo","bar","zoo"].multiChannelPerform('++', ["l","ba"])
::

subsection:: Using flop and flop1 for multichannel expansion
The method flop swaps columns and rows, allowing to derive series of argument sets:
code::
(
SynthDef("help_multichannel", { |out=0, freq=440, mod=0.1, modrange=20|
	Out.ar(out,
		SinOsc.ar(
			LFPar.kr(mod, 0, modrange) + freq
		) * EnvGate(0.1)
	)
}).add;
)
::
code::
(
var freq, mod, modrange;

freq = Array.exprand(8, 400, 5000);
mod = Array.exprand(8, 0.1, 2);
modrange = Array.rand(8, 0.1, 40);

fork {
	[\freq, freq, \mod, mod, \modrange, modrange].flop.do { |args|
		args.postln;
		Synth("help_multichannel", args);
		0.3.wait;
	}
};
)
::

Similarly, link::Classes/Function#-flop#Function:flop:: and link::Classes/Function#-flop1#Function:flop1:: return an unevaluated function that will expand to its arguments when evaluated.

code::
// multichannel expansion for if, here to protect from division by zero.
// flop always returns an array
f = { |a, b| if(b != 0) { a / b } { 0 } }.flop;
f.value([1, 2, 3, 4], [0, 10, 1000]); //  -> [ 0, 0.2, 0.003, 0 ]
f.value(2, 4); // [ 0.5 ] (always returns an array)

// multichannel expansion for if, here to protect from division by zero
// flop1 returns an array only if the arguments include an array
f = { |a, b| if(b != 0) { a / b } { 0 } }.flop1;
f.value([1, 2, 3, 4], [0, 10, 1000]); //  -> [ 0, 0.2, 0.003, 0 ]
f.value([2], 4); // -> [0.5]
f.value(2, 4); // -> 0.5
::


code::
// multichannel expand a function that forks a task
(
SynthDef(\blip, { |out, freq|
	Out.ar(out,
		Line.ar(0.1, 0, 0.05, 1, 0, 2) * Pulse.ar(freq * [1, 1.02])
	)
}).add;

a = { |dur=1, x=1, n=10, freq=400|
	fork {
		n.do {
			if(x.coin) { Synth(\blip, [\freq, freq]) };
			(dur / n).wait;
		}
	}
}.flop;
)

a.value(5, [0.3, 0.3, 0.2], [12, 32, 64], [1000, 710, 700]);
::

subsection:: Multichannel expansion in Patterns
Multichannel expansion does not quite follow the scheme one might expect from the previously described. E.g. the following doesn't multichannel-expand properly:
code::
(
SynthDef(\help_multichannel, { |out=0, freq=#[342, 145]|
	var env = EnvGate.new;
	Out.ar(out, [SinOsc.ar(freq[0]), Saw.ar(freq[1])] * env * 0.2)
}).add
)

// not working as expected
// only freq in the left channel gets set correctly
(
a = Pbind(
	\instrument, \help_multichannel,
	\freq, Pseq([[342, 145], [187, 564], [234, 135]], inf),
	\dur, 0.5
).play;
)
::

Instead wrap arrayed args in an extra pair of square brackets:

code::
a.stop;

// freq in both channels set as expected
(
a = Pbind(
	\instrument, \help_multichannel,
	\freq, Pseq([[[342, 145]], [[187, 564]], [[234, 135]]], inf),
	\dur, 0.5
).play;
)
::

Under the hood this is a consequence of how .flop prepares the given args to be passed to the Synth:

code::
// single square brackets
[\freq, [342, 145]].flop
// --> [ [ freq, 342 ], [ freq, 145 ] ]

// double square brackets
[\freq, [[342, 145]]].flop
// --> [ [ freq, [ 342, 145 ] ] ]
::

section:: Pitfalls
Some UGens create stereo output from mono input, and might not behave as expected regarding multichannel expansion.

For example, link::Classes/Pan2:: :
code::
{ Pan2.ar(SinOsc.ar([500,600]),[-0.5,0.5]) }.play;
::
The expectation here might be that the two sines would get individual pan positions. And they do, but Pan2 expands into two stereo ugens nested in an outer array, resulting in a total of four output channels. code::play:: will add an link::Classes/Out:: UGen for each of them, resulting in both Pan2's writing to the same output bus:
code::
Pan2.ar(SinOsc.ar([500,600]),[-0.5,0.5])

// prints:
// [ [ an OutputProxy, an OutputProxy ], [ an OutputProxy, an OutputProxy ] ]
::

In this case, the solution is simply to sum the nested four channels into a single stereo-channel:
code::
{ Pan2.ar(SinOsc.ar([500,600]),[-0.5,0.5]).sum }.play;
::

If we take a look at the resulting UGen graph of the code above, we can see that it is correct. The two Pan2 is mixed together to create a single stereo output:
code::
{ Pan2.ar(SinOsc.ar([500,600]),[-0.5,0.5]).sum }.asSynthDef.dumpUGens

// prints:
// [ 0_Control, scalar, nil ]
// [ 1_SinOsc, audio, [ 500, 0 ] ]
// [ 2_Pan2, audio, [ 1_SinOsc, -0.5, 1 ] ]
// [ 3_SinOsc, audio, [ 600, 0 ] ]
// [ 4_Pan2, audio, [ 3_SinOsc, 0.5, 1 ] ]
// [ 5_+, audio, [ 2_Pan2[0], 4_Pan2[0] ] ]
// [ 6_+, audio, [ 2_Pan2[1], 4_Pan2[1] ] ]
// [ 7_Out, audio, [ 0_Control[0], 5_+, 6_+ ] ]
::

section:: Protecting arrays against expansion
Some unit generators such as link::Classes/Klank:: require arrays of values as inputs. Since all arrays are expanded, you need to protect some arrays by a link::Classes/Ref:: object.
A Ref instance is an object with a single slot named 'value' that serves as a holder of an object.
code::Ref.new(object):: is one way to create a Ref, but there is a syntactic shortcut. The backquote code::`:: is a unary operator that is equivalent to calling code::Ref.new(something)::. So to protect arrays that are inputs to a Klank or similar UGens you write:
code::
Klank.ar(`[[400,500,600],[1,2,1]], z)
::
You can still create multiple Klanks by giving it an array of Ref'ed arrays.
code::
Klank.ar([ `[[400,500,600],[1,2,1]],  `[[700,800,900],[1,2,1]] ], z)
::
is equivalent to:
code::
[ Klank.ar(`[[400,500,600],[1,2,1]], z),  Klank.ar(`[[700,800,900],[1,2,1]], z)]
::
Also the Refs multichannelExpand when passed to a Klank:
code::
Klank.ar(`[[[400,500,600], [700,800,900]],[1,2,1]], z)
::
, which is is equivalent to:
code::
[ Klank.ar(`[[400,500,600],[1,2,1]], z),  Klank.ar(`[[700,800,900],[1,2,1]], z)]
::

section:: Reducing channel expansion with Mix
The link::Classes/Mix:: object provides the means for reducing multichannel arrays to a single channel.
code::
Mix.new([a, b, c]) // array of channels
::
or
code::
[a, b, c].sum
::
is equivalent to:
code::
a + b + c  // mixed to one
::
Mix is more efficient than using + since it can perform multiple additions at a time. But the main advantage is that it can deal with situations where the number of channels is arbitrary or determined at runtime.
code::
// three channels of Pulse are mixed to one channel
{ Mix.new(  Pulse.ar([400, 501, 600], [0.5, 0.1], 0.1) ) }.play
::
Multi channel expansion works differently for Mix. Mix takes one input which is an array (one not protected by a Ref). That array does not cause copies of Mix to be made.
All elements of the array are mixed together in a single Mix object. On the other hand if the array contains one or more arrays then multi channel expansion is performed one level down. This allows you to mix an array of stereo (two element) arrays resulting in one two channel array. For example:
code::
Mix.new( [ [a, b], [c, d], [e, f] ] ) // input is an array of stereo pairs
::
is equivalent to:
code::
// mixed to a single stereo pair
[ Mix.new( [a, c, e] ), Mix.new( [b, d, f] ) ]
::
Currently it is not recursive. You cannot use Mix on arrays of arrays of arrays.

Here's a final example illustrating multi channel expansion and Mix. By changing the variable 'n' you can change the number of voices in the patch. How many voices can your machine handle?
code::
(
{
	var n;
	n = 8; // number of 'voices'
	Mix.new( // mix all stereo pairs down.
		Pan2.ar( // pan the voice to a stereo position
			CombL.ar( // a comb filter used as a string resonator
				Dust.ar( // random impulses as an excitation function
					// an array to cause expansion of Dust to n channels
					// 1 means one impulse per second on average
					Array.fill(n, 1),
					0.3 // amplitude
				),
				0.01, // max delay time in seconds
				// array of different random lengths for each 'string'
				Array.fill(n, {0.004.rand+0.0003}),
				4 // decay time in seconds
			),
			Array.fill(n,{1.0.rand2}) // give each voice a different pan position
		)
	)
}.play;
)
::





title:: News in 3.10
summary:: All the news that's fit to .postln
categories:: News

section:: Known issues

FileDialog can hang — currently we are only able to reproduce on KDE, but other OS's could be affected.

On Windows and Linux, running code with Ctrl+Enter in the help browser (not the editor) only evaluates the current line.

QtWebEngine, a hard dependency of SCLang and SCIDE, is difficult or impossible to install in some environments. Work is underway to make it an optional component, but this will not happen in time for 3.10.

section:: General: Added

A code:: NO_X11 :: option has been added to the build system so that server plugins requiring an X server such as MouseX can be omitted.

section:: General: Changed

sclang and scide have long been stuck with Qt 5.5 due to Qt dropping QtWebKit for QtWebEngine. They have been upgraded for compatibility with Qt 5.7+. We recommend using the most recent version of Qt. The impacts of this change include:

list::
## sclang and scide now build on Visual Studio 2015 and later. (Previously, Windows users had to obtain the now-ancient Visual Studio 2013.)
## UserView now supports Retina/HiDPI display.
## A somewhat different build process on Linux. See the README.
::

The minimum required version is now CMake 3.5 instead of CMake 2.8.

scel (the emacs package) is now a submodule.

section:: General: Fixed

Many issues with Unicode paths on Windows were fixed in 3.9. A few remaining cases involving sound files remained, and are now fixed:

list::
## supernova's sound file backend, buffer manager, and plugin loading
## NRT mode in scsynth
## code:: /b_read :: family of commands in scsynth
## code:: SoundFileView :: in the sclang GUI
::

Fixed a build failure with the CMake option code:: SYSTEM_YAMLCPP=on ::.

Fixed a misleading deprecation warning when code:: CMAKE_INSTALL_PREFIX :: is set to the home directory in Linux.

Fixed code:: CMAKE_PREFIX_PATH :: incorrectly defaulting to code:: /usr/local/ :: on macOS under some conditions.

section:: scsynth and supernova: Added

supernova now has latency compensation.

section:: scsynth and supernova: Fixed

scsynth's latency compensation had a math error that ended up doubling the latency. It is fixed now.

For consistency with scsynth, supernova no longer requires the final argument to code:: /b_allocReadChannel ::.

One second folks, takin' a quick break here. Gotta get my morning cuppa! Alright, we're back.

Fixed a missing newline in some of supernova's error messages.

Fixed errors in supernova's code:: /s_getn ::.

Fix supernova's response to code:: /g_queryTree :: so it matches scsynth.

section:: UGens: Fixed

Fixed clicks in Convolution2L.

section:: sclang: Added

Menus are now supported in the Qt GUI. See help files for code:: Menu ::, code:: MenuAction ::, code:: ToolBar ::, and code:: MainMenu ::.

Added wrappers for over 100 special mathematical functions (gamma function, Bessel functions, elliptic integrals, etc.) from the Boost library.

SerialPort now works on Windows.

code:: FileDialog :: and code:: Dialog :: now support a "path" argument that specifies a default directory when the dialog appears.

code:: QTreeView :: has a new method: code:: setColumnWidth ::.

section:: sclang: Changed

strong:: Breaking change: :: code:: Float:asString :: now always produces a decimal point, so code:: 3.0.asString :: is now code:: "3.0" :: instead of code:: "3" ::.

strong:: Breaking change: :: The code:: server :: argument has changed to code:: target :: in code:: Function:asBuffer ::, code:: Function:loadToFloatArray ::, and code:: Function:plot ::, and now allows spawning the plotting synth relative to a group or node rather than just a server.

strong:: Breaking change: :: code:: File:mkdir :: now returns a Boolean indicating whether the operation was successful. Previously, it returned the File object.

Scrollbars now always appear for ScrollView on Linux an Windows, as a temporary workaround for a very odd dependency on the use of the scroll wheel.

section:: sclang: Removed

Removed some unused Qt dependencies from the build system.

section:: sclang: Fixed

strong:: Breaking change: :: Fixed a long-standing math error in code:: SimpleNumber:expexp ::.

Fixed extreme CPU usage of sclang when built without Qt.

On Windows, the directory where extensions were installed was accidentally changed in 3.9. It has been reverted.

Fixed a crash when calling code:: File.copy :: when the destination exists.

Fixed two code:: Array:lace :: issues: a crash when any element is an empty array, and an error when no length argument is provided and any element is not an array.

Fixed conditions where code:: Integer:forBy :: can cause sclang to freeze when the step size is 0 or a floating point value with an absolute value less than 1.

Fixed some incorrect output in code:: FunctionDef:dumpByteCodes ::.

Fixed code:: Node:release :: getting stuck on negative release times, which are now equivalent to 0.

Fixed code:: == :: on code:: Signal :: objects randomly returning the wrong result.

section:: Class library: Added

code:: UnitTest.passVerbosity :: allows changing the verbosity of test failure reports. See the code:: UnitTest :: help file for more information.

Added new UGen methods code:: .snap :: and code:: .softRound ::.

code:: Node:query :: has a new code:: action :: argument, allowing specification of a callback function.

code:: .degrad :: and code:: .raddeg :: are now implemented for UGens.

section:: Class library: Changed

The default behavior of code:: SerialPort.devices :: pattern matching has been improved to match a wider variety of devices on macOS and Linux.

Internal calls to code:: .interpret :: have been removed from code:: Color.fromHexString :: and code:: History.unformatTime ::, improving both performance and security.

section:: Class library: Deprecated

code:: SerialPort.cleanupAll :: is deprecated.

Providing an integer index for code:: SerialPort.new :: is deprecated.

section:: Class library: Fixed

code:: BufWr.ar :: no longer allows its input signals to be control rate, which caused the server to read from garbage memory.

code:: Buffer:query :: returned incorrect results if multiple query messages are sent at once. This has been fixed.

Fixed fragilities in path joining methods such as code:: +/+ ::, code:: withTrailingSlash ::, and code:: withoutTrailingSlash ::.

Fixed bugs when certain pattern classes are passed in 0 as the number of repeats.

Fixed code:: Event.addEventType :: ignoring the code:: parentEvent :: argument.

Fixed code:: Pkey :: being skipped because the default number of repeats is code:: nil :: instead of code:: inf ::.

Fixed some harmless but annoying errors about extensions of nonexistent classes when sclang is built without Qt.

code:: ProxySpace:linkDoc :: was broken — switching documents did not actually change ProxySpaces. This is fixed now.

code:: Recorder:prepareForRecord :: produced an error if the recordings path does not exist. It now makes the directory if it doesn't exist.

Fixed bugs when providing multiple paths in code:: ServerOptions:ugensPluginPath ::.

Fixed code:: HelpBrowser :: (the class, not the IDE help browser) being unusable since it didn't trigger rendering of help files when links are clicked.

Fixed some bugs in code:: EnvGate ::: throwing an error when code:: fadeTime :: is a constant rather than a UGen input, and code:: i_level :: not behaving as documented.

Fixed occasional hangs when rebooting supernova.

Fixed confusing user feedback with the "Check for updates" button in the quarks GUI.

code:: Buffer :: methods ensure that the buffer number in outbound OSC messages is an integer. This fixes errors in supernova, which is stricter than scsynth about the buffer number type.

Fixed confusing user feedback with the "Check for updates" button in the quarks GUI.

Fixed missing default arguments in code:: fold2 ::, code:: wrap2 ::, and code:: excess :: methods of code:: Collection :: for consistency with code:: SimpleNumber ::.

Fixed incorrect template matching behavior in code:: OSCFunc :: and related functionality.

Fixed "Message 'extension' not understood" preventing code:: Image :: from working.

section:: IDE & SCDoc: Added

The IDE has a prettier default theme. The old theme still exists as "classic."

The IDE now properly highlights scale degree literals like code:: 4s ::.

section:: IDE & SCDoc: Changed

The IDE has a prettier default theme. The old theme still exists as "classic."

The IDE now has a unified look across all platforms, and its color scheme adapts to match the editor theme.

The SCDoc TOC and menubar have been redesigned again.

Various tweaks to the appearance of the IDE: nicer tabs, better border colors.

section:: IDE & SCDoc: Fixed

When starting the IDE, detached docklet sometimes spawn as unresponsive. This has been fixed.

Syntax colors in the help browser now match the IDE.

Only one preference window can be open at a time now.

Fixed tabs reversing in order when restoring a session.


title:: News in 3.11
summary:: A summary of news in SC 3.11
categories:: News

STRONG:: New feature:: - Ableton Link support. See link::#sclang: Added::

Documentation improvements (#4759, #4732, #4744, #4697, #4326, #4673, #4610, #4515, #4389, #4355, #4333, #4222, #4198, #4144, #4123, #4148, #4140, #4080, #4078, #4057, #4016, #4027, #3925, #3953, #3954, #3912, #3929)

section:: General: Added

Added NOVA_SIMD build option for cookiecutter based plugin development (#4354)

section:: General: Changed

Moved RPi and BeagleBone README files into the main repository. (#4639)

The way version numbering is handled in the build system has been reformed. This primarily affects building, but also required changes to the class library (see class library: deprecated) (#4706)

scel has been updated (#4712, #4700)

scvim has been updated (#4197)

code:: CONTRIBUTING.md :: and code:: DEVELOPING.md :: have been updated and moved to the wiki (#4503, #4297, #4028)

code:: README_LINUX.md :: has been updated (#4397, #4159)

Templates for issues have been updated (#4271)

Templates for pull requests have been updated (#4272)

macOS builds now require >= 10.10. Documentation and travis builds are updated to reflect this (#4068)

section:: General: Fixed

Fixed linking issues for supernova on macOS (#4764)

Fixed build issues when using system boost or yaml-cpp (#4185)

section:: scsynth and supernova: Added

macOS: Added cocoa event loop to scsynth and supernova to allow future work on VST integration (#4499)

Added a missing flag for no buffer aliasing to the plugin interface (#4356)

section:: scsynth and supernova: Changed

Replaced a magic number used by the clock (#4714)

supernova now has more deterministic ordering of OSC messages in asynchronous requests (#4460)

section:: scsynth and supernova: Fixed

Fixed an issue with scsynth and supernova pre-processor directives (fixes issue raised in (#4504)) (#4784)

Fixed issues with clock jitter when using JACK (#4599)

Fixed a bug where Windows would not guard against denormals, which would cause large CPU utilisation (#4504)

Prevented coreaudio from resampling audio stream when using portaudio on macOS (#4477)

Fixed an erroneous include  that stopped supernova from compiling in some cases (#4018)

section:: Ugens: Fixed

Fixed an issue with the Done flags on EnvGen (#4789)

Fixed an issue with EnvGen gating non-gated envelopes (#4436)

section:: sclang: Added

Ableton Link support is here! Check the LinkClock class for more information.
(#4331, #4340, #4337)

Add PortAudio bindings to allow listing audio devices on Windows (#4742).

section:: sclang: Fixed

Fixed an issue where TCP connections were not closed properly when recompiling the class library (#4518)

Fixed code:: LanguageConfig :: sometimes storing in the wrong location (#4680)

Fixed an number of garbage collection related issues that would sometimes render the interpreter unstable (#4192)

section:: Class library: Added

Added code:: Platform.architecture :: to allow detection of system architecture (#4524)

Added code:: File.deleteAll :: to facilitate the deletion of all files within a given path - to be used for good, not evil (#3921)

Added more flexible ways to modify ControlSpecs related to SynthDef args (#3814)

Added support for listing audio devices on Windows from code:: ServerOptions.inDevices ::, code:: ServerOptions.outDevices :: and code:: ServerOptions.devices :: (#4742)

Added 'composite' event type to default Event prototype (#4441)

Added code:: SequenceableCollection:unixCmdGetStdOut :: to capture std output from external programs (#3539)

Added code:: String.parseJSON :: and code:: String.parseJSONFile :: as an alias around code:: parseYAML :: (#3956)

Added code:: debug :: method to code:: UnitTest ::(#3623)

section:: Class library: Changed

Improvements to drag functionality with Ndef params (#4093)

code:: Collection:== :: optimised to exit early for identity, inherited by subclasses (#3962)

As part of version reforming, code:: Main.versionAtMost :: and code:: Main.versionAtLeast :: now accept a third argument for the tweak level (e.g. checking for 3.10.4 is now possible) (#4706)

Some UnitTests now print fewer newline characters, and inline warnings have been fixed (#4716)

code:: NodeProxy:set :: can now be used with arbitrary objects (#4090)

UnitTest methods are now isolated from each other (#3836)

Increased the maximum number of attempts for TCP connection to server (#4481)

section:: Class library: Deprecated

code:: String.scDir :: is deprecated (#4374). Please use code:: Platform.resourceDir :: instead.

code:: PlotView.plotColors :: is deprecated (#4678). Please use code:: plotColor :: instead.

As part of version reforming, code:: Main.scVersionPostfix :: has been deprecated (#4706).  Please use code:: Main.scVersionTweak :: instead

code:: Object.asInt :: is deprecated (#4089). Please use code:: Object.asInteger :: instead.

section:: Class library: Fixed

STRONG:: Breaking change::: Fixed an issue with code:: Signal:hammingWindow :: using incorrect coefficients. code:: Signal:hammingWindow_old :: can be used for previous behaviour (#4324)

STRONG:: Breaking change::: code:: Color:asHSV :: could sometimes return NaN -- grayscale colors returned NaN hue, and black returned NaN hue and saturation. Zero values are now returned in these cases, as is the standard (#4369)

Fixed an issue where NamedControl would erroneously convert code:: name :: to a String in some cases (#4761).

Fixed an issue with copying Ndef (#4690)

Fixed an issue where code:: Document.initAction :: would fail to run in some cases (#4582)

Fixed an issue with NodeProxy bundling (#4461)

Fixed a bug in code:: Ndef:asCode :: to correctly handle the default code:: fadeTime :: (#4721, #4695)

Fixed a bug involving fadeTime and code:: Ndef:copy :: (#4701)

Fixed issues with resampling in code:: Plotter :: (#4223)

Fixed a duplicate node ID error in code:: NodeProxy:xset :: (#4512)

Fixed an issue where changing the number of channels or rate of a code:: NodeProxy :: would not free the old bus in time (#4493)

Fixed an issue with code:: Plotter :: resampling of domain given fixed code:: Array:series :: method (#4510)

Fixed a UnitTest for code:: TestTempoClock :: (#4334)

Fixed an issue where code:: typeView :: wasn't updated in NdefGUI (#4056)

Fixed an issue where code:: findRegexp :: would return incorrectly when given an empty string  (#4241)

Fix for Score examples and code:: Platform.defaultTempDir :: on OSX (#4221)

Fixed code:: Plotter :: domain and superpose behavior (#4082)

Fix code:: FunctionDef:argumentString :: handling of varArgs (#4085)

Fixed several issues with code:: SoundFile:cue :: behaviour (#3728)

Fixed an issue where code:: Image :: would not support a filename as an argument (#3949)

Fixed UnitTests for code:: Event :: to reset between tests (#3961)

Fixed an issue where code:: NodeProxy :: would use the wrong release shape in some cases (#3776)

Fixed an issue with code:: Menu.insertAction :: not invoking properly (#3871)

Fixed an issue with code:: UnitTest :: where code:: runAll :: could be inherited by individual tests (#4722)

section:: IDE & SCDoc: Added

Help Browser now supports executing code regions (#3904)

section:: IDE & SCDoc: Changed

sc-ide is now built as a static library (#4628)

Improved a number of style issues in the Help Browser (#3881)

section:: IDE & SCDoc: Fixed

Fixed an issue where SCDoc might segfault on deep node trees during tests (#4713)

Fix for an issue on Windows where the IDE would appear to lock during launch in some cases due to an IPC issue between IDE and sclang (#4646)

Fixed an issue with code execution in the Help Browser where comments contained brackets (#4548)

Fixed an issue where copying a theme would crash the IDE if the new theme was not yet saved (#4146)

Fixed a number of deprecations in Qt (#4649)

Fixed a number of rendering warnings from SCDoc (#4265)


title:: News in 3.12
summary:: A summary of news in SC 3.12
categories:: News

The 3.12 release brings new features, countless bugfixes, as well as project and documentation updates. See the repository for all the changes. A big thank you to all developers for your contributions!

Change log highlights:

section::  General: Added
Supernova on Windows (#4763)

Bela support (#5295)

macOS Big Sur support (#5298, #5356)

section::  General: Changed
Bigger build matrix add CI jobs to implement platform support RFC (#4906)
 
Updated portaudio submodule (#4925)

Implement RFC 10: Replace oppressive terminology with more accurate alternatives (#5251, #5424, #5470)

Increase required C++ standard to C++17 (#5396)

Move CI from Travis/AppVeyor to GitHub Actions (#5261, #5273 #5371, #5377)

Run TestSuite in CI (#5332)

section::  General: Fixed
Builds for older macOS systems (#5537)

section::  sclang: Changed
Exclude default paths: change from command line parameter to language file flag (#3733)

section::  sclang: Fixed
MIDI realtime messages: Push correct number of values onto the stack (#5200)

section::  Class library: Added
Fuzzy equals add fuzzy array comparisons (#4468)

code:: String -runInTerminal :: on Windows (#4882)

Provide suggestions on code:: method not found ::: (#4866)

Add "lazy equality" |==| operator (#5183)

New class: CondVar (#5436, #5448, #5456)

section::  Class library: Fixed
Various UnitTest fixes (#5461, #5457)

section::  scsynth and supernova: Added
Clip values on hardware out busses (macOS) (5110, #5454)

section::  scsynth and supernova: Changed
Supernova bind to the specified address (#5474)

Supernova on macOS: avoid resampling when talking to audio hardware  (#4477)

section::  scsynth and supernova: Fixed
Servers not booting on Windows if some system logs are missing (#5393)

macOS builds include a custom build of libsndfile to support older macOS versions (#5518) 

section::  UGens: Fixed
PanAz: initialize amps in Ctor (#4973)

EnvGen fixes (#5217, #4921, #4793)

section::  IDE: Fixed
Classname highlighting before introspection is available (#5438)


title:: News in 3.13
summary:: A summary of news in SC 3.13
categories:: News

Welcome to the SuperCollider 3.13 release! 

NOTE:: In this version numerous UGens have been fixes so that they calculate their initial value as originally intended. In some cases this may create a different result than previously. See below for details ::

We now also provide a universal build for both x86_64 and arm64 Apple machines.

Below you can find a more complete list of changes in this version. A big thank you to all developers for your contributions!

section::  General

Countless improvements to help files and documentation (@elifieldsteel, @JaimeClover, @DoHITB, @jamshark70, @heretogo, @capital-G, @alexhughk, @chris75vie, @forrcaho, @paum3, @avdrd, @wolfgangschaltung, @telephon, @redFrik, @madskjeldgaard, @mxw, @dyfer, @tdug, @mtmccrea, @prko, @mjsyts, @grirgz, @chkworks, @balzss, @hectorgonzalezo, @michelestew, @mttvn, @pearcemerritt, @mlang)

Updates and fixes for the test suite:
@telephon in https://github.com/supercollider/supercollider/pull/5304, 
@telephon in https://github.com/supercollider/supercollider/pull/5676, 
@jamshark70 in https://github.com/supercollider/supercollider/pull/5666, 
@elgiano in https://github.com/supercollider/supercollider/pull/5717, 
@dyfer in https://github.com/supercollider/supercollider/pull/5702, 
@dyfer in https://github.com/supercollider/supercollider/pull/5738, 
@dyfer in https://github.com/supercollider/supercollider/pull/5792, 
@telephon in https://github.com/supercollider/supercollider/pull/5801, 
@dyfer in https://github.com/supercollider/supercollider/pull/5867, 
@telephon in https://github.com/supercollider/supercollider/pull/5677, 
@nuss in https://github.com/supercollider/supercollider/pull/5687 
@elgiano in https://github.com/supercollider/supercollider/pull/5716.

Updates and fixes for the automated build system (GitHub Actions):
@dyfer in https://github.com/supercollider/supercollider/pull/5845, 
@dyfer in https://github.com/supercollider/supercollider/pull/5783, 
@dyfer in https://github.com/supercollider/supercollider/pull/5847, 
@dyfer in https://github.com/supercollider/supercollider/pull/5875, 
@dyfer in https://github.com/supercollider/supercollider/pull/5889, 
@dyfer in https://github.com/supercollider/supercollider/pull/5776.

section::  General: Added

Universal macOS build for both Intel x86_64 and Apple arm64 CPUs by @dyfer in https://github.com/supercollider/supercollider/pull/5953

Better description in the about dialog for tagged builds by @dyfer in https://github.com/supercollider/supercollider/pull/5697 and https://github.com/supercollider/supercollider/pull/5739

section::  General: Changed

Update sc-el submodule to latest version by @jxa in https://github.com/supercollider/supercollider/pull/5600

The regular release macOS build now supports macOS 10.14 and up (previously supported 10.13). The legacy build is still provided supporting macOS 10.10 and up.
section::  General: Fixed

Remove spurious Qt dependencies by @marcan in https://github.com/supercollider/supercollider/pull/4991

Update urls in git submodules to use https by @dyfer in https://github.com/supercollider/supercollider/pull/5694

Fix building on Apple M1 by adding ad hoc code signing by @dyfer in https://github.com/supercollider/supercollider/pull/5650

Build on OpenBSD by @ibz in https://github.com/supercollider/supercollider/pull/5822

Find JACK using cmake's FindPkgConfig by @dvzrv in https://github.com/supercollider/supercollider/pull/5680

section::  sclang: Added
Ability to set scrollPosition of QWebView by @paum3 in https://github.com/supercollider/supercollider/pull/5483

Interactive Command line interface on Windows using Readline by @dyfer in https://github.com/supercollider/supercollider/pull/5712

Support for MPEG formats by @dyfer in https://github.com/supercollider/supercollider/pull/5786

section::  sclang: Changed

code:: Signal -thresh :: by @elgiano in https://github.com/supercollider/supercollider/pull/5432
section::  sclang: Fixed

Stretch behaviour in QcRangeSlider by @miriamvoth in https://github.com/supercollider/supercollider/pull/5595

code:: Symbol -isPrefix :: by @Brandon-Yip2 in https://github.com/supercollider/supercollider/pull/5708

MIDI realtime message type codes on Linux by @jamshark70 in https://github.com/supercollider/supercollider/pull/5846

RF64 and W64 format recognition by @dyfer in https://github.com/supercollider/supercollider/pull/5877

UdpInPort error reporting by @jamshark70 in https://github.com/supercollider/supercollider/pull/5850

Parsing block arguments by @nilninull in https://github.com/supercollider/supercollider/pull/5522

section::  Class library: Added

Support for code:: kitty :: and code:: alacritty :: Linux terminals by @madskjeldgaard in https://github.com/supercollider/supercollider/pull/5548

code:: NodeProxy -seti :: by @nuss in https://github.com/supercollider/supercollider/pull/5640

Converting mixed outputs in code:: NodeProxy :: instead of failing by @telephon in https://github.com/supercollider/supercollider/pull/5699

Posthook code:: \synthDefReady :: after synthdef is built by @avdrd in https://github.com/supercollider/supercollider/pull/5657

Setting the number of decimal places to code:: SimpleNumber -asTimeString :: by @dyfer in https://github.com/supercollider/supercollider/pull/4709

Make it possible to reschedule a Routine, Task or EventStreamPlayer transparently by @jamshark70 in https://github.com/supercollider/supercollider/pull/5038

Handle code:: langPort :: startup error descriptively by @jamshark70 in https://github.com/supercollider/supercollider/pull/5158

code:: AppClock -schedAbs :: by @telephon in https://github.com/supercollider/supercollider/pull/5851

Vim-like keyshortcuts in HelpBrowser by @paum3 in https://github.com/supercollider/supercollider/pull/5742

Add hooks to the code::Quark:: class by @capital-G and @telephon in https://github.com/supercollider/supercollider/pull/5907

section::  Class library: Changed

Refactor functionality: code:: connectToServerAddr :: by @telephon in https://github.com/supercollider/supercollider/pull/5569

Improve efficiency of calling code:: List -order :: by @telephon in https://github.com/supercollider/supercollider/pull/5561

Allow any type of text stream in the FileReader hierarchy by @jamshark70 in https://github.com/supercollider/supercollider/pull/5611

Improve behaviour of error in code:: loadRelative :: by @telephon in https://github.com/supercollider/supercollider/pull/5744

The argument name for code:: Spawner -seq :: was changed to code:: pattern :: by @tdug in https://github.com/supercollider/supercollider/pull/5767

Replace code:: aiff :: with code:: wav :: as the default value for code:: recHeaderFormat :: by @RhnSharma in https://github.com/supercollider/supercollider/pull/5559

Guarantee that code:: SetBuf :: gets an array by @telephon in https://github.com/supercollider/supercollider/pull/5743

Delete unused method code:: *findMethod :: from ScIDE class by @jamshark70 in https://github.com/supercollider/supercollider/pull/5840

HistoryGui: improve display readability by @adcxyz in https://github.com/supercollider/supercollider/pull/5861

Create only a single server meter by default by @telephon in https://github.com/supercollider/supercollider/pull/5908

section::  Class library: Deprecated

QuartzComposerView by @dyfer in https://github.com/supercollider/supercollider/pull/5710

section::  Class library: Fixed

Prevent possible infinite recursion in code:: *initClassTree :: by @jamshark70 in https://github.com/supercollider/supercollider/pull/5575

Use named controls in node proxy by @telephon in https://github.com/supercollider/supercollider/pull/5675

Fix implicit specs in synth functions by @adcxyz in https://github.com/supercollider/supercollider/pull/5681

Put code:: protect :: in PauseStreams by @jamshark70 in https://github.com/supercollider/supercollider/pull/5626

Fix some filters with node proxy by @telephon in https://github.com/supercollider/supercollider/pull/5679

Handle buffer instance of code:: NdefGui :: as argument by @redFrik in https://github.com/supercollider/supercollider/pull/5692

Defer GUI updates in code:: ServerPlusGUI :: by @dyfer in https://github.com/supercollider/supercollider/pull/5491

Make envelopes behave like patterns in a pattern proxy by @telephon in https://github.com/supercollider/supercollider/pull/5287

Fix code:: Server.remote :: code:: -startAliveThread :: by @elgiano in https://github.com/supercollider/supercollider/pull/5715

Exclude QQuartzComposer from headless builds by @elgiano in https://github.com/supercollider/supercollider/pull/5733

Prevent double-firing of cleanup functions in code:: EventStreamCleanup :: by @jamshark70 in https://github.com/supercollider/supercollider/pull/5386

Fix cleanup setup for Pmono and PmonoArtic by @eleses in https://github.com/supercollider/supercollider/pull/5027

Escaping of code:: String:openOS :: by @elgiano in https://github.com/supercollider/supercollider/pull/5322

Recording in code:: Pbind :: by @madredeuz in https://github.com/supercollider/supercollider/pull/5793

Cast sampleRate to Integer in code:: SoundFileView -setData :: by @redFrik in https://github.com/supercollider/supercollider/pull/5812

Use embedded specs in Ndef for guis by @adcxyz in https://github.com/supercollider/supercollider/pull/5686

Plotter: update colors, fix grid and axis labels, remove code:: Plotter -gui :: method by @mtmccrea in https://github.com/supercollider/supercollider/pull/4511, https://github.com/supercollider/supercollider/pull/5827, https://github.com/supercollider/supercollider/pull/5858. Grid lines and their labels are improved, along with axis labels, which are now settable by their own methods code:: labelX_ :: and code:: labelY_ ::. The x-axis label inherits the units of a code:: domainSpec :: if it is explicitly set and labelX hasn't already been set

Make sure code:: Plot :: color is not converted to array by @telephon in https://github.com/supercollider/supercollider/pull/5849

code:: BinaryOpUGen :: optimization for code:: a === b :: cases by @smrg-lm in https://github.com/supercollider/supercollider/pull/5427

Remove inline warnings in the class library by @telephon in https://github.com/supercollider/supercollider/pull/5856

Make maxLogins not to exceed 32 in code:: ServerOptions :: by @jamshark70 in https://github.com/supercollider/supercollider/pull/5149

Sample alignment with grid lines in code:: Function -plot ::  by @mtmccrea in https://github.com/supercollider/supercollider/pull/5855

Make code:: subBus :: use the same server as receiver by @telephon in https://github.com/supercollider/supercollider/pull/5887

GridLines improvements: fix exponential grids and add spacing control by @dyfer in https://github.com/supercollider/supercollider/pull/5161 and @mtmccrea in https://github.com/supercollider/supercollider/pull/5895, https://github.com/supercollider/supercollider/pull/5942

Expand tilde to users home directory on Windows by @miriamvoth in https://github.com/supercollider/supercollider/pull/5431

Improve code:: Function -flop :: implementation that works with string ellipsis and keyword arguments by @telephon in https://github.com/supercollider/supercollider/pull/5499, https://github.com/supercollider/supercollider/pull/5900

Time precision issues with Psync and EventStreamPlayer by @totalgee in https://github.com/supercollider/supercollider/pull/5891

code:: Pattern -record :: by @jamiehodge in https://github.com/supercollider/supercollider/pull/5883

Make code:: Rest :: accepted by Patterns by @olafklingt in https://github.com/supercollider/supercollider/pull/5882

code:: Buffer *cueSoundFile ::: keep code:: path :: value by @telephon in https://github.com/supercollider/supercollider/pull/5937

section::  scsynth and supernova: Added

Support for MPEG formats by @dyfer in https://github.com/supercollider/supercollider/pull/5786

Option for LIB_SUFFIX in the CMake build system by @tdug in https://github.com/supercollider/supercollider/pull/5644 and @elgiano in https://github.com/supercollider/supercollider/pull/5728

Error warnings and /fail replies to /d_load and /d_loadDir (scsynth) by @muellmusik in https://github.com/supercollider/supercollider/pull/5244

section::  scsynth and supernova: Fixed

Make code:: /g_head :: always fire an code:: /n_move :: reply (scsynth) by @Sciss in https://github.com/supercollider/supercollider/pull/5580

Non-real-time mode in supernova by @Spacechild1 in https://github.com/supercollider/supercollider/pull/5616

Crash when passing audio/control bus mapping to arrayed Group control in supernova by @Spacechild1 in https://github.com/supercollider/supercollider/pull/5617

Possible crash with unit commands by @Spacechild1 in https://github.com/supercollider/supercollider/pull/5610

Use the code:: /error :: messages to turn on / off the console printing in supernova by @vitreo12 in https://github.com/supercollider/supercollider/pull/5820

Support for code:: libsndfile :: version >= 1.1.0 by @dyfer in https://github.com/supercollider/supercollider/pull/5761

Print plugin API method in supernova by @Spacechild1 in https://github.com/supercollider/supercollider/pull/5874

UdpInPort error reporting by @jamshark70 in https://github.com/supercollider/supercollider/pull/5850

Behavior of .sqrt and .reciprocal operations on the server on Apple M1 CPUs by @dyfer in https://github.com/supercollider/supercollider/pull/5901

OffsetOut_Ctor error in supernova on Windows by @Spacechild1 in https://github.com/supercollider/supercollider/pull/5902

section::  UGens: Added

Argument code:: binout :: to code:: SpecPcile :: by @woolgathering in https://github.com/supercollider/supercollider/pull/5097
section::  UGens: Changed

code:: Impulse :: is now initialized correctly such that:
LIST::
##it will fire on the first sample, given the default phase of 0 (or multiple of 1).
##a frequency of 0 fires once and only once on the first sample (unless the frequency subsequently changes).
##negative frequencies and phases are now supported and phase of any value is wrapped into range.
::

These are intended and documented behaviors, but which failed previously in certain UGen configurations. Therefore, users may observe changes to the initial state of synth graphs that use Impulse. (Especially triggered UGens.) For details, a list of resolved/changed behavior can be found here.

For more details see https://github.com/supercollider/supercollider/pull/4150 by @mtmccrea

Numerous UGens have been updated so that their initialization sample is set correctly by @mtmccrea: 
code:: OscUGens :: in https://github.com/supercollider/supercollider/pull/5787, 
code:: Klang :: and code:: Klank :: in https://github.com/supercollider/supercollider/pull/5817, 
code:: TWindex :: in https://github.com/supercollider/supercollider/pull/5815,
code:: Free :: and code:: PauseSelf :: in https://github.com/supercollider/supercollider/pull/5914,
code::Poll:: in https://github.com/supercollider/supercollider/pull/5965
.

code:: Integrator :: Ctor passes through the first sample only by @jamshark70 in https://github.com/supercollider/supercollider/pull/5352. Prior to v3.13, there was a bug that caused the Integrator to double-count the initial value: the integral of a single 1 followed by endless 0s ends up being 2. Starting with v.3.13, it's 1 as expected.

code:: PanAz ::, due to fixing leaks and imprecisions by @elgiano in https://github.com/supercollider/supercollider/pull/4971

section::  UGens: Fixed
code:: Tap :: samplerate compensation by @morfant in https://github.com/supercollider/supercollider/pull/5606

Audio rate versions of triggered random ugens by @telephon in https://github.com/supercollider/supercollider/pull/5344

code:: AudioControl :: and code:: InFeedback :: processing for an extra cycle by @vitreo12 in https://github.com/supercollider/supercollider/pull/5601

Remove RTAlloc exceptions, and review all plugins' RTAlloc/RTFree by @elgiano in https://github.com/supercollider/supercollider/pull/5713


title:: News in 3.5
summary:: A summary of news in SC 3.5
categories:: News

SECTION:: Language-side news

subsection:: Qt GUI
A new cross-platform GUI kit intended to replace Cocoa and an alternative to SwingOSC.
See link::Guides/News-Qt-GUI:: for more.

subsection:: SCDoc
A new help-system provides consistent documentation with good introspection and easy link::Search##searching:: and link::Browse##browsing::.

The help-files are written in a markup language which is then parsed and used to generate HTML files, which are displayed with the new link::Classes/WebView:: widget inside the link::Classes/HelpBrowser::.

See link::Classes/SCDoc::, link::Reference/SCDocSyntax::, link::Guides/WritingHelp::.

Also a new method link::Classes/Help#*methodArgs:: returns a human-readable string of arguments and default values for a method. Example: code::Help.methodArgs("SinOsc.ar")::

In SuperCollider version 3.5.2, SCDoc has been rewritten and the parser is now implemented in C++ for speed and stability.
The syntax has gotten stricter, and it will throw errors or warnings if there are faults in the documentation. See link::Guides/WritingHelp#News in SC 3.5.2:: for some important changes to keep in mind.

subsection:: OSC and MIDI responders
The new link::Classes/OSCFunc:: and link::Classes/MIDIFunc:: provides better alternatives to the old link::Classes/OSCresponderNode:: and link::Classes/NoteOnResponder::, etc.

OSCFunc can receive on any port, not only the main code::NetAddr.langPort::.

subsection:: New Location of Startup file

The link::Reference/StartupFile##sclang startup file:: has moved to code::Platform.userConfigDir +/+ "startup.scd"::.
Old platform-specific startup file locations have been deprecated. The new startup file is plain-text, rtf is not supported.

subsection:: Language configuration files

The Linux-only library configuration file has been deprecated. It is replaced by a cross-platform language configuration
file, which is located at code::Platform.userConfigDir +/+ "sclang_conf.yaml" :: . It can be configured via the
link::Classes/LanguageConfig:: class.

subsection:: Sced3
The GEdit plugin sced has been updated to support GEdit version 3.

subsection:: WiiMote
code::WiiMote.discover:: now returns the device object, or nil if it failed.

subsection:: Bus-asMap in patterns
Bus-asMap symbols are now allowed in code::\freq:: and friends in patterns.

subsection:: Warn on classlib overwrites
Warnings are posted when extensions overwrites methods in main class lib, unless the extensions are put in a subfolder named "SystemOverwrites".

subsection:: Filesystem utils
New cross-platform filesystem utilities: link::Classes/File#*copy::, link::Classes/File#*mtime::, link::Classes/File#*mkdir::, link::Classes/File#*realpath::, link::Classes/File#*type::, link::Classes/File#*fileSize::

subsection:: String-openTextFile
link::Classes/String#-openTextFile:: now works also on frontends without link::Classes/Document:: support. It falls back to link::Classes/String#-openOS:: to open the file with the default application for that file type.

subsection:: Optional trailing comma
It was already allowed to have a trailing comma in arrays: code::[1,2,3,]::,
but now it's also allowed in Event construction and message arguments:
code::
(a:1, b:2, c:3,);

Pbind(
    \foo, 1,
    \bar, 2,
);

myFunc.value(1, 2, 3,);
::

subsection:: Various bugfixes
A lot of bugs has been fixed, for example: String regexp primitives, multichannel wrappers of SequenceableCollection, CoinGate.ar, T2K, WiiMote, SynthDesc.

subsection:: Interpreter Performance Improvements

The sclang now uses token threading footnote::http://www.complang.tuwien.ac.at/forth/threaded-code.html:: instead of one huge switch statement for bytecode dispatching.

subsection:: PriorityQueue stable order

The link::Classes/PriorityQueue:: now provides a stable heap order: items of the same time value will have a FIFO order.

subsection:: plot improvements

link::Reference/plot:: has been changed to use the link::Classes/Plotter:: class, which was formerly used by the code::plot2:: methods. code::plot2:: has been deprecated, the old behavior is still available via the code::plotOld:: methods, which have also been deprecated.

subsection:: UI deprecated

The UI class has been deprecated. Its functionality is now provided by the link::Classes/ShutDown:: and
link::Classes/OnError:: classes.

subsection:: Panner and XFade classes deprecated

The Panner and XFade classes that been used internally are now deprecated. UGens are better off, implementing the
code::checkInputs:: explicitly.

subsection:: Quark files outside DIRECTORY

teletype::*.quark:: files are now allowed to be within the quark itself rather than in the DIRECTORY.
This allows manually installed quarks to be easily managed by link::Classes/Quarks#*gui::

subsection:: New error marker
Instead of the non-cross-platform bullet-character (•), the error token in error messages are now underlined with teletype::^^^:: characters instead.

For example, the code code::[a, %%&&**, b]:: results in:
teletype::
  line 1 char 10:

  [a, %%&&**, b]
      ^^^^^^
::

SECTION:: Server-side news

subsection:: Bitwise ops
The bitwise operators code::&:: (and), code::|:: (or), code:: xor: :: (xor), code::<<:: (left shift) and code::>>:: (right shift) are now supported server-side on audio and control signals. Example:
code::
// 8-bit magic
(
play {
    var t = PulseCount.ar(Impulse.ar(8e3));
    HPF.ar(
        (
            ((t * 15) & (t >> 5)) |
            ((t * 5)  & (t >> [3, 4])) |
            ((t * 2)  & (t >> 9)) |
            ((t * 8)  & (t >> 11))
            - 3 % 256
        ) / 127-1 * 3
        , 20
    ).tanh
}
)
::

subsection:: VarLag UGen
The new link::Classes/VarLag:: UGen provides the same functionality as Lag but with linear and other curves.

subsection:: DelTapWr/DelTapRd UGens
The new link::Classes/DelTapRd:: and link::Classes/DelTapWr:: UGen can be used to easily implement multitap delays.

subsection:: Node-onFree
A new method link::Classes/Node#-onFree:: runs a function when node finished playing.

subsection:: LocalIn initial value
link::Classes/LocalIn:: now has an input for initial value.

subsection:: Close buffers on free
teletype::/b_free:: also free's soundfile if open (like teletype::/b_close::)

subsection:: More done flags
link::Classes/Demand::, link::Classes/VDiskIn:: and link::Classes/DiskIn:: now sets done flag (to be used by link::Classes/Done:: or link::Classes/FreeSelfWhenDone::)


subsection:: Shared Memory Server Interface

A shared-memory interface to the server has been introduced. This allows scoping and synchronous control bus access
for local clients.

subsection:: HPF/RHPF internal precision

The recursive filter loop for link::Classes/HPF:: and link::Classes/RHPF:: has been changed to double-precision in
order to avoid quantization noise. Pieces that depend on the quantization noise can make use of the GlitchUGens provided in sc3-plugins, which implement the old behavior.

subsection:: Plugin entry point

Plugins should use the teletype::PluginLoad:: macro as entry point instead of implementing a teletype::load:: funcion.
This allows ABI version checks and ensures that the entry point function is correctly exported from the shared library.
See link::Guides/WritingUGens:: for details.

subsection:: New FFT Plugin API

A new FFT API for server plugins has been introduced: this simplifies writing FFT ugens in a cross-platform manner,
since no external FFT libraries are required.

subsection:: Supernova

A new multi-processor implementation of scsynth. Parallelism of the synthesis graph is exposed to the user via the 
link::Classes/ParGroup:: class. Supernova is currently Linux-only. It is not provided in the macOS/Windows binaries.
In order to play patterns inside a ParGroup, the link::Classes/PparGroup:: can be used. Scsynth emulates parallel groups
with groups.

Plugins have to be adapted by acquiring spinlocks when accessing busses or buffers. See link::Guides/WritingUGens:: for
details.


title:: News in 3.6
summary:: A summary of news in SC 3.6
categories:: News

SECTION:: SuperCollider IDE

A new cross-platform SuperCollider coding environment.

Read link::Guides/SCIde##the guide::!


SECTION:: Language-side news

subsection:: More informative syntax errors
The parser now posts the details of syntax errors, example:
code::
[1,2,%,4];
123;
::
Posts the following error message:
teletype::
ERROR: syntax error, unexpected BINOP, expecting ']'
  in file 'selected text'
  line 1 char 6:

  [1,2,%,4];
       ^
  123;
-----------------------------------
ERROR: Command line parse failed
::

subsection:: Remove old syntax
code::#(a:1):: was valid syntax, but yielded nonsense results. This will now result in a syntax error instead.

subsection:: YAML/JSON parser
link::Classes/String#-parseYAML:: and link::Classes/String#-parseYAMLFile:: can be used to parse YAML or JSON.

subsection:: SynthDef optimizations for additive terms

When the SynthDef is compiled, separate additive ugens are combined via the new link::Classes/Sum3:: and
link::Classes/Sum4:: ugens.

subsection:: Basic dead code elimination for SynthDefs

The process of building synthdefs now performs a simple dead code elimination pass, which removes all
link::Classes/PureUGen:: instances without successor.

subsection:: Case sensitive String comparison
String comparison operators (teletype::==, !=, <=, >=, >, <::) are now case sensitive.
code::
"Foo" == "fOo"; // false
::

subsection:: SplayAz Bug Fix
Positioning of SplayAz was broken. The semantics of the TELETYPE::spread:: and TELETYPE::center:: arguments has
been changed in order to fix the behavior.

subsection:: Array primitives respect mutability
The array primitives now respect object mutability: writing to an immutable object now fails and changing an
immutable object with TELETYPE::add::, TELETYPE::addAll::, TELETYPE::insert::, TELETYPE::extend::,
TELETYPE::growClear:: and TELETYPE::overwrite:: will return a newly allocated object.

SECTION:: Server-side news

subsection:: SynthDef2 fileformat

subsection:: C++ base class for Unit Generators

A new C++ base class has been introduced, which extends the plain c-style Unit struct by a C++ interface.


title:: News in 3.7
summary:: A summary of news in SC 3.7
categories:: News
related::Guides/News-3_6, Guides/News-3_5, Guides/Debugging-tips


In addition to the new features and changes described here, there are STRONG::many bugfixes and interesting improvements::, a full list of which can be found in CHANGELOG.md.


SECTION::SuperCollider IDE

LIST::
##Menu entries for Recording, scope and server inspection
##Modify and query IDE documents from sclang
##Support for the Atom text editor
##Integrated help with auto-completion
##Autosave feature
::

SECTION::SuperCollider Language




LIST::
##Improved link::Classes/Quark:: system and many new interesting Quarks.
##LINK::Classes/TempoClock#-beats:: can be set.
##An interface for key-value-pairs, see link::Reference/Key-Value-Pairs::
##Refactored JITLib, see link::Other/JITLibChanges3.7:: (in particular dynamic channel expansion).
##LINK::Classes/QuartzComposerView::
::


SUBSECTION::External Interfacing

There is an entirely new HID (Human Interface Device) implementation: see link::Guides/Working_with_HID:: that works cross platform (Linux and macOS thus far). This deprecates the GeneralHID interface. Also the link::Classes/LID:: interface has been updated to match the API of the new HID implementation.



SUBSECTION::New methods and classes

LIST::
##link::Classes/Collection#-collectCopy::, link::Classes/Collection#-collectInPlace::
##link::Classes/SimpleNumber#-lcm:: and link::Classes/SimpleNumber#-gcd:: have consistent interpretations of negative values and zero.
##link::Classes/Dictionary#-embedInStream:: can be customized from within the dictionary.
##link::Classes/Server#*remote:: Create a new Server instance corresponding to a server app running on a separate machine.
::

SUBSECTION::Deprecated classes and methods
LIST::
##TuningInfo
##ScaleInfo
##Proutine (use Prout instead)
##Document style api - set postColor background etc.
##Date-bootTime
##Platform-getMouseCoords (use GUI.cursorPosition instead)
::



SECTION::SuperCollider Server

Apart from UDP, the TCP-protocol is now supported.

When mapping controls of synths to busses, their number of channels is limited to the number of control channels, avoiding a "spill-over" of mappings.

SUBSECTION::List of new UGens

LIST::
##NodeID (UGen that returns the current node id)
##LINK::Classes/Dconst::
::

SUBSECTION::Improved or corrected behavior
LIST::
##LINK::Classes/LinXFade2:: (correct fading direction)
##LINK::Classes/LFPulse:: (when width = 0.5, return exactly as many 0 as 1)
##LINK::Classes/TrigControl:: is now independent of synth order, like LINK::Classes/Control::.
##LINK::Classes/TRand::, LINK::Classes/TExpRand::, LINK::Classes/TIRand:: (can operate at audio rate)
##LINK::Classes/Env#*new:: accepts a new TELETYPE::step2:: shape, which steps to a value at the end of a shape
##LINK::Classes/UGen#-curvelin:: is now inverse of LINK::Classes/UGen#-lincurve::
##LINK::Classes/Server#-record:: correctly closes short files
##In combinations of demand-ugens: Instances of PV_Copy are added automatically where necessary for parallel processing
::


SUBSECTION::More operators work uniformly across sclang and scserver

The following operators have been added as UGens and work the same as in sclang:

TABLE::
##unary operators || code::rand, rand2, linrand, bilinrand, sum3rand, coin::

##binary operators || code::lcm, gcd, rrand, exprand::
::

See link::Overviews/Operators::


SECTION:: Known Issues

While much has improved and many bugs from 3.6 have been fixed, there are still many known issues. For a complete list see: link::https://github.com/supercollider/supercollider/issues/::

Please do not hesitate to add new issues you find to the LINK::https://github.com/supercollider/supercollider/issues##issue tracker:: or mention them on the  LINK::http://www.birmingham.ac.uk/facilities/ea-studios/research/supercollider/mailinglist.aspx##mailing list::


title:: News in 3.8
summary:: A summary of news in SC 3.8
categories:: News
related::Guides/News-3_7, Guides/News-3_6, Guides/News-3_5, Guides/Debugging-tips

3.8 is light on new features and heavy on small bugfixes. See CHANGELOG.md for more details.

SECTION::SuperCollider IDE

LIST::
## The middle mouse button now closes tabs.
## A new menu entry, Language > Quarks, launches Quarks.gui.
::

SECTION::SuperCollider Language

LIST::
## New methods: link::Classes/Function#-plotAudio::, link::Classes/Bus#-plotAudio::.
## It is now easier to insert custom views, in particular subclasses of link::Classes/SCViewHolder::, into layouts.
## New methods: link::Classes/TreeView#-addChild::, link::Classes/TreeView#-insertChild::, and link::Classes/TreeView#-childAt::, alias methods provided for symmetry with TreeViewItem.
::

SECTION::SuperCollider Server

LIST::
## A new command-line option for scsynth, -B, allows binding to a specific address.
## link::Classes/VOsc:: supports an audio-rate phasein argument.
## link::Classes/TGrains:: supports numChannels set to 1.
::

SECTION::API changes

LIST::
## The number of default audio buses has been increased from 128 to 1024.
## link::Classes/TGrains::, link::Classes/GrainBuf::, link::Classes/GrainSin::, link::Classes/GrainFM::, and link::Classes/GrainIn:: now have unified panning behavior when numChannels is 2 and the pan exceeds the range [-1, 1].
## Several old methods have been deprecated from link::Classes/PathName::: *fromOS9, foldersWithoutCVS, isCVS, foldersWithoutSVN, isSVN, filesDoNoCVS, filesDoNoSVN, streamTreeNoCVS.
## The argument "startframe" has been renamed to "startFrame" and "aSoundFile" to "soundFile" in the following methods of link::Classes/SoundFileView::: loadFile, setData, readFile, read, readFileWithTask, readWithTask.
::

SECTION:: Known Issues

While much has improved and many bugs from 3.7 have been fixed, there are still many known issues. For a complete list see: link::https://github.com/supercollider/supercollider/issues/::

Please do not hesitate to add new issues you find to the LINK::https://github.com/supercollider/supercollider/issues##issue tracker:: or mention them on the  LINK::http://www.birmingham.ac.uk/facilities/ea-studios/research/supercollider/mailinglist.aspx##mailing list::


title:: News in 3.9
summary:: A summary of news in SC 3.9
categories:: News
related::Guides/News-3_8, Guides/News-3_7

We are proud to announce the arrival of SuperCollider 3.9.0! Apologies
for being so far behind schedule; we hope the improvements you'll find here
will more than make up for it. In 3.9.0, determined contributors have fixed
some of SuperCollider's major cross-platform compatibility demons, addressed
longstanding issues in the IDE and language, and added new features and bugfixes
across the board.

Many thanks to all who contributed to this release: adcxyz, awson, bagong,
brianlheim, cappelnord, carlocapocasa, crucialfelix, danstowell, defaultxr,
dyfer, elifieldsteel, gagnonlg, ghost, gusano, jamshark70, jd-m, jleben,
jmckernon, joshpar, jreus, LFSaw, llloret, LucaDanieli, Magicking,
miguel-negrao, muellmusik, patrickdupuis, porres, privong, redFrik, samaaron,
scztt, simdax, smoge, smrg-lm, snappizz, telephon, thormagnusson,
tiagomoraismorgado88, timsutton, vivid-synth, vividsnow, yurivict, and many
more in the SC community who helped in ways other than participation on GitHub.

section:: Known Issues

The IDE server status display turns yellow after a few seconds when opening code:: s.makeGui ::.  This does not cause any usability issues.

Only the first pages of the HTML files produced by SCDoc are printed in web browsers.

The help browser does not remember the last position open in a document when navigating through history, and just jumps to the top of the file.

Supernova loads plugins from "Extensions/plugins" rather than "Extensions".

code:: LevelIndicator.style() :: is broken, which leads to confusing warning messages.

code:: File.copy :: crashes the interpreter if the destination file exists.

On Windows, SerialPort is not available.

On Windows, Supernova is not available.

On Windows, the command-line sclang interpreter is not available.

section:: General: Added

scvim has seen numerous enhancements now that an actively maintained fork has been merged in.

SuperCollider can now be built on Windows using the MSYS2 toolchain, thanks in particular to @awson and @bagong.

SuperCollider can now be built on FreeBSD, thanks to @shamazmazum and @yurivict.

Detailed documentation on creating macOS standalone applications with SuperCollider has been added, thanks to @adcxyz.

Support for multiple sclang clients connecting to the same server is greatly improved, thanks to @adcxyz.

A CODE_OF_CONDUCT.md and CONTRIBUTING.md have been added to the repository.

Higher-resolution raster versions of the SC cube logo have been added to the top-level code:: icons/ :: directory, and a retina-friendly code:: .icns :: file.

section:: General: Changed

strong:: Breaking change: :: code:: sc_gcd :: in the plugin interface now conforms to code:: gcd(n, 0) == n :: instead of code:: gcd(n, 0) == abs(n) ::. This also affects the method code:: SimpleNumber:gcd ::.

The macOS plist file now shows the full version number for both the Version String and Shortened Version String.

section:: General: Fixed

A typo in the build system prevented the code:: -msse :: compiler flag from being properly set for gcc and clang. This *may* fix subnormal number issues in scsynth that some users have been experiencing.

Fixed a fontification break in scel when too many classes are defined.

Fixed build failures on FreeBSD, GCC 7, and newer versions of Boost.


section:: scsynth and supernova: Added

scsynth and supernova now support a code:: /version :: command, which responds with a message of the form code:: /version.reply program major minor patch branch commit ::. See the Server Command Reference for full details.

section:: scsynth and supernova: Changed

On macOS, if scsynth's input and output devices have mismatched sample rates, an error is thrown and the server does not boot. Setting the number of input channels to 0 (code:: -i 0 :: on the command line and code:: s.options.numInputBusChannels = 0 :: in sclang) now bypasses this error.

Disabled Nagle's algorithm for TCP communication in scsynth. Nagle's algorithm increases bandwidth at the cost of delay, which is undesirable in the context of SuperCollider. Both supernova and sclang have it turned off.

section:: scsynth and supernova: Fixed

The code:: /b_read :: and code:: /b_readChannel :: messages experienced intermittent failures to read sound files, most notably affecting code:: Buffer.cueSoundFile ::. This has been fixed.


section:: UGens: Added

A new UGen, code:: Sanitize ::, replaces infinities, NaNs, and subnormals with another signal, zero by default.

The code:: doneAction :: argument to DetectSilence can now be modulated.

UnaryOpUGen now supports the bitwise not operator code:: bitNot ::. It used to simply fail silently.

section:: UGens: Changed

strong:: Breaking change: :: The application binary interface (ABI) for server plugins has changed. This has an important impact: strong:: plugin binaries compiled for SuperCollider 3.8 will not work with SuperCollider 3.9 :: and vice versa. Please recompile your plugins.

strong:: Breaking change: :: code:: FOS.ar :: with control-rate coefficient inputs incorrectly initialized its coefficients at 0 and ramped to the correct values over the first control period. This has been fixed. To restore old behavior, multiply each coefficient by code:: Line.ar(0, 1, ControlDur.ir) ::.

section:: UGens: Deprecated

code:: Donce ::, a demand-rate UGen with no identifiable purpose, is deprecated. It was most likely used in the production of electronic donce music.

section:: UGens: Fixed

A number of UGens were discovered to have serious initialization bugs where the UGen would output an initial sample of garbage memory. This can create audio explosions if the buggy UGen's output is fed into certain filter UGens like LPF or Delay1. These bugs have been fixed, affecting BeatTrack, BeatTrack2, CoinGate, Convolution, Convolution2, Convolution2L, Convolution3, DetectSilence, DiskIn, DiskOut, IFFT, KeyTrack, LFGauss, PartConv, PV_JensenAndersen, PV_HainsworthFoote, RunningSum, StereoConvolution2L, and Unpack1FFT.

Fixed a bug with code:: TGrains :: ignoring the code:: amp :: parameter.

code:: Dibrown :: no longer ignores the code:: length :: argument.

code:: Pitch :: no longer ignores the code:: median :: argument.

Fixed a build error in DiskIOUGens on Windows.

Fixed code:: AudioControl :: outputting garbage data if a bus is mapped to it but nothing is playing to the bus.

Fixed incorrect math in code:: PanAz.ar :: with audio-rate input signal and position.


section:: sclang: Added

Regression tests for the sclang lexer, parser, and compiler have been added. This will make it easier to make fixes to these components in the future.

section:: sclang: Changed

strong:: Breaking change: :: sclang's nestable multiline comments had some mistakes. In particular, sometimes sclang's lexer would incorrectly process overlapping combinations of code:: /* :: and code:: */ ::, so e.g. code:: */*/ :: would be interpreted like code:: */ /* */ ::. This has been fixed.

The maximum number of MIDI ports has been increased from 16 to 128.

The startup post "NumPrimitives = #" is reworded to "Found # primitives".

section:: sclang: Removed

Removed some unhelpful memory addresses from call stack output in error printing.

Removed some accidentally retained debug posts when the language starts up.

section:: sclang: Fixed

Fixed help files failing to open on Windows if the user's name contains a non-ASCII character.

Fixed non-ASCII characters breaking the Visual Studio debugger.

Fixed a crash in code:: Object:perform :: when the selector is an Array whose first element is not a Symbol, e.g. code:: 0.perform([0]) ::.

code:: thisProcess.nowExecutingPath :: is no longer corrupted by code:: Routine:stop ::.

code:: TextView:selectedString_ :: now works when the selection size is zero.

Fixed a crash when a method or class/instance variable is named "code:: none ::".

Exceptions occurring in primitives no longer print unavoidable error messages even when wrapped in try-catch.

Fixed a crash when code:: Dictionary:keysValuesArrayDo :: is called with code:: nil :: as an argument.

Fixed code:: WebView:onLinkActivated :: handler failing to fire.

Fixed GUI objects failing to display when launched from the code:: action :: of code:: unixCmd ::. You will still need code:: { }.defer ::, however.

Fixed code:: QImage:getColor :: always returning zero for the green channel.


section:: Class library: Added

The UnitTest quark has been incorporated into the main repository.

Added a code:: rewind :: method to code:: CollStream ::.

Added four new class methods to code:: File :: for convenience: code:: readAllString ::, code:: readAllSignal ::, code:: readAllStringHTML ::, code:: readAllStringRTF ::.

code:: Pstep :: accepts an array as a duration argument.

Help files originating from extensions now display a plaque for visibility.

For consistency with other code:: Platform :: class methods, code:: Platform.recordingsDir :: may be used instead of code:: thisProcess.platform.recordingsDir ::.

code:: SequenceableCollection :: has two new instance methods: code:: flatten2 :: and code:: flatBelow ::. Additionally, code:: flatten :: is faster now.

The code:: ~callback :: function is now available for all code:: Event :: types instead of just "on" events.

Event types now include a code:: parentEvent ::, which provides default values..

New aliases for done actions, e.g. code:: Done.freeSelf == 2 ::, are introduced for better readability. See the code:: Done :: helpfile for details.

A new class, code:: Recorder ::, allows recording independently of the code:: Server :: object.

code:: SequenceableCollection:reduce :: supports an adverb argument.

A code:: recordingsDir :: method has been added directly to code:: Platform ::, which transparently calls code:: thisProcess.platform.recordingsDir ::.

code:: View:-resizeToBounds ::, code:: View:-resizeToHint ::, and code:: Window:-resizeToHint :: were added to make it easier to force Views and Windows to automatically resize.

code:: Maybe :: now supports collection methods code:: at ::, code:: atAll ::, code:: put ::, code:: putAll ::, code:: add ::, code:: addAll ::.

code:: BusPlug:-play :: can now accept a code:: Bus :: object.

Breadcrumb links in helpfiles now have separate links for each node in the hierarchy, and pages with multiple categories have separators between the categories.

code:: SoundFile:*openWrite :: now takes additional parameters.

Two new instance methods were added to Symbol: code:: isBinaryOp :: and code:: isIdentifier ::.

Added three convenience methods: code:: View:resizeToBounds ::, code:: View:resizeToHint ::, and code:: Window:resizeToHint ::.

Added code:: Collection:asEvent :: for easy conversion to an code:: Event ::.

code:: DeprecatedError :: now shows you the file path of the deprecated method.

Added two new methods to code:: SimpleNumber ::: code:: snap :: and code:: softRound ::.

code:: ReadableNodeIDAllocator :: offers a new optional replacement for code:: PowerOfTwoAllocator :: that assigns node IDs in a way more readable to humans when working with multiclient setups.

A new "booted" stage has been added to Server objects that have been booted but
may not be running yet, accessible via code:: Server:hasBooted :: and
code:: Server.allBootedServers ::.

section:: Class library: Changed

strong:: Breaking change: :: Rests in the patterns system have been restructured. Instead of using the code:: isRest :: event property, events are considered rests if one of their properties is a code:: Rest :: object. You must use instances of code:: Rest :: rather than the rest class itself -- use of code:: Rest :: instead of code:: Rest() :: is now deprecated.

strong:: Breaking change: :: Fixed code:: Dictionary:== :: only comparing the values of the two dictionaries, not the keys.

strong:: Breaking change: :: Fixed a mistake where code:: Pen.quadCurveTo :: used the primitive for a cubic Bézier instead of quadratic. To restore the old behavior, change code:: Pen.quadCurveTo :: to code:: Pen.curveTo ::.

strong:: Breaking change: :: The convenience instance methods code:: Env:kr :: and code:: Env:ar :: had the arguments code:: mul :: and code:: add :: renamed to code:: levelScale :: and code:: levelBias ::, since they don't behave like typical code:: mul :: and code:: add :: arguments.

code:: Collection:processRest :: returns the processed collection rather than the original.

The maximum number of MIDI ports has been increased.

Attempting to use a control-rate signal as an input to code:: Hasher.ar :: now results in an error.

The "Cleaning up temp synthdefs..." post message is suppressed if there is nothing to clean up.

To match code:: Out :: and code:: ReplaceOut ::, code:: LocalOut :: and code:: XOut :: now correctly validate their input, checking for a non-zero number of channels.

The argument to code:: Pattern:fin :: has a default of 1 for consistency with code:: Object:fin ::.

code:: Complex:reciprocal :: is faster now.

code:: Buffer:write :: takes floating point arguments, truncating them to integers.

Conversion methods among collection types has been improved and documented.

code:: clientID :: is now protected from being changed while the server is running.

section:: Class library: Deprecated

code:: OSCresponder ::, code:: OSCresponderNode ::, and code:: OSCpathResponder :: now emit deprecation messages, and will be removed after at least a year. Use code:: OSCFunc :: or code:: OSCdef :: instead.

code:: Speech :: is deprecated, and will be removed in 3.10. The rationale is that its audio output is independent of the server (severely limiting use in compositions), it depends on a proprietary macOS API with no prospect of cross-platform compatibility, and it is too niche to justify inclusion in the core library.

The WiiMote classes (code:: WiiMote ::, code:: WiiMoteIRObject ::, code:: WiiCalibrationInfo ::, code:: WiiMoteGUI ::, code:: WiiRemoteGUI ::, code:: WiiNunchukGUI ::) are deprecated. They never reached a stable state and have gone unmaintained and unused for years.

code:: AudioIn :: is deprecated and will be removed in some future version. It was provided only for backward compatibility with SC2, so its deprecation is long overdue. Use code:: SoundIn :: instead.

code:: SplayZ :: has been deprecated for a long time, but it's finally on the "official" deprecation track and will be removed in 3.10. Use code:: SplayAz :: instead.

code:: TDuty_old :: has been deprecated for a long time, but it now emits a warning and will be removed in 3.10. Use code:: TDuty :: instead.

code:: Watcher :: is an old alias for code:: SkipJack :: provided for backward compatibility. It is officially deprecated and will be removed in 3.10.

code:: Server:recordNode :: is deprecated. Use code:: Recorder:recordNode :: instead (e.g. code:: s.recorder.recordNode ::).

The code:: Server.set :: class variable is deprecated. Use code:: Server.all :: instead.

code:: SimpleNumber:quantize :: is deprecated. Use code:: SimpleNumber:snap :: instead.

code:: Server:userSpecifiedClientID :: is deprecated. Use code:: Server:clientID :: instead.

section:: Class library: Removed

Removed non-functional stub methods and classes related to Image: the classes ImageFilter and ImageKernel, and the Image instance methods lockFocus, unlockFocus, applyFilters, filters, filteredWith, addFilter, removeFilter, flatten, invert, crop, applyKernel.

code:: Module ::, an unmaintained and unused class for serialization of Synths, has been moved to a quark.

Removed the code:: openHelpFile :: instance methods of code:: Object ::, code:: String ::, code:: Method ::, and code:: Quark ::. These methods have been deprecated since 3.8.

Removed code:: String:openTextFile :: and code:: Symbol:openTextFile ::. Use code:: String:openDocument :: and code:: Symbol:openTextFile :: instead. These methods have been deprecated since 3.8.

section:: Class library: Fixed

A number of instance methods in code:: Buffer :: and code:: Bus :: did not properly check to see if the object has already been freed, and would act on buffer #0 or bus #0 (which is especially dangerous for the code:: free :: instance method). They now safeguard against this case and throw errors.

The code:: useRanger :: option in code:: EnvirGui :: broke in 3.7. This has been fixed.

code:: IdentityDictionary :: methods code:: collect ::, code:: select ::, and code:: reject :: retain references to the code:: parent :: and code:: proto :: objects.

On Linux, some MIDI methods created method override warnings. These have been silenced.

The "key" argument to code:: Pn :: was not properly set on the first repeat. This has been fixed.

Fixed errors when using a DragSource inside a CompositeView object.

Fixed an interpreter crash when defining a SynthDef whose name is too long. More specifically, the inputs to code:: UnixFILE:putPascalString :: and code:: CollStream:putPascalString :: are now validated.

Server crashes are better handled by the interpreter.

The time display and the "start recording", "pause recording", and "stop recording" menu items now cooperate better with running code:: Server:record ::, code:: Server:pauseRecording ::, and code:: Server:stopRecording ::.

code:: Server:makeGui :: and code:: Server:makeWindow :: broke in 3.8 — the fields in the windows went blank. They are working again.

A timing error with code:: NodeProxy:-clear :: was fixed.

code:: SoundFileView :: correctly displays its grid and does not draw the grid on top of the selection box.

The macOS plist file now shows the full version number for both the Version String and Shortened Version String.

Fixed instances of accidentally silencing error messages caused by neglecting to call code:: Object:primitiveFailed ::.

Patched the possibility of inconsistent code:: TempoClock :: state when the tempo is set via code:: setTempoAtSec ::.

Fixed memory spikes when using code:: MIDIFunc.sysex :: with a large code:: srcID ::.

Fixed spaces sometimes being rendered as code:: %20 :: in links in SCDoc.

Fixed code:: Function:plot :: showing an empty graph if the server wasn't booted when the method was invoked.

Fixed blatant errors in code:: Collection:asAssociations :: and code:: Collection:asPairs :: where elements were dropped.

Fixed bugs in code:: NodeProxy :: when using external servers.

code:: History :: now outputs a correct timestamp on Windows.

Fixed Volume control failing to be persistent when rebooting the server.

Fixed code:: SimpleNumber:asTimeString :: producing nonsensical results with the "precision" argument.

code:: Server:clientID :: can now be changed, allowing multiple clients connect to the same server.

History and HistoryGui have been cleaned up.

Fixed duplicate node IDs involving code:: Server.initTree ::.

Fixed supernova crashing when too many controls are used.

code:: Volume :: now respects lag time when it is instantiated or destroyed.

section:: IDE & SCDoc: Added

Entries in the Documents docklet can be reordered, and document tabs will automatically reorder to reflect this.

"Edit > Preferences > Editor > Display" has a new option that allows replacing tabs with a dropdown whose items are alphabetically ordered. This makes navigation easier in some performance contexts.

section:: IDE & SCDoc: Changed

Server actions, which were previously in the "Language" menu, have been moved out to their own "Server" menu.

Changed "occurrences" to "matches" in the status bar in the Find and Replace features.

Many minor improvements were made to the look and feel of the documentation.

section:: IDE & SCDoc: Fixed

Fixed SCDoc refusing to index any further documents if one document has a malformed code:: copymethod :: command.

Some Linux systems had unreadable font colors in the autocomplete tooltips. This has been (finally) fixed.

Fixed a bug where code:: Document:selectedString_ :: had no effect.

New tabs are now inserted to the right of the current tab instead of all the way at the end.

The help browser now has keyboard shortcuts for navigating back and forward. These shortcuts are OS-dependent and given to us by Qt.

Fixed the "Find in page..." feature in the help viewer skipping every other occurrence.

Fixed HTML checkboxes appearing in the upper left of the help viewer.

Fixed the right-click menu for the tabs appearing in the wrong place in macOS.


title:: What's new in Qt GUI
summary:: A summary of new features and differences in Qt GUI
categories:: GUI, News

This document is intended for those already familiar with graphical user interface programming in SuperCollider. If you are new to this topic, you are suggested to first read the link::Guides/GUI-Introduction::.

For the purpose of this guide, let's switch to the Qt GUI:

code::
GUI.qt
::

SECTION:: View hierarchy

SUBSECTION:: Every view can be a window

Every view can be displayed as a window on its own, without the use of the Window class. Hence, most methods that are present in Window, are also present in View.

For example, you can display any view without embedding it in a Window or another container view using the link::Classes/View#-front:: method. For this reason, it is valid to omit the 'parent' argument at view construction - any view without a parent can be shown as a window:

code::
(
x = SoundFileView().front;
x.load(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)
::

SUBSECTION:: Every view can be a container

Every view can contain other views (i.e. act as their parent). For this reason, if you want to group several views together, you can simply use a View as the container:

code::
(
v=View(bounds:300@300);
5.do { |i|
    Slider(v).moveTo(i * 25 + 10, 10);
};
v.front;
)
::


SECTION:: Layout management

The Qt layout system allows you to forget about pixels - it manages the size and position of child views in a parent automatically.

SUBSECTION:: Intrinsic view sizes

You may have noticed in the examples above that, besides omitting the code::parent:: argument, we sometimes omitted the code::bounds:: argument as well, at view construction. This is possible because views have intrinsically defined preferred and minimum sizes. See link::Guides/GUI-Layout-Management#Intrinsic view sizes:: for further explanation.

SUBSECTION:: Layout classes

A collection of layout classes allows you to associate one of them with a parent view and several child views, and it will manage positions and sizes of the children automatically according to their size preferences and constraints. It will also do that dynamically, as you resize the window:

code::
(
w = Window.new(bounds:Rect(100,100,300,80)).layout_(
    VLayout (
        HLayout(
            Button().states_([["Super"]]),
            TextField().string_("Collider")
        ),
        Button().states_([["SuperCollider"]])
    )
).front;
)
::

See the link::Guides/GUI-Layout-Management:: guide for detailed explanation.


SECTION:: Color management

SUBSECTION:: The palette

Qt has the notion of the color palette - a collection of colors from which the views pick when drawing themselves. It is represented by the link::Classes/QPalette:: class, and can be set on a view using link::Classes/View#-palette::.

By default, a window will get the global palette ( link::Classes/QtGUI#*palette:: ), and the palette is inherited by child views from their parent. Thus, changing the parent's palette will also affect its children, unless the palette has been overridden on a particular child. You can easily change the appearance of the whole GUI by changing the global palette.

SUBSECTION:: Predefined palettes

There are two predefined palettes ( link::Classes/QPalette#*light:: and link::Classes/QPalette#*dark:: ), and you can also access the native palette of your operating system ( link::Classes/QPalette#*system:: ):

Try changing the global palette with the code below; if you have the Qt GUI active, this will affect this window as well:

code::
QtGUI.palette = QPalette.dark;

QtGUI.palette = QPalette.light;

QtGUI.palette = QPalette.system;
::

SECTION:: View actions and hooks

SUBSECTION:: Mouse and key event propagation

In addition to key events, mouse events can also propagate to parent views.

Also, the control over event propagation works differently in Qt. See link::Classes/View#Key and mouse event processing:: for detailed explanation.

Moreover, you can make a view transparent for mouse events using link::Classes/View#-acceptsMouse::, which will forward all mouse events to the view under, regardless of whether they are in a parent-child relationship.

code::
(
var win, parent, child, sibling1, sibling2;
win = Window(bounds:Rect(30,30,300,300));
parent = Slider2D(win, win.bounds.moveTo(0,0).insetBy(50,50));

// A StaticText will propagate mouse clicks to parent by default:
child = StaticText(parent, Rect(100,-50,150,150))
    .align_(\bottomLeft)
    .string_("\npropagate\nto\nSlider2D")
    .background_(Color.red.alpha_(0.4));

// This StaticText is not a child of Slider2D so will propagate mouse
// clicks to the window instead:
sibling1 = StaticText(win, Rect(0,0,150,150))
    .align_(\topLeft)
    .string_("propagate\nto\nWindow")
    .background_(Color.cyan.alpha_(0.4));

// This StaticText is not a child of Slider2D, but is made transparent for mouse events:
sibling2 = StaticText(win, Rect(150,150,150,150))
    .align_(\bottomRight)
    .string_("ignore")
    .background_(Color.green.alpha_(0.4))
    .acceptsMouse_(false);
win.view.mouseDownAction = { win.background = Color.red(0.6) };
win.view.mouseUpAction = { win.view.palette = QPalette() };
win.front;
)
::

SUBSECTION:: Extended mouse interaction

Many Qt views already implement some kind of strong::mouse wheel:: interaction. For example, you can scroll a ScrollView, ListView and TreeView using the mouse wheel. You can also change the value of a Slider or a Knob using the mouse wheel. In addition, you can assign an action of your own to the mouse wheel event using link::Classes/View#-mouseWheelAction:::

There's another two handy new mouse actions triggered when the strong::mouse enters or leaves:: the view: link::Classes/View#-mouseEnterAction:: and link::Classes/View#-mouseLeaveAction:::.

code::
(
var val = 1.0;
t=StaticText(bounds:Rect(30,30,100,100))
    .font_(Font(size:25))
    .align_(\center)
    .string_(val.asString)
    .stringColor_(Color.red)
    .background_(Color.black)
    .front;
t.mouseEnterAction = { t.background = Color.white };
t.mouseLeaveAction = { t.background = Color.black };
t.mouseWheelAction = { |v,x,y,mod,dx,dy|
    if(dy > 0) { val = val + 0.05 } { val = val - 0.05 };
    val = val.clip(0,2).round(0.01);
    t.string = val.asString;
    t.stringColor = Color.red(val);
};
)
::



SUBSECTION:: Hooks for position and size change

Since views can be automatically repositioned and resized by link::#Layout management#layouts::, or by the user (if they are windows), it may come handy to make your view respond to these changes using link::Classes/View#-onMove:: and link::Classes/View#-onResize::.

code::
(
var view, update;
update = { |v|
    var bounds = v.bounds;
    v.string = "%@%\n%x%".format(
        bounds.left,
        bounds.top,
        bounds.height,
        bounds.width
    );
};

x = StaticText(bounds:Rect(100,100,200,200)).align_(\center).font_(Font(size:25));
x.onMove = update;
x.onResize = update;
update.(x);

x.front;
)
::

SECTION:: Enhancements

SUBSECTION:: Stethoscope

Qt brings a new implementation of link::Classes/Stethoscope:: that uses emphasis::shared memory:: to allow highly efficient monitoring of buses on any strong::local server::.

All the 'scope' methods of various classes (like Server, Bus, Function, etc.) are wired to this new implementation, so you don't need to worry about instantiating a Stethoscope yourself.

code::
Server.local.scope;
::

SUBSECTION:: SoundFileView

link::Classes/SoundFileView:: has strong::infinite display resolution::. This means you can always zoom into the waveform until you see a single sound frame.

It also offers convenient strong::mouse interaction:: for zooming in and scrolling:
list::
## shift + right-click + mouse-up/down = strong::zoom::
## right-click + mouse-left/right = strong::scroll::
::

code::
(
var x = SoundFileView().front;
x.load(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)
::

Alternatively to displaying a soundfile, you can allocate an empty amount of display frames, and fill it strong::part by part:: with data to display (see documentation of link::Classes/SoundFileView#-alloc:: and link::Classes/SoundFileView#-set::). This allows, for example, to implement efficient monitoring of recording into a Buffer.

code::
(
var v, s;
v = SoundFileView().front;
s = Signal.sineFill(1000, 1.0/[1,2,3,4]);
v.alloc(5000, samplerate: 500);
3.do { |i| v.set( i * 2000, s * (1/(i+1)) ) };
)
::

SUBSECTION:: EnvelopeView

link::Classes/EnvelopeView:: offers two different strong::display styles::: in addition to traditional style where nodes are drawn as rectangles with labels inside, it can draw nodes as small dots, with labels next to them. See link::Classes/EnvelopeView#-style::.

code::
(
var w, e, m;
e = EnvelopeView()
    .value_([[0,0.4,0.6,1.0],[0,0.7,0.5,0.56]])
    .strings_(["alpha", "beta", "gamma", "delta"])
    .thumbWidth_(60)
    .style_(\dots);
m = PopUpMenu()
    .items_(["Dot Style", "Rect Style"])
    .action_({e.style = m.value});
w = Window()
    .layout_(VLayout(m,e))
    .front;
)
::

You can enforce a strong::strict order of nodes:: on the time axis. In this case, a node can not move to position before the previous node, or after the next node. See link::Classes/EnvelopeView#-keepHorizontalOrder:: and the example below.

You can also control how a strong::selection of nodes:: behaves when it is strong::moved::: it can either keep its form rigidly and block all movement when meeting view edges or other nodes, or it can adjust its form to the obstacles, allowing the movement of those nodes that are not blocked individually. See link::Classes/EnvelopeView#-elasticSelection:: and the following example.

Example: try selecting several nodes (by clicking on them with Shift key pressed) and moving them around, then use the menu to switch the way selection behaves, and repeat:

code::
(
var w, e, m;
e = EnvelopeView()
    .value_([
        [0, 0.1, 0.3, 0.4, 0.55, 0.7, 1.0],
        [0, 1.0, 0.7, 0.3, 0.5, 0.2, 0]
    ])
    .keepHorizontalOrder_(true)
    .elasticSelection_(true)
    .front;
m = PopUpMenu()
    .items_(["Elastic Selection", "Rigid Selection"])
    .action_({e.elasticSelection = m.value == 0});
w = Window()
    .layout_(VLayout(m,e))
    .front;
)
::

SUBSECTION:: ScrollView

link::Classes/ScrollView:: allows to strong::replace the canvas:: that holds its child views with an arbitrary view. This allows great flexibility, including using a link::#Layout management#layout:: to manage the child views. See link::Classes/ScrollView#-canvas:: for explanation, and this link::Classes/ScrollView#examples#example::.


SECTION:: New views

SUBSECTION:: TreeView

link::Classes/TreeView:: is a powerful addition to the group of views that display a strong::set of items:: (including ListView and PopUpMenu). It displays items organized in a strong::hierarchical:: manner, akin to filesystem browsers.

Unlike ListView, where items are only arranged in one column, TreeView may consist of strong::several columns::: each item occupies a row, and may contain one text value for each column. Columns also have strong::labeled headers::.

Moreover, each data field of an item may also strong::contain another view::, giving you a great potential for interactivity with items.

SUBSECTION:: WebView

link::Classes/WebView:: is the core component for strong::web page browsing::. It is also implemented in the Cocoa GUI, but we list it here nonetheless.

It is a view that displays web pages, with web technology support comparable to widespread desktop web browsers.

NOTE:: There may currently be some issues with displaying multimedia content. ::

code::
(
w = WebView(bounds: Window.screenBounds.insetBy(100,40))
    .url_("http://supercollider.sourceforge.net/")
    .front;
)
::


title:: Node Messaging
summary:: Messaging Nodes with OSC
categories:: Server>Nodes, External Control>OSC

section:: Introduction
The most direct and fast way to send commands to the server is to send messages to the link::Classes/Server:: object, if you are within sc-lang.  If you are in a shell you can use sendOSC (available from CNMAT).

this messaging scheme is explained in detail in:
list::
## link::Reference/Server-Architecture::
## link::Reference/Server-Command-Reference::
## link::Tutorials/Server_Tutorial::
::

section:: Messaging nodes
When creating nodes on the server (synths and groups) the only things we need to know are the nodeID and the server (its address to be precise).

In order to communicate with a synth, one sends messages with its nodeID. If you do not intend to communicate with the node after its creation (and the node will cause itself to end without external messaging), the node id can be set to -1, which is the server's equivalent to nil.

As soon as you want to pass around the reference to a certain node, assuming that you might not have only one server, it can be useful to create a link::Classes/Synth:: or link::Classes/Group:: object. These objects also respond to messages, and when needed can be used to obtain the state of the server side node.

see link::Classes/Node::, link::Classes/Synth::, and link::Classes/Group:: help for more detailed helpfiles on node objects.

the equivalent of
code::
n = s.nextNodeID;
s.sendMsg("/s_new", "default", n);
s.sendMsg("/n_free", n);
::
is
code::
n = Synth("default");
n.free;
::

when passing arguments:
code::
n = s.nextNodeID;
s.sendMsg("/s_new", "default", n, 0, 0, "freq", 850);
s.sendMsg("/n_set", n, "freq", 500);
s.sendMsg("/n_free", n);
::

it is
code::
n = Synth("default", [\freq, 850]);
n.set(\freq, 500)
n.free;
::

note that Symbols may be used instead of Strings:
code::
n = s.nextNodeID;
s.sendMsg(\s_new, \default, n, 0, 0, \freq, 850);
s.sendMsg(\n_set, n, \freq, 500);
s.sendMsg(\n_free, n);
::
and:
code::
n = Synth(\default, [\freq, 850]);
n.set(\freq, 500)
n.free;
::

The answer to the question of whether one should work with node objects or directly with messages depends to some extent on context, and to some extent is a matter of personal taste.

The encapsulation of node objects results in a certain generalization, meaning that other compound objects can respond to the same messages and thus exploit polymorphism. They also provide a certain level of convenience, keeping track of indexes and IDs, etc.

In certain cases, such as for granular synthesis it is recommended to use messages directly, because there is no benefit to be gained from the node objects (i.e. no need to message them) and they add cpu load to the client side.
code::
(
SynthDef("grain", {
	Out.ar(0, Line.kr(0.1, 0, 0.01, doneAction: Done.freeSelf) * FSinOsc.ar(12000))
}).send(s);
)

(
Routine({
	20.do({
		s.sendMsg("/s_new", "grain", -1);
		0.01.wait;
	})
}).play;
)
::

In cases where you need to keep track of the synth's state, it is advisable to use node objects and register them with a link::Classes/NodeWatcher::. (see helpfile)

Apart from such cases it is a matter of taste whether you want to use the combination of message and a numerical global representation or an object representation. The two can be mixed, and certain advantages of the object style can be accessed when using messaging style. For instance code::Server.nextNodeID:: allows one to use dynamically assigned IDs in messaging style. As a gross generalization, it is probably fair to say that object style is more convenient, but messaging style is more efficient, due to reduce client-side CPU load.

note::
IMPORTANT: If you wish to have the functionality of the default_group (e.g. problem free use of Server's record and scope functionality) you should treat ID 1 (the default_group) as the root of your node tree rather than ID 0 (the RootNode). See default_group for more details.
::

Note that link::Classes/Function#-play#Function-play:: and link::Classes/SynthDef#-play#SynthDef-play:: return a synth object that can be used to send messages to.
code::
x = { arg freq=1000; Ringz.ar(Crackle.ar(1.95, 0.1), freq, 0.05) }.play(s);
x.set(\freq, 1500);
x.free;
::

section:: Argument lists in node messages

Several node messages accept lists of values to map onto the controls of Synth nodes, as in some of the examples already given:
code::
s.sendMsg(\s_new, \default, n, 0, 0, \freq, 850);
n = Synth(\default, [\freq, 850]);
::
Argument lists generally appear as alternating pairs, with the control identifier preceding the value. Usually the control identifier is a name, as above, but it could also be an integer index. (Using integers is slightly faster for the server, but it makes the code harder to read and can introduce bugs if the SynthDef structure changes.)
One way to find out control indices is to .add the SynthDef into a link::Classes/SynthDescLib::, then get the list of all controls out of the link::Classes/SynthDesc::.
code::
	(
		SynthDef(\controlList, { |out = 0, freq = 440, amp = 0.1, detune = #[0.999, 1.001], gate = 1|
			var	sig = Mix(Saw.ar(freq * (detune ++ [1]), amp)),
			env = EnvGen.kr(Env.adsr, gate, doneAction: Done.freeSelf);
			Out.ar(out, (sig * env) ! 2);
		}).add;

		SynthDescLib.global[\controlList]
	)
::
Prints:
code::
SynthDesc 'controlList'
Controls:
ControlName  P 0 freq control 440
ControlName  P 1 amp control 0.10000000149012
ControlName  P 2 detune control 0.9990000128746
ControlName  P 3 ? control 1.00100004673
ControlName  P 4 gate control 1
ControlName  P 5 out control 0
   O audio 0 2
::
The list shows that the 'freq' control has index 0, 'amp' is 1 and so on. Detune is defined as an "array argument," occupying indices 2-3.

SynthDefs with a large number of controls may need a little extra code to print the entire list.
code::
SynthDescLib.global[\controlList].controls.do(_.postln); ""
::

Prior to SuperCollider 3.3, the only way to set array arguments by name was using n_setn (or Node's setn method). Beginning in version 3.3, array arguments can be included in s_new or n_set messages transparently.

subsection::Messaging style
note the characters $[ and $] delimiting the array in the list:
code::
n = s.nextNodeID;
s.sendMsg(\s_new, \controlList, n, 0, 0, \detune, $[, 0.95, 1.005, $], \freq, 220);
s.sendMsg(\n_set, n, \gate, 0);
::

subsection::Object style
the Node object automatically inserts $[ and $] for you:
code::
n = Synth(\controlList, [\detune, [0.95, 1.005], \freq, 220]);
n.set(\detune, [0.99, 1.01]);
n.release;
::

subsection::Event style
Supplying an array for an argument in an event already has another meaning: multichannel expansion, in which a separate node is created for each array item. If all items of the array should be sent to the same node, then the array argument should be enclosed in another array level:
code::
(instrument: \controlList, freq: 220, detune: [[0.95, 1.005]], sustain: 2).play;
::


 title:: Non-Realtime Synthesis (NRT)
summary:: Non-realtime synthesis with binary files of OSC commands
categories:: Server>NRT, External Control>OSC
related:: Classes/Score

SECTION:: Realtime vs. Non-Realtime Synthesis

When you boot a SuperCollider server (scsynth, or supernova on supported systems) normally, it runs in emphasis::realtime:: mode:

list::
## The server is constantly processing audio, at a rate determined by the hardware sample rate.
## The server receives OSC commands over a network interface, and processes them either at the next available opportunity, or at a time specified by a timestamp.
## The server can also send OSC messages back to the client.
::

If the server starts with the -N switch, it runs in emphasis::non-realtime:: (NRT) mode:

list::
## The server processes audio as fast as possible, or as slow as necessary, depending only on workload. There is no attempt to synchronize with any other time reference.
## The server takes commands only from a file of OSC commands (a "score"), prepared in advance.
## There is no network connection and no interaction with the process while it is running.
::

Strong::When to use NRT mode: :: If the audio processing can be arranged fully in advance, and you need "faster-than-light" processing (or the processing is too heavy to complete in real time), NRT may be appropriate.

Strong::When not to use NRT mode: :: If you need to interact with the server process at specific times, NRT is not appropriate. For instance, if your code makes decisions about upcoming events based on data received from link::Classes/SendReply::, link::Classes/Bus#-get:: (teletype::/c_get::) or link::Classes/Buffer#-get:: (teletype::/b_get::), or node notification messages, these data will not be available in NRT mode.


SECTION:: Basic usage of Score

It is recommended to use a link::Classes/Score:: object to run NRT processes. A Score object:

list::
## prepares the binary OSC file for you, in the correct format;
## manages NRT server processes;
## can optionally play the Score, or portions of it, in real time for testing.
::

code::
(
var server = Server(\nrt,
	options: ServerOptions.new
	.numOutputBusChannels_(2)
	.numInputBusChannels_(2)
);

a = Score([
	[0.0, ['/d_recv',
		SynthDef(\NRTsine, { |out, freq = 440|
			Out.ar(out, SinOsc.ar(freq, 0, 0.2).dup)
		}).asBytes
	]],
	[0.0, (x = Synth.basicNew(\NRTsine, server, 1000)).newMsg(args: [freq: 400])],
	[1.0, x.freeMsg]
]);

a.recordNRT(
	outputFilePath: "~/nrt-help.wav".standardizePath,
	headerFormat: "wav",
	sampleFormat: "int16",
	options: server.options,
	duration: 1,
	action: { "done".postln }
);

server.remove;
)
::

subsection:: Timed messages

A new Score object needs a list of commands, with times.

Each command is an array, e.g. code::['/n_set', 1000, 'gate', 0]::.

Each command is bound to a time by placing it in another array, with the time (a floating point number, in beats) first:

code::
[143.2647423, ['/n_set', 1000, 'gate', 0]]
::

NOTE:: Times are adjusted for the clock's tempo. link::Classes/Score#*new:: allows you to specify a link::Classes/TempoClock::; if you don't, then code::TempoClock.default:: will be used. ::

Server abstraction objects (Synth, Group, Buffer etc.) include methods to give you the OSC message. So, a Score may frequently include idioms such as:

list::
## Create a group: code::[time, Group.basicNew(server).newMsg]::
## Create a synth: code::[time, Synth.basicNew(\defname, server).newMsg(target, args: [...])]::
## Read a buffer from disk: code::[time, Buffer(server).allocReadMsg(path)]::
::

NOTE:: Normal usage of link::Classes/Synth:: or link::Classes/Buffer:: communicates immediately with the server: code::Synth.new(...):: transmits teletype::/s_new::; code::Buffer.alloc(server, ...):: sends teletype::/b_alloc::. To build a NRT score, create the object as a placeholder (no immediate communication) and then ask a placeholder for the message: link::Classes/Synth#*basicNew:: and link::Classes/Synth#-newMsg::, or link::Classes/Buffer#*new:: and link::Classes/Buffer#-allocMsg:: or link::Classes/Buffer#-allocReadMsg::. There is no need for a bus-allocation message simmilar to link::Classes/Buffer#-allocMsg::. If you have only used realtime synthesis, this code style is unfamiliar, but it's worth practicing.

(The result of, e.g., teletype::newMsg:: is already the array representing the message. So it is sufficient for each Score item to be an array containing the time and method call. The subarray should be explicit only when writing the message by hand.) ::

Consult help files for the server abstraction classes for additional "...Msg" methods.

If you save the result of code::Synth.basicNew(...):: in a variable, then you can free it later using either link::Classes/Node#-freeMsg:: or link::Classes/Node#-releaseMsg::, e.g.:

code::
[1.0, (x = Synth.basicNew(\default, server)).newMsg(args: [freq: 200])],
[2.0, x.releaseMsg]
::

For link::Classes/SynthDef::, there is no teletype::addMsg:: or teletype::recvMsg:: method. Add SynthDefs into the Score as follows:

code::
[0.0, ['/d_recv', SynthDef(...).asBytes]]
::

Very large SynthDefs will need to be written to disk and emphasis::not:: rendered as OSC messages in the Score. The SuperCollider language client limits the size of a single OSC message to 65516 bytes. If a SynthDef exceeds this limit, creation of the Score object will fail with the error message teletype::ERROR: makeSynthMsgWithTags: buffer overflow::. Resolve this error message as follows:

code::
(
SynthDef(\veryLarge, {
	// ... very large UGen graph...
}).writeDefFile;
)

(
x = Score([
	// Do NOT put a \d_recv message for \veryLarge here!
	// Allow the NRT server to read it from the disk file.
	...
]);
)
::

subsection:: Rendering a Score using 'recordNRT'

To render the Score, use the link::Classes/Score#-recordNRT:: method. Here is a rough template, followed by an explanation of the teletype::recordNRT:: parameters.

code::
(
a = Score(...);

a.recordNRT(
	oscFilePath: ,
	outputFilePath: ,
	inputFilePath: ,
	sampleRate: ,
	headerFormat: ,
	sampleFormat: ,
	options: ,
	completionString: ,
	duration: ,
	action:
);
)
::

definitionlist::
## oscFilePath || Recommended to omit (leave as teletype::nil::). Score will generate a temporary filename  for you.
## outputFilePath || The output audio file that you want (full path).
## inputFilePath || Optional. If you provide an existing audio file, its contents will stream to the NRT server's hardware input buses.
## sampleRate || Output file sample rate.
## headerFormat || See link::Classes/SoundFile#-headerFormat::.
## sampleFormat || See link::Classes/SoundFile#-sampleFormat::.
## options || An instance of link::Classes/ServerOptions::. In particular, this is important to set the desired number of output channels, e.g. code::ServerOptions.new.numOutputBusChannels_(2)::.
## completionString || Undocumented. No apparent purpose.
## duration || The desired total length of the output file, in seconds.
## action || A function to evaluate when rendering is complete.
::

Of these, teletype::outputFilePath::, teletype::options:: and teletype::duration:: are particularly important. Make sure you specify at least these.

NOTE:: NRT processing continues until the last timestamp in the score file. If you specify a teletype::duration:: for recordNRT, Score will automatically append a dummy command at the end of the score, with the given timestamp, ensuring that the output file will be at least this long. ::

If you are repeatedly rendering NRT scores, you can set code::Score.options = ServerOptions.new...:: and teletype::recordNRT:: will use this set of server options by default.

subsection:: Score files
teletype::recordNRT:: allows you optionally to specify the path to the binary OSC score file. This is useful if you want to keep the file for archival purposes, or to delete the file in teletype::recordNRT::'s action function.

If you do not give a path, teletype::recordNRT:: will generate one for you in the system's temporary file location. These files are not automatically deleted after rendering. Some systems may automatically clean up old temporary files after some time. Otherwise, you can take it into your own hands:

code::
var oscPath = PathName.tmp +/+ "mytempscore";

x = Score([ ... ]);

x.recordNRT(oscFilePath: oscPath, ..., action: {
	File.delete(oscPath)
});
::

subsection:: Server instance

If you want to use server abstraction objects (e.g. Synth, Group, Buffer), you might also want them to allocate node IDs or buffer and bus numbers for you. link::Classes/Synth#*basicNew:: and link::Classes/Buffer#*new:: use the server's allocators if you don't supply an ID (leave it nil). However, if you accidentally use the default server, any IDs you allocate for NRT will be marked as allocated in the default, realtime server. To avoid this, you can create a separate Server instance, just for producing the Score, and then remove the instance after rendering. This is a client-only object; you don't need to boot it.

It is technically incorrect to use the default server teletype::s:: for Score generation, but for quick and dirty uses, it may be acceptable. The examples in this document demonstrate the use of a dedicated Server object as a best practice. Following this best practice is likely to avoid problems in which NRT Score generation affect the default server instance; however, in common usage, such problems might not be severe. "At the user's own risk."

subsection:: Server resources

A NRT server is emphasis::a separate server process:: from any other. Every time you run a Score, it launches a brand-new server process. Each new server starts with a blank slate. In particular, any SynthDefs you have added or Buffers you have loaded are not automatically available to the new server.

Therefore, your Score must include instructions to prepare these resources.

It is a very common mistake to load a buffer into a realtime server, and then run a non-realtime server, and find that resources are not available. For instance, this example adds a SynthDef in the normal way (added in memory only), and the SynthDef is not automatically transferred to the NRT server.

code::
// Incorrect
(
SynthDef(\NRTsine, { |out, freq = 440|
	Out.ar(out, SinOsc.ar(freq, 0, 0.2).dup)
}).add;
)

(
var server = Server(\nrt,
	options: ServerOptions.new
	.numOutputBusChannels_(2)
	.numInputBusChannels_(2)
);

a = Score([
	[0.0, (x = Synth.basicNew(\NRTsine, server, 1000)).newMsg(args: [freq: 400])],
	[1.0, x.freeMsg]
]);

a.recordNRT(
	outputFilePath: PathName.tmp +/+ "nrt-help-fail.wav",
	headerFormat: "wav",
	sampleFormat: "int16",
	options: server.options,
	duration: 1,
	action: { "done".postln }
);

server.remove;
)
::

teletype::
->
nextOSCPacket 0
*** ERROR: SynthDef NRTsine not found
FAILURE IN SERVER /s_new SynthDef not found
::

code::
File.delete(PathName.tmp +/+ "nrt-help-fail.wav");
::

NOTE:: Another common technique to transmit SynthDefs to an NRT server is to use link::Classes/SynthDef#-writeDefFile:: to avoid this problem. This works by writing the SynthDef into the default SynthDef directory; then, the NRT server reads SynthDefs from the default location when it starts up. This approach is perfectly valid, but has the disadvantage of leaving teletype::.scsyndef:: files on disk that you might not need later. For that reason, this document demonstrates how to make SynthDefs available to NRT servers without using disk files. ::

The good news is that a NRT server does not have to wait for "heavy" operations like receiving SynthDefs or loading buffers. Commands that are considered asynchronous in a realtime server behave as synchronous commands in NRT. So, you can simply front-load your Score with all the SynthDefs and Buffers, at time 0.0, and then start the audio processing also at time 0.0. (However, you might need a slight offset for the audio processing because code::sort:: may not know which entries at time 0.0 must come first.) The following examples demonstrate.

section:: Examples

subsection:: Algorithmic generation of Synth messages

The preceding example, for simplicity, adds only one synth. Another approach is to create the initial Score with "setup" messages, and add further Synth messages for notes.

code::
(
var server = Server(\nrt,
	options: ServerOptions.new
	.numOutputBusChannels_(2)
	.numInputBusChannels_(2)
),
defaultGroup = Group.basicNew(server);

var time = 0;

x = Score([
	[0.0, ['/d_recv',
		SynthDef(\singrain, { |out, freq = 440, time = 0.1, amp = 0.1|
			var eg = EnvGen.kr(Env.perc(0.01, time), doneAction: 2),
			sig = SinOsc.ar(freq) * amp;
			Out.ar(out, (sig * eg).dup);
		}).asBytes
	]],
	[0.0, defaultGroup.newMsg]
]);

100.do {
	x.add([time, Synth.basicNew(\singrain, server)
		.newMsg(g, [freq: exprand(200, 800), time: exprand(0.1, 1.0)])
	]);
	time = time + exprand(0.02, 0.25)
};

x.recordNRT(
	outputFilePath: "~/nrt.wav".standardizePath,
	sampleRate: 44100,
	headerFormat: "wav",
	sampleFormat: "int16",
	options: server.options,
	duration: x.endTime + 1
);

server.remove;
)
::

subsection:: NRT processing of an audio file

Applying a custom effect to a very long audio file is an especially good use of NRT: create a Score that defines an effect SynthDef and runs it for the duration of of the input file. You can use teletype::recordNRT::'s input file parameter to pipe the source audio to the NRT server's hardware inputs, and read it with link::Classes/SoundIn::.

The example audio file is not very long, but processing here is almost instantaneous.

code::
(
var server,
inputFile = SoundFile.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");

inputFile.close;  // doesn't need to stay open; we just need the stats

server = Server(\nrt,
	options: ServerOptions.new
	.numOutputBusChannels_(2)
	.numInputBusChannels_(inputFile.numChannels)
);

x = Score([
	[0.0, ['/d_recv',
		SynthDef(\fft, {
			var in = SoundIn.ar([0]),
			fft = FFT(LocalBuf(1024, 1), in);
			fft = PV_MagFreeze(fft, ToggleFF.kr(Dust.kr(12)));
			Out.ar(0, IFFT(fft).dup)
		}).asBytes
	]],
	[0.0, Synth.basicNew(\fft, server).newMsg]
]);

x.recordNRT(
	outputFilePath: "~/nrt.wav".standardizePath,
	inputFilePath: inputFile.path,
	sampleRate: 44100,
	headerFormat: "wav",
	sampleFormat: "int16",
	options: server.options,
	duration: inputFile.duration
);

server.remove;
)
::

subsection:: Generating NRT scores from patterns

Event patterns can be converted into Scores by teletype::asScore::. (Note that teletype::asScore:: internally creates a Server instance to use for allocators. So, it is not necessary for this example to create a Server.)

First, a simple example using the default SynthDef. Note that the default SynthDef is not stored to disk by default, so it is necessary to include it in the score. The slight time offset in code::asScore:: is necessary to be sure that the SynthDef message comes first.

code::
(
x = Pbind(
	\freq, Pexprand(200, 800, inf),
	\dur, Pexprand(0.8, 1.25, inf) * Pgeom(0.01, 1.0143978590819, 400),
	\legato, 3,
).asScore(10, timeOffset: 0.001);

x.add([0.0, [\d_recv, SynthDescLib.global[\default].def.asBytes]]);
x.sort;

x.recordNRT(
	outputFilePath: "~/nrt.wav".standardizePath,
	sampleRate: 44100,
	headerFormat: "wav",
	sampleFormat: "int16",
	options: ServerOptions.new.numOutputBusChannels_(2),
	duration: 10
);
)
::

To use Buffers and Buses, it is recommended to avoid conflicts with real-time server instances by creating a Server object just for the non-realtime process. It is not necessary to boot this server, only to use its allocators. After rendering, you may safely code::remove:: the server instance.

code::
(
var server = Server(\nrt,
	options: ServerOptions.new
	.numOutputBusChannels_(2)
	.numInputBusChannels_(2)
),
def = SynthDef(\buf1, { |out, bufnum, rate = 1, time = 0.1, start = 0, amp = 0.1|
	var eg = EnvGen.kr(Env.perc(0.01, time), doneAction: 2),
	sig = PlayBuf.ar(1, bufnum, rate, startPos: start);
	Out.ar(out, (sig * (eg * amp)).dup);
}),
// the pattern needs a placeholder for the buffer
buf = Buffer.new(server, 0, 1);

def.add;  // the pattern needs the def in the SynthDescLib

x = Pbind(
	\instrument, \buf1,
	\bufnum, buf,
	\rate, Pexprand(0.5, 2, inf),
	\start, Pwhite(0, 50000, inf),
	\time, 0.1,
	\dur, Pexprand(0.05, 0.5, inf),
	\legato, 3,
).asScore(duration: 20, timeOffset: 0.001);

// the score also needs the def and buffer
x.add([0.0, [\d_recv, def.asBytes]]);
x.add([0.0, buf.allocReadMsg(Platform.resourceDir +/+ "sounds/a11wlk01.wav")]);
x.sort;

x.recordNRT(
	outputFilePath: "~/nrt.wav".standardizePath,
	sampleRate: 44100,
	headerFormat: "wav",
	sampleFormat: "int16",
	options: server.options,
	duration: 20
);

server.remove;
)
::

See also link::Classes/Pproto:: for another way to initialize buffers and other resources within a pattern object. Not every type of resource is supported in teletype::Pproto::, but for typical cases, it may be more convenient than the above approach.

subsection:: Analysis using a Non-Realtime server

An NRT server may also be used to extract analytical data from a sound file. The main issues are:

definitionlist::
## Suppressing audio file output
|| In macOS and Linux environments, use teletype::/dev/null:: for the output file path. In Windows, use teletype::NUL::.
## Retrieving analytical data.
|| The easiest way is to allocate a buffer at the beginning of the NRT score, and use BufWr to fill the buffer. At the end of the score, write the buffer into a temporary file. Then you can use SoundFile on the language side to access the data. See the example.
::

code::
// Example: Extract onsets into a buffer.

(
fork {
	var server = Server(\nrt,
		options: ServerOptions.new
		.numOutputBusChannels_(2)
		.numInputBusChannels_(2)
	);
	var resultbuf, resultpath, oscpath, score, dur, sf, cond, size, data;

	// get duration
	sf = SoundFile.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
	dur = sf.duration;
	sf.close;

	resultpath = PathName.tmp +/+ UniqueID.next ++ ".wav";
	oscpath = PathName.tmp +/+ UniqueID.next ++ ".osc";

	score = Score([
		[0, (resultbuf = Buffer.new(server, 1000, 1, 0)).allocMsg],
		[0, [\d_recv, SynthDef(\onsets, {
			var sig = SoundIn.ar(0), // will come from NRT input file
			fft = FFT(LocalBuf(512, 1), sig),
			trig = Onsets.kr(fft),
			// count the triggers: this is the index to save the data into resultbuf
			i = PulseCount.kr(trig),
			// count time in seconds
			timer = Sweep.ar(1);
			// 'i' must be audio-rate for BufWr.ar
			BufWr.ar(timer, resultbuf, K2A.ar(i), loop: 0);
			BufWr.kr(i, resultbuf, DC.kr(0), 0);  // # of points in index 0
		}).asBytes]],
		[0, Synth.basicNew(\onsets, server, 1000).newMsg],
		[dur, resultbuf.writeMsg(resultpath, headerFormat: "wav", sampleFormat: "float")]
	]);

	cond = Condition.new;

	// osc file path, output path, input path - input is soundfile to analyze
	score.recordNRT(oscpath, "/dev/null", sf.path, sampleRate: sf.sampleRate,
		options: ServerOptions.new
			.verbosity_(-1)
			.numInputBusChannels_(sf.numChannels)
			.numOutputBusChannels_(sf.numChannels)
			.sampleRate_(sf.sampleRate),
		action: { cond.unhang }  // this re-awakens the process after NRT is finished
	);
	cond.hang;  // wait for completion

	sf = SoundFile.openRead(resultpath);
	// get the size: one frame at the start
	sf.readData(size = FloatArray.newClear(1));
	size = size[0];
	// now the rest of the data
	sf.readData(data = FloatArray.newClear(size));
	sf.close;

	File.delete(oscpath);
	File.delete(resultpath);
	server.remove;

	data.postln;  // these are your onsets!
};
)
::

section:: OSC file format

If, for some reason, you need to write the OSC command file yourself without using Score, the general method is:

numberedlist::
## Open a file for writing: code::File(path, "w")::.
## For each OSC command:
numberedlist::
## Create the command as an array, and save it in a variable such as teletype::cmd::.
## Convert to binary: code::cmd = cmd.asRawOSC;::
## Write the byte size as an integer: code::file.write(cmd.size);::
## Write the binary command: code::file.write(cmd);::
::
::

code::
f = File(PathName.tmp +/+ "Cmds.osc", "w");

// start a sine oscillator at 0.2 seconds.
c = [0.2, [\s_new, \default, 1001, 0, 0]].asRawOSC;
f.write(c.size); // each bundle is preceded by a 32 bit size.
f.write(c); // write the bundle data.

// stop sine oscillator at 3.0 seconds.
c = [3.0, [\n_free, 1001]].asRawOSC;
f.write(c.size);
f.write(c);

// scsynth stops processing immediately after the last command, so here is
// a do-nothing command to mark the end of the command stream.
c = [3.2, [0]].asRawOSC;
f.write(c.size);
f.write(c);

f.close;

// after rendering, always remember to clean up your mess:
File.delete(PathName.tmp +/+ "Cmds.osc");
::

section:: Bus allocation and synth/LFO mapping

In this example, a control bus and LFO map is used to have various affects on the source sound.

code::
(
var nrtserver = Server(\nrt,
    options: ServerOptions.new
    .numOutputBusChannels_(2)
    .numInputBusChannels_(2)
);

//control bus allocation
var bus = Bus.control(nrtserver, 2);
var lfo, sine;

//LFO
SynthDef.new(\lfo, {|out, freq=100|
	Out.kr(out, LFNoise0.kr(freq).exprange(20.0,1000))
}).load;

lfo = Synth.basicNew(\lfo, server: nrtserver);

SynthDef.new(\NRTsine, {|out=0, freq=440|
	Out.ar(out, SinOsc.ar(freq, 0, 0.2).dup)
}).load;

sine = Synth.basicNew(\NRTsine, server: nrtserver);

a = Score([
	[0.0, lfo.newMsg(args:[\out, bus])],
	[0.0, sine.newMsg],
	[0.0, sine.mapMsg(\freq, bus)],
]);

a.recordNRT(
    outputFilePath: "~/nrtbus-help.wav".standardizePath,
    headerFormat: "wav",
    sampleFormat: "int16",
    options: nrtserver.options,
    duration: 1,
    action: { "done".postln }
);

nrtserver.remove;
)
::

title:: OSC Communication
categories:: External Control>OSC
summary:: OSC network communication
related:: Classes/NetAddr, Classes/OSCFunc

OSC communication between programs is often done to send messages from one application to another, possibly with the applications running on different computers. In SuperCollider this communication is done by creating a link::Classes/NetAddr:: of the target application and creating an link::Classes/OSCFunc:: to listen to another application. The underlying protocol of OSC is either UDP or TCP.

section::Sending OSC to another application

To establish communication to another application, you need to know on which port that application is listening. For example if an application is listening on port 7771, we can create a NetAddr and send it a message:
code::
b = NetAddr.new("127.0.0.1", 7771);	// create the NetAddr
b.sendMsg("/hello", "there");	// send the application the message "hello" with the parameter "there"
::

section::Receiving OSC from another application

To listen to another application, that application needs to send a message to the port SuperCollider is listening on. Normally the default port is 57120, but it could be something different if that port was already bound when SC started. The current default port can be retrieved with
code::
NetAddr.langPort;	// retrieve the current port SC is listening to
::
Or you can retrieve both the IP and the port with:
code::
NetAddr.localAddr	// retrieve the current IP and port
::

You can open additional ports using link::Classes/Main#-openUDPPort::. This will return a link::Classes/Boolean:: indicating whether SC succeeded in opening the new port. Or you can just pass a custom port as the strong::recvPort:: argument to link::Classes/OSCFunc:: and it will open it automatically if not already open.
code::
thisProcess.openUDPPort(1121); // attempt to open 1121
thisProcess.openPorts; // list all open ports
::

To listen to incoming messages, an link::Classes/OSCFunc:: needs to be created in SuperCollider. If the sending application strong::has a fixed port it sends message from::, you can set the OSCFunc to listen only to messages coming from that IP and port:
code::
n = NetAddr.new("127.0.0.1", 7771);	// create the NetAddr
// create the OSCFunc
o = OSCFunc({ arg msg, time, addr, recvPort; [msg, time, addr, recvPort].postln; }, '/goodbye', n);
o.free;	// remove the OSCFunc when you are done.
::
note:: The port 7771 above is the port the other application is sending strong::from::, not the port SC is receiving on. See the strong::recvPort:: argument in link::Classes/OSCFunc#*new:: if you want to receive on another port than NetAddr.langPort. ::

section::Receiving from an application that is sending from a variable port

Some applications (notably Pd and Max) do not send messages from a fixed port, but instead use a different port each time they send out a message, or each time a patch starts up it picks a random port. In that case the OSCFunc needs to be set up, so that it listens to messages coming from anywhere. You do this by passing nil as the srcID argument.
code::
o = OSCFunc({ arg msg, time, addr, recvPort; [msg, time, addr, recvPort].postln; }, '/goodbye'); // create the OSCFunc
o.free;	// remove the OSCFunc when you are done.
::

section::Testing incoming traffic

OSCFunc has a convenience method, link::Classes/OSCFunc#*trace:: which posts all incoming OSC messages:
code::
OSCFunc.trace(true); // Turn posting on
OSCFunc.trace(false); // Turn posting off
::

section::Custom OSC message processing

All incoming OSC messages call the message recvOSCmessage in link::Classes/Main::. If needed, one can add a custom link::Classes/Function:: or other object to Main's recvOSCFunc variable. Although one can do this directly using the corresponding setter, it is better to use the link::Classes/Main#-addOSCRecvFunc:: and link::Classes/Main#-removeOSCRecvFunc:: to avoid overwriting any other functions that may have been added by class code.
code::
// this example is basically like OSCFunc.trace but filters out
// /status.reply messages
(
f = { |msg, time, addr|
    if(msg[0] != '/status.reply') {
        "time: % sender: %\nmessage: %\n".postf(time, addr, msg);
    }
};
thisProcess.addOSCRecvFunc(f);
);

// stop posting.
thisProcess.removeOSCRecvFunc(f);
::

section::OSC type tags and sclang

Inbound OSC messages must have type tags, or an error will be thrown.

The following conversions are supported outbound:

list::
## Integers become "i". Both OSC and sclang use 32-bit signed integers.
## Booleans become "i", with true translating to 1 and false translating to 0.
## Nil becomes "i", translating to value 0.
## Floats become "f" (32-bit float). sclang's Floats are 64-bit, so the conversion to OSC is lossy.
## Strings and Symbols become "s" (string).
## Int8Arrays become "b" (blob).
## Chars are added as a raw type tag, appending no data to the OSC packet. This is needed to send code::$N:: (nil), code::$T:: (true), code::$F:: (false), code::$I:: (infinity/impulse). Be careful with this -- if the destination entity doesn't agree that the tag consumes zero bytes, the remaining part of the OSC message may be corrupted!
::

If code::NetAddr.useDoubles:: is set to true, then in outbound messages, sclang will use the "d" (double) type tag instead of "f". OSC doubles are 64-bit. It is up to you to ensure that the receiver understands "d".

The following type tags are supported inbound:

list::
## "i" (32-bit signed integer) becomes Integer
## "f" (32-bit float) becomes Float
## "s" (string) becomes Symbol
## "b" (blob) and "m" (4-byte MIDI message) becomes Int8Array
## "d" (64-bit float) becomes Float
## "T" (true) and "F" (false) become Booleans
## "I" (infinity/impulse) becomes code::+inf::
## "N" (nil) becomes code::nil::
## "t" (64-bit big-endian fixed-point time tag) becomes Float
## "c" (character) becomes Char
::

"r" (RGBA color), "S" (symbol), and "[" and "]" (array start and end) are not supported.

If an unrecognized tag is encountered, sclang will make that unrecognized tag into a Char object and add that to the OSC message. It will then skip ahead in the OSC message as if it were reading a string -- it looks for the next null byte and then skips 0-3 bytes for 4-byte alignment.


title:: Order of execution
summary:: Understanding order of execution of synths on the server
categories:: Server>Nodes
related:: Classes/Server, Classes/Node, Classes/Group, Classes/ParGroup, Reference/default_group, Classes/Bus, Classes/Out, Classes/ReplaceOut, Classes/XOut, Classes/OffsetOut, Classes/In, Classes/InFeedback, Classes/LocalIn, Classes/LocalOut, Classes/SharedIn, Classes/SharedOut

Order of execution is one of the most critical and seemingly difficult aspects of using SuperCollider, but in reality it only takes a little thought in the early planning stages to make it work for you.

section:: Introduction

Order of execution in this context doesn't mean the order in which statements are executed in the language (the client). It refers to the ordering of synth nodes on the server, which corresponds to the order in which their output is calculated each control cycle (blockSize).
Whether or not you specify the order of execution, each synth and each group goes into a specific place in the chain of execution.

If you have on the server:
code::
    synth 1 ---> synth 2
::
... all the unit generators associated with synth 1 will execute before those in synth 2 during each control cycle.

If you don't have any synths that use In.ar, you don't have to worry about order of execution. It only matters when one synth is reading the output of another.

The rule is simple: if you have a synth on the server (i.e. an "effect") that depends on the output from another synth (the "source"), the effect must appear later in the chain of nodes on the server than the source.
code::
    source ---> effect
::
If you have:
code::
    effect ---> source
::
The effect synth will not hear the source synth, and you won't get the results you want.

image::server.png#A diagram of a typical server configuration::

On the server external signals can be received by synths from "public" input busses (one in the represented case), while the different synths must be connected to "public" out audio busses (two in the case) in order to output a signal externally to the soundcard (see Bus). Other busses (both control and audio) are internal.
In general, busses can be thought as roughly analogous to sends, busses, or submixes on an analog mixer, or as pipes allowing one to route "flowing" signals. If a synth is connected to a bus at a certain point (thus "flowing" into it)  a synth taking the signal from the same bus at a subsequent point will take as input the flowing signal (along with anything else previously output to the bus), just as would occur with a water pipe.

section:: Some Notes about Servers and Targets

There is always a default Server, which can be accessed or set through the class method Server.default. At startup this is set to be the local Server, and is also assigned to the interpreter variable s.
code::
// execute the following and watch the post window
s === Server.default;
s === Server.local;
Server.default = Server.internal; s === Server.default;
Server.default = Server.local; // return it to the local server
::
When a link::Classes/Server:: is booted there is a top level group with an ID of 0 that defines the root of the node tree. This is represented by a subclass of Group: link::Classes/RootNode::.
There is also a link::Reference/default_group:: with an ID of 1. This group is the default group for all Nodes. This is what you will get if you supply a Server as a target. If you don't specify a target or pass in nil, you will get the default group of the default Server.

The default group serves an important purpose: It provides a predictable basic Node tree so that methods such as Server:scope and Server:record can function without running into order of execution problems.
Thus in general one should create new Nodes within the default group rather than in the RootNode. See link::Reference/default_group:: and link::Classes/RootNode:: for more detail.

section:: Controlling order of execution

There are three ways to control the order of execution: using addAction in your synth creation messages, moving nodes, and placing your synths in groups. Using groups is optional, but they are the most effective in helping you organize the order of execution.

subsection:: Add actions

By specifying an addAction argument for code::Synth.new:: (or SynthDef.play, Function.play, etc.) one can specify the node's placement relative to a target. The target might be a group node, another synth node, or a server.

As noted above, the default target is the default_group (the group with nodeID 1) of the default Server.

The following Symbols are valid addActions for Synth.new: code::\addToHead, \addToTail, \addBefore, \addAfter, \addReplace::.
definitionlist::
## code:: Synth.new(defName, args, target, addAction) :: || list::
## if target is a Synth the  \addToHead, and \addToTail methods will apply to that Synths group
## if target is a Server it will resolve to that Server's default group
## if target is nil it will resolve to the default group of the default Server
::
::

For each addAction there is also a corresponding convenience method of class Synth:

definitionlist::
## code:: Synth.head(aGroup, defName, args) :: || add the new synth to the head of the group specified by aGroup
list::
## if aGroup is a synth node, the new synth will be added to the head of that node's group
## if target is a Server it will resolve to that Server's default group
## if target is nil it will resolve to the default group of the default Server
::

## code:: Synth.tail(aGroup, defName, args) :: || add the new synth to the tail of the group specified by aGroup
list::
## if aGroup is a synth node, the new synth will be added to the tail of that node's group
## if target is a Server it will resolve to that Server's default group
## if target is nil it will resolve to the default group of the default Server
::

## code:: Synth.before(aNode, defName, args) :: || add the new node just before the node specified by aNode.

## code:: Synth.after(aNode, defName, args) :: || add the new node just after the node specified by aNode.
## code:: Synth.replace(synthToReplace, defName, args) :: || the new node replaces the node specified by synthToReplace. The target node is freed.
::

Using Synth.new without an addAction will result in the default addAction. (You can check the default values for the arguments of any method by looking at a class' source code. See Internal-Snooping for more details.)
Where order of execution matters, it is important that you specify an addAction, or use one of the convenience methods shown above.


subsection:: Moving nodes
code::
    .moveBefore
    .moveAfter
    .moveToHead
    .moveToTail
::
If you need to change the order of execution after synths and groups have been created, you can do this using move messages.
code::
    ~fx = Synth.tail(s, "fx");
    ~src = Synth.tail(s, "src");  // effect will not be heard b/c it's earlier
    ~src.moveBefore(~fx);   // place the source before the effect
::

subsection:: Groups

Groups can be moved in the same way as synths. When you move a group, all the synths in that group move with it. This is why groups are such an important tool for managing order of execution. (See the Group helpfile for details on this and other convenient aspects of Groups.)
code::
    Group 1 ---> Group 2
::
In the above configuration, all of the synths in group 1 will execute before all of the synths in group 2. This is an easy, easy way to make the order of execution happen the way you want it to.

Determine your architecture, then make groups to support the architecture.


subsection:: Parallel Groups

In some cases, server nodes do not depend on each other. On multiprocessor systems, these nodes could be evaluated on different CPUs.
This can be achieved by adding those nodes to a parallel group (see link::Classes/ParGroup::). Parallel Groups can be considered as
Groups, whose contained nodes are not guaranteed to have a specific order of execution.

note::
SuperCollider's default server strong::scsynth:: is not able to distribute the synths to different threads. However the alternative
server strong::supernova:: is able to distribute the contents of parallel groups to different CPUs.
::


subsection:: Using order of execution to your advantage

Before you start coding, plan out what you want and decide where the synths need to go.

A common configuration is to have a routine playing nodes, all of which need to be processed by a single effect. Plus, you want this effect to be separate from other things running at the same time.
To be sure, you should place the synth -> effect chain on a private audio bus, then transfer it to the main output.
code::
	[Lots of synths] ----> effect ----> transfer
::
This is a perfect place to use a group:
code::
	Group ( [lots of synths] ) ----> effect ----> transfer
::
To make the structure clearer in the code, one can also make a group for the effect (even if there's only one synth in it):
code::
	Group ( [lots of synths] ) ----> Group ( [effect] ) ----> transfer
::
I'm going to throw a further wrench into the example by modulating a parameter (note length) using a control rate synth.

So, at the beginning of your program:
code::
s.boot;

(
l = Bus.control(s, 1);  // get a bus for the LFO--not relevant to order-of-exec
b = Bus.audio(s, 2);	// assuming stereo--this is to keep the src->fx chain separate from
				// other similar chains
~synthgroup = Group.tail(s);
~fxgroup = Group.tail(s);

// now you have synthgroup --> fxgroup within the default group of s

// make some synthdefs to play with
SynthDef("order-of-ex-dist", { arg bus, preGain, postGain;
	var sig;
	sig = In.ar(bus, 2);
	sig = (sig * preGain).distort;
	ReplaceOut.ar(bus, sig * postGain);
}).add;

SynthDef("order-of-ex-pulse", { arg freq, bus, ffreq, pan, lfobus;
	var sig, noteLen;
	noteLen = In.kr(lfobus, 1);
	sig = RLPF.ar(Pulse.ar(freq, 0.2, 0.5), ffreq, 0.3);
	Out.ar(bus, Pan2.ar(sig, pan)
		* EnvGen.kr(Env.perc(0.1, 1), timeScale: noteLen, doneAction: Done.freeSelf));
}).add;

SynthDef("LFNoise1", { arg freq, mul, add, bus;
	Out.kr(bus, LFNoise1.kr(freq, mul:mul, add:add));
}).add;
)

// Place LFO:

~lfo = Synth.head(s, "LFNoise1", [\freq, 0.3, \mul, 0.68, \add, 0.7, \bus, l]);

// Then place your effect:

~dist = Synth.tail(~fxgroup, "order-of-ex-dist", [\bus, b, \preGain, 8, \postGain, 0.6]);

// transfer the results to main out, with level scaling
// play at tail of s's default group (note that Function-play also takes addActions!

~xfer = { Out.ar(0, 0.25 * In.ar(b, 2)) }.play(s, addAction: \addToTail);

// And start your routine:

(
r = Routine({
	{
		Synth.tail(~synthgroup, "order-of-ex-pulse",
			[\freq, rrand(200, 800), \ffreq, rrand(1000, 15000), \pan, 1.0.rand2,
			\bus, b, \lfobus, l]);
		0.07.wait;
	}.loop;
}).play(SystemClock);
)

~dist.run(false);	// proves that the distortion effect is doing something
~dist.run(true);

// to clean up:
(
r.stop;
[~synthgroup, ~fxgroup, b, l, ~lfo, ~xfer].do({ arg x; x.free });
currentEnvironment.clear; // clear all environment variables
)
::
Note that in the routine, using a Group for the source synths allows their order to easily be specified relative to each other (they are added with the .tail method), without worrying about their order relative to the effect synth.

Note that this arrangement prevents errors in order of execution, through the use of a small amount of organizational code. Although straightforward here, this arrangement could easily be scaled to a larger project.


subsection:: Messaging Style

The above examples are in 'object style'. Should you prefer to work in 'messaging style' there are corresponding messages to all of the methods shown above. See NodeMessaging, and Server-Command-Reference for more details.


section:: Feedback

When the various output ugens (Out, OffsetOut, XOut) write data to a bus, they mix it with any data from the current cycle, but overwrite any data from the previous cycle. (ReplaceOut overwrites all data regardless.)
Thus depending on node order, the data on a given bus may be from the current cycle or be one cycle old. In the case of input ugens (see In and InFeedback) In.ar checks the timestamp of any data it reads in and zeros any data from the previous cycle (for use within that synth; the data remains on the bus).
This is fine for audio data, as it avoids feedback, but for control data it is useful to be able to read data from any place in the node order. For this reason In.kr also reads data that is older than the current cycle.

In some cases we might also want to read audio from a node later in the current node order. This is the purpose of InFeedback. The delay introduced by this is at maximum one block size, which equals about 0.0014 sec at the default block size and sample rate.

The variably mixing and overwriting behaviour of the output ugens can make order of execution crucial when using In.kr or InFeedback.ar. (No pun intended.) For example with a node order like the following the InFeedback ugen in Synth 2 will only receive data from Synth 1 (-> = write out; <- = read in):
numberedlist::
## Synth 1 -> busA (this synth overwrites the output of Synth3 before it reaches Synth 2)
## Synth 2 (with InFeedback) <- busA
## Synth 3 -> busA
::
If Synth 1 were moved after Synth 2 then Synth 2's InFeedback would receive a mix of the output from Synth 1 and Synth 3. This would also be true if Synth 2 came after Synth1 and Synth 3.
In both cases data from Synth 1 and Synth 3 would have the same time stamp (either current or from the previous cycle), so nothing would be overwritten.

(As well, if any In.ar wrote to busA earlier in the node order than Synth 2, it would zero the bus before Synth 3's data reached Synth 2. This is true even it there were no node before Synth 2 writing to busA.)

Because of this it is often useful to allocate a separate bus for feedback. With the following arrangement Synth 2 will receive data from Synth3 regardless of Synth 1's position in the node order.
numberedlist::
## Synth 1 -> busA
## Synth 2 (with InFeedback) <- busB
## Synth 3 -> busB + busA
::
The following example demonstrates this issue with In.kr:
code::
(
SynthDef("help-Infreq", { arg bus;
	Out.ar(0, FSinOsc.ar(In.kr(bus), 0, 0.5));
}).add;

SynthDef("help-Outfreq", { arg freq = 400, bus;
	Out.kr(bus, SinOsc.kr(1, 0, freq/40, freq));
}).add;

b = Bus.control(s,1);
)

// add the first control Synth at the tail of the default server; no audio yet
x = Synth.tail(s, "help-Outfreq", [\bus, b]);

// add the sound producing Synth BEFORE it; It receives x's data from the previous cycle
y = Synth.before(x, "help-Infreq", [\bus, b]);

// add another control Synth before y, at the head of the server
// It now overwrites x's cycle old data before y receives it
z = Synth.head(s, "help-Outfreq", [\bus, b, \freq, 800]);

// get another bus
c = Bus.control(s, 1);

// now y receives x's data even though z is still there
y.set(\bus, c); x.set(\bus, c);

x.free; y.free; z.free;
::



title:: Polymorphism
summary:: the ability of different classes to respond to a message in different ways
categories:: Language>OOP
related:: Reference/Messages, Reference/Classes, Guides/Intro-to-Objects

section:: Introduction

Polymorphism is the ability of different classes to respond to a message in different ways. A message generally has some underlying meaning and it is the responsibility of each class to respond in a way appropriate to that meaning.

For example, the code::value:: message means "give me the effective value of this object".

The value method is implemented by these classes (among others):
definitionlist::
## Function : || this.value(args)
## Object : || this.value()
## Ref : || this.value
::

Let's look at how these classes implement the value message.

subsection:: Object

Here's the value method in class link::Classes/Object:: :
code::
value { ^this }
::
It simply returns itself. Since all classes inherit from class Object this means that unless a class overrides code::value::, the object will respond to code::value:: by returning itself.
code::
5.postln;			// posts itself
5.value.postln;		// value returns itself
'a symbol'.postln;
'a symbol'.value.postln;
[1,2,3].value.postln;
//etc...
::

subsection:: Function
In class link::Classes/Function:: the value method is a primitive:
code::
value { arg ... args;
    _FunctionValue
    // evaluate a function with args
    ^this.primitiveFailed
}
::

code::_FunctionValue:: is a C code primitive, so it is not possible to know just by looking at it what it does. However what it does is to evaluate the function and return the result.
code::
{ 5.squared }.postln;			// posts Instance of Function
{ 5.squared }.value.postln;		// posts 25
::

subsection:: Ref
The link::Classes/Ref:: class provides a way to create an indirect reference to an object. It can be used to pass a value by reference. Ref objects have a single instance variable called code::value::.
The code::value:: method returns the value of the instance variable code::value::. Here is a part of the class definition for Ref:
code::
Ref : AbstractFunction
{
    var <>value;

	*new { arg thing; ^super.new.value_(thing) }
    set { arg thing; value = thing }
    get { ^value }
    dereference { ^value }
    asRef { ^this }

    // behave like a stream
    next { ^value }

    printOn { arg stream;
        stream << "`(" << value << ")";
    }
    storeOn { arg stream;
        stream << "`(" <<< value << ")";
    }
}
::
Here is how it responds :
code::
Ref.new(123).postln;
Ref.new(123).value.postln;
::

Ref also implements a message called code::dereference:: which is another good example of polymorphism. As implemented in Ref, dereference just returns the value instance variable which is no different than what the value method does.
So what is the need for it? That is explained by how other classes respond to dereference. The dereference message means "remove any Ref that contains you".
In class Object dereference returns the object itself, again just like the value message. The difference is that no other classes override this method. So that dereference of a Function is still the Function.
definitionlist::
## Object : || this.dereference()
## Ref : || this.dereference()
::
code::
5.value.postln;
{ 5.squared }.value.postln;
Ref.new(123).value.postln;

5.dereference.postln;
{ 5.squared }.dereference.postln;
Ref.new(123).dereference.postln;
::

section:: Play
Yet another example of polymorphism is play. Many different kinds of objects know how to play themselves.

subsection:: Function
code::
{ PinkNoise.ar(0.1) }.play;
::

subsection:: AppClock
code::
(
var w, r;
w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;
r = Routine({ arg appClockTime;
    ["AppClock has been playing for secs:",appClockTime].postln;
    60.do({ arg i;
        0.05.yield;
        w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
        w.alpha = cos(i*0.1pi)*0.5+0.5;
    });
    1.yield;
    w.close;
});
AppClock.play(r);
)
::

subsection:: SynthDef
code::
(
x = SynthDef("Help-SynthDef", { arg out=0;
    Out.ar(out, PinkNoise.ar(0.1))
}).play;
)
::

subsection:: Pattern
code::
Pbind(\degree, Pseq([0, 1, 2, 3],inf)).play;
::

section:: Conclusion
Polymorphism allows you to write code that does not assume anything about the implementation of an object, but rather asks the object to "do what I mean" and have the object respond appropriately.



title:: Randomness
categories:: Random
summary:: Randomness in SC
related:: Reference/randomSeed

As in any computer program, there are no "truly random" number generators in SC.
They are pseudo-random, meaning they use very complex, but deterministic
algorithms to generate sequences of numbers that are long enough and complicated enough
to seem "random" for human beings. (i.e. the patterns are too complex for us to detect.)

If you start a random number generator algorithm with the same "seed" number
several times, you get the same sequence of random numbers.
(See example below, randomSeed)

section:: Create single random numbers

subsection:: Between zero and <number>
code::
5.rand          // evenly distributed.

1.0.linrand     // probability decreases linearly from 0 to <number>.
::

subsection:: Between -<number> and <number>
code::
5.0.rand2       // evenly distributed.

10.bilinrand    // probability is highest around 0,
                // decreases linearly toward +-<number>.

1.0.sum3rand    // quasi-gaussian, bell-shaped distribution.
::

subsection:: Within a given range
code::
rrand(24, 48)       // linear distribution in the given range.

exprand(0.01, 1)    // exponential distribution;
                    // both numbers must have the same sign.
                    // (Note that the distribution of numbers is not exactly an exponential distribution,
                    // since that would be unbounded: we might call it a logarithmic uniform distribution.)
::

subsection:: Test them multiple times with a do loop
code::
20.do({ 5.rand.postln; });			// evenly distributed

20.do({ 1.0.linrand.postln; });		// probability decreases linearly from 0 to 1.0

20.do({ 5.0.rand2.postln; });		// even

20.do({ 10.bilinrand.postln; });		// probability is highest around 0,
							// decreases linearly toward +-<number>.

20.do({ 1.0.sum3rand.postln; });	// quasi-gaussian, bell-shaped.
::

subsection:: Collect the results in an array
code::
Array.fill(10, { 1000.linrand }).postln;

// or more compact:

{ 1.0.sum3rand }.dup(100)

// or:

({ 1.0.sum3rand } ! 100)
::

subsection:: Seeding
You can seed a random generator in order to repeat
the same sequence of random numbers:
code::
(
5.do({
	thisThread.randSeed = 4;
	Array.fill(10, { 1000.linrand}).postln;
});
)

// Just to check, no seeding:

(
5.do({ Array.fill(10, { 1000.linrand }).postln; });
)
::
See also link::Reference/randomSeed::.


subsection:: Histograms
Demonstrate the various statistical distributions visually, with histograms:

code::
Array.fill(500, {  1.0.rand }).plot("Sequence of 500x 1.0.rand");

Array.fill(500, {  1.0.linrand }).plot("Sequence of 500x 1.0.linrand");

Array.fill(500, {  1.0.sum3rand }).plot("Sequence of 500x 1.0.sum3rand");
::

Use a histogram to display how often each (integer)
occurs in a collection of random numbers, :
code::
(
var randomNumbers, histogram, maxValue = 500, numVals = 10000, numBins = 500;

randomNumbers = Array.fill(numVals, { maxValue.rand; });
histogram = randomNumbers.histo(numBins, 0, maxValue);
histogram.plot("histogram for rand 0 - " ++ maxValue);
)
::

A histogram for linrand:
code::
(
var randomNumbers, histogram, maxValue = 500.0, numVals = 10000, numBins = 500;

randomNumbers = Array.fill(numVals, { maxValue.linrand; });
histogram = randomNumbers.histo(numBins, 0, maxValue);
histogram.plot("histogram for linrand 0 - " ++ maxValue);
)
::
A histogram for bilinrand:
code::
(
var randomNumbers, histogram, minValue = -250, maxValue = 250, numVals = 10000, numBins = 500;

randomNumbers = Array.fill(numVals, { maxValue.bilinrand; });
histogram = randomNumbers.histo(numBins, minValue, maxValue);
histogram.plot("histogram for bilinrand" + minValue + "to" + maxValue);
)
::

A histogram for exprand:
code::
(
var randomNumbers, histogram, minValue = 5.0, maxValue = 500, numVals = 10000, numBins = 500;

randomNumbers = Array.fill(numVals, { exprand(minValue, maxValue); });
histogram = randomNumbers.histo(numBins, minValue, maxValue);
histogram.plot("histogram for exprand: " ++ minValue ++ " to " ++ maxValue);
)
::

And for sum3rand (cheap quasi-gaussian):
code::
(
var randomNumbers, histogram, minValue = -250, maxValue = 250, numVals = 10000, numBins = 500;

randomNumbers = Array.fill(numVals, { maxValue.sum3rand; });
histogram = randomNumbers.histo(numBins, minValue, maxValue);
histogram.plot("histogram for sum3rand " ++ minValue ++ " to " ++ maxValue);
)
::


subsection:: on Collections
All of the single-number methods also work for (Sequenceable)Collections,
simply by applying the given random message to each element of the collection:
code::
[ 1.0, 10, 100.0, \aSymbol ].rand.postln;		// note: Symbols are left as they are.
List[ 10, -3.0, \aSymbol ].sum3rand.postln;
::

subsection:: Arbitrary random distributions

An integral table can be used to create an arbitrary random distribution quite efficiently. The table
building is expensive though. The more points there are in the random table, the more accurate the
distribution.
code::
(
var randomNumbers, histogram, distribution, randomTable, randTableSize=200;
var minValue = -250, maxValue = 250, numVals = 10000, numBins = 500;

// create some random distribution with values between 0 and 1
distribution = Array.fill(randTableSize,
	{ arg i; (i/ randTableSize * 35).sin.max(0) * (i / randTableSize) }
);

// render a randomTable
randomTable = distribution.asRandomTable;

// get random numbers, scale them

randomNumbers = Array.fill(numVals, { randomTable.tableRand * (maxValue - minValue) + minValue; });
histogram = randomNumbers.histo(numBins, minValue, maxValue);


histogram.plot("this is the histogram we got");
distribution.plot("this was the histogram we wanted");
)
::

section:: Random decisions

code:: coin :: simulates a coin toss and results in true or false.
1.0 is always true, 0.0 is always false, 0.5 is 50:50 chance.
code::
20.do({ 0.5.coin.postln });
::
biased random decision can be simulated bygenerating a single value
and check against a threshhold:
code::
20.do({ (1.0.linrand > 0.5).postln });
20.do({ (exprand(0.05, 1.0) > 0.5).postln });
::

section:: Generating Collections of random numbers
code::
		// size, minVal, maxVal
Array.rand(7, 0.0, 1.0).postln;

// is short for:

Array.fill(7, { rrand(0.0, 1.0) }).postln;
::
code::
		// size, minVal, maxVal
List.linrand(7, 10.0, 15.0).postln;

// is short for:

List.fill(7, { 10 + 5.0.linrand }).postln;
::

code::
Signal.exprand(10, 0.1, 1);

Signal.rand2(10, 1.0);
::

section:: Random choice from Collections

code::choose:: : equal chance for each element.
code::
10.do({ [ 1, 2, 3 ].choose.postln });
::

Weighted choice:

code::wchoose(weights):: : An array of weights sets the chance for each element.
code::
10.do({ [ 1, 2, 3 ].wchoose([0.1, 0.2, 0.7]).postln });
::

section:: Randomize the order of a Collection

code::
List[ 1, 2, 3, 4, 5 ].scramble.postln;
::

section:: Generate random numbers without duplicates
code::
f = { |n=8, min=0, max=7| (min..max).scramble.keep(n) };
f.value(8, 0, 7)
::

section:: Randomly group a Collection
code::
curdle(probability)
::
The probability argument sets the chance that two adjacent elements will be separated.
code::
[ 1, 2, 3, 4, 5, 6, 7, 8 ].curdle(0.2).postln;	// big groups

[ 1, 2, 3, 4, 5, 6, 7, 8 ].curdle(0.75).postln;	// small groups
::

section:: Random signal generators, i.e. UGens
list::
## link::Classes/PinkNoise::
## link::Classes/WhiteNoise::
## link::Classes/GrayNoise::
## link::Classes/BrownNoise::
## link::Classes/ClipNoise::
## link::Classes/LFNoise0::
## link::Classes/LFNoise1::
## link::Classes/LFNoise2::
## link::Classes/LFClipNoise::
## link::Classes/LFDNoise0::
## link::Classes/LFDNoise1::
## link::Classes/LFDNoise3::
## link::Classes/LFDClipNoise::
## link::Classes/Dust::
## link::Classes/Dust2::
## link::Classes/Crackle::
## link::Classes/TWChoose::
::

Also see UGens>Generators>Stochastic in the link::Browse#UGens>Generators>Stochastic:: page.

subsection:: Random operators on signals

Unary or binary random method produce a random value for each frame (not implemented in some cases). This can be used to implement tendency masks.

code::
{ rrand(SinOsc.ar(0.1), SinOsc.ar(0.42)) * 0.1 }.play
{ linrand(SinOsc.ar(0.1)) * 0.1 }.play
{ bilinrand(SinOsc.ar(0.1)) * 0.1 }.play
{ sum3rand(SinOsc.ar(0.1)) * 0.1 }.play
{ coin(SinOsc.ar(0.1)) * 0.1 }.play
{ exprand(SinOsc.ar(0.1).range(0.1, 1), 0.1) - 1 * 0.1 }.play // exprand must not touch zero
::



subsection:: UGens that generate random numbers once, or on trigger:

definitionlist::
## link::Classes/Rand:: || uniform distribution of float between (lo, hi), as for numbers.
## link::Classes/IRand:: || uniform distribution of integer numbers.
## link::Classes/TRand:: || uniform distribution of float numbers, triggered
## link::Classes/TIRand:: || uniform distribution of integer numbers, triggered
## link::Classes/LinRand:: || skewed distribution of float numbers, triggered
## link::Classes/NRand:: || sum of n uniform distributions, approximates gaussian distr. with higher n.
## link::Classes/ExpRand:: || exponential distribution
## link::Classes/TExpRand:: || exponential distribution, triggered
## link::Classes/CoinGate:: || statistical gate for a trigger
## link::Classes/TWindex:: || triggered weighted choice between a list.
::

subsection:: Seeding
Like using randSeed to set the random generatorsfor each thread in sclang,
you can choose which of several random generators on the server to use,
and you can reset (seed) these random generators:
list::
## link::Classes/RandID::
## link::Classes/RandSeed::
::

subsection:: UGens that generate random numbers on demand
("Demand UGens")
list::
## link::Classes/Dwhite::
## link::Classes/Dbrown::
## link::Classes/Diwhite::
## link::Classes/Dibrown::
## link::Classes/Drand::
## link::Classes/Dxrand::
::

see random patterns with analogous names

section:: Random Patterns
definitionlist::
## link::Classes/Prand:: || choose randomly one from a list ( list, numRepeats)
## link::Classes/Pxrand:: || choose one element from a list, no repeat of previous choice
## link::Classes/Pwhite:: || within range [<hi>, <lo>], choose a random value.
## link::Classes/Pbrown:: || within range [<hi>, <lo>], do a random walk with a maximum <step> to the next value.
## link::Classes/Pgbrown:: || geometric brownian motion

## link::Classes/Plprand::
## link::Classes/Phprand::
## link::Classes/Pmeanrand::
## link::Classes/Pbeta::
## link::Classes/Pcauchy::
## link::Classes/Pgauss::
## link::Classes/Ppoisson::
## link::Classes/Pexprand::

## link::Classes/Pwrand:: || choose from a list, probabilities by weights
code::
Pwrand([ 1, 2, 3 ], [0.1, 0.3, 0.6], 20);
::

## link::Classes/Pshuf:: || scramble the list, then repeat that order <repeats> times.

## link::Classes/Pwalk:: || code::Pwalk( (0 .. 10), Prand([ -2,-1, 1, 2], inf));:: random walk.

## link::Classes/Pfsm:: || random finite state machine pattern, see its help file. see also MarkovSet in MathLib quark

## link::Classes/Pseed:: || sets the random seed for that stream.
::

some basic examples
code::
(
Pbind(\note, Prand([ 0, 2, 4 ], inf),
	\dur, 0.2
).play;
)

(
Pbind(
	\note, Pxrand([ 0, 2, 4 ], inf),
	\dur, 0.2
).play;
)

(
Pbind(
	\note, Pwrand([ 0, 2, 4 ], [0.1, 0.3, 0.6], inf),
	\dur, 0.2
).play;
)

(
Pbind(
	\midinote, Pwhite(48, 72, inf),
	\dur, 0.2
).play;
)

(
Pbind(
	\midinote, Pbrown(48, 72, 5, inf),
	\dur, 0.2
).play;
)

(
Pbind(
	\midinote, Pgbrown(48, 72, 0.5, inf).round,
	\dur, 0.2
).play;
)
::



title:: SuperCollider IDE
summary:: A guide to the cross-platform SuperCollider coding environment
categories:: Frontends
keyword:: scide
keyword:: editor


SuperCollider IDE is a new cross-platform coding environment, developed specifically for SuperCollider and introduced in version 3.6.

It is easy to start using, handy to work with, and sprinkled with powerful features for experienced SuperCollider coders. It is also very customizable.

It runs equally well and looks almost the same on macOS, Linux and Windows 7. (Issues with Windows XP remain to be solved.)



Section:: Overview

note:: Throughout this document, strong::Ctrl:: indicates the modifier key for keyboard shortcuts that is used on Linux and Windows platforms. strong::On macOS, use Cmd instead::.::

Here is an annotated screenshot describing various components of the IDE.
Click link::Guides/sc_ide_overview.png##here:: for a natural-size version.

image::sc_ide_overview_scaled.png::



Subsection:: Central components

definitionlist::
## Title Bar || Displays the current session name (see link::#Sessions::), and the filename of the current document.
## Code Editor || The editor takes the central place. Here is where you will spend most of your time, writing code. Read more in the link::#Code editor:: section.
## Document Tabs || Above the editor, there is a series of tabs, one for each open document. Clicking on a tab
will display the related document in the editor. The tabs can be drag-and-dropped to change their order.
## Tool Panel || This is where various tools related to code editing are displayed. The panel is initially hidden, and is only displayed when one of the tools is activated. You can activate each of the available tools via the menu strong::View > Tool Panels::, as well as using keyboard shortcuts. This the list of tools:
  list::
	## Find (Ctrl+F) - Find text in the current document.
	## Replace (Ctrl+R) - Find and replace text in the current document.
	## Go-to-line (Ctrl+L) - Jump to a particular line of the current document by number.
	## Command Line (Ctrl+E) - Write and evaluate single lines of code, as in a terminal.
	::
## Status Bar || Contains status information about the interpreter and the sound server. Also displays any occasional notifications related to the IDE.
::

Subsection:: Docklets

Around the central area described above, there are strong::dock areas:: where various other panels called strong::docklets:: are displayed. They are named so, because they can be moved around to different positions in the dock areas, or even be undocked to float above the main window, and they may also be hidden. You can show or hide each of the available docklets via the menu strong::View > Docklets::.

Here is a list of available docklets:

definitionlist::
## Help Browser || Displays and navigates through help pages.
## Post Window || Displays the response of the interpreter: results of code evaluation and various notifications, warnings, errors, etc...
## Documents List || A list of open documents; when you have a lot of them, this may be more handy than the Document tabs.
::

The docklets may be moved to different areas by strong::drag-and-dropping:: them by their own title bar. There are four dock areas, along each of the edges of the screen: left, right, top and bottom. .

The docklets may be in four different states:

list::
## strong::Docked:: - You can drag-and-drop docklets into each dock area either strong::side by side:: or strong::on top of each other::. In the latter case, small tabs will appear that allow you to switch the visible docklet in a particular area. Some docklets are restricted so they can only be placed into some of the areas.
## strong::Undocked:: - By dropping a docklet outside of any dock area it will stay separate and always on top of the main window. You can also undock it using the menu accessible by clicking in the top-left corner of a docklet.
## strong::Detached:: - Using the menu accessible by clicking in the top-left corner of a docklet, you can detach it. A detached docklet behaves just like a normal window: it may be minimized and maximized, the main window may be raised in front of it, it will appear in the operating system task bar, etc.
## strong::Hidden:: - A docklet may be hidden either using the menu accessible by clicking in the top-left corner of a docklet, closing a detached docklet's window, or using the main window menu View > Docklets. To show a hidden docklet, use the same main window menu.
::

Section:: Getting help

All the help options are accessible via the main menu under Help.

The keyboard shortcut strong::Ctrl+D:: (as in Documentation) is the most handy way to get help. It will navigate the Help Browser to a help page related to the text around the cursor:
list::
## If the cursor is at a class or a method name, its documentation will be displayed.
## If there is no class or method matching the text at the cursor, the help search results will be displayed for the text.
## In any case, the Help Browser will be shown, if it was hidden.
::

The Ctrl+D shortcut works in various places in the IDE: the Editor, the Command Line, the Post Window, or the Help Browser itself. It will always use the text around the cursor or the selected text (if any) to search for help.

If you want to go directly to a specific help page, use the strong::Ctrl+Shift+D:: shortcut which will pop up a box where you can type a name of a class or a method, or any text, and hit Return to get related help.

In the title bar of the Help Browser there are controls to strong::navigate:: to the help home page, or backwards and forwards in history, as well as to strong::reload:: the current page.

Using the strong::Ctrl+F:: shortcut while the Help Browser is focused, you are sent directly to the strong::Find:: field, which you can use to search for text in the current help page.



Section:: Starting up the system

There is no SuperCollider fun without two crucial components:

definitionlist::
## The language interpreter ||
...is what interprets and executes your SuperCollider code. It is strong::started automatically:: when the IDE starts. However, it is actually separate from the IDE, so it can be stopped and restarted at your will using the strong::Language menu::. When the interpreter is running, the box in the Status Bar labelled "Interpreter" will display "Active" in green letters.

## The audio server ||
...is what makes your SuperCollider code sound. Without the audio server running, you can run SuperCollider code, but it will not make any sound. Unlike the interpreter, the audio server is strong::not started automatically::. To start it, use the quick strong::Ctrl+B:: shortcut, or the strong::Language menu::. Note that the language interpreter must already be running in order to start the audio server. When the audio server is running, the box in the Status Bar labelled "Server" will display the status in green numbers.
::

Of course, once the interpreter and the audio server are running, the most fun part of it all is strong::evaluating code::. Use the strong::Ctrl+Return:: shortcut to evaluate the current line, region, or selection. See link::#Evaluating code:: for more information.

When you want to strong::stop the running code::, use the strong::Ctrl+.:: shortcut (Ctrl+Period). See more on this at the end of the link::#Evaluating code:: section.

Most of the time, there is no need for strong::restarting the interpreter::. However, this becomes very useful if you accidentally evaluate code that goes into an infinite loop without a pause, or if the interpreter simply crashes and stops by itself. In that case, use the strong::Language menu:: to restart the interpreter.

When your class library changes, either because you have installed or removed a Quark, or just modified a class file, you will need to strong::recompile the class library:: in order for changes to take effect. You can do that quickly via the strong::Ctrl+Shift+L:: shortcut, or via the Language menu.



Section:: Code editor

Subsection:: Evaluating code

To evaluate code, use one of the following keyboard commands:

definitionlist::

## Ctrl+Return || Most used, "smart" code evaluation:

list::
## Normally, the current line will be evaluated (where the cursor is).
## If the cursor is within a emphasis::region::, the entire region will be evaluated. See below for explanation of regions.
## If some code is selected, the selection will be evaluated.
::

## Shift+Return || Evaluates either the current line, or the selection (if any). Use this to evaluate a single line within a region without the need to select it.

::

strong::Regions:: make it quick and easy to evaluate larger portions of code. A region is surrounded by parentheses; to be interpreted as a region, the parenthesis must each be the only character on a line.

code::
(
Pbind(
	\degree, Pseries(0, 1, 8),
	\dur, 0.25
).play;
)
::

If the cursor is anywhere between the outermost parentheses, pressing Ctrl+Return will automatically evaluate the entire contents within the parentheses, starting with code::Pbind:: and ending with code::play;::.

To quickly evaluate a portion of code, you can also double-click on any bracket (round, squared, or curly), which will select everything between this and the other matching bracket, so you can quickly evaluate it.

To strong::stop:: any running code, use the strong::Ctrl+.:: shortcut (Ctrl+Period). This will stop all the code scheduled on the link::Tutorials/Getting-Started/14-Scheduling-Events##clocks::, as well as all the sound processes on the audio server.

note:: If some code goes into a strong::infinite loop without a pause::, using Ctrl+. will not help to stop it. In this case, you will need to restart the interpreter (see link::#Starting up the system::).
::

Subsection:: Automatic indentation

The editor helps you by automatically indenting lines according to opening and closing brackets as you type. With every new line, the indentation will be increased if there is an opening bracket on the previous line. As you continue to type closing brackets, the indentation will decrease to align with the matching opening brackets.

If the indentation of a portion of code is messed up, you can select it and press strong::Tab:: to automatically indent it according to surrounding brackets. This also works without selection for the current line.

You can manually insert a level of indentation anywhere in code by pressing strong::Shift+Tab::.

The indentation can either use strong::tab characters or spaces::, which you can quickly toggle via the main menu option Edit > Use Spaces for Indentation. More indentation options are available in the IDE preferences dialog.



Subsection:: Automatic completion

As you type, the editor will try to find possible continuations of your code, and pop up a list of suggestions, so you can quickly insert one instead of typing the whole text. This is called emphasis::autocompletion:: and is a great aid towards writing code faster and with less errors.

In general, this works for class and method names. These are the things that the editor can autocomplete:

list::

## strong::Class names::
code::
Sin<...>
::
When you have typed at least 3 letters of a class name, a list of classes beginning with these letters will be shown.

## strong::Method names following class names::
code::
Array.<...>
::
When you type a dot after a class name, a list of methods of that class will be shown.

## strong::Method names following literals and built-ins::
code::
123.<...>
currentEnvironment.<...>
::
When you type a dot after a literal (number, string, symbol, etc.) or a built-in (currentEnvironment, thisProcess, etc.), a list of instance methods of their classes will be shown.

## strong::Method names following a variable name::
code::
value.lin<...>
::
When you type a dot and 3 letters after a variable, a list of all methods of all classes starting with these letters will be shown (because the class of the variable is not known).
::

Once the autocompletion menu pops up, you can use the arrow keys or Page Up and Page Down to select an entry, and press Return to insert it into your code. If you continue typing, the list of options will be further filtered to match the typed text.

Note that the autocompletion menu disappears when the typed text exactly matches one of autocompletion options. This is intended as help: the menu tries to get out of your way when you probably don't need it.

If the autocompletion menu is not shown, you can show it using strong::Ctrl+Space::, as long as there is any autocompletion options available. You can always dismiss the menu by pressing strong::Escape::.

Subsection:: Method call assistance

The editor helps you when writing arguments of a method by showing you a complete list of the method's arguments and their default values, as long as it manages to figure out exactly which method that is. This is called emphasis::method call assistance::. It helps you to know exactly which argument you are typing, and reduces the need to look into documentation.

The assistance is activated as soon as you type an opening parenthesis after a method name, at which point a box containing the arguments will pop up. However, if the class of the method is not known, first a menu of classes that implement the method will be shown, and after you select one of the classes using the arrow keys or the Page Up and Page Down keys, and press Return, the box with arguments will pop up.

So, for example, in the following cases method call assistance will pop up immediately:
code::
SinOsc.ar(
123.forBy(
::
...while in the following cases, you will first need to select a class, because the class is not known:
code::
min(
x.play(
[1,2,3].inject(
::

If method call assistance is not shown, you can activate it using strong::Ctrl+Shift+Space:: with the cursor between parenthesis surrounding the arguments. You can always dismiss it by pressing strong::Escape::.



Section:: Tool panels

All tool panels are listed and may be activated via the main menu strong::View > Tool Panels::. To close the
currently displayed panel, press strong::Escape::.



subsection:: Find and Replace

Shortcuts: Find: strong::Ctrl+F:: / Replace: strong::Ctrl+R::

The strong::Find:: panel is used to find text in the currently open document. As soon as you start typing into the Find field, the entered text is searched for, and the results are highlighted. The first found result is also selected. By pressing Return, you can jump through all the result.

Notice how the Status Bar reports the strong::number of search results::, whenever the search text is changed.

If you invoke the Find shortcut with some text selected in the code editor, the Find field will be filled with the selection.

The strong::Replace:: panel is an extension to the Find panel: it adds another field where you can enter text to replace the search results with. By pressing Return in the Replace field, the current search result will be replaced and the next result will be selected.

Use the strong::Replace All:: button to replace all search results. Notice how the Status Bar reports the strong::number of replacements::.

You can access more strong::search options:: by clicking on the button in the top-right corner of the Find/Replace panel. The options are:

list::
## strong::Match Case:: - make the search case-sensitive.
## strong::Regular Expression:: - treat the search text as a emphasis::regular expression::. More on this below.
## strong::Whole Words:: - only search for whole words; i.e. the characters on the left and the right side of a search result must not be letters or numbers.
::

strong::Regular expressions:: are a powerful way to search for text that matches a pattern, instead of an exact sequence of characters. When this option is enabled, replacement supports strong::backreferences::, i.e. reusing portions of the found pattern in the replacement text.

We will not go here into details about regular expression. To learn more, we would like to refer you to an excellent tutorial online: link::http://www.regular-expressions.info/quickstart.html::



subsection:: Go-To-Line

Shortcut: strong::Ctrl+L::

Using the Go-To-Line tool, you can quickly jump to a line in the current document, by number. Just enter the line number and press Return.



subsection:: Comand Line

Shortcut: strong::Ctrl+E::

Sometimes, you need to evaluate a temporary expression that does not need to be saved into a document. The Command Line offers a one-line text field where you can enter a SuperCollider expression, and press Return to evaluate it.

Use the Up and Down arrow keys to navigate through the strong::history:: of evaluated expressions. Up will move to older expressions, and Down will move back to more recent ones.



Section:: Class library navigation

Often it is very useful to be able to jump directly to a place in a file, where a particular class or method is implemented, or to find all the places where a class or a method name is used. The IDE offers practical ways to achieve that.

subsection:: Look up implementations

The strong::Ctrl+I:: shortcut with the text cursor at a method or a class name will open a dialog with a list of places where that method or class is implemented. By selecting one of the entries and pressing Return, the IDE will open the file and position the text cursor at the location you are looking for.

Note that the Ctrl+I shortcut works in various places in the IDE, wherever there may be code: the Editor, the Command Line, the Post Window, or the Help Browser. It will always use the text around the cursor or the selected text (if any) to look for a method or a class with a matching name.

The list in the dialog is formed as follows:
list::
## If you are looking up a class name, the class and all its methods including those of its superclasses will be listed.
## If you are looking up a method name, all the methods of all classes with that name will be listed.
## If there is no class or method that matches the name exactly, partial matches will be displayed
::

You can use the text field at the top of the dialog to search for a method or a class directly. Just type in some text and press Return.

The strong::Ctrl+Shift+I:: shortcut will open the dialog empty, regardless of position of the text cursor.

subsection:: Look up references

The strong::Ctrl+U:: shortcut will open a dialog similar to the one described above, except that it will list places where a method or a class with a particular name is emphasis::used::. Note that this only searches class files in the class library, not regular code files.

Just as the Ctrl+I shortcut described above, Ctrl+U will work at any place in the IDE where there may be code.

The strong::Ctrl+Shift+U:: shortcut will open the dialog empty, regardless of position of the text cursor.



Section:: Sessions

Sessions preserve the state of the IDE at the time of quitting, so next time you use it you can resume with the same arrangement of open documents and link::#Docklets#docklets:: automatically.

To strong::save:: the current state as a new session, use the "Session > Save Session As..." menu action. You will be prompted to enter a name for the new session.

To strong::open:: a saved session, use the "Session > Open Session..." menu, which contains all the saved sessions.

To start a strong::new:: unsaved session, use the "Session > New Session" menu action.

You can quickly strong::switch:: the active session via a pop-up list of all sessions using the Ctrl+Shift+Q shortcut.

More options, including strong::removing:: a saved session, are available in a session management dialog accessible via "Session > Manage Sessions..." menu action.

By default, the IDE starts with the strong::last session:: used before closing, but you can change this behavior in the IDE configuration dialog.



Section:: Various handy shortcuts

definitionlist::
## Focus Post Window: Ctrl+P ||  Gives focus to the Post Window. Then you can use arrow keys and Page Up / Page Down to scroll through output from the interpreter. Press Tab to return to the Code Editor.
## Clear Post Window: Ctrl+Shift+P || Clears the Post Window contents.
## Enlarge/Shrink Font: Ctrl++ / Ctrl+- || Enlarges or shrinks font in Code Editor, Post Window, or Help Browser.
::

Section:: Customization

Many customization options are available in the IDE configuration dialog, accessible via "Edit > Preferences" menu action.

The options include: fonts, code colors, keyboard shortcuts,...

(More to write later)


title:: Server Guide
summary:: Using Server objects in different situations
categories:: Server>Abstractions
related:: Classes/Server, Classes/ServerOptions, Reference/Server-Architecture, Reference/Server-Command-Reference, Guides/MultiClient_Setups

description::

A Server object is the client-side representation of a server app and is used to control the app from the SuperCollider language application. (See link::Guides/ClientVsServer:: for more details on the distinction.)
It forwards OSC messages and has a number of allocators that keep track of IDs for nodes, buses and buffers.

The server application is a commandline program, so all commands apart from OSC messages are UNIX commands.

The server application represented by a Server object might be running on the same machine as the client (in the same address space as the language application or separately; see below), or it may be running on a remote machine.

Most of a Server's options are contolled through its instance of ServerOptions. See the link::Classes/ServerOptions:: helpfile for more detail.

subsection:: Paths

Server apps running on the local machine have two UNIX environment variables: code::SC_SYNTHDEF_PATH:: and code::SC_PLUGIN_PATH::. These indicate directories of synthdefs and ugen plugins that will be loaded at startup. These are in addition to the default synthdef/ and plugin/ directories which are hard-coded.

These can be set within SC using the getenv and setenv methods of class link::Classes/String::.
code::
// all defs in this directory will be loaded when a local server boots
"SC_SYNTHDEF_PATH".setenv("~/scwork/".standardizePath);
"echo $SC_SYNTHDEF_PATH".unixCmd;
::

subsection:: The default group

When a Server is booted there is a top level group with an ID of 0 that defines the root of the node tree. (This is represented by a subclass of link::Classes/Group:: : link::Classes/RootNode::.)
If the server app was booted from within SCLang (as opposed to from the command line) the method code::initTree:: will be called automatically after booting.
This will also create a link::Reference/default_group:: with an ID of 1, which is the default group for all link::Classes/Node::s when using object style.
This provides a predictable basic node tree so that methods such as Server-scope, Server-record, etc. can function without running into order of execution problems.

The default group is persistent, i.e. it is recreated after a reboot, pressing cmd-., etc. See link::Classes/RootNode:: and link::Reference/default_group:: for more information.
Note::
If a Server has been booted from the command line you must call code::initTree:: manually in order to initialize the default group, if you want it. See code::initTree:: below.
::

subsection:: Local vs. Internal

In general, when working with a single machine one will probably be using one of two Server objects which are created at startup and stored in the class variables link::Classes/Server#*local#*local:: and link::Classes/Server#*internal#*internal::. In SuperCollider.app (OSX), two GUI windows are created to control these. Use link::Classes/Server#-makeGui#-makeGui:: to create a GUI window manually.

The difference between the two is that the local server runs as a separate application with its own address space, and the internal server runs within the same space as the language/client app.

Both local and internal server supports link::Classes/Server#-scope#scoping:: and link::Classes/Bus#Synchronous Control Bus Methods#synchronous bus access::.

The local server, and any other server apps running on your local machine, have the advantage that if the language app crashes, it (and thus possibly your piece) will continue to run. It is thus an inherently more robust arrangement. But note that even if the synths on the server continue to run, any language-side sequencing and control will terminate if the language app crashes.

At the current time, there is generally no benefit in using the internal server, but it remains for the purposes of backwards compatibility.

subsection:: The default Server

There is always a default Server, which is stored in the class variable code::default::. Any link::Classes/Synth::s or link::Classes/Group::s created without a target will be created on the default server. At startup this is set to be the local server (see above), but can be set to be any Server.

subsection:: Local vs. Remote Servers, Multi-client Configurations

Most of the time users work with a server app running on the same machine as the SC language client. It is possible to use a server running on a different machine via a network, providing you know the IP address and port of that server. The link::Classes/Server#*remote#*remote:: method provides a convenient way to do this. note::To enable remote connections you will need to change link::Classes/ServerOptions#-bindAddress:: in the server's link::Classes/ServerOptions:: as the default value only allows connections from the local machine. code::s.options.bindAddress = "0.0.0.0":: will allow connections from any address.::

One common variant of this approach is multiple clients using the same server. If you wish to do this you will need to set the server's link::Classes/ServerOptions#-maxLogins:: to at least the number of clients you wish to allow.  When a client registers for link::Classes/Server#-notify#notifications:: the server will supply a client ID. This also configures the allocators to avoid conflicts when allocating link::Classes/Node##Nodes::, link::Classes/Buffer##Buffers::, or link::Classes/Bus##Busses::. For more info see link::Guides/MultiClient_Setups::.

In order to use a remote server with tcp one should first boot the remote server using the code::-t:: option e.g. as follows:
code::
// on machine running the server
(
s.options.protocol = \tcp; // set to use tcp
s.options.bindAddress = "0.0.0.0"; // allow connections from any address
s.options.maxLogins = 2; // set to correct number of clients
s.boot;
)
::

then run the following code:

code::
// on remote machine connecting to server
(
o = ServerOptions.new;
o.protocol_(\tcp);
t = Server.remote(\remote, NetAddr("192.168.0.130", 57110), o); // set to correct address and port
t.addr.connect;
t.startAliveThread( 0 );
t.doWhenBooted({ "remote tcp server started".postln; t.notify; t.initTree });
)
::




title:: Scheduling and Server timing
summary:: Server bundling latency and OSC timing, logical and physical time
categories:: Server>Architecture, External Control>OSC, Scheduling
related:: Classes/Server, Classes/TempoClock

To ensure correct timing of events on the server, OSC messages may be sent with a time stamp, indicating the precise time the sound is expected to hit the hardware output.

section:: Latency

In the SuperCollider language, the time stamp is generated behind the scenes based on a parameter called "latency."

To understand how latency works, we need to understand the concepts of logical time and physical time.

Every clock in SuperCollider has both a logical time and physical time.
definitionlist::
## Physical time || always advances, represents real time.
## Logical time || advances only when a scheduling thread wakes up.
::

While a scheduled function or event is executing, logical time holds steady at the "expected" value. That is, if the event is scheduled for 60 seconds exactly, throughout the event's execution, the logical time will be 60 seconds. If the event takes 2 seconds to execute (very rare), at the end of the event, the logical time will still be 60 seconds but the physical time will be 62 seconds. If the next event is to happen 3 seconds after the first began, its logical time will be 63 seconds. Logical time is not affected by fluctuations in system performance.

This sequencing example illustrates the difference. It's written deliberately inefficiently to expose the problem more clearly. Two copies of the same routine get started at the same time. On a theoretically perfect machine, in which operations take no time, we would hear both channels in perfect sync. No such machine exists, and this is obviously not the case when you listen. The routines also print out the logical time (clock.beats) and physical time (clock.elapsedBeats) just before playing a grain.

code::
s.boot;

SynthDef(\sinGrain, { |out = 0, freq = 440, amp = 0.5, dur = 1|
    Out.ar(out, SinOsc.ar(freq, 0, amp) * EnvGen.kr(Env.sine(1), timeScale:dur, doneAction: Done.freeSelf));
}).add;

2.do({ |chan|
    var rout;
    rout = Routine({
        var freq;
        {   freq = 0;
            rrand(400, 1000).do({ freq = freq + 1 });
            [thisThread.clock.beats, thisThread.clock.elapsedBeats].postln;
            Synth(\sinGrain, [\out, chan, \freq, freq, \dur, 0.005]);
            0.1.wait;
        }.loop;
    });
    TempoClock.default.schedAbs(TempoClock.default.elapsedBeats.roundUp(1), rout);
});
::

This is the output:
code::
    Left channel                     Right channel
Logical vs Physical time         Logical vs Physical time
95         95.001466112          95         95.002988196
95.1       95.101427968          95.1       95.103152311
95.2       95.201250057          95.2       95.202905826
95.3       95.301592755          95.3       95.303724638
95.4       95.401475486          95.4       95.403289141

Average physical latency:
0.00144247559999830              .0032120224000039
::

Notice that even though the left and right channel patterns were scheduled for exactly the same time, the events don't complete executing at the same time. Further, the Synth(...) call instructs the server to play the synth immediately on receipt, so the right channel will be lagging behind the left by about 2 ms each event--and not by the same amount each time. Timing, then, is always slightly imprecise.

This version is the same, but it generates each synth with a 1/4 second latency parameter:

code::
2.do({ |chan|
    var rout;
    rout = Routine({
        var freq;
        {   freq = 0;
            rrand(400, 1000).do({ freq = freq + 1 });
            [thisThread.clock.beats, thisThread.clock.elapsedBeats].postln;
            s.makeBundle(0.25, { Synth(\sinGrain, [\out, chan, \freq, freq, \dur, 0.005]); });
            0.1.wait;
        }.loop;
    });
    TempoClock.default.schedAbs(TempoClock.default.elapsedBeats.roundUp(1), rout);
});
::

By using makeBundle with a time argument of 0.25, the \s_new messages for the left and right channel are sent with the same timestamp: the clock's current logical time plus the time argument. Note in the table that both channels have the same logical time throughout, so the two channels are in perfect sync.

These routines are written deliberately badly. If they're made maximally efficient, the synchronization will be tighter even without the latency factor, but it can never be perfect. You'll also see this issue, however, if you have several routines executing and several of them are supposed to execute at the same time. Some will execute sooner than others, but their logical time will all be the same. If they're all using the same amount of latency, you will still hear them at the same time.

In general, all synths that are triggered by live input (MIDI, GUI, HID) should specify no latency so that they execute as soon as possible. All sequencing routines should use latency to ensure perfect timing.

The latency value should allow enough time for the event to execute and generate the OSC bundle, and for the server to interpret the message and render the audio in time to reach the hardware output on time. If the client and server are on the same machine, this value can be quite low. Running over a network, you must allow more time. (Latency compensates for network timing jitter also.)

Pbind automatically imports a latency parameter from the server's latency variable. You can set the default latency for event patterns like this:
code::
myServer.latency = 0.2;  // 0.2 is the default
::

Here are three ways to play a synth with the latency parameter:
code::
// messaging style
// s.nextNodeID is how to get the next unused node ID from the server
s.sendBundle(latency, [\s_new, defName, s.nextNodeID, targetID, addAction, arguments]);

// object style, asking the object for the message
synth = Synth.basicNew(defName, s);
s.sendBundle(latency, synth.newMsg(target, arguments, addAction));

// object style, using automatic bundling
// like the previous example, when this finishes you'll have the Synth object in the synth variable
s.makeBundle(latency, { synth = Synth(defName, arguments, target, addAction); });
::



title:: "Spawning" and "TSpawning"
summary:: The lack of the Spawn and TSpawn UGens and their various convienence classes
categories:: Language>SC3 vs SC2

In SC2, Spawn and TSpawn were two of the most powerful and commonly used UGens. In SC3 the idea of a top level Synth in which everything is spawned is no longer valid. Synthesis is always running (at least as long as a server is) and new Synths can be created on the fly. This arrangement results in even greater flexibility than in SC2, but requires a slightly different approach.

In SC3 one can create Synths at any time simply by executing blocks of code.

code::
// do this
(
x = SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).play; // SynthDef-play returns a Synth object.
)

// then do this
(
SynthDef("help-Rand", { arg out = 0;
	Out.ar(
		out,
		FSinOsc.ar(
			Rand(200.0, 400.0), // frequency between 200 and 400 Hz
			0, Line.kr(0.2, 0, 1, doneAction: Done.freeSelf) // frees itself
		)
	)
}).play(s);
)

x.free;
::

Clocks, such as link::Classes/SystemClock::, provide a way to schedule things at arbitrary points in the future. This is similar to code::Synth.sched:: in SC2.

code::
(
SystemClock.sched(2.0, {
	"2.0 seconds later".postln; // this could be any code, including Synth creation
	nil // this means don't repeat
});
)
::

In SC3 time-based sequences of events can be implemented using Routines. A link::Classes/Routine:: which yields a number can be scheduled using a clock:

code::
(
var w, r;

w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;

r = Routine({ arg time;
	60.do({ arg i;
		0.05.yield; // wait for 0.05 seconds
		{
			w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
			w.alpha = cos(i*0.1pi)*0.5+0.5;
		}.defer;
	});
	1.yield; // wait for 1 second before closing w
	w.close;
});

SystemClock.play(r);
)
::

Note that this implementation avoids one of the stranger aspects of the SC2 approach: The need to start a Synth to schedule time-based behavior, even if no audio is involved.

Both link::Classes/SystemClock:: and link::Classes/AppClock:: (a less accurate version which can call Cocoa primitives) have only class methods. Thus one does not create instances of them. If you need to have an individual clock to manipulate (for instance to manipulate the tempi of different sequences of events) you can use link::Classes/TempoClock::.

A simple SC2 Spawn example is shown below, followed by its translation into SC3 style code.

code::
// This will not execute in SC3
(
Synth.play({
	Spawn.ar(
		{ EnvGen.ar(Env.perc) * SinOsc.ar(440,0,0.1) },
		1, // one channels
		1 // new event every second
	)
})
)

// The same example in SC3 (will execute)
s.boot;
(
SynthDef("help-EnvGen",{ arg out = 0;
	Out.ar(
		out,
		EnvGen.kr(Env.perc,1.0,doneAction: Done.freeSelf) * SinOsc.ar(440,0,0.1)
	)
}).send(s);
)

(
r = Routine.new({ { Synth.new("help-EnvGen"); 1.yield; }.loop }); // loop every one second
SystemClock.play(r);
)
::

Note that the above example uses a precompiled link::Classes/SynthDef::. This results in a lower CPU spike when Synths are created than SC2-style Spawning. It is possible to create SynthDefs on the fly, if this is necessary, but a great deal of variation can be achieved with arguments, or with UGens such as link::Classes/Rand:: and link::Classes/TRand::. See the section link::Overviews/SC3vsSC2#SynthDefsVsSynths:: for more detail.

code::
// SynthDefs on the fly
s.boot;
(
t = TempoClock.new;
r = Routine.new({
	10.do({
		// could be done with an argument instead of a new def, but proves the point
		SynthDef("help-EnvGen" ++ i, { arg out = 0;
			Out.ar(
				out,
				EnvGen.kr(Env.perc, 1.0, doneAction: Done.freeSelf)
				* SinOsc.ar(100 + (100 * t.elapsedBeats), 0, 0.1)
			)
		}).play(s);
		1.yield;
	});
}).play(t); // Note the alternative syntax: Routine.play(aClock)
)
::

Note the alternative syntax for playing a Routine. code::aClock.play(aRoutine):: and code::aRoutine.play(aClock):: are functionally equivalent. The two make different things more or less convenient, like sending messages to the link::Classes/Routine:: or link::Classes/Clock::. (See the play helpfile for a more detailed discussion.) For instance:

code::
(
// this, that and the other
r = Routine.new({var i = 0; { ("this: " ++ i).postln; i = i + 1; 1.yield; }.loop });
q = Routine.new({var i = 0; { ("that: " ++ i).postln; i = i + 1; 1.yield; }.loop });
t = Routine.new({var i = 0; { ("the other: " ++ i).postln; i = i + 1; 1.yield; }.loop });
)

SystemClock.play(r);	// start this
SystemClock.play(q);	// start that
SystemClock.play(t);	// start the other

r.stop;			// stop this but not that or the other
q.reset;		// reset that while playing

c = TempoClock.new;	// make a TempoClock
r.reset;		// have to reset this because it's stopped
c.play(r);		// play this in the new clock; starts from the beginning
c.tempo = 16;		// increase the tempo of this

SystemClock.clear;	// clear EVERYTHING scheduled in the SystemClock; so that and the other
			// but not this

c.clear;		// clear everything scheduled in c, i.e. this
c.play(r);		// since it wasn't stopped, we don't have to reset this
			// and it picks up where it left off

c.stop;			// stop c, destroy its scheduler, and release its OS thread
::

For convenience pauseable scheduling can be implemented with a link::Classes/Task::. code::Task.new:: takes two arguments, a function and a clock, and creates it's own link::Classes/Routine::. If you don't specify a clock, it will create a link::Classes/TempoClock:: for you. Since you don't have to explicitly create a link::Classes/Clock:: or link::Classes/Routine::, use of link::Classes/Task:: can result in code that is a little more compact.

code::
(
t = Task.new({
	inf.do({ arg i;
		i.postln;
		0.5.wait
	});
});
)

t.start;		// Start it
t.stop;			// Stop it
t.start;		// Start again from the beginning
t.reset;		// Reset on the fly
t.stop;			// Stop again
t.resume;		// Restart from where you left off
t.clock.tempo = 0.25;	// Get the Task's clock and change the tempo. This works since the
			// default is a TempoClock.
t.pause;		// Same as t.stop
::

TSpawn's functionality can be replicated with link::Classes/SendTrig:: and link::Classes/OSCFunc::. See their individual helpfiles for details on their arguments and functionality.

code::
s.boot;
(
// this Synth will send a trigger to the client app
SynthDef("help-SendTrig", {
	SendTrig.kr(
		Dust.kr(1.0), // trigger could be anything, e.g. Amplitude.kr(SoundIn.ar(0) > 0.5)
		0, 0.9
	);
}).send(s);
)

(
// this receives the trigger on the client side and 'Spawns' a new Synth on the server
OSCFunc({
	SynthDef("help-EnvGen", { arg out = 0;
		Out.ar(
			out,
			EnvGen.kr(Env.perc, 1.0, doneAction: Done.freeSelf)
			* SinOsc.ar(440, 0, 0.1)
		)
	}).play(s);
}, '/tr', s.addr);

// Start 'spawning'
Synth("help-SendTrig");
)
::


title:: SuperColliderAU
categories:: Platform>macOS
summary:: wraps scsynth as an AudioUnits plugin

SuperColliderAU is an AudioUnit wrapper that allows using SuperCollider servers inside AudioUnits hosts on macOS. The embedded server may be controlled over OSC as usual. In addition, it may be packed with a synth definition and a configuration file that defines its parameters.

section::Installing

Copy the bundle "SuperColliderAU.component" into /Library/Audio/Plug-ins/Components or in ~/Library/Audio/Plug-ins/Components

section::Quick Start

Start up an Audio Units host application. Common hosts include Apple Logic and Ableton Live. A list of supported hosts can be found in this page of the SuperCollider swiki (feel free to update it):

http://swiki.hfbk-hamburg.de:8888/MusicTechnology/823

Find SuperColliderAU among the rest of AudioUnit plugins and add an instance to a track (check the manual of your host if you don't know how to do this). A panel will appear telling you which port the server is listening to for OSC messages.

Now you can run this code from within the SuperCollider language to talk directly with the embedded server:
code::
u = Server(\scau, NetAddr("127.0.0.1", 9989)); // Change the port from 9989 to the right one for you
u.serverRunning = true;
u.ping(10); // Gives about 0.02 for me - confirms that communication is working
// Now let's create a quick ring-modulator effect:
z = { SoundIn.ar([0,1]) * SinOsc.ar(MouseX.kr(100, 1000)) }.play(u);
::

section::Inside the bundle

As an AudioUnit plugin, SuperColliderAU is packaged in a component bundle. All the files needed by SuperColliderAU can be found in the Resources folder inside the bundle:

subsection::serverConfig.plist
Stores configuration parameters for the server (see link::Classes/ServerOptions::)

list::
## PortNumber: the udp port that scserver will listen to if available (otherwise, it will look for an available port).
## BlockSize: block size configuration for the server.
## MemorySize: amount of real time memory allocated to this server.
## NumWireBufs: maximum number of buffers for connecting ugens.
## DoNoteOn: (experimental) if true the server will send an OSC bundle setting the "note" and "velocity" parameters when a MIDI noteon or noteoff message is received. For this to work you need a host that supports Midi effect AudioUnits and sends them MIDI messages.
## BeatDiv: For linking Demand Ugens to the Host tempo. If this number is set, SuperColliderAU will trigger bus 0 each beat division and use bus 1 for reset.
::

subsection::pluginSpec.plist
Stores parameter configuration for standalone plugins. SuperColliderAU will use this to display and set the parameters of your synth definition. Note that the default values must be the same for the synth definition, they will not be set by the wrapper. The value in this file is only for display.

subsection::synthdefs
For standalone plugins you should have your synth definition here. When controlling the server remotely you can just send the synth definitions.

subsection::plugins
Here you need all the SC plugins you intend to use with that server.

section::Making standalone plugins

Besides controlling SuperColliderAU from within the language, you can create AudioUnits plugins that are controlled from the host using the default GUI. This can be done manually by duplicating SupercolliderAU.component, adding a synthdef and associated SC plugins and editing pluginSpec.plist. However, if you want an AudioUnit with a unique identifier (the identifier is what you see from within the host GUI) you have to recompile its resource file (with the new identifier) using Rez. This program is included in Apple's Developer Tools. A helper class that automates all this process is maintained in the AudioUnitBuilder quark. Using the class AudioUnitBuilder you can create standalone AudioUnit plugins without leaving SuperCollider.


title:: Synchronous and Asynchronous Execution
summary:: The problem of simultaneous synchronous and asynchronous execution
categories:: Language>SC3 vs SC2

Using a program such as SuperCollider introduces a number of issues regarding timing and order of execution. Realtime audio synthesis requires that samples are calculated and played back at a certain rate and on a certain schedule, in order to avoid dropouts, glitches, etc. Other tasks, such as loading a sample into memory, might take arbitrary amounts of time, and may not be needed within a definite timeframe. This is the difference between synchronous and asynchronous tasks.

Problems can arise when synchronous tasks are dependent upon the completion of asynchronous ones. For instance trying to play a sample that may or may not have been completely loaded yet.

In SC2 this was relatively simple to handle. One scheduled synchronous tasks during synthesis, i.e. within the scope of a code::Synth.play::. Asynchronous tasks were executed in order, outside of synthesis. Thus one would first create buffers, load samples into them, and then start synthesis and play them back. The interpreter made sure that each step was only done when the necessary previous step had been completed.

In SC3 the separation of language and synth apps creates a problem: How does one side know that the other has completed necessary tasks, or in other words, how does the left hand know if the right is finished? The flexibility gained by the new architecture introduces another layer of complexity, and an additional demand on the user.

A simple way to deal with this is to execute code in blocks. In the following code, for instance, each block or line of code is dependent upon the previous one being completed.

code::
// Execute these one at a time

// Boot the server
s.boot;

// Compile a SynthDef and write it to disk
(
SynthDef("Help-SynthDef", { arg out = 0;
	 Out.ar(out, PinkNoise.ar(0.1))
}).writeDefFile;
)

// Load it into the server
s.loadSynthDef("Help-SynthDef");

// Create a Synth with it
x = Synth.new("Help-SynthDef", s);

// Free the node on the server
x.free;

// Allow the client-side Synth object to be garbage collected
x = nil;
::

In the previous example it was necessary to use interpreter variables (the variables a-z, which are declared at compile time) in order to refer to previously created objects in later blocks or lines of code. If one had declared a variable within a block of code (i.e. code::var mySynth;::) than it would have only persisted within that scope. (See the helpfile link::Reference/Scope:: for more detail.)

This style of working, executing lines or blocks of code one at a time, can be very dynamic and flexible, and can be quite useful in a performance situation, especially when improvising. But it does raise the issues of scope and persistence. Another way around this that allows for more descriptive variable names is to use environment variables (i.e. names that begin with ~, so code::~mysynth;:: see the link::Classes/Environment:: helpfile for details). However, in both methods you become responsible for making sure that objects and nodes do not persist when you no longer need them.

code::
(
SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s);
)

// make a Synth and assign it to an environment variable
~mysynth = Synth.new("Help-SynthDef", s);

// free the synth
~mysynth.free;

// but you've still got a Synth object
~mysynth.postln;

// so remove it from the Environment so that the Synth will be garbage collected
currentEnvironment.removeAt(\mysynth);
::

But what if you want to have one block of code which contains a number of synchronous and asynchronous tasks. The following will cause an error, as the link::Classes/SynthDef:: that the server needs has not yet been received.

code::
// Doing this all at once produces the error "FAILURE /s_new SynthDef not found"
(
var name;
name = "Rand-SynthDef" ++ 400.0.rand; // use a random name to ensure it's not already loaded

SynthDef(name, { arg out=0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s);

Synth.new(name, s);
)
::

A crude solution would be to schedule the dependant code for execution after a seemingly sufficient delay using a clock.

code::
// This one works since the def gets to the server app first
(
var name;
name = "Rand-SynthDef" ++ 400.0.rand;

SynthDef(name, { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s);

SystemClock.sched(0.05, {Synth.new(name, s);}); // create a Synth after 0.05 seconds
)
::

Although this works, it's not very elegant or efficient. What would be better would be to have the next thing execute immediately upon the previous thing's completion. To explore this, we'll look at an example which is already implemented.

You may have realized that first example above was needlessly complex. SynthDef-play will do all of this compilation, sending, and Synth creation in one stroke of the enter key.

code::
// All at once
(
SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).play(s);
)
::

Let's take a look at the method definition for SynthDef-play and see what it does.

code::
	play { arg target,args,addAction=\addToTail;
		var synth, msg;
		target = target.asTarget;

		synth = Synth.basicNew(name,target.server); // create a Synth, but not a synth node
		msg = synth.newMsg(target, addAction, args);// make a message that will add a synth node
		this.send(target.server, msg); // ** send the def, and the message as a completion message
		^synth // return the Synth object
	}
::

This might seem a little complicated if you're not used to mucking about in class definitions, but the important part is the second argument to code::this.send(target.server, msg);::. This argument is a completion message, it is a message that the server will execute when the send action is complete. In this case it says create a synth node on the server which corresponds to the link::Classes/Synth:: object I've already created, when and only when the def has been sent to the server app. (See the helpfile link::Reference/Server-Command-Reference:: for details on messaging.)

Many methods in SC have the option to include completion messages. Here we can use SynthDef-send to accomplish the same thing as SynthDef-play:

code::
// Compile, send, and start playing
(
SynthDef("Help-SynthDef", { arg out=0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s, ["s_new", "Help-SynthDef", x = s.nextNodeID]);
// this is 'messaging' style, see below
)
s.sendMsg("n_free", x);
::

The completion message needs to be an OSC message, but it can also be some code which when evaluated returns one:

code::
// Interpret some code to return a completion message. The .value is needed.
// This and the preceding example are essentially the same as SynthDef.play
(
SynthDef("Help-SynthDef", { arg out=0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s, {x = Synth.basicNew("Help-SynthDef"); x.newMsg; }.value); // 'object' style
)
x.free;
::

If you prefer to work in 'messaging' style, this is pretty simple. If you prefer to work in 'object' style, you can use the commands like code::newMsg::, code::setMsg::, etc. with objects to create appropriate server messages. The two proceeding examples show the difference. See the link::Guides/NodeMessaging:: helpfile for more detail.

In the case of link::Classes/Buffer:: objects a function can be used as a completion message. It will be evaluated and passed the link::Classes/Buffer:: object as an argument. This will happen after the link::Classes/Buffer:: object is created, but before the message is sent to the server. It can also return a valid OSC message for the server to execute upon completion.

code::
(
SynthDef("help-Buffer",{ arg out=0, bufnum;
	Out.ar(
		out,
		PlayBuf.ar(1,bufnum,BufRateScale.kr(bufnum))
	)
}).load(s);

y = Synth.basicNew("help-Buffer"); // not sent yet

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", action: { arg buffer;
       // synth send its s_new msg to follow
       // after the buffer read completes
       s.sendBundle(nil, y.newMsg(s,[\bufnum,buffer],\addToTail));
   }
);
)

// when done...
y.free;
b.free;
::

The main purpose of completion messages is to provide OSC messages for the server to execute immediately upon completion. In the case of link::Classes/Buffer:: there is essentially no difference between the following:

code::
(
b = Buffer.alloc(s, 44100,
	completionMessage: { arg buffer; ("bufnum:" + buffer).postln; }
);
)

// this is equivalent to the above
(
b = Buffer.alloc(s, 44100);
("bufnum:" + b).postln;
)
::

One can also evaluate a function in response to a 'done' message, or indeed any other one, using an link::Classes/OSCFunc::. See its help file for details.

code::
(
SynthDef("help-SendTrig",{
    SendTrig.kr(Dust.kr(1.0), 0, 0.9);
}).send(s);

// register to receive this message
a = OSCFunc({ arg msg, time;
    ("This is the done message for the SynthDef.send:" + [time, msg]).postln;
}, '/done').oneShot; // remove me automatically when done

b = OSCFunc({ arg msg, time;
    [time, msg].postln;
}, '/tr');
c = OSCFunc({ arg msg;
    "this is another call".postln;
}, '/tr');
)

x = Synth.new("help-SendTrig");
b.free;
c.free;
a.free;
::


title::SynthDefs versus Synths
summary:: The use of precompiled SynthDefs as opposed to always compiling on the fly
categories:: Language>SC3 vs SC2

In SC2 code::Synth.play:: was the standard way to compile a emphasis::ugenGraphFunc:: and play it. Each time you executed code::Synth.play::, or Spawned a new event, that function was compiled anew. SC3 on the other hand, makes use of what are called SynthDefs. A link::Classes/SynthDef:: takes a emphasis::ugenGraphFunc:: and compiles it to a kind of bytecode (sort of like Java bytecode) which can be understood by the server app. The server reads the link::Classes/SynthDef:: and creates a synth node based upon it.

SynthDefs can be precompiled and saved to disk. Any def saved in the synthdefs/ directory (or in any directory set in the environment variable SC_SYNTHDEF_PATH) will be loaded into memory by a local link::Classes/Server:: when it is booted. If the def being used in a new link::Classes/Synth:: is already compiled and loaded, there is much less of a CPU spike when creating a new link::Classes/Synth:: than there was in SC2.

SynthDefs can also be compiled and loaded into the link::Classes/Server:: without writing them to disk. This can be done while performing.

The downside of this is that precompiled SynthDefs lack some of the programmatic flexibility that was one of SC2's great strengths. Much of this flexibility is gained back however, through the ability to set and change arguments (which you build into your emphasis::ugenGraphFunc::), and through new UGens such as link::Classes/Rand:: and link::Classes/TRand::.

When maximum flexibility is required, it is still possible to compile and send SynthDefs 'on the fly', albeit with SC2-like CPU spikes and a small amount of messaging latency.

It is important to understand that creating and sending SynthDefs is emphasis::asynchronous::. This means that it is impossible to determine precisely how long it will take to compile and send a link::Classes/SynthDef::, and thus when it will be available for creating new Synths. A simple way around this is to execute code in blocks, selecting them one at a time. More complicated is to use completion messages. code::SynthDef.play:: takes care of this for you, and returns a link::Classes/Synth:: object which you can then manipulate. See the example below

Another important distinction is between Synth in SC2 and link::Classes/Synth:: in SC3. The latter is a client-side object which represents a synth node on the server. Although it has some of the same methods, it does not function in the same way. There is no top level Synth in SC3, within which all scheduling and creation of other Synths occurs. There are only link::Classes/Synth:: objects which represent synth nodes on the server. These can be created at any time, within any scope.

examples::

code::
s.boot;

// Compile a SynthDef and write it to disk
(
SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).writeDefFile;
)

// Compile, write, and load it to the server
(
SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).load(s);
)

// Load it to the server without writing to disk
(
SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s);
)

// Create a Synth with it
x = Synth.new("Help-SynthDef", s);
x.free;

// Shorthand method to compile and write a SynthDef, and then play it in a Synth when done.
// Look familiar?
(
x = SynthDef("Help-SynthDef", { arg out = 0;
	Out.ar(out, PinkNoise.ar(0.1))
}).play(s);
)
// The above only starts the new Synth after the def has been sent to the server.
// Note that SynthDef.play returns a Synth object!

x.set(\out, 1); // change one of the arguments
x.free;

// SynthDef with a parameter that will be randomly determined each time a new Synth is created
// (try it several times to hear the differences)
(
SynthDef("help-RandFreq", { arg out = 0;
	Out.ar(
		out,
		FSinOsc.ar(
			Rand(200.0, 400.0), // frequency between 200 and 400 Hz
			0, Line.kr(0.2, 0, 1, doneAction: Done.freeSelf)
		)
	)
}).play(s);
)
::


TITLE:: Tour of Special Functions
SUMMARY:: Examples and plots for Boost Special Functions
CATEGORIES:: Guides
related:: Classes/SimpleNumber
KEYWORD:: special functions, boost


DESCRIPTION:: Boost library Special Functions: usage, bounds and plots

An array of Special Functions supplied by the Boost library. The library's
LINK::http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/special.html##online documentation::
 serves as the primary reference for the following functions.

Many of the functions are only valid in certain numerical ranges. The following tour will
show you plots that illustrate the behavior of the functions, their ranges and asymptotes.

Define the plotting functions in the next section, then you can use the Table of Contents
menu to jump between function families.

SECTION:: Before you get started...

Define the following functions that will lay out the plots for you:

CODE::
(
var genCol, getPlotLay, multiPlot, layOutPlots, plotSpecs;

// generate colors for each plot
genCol = { |num, offset=(rrand(0,1.0)), range=(rrand(0.15,1.3))|
	num.collect { |i|
		Color.hsv(((i/(max(num,1.0001)-1)) * range + offset).wrap(0,1), 0.6, 1, 1)
	}
};
// generate a vertical layout for the plot and its text
getPlotLay = { |plot, text|
	VLayout(plot, StaticText().string_(text).maxHeight_(50).align_(\center), 10)
};

~multiPlot = { |func, data, txt, min, max|
	var res, params, samps, clumped, pltr;
	var gridcol = Color.gray.alpha_(0.2);

	if(data.shape.size == 1) {
		samps = data;
		clumped = data.asList.flop;
	}{
		#params, samps = data;
		if (params.size > 6) {
			txt = txt ++ format("( % .. % )", params.first, params.last);
		} {
			txt = txt ++ params.asString;
		};
		clumped = params.collect{ |param, i|
			samps.collect([param, _, i])
		}
	};

	res = clumped.collect({ |bundle, i|
		bundle.collect(func.applyTo(*_)).select(_.notNil)
	});

	pltr = res.plot( txt, minval: min, maxval: max)
	.superpose_(true)
	.domainSpecs_([samps.minItem, samps.maxItem].asSpec)
	.plotColor_(
		genCol.(params !? params.size ?? 1, rrand(0,1.0))
	)
	;

	pltr.plots[0]
	.gridColorX_(gridcol)
	.gridColorY_(gridcol)
	;

	pltr
};

~layOutPlots = { |plotters, title="", numCols|
	var cols, hl, plotlay, colbut, plots, wscl;
	var vl = VLayout();
	var sb = Window.screenBounds;

	cols = numCols ?? { plotters.size.sqrt.ceil.asInteger };
	wscl = cols.linlin(1, 4, 0.5, 0.9);
	w = Window(title,
		Rect().width_(sb.width*wscl).height_(sb.height).center_(sb.center)
	).view.layout_(vl).front;

	colbut = Button().states_([["Light Plots"], ["Dark Plots"]]).maxSize_(Size(80,15));
	vl.add(HLayout(nil, colbut));

	plotters.do { |pltr, i|
		var plot = pltr.parent.view.children[0];
		if(i % cols == 0) {
			vl.add(hl = HLayout())
		};
		plotlay = getPlotLay.(plot, pltr.name.asString);
		hl.add(plotlay);
		pltr.parent.close;
	};

	if((plotters.size) % cols > 0) {
		((cols-(plotters.size)%cols)).do{hl.add(StaticText().string_(""))}
	};

	colbut.action_({ |but|
		var switch = but.value.asBoolean;
		plotters.do{ |pltr|
			pltr.plots[0]
			.backgroundColor_(
				switch.if({Color.white.alpha_(1)}, {Color(*0.1.dup(3)).alpha_(0.95)})
			)
			.fontColor_(
				switch.if({Color.gray},{Color.red});
			);
		};
		w.refresh;
	});
	colbut.value_(0).doAction; // start with dark plots
};
)
::

SECTION:: Number Series

CODE::
/* Bernouli Numbers */

//   Odd numbered Bernoulli numbers are zero, except B1
//   which is -1/2. Post even Bernouli numbers:
(0..31).do{ |i| postf("% %\n", i*2, bernouliB2n(i)) }


/* Tangent numbers */

(0..15).do { |i| postf("% %\n", i, tangentT2n(i)) }
::


SECTION:: Gamma Functions

SUBSECTION:: Gamma, Log Gamma, Digamma, Trigamma, Polygamma

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var checkCall, plotSpecs;
// make sure z isn't a negative integer
checkCall = { |selector, z|
	if ((z <= 0) nand: { (z % 1) == 0 }) { z.perform(selector) }
};

plotSpecs = [
	[   { |z| checkCall.(\tgamma, z) },
		(-4, -3.95 .. 6),
		"tgamma(z)\n\"True\" gamma function",
		-125, 125
	],
	[   { |dz| checkCall.(\tgamma1pm1, dz) },
		(-4, -3.95 .. 6),
		"tgamma1pm1(dz)\ngamma(dz + 1) - 1",
		-125, 125
	],
	[   { |z| checkCall.(\lgamma, z) },
		(-4, -3.95 .. 10),
		"lgamma(z)\nLog gamma",
		-2.5, 12.5
	],
	[   { |z| checkCall.(\digamma, z) },
		(-3, -2.95 .. 10),
		"digamma(z)\nDigamma",
		-2.5, 12.5
	],
	[   { |z| checkCall.(\trigamma, z) },
		(-3.99, -3.94 .. 10),
		"trigamma(z)\nTrigamma",
		0, 30
	],
	[   // make sure z isn't a negative integer
		{ |n, z| if ( z <= 0 nand: { (z % 1) == 0 }) { polygamma(n, z) } },
		[[2,3], (-6, -5.95 .. 5)],
		"polygamma(z)\nPolygamma\nn=",
		-50, 400
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Gamma Functions", 2 );
)
::

SUBSECTION:: Gamma Ratios, Incomplete/Inverses, and Derivatives of Gamma Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \gammaP,
		[ (0.1, 0.3 .. 8), (0.01, 0.05 .. 20) ],
		"gammaP(a, z)\nLower incomplete gamma function (normalized)\na=",
	],
	[   \gammaQ,
		[ (0.1, 0.3 .. 8), (0.01, 0.05 .. 20) ],
		"gammaQ(a, z)\nUpper incomplete gamma function (normalized)\na=",
	],
	[   \tgammaLower,
		[ (0.1, 0.3 .. 8), (0.01, 0.05 .. 6) ],
		"tgammaLower(a, z)\nLower incomplete gamma function (non-normalized)\na=",
		0, 3
	],
	[   \tgammaUpper,
		[ (0.1, 0.3 .. 8), (0.01, 0.05 .. 6) ],
		"tgammaUpper(a, z)\nUpper incomplete gamma function (non-normalized)\na=",
		0, 3
	],
	[   { |delta, z| if(z.neg != delta) { tgammaDeltaRatio(z, delta) } },
		[ (-0.5, -0.45  .. 1), (0.0001, 0.1 .. 40)],
		"tgammaDeltaRatio(z, delta)\nGamma Delta Ratio\ndelta=",
		0, 7
	]
];

~layOutPlots.( plotSpecs.collect { |data| ~multiPlot.(*data) }, "Gamma Functions (cont'd)", 2 );
)
::


SECTION:: Factorials and Binomial Coefficients

CODE::
/*  Factorial  */
// Warning: overflows i > 170
(1..170).do{ |i| (i.asString + factorial(i.asFloat)).postln };


/*  Double Factorial  */
// for even i, i !! = i(i-2)(i-4)(i-6) ... (4)(2)
doubleFactorial(8);
// for odd i, i !! = i(i-2)(i-4)(i-6) ... (3)(1)
doubleFactorial(7)

/*  Rising Factorial  */
// x(x+1)(x+2)(x+3)...(x+i-1)
risingFactorial(9, 4)  // 9 * 10 * 11 ... (9+4-1)

/*  Falling Factorial  */
// x(x-1)(x-2)(x-3)...(x-i+1)
fallingFactorial(9, 4) // 9 *  8 *  7 ... (9-4+1)
::


SECTION:: Beta Functions

SUBSECTION:: Beta Functions, Incomplete and Derivative

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var as = [9,7,5,2,1];
var bs = [1,2,5,7,9];
var xs = (0, 0.005 .. 1);
var plotSpecs = [
	[   { |a, b| log(beta(a, b)) }, // NOTE: using log for plot as in boost doc
		[[0.5, 1.0, 5.0, 10.0], (0.001, 0.005 .. 5)],
		"log(beta(a, b))\nBeta function\nas=",
		-10, 10
	],
	[   { |a, x, i| ibetaDerivative(a, bs[i], x) },
		[as, xs],
		"ibetaDerivative(a, b, x)\nDerivative of the Incomplete Beta function (norm)\nbs=[1,2,5,7,9]  as=",
		0, 6
	],
	[   { |a, x, i| ibeta(a, bs[i], x) },
		[as, xs],
		"ibeta(a, b, x)\nIncomplete Beta function (norm)\nbs=[1,2,5,7,9]  as=",
		0, 1
	],
	[   { |a, x, i| ibetaC(a, bs[i], x) },
		[as, xs],
		"ibetaC(a, b, x)\nComplement of Incomplete Beta function (norm)\nbs=[1,2,5,7,9]  as=",
		0, 1
	],
	[   { |a, x, i| betaFull(a, bs[i], x) },
		[as, xs],
		"betaFull(a, b, x)\nIncomplete Beta function (non-norm)\nbs=[1,2,5,7,9]  as=",
		0, 0.125
	],
	[   { |a, x, i| betaFullC(a, bs[i], x) },
		[as, xs],
		"betaFullC(a, b, x)\nComplement of the Incomplete Beta function (non-norm)\nbs=[1,2,5,7,9]  as=",
		0, 0.125
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Beta Functions, Incomplete and Derivative", 2);
)
::

SUBSECTION:: Incomplete Beta Function Inverses

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var abs = [9,7,5,2,1];
var bs = [1,2,5,7,9];
var xs = [ 0.1, 0.3, 0.5, 0.7, 0.9 ];
var pqs = (0.001, 0.005 .. 1);
var plotSpecs = [
	[   { |a, p, i| ibetaInv(a, bs[i], p) },
		[abs, pqs],
		format("ibetaInv(a, b, p)\nbs=%  as=", bs),
		0, 1
	],
	[   { |a, p, i| ibetaCInv(a, bs[i], p) },
		[abs, pqs],
		format("ibetaCInv(a, b, x)\nbs=%  as=", bs),
		0, 1
	],
	[   { |b, p, i| ibetaInvA(b, xs[i], p) },
		[abs, pqs],
		format("ibetaInvA(b, x, p)\nxs=%  bs=", xs),
		0, 18
	],
	[   { |b, q, i| ibetaCInvA(b, xs[i], q) },
		[abs, pqs],
		format("ibetaCInvA(b, x, q)\nxs=%  bs=", xs),
		0, 18
	],
	[   { |b, p, i| ibetaInvB(b, xs[i], p) },
		[abs, pqs],
		format("ibetaInvB(b, x, p)\nxs=%  bs=", xs),
		0, 18
	],
	[   { |b, q, i| ibetaCInvB(b, xs[i], q) },
		[abs, pqs],
		format("ibetaCInvB(b, x, q)\nxs=%  bs=", xs),
		0, 18
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Incomplete Beta Function Inverses", 4);
)
::


SECTION:: Error Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var erfSamps = (-3, -2.995 .. 3);
var plotSpecs = [
	[   \erf,
		erfSamps,
		"erf(z)\nError Function",
		-1, 1
	],
	[   \erfC,
		erfSamps,
		"erfC(z)\nComplement of the Error Function",
		0, 2
	],
	[   \erfInv,
		(-0.9995, -0.995 .. 1),
		"erfInv(z)\nInverse of the Error Function",
		-3, 2
	],
	[   \erfCInv,
		(0.001, 0.002 .. 1.999),
		"erfCInv(z)\nInverse of the Complement of the Error Function",
		-3, 2
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Error Function" );
)
::


SECTION:: Polynomials

SUBSECTION:: Legendre (and Associated) Polynomials

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   { |l, x| legendreP(l, x.clip(-1,1)) },
		[(1..4), (-1,-0.995 .. 1)],
		"legendreP(l, x)\nLegendre Polynomials of the First Kind \nls=",
		-1, 1
	],
	[   { |l, x| legendrePPrime(l, x.clip(-1,1)) },
		[(1..4), (-1,-0.995 .. 1)],
		"legendrePPrime(l, x)\nDerivatives of the Legendre Polynomials of the First Kind \nls=",
		-5, 5
	],
	[   { |l, x| legendreQ(l, x.clip(-0.9999,0.9999)) },
		[(1..4), (-1,-0.995 .. 1)],
		"legendreQ(l, x)\nLegendre Polynomials of the Second Kind \nls=",
		-1, 1
	],
	[   { |l, x, i| var ms = (l.neg..l); legendrePAssoc(l, ms[i], x.clip(-1,1)) },
		[1.dup(1*2+1), (-1,-0.995 .. 1)],
		"legendrePAssoc(l, m, x)\nAssociated Legendre Polynomials of the First Kind \nEach order (m) in degree l=",
		-3, 3
	],
	[   { |l, x, i| var ms = (l.neg..l); legendrePAssoc(l, ms[i], x.clip(-1,1)) },
		[2.dup(2*2+1), (-1,-0.995 .. 1)],
		"legendrePAssoc(l, m, x)\nAssociated Legendre Polynomials of the First Kind \nEach order (m) in degree l=",
		-3, 3
	],
	[   { |l, x, i| var ms = (l.neg..l); legendrePAssoc(l, ms[i], x.clip(-1,1)) },
		[4.dup(4*2+1), (-1,-0.995 .. 1)],
		"legendrePAssoc(l, m, x)\nAssociated Legendre Polynomials of the First Kind\nEach order (m) in degree l=",
		-150, 150
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Legendre (and Associated) Polynomials" );
)
::

SUBSECTION:: Laguerre (and Associated) Polynomials

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \laguerre,
		[(0..6), (-5, -4.995 .. 11)],
		"laguerre(n, x)\n Laguerre Polynomial\nns=",
		-10, 15
	],
	[   { |n, x, i| var ms = (0..n); laguerreAssoc(n, ms[i], x) },
		[3.dup(3+1), (-1, -0.95 .. 8)],
		"laguerreAssoc(n, m, x)\nAssociated Laguerre Polynomials of the First Kind\nOrder m = (0..n), degree n=",
		-10, 10
	],
	[   { |n, x, i| var ms = (0..n); laguerreAssoc(n, ms[i], x) },
		[7.dup(7+1), (-1, -0.95 .. 8)],
		"laguerreAssoc(n, m, x)\nAssociated Laguerre Polynomials of the First Kind\nOrder m = (0..n), degree n=",
		-65, 30
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Laguerre (and Associated) Polynomials", 1);
)
::


SUBSECTION:: Hermite Polynomials

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \hermite,
		[(0..4), (-2, -1.95 .. 2)],
		"hermite(n, x)\n Hermite Polynomial\nns=",
		-25, 25
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Hermite Polynomials");
)
::


SUBSECTION:: Chebyshev Polynomials

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var ns = (0..6);
var samps = (-1, -0.995 .. 1);
var plotSpecs = [
	[   \chebyshevT,
		[ns, samps],
		"chebyshevT(n, x)\nChebyshev Polynomial of the First Kind \nns=",
		-1, 1
	],
	[   \chebyshevU,
		[ns, samps],
		"chebyshevU(n, x)\nChebyshev Polynomial of the First Kind \nns=",
		-3, 3
	],
	[   \chebyshevTPrime,
		[ns, samps],
		"chebyshevTPrime(n, x)\nDerivative of the Chebyshev Polynomial of the First Kind \nns=",
		-15, 15
	],

];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Chebyshev Polynomials", 1 );
)
::

SUBSECTION:: Spherical Harmonics

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var samps = (-2pi, -1.995pi .. 2pi);
var dupN = { |n| n.dup(n*2+1) };
var plotSpecs = [
	[   { |n, theta, i| var ms = (n.neg..n), phi = -15.degrad;
			sphericalHarmonicR(n, ms[i], theta, phi)
		},
		[dupN.(3), samps],
		"sphericalHarmonicR(n, m, theta, phi)\nSpherical Harmonics (real part)\nm = (n.neg..n), phi = -15 deg, ns=",
		-1, 1
	],
	[   { |n, theta, i| var ms = (n.neg..n), phi = 85.degrad;
			sphericalHarmonicI(n, ms[i], theta, phi)
		},
		[dupN.(3), samps],
		"sphericalHarmonicI(n, m, theta, phi)\nSpherical Harmonics (imaginary part)\nm = (n.neg..n), phi = 85 deg, ns=",
		-1, 1
	],
	[   { |n, theta, i| var ms = (n.neg..n), phi = 25.degrad;
			sphericalHarmonicR(n, ms[i], theta, phi)
		},
		[dupN.(9), samps],
		"sphericalHarmonicR(n, m, theta, phi)\nSpherical Harmonics (real part)\nm = (n.neg..n), phi = 25 deg, ns=",
		-1.5, 1.5
	],
	[   { |n, theta, i| var ms = (n.neg..n), phi = 45.degrad;
			sphericalHarmonicI(n, ms[i], theta, phi)
		},
		[dupN.(5), samps],
		"sphericalHarmonicI(n, m, theta, phi)\nSpherical Harmonics (imaginary part)\nm = (n.neg..n), phi = 45 deg, ns=",
		-1, 1
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Spherical Harmonics" );
)
::


SECTION:: Bessel Functions

SUBSECTION:: Bessel and Modified Bessel Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \cylBesselJ,
		[(0..4), (-20,-19.9 .. 20)],
		"cylBesselJ(v, x)\nBessel Function of the First Kind \nvs=",
		-1, 1
	],
	[   \cylNeumann,
		[(0..4), (0.001, 0.05 .. 20)],
		"cylNeumann(v, x)\nBessel Function of the Second Kind (Neumann) \nvs=",
		-3, 1
	],
	[   \cylBesselI,
		[[0,2,5,7,10], (-10, -9.95 .. 10)],
		"cylBesselI(v, x)\nModified Bessel Function of the First Kind \nvs=",
		-15, 15
	],
	[   \cylBesselK,
		[[0,2,5,7,10], (0.15, 0.25 .. 10)],
		"cylBesselK(v, x)\nModified Bessel Function of the Second Kind \nvs=",
		0, 4
	],
	[   \sphBessel,
		[(0..4), (0, 0.05 .. 20)],
		"sphBessel(v, x)\nSpherical Bessel Function of the First Kind \nvs=",
		-1, 1
	],
	[   \sphNeumann,
		[(0..4), (0.001, 0.05 .. 20)],
		"sphNeumann(v, x)\nSpherical Bessel Function of the Second Kind (Spherical Neumann) \nvs=",
		-3, 1
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Bessel Functions", 2 );
)
::

SUBSECTION:: Derivatives of Bessel and Modified Bessel Functions
Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var bPrimeVs = (0..5);
var modBPrimeVs = [0,2,5,7,10];
var plotSpecs = [
	[   \cylBesselJPrime,
		[bPrimeVs, (-20,-19.9 .. 20)],
		"cylBesselJPrime(v, x)\nDerivative of the Bessel Function of the First Kind \nvs=",
		-1, 1
	],
	[   \cylNeumannPrime,
		[bPrimeVs, (0.04, 0.05 .. 20)],
		"cylNeumannPrime(v, x)\nDerivative of the Bessel Function of the Second Kind \nvs=",
		-1, 2
	],
	[   \cylBesselIPrime,
		[modBPrimeVs, (-10, -9.95 .. 10)],
		"cylBesselIPrime(v, x)\nDerivative of the Modified Bessel Function of the First Kind \nvs=",
		-25, 25
	],
	[   \cylBesselKPrime,
		[modBPrimeVs, (0.01, 0.05 .. 10)],
		"cylBesselKPrime(v, x)\nDerivative of the Modified Bessel Function of the Second Kind \nvs=",
		-0.5, 0
	],
	[   \sphBesselPrime,
		[modBPrimeVs, (0.001, 0.05 .. 20)],
		"sphBesselPrime(v, x)\nDerivative of the Spherical Bessel Function of the First Kind \nvs=",
	],
	[   \sphNeumannPrime,
		[modBPrimeVs, (1.13, 1.15 .. 20)],
		"sphNeumannPrime(v, x)\nDerivative of the Spherical Bessel Function of the Second Kind \nvs=",
		-0.5, 0.5
	],
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Derivatives of Bessel Functions", 2);
)
::


SECTION:: Hankel Functions

SUBSECTION:: Cyclic Hankel Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var ns = (0..3);
var range = (0.001, 0.025 .. 6);
var plotSpecs = [
	[   { |n, z| cylHankel1(n,z).real },
		[ns, range],
		"cylHankel1(n,z).real\nCyclic Hankel Function of the First Kind (real part)\nns=",
		-1, 1.5
	],
	[   { |n, z| cylHankel1(n,z).imag },
		[ns, range],
		"cylHankel1(n,z).imag\nCyclic Hankel Function of the First Kind (imaginary part)\nns=",
		-2, 1
	],
	[   { |n, z| cylHankel2(n,z).real },
		[ns, range],
		"cylHankel2(n,z).real\nCyclic Hankel Function of the Second Kind (real part)\nns=",
		-1, 1.5
	],
	[   { |n, z| cylHankel2(n,z).imag },
		[ns, range],
		"cylHankel2(n,z).imag\nCyclic Hankel Function of the Second Kind (imaginary part)\nns=",
		-1, 2
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Cyclic Hankel Functions" );
)
::

SUBSECTION:: Spherical Hankel Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var ns = (0..3);
var range = (0.001, 0.025 .. 6);
var plotSpecs = [
	[   { |n, z| sphHankel1(n,z).real },
		[ns, range],
		"sphHankel1(n,z).real\nSpherical Hankel Function of the First Kind (real part)\nns=",
		-1, 2
	],
	[   { |n, z| sphHankel1(n,z).imag },
		[ns, range],
		"sphHankel1(n,z).imag\nSpherical Hankel Function of the First Kind (imaginary part)\nns=",
		-2, 1
	],
	[   { |n, z| sphHankel2(n,z).real },
		[ns, range],
		"sphHankel2(n,z).real\nSpherical Hankel Function of the Second Kind (real part)\nns=",
		-1, 2
	],
	[   { |n, z| sphHankel2(n,z).imag },
		[ns, range],
		"sphHankel2(n,z).imag\nSpherical Hankel Function of the Second Kind (imaginary part)\nns=",
		-1, 2
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Spherical Hankel Functions" );
)
::


SECTION:: Airy Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var aiSamps = (-20, -19.95 .. 20);
var biSamps = (-20, -19.95 .. 3);
// generate sample points starting from a zero
var genSamps = { |selector, zeroDex|
	var zero = zeroDex.perform(selector);
	(zero, zero - (zero*0.001) .. 0)
};
var plotSpecs = [
	[ \airyAi, aiSamps, "airyAi(z)"],
	[ \airyBi, biSamps, "airyBi(z)", -2,15],
	[ \airyAiPrime, aiSamps, "airyAiPrime(z)", -1.2, 1.2],
	[ \airyBiPrime, biSamps, "airyBiPrime(z)", -1.2, 1.2],
	[   \airyAi,
		genSamps.(\airyAiZero, 7),
		"AiryAi from 7th zero\nairyAiZero(n)"
	],
	[   \airyBi,
		genSamps.(\airyBiZero, 7),
		"AiryBi from 7th zero\nairyBiZero(n)"
	]
];

~layOutPlots.( plotSpecs.collect { |data| ~multiPlot.(*data) }, "Airy Functions" );
)
::


SECTION:: Elliptic Integrals

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var samps = (-1, -0.995 ..1);
var args1 = [0.5,0.75,1.25,pi/2]; // phis for first/second kind
var args2 = [0, 0.5, 0.25, 0.75]; // ns/phis for third kind, D, Zeta, Lambda Funcs
var plotSpecs = [
	[   { |phi, k| ellint1(k.clip(-1,1), phi) },
		[args1, samps],
		"ellint1(k,phi)\nElliptic Integrals of the First Kind (Inomplete) \nphis=",
		0.5, 2.5
	],
	[   { |k| ellint1C(k.clip(-0.999,0.999)) },
		samps,
		"ellint1C(k)\nElliptic Integrals of the First Kind (Complete)",
		0.5, 2.5
	],
	[   { |phi, k| ellint2(k.clip(-1,1), phi) },
		[args1, samps],
		"ellint2(k,phi)\nElliptic Integrals of the Second Kind (Inomplete) \nphis=",
		0.4, 1.6
	],
	[   { |k| ellint2C(k.clip(-1,1)) },
		samps,
		"ellint2C(k)\nElliptic Integrals of the Second Kind (Complete)",
		0.5, 1.5
	],
	[   { |n, k, i|
			var phis = [1.25,1.25,pi/2,pi/2];
			ellint3(k.clip(-1,1), n, phis[i])
		},
		[args2, samps],
		"ellint3(k,n,phi)\nElliptic Integrals of the Third Kind (Incomplete) \nphis=[1.25,1.25,pi/2,pi/2], ns=",
		1, 4
	],
	[   { |n, k| ellint3C(k.clip(-0.999,0.999), n) },
		[args2, samps],
		"ellint3C(n,k)\nElliptic Integrals of the Third Kind (Complete) \nns=",
		1, 4
	],
	[   { |phi, k| ellintD(k.clip(-1,1), phi) },
		[args2, samps],
		"ellintD(k, phi)\nElliptic Integral D (Incomplete) \nphis=",
		0, 0.2
	],
	[   { |k| ellintDC(k.clip(-0.999,0.999)) },
		samps,
		"ellintDC(k, phi)\nElliptic Integral D (Complete)",
		0.5, 1.5
	],
	[   { |phi, k| jacobiZeta(k.clip(-0.999,0.999), phi) },
		[args2, samps],
		"jacobiZeta(k,phi)\nJacobi Zeta Function \nphis=",
		0, 0.3
	],
	[   { |phi, k| heumanLambda(k.clip(-0.999,0.999), phi) },
		[args2, samps],
		"heumanLambda(k,phi)\nHeuman Lambda Function \nphis=",
		0, 0.7
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Elliptic Integrals" );
)
::


SECTION:: Jacobi Elliptic Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs =
[
	\Cd, [-10, 10], \Cn, [-10, 10], \Cs, [0, 3], \Dc, [-10, 10], \Dn, [-10, 10], \Ds, [0, 3],
	\Nc, [-5, 5], \Nd, [-2, 2], \Ns, [0,4], \Sc, [-5,5], \Sd, [-2.5, 2.5], \Sn, [-10,10]
].clump(2).collect{ |nameRange, i|
	var method, variant, range, us, step;
	var data, max, min, clipplot = 8;
	var samps = 500, ks = [0, 0.5, 0.75, 0.95, 1];

	#variant, range = nameRange;
	step = range[1] - range[0] / samps;
	us = (range[0], range[0]+step .. range[1]);
	method = (\jacobi ++ variant).asSymbol;
	data = ks.collect { |k|
		us.collect { |u| k.perform(method, u) }
	}.flat;
	[
		method,
		[ks, us],
		format("jacobi%(k,u)\nk's=", variant),
		max(data.minItem, clipplot.neg)*1.1, min(data.maxItem, clipplot)*1.1,
	];
};
~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Jacobi Elliptic Functions" );
)
::


SECTION:: Zeta Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \zeta,
		(-28, -27.95 .. 5),
		"zeta(z)",
		-75, 100
	],
	[   \zeta,
		(-15, -14.95 .. 0),
		"zeta(z)",
		-0.2, 0.05
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Riemann Zeta Function" );
)
::


SECTION:: Exponential Integrals

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \expintEn,
		[[1,2,3,4], (0.0001, 0.01 .. 2)],
		"expintEn(z)\nns = ",
		0,1
	],
	[   \expintEi,
		(-3, -2.99 .. 4),
		"expintEi(z)",
		-18,18
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Exponential Integrals" );
)
::


SECTION:: Basic Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \sinPi,
		(0, 0.1 .. 8),
		"sinPi(x)",
	],
	[   \cosPi,
		(0, 0.1 .. 8),
		"cosPi(x)",
	],
	[   \log1p,
		(-0.999, -0.994 .. 10),
		"log1p(x)",
	],
	[   \expm1,
		(-4, -3.995 .. 2),
		"expm1(x)",
	],
	[   \cbrt,
		(-10, -9.95 .. 10),
		"cbrt(x)",
	],
	[   \sqrt1pm1,
		(-0.999, -0.994 .. 5),
		"sqrt1pm1(x)",
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Basic Functions" );
)
::


SECTION::  Sinus Cardinal (Sinc) and Hyperbolic Sinus Cardinal Functions, Inverse Hyperbolic Functions

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   \sincPi,
		(-40, -39.95 ..40),
		"sincPi(x)\nSinus Cardinal (\"sinc\") Function\n(note: plot should be centered at 0)",
	],
	[   \sinhcPi,
		(-5, -4.95 ..5),
		"sinhcPi(x)\nHyperbolic Sinus Cardinal Function\n(note: plot should be centered at 0)",
	],
	[   \acosh,
		(1, 1.05 .. 10),
		"acosh(x)\nReciprocal of the hyperbolic cosine function",
	],
	[   \asinh,
		(-10, -9.99 ..10),
		"asinh(x)\nReciprocal of the hyperbolic sine function",
	],
	[   \atanh,
		(-0.999, -0.995 .. 0.999),
		"atanh(x)\nReciprocal of the hyperbolic tangent function",
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Sinus & Hyperbolic Sinus Cardinal, Inverse Hyperbolic Functions" );
)
::

SECTION:: Owen's T Function

Be sure to define code::~layOutPlots:: and code::~multiPlot:: at the link::#Before you get started...#top of the page::.
CODE::
(
var plotSpecs = [
	[   { |a, h| owensT(h, a) },
		[(-6, -5.5 .. 6),(-5, -4.995 ..5)],
		"owensT(h, a)\nOwen's T Function\nh = ",
		-0.4, 0.4
	]
];

~layOutPlots.( plotSpecs.collect{ |data| ~multiPlot.(*data) }, "Owen's T Function" );
)
::


title:: Tour of UGens
summary:: Signal Processing in SuperCollider
related:: Browse#UGens
categories:: UGens, Server>Nodes

definitionlist::
## 1. A Tour of available Unit Generators.
|| SuperCollider has over 250 unit generators.
   If you count the unary and binary operators, there are over 300.
   This tour covers many, but not all of them.

    categories of unit generators:
    list::
    ## sources: periodic, aperiodic
    ## filters
    ## distortion
    ## panning
    ## reverbs
    ## delays and buffer ugens
    ## granular synthesis
    ## control: envelopes, triggers, counters, gates, lags, decays
    ## spectral
    ::

## 2. Techniques
||
    list::
    ## artificial space - decorrelation, beat frequencies, delays.
    ## series and parallel structures.
    ::
::

Note: The link::Browse#UGens#category browser:: contains a category for UGens, which provides another useful way to get an overview of the available UGens, including those which were created since this tour was written.

code::
(
s.boot;
)
::

section:: Periodic Sources: Oscillators.

subsection:: LF - "Low Frequency" Unit Generators.

link::Classes/LFPar::, link::Classes/LFCub::, link::Classes/LFTri::, link::Classes/Impulse::, link::Classes/LFSaw::, link::Classes/LFPulse::, link::Classes/VarSaw::, link::Classes/SyncSaw:: - has geometric waveforms, not band limited.
will cause aliasing at higher frequencies.

definitionlist::
## link::Classes/LFPar::, link::Classes/LFCub::, link::Classes/LFTri::, link::Classes/LFSaw::, link::Classes/Impulse::
|| arguments: code::frequency, phase, mul, add::

code::
// parabolic approximation of sine
{ LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFPar.ar(800,0,0.1) }.scope(1, zoom: 4);
// since it is not band limited, there are aliasing artifacts
{ LFPar.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::
code::
// cubic approximation of sine
{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFCub.ar(800,0,0.1) }.scope(1, zoom: 4);
{ LFCub.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::
code::
{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFTri.ar(800,0,0.1) }.scope(1, zoom: 4);
{ LFTri.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::
code::
{ LFSaw.ar(LFSaw.kr(LFSaw.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFSaw.ar(LFSaw.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ LFSaw.ar(100,0,0.1) }.scope(1, zoom: 4);
{ LFSaw.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::
code::
{ Impulse.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ Impulse.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ Impulse.ar(100,0,0.1) }.scope(1, zoom: 4);
{ Impulse.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::

## link::Classes/LFPulse::, link::Classes/VarSaw::
|| arguments: code::frequency, phase, width, mul, add::

code::
{ LFPulse.ar(LFPulse.kr(LFPulse.kr(0.2,0,0.5,8,10),0,0.5, 400,800),0,0.5,0.1) }.scope(1, zoom: 4);
{ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) }.scope(1, zoom: 4);
{ LFPulse.ar(XLine.kr(100,15000,6),0,0.5,0.1) }.scope(1, zoom: 4);
::
code::
// pulse width modulation
{ LFPulse.ar(100,0,MouseY.kr(0,1),0.1) }.scope(1, zoom: 4);
{ LFPulse.ar(100,0,LFTri.kr(0.2,0,0.5,0.5),0.1) }.scope(1, zoom: 4);
::
code::
{ VarSaw.ar(VarSaw.kr(VarSaw.kr(0.2,0,0.2,8,10),0,0.2, 400,800),0,0.2,0.1) }.scope(1, zoom: 4);
{ VarSaw.ar(VarSaw.kr(0.2, 0, 0.2, 400,800),0,0.2,0.1) }.scope(1, zoom: 4);
{ VarSaw.ar(XLine.kr(100,15000,6),0,0.2,0.1) }.scope(1, zoom: 4);
::
code::
// pulse width modulation
{ VarSaw.ar(100,0,MouseY.kr(0,1),0.1) }.scope(1, zoom: 4);
{ VarSaw.ar(100,0,LFTri.kr(0.2,0,0.5,0.5),0.1) }.scope(1, zoom: 4);
::

## link::Classes/SyncSaw::
|| arguments: code::syncFreq, sawFreq, mul, add::

code::
{ SyncSaw.ar(100, MouseX.kr(100, 1000), 0.1) }.scope(1, zoom: 4);
{ SyncSaw.ar(100, Line.kr(100, 800, 12), 0.1) }.scope(1, zoom: 4);
::
::

subsection:: Band Limited Oscillators

link::Classes/SinOsc::, link::Classes/FSinOsc::, link::Classes/Blip::, link::Classes/Saw::, link::Classes/Pulse:: - will not alias.

definitionlist::
## link::Classes/SinOsc::, link::Classes/FSinOsc::
|| arguments: code::frequency, phase, mul, add::
code::
{ SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.scope(1, zoom: 4);
{ SinOsc.ar(800,0,0.1) }.scope(1, zoom: 4);
{ SinOsc.ar(XLine.kr(100,15000,6),0,0.1) }.scope(1, zoom: 4);
::
code::
{ FSinOsc.ar(800,0,0.1) }.scope(1, zoom: 4);
// FSinOsc should not be frequency modulated.
// Since it is based on a filter at the edge of stability, it will blow up:
{ FSinOsc.ar(FSinOsc.kr(FSinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4);
::

## link::Classes/Blip::
|| arguments: code::frequency, numHarmonics, mul, add::
code::
{ Blip.ar(XLine.kr(20000,200,6),100,0.2) }.scope(1);
{ Blip.ar(XLine.kr(100,15000,6),100,0.2) }.scope(1); // no aliasing
// modulate number of harmonics
{ Blip.ar(200,Line.kr(1,100,20),0.2) }.scope(1);
::

## link::Classes/Saw::
|| arguments: code::frequency, mul, add::
code::
{ Saw.ar(XLine.kr(20000,200,6),0.2) }.scope(1);
{ Saw.ar(XLine.kr(100,15000,6),0.2) }.scope(1); // no aliasing
::

## link::Classes/Pulse::
|| arguments: code::frequency, width, mul, add::
code::
{ Pulse.ar(XLine.kr(20000,200,6),0.3,0.2) }.scope(1);
{ Pulse.ar(XLine.kr(100,15000,6),0.3,0.2) }.scope(1); // no aliasing

// modulate pulse width
{ Pulse.ar(200, Line.kr(0.01,0.99,8), 0.2) }.scope(1);

// two band limited square waves thru a resonant low pass filter
{ RLPF.ar(Pulse.ar([100,250],0.5,0.1), XLine.kr(8000,400,5), 0.05) }.scope(1);
::

## link::Classes/Klang:: - sine oscillator bank
|| arguments: code:: `[ frequencies, amplitudes, phases ], mul, add ::
code::
{ Klang.ar(`[ [800, 1000, 1200],[0.3, 0.3, 0.3],[pi,pi,pi]], 1, 0) * 0.4}.scope(1);

{ Klang.ar(`[ {exprand(400, 2000)}.dup(16), nil, nil ], 1, 0) * 0.04 }.scope(1);
::
::

subsection:: Table Oscillators

link::Classes/Osc::, link::Classes/COsc::, link::Classes/VOsc::, link::Classes/VOsc3:: - uses a buffer allocated on the server.

code::
(
b = Buffer.alloc(s, 2048, 1, bufnum: 80);
b.sine1(1.0/(1..6), true, true, true);
)
::

definitionlist::
## link::Classes/Osc::
|| arguments: code:: buffer number, frequency, phase, mul, add ::

code::
{ Osc.ar(80, 100, 0, 0.1) }.scope(1, zoom:4);

b.sine1(1.0/(1..12));
b.sine1(1.0/(1..24));
b.sine1(1.0/(1..32));
b.sine1([1.0/(1,3..12), 0].flop.flat.postln);
b.sine1([1.0/(1,3..32).squared, 0].flop.flat.postln);
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
b.sine1({1.0.rand2.cubed}.dup(8).round(1e-3).postln);
b.sine1({1.0.rand2.cubed}.dup(12).round(1e-3).postln);
b.sine1({1.0.rand2.cubed}.dup(16).round(1e-3).postln);
b.sine1({1.0.rand2.cubed}.dup(24).round(1e-3).postln);
::

## link::Classes/COsc:: - two oscillators, detuned
|| arguments: code:: buffer number, frequency, beat frequency, mul, add ::
code::
b.sine1(1.0/(1..6), true, true, true);

{ COsc.ar(80, 100, 1, 0.1) }.scope(1, zoom:4);
// change buffer as above.
::

## link::Classes/VOsc:: - multiple wave table crossfade oscillators
|| arguments: code:: buffer number, frequency, phase, mul, add ::
code::
(
// allocate tables 80 to 87
8.do {|i| s.sendMsg(\b_alloc, 80+i, 1024); };
)

(
// fill tables 80 to 87
8.do({|i|
	var n, a;
	// generate array of harmonic amplitudes
	n = (i+1)**2; // num harmonics for each table: [1,4,9,16,25,36,49,64]
	a = {|j| ((n-j)/n).squared }.dup(n);
	// fill table
	s.listSendMsg([\b_gen, 80+i, \sine1, 7] ++ a);
});
)

{ VOsc.ar(MouseX.kr(80,87), 120, 0, 0.3) }.scope(1, zoom:4);

(
// allocate and fill tables 80 to 87
8.do({|i|
	// generate array of harmonic amplitudes
	a = {1.0.rand2.cubed }.dup((i+1)*4);
	// fill table
	s.listSendMsg([\b_gen, 80+i, \sine1, 7] ++ a);
});
)
::

## link::Classes/VOsc3:: - three VOscs summed.
|| arguments: code:: buffer number, freq1, freq2, freq3, beat frequency, mul, add ::
code::
// chorusing
{ VOsc3.ar(MouseX.kr(80,87), 120, 121.04, 119.37, 0.2) }.scope(1, zoom:4);

// chords
{ VOsc3.ar(MouseX.kr(80,87), 120, 151.13, 179.42, 0.2) }.scope(1, zoom:4);
::
::

section:: Aperiodic Sources: Noise.

subsection:: LF "Low Frequency" Noise Generators.

definitionlist::
## link::Classes/LFNoise0::, link::Classes/LFNoise1::, link::Classes/LFNoise2::, link::Classes/LFClipNoise::
|| arguments: code:: frequency, mul, add ::
code::
{ LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.scope(1);
{ LFNoise0.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);
{ LFNoise1.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);
{ LFNoise2.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);

// used as controls
{ LFPar.ar(LFClipNoise.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8);
{ LFPar.ar(LFNoise0.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8);
{ LFPar.ar(LFNoise1.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8);
{ LFPar.ar(LFNoise2.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8);
::
::

subsection:: Broad Spectrum Noise Generators

definitionlist::
## link::Classes/ClipNoise::, link::Classes/WhiteNoise::, link::Classes/PinkNoise::, link::Classes/BrownNoise::, link::Classes/GrayNoise::
|| arguments: code:: mul, add ::
code::
{ ClipNoise.ar(0.2) }.scope(1);
{ WhiteNoise.ar(0.2) }.scope(1);
{ PinkNoise.ar(0.4) }.scope(1);
{ BrownNoise.ar(0.2) }.scope(1);
{ GrayNoise.ar(0.2) }.scope(1);
::
::

subsection:: Impulse Noise Generators

definitionlist::
## link::Classes/Dust::, link::Classes/Dust2::
|| arguments: code:: density, mul, add ::
code::
{ Dust.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4);
{ Dust2.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4);
::
::

subsection:: Chaotic Noise Generators

definitionlist::
## link::Classes/Crackle::
|| arguments: code:: chaosParam, mul, add ::
code::
{ Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1);
::
::

section:: Filters

subsection:: Low Pass, High Pass

definitionlist::
## link::Classes/LPF::, link::Classes/HPF:: - 12 dB / octave
|| arguments: code:: in, freq, mul, add ::
code::
{ LPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1);
{ HPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1);
{ LPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) }.scope(1);
{ HPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) }.scope(1);
::
::

subsection:: Band Pass, Band Cut

definitionlist::
## link::Classes/BPF::, link::Classes/BRF:: - 12 dB / octave
|| arguments: code:: in, freq, rq, mul, add ::

rq is the reciprocal of the Q of the filter,
or in other words: the bandwidth in Hertz = rq * freq.
code::
{ BPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.4, 0.4) }.scope(1);
{ BRF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.4, 0.2) }.scope(1);
{ BPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.4, 0.4) }.scope(1);
{ BRF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.4, 0.2) }.scope(1);

// modulating the bandwidth
{ BPF.ar(WhiteNoise.ar, 3000, MouseX.kr(0.01,0.7,1), 0.4) }.scope(1);
::
::

subsection:: Resonant Low Pass, High Pass, Band Pass

definitionlist::
## link::Classes/RLPF::, link::Classes/RHPF:: - 12 dB / octave
|| arguments: code:: in, freq, rq, mul, add ::
code::
{ RLPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);
{ RHPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);
{ RLPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);
{ RHPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);
::

## link::Classes/Resonz:: - resonant band pass filter with uniform amplitude
|| arguments: code:: in, freq, rq, mul, add ::
code::
// modulate frequency
{ Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.scope(1);

// modulate bandwidth
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(1, 0.001, 8)) }.scope(1);

// modulate bandwidth opposite direction
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(0.001, 1, 8)) }.scope(1);
::

## link::Classes/Ringz:: - ringing filter.
|| arguments: code:: in, frequency, ring time, mul, add ::

Internally it is the same as Resonz but the bandwidth is expressed as a ring time.
code::
{ Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.scope(1, zoom:4);

{ Ringz.ar(WhiteNoise.ar(0.005), 2000, 0.5) }.scope(1);

// modulate frequency
{ Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.scope(1, zoom:4);

{ Ringz.ar(Impulse.ar(6, 0, 0.3),  XLine.kr(100,3000,10), 0.5) }.scope(1, zoom:4);

// modulate ring time
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(0.04, 4, 8)) }.scope(1, zoom:4);
::
::

subsection:: Simpler Filters
definitionlist::
## link::Classes/OnePole::, link::Classes/OneZero:: - 6 dB / octave
||
code::
{ OnePole.ar(WhiteNoise.ar(0.5), MouseX.kr(-0.99, 0.99)) }.scope(1);
{ OneZero.ar(WhiteNoise.ar(0.5), MouseX.kr(-0.49, 0.49)) }.scope(1);
::
::

subsection:: NonLinear Filters
definitionlist::
## link::Classes/Median::, link::Classes/Slew::
||
code::
// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1);
// after applying median filter
{ Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.scope(1);

// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1);
// after applying slew rate limiter
{ Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.scope(1);
::
::

subsection:: Formant Filter
definitionlist::
## link::Classes/Formlet:: - A filter whose impulse response is similar to a FOF grain.
||
code::
{ Formlet.ar(Impulse.ar(MouseX.kr(2,300,1), 0, 0.4), 800, 0.01, 0.1) }.scope(1, zoom:4);
::

## link::Classes/Klank:: - resonant filter bank
|| arguments: code:: `[ frequencies, amplitudes, ring times ], mul, add ::

code::
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ Klank.ar(`[ {exprand(200, 4000)}.dup(12), nil, nil ], PinkNoise.ar(0.007)) }.scope(1);

{ Klank.ar(`[ (1..13)*200, 1/(1..13), nil ], PinkNoise.ar(0.01)) }.scope(1);

{ Klank.ar(`[ (1,3..13)*200, 1/(1,3..13), nil ], PinkNoise.ar(0.01)) }.scope(1);
::
::

section:: Distortion

definitionlist::
## abs, max, squared, cubed
||
code::
{ SinOsc.ar(300, 0, 0.2) }.scope(1);
{ SinOsc.ar(300, 0, 0.2).abs }.scope(1);
{ SinOsc.ar(300, 0, 0.2).max(0) }.scope(1);
{ SinOsc.ar(300, 0).squared * 0.2 }.scope(1);
{ SinOsc.ar(300, 0).cubed * 0.2 }.scope(1);
::

## distort, softclip, clip2, fold2, wrap2,
||
code::
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).distort * 0.2 }.scope(1);
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).softclip * 0.2 }.scope(1);
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).clip2(1) * 0.2 }.scope(1);
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).fold2(1) * 0.2 }.scope(1);
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1);
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1);
::

## scaleneg
||
code::
{ SinOsc.ar(200, 0, 0.2).scaleneg(MouseX.kr(-1,1)) }.scope(1);
::

## waveshaping by phase modulating a 0 Hz sine oscillator
|| (currently there is a limit of 8pi)
code::
(
{
	var in;
	in = SinOsc.ar(300, 0, MouseX.kr(0.1,8pi,1));
	SinOsc.ar(0, in, 0.2); // 0 Hz sine oscillator
}.scope(1);
)
::

## link::Classes/Shaper:: - input is used to look up a value in a table.
|| Chebyshev polynomials are typically used to fill the table.

code::
s.sendMsg(\b_alloc, 80, 1024); // allocate table
// fill with chebyshevs
s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));

{ Shaper.ar(80, SinOsc.ar(600, 0, MouseX.kr(0,1))) * 0.3; }.scope(1);

s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));
s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));
::
::

section:: Panning
code::
(
s.quit;
s.options.numOutputBusChannels = 8;
s.options.numInputBusChannels = 8;
s.boot;
)
::

definitionlist::
## link::Classes/Pan2:: - equal power stereo pan a mono source
|| arguments: code:: in, pan position, level ::

pan controls typically range from -1 to +1

code::
{ Pan2.ar(BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.scope(2);
{ Pan2.ar(BrownNoise.ar, SinOsc.kr(0.2), 0.3) }.scope(2);
::

## link::Classes/LinPan2:: - linear pan a mono source (not equal power)
|| arguments: code:: in, pan position, level ::

code::
{ LinPan2.ar(BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.scope(2);
{ LinPan2.ar(BrownNoise.ar, SinOsc.kr(0.2), 0.3) }.scope(2);
::

## link::Classes/Balance2:: - balance a stereo source
|| arguments: code:: left in, right in, pan position, level ::
code::
{ Balance2.ar(BrownNoise.ar, BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.scope(2);
::

## link::Classes/Pan4:: - equal power quad panner
||
code::
{ Pan4.ar(BrownNoise.ar, MouseX.kr(-1,1), MouseY.kr(1,-1), 0.3) }.scope(4);
::

## link::Classes/PanAz:: - azimuth panner to any number of channels
|| arguments: code:: num channels, in, pan position, level, width ::
code::
{ PanAz.ar(5, BrownNoise.ar, MouseX.kr(-1,1), 0.3, 2) }.scope(5);

// change width to 3
{ PanAz.ar(5, BrownNoise.ar, MouseX.kr(-1,1), 0.3, 3) }.scope(5);
::

## link::Classes/XFade2:: - equal power cross fade between two inputs
|| arguments: code:: in1, in2, crossfade, level ::
code::
{ XFade2.ar(BrownNoise.ar, SinOsc.ar(500), MouseX.kr(-1,1), 0.3) }.scope(1);
::

## link::Classes/PanB2:: and link::Classes/DecodeB2:: - 2D ambisonics panner and decoder
||
code::
(
{
	var w, x, y, p, lf, rf, rr, lr;

	p = BrownNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.3);

	// B-format decode to quad. outputs in clockwise order
	#lf, rf, rr, lr = DecodeB2.ar(4, w, x, y);

	[lf, rf, lr, rr] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.scope(4);
)
::

## link::Classes/Rotate2:: - rotate a sound field of ambisonic or even stereo sound.
||
code::
(
{
	// rotation of stereo sound via mouse
	var x, y;
	x = Mix.fill(4, { LFSaw.ar(200 + 2.0.rand2, 0, 0.1) }); // left in
	y = WhiteNoise.ar * LFPulse.kr(3,0,0.7,0.2); // right in
	#x, y = Rotate2.ar(x, y, MouseX.kr(0,2));
	[x,y]
}.scope(2);
)
::
::

section:: Reverbs

definitionlist::
## link::Classes/FreeVerb::
||
code::
(
{
	// play with the room size
	var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
	x = Pan2.ar(x, -0.2);
	x = [x[0], DelayC.ar(x[1], 0.01, 0.01)]; // de-correlate
	FreeVerb.ar(x, 0.75, 0.9, 0.4);
}.scope;
)
::

## link::Classes/GVerb::
||
code::
(
{
	// play with the room size
	var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
	GVerb.ar(x, 105, 5, 0.7, 0.8, 60, 0.1, 0.5, 0.4) + x;
}.scope;
)
::
::

section:: Delays and Buffer UGens

definitionlist::
## link::Classes/DelayN::, link::Classes/DelayL::, link::Classes/DelayC:: - simple delays
||
list::
## N - no interpolation
## L - linear interpolation
## C - cubic interpolation
::
arguments: code:: in, maximum delay time, current delay time, mul, add ::

code::
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input
}.scope(1, zoom: 4)
)
::
code::
(
{
z = Decay.ar(Impulse.ar(2,0,0.4), 0.3, WhiteNoise.ar);
DelayL.ar(z, 0.3, MouseX.kr(0,0.3), 1, z); // input is mixed with delay via the add input
}.scope(1, zoom: 4)
)
::

## link::Classes/CombN::, link::Classes/CombL::, link::Classes/CombC:: - feedback delays
|| arguments: code:: in, maximum delay time, current delay time, echo decay time, mul, add ::

code::
// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.scope(1, zoom:4);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.scope(1, zoom:4);
::

## link::Classes/AllpassN::, link::Classes/AllpassL::, link::Classes/AllpassC:: - allpass delay
|| arguments: code:: in, maximum delay time, current delay time, echo decay time, mul, add ::
code::
(
{
	var z;
	z = Decay.ar(Dust.ar(1,0.5), 0.1, WhiteNoise.ar);
	8.do { z = AllpassL.ar(z, 0.04, 0.04.rand, 2) };
	z
}.scope(1);
)
::

## link::Classes/PlayBuf:: - buffer playback
|| arguments: code:: numChannels, buffer number, rate, trigger, start pos, loop ::
code::
// read sound
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

{ SinOsc.ar(800 + (700 * PlayBuf.ar(1,b, BufRateScale.kr(b),  loop:1)),0,0.3) }.scope(1);

// loop is true
{ PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1) }.scope(1);
::
code::
// trigger one shot on each pulse
(
{
	var trig;
	trig = Impulse.kr(2.0);
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,0,0);
}.scope(1);
)

// trigger one shot on each pulse
(
{
	var trig;
	trig = Impulse.kr(XLine.kr(0.1,100,30));
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,5000,0);
}.scope(1);
)
::
code::
// mouse control of trigger rate and startpos
(
{
	var trig;
	trig = Impulse.kr(MouseY.kr(0.5,200,1));
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,MouseX.kr(0,BufFrames.kr(b)),1)
}.scope(1);
)

// accelerating pitch
(
{
	var rate;
	rate = XLine.kr(0.1,100,60);
	PlayBuf.ar(1, b, rate, 1.0,0.0, 1.0)
}.scope(1);
)

// sine wave control of playback rate. negative rate plays backwards
(
{
	var rate;
	rate = FSinOsc.kr(XLine.kr(0.2,8,30), 0, 3, 0.6);
	PlayBuf.ar(1,b,BufRateScale.kr(b)*rate,1,0,1)
}.scope(1);
)

// zig zag around sound
(
{
	var rate;
	rate = LFNoise2.kr(XLine.kr(1,20,60), 2);
	PlayBuf.ar(1,b,BufRateScale.kr(b) * rate,1,0,1)
}.scope(1);
)


// free sound
b.free;
::
::

section:: Granular Synthesis.

definitionlist::
## link::Classes/TGrains:: - granulation of a buffer
|| arguments: code:: numChannels, trigger, buffer number, rate, center pos, dur, pan, amp, interpolation ::
code::
// read sound
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var trate, dur;
	trate = MouseY.kr(2,200,1);
	dur = 4 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, 1, MouseX.kr(0,BufDur.kr(b)), dur, 0, 0.1, 2);
}.scope(2, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)

// 4 channels
(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1);
}.scope(4, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 4 / trate;
	clk = Dust.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)



(
{
	var trate, dur, clk, pos, pan;
	trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120);
	dur = 12 / trate;
	clk = Impulse.ar(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)


(
{
	var trate, dur, clk, pos, pan;
	trate = 12;
	dur = MouseY.kr(0.2,24,1) / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = 100;
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = Integrator.kr(BrownNoise.kr(0.001));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(1,400,1);
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.8);
	TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1);
}.scope(2, zoom: 4);
)

(
{
	var trate, dur;
	trate = MouseY.kr(2,120,1);
	dur = 1.2 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1);
}.scope(2, zoom: 4);
)

// free sound
b.free;
::

## link::Classes/GrainSin:: - sine grain
|| arguments: code:: numChannels, trigger, dur, freq, pan, envbufnum ::

code::
( // using default window
{
	var trigrate, winsize, trig;
	trigrate = MouseX.kr(2, 120);
	winsize = trigrate.reciprocal;
	trig = Impulse.ar(trigrate);
	GrainSin.ar(2, trig, winsize, TRand.ar(440.0, 880.0, trig), LFNoise1.kr(0.2),
		-1, 512, 0.2)
}.scope(2, zoom: 4);
)

b = Buffer.sendCollection(s, Env([0, 1, 0], [0.5, 0.5], [8, -8]).discretize, 1);

( // using user supplied window
{
	var trigrate, winsize, trig;
	trigrate = MouseX.kr(2, 120);
	winsize = trigrate.reciprocal;
	trig = Impulse.ar(trigrate);
	GrainSin.ar(2, trig, winsize, TRand.ar(440.0, 880.0, trig), LFNoise1.kr(0.2),
		b, 512, 0.2)
}.scope(2, zoom: 4);
)
::
::
see also link::Classes/GrainFM::, link::Classes/GrainBuf:: and link::Classes/GrainIn::

section:: Control

subsection:: Filters for Controls

definitionlist::
## link::Classes/Decay:: - triggered exponential decay
|| arguments: code:: in, decay time, mul, add ::
code::
{ WhiteNoise.ar * Decay.ar(Impulse.ar(1), 0.9, 0.2) }.scope(1, zoom:4);
{ WhiteNoise.ar * Decay.ar(Dust.ar(3), 0.9, 0.2) }.scope(1, zoom:4);
{ SinOsc.ar(Decay.ar(Dust.ar(4), 0.5, 1000, 400), 0, 0.2) }.scope(1, zoom:4);
::

## link::Classes/Decay2:: - triggered exponential attack and exponential decay
|| arguments: code:: trigger, attack time, decay time, mul, add ::
code::
{ WhiteNoise.ar * Decay2.ar(Impulse.ar(1), 0.2, 0.9, 0.2) }.scope(1, zoom:4);
{ WhiteNoise.ar * Decay2.ar(Dust.ar(3), 0.2, 0.9, 0.2) }.scope(1, zoom:4);
::

## link::Classes/Lag::
|| arguments: code:: trigger, duration ::
code::
{ SinOsc.ar(Lag.ar(LFPulse.ar(2,0,0.5,800,400), MouseX.kr(0,0.5)), 0, 0.2) }.scope(1, zoom:4);
::

## link::Classes/Integrator:: - leaky integrator
||
code::
{ SinOsc.ar(Integrator.ar(Dust2.ar(8), 0.99999, 200, 800), 0, 0.2) }.scope(1)
::
::

subsection:: Triggers

definitionlist::
## link::Classes/Trig::, link::Classes/Trig1:: - timed duration gate
|| arguments: code:: trigger, duration ::
code::
// amplitude determined by amplitude of trigger
{ Trig.ar(Dust.ar(2), 0.2) * FSinOsc.ar(800, 0, 0.4) }.scope(1, zoom:4);
// amplitude always the same.
{ Trig1.ar(Dust.ar(2), 0.2) * FSinOsc.ar(800, 0, 0.4) }.scope(1, zoom:4)
::

## link::Classes/TDelay:: - delays a trigger. only delays one pending trigger at a time.
|| arguments: code:: trigger, delay time ::
code::
(
{
	var trig;
	trig = Dust.ar(2);
	[(Trig1.ar(trig, 0.05) * FSinOsc.ar(600, 0, 0.2)),
	(Trig1.ar(TDelay.ar(trig, 0.1), 0.05) * FSinOsc.ar(800, 0, 0.2))]
}.scope(2, zoom:4);
)
::

## link::Classes/Latch:: - sample and hold
|| arguments: code:: in, trigger ::
code::
{ Blip.ar(Latch.ar(WhiteNoise.ar, Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
{ Blip.ar(Latch.ar(SinOsc.ar(0.3), Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
::

## link::Classes/Gate:: - pass or hold
|| arguments: code:: in, trigger ::
code::
{ Blip.ar(Gate.ar(LFNoise2.ar(40), LFPulse.ar(1)) * 400 + 500, 4, 0.2) }.scope(1, zoom:4);
::

## link::Classes/PulseCount:: - count triggers
|| arguments: code:: trigger, reset ::
code::
(
{
SinOsc.ar(
			PulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,
			0, 0.05
		)
}.scope(2, zoom:4);
)
::

## link::Classes/PulseDivider::
|| arguments: code:: trigger, div, start ::
code::
(
{
	var p, a, b;
	p = Impulse.ar(8);
	a = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));
	b = SinOsc.ar(600,  0, Decay2.ar(PulseDivider.ar(p, MouseX.kr(1,8).round(1)), 0.005, 0.5));

	[a, b] * 0.4
}.scope(2, zoom:4);
)
::

## link::Classes/EnvGen:: - envelope generator
|| envelope is specified using an instance of the link::Classes/Env:: class.
code::
{ EnvGen.kr(Env.perc, doneAction: Done.freeSelf) * SinOsc.ar(880,0,0.2) }.play;
{ EnvGen.kr(Env.perc(1,0.005,1,4), doneAction: Done.freeSelf) * SinOsc.ar(880,0,0.2) }.play;

{ EnvGen.kr(Env.perc, Impulse.kr(2)) * SinOsc.ar(880,0,0.2) }.play;
{ EnvGen.kr(Env.perc, Dust.kr(3)) * SinOsc.ar(880,0,0.2) }.play;

// for sustain envelopes a gate is required
z = { arg gate=1; EnvGen.kr(Env.adsr, gate, doneAction: Done.freeSelf) * SinOsc.ar(880,0,0.2) }.play;
z.release;

(
// randomly generated envelope
z = { arg gate=1;
	var env, n=32;
	env = Env(
				[0]++{1.0.rand.squared}.dup(n-1) ++ [0],
				{rrand(0.005,0.2)}.dup(n),
				\lin, n-8, 8 );
	EnvGen.kr(env, gate, doneAction: Done.freeSelf) * LFTri.ar(220,0,0.4)
}.scope(1, zoom:4);
)
z.release;
::
::

section:: Spectral

FFT, IFFT and the phase vocoder ugens.

link::Classes/FFT:: calculates the spectrum of a sound, puts it into a buffer, and outputs a trigger each time the
buffer is ready to process. The PV UGens process the spectrum when they receive the trigger.
link::Classes/IFFT:: converts the spectrum back into sound.

code::
// alloc a buffer for the FFT
b = Buffer.alloc(s,2048,1);
// read a sound
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
// do nothing
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	0.5 * IFFT(chain);
}.scope(1);
)

(
// pass only magnitudes above a threshold
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1));
	0.5 * IFFT(chain);
}.scope(1);
)

(
// pass only magnitudes below a threshold
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagBelow(chain, MouseX.kr(0.1,512,1));
	0.5 * IFFT(chain);
}.scope(1);
)

(
// brick wall filter.
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_BrickWall(chain, MouseX.kr(-1,1));
	0.5 * IFFT(chain);
}.scope(1);
)

(
// pass random frequencies. Mouse controls how many to pass.
// trigger changes the frequencies periodically
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_RandComb(chain, MouseX.kr(0,1), Impulse.kr(0.4));
	0.5 * IFFT(chain);
}.scope(1);
)

(
// rectangular comb filter
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_RectComb(chain, 8, MouseY.kr(0,1), MouseX.kr(0,1));
	0.5 * IFFT(chain);
}.scope(1);
)

(
// freeze magnitudes
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagFreeze(chain, LFPulse.kr(1, 0.75));
	0.5 * IFFT(chain);
}.scope(1);
)
::


section:: Techniques

subsection:: Artificial Space
Building a sense of space into a sound by setting up phase differences between the speakers.

code::
{ var x; x = BrownNoise.ar(0.2); [x,x] }.scope(2); // correlated
{ {BrownNoise.ar(0.2)}.dup }.scope(2); // not correlated

// correlated
{ var x; x = LPF.ar(BrownNoise.ar(0.2), MouseX.kr(100,10000)); [x,x] }.scope(2);
// not correlated
{ LPF.ar({BrownNoise.ar(0.2)}.dup, MouseX.kr(100,10000)) }.scope(2);


// correlated
(
{ var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(7e-3));
	[x,x]
}.scope(2))
// not correlated
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([7e-3,7e-3])) }.scope(2);

// two waves mixed together coming out both speakers
{ var x; x = Mix.ar(VarSaw.ar([100,101], 0, 0.1, 0.2)); [x,x] }.scope(2);
// two waves coming out each speaker independently
{ VarSaw.ar([100,101], 0, 0.1, 0.2 * 1.414) }.scope(2); // * 1.414 to compensate for power

// delays as cues to direction
// mono
{ var x; x = LFTri.ar(1000,0,Decay2.ar(Impulse.ar(4,0,0.2),0.004,0.2)); [x,x]}.scope(2);

(
// inter-speaker delays
{ var x; x = LFTri.ar(1000,0,Decay2.ar(Impulse.ar(4,0,0.2),0.004,0.2));
	[DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0.02, 0))]
}.scope(2);
)

(
// mixing two delays together
// you hear a phasing sound but the sound is still flat.
{ var x; x = BrownNoise.ar(0.2);
	x = Mix.ar([DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0,0.02))]);
	[x,x]
}.scope(2);
)

(
// more spatial sounding. phasing causes you to perceive directionality
{ var x; x = BrownNoise.ar(0.2);
	[DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0.02, 0))]
}.scope(2);
)
::

subsection:: Parallel Structures
code::
(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			// this function creates an oscillator at a random frequency
			{ FSinOsc.ar(200 + 1000.0.rand) }
	) / (2*n)			// scale amplitude
}.scope(1);
)

(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			// this function creates an oscillator at a random frequency
			{ FSinOsc.ar(200 + 1000.0.rand + [0, 0.5]) }
	) / (2*n)			// scale amplitude
}.scope(2);
)

(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			{
				var amp;
				amp = FSinOsc.kr(exprand(0.1,1),2pi.rand).max(0);
				Pan2.ar(
					FSinOsc.ar(exprand(100,1000.0), 0, amp),
					1.0.rand2)
			}
	) / (2*n)			// scale amplitude
}.scope(2);
)


(
{
	var n;
	n = 8; // number of 'voices'
	Mix.ar( // mix all stereo pairs down.
		Pan2.ar( // pan the voice to a stereo position
			CombL.ar( // a comb filter used as a string resonator
				Dust.ar( // random impulses as an excitation function
					// an array to cause expansion of Dust to n channels
					// 1 means one impulse per second on average
					1.dup(n),
					0.3 // amplitude
				),
				0.01, // max delay time in seconds
				// array of different random lengths for each 'string'
				{0.004.rand+0.0003}.dup(n),
				4 // decay time in seconds
			),
			{1.0.rand2}.dup(n) // give each voice a different pan position
		)
	)
}.scope(2, zoom:4);
)
::

subsection:: Serial structures
code::
(
play {
    var sig, chain;

    // The original sound source
    sig = sum({ SinOsc.ar(rrand(50,6000),0,2*Decay.ar(Dust2.ar(1),0.1)).tanh } ! 7);

    chain = sig;    // Start with the original signal
    8.do {|i|       // Loop 8 times. For each loop, connect the signal through something.

        // A simple reverb
        chain = LeakDC.ar(AllpassL.ar(LPF.ar(chain*0.9,3000), 0.2, {0.19.rand+0.01}!2, 3));
    };

    Limiter.ar(sig+chain);    // dry + wet
}
)
::



title:: Tracing Processes
summary:: Tracing processes in SC
categories:: Debugging
related:: Guides/Debugging-tips

What goes on in a running system? In SC, various methods help to get information about processes on different levels: server side and client side (in sclang).

section:: Tracing sclang processes

In order to know more about objects as they are created by processes like tasks or even simply by evaluating a bit of code, one can insert messages like postln and postcs anywhere in the code.

calculating the sum of n subsequent squares
code::
var n = 8, x = 0;
(1..n).do { |num| x = x + num.squared };
x
::

what happens while we are doing this?
code::
var n = 8, x = 0;
(1..n).do { |num| x = x + num.squared.postln; };
x
::
or more in detail:
code::
var n = 8, x = 0;
(1..n).do { |num| [\before, x].postln; x = x + num.squared; [\after, x].postln;};
x
::

when posting several values, some more verbose posts can be useful.
postf formats a string and inserts values for %-characters.
here separate statements are needed.
code::
var n = 8, x = 0;
(1..n).do { |num| x = x + num.squared; "num: % num-squared: % new x: %\n".postf(num, num.squared, x) };
x
::

in some cases, postln will only post part of the data, or a simplified
representation.
code::
// n times 200 random numbers
// will just add ... etc ... after 123
var n = 3;
(1..n).do { |num| { 1000.rand }.dup(200).postln };
::

posts the compile string, i.e. the code needed to recreate the receiver (here the array)
code::
var n = 3;
(1..n).do { |num| { num.rand }.dup(200).postcs };
::

subsection:: Streams, tasks and routines
in streams, tasks and routines, this works just as well:
code::
fork {
	var n = 14;
	(1..n).do { |num|
		{ num.rand }.dup(200).postcs;
		1.wait;
	};
}
::

code::
fork {
	var str = Routine { |in| 10.do { in = in.rand.yield } };
	12.0.do { |i|
		str.next(i).postln;
		0.5.wait;
	};
}
::


for creating a pattern that once it is used posts its values,
the message trace can be used (in returns a Ptrace)
code::
a = Pseq([1, 4, 1, Pwhite(0, 6, 3), 100, 39], inf).trace(prefix: "value: ");
b = a.asStream;
b.next;
b.next;
b.next;
b.next;
::

in a running stream:
code::
Pbind(
	\degree, Pseq([1, 4, 1, Pwhite(0, 6, 3), 100, 39], inf).trace(prefix: "value: "),
	\dur, 0.2
).play
::

post only a slot of the events
code::
Pbind(
	\degree, Pseq([1, 4, 1, Pwhite(0, 6, 3), 100, 39], inf),
	\dur, 0.2
).trace(\degree).play
::

several slots at once:
code::
Pbind(
	\degree, Pseq([1, 4, 1, Pwhite(0, 6, 3), 100, 39], inf),
	\dur, Pwhite(0.2, 0.4, inf)
).trace([\degree, \dur], prefix: ["degree ", "dur "]).play
::

section:: Tracing server processes

Using postln or post on a UGen will only return the UGen, but not the values it produces in a running synth. The poll message creates a Poll UGen which posts at regular intervals when given a time value or as a response to a trigger (see link::Classes/Poll:: helpfile)
code::
// postln returns only the UGen itself (a MulAdd here)
{ SinOsc.ar(SinOsc.kr(0.2, 0, 300, 400).postln) * 0.1 }.play;

// poll traces the values
{ SinOsc.ar(SinOsc.kr(0.2, 0, 300, 400).poll) * 0.1 }.play;

// using a label:
{ SinOsc.ar(SinOsc.kr(0.2, 0, 300, 400).poll(label: "freq")) * 0.1 }.play;
::

For demand ugens, poll does not work - these ugens are called by a Demand or Duty Ugen at certain intervals. The message dpoll creates a Dpoll ugen that posts when they are called (see link::Classes/Dpoll:: helpfile)

code::
{ SinOsc.ar(Duty.kr(0.5, 0, (Dseries(0, 1, inf) * 200 + 300).dpoll)) * 0.1 }.play;

{ SinOsc.ar(Duty.kr(0.5, 0, (Dseries(0, 1, inf) * 200 + 300).dpoll(label: "freq"))) * 0.1 }.play;
::

The scope window can give valuable information about the ongoing sound (see link::Classes/Stethoscope:: help):
code::
{ SinOsc.ar(SinOsc.kr(0.2, 0, 300, 400)) * 0.1 }.scope;
::
A FreqScope window can be used for observing the spectrum of the output:
code::

// create a new analyzer
FreqScope.new;

{ SinOsc.ar(SinOsc.ar(0.2, 0, 3000, 4000)) * 0.1 }.play;
{ SinOsc.ar(SinOsc.ar((1..4) * 0.02, 0, 3000, 4000)).sum * 0.1 }.play;
::



title:: Unit Generators and Synths
summary:: Introduction to some fundamental concepts
categories:: Server>Nodes

A unit generator is an object that processes or generates sound. There are many classes of unit generators, all of which derive from the class link::Classes/UGen::.

Unit generators in SuperCollider can have many inputs, but always have a single output. Unit generator classes which would naturally have several outputs such as a panner, return an array of unit generators when instantiated. The convention of having only a single output per unit generator allows the implementation of multiple channels by using arrays of unit generators. (See link::Guides/Multichannel-Expansion:: for more details.)

section::Instantiation. Audio Rate, Control Rate

A unit generator is created by sending the 'ar' or 'kr' message to the unit generator's class object. The 'ar' message creates a unit generator that runs at audio rate. The 'kr' message creates a unit generator that runs
at control rate. Control rate unit generators are used for low frequency or slowly changing control signals. Control rate unit generators produce only a single sample per control cycle and therefore use less processing power than audio rate unit generators.

The input parameters for a unit generator are given in the documentation for that class.

code::
FSinOsc.ar(800, 0.0, 0.2); // create a sine oscillator at 800 Hz, phase 0.0, amplitude 0.2
::

A unit generator's signal inputs can be other unit generators, scalars, or arrays of unit generators and scalars.

section::SynthDefs and Synths

In order to play a unit generator one needs to compile it in a link::Classes/SynthDef:: and play it on the server in a link::Classes/Synth::. A synth node is a container for one or more unit generators that execute together. A SynthDef is like a kind of pattern for creating synth nodes on the server.

code::
s.boot; // boot the server

// compile and send this def
SynthDef.new("FSinOsc-test", { Out.ar(0, FSinOsc.ar(800, 0, 0.2)) }).send(s); // out channel 0

// now create a Synth object which represents a synth node on the server
x = Synth.new("FSinOsc-test");

// free the synth
x.free;
::

The synth node created above could also be created using 'messaging style', thus saving the overhead of a clientside Synth object:

code::
n = s.nextNodeID;
s.sendMsg("/s_new", "FSinOsc-test", n);
s.sendMsg("/n_free", n);
::

Because any expression returns its value, we can nest the first two lines above for convenience. (See link::Reference/Expression-Sequence:: for more detail.)

code::
s.sendMsg("/s_new", "FSinOsc-test", n = s.nextNodeID;);
s.sendMsg("/n_free", n);
::

It is VERY important and useful to understand the messaging structure which underlies the clientside Synth, Group, Buffer, and Bus objects. See link::Guides/NodeMessaging::, link::Tutorials/Server_Tutorial::, and link::Guides/ClientVsServer:: for more detail.

As a convenience the 'play' method of class link::Classes/Function:: will compile a SynthDef and create and play a synth using the function for you. With this method an link::Classes/Out:: ugen will be created for you if you do not do so explicitly.

code::
{ FSinOsc.ar(800, 0, 0.2) }.play; // create and play a sine oscillator at 800 Hz
::

section::Building Patches

You can do math operations on unit generators and the result will be another unit generator. Doing math on unit generators is not doing any signal calculation itself - it is building the network of unit generators that will execute once they are played in a Synth. This is the essential thing to understand: Synthesis networks, or in other words signal flow graphs are created by executing expressions of unit generators. The following expression creates a flow graph whose root is an instance of link::Classes/BinaryOpUGen:: which performs the '+' operation. Its inputs are the link::Classes/FSinOsc:: and link::Classes/BrownNoise:: unit generators.

code::
FSinOsc.ar(800, 0.0, 0.2) + BrownNoise.ar(0.2); // press enter and look at the post window

{FSinOsc.ar(800, 0.0, 0.2) + BrownNoise.ar(0.2)}.play; // play it
::


title:: Understanding errors
summary:: a guide to understanding errors
related:: Guides/Debugging-tips
categories:: Language, Debugging

section:: Reading error dumps

When sc3 reports an error to the user, there are usually three parts:
list::
## the error text
## a dump of the receiver of the method that caused the error, and/or any arguments of the method call
## a dump of the call stack to the point of the error
::

For example:
code::
1.blech  // no class implements this method; therefore you'll get an error

// error text
ERROR: Message 'blech' not understood.

// receiver and args
RECEIVER:
   Integer 1
ARGS:
Instance of Array {    (02207560, gc=01, fmt=01, flg=11, set=00)
  indexed slots [0]
}

// call stack
CALL STACK:
	DoesNotUnderstandError-reportError
		arg this = <instance of DoesNotUnderstandError>
	Nil-handleError
		arg this = nil
		arg error = <instance of DoesNotUnderstandError>
	Object-throw
		arg this = <instance of DoesNotUnderstandError>
	Object-doesNotUnderstand
		arg this = 1
		arg selector = 'blech'
		arg args = [*0]
	< closed FunctionDef >  (no arguments or variables)
	Interpreter-interpretPrintCmdLine
		arg this = <instance of Interpreter>
		var res = nil
		var func = <instance of Function>
	Process-interpretPrintCmdLine
		arg this = <instance of Main>
::
Each of these parts provides valuable information about the cause of the error. Debugging is much easier if you understand what the error output means.

definitionlist::
## Error text || A string describing the error. In this case, "Message 'xxx' not understood" means that you attempted to use the method xxx on a class that does not implement it.
## Receiver and arguments || The method was applied to an integer (1), with no arguments (the size of the arguments array is 0).
## Call stack || Order of execution in the call stack is in reverse: the top of the stack shows the most recent calls.
::

Most call stacks for errors will show the same top three calls as shown here (calling the method reportError on an error class, calling handleError on Nil, and calling throw on the error object).
You can ignore these three calls.

Following is the meat: the error happened when an object was not understood. Continuing to read down, it happened inside a function definition.
(Every time you highlight a block of code and press the enter key, the code is compiled into a function definition and executed. So, this function definition simply refers to the text submitted to the interpreter.)
And, it all began with the instruction to interpret and print a command line.

Here is a slightly more complex example, showing how you can use the variables listed for each call in the call stack to help locate the error.
code::
Routine({
	var a;
	a = 5;
	loop {
		var b;
		b = 20.rand;
		b.postln.ecky_ecky_phtang;   // "NI!!!!"
		a.wait;
	}
}).play;

ERROR: Message 'ecky_ecky_phtang' not understood.
RECEIVER:
   Integer 6
ARGS:
Instance of Array {    (02207560, gc=01, fmt=01, flg=11, set=00)
  indexed slots [0]
}
CALL STACK:
	DoesNotUnderstandError-reportError
		arg this = <instance of DoesNotUnderstandError>
	Nil-handleError
		arg this = nil
		arg error = <instance of DoesNotUnderstandError>
	Object-throw
		arg this = <instance of DoesNotUnderstandError>
	Object-doesNotUnderstand
		arg this = 6
		arg selector = 'ecky_ecky_phtang'
		arg args = [*0]
	< FunctionDef in closed FunctionDef >
		var b = 6
	Function-loop
		arg this = <instance of Function>
	< FunctionDef in closed FunctionDef >
		var a = 5
	Routine-prStart
		arg this = <instance of Routine>
		arg inval = 1542.075067
::
Reading from the bottom this time, to trace the flow in chronological order: this time, execution did not begin with the command line, but with a routine commencing within the scheduler (Routine({...}).play).
Note that there are two calls identified as "FunctionDef in closed FunctionDef" and that they can be distinguished by the variables contained within.
The earlier call (second from the bottom) defines the variable "a" while the other defines "b." To locate the error in the code, then, you should look for a function defining the variable "b" that is called within another function defining "a" inside a routine.

What if the error occurred not inside a function definition that you wrote, but inside a method in the class library?
There may be a bug in the method, or you may have thought the method took a certain kind of argument when in fact it expects something else.

If you double click on the construction "ClassName-methodName" in the call stack, the whole thing is selected. Then you can press cmd-J to open the method definition and look at the source code.

section:: Error objects and error handling

sc3 implements error reporting using Error objects, which are instances of the class Error or one of its subclasses.
Any code (whether in the class library or any user application) can throw an error any time as follows:
code::
Error("This is a basic error.").throw;
::
You can also catch exceptions that occur within functions by executing the function with code::try:: or code::protect:: instead of code::value::.

definitionlist::
## try || execute the first function. On an error, execute the second function and suppress the error. The second function can rethrow the error if desired, allowing you to decide which errors will be reported and which suppressed.
In this example, we do not rethrow the error, so the error is swallowed and execution continues to the end.
code::
try { 1.blech } { |error| "oops".postln };
"next line".postln;

oops
next line
::
## protect || executes the first function. On an error, execute the second function before reporting the error.
This is useful when the steps before the protect make some changes that need to be undone if an error occurs.
See link::Classes/Environment#use#Environment:use:: for an example.
code::
protect { 1.blech } { |error| "oops".postln };
"next line".postln;

oops  // without protect, this would not be posted
ERROR: Message 'blech' not understood.
RECEIVER:
   Integer 1
ARGS:
Instance of Array {    (02207560, gc=01, fmt=01, flg=11, set=00)
  indexed slots [0]
}
CALL STACK:
	DoesNotUnderstandError-reportError
		arg this = <instance of DoesNotUnderstandError>
::
::

Prior to August 2004, try and protect do not return the value of the function to the caller if there is no error.
code::
try { 1+1 }

a Function
::
More recent builds (since early August 2004) do return the function's value. Non-error objects can be thrown using the class Exception.
code::
try { 1+1 }
2

// can't add a Point to an integer - binary op failed error
// result of catch func is returned instead
try { 1+Point(0, 0) } { 2*5 }
10
::

section:: Common primitive errors

subsection:: operation cannot be called from this Process.

This is usually the results of performing a GUI operation within a routine or scheduled function that is executing on some clock other than AppClock.
AppClock is the only clock that can execute GUI manipulation because it is a lower priority thread. If the CPU is busy with audio synthesis or maintaining accurate scheduling for musical events, AppClock events will be delayed until the CPU is free enough.

Solution: write your GUI updates as follows. defer schedules the function on AppClock.
code::
{ myGUIObject.value_(newValue) }.defer;
::

subsection:: Attempted write to immutable object.
code::
#[0, 1, 2].put(1, 3)

ERROR: Primitive '_BasicPut' failed.
Attempted write to immutable object.
::
code:: #[0, 1, 2] :: is a literal array. Literal arrays cannot be manipulated--they can only be indexed. They cannot be changed internally.

Solution: copy the array first.
code::
#[0, 1, 2].copy.put(1, 3)

[ 0, 3, 2 ]
::

subsection:: Index not an Integer.
code::
#[0, 1, 2].at(\1)

ERROR: Primitive '_BasicAt' failed.
Index not an Integer
::
Arrays can be indexed only with integers (or, in builds since August 2004, floats).

Solution: use code:: .asInteger ::
code::
#[0, 1, 2].at(\1.asInteger)
1
::
note:: if the object cannot be converted into an integer, you'll get a "Does not understand" error! ::

subsection:: Index out of range.
code::
[0, 1, 2].put(5, 5)

ERROR: Primitive '_BasicPut' failed.
Index out of range.
::
Arrays have a finite size. If you try to put an object into an array slot but the slot does not exist because the array is too small, you'll get this error.

Solution: extend the array.
code::
[0, 1, 2].extend(6).put(5, 5)

[ 0, 1, 2, nil, nil, 5 ]
::
Note that if the argument to extend() is smaller than the array, then the array will be truncated. If you're not sure, use max:
code::
i = rrand(5, 10);
a = [0, 1, 2];
a.extend(max(i+1, a.size)).put(i, 100);
::
Why i+1? An array with size 4 allows 0, 1, 2 and 3 as indexes (4 elements starting with 0).

If it's a new array, use .newClear instead of .new.
code::
a = Array.new(4);
a.put(3, 1);
ERROR: Primitive '_BasicPut' failed.
Index out of range.

a = Array.newClear(4);
a.put(3, 1);
[ nil, nil, nil, 1 ]
::

section:: A common warning
code::
WARNING: FunctionDef contains variable declarations and so will not be inlined.
::
This warning can be safely ignored. Your code will still run, even if you get this warning.

Inlining is a compiler optimization that takes the operations inside a function and places them in the main line of the containing function. For instance,
code::
// inlined
{ while { 0.9.coin } { 10.rand.postln }
}.def.dumpByteCodes;

BYTECODES: (16)
  0   40       PushLiteral Float 0.9   3FECCCCC CCCCCCCD  // { 0.9.coin }
  1   0D 2C    SendSpecialUnaryArithMsgX 'coin'
  3   F9 00 09 JumpIfFalsePushNil 9  (15)
  6   2C 0A    PushInt 10							  // { 10.rand.postln }
  8   0D 25    SendSpecialUnaryArithMsgX 'rand'
 10   C1 38    SendSpecialMsg 'postln'
 12   FD 00 0D JumpBak 13  (0)
 15   F2       BlockReturn
a FunctionDef in closed FunctionDef
::
This function contains two other functions. One is the condition for the while loop; the other is the while loop's action. The compiler renders this into a single code block, using jump instructions to handle the looping and exit.

If, however, one of the functions defines a variable, then that function requires a separate execution frame. In this case, it's necessary for the compiler to push function definition objects onto the stack.
code::
// not inlined
{ while { 0.9.coin } {
    var a;	// variable here prevents optimization
    a = 10.rand;
    a.postln
  }
}.def.dumpByteCodes;

BYTECODES: (7)
  0   04 00    PushLiteralX instance of FunctionDef in closed FunctionDef
  2   04 01    PushLiteralX instance of FunctionDef in closed FunctionDef
  4   C2 0C    SendSpecialMsg 'while'
  6   F2       BlockReturn
a FunctionDef in closed FunctionDef
::
Inlined code will run faster, because pushing and using different execution frames is extra work for the virtual machine. If you're very concerned about speed, you can use this warning as an indicator that you might be able to optimize something in your code further.

Sometimes, there's no way around un-optimized code. To wit,
code::
// inlined, optimized, but you'll get stuck notes
Routine({
  var synth;
  { synth = Synth("someSynth", [...args...]);
    thisThread.clock.sched(10, {
      synth.free;
    });
    2.wait;
  }.loop;
}).play;

// not inlined, but no stuck notes
Routine({
  { var synth;
    synth = Synth("someSynth", [...args...]);
    thisThread.clock.sched(10, {
      synth.free;
    });
    2.wait;
  }.loop;
}).play;
::
The first routine can be optimized because there is no variable declaration inside the loop. But, the synth variable changes on each iteration, meaning that by the time the first release happens, you don't have access anymore to the first note.
Thus the first note will never terminate.

In the second case, each note has its own synth variable, so the notes will be terminated as expected. You get a warning, but it's better because the results are correct.

A solution to the above problem is to use a function with local variables.
code::
(
Routine({
    var func;
    func = {
        var synth; // this variable is local to the function
        synth = Synth("default");
        [\play, synth].postln;
        thisThread.clock.sched(4.5, {
            synth.free;
        	[\free, synth].postln;
        });
    };
    { func.value; 1.wait; }.loop
}).play;
)
::



title:: User FAQ
summary:: Some FAQ and common errors
categories:: FAQ


anchor::ERROR Primitive BasicNew failed Index not an Integer::

SECTION:: ERROR: Primitive 'BasicNew' failed. Index not an Integer

subsection:: If you're writing a SynthDef

It's quite likely that the error means you're trying to dynamically change the number of channels inside a SynthDef, which is something you can't do - SynthDefs need to have a fixed layout.
For example, this is a simple attempt to make pink noise over a variable number of channels:

code::
(
SynthDef(\thiswillfail, { |out=0, numChannels=2|
    Out.ar(out, {PinkNoise.ar}.dup(numChannels))
}).add
)
::

It fails because we're trying to make the number of pink noise generators involved, actually changeable.
You can't do that - when the SynthDef is compiled, the language needs to know strong::exactly:: how many UGens will be involved and how they are connected. This is because a SynthDef represents an efficient fixed-layout synth that the server can instantiate.

subsection:: So what to do instead?

Think of SynthDefs as tiny fixed reusable components, and design your logic to reuse them in whatever combinations are needed.

To go back to the simple example above (the pink noise generator), you could simply do:

code::
(
SynthDef(\simplepink, { |out=0|
    Out.ar(out, PinkNoise.ar)
}).add
)
::

and create one code::\simplepink:: synth for each channel. Or you could create one SynthDef for each number of channels you expect to use.
For example if you might use between 1 and 5 channels:

code::
(
(1..5).do{ |n|
SynthDef("simplepink_%".format(n).asSymbol, { |out=0|
    Out.ar(out, {PinkNoise.ar}.dup(n))
}).add
}
)
::

Then you'd need to invoke code::\simplepink_4:: or whatever, as appropriate.


anchor::Language (client) Issues::

SECTION:: Language (client) issues

subsection:: Calling gui primitives from a SystemClock routine

When calling gui primitives from a SystemClock routine will cause an error:

code::
SystemClock.sched(0,{ Window.new.front })
::

code::
ERROR: Qt: You can not use this Qt functionality in the current thread. Try scheduling on AppClock instead.
ERROR: Primitive '_QWindow_AvailableGeometry' failed.
::

To avoid this issue use the AppClock:

code::
AppClock.sched(0,{ Window.new.front })
::

or the defer method:

code::
SystemClock.sched(0,{ { Window.new.front }.defer })
::


subsection:: Binary operations order

Because of the way SuperCollider evaluates expressions, the usual order of execution of mathematical expressions is not respected.
In SuperCollider everything is an object, and evaluation happens from left to right, so:

code::
5 + 3 * 2
::

will evaluate as (5 + 3 ) * 2.

This happens because the expression becomes:

code::
5.performBinaryOpOnSimpleNumber('+',3).performBinaryOpOnSimpleNumber('*',2)
::

Therefore, in algebraic expressions parenthesis must be used when left to right orders is not what is desired:

code::
5 + (3 * 2)
::


anchor::SynthDef Issues::

SECTION:: SynthDef Issues

subsection:: "If" statements inside a SynthDef

It's only a matter of time before a user tries to write something like this in a code::SynthDef::

code::
SynthDef(\kablooie, { |x = 0|
    var signal;
    if(x > 0) {
        signal = SinOsc.ar
    } {
        signal = Saw.ar
    };
});
::

... with the disturbing result: code::ERROR: Non Boolean in test.::

"Non Boolean in test"? But strong::x > 0:: is a comparison, and surely should produce a Boolean, right?

This should be the first clue that Boolean logic in the server is a very different animal from the so-called "normal" use of conditionals on the client side (in the language).

subsection:: What is a Boolean in the server?

In fact, there is no such thing. The server handles floating-point numbers. It doesn't have strong::true:: or strong::false:: entities.

Since everything in the server is a number, the result of the comparison must also be a number. The server follows the same convention as other DSP environments (Max/MSP, pd etc.):

- code::True:: is represented by 1.0
- code::False:: is represented by 0.0

subsection:: Why is x > 0 "non-Boolean" in the "test"?

This goes back to the general issue of handling operators in the server.
Math operators in a SynthDef are not calculations to do strong::right now::.
They strong::describe:: calculations that will be done strong::in the future::, many thousands of times.

code::
var x = 1;
x > 0;
// -> true
::

code::
SynthDef(\kablooie, { |x = 0|
    "x: ".post; x.postln;
    "(x > 0): ".post; (x > 0).postln;
});
::

code::
x: an OutputProxy
(x > 0): a BinaryOpUGen
::

The precise value of strong::x:: is unknown at the time you execute the SynthDef code.
strong::x:: actually represents an unlimited number of values, which will be provided to Synths using argument lists. So, it's meaningless to determine, once and for all, whether strong::x > 0:: or not. strong::x:: may be strong::> 0:: now and strong::< 1:: a split second later. So, instead of producing a Boolean, strong::x > 0:: produces a strong::Binary Operator UGen:: that repeatedly executes the comparison.

Going back to this:

code::
if (aBinaryOpUGen) { ... } { ... };
::

To do this, the language must know which function (true or false) to execute. But there is no way to know which one the BinaryOpUGen will be.
So, SuperCollider throws an error.

subsection:: If you can't branch, what good is a comparison in the server?

Comparisons have a lot of uses, actually.

- strong::Choosing one of two signals::: This is the closest we can get to strong::if-then-else:: in the server. Both strong::then:: and strong::else:: must be running continuously. That's a requirement of how the server works: the number and arrangement of unit generators within a single Synth cannot change. Instead, you can choose strong::which of those signals makes it downstream::. One will be used and the other ignored.
Since true is 1 and false is 0, you can use a conditional to index into an array using Select.

code::
Select.kr(aKrSignal > anotherKrSignal, [false_signal, true_signal]);
::

- strong::Generating triggers::: A trigger occurs whenever a signal is <= 0, and then becomes > 0. Extending this to comparisons, it means that strong::a trigger occurs when a comparison is false for a while, and then becomes true::. Comparing a signal to a threshold may then be used anywhere that a trigger is valid.
For a simple example, take the case of sending a message to the language when the microphone input's amplitude crosses a threshold.

code::
var mic = In.ar(8, 1), amplitude = Amplitude.kr(mic);
SendTrig.kr(amplitude > 0.2, 0, amplitude);
::

- strong::Passing or suppressing triggers::: You might need to generate triggers continuously, but permit the triggers to take effect only when a condition is met. Multiplication handles this nicely:
strong::condition * trigger::. Since the condition evaluates as 0 when false, the trigger will be replaced by 0 and nothing happens, as desired.

For a simple case, let's refine the mic amplitude example by suppressing triggers that occur within 1/4 second after the previous.

code::
var mic = In.ar(8, 1),
    amplitude = Amplitude.kr(mic),
    trig = amplitude > 0.2,
    timer = Timer.kr(trig), // how long since the last trigger?
    filteredTrig = (timer > 0.25) * trig;

SendTrig.kr(filteredTrig, 0, amplitude);
::

subsection:: Logical operators: And, Or, Not, Xor

Logical operators have simple arithmetic equivalents.

- strong::And = multiplication::: strong::(x > 0) * (y > 0):: means both conditions must be true (nonzero) for the result to be nonzero.

- strong::Or = addition::: strong::(x > 0) + (y > 0):: means nonzero in either condition is enough to make the result nonzero.

NOTE::
If both are true, then the result will be 2, not 1. In some cases, the 2 may not be acceptable. That can be fixed by wrapping the Or in another comparison -- strong::((x > 0) + (y > 0)) > 0:: -- because 2 > 0 evaluates to 1!
::

-  strong::Not::: I prefer to negate a condition by comparing it to zero:
strong::condition <= 0::. 0 <= 0 is 1 (i.e., not 0), and 1 <= 0 is 0 (not 1).
If you're certain the logical expression will only ever be 0 or 1 exactly, you can also negate by subtraction: strong::1 - condition::.

- strong::Xor::: Exclusive-or is true if one or the other condition is true, but not both. We can add the two conditions and compare it to 1. The syntax is a little bit tricky because code::==:: doesn't turn into a BinaryOpUGen automatically.
We have to create the BinaryOpUGen by hand.

code::
BinaryOpUGen('==', (x > 0) + (y > 0), 1)
::


subsection:: ERROR: SynthDef not found

Sending a SynthDef to the server requires a little bit of time, which means that running a block of code with both SynthDef definitions and instances of those SynthDefs won't be guaranteed to work unless this slight delay is accounted for. There are two main ways to do this:

First way: put the SynthDefs and the main code in a Task and put some kind of code::.wait:: time between them.

code::
Task({
    // put your SynthDefs here
    0.2.wait;
    // put the rest of your code here
}).play;
::

Second way: use code::.sync:::

code::
Routine({
    // put your SynthDefs here
    s.sync; // assuming that 's' is the server
    // put the rest of your code here
}).play
::

subsection:: FAILURE /s_new alloc failed, increase server's memory allocation

strong::What it means::: While initializing the unit generators in a new Synth node, the server ran out of real-time memory.

strong::Solution::: Increase the amount of real-time memory available to the server. This size is set, as the error message says, in the
code::ServerOptions:: object associated with the server. It is a server startup option; you must quit the server and reboot it, or the new
setting will not take effect.

code::
myServer.quit;
myServer.options.memSize = 65536;  // e.g., could be different for you
myServer.boot;
::

code::myServer.options.memSize:: is given in KB. The default is 8192KB, or 8MB.

strong::What it really means::: Many unit generators require internal memory buffers, such as delay lines, comb filters, allpass delays, some FFT manipulators, reverb units etc.
These internal buffers are not allocated directly from the operating system, but rather from a "real-time memory pool."
This is because direct allocation from the OS, by functions such as code::malloc()::, is not real-time safe.
The OS may take too long to return the new block, causing glitches in the audio.
To solve this problem, the server allocates a chunk of memory when it starts up and parcels it out to unit generators as needed.

If you use a large number of delays, the server may run out of real-time memory. The default code::8192KB:: setting can support 47.55 seconds of delay at a sampling rate of 44.1 kHz.
This goes away quickly when using lots of synths with multiple channels of delay.

strong::Alternate solution::: For delay units, you may use preallocated delay buffers -- code::Buffer.alloc():: -- and the "Buf" delay units:
code::BufDelayN::, code::BufDelayL::, code::BufDelayC::, code::BufCombL:: etc.
code::Buffer.alloc():: does not use the real-time pool and is not subject to the memSize limitation. This approach will not help with FFT units.

subsection:: Array arguments

Sometimes, you need to send an array to a series of Control inputs in a SynthDef (often called "_array arguments_").

code::
Synth(\xyz, [freqs: [300, 400, 500]]);
::

There are two primary ways to do this:

- Supply a literal array -- code::\#[1, 2, 3]:: -- as the default for the argument name in the function.
This is discussed in link::Classes/SynthDef::'s help file.

code::
SynthDef(\xyz, { |freqs = #[1, 2, 3]|
    // ...
})
::

- Or, use code::NamedControl::.
This is the only way to do it if you want to construct the array's size dynamically, or based on a variable. See link::Classes/NamedControl::.

code::
SynthDef(\xyz, {
    var freqs = NamedControl.kr(\freqs, #[1, 2, 3]);
    // ...
});
::

subsection:: Why does it have to be a literal array?

The reason comes from the process of building a SynthDef:

1. First, look at the function arguments to figure out what the Control inputs should be.
2. Then create Control units (usually just one, if they're all normal arguments without prefixes or special rates). Each channel is represented by an code::OutputProxy::.
3. Then run the SynthDef function, passing the output proxies to the arguments.
4. Then sort the UGens into the right order, etc. etc.

To do steps \#1 and \#2, the SynthDef builder has to know the size of an array argument strong::before:: running the function. That's possible only if it's a literal array: code::\#[1, 2, 3, 4, 5]::. Any other array notation creates the array strong::while running the function:: (step \#3). But then it's too late -- the SynthDef builder already created a non-array control channel for it!

code::
SynthDef(\notArray, { |a = (1..5)|
    a.debug("a is");
});
::
code::a is: an OutputProxy::

code::
SynthDef(\array, { |a = #[1, 2, 3, 4, 5]|
   a.debug("a is");
});
::
code::a is: [ an OutputProxy, an OutputProxy, an OutputProxy, an OutputProxy, an OutputProxy ]::

(Note, if 'a' printed as [ 1, 2, 3, 4, 5 ], then you wouldn't be able to change the values in a Synth using code::.set::!)


anchor::Server Issues::

SECTION:: Server issues

subsection:: How to trigger a function from the server

The first and most important point: strong::Functions are client-side only::.
The server doesn't know what functions are, doesn't understand them and has no way to execute them.
strong::Only the client can execute a function::.

Therefore, if you want a function to execute when something happens in the server, the only way is for the server to tell the client to take the action.

The server can communicate messages back to the client using one of two unit generators: code::SendTrig:: and code::SendReply::.
code::SendTrig:: is simpler and less flexible (it can send only a code::/tr:: message, and only one data value).
code::SendReply:: allows you to name the message anything you like, and can send arrays with the message.
We'll use SendReply here because of its greater flexibility.

Within the language, you also need an object to receive the message and act on it. Usually this is code::OSCFunc:: or code::OSCdef::.  In this example, code::OSCdef:: filters messages not just on the name code::/bleep:: but also on the synth's ID. This way, you could have multiple triggering synths, with a different responder and a different action per synth.

code::
(
a = {
    var trig = Dust.kr(8),
    decay = Decay2.kr(trig, 0.01, 0.1),
    sig = SinOsc.ar(TExpRand.kr(200, 600, trig), 0, 0.1) * decay;
    SendReply.kr(trig, '/bleep', trig);
    sig ! 2
}.play;

o = OSCdef(\bleepResponder, { |msg|
    msg.postln;
}, '/bleep', s.addr, argTemplate: [a.nodeID]);
)

a.free; o.remove;
::

subsection:: Helpfile references:

- link::Classes/SendTrig::, link::Classes/SendReply::

- link::Classes/OSCresponderNode::, link::Classes/OSCpathResponder::, link::Classes/OSCresponder::, link::Guides/OSC_communication::


subsection:: Error: failed to open UDP socket: address in use

Sometime when booting the server one gets a message: code::Error: failed to open UDP socket: addess in use::.

This is usually caused by an instance of scsynth that as hanged but has not released the osc port, perhaps because SuperCollider crashed.
You can use SuperCollider (sclang) to kill all running servers by running code::Server.killAll::.
You can also kill scsynth using a terminal or your operating system's task manager.


anchor::Other Issues::

SECTION:: Other issues

subsection:: Error while loading shared libraries: libsclang.so: cannot open shared object file

This usually happens after building on Linux and it means that your system is unaware of newly installed shared libraries. Running ldconfig
(as root) solves the problem:

code::/sbin/ldconfig::


title:: Using Extensions
summary:: Using Extensions
categories:: Internals
related:: Guides/WritingUGens, Guides/UsingQuarks, Guides/WritingClasses

SC supports extensions to its class library, documentation, and server UGen plugins. Extensions should be packaged as a
single folder containing all three (for convenient addition or removal), or any combination, which can then be placed in
platform-specific extension directories in order to be included.



section:: Platform Specific Directories

You can install extensions simply by copying the extensions to the following location. There are different directories
for per-user and system-wide extensions that apply to all users.. The locations can be obtained by running
code::Platform.userExtensionDir:: and code::Platform.systemExtensionDir::.

Typical user-specific extensions directories:
table::
## macOS   || ~/Library/Application Support/SuperCollider/Extensions/
## Linux   || ~/.local/share/SuperCollider/Extensions/
## Windows || %LOCALAPPDATA%/SuperCollider/Extensions/
::

Typical system-wide extension directories:
table::
## macOS   || /Library/Application Support/SuperCollider/Extensions/
## Linux   || /usr/share/SuperCollider/Extensions/
## Windows || %PROGRAMDATA%/SuperCollider/Extensions/
::

section:: How Extensions Folders Should be Organised

Class files and UGen plugins are recognised by their file extensions. Anything placed within a folder named 
teletype::ignore/:: (case insensitive) will be ignored when compiling the class library or loading plugins.

Here is an example folder layout:

teletype::MyExtension::
tree::
## teletype::classes::
    tree::
    ## teletype::myClass.sc::
    ## teletype::myUGens.sc::
    ::
## teletype::plugins::
    tree::
    ## teletype::myUGenPlugins.scx::
    ::
## teletype::HelpSource::
    tree::
    ## teletype::Classes::
        tree::
        ## teletype::MyClass.schelp::
        ## teletype::MyUGen1.schelp::
        ## teletype::MyUGen2.schelp::
        ::
    ## teletype::Guides::
        tree::
        ## teletype::MyExtensionGuide.schelp::
        ::
    ::
::



title:: Using MIDI
summary:: Notes on MIDI support in SuperCollider
related:: Guides/MIDI, Classes/MIDIFunc, Classes/MIDIdef
categories:: External Control>MIDI

keyword::MIDI
section::Introduction

SuperCollider's out of the box MIDI support is fairly thorough (although not as complete as you'll find in commercial sequencers). All MIDI devices accessible to your operating system (CoreMIDI on macOS, ALSA on Linux, PortMIDI on Windows) are accessible to SuperCollider.

The main MIDI classes are:

definitionList::
## link::Classes/MIDIClient:: || This class connects to the operating system's MIDI layer, and obtains the lists of available MIDI sources and destinations. The information about the hardware is stored in code::MIDIClient.sources:: and code::MIDIClient.destinations:: as link::Classes/MIDIEndPoint:: objects. MIDIClient must be initialized before MIDI can be received. See the example link::#Playing notes on your MIDI keyboard::.
## link::Classes/MIDIFunc:: || The optimal way to receive the most typical MIDI messages: note on/off, controller, pitch bend, aftertouch, poly-touch and program change.
## link::Classes/MIDIdef:: || Related to link::Classes/MIDIFunc::, this class keeps several MIDIFunc objects in global storage, by name. Especially helpful for live or interactive use.
## link::Classes/MIDIOut:: || Supports MIDI output to hardware ports or inter-application MIDI buses.
## link::Classes/MIDIEndPoint:: || Represents a MIDI port published by the operating system. It contains a device name, port name and unique identifier (uid).
## link::Classes/MIDIIn:: || The lowest-level MIDI input class. MIDIFunc and MIDIdef use this class so that you don't have to. It is strongly recommended to avoid using this class directly.
::

In most cases, each physical MIDI connection (pair of in/out jacks on the MIDI interface) has one MIDIEndPoint object to represent it in the client.

section::Receiving MIDI input
subsection:: MIDIFunc and MIDIdef

For most uses, the preferred way to receive MIDI input is using the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. The advantage of this approach is that any number of responders can be registered, using extremely flexible matching.

link::Classes/MIDIFunc:: has a number of convenience methods allowing you to register for the different MIDI message types. It can  filter incoming MIDI messages to respond to a particular device, channel number, or specific message number, or ranges thereof.

See link::#Playing notes on your MIDI keyboard:: below for a simple example using the note-on and note-off MIDIFuncs.

subsection:: MIDIFunc and MIDIdef: Filtering based on device or message data

MIDIFunc and MIDIdef can filter incoming messages, responding to specific devices, MIDI channels or data values. For example, you may want one MIDIFunc to handle controller 1, while a different MIDIFunc handles controller 7.

Filters are set by the argument immediately following the response function: code::MIDIFunc.incomingType({ /* function */ }, msgNum, chan, srcID):: where the meaning of msgNum depends on the message type.

definitionlist::
## msgNum || The first data byte of the message. Note on/off messages send code::note_number velocity::; code::msgNum:: is the note number. Continuous controllers send code::cc_number value::; code::msgNum:: is the CC number. Check the specific message type for details.
## chan || The channel number. Most MIDI devices and software refer to channels 1-16. SuperCollider uses channels 0-15. In SuperCollider, you usually have to subtract 1 from the channel number set in the sending device.
## srcID || The UID (unique identifier) of the MIDI port. This is set by the system, and is available through the link::Classes/MIDIEndPoint:: objects in the array code::MIDIClient.sources::. (For MIDI input, use code::MIDIClient.sources::, not code::destinations::.) If you know the device's array index, you can set code::srcID: MIDIClient.sources[index].uid::. If you know the device's name, you can search the array for a matching MIDIEndPoint first: code::srcID: MIDIClient.sources.detect { |e| e.device.containsi("searchstring") }.uid::.
::

Any filters that are omitted will match all values -- e.g., for an omni-channel responder, simply leave out a code::chan:: filter.

subsection:: MIDIIn

MIDIIn has a number of class variables holding functions to be evaluated when a MIDI event comes in. Technical details on each function can be found in the link::Classes/MIDIIn:: help file.

Note, however, that MIDIIn provides no functionality for filtering incoming MIDI based on device, controller number or other factors. This means, for practical use, MIDIIn is significantly harder to use than link::Classes/MIDIFunc:: or link::Classes/MIDIdef::. strong::It is generally recommended to avoid using MIDIIn directly.:: The exceptions are sysex (system exclusive) and sysrt (MIDI clock) messages, which are currently supported only by MIDIIn.

section::Playing notes on your MIDI keyboard

The technical problem is that every note on needs to save its synth object so that the note off message can end the right server-side node.

code::
s.boot;

(
var notes, on, off;

MIDIClient.init;
MIDIIn.connectAll;

notes = Array.newClear(128);	// array has one slot per possible MIDI note

on = MIDIFunc.noteOn({ |veloc, num, chan, src|
	notes[num] = Synth(\default, [\freq, num.midicps,
		\amp, veloc * 0.00315]);
});

off = MIDIFunc.noteOff({ |veloc, num, chan, src|
	notes[num].release;
});

q = { on.free; off.free; };
)

// when done:
q.value;
::

The link::Classes/MIDIIn:: help file contains a more elaborate example.

SuperCollider does not have a built-in class to handle this automatically. However, emphasis::dewdrop_lib::, a third party library mentioned link::#Third party libraries#below::, includes Voicer (to simplify note on-off bookkeeping) and VoicerMIDISocket (to trigger Voicer notes by MIDI). Users interested in this functionality may wish to examine that library.

section::Sending MIDI out

See the link::Classes/MIDIOut:: helpfile. Unlike MIDIIn, with MIDIOut you create an instance of the MIDIOut class with a port and uid. You can have multiple MIDIOut objects to send MIDI to different physical devices.

Many users have reported timing issues with MIDIOut. When the CPU is busy, especially during graphics updates, outgoing MIDI messages may be delayed. Use with caution in a performance situation.

section::MIDI synchronization

MIDI synchronization may be performed using MIDIIn's sysrt or smpte response functions. It's up to the user to implement the desired kind of synchronization.

For sysrt, external MIDI clocks output 24 pulses per quarter note. The responder should count the incoming pulses and multiply the rhythmic value into 24 to determine how many pulses to wait:

table::
## 0.25 || wait 6 pulses (16th note)
## 0.5 || wait 12 pulses (8th note)
## 2 || wait 48 pulses (half note)
::

dewdrop_lib (third party library) includes a class, MIDISyncClock, that receives MIDI clock messages and allows events to be scheduled to keep time with an external MIDI device. See the MIDISyncClock helpfile for details.

There are significant limitations, discussed in the helpfile. This is not really a fully supported class, but it's there for users who need rudimentary MIDI sync functionality.

section::Third party libraries

emphasis::dewdrop_lib:: is a third party library providing a number of useful performance features, available through the link::Classes/Quarks:: interface. The library provides a user-extensible framework of MIDI responder classes designed for multiport, multichannel applications.

Among its features:

- user-extensible: simple functions may be used, and frequently-needed responses can be written into classes that inherit from the framework (see BasicMIDISocket and BasicMIDIControl helpfiles)

- easy to use classes for playing MIDI notes and assigning MIDI controllers to synthesis parameters

- a user-configurable array of MIDI controller numbers, to simplify assignment of events to hardware controllers


title:: Using Quarks
summary:: A guide to Quarks
categories:: Quarks
related:: Classes/Quarks, Classes/Quark, Classes/Git

Quarks are packages of SuperCollider code containing classes, extension methods, documentation and server UGen plugins. The Quarks class manages downloading these packages and installing or uninstalling them.

section:: Installing quarks

subsection::using the GUI

You can install Quarks using the interface:

code::
Quarks.gui
::

This offers many community contributed packages most of which are hosted on github.

You can also add additional folders where you keep your personally developed quarks or those you have forked or downloaded.
These will also be shown on the GUI as options for installing.

code::
// put this in your startup.scd
Quarks.addFolder("~/supercollider/quarks");
::


subsection::by name

You can (un)install a Quark by name:

code::
Quarks.install("MathLib");
Quarks.uninstall("MathLib");
::

subsection::by git URL

code::
Quarks.install("https://github.com/supercollider-quarks/MathLib.git");
// uninstall it
Quarks.uninstall("https://github.com/supercollider-quarks/MathLib.git");
::

subsection::from a local folder

and you can install any local folder:

code::
// add your own classes
Quarks.install("~/supercollider/quarks/my-thing");
// install something that you downloaded and want to try out
Quarks.install("~/Downloads/something-i-found");
::

You can also add a folder where you keep your development quarks (your own and things you have forked):

code::
Quarks.addFolder("~/supercollider/quarks");
::

Now each quark inside that folder will appear on the GUI for you to un/install.

If you wish to be able to uninstall local quarks, but still see them in the GUI, it is highly recommended to collect your local quark directories under a single primary directory. Then, use link::Classes/Quarks#*addFolder:: to add the primary directory. code::addFolder:: does not add individual quark directories.

subsection::Recompile the class library

After installing or uninstalling you need to strong::Language > Recompile Class Library::

If you've made a bit of a mess:

code::
// remove everything
Quarks.clear
::


subsection::Internals

When you install one it is cloned using git into:

code::
Quarks.folder;
// open the folder and have a look
Quarks.openFolder;
::

and this path is added to the link::Classes/LanguageConfig:: includePaths so that the classes are in SuperCollider's class path when you recompile the library.

You can view and edit the current include paths via strong::Preferences > Interpreter > Include Paths::.

code::
LanguageConfig.includePaths
::

You can also see or edit these settings in the file sclang_config.yaml


subsection:: Fixing Conflicts

SuperCollider does not allow duplicate class definitions and will fail to compile if you've accidentally installed conflicting packages.

The Quarks interface can only work if SuperCollider is compiled and running, so if something goes wrong then you have to fix it manually.

If you are using the SC IDE then open strong::Preferences > Interpreter:: and remove the paths from the Include Paths.

You can also manually edit teletype::sclang_config.yaml::



section:: Saving and Loading sets of Quarks

To make project work simpler you can save and later reload your currently installed Quarks to and from a quarks.txt file.
This is similar to what the LanguageConfig does but this also downloads the Quarks if needed and installs all dependencies.

This is very useful for projects because you can pin the exact releases of each Quark that your project depends on and you should be able to reload them exactly even years in the future.

code::
// save your current state
Quarks.save("~/supercollider/quarks.txt");
// reload it later
Quarks.load("~/supercollider/quarks.txt");
::

This saves both what quarks you have and what git revision they are on.
If you have uncommitted changes in one of the quarks then it will warn you that its dirty.

The save format specifies the revisions using git tags with a fall back to the full sha hash that specifies the revision. In git terminology this is known as a refspec.

If you have installed local paths that are not under git source control (your own work or things you have downloaded) then the paths will be saved without any version or refspec.

The file format looks like this:

code::
https://github.com/author/quarkname@tags/4.1.4
https://github.com/supercollider-quarks/ddwCommon@8ae156b460dcb08285013265cf3a1c7172bba665
~/supercollider/quarks/my-thing
::

Note that in this case `quarkname` was checked out to the tag 4.1.4, and `ddwCommon` was not on a tag so the refspec is the SHA hash. In both cases this results in an exact reference.
`~/supercollider/quarks/my-thing` was not a git repo so the best it can do is to specify the path.

Even if a quark was installed by name using the directory, the full repository URL will be saved to ensure that the reference is unvarying (the directory.txt could be edited and the URL changed, and that might then point to different source code).

Any packages not under git source control are specified by path, abbreviated to the most logical path relative to the quark file, the home directory or by absolute path. They do not have a version or refspec.


section:: Making your own Quarks

Packages are a natural way to store your work.

Install any source code folder as a Quark:

code::
Quarks.install("~/path/to/my-quark")
::

Or create a folder where you do your development work and add that to the additional folders:

code::
Quarks.addFolder("~/supercollider/quarks");
::

Now you can (un)install your own packages from your local folder.

Managing your code with git is optional, but you should consider using it early on. Even if you do not intend to share your code with anyone else, git provides a backup system and a time machine if you break something.

code::
# in the terminal, its easy as this:
git init
::

Bitbucket offers free hosting for private repositories, and you can setup your own git host on any machine that you have SSH access to.  But you don't even need an externally hosted repository to use git.

Hard drives die, backups fail, people make mistakes. If you keep a copy on bitbucket then your work is that much safer.

section:: Publishing a Quark

Make a git repository and push it to github, gitlab, bitbucket or any publicly accessible git host.

Be sure to strong::tag your releases::. The name of a tag should be the release version to which it corresponds. Using link::https://semver.org##Semantic Versioning:: (eg "v1.0.1") is strongly recommended. This provides the Quarks system with the ability to list available versions and allow the user to choose which version to checkout. Version tags also allow other quark developpers to pin their dependencies to specific release versions.

You can add your quark to the Community Quark Directory by adding its name and git URL to the following file:

https://github.com/supercollider-quarks/quarks/blob/master/directory.txt

Simply click teletype::edit::, add in your quark's info, and submit a pull request. Here's an example of what an entry should look like in the Quark Directory:

code::
quarkname=https://github.com/author/quarkname
::

subsection::Migrated Quarks from SVN

I (felix) migrated the old SVN repository to github and preserved all the commits and authorship.
You may find your old work in one of these quarks:

https://github.com/supercollider-quarks

Contact me to transfer ownership to your own github account. You may also just fork any repo there, or if you've already moved your code to github then just edit the directory to point to your preferred newer version.

Quarks with spaces in the name had to have those spaces removed. Quarks nested inside other quarks (dewdrop_lib) are now un-nested.

subsection::git branches

Releases are specified with a git tag which refers to a specific commit regardless of what branch it is on. The default branch is master, but the branch does not really matter, only the tag. If you are not tagging specific releases then Quarks will fetch the master branch.

section:: Quark file

The quark file is a SuperCollider code file containing authorship, version, copyright and dependency information. It is optional but recommended. None of the fields are required and you may include any custom fields you like.

The most important feature is to specify dependencies, version, summary and to specify the help file.

It's similar to the package.json file in npm (JavaScript package manager) or bower.json for Bower (web/frontend package manager).

The file name is the name of the quark followed by the .quark extension:

code::
{quark name}.quark
::

and is a SuperCollider file that returns an IdentityDictionary

code::
(
  name: "DemonWidgets",
  summary: "Widgets, gadgets and arcane devices for summoning demons.",
  version: "1.0.0",
  schelp: "DemonWidgets",
  dependencies: ["Bjorklund", "Canvas3D", "cruciallib@tags/4.1.4"],
  license: "GPL",
  copyright: "Frank Furter, Dr.-Ing. 2015"
)
::

Common fields

list::
## name
## summary
## author
## copyright
## license - default is GPL
## version - semver compatible string is preferred eg. "1.0.0"
## schelp - title  of the primary help file
## url - home page, defaults to the github/bitbucket url
## dependencies - see below
## isCompatible - a function returning a Boolean. Can check for presence of classes, features, version numbers.
## organization
## country
## since
## ext_dependency - text describing external software like "PD" or "processing"
## preInstall - a function / hook which will be called before installation - see link::Guides/UsingQuarks#Hooks::
::

dependencies is a list of Quarks or git urls with optional an @refspec

code::
Bjorklund
cruciallib@tags/4.1.4
::

subsection::Hooks

note::
Introduced in SuperCollider 3.13 and therefore only available if running at least this version.
::

It is possible to run a functions which are defined in the code::.quark:: file at specific points of installation or update process, so called "hooks".

This can be used to setup or delete certain directory structures, check for hardware, etc.

Upon execution, the hook function will be handled link::Classes/Quark#-data::, which is the parsed code::.quark:: file as an Link::Classes/Event::, as the first argument.

The following hooks are available and will be executed by link::Classes/Quark#-runHook::

table::
    ## \preInstall || Will be executed before link::Classes/Quarks#*link:: ||
    ## \postInstall || Will be executed after link::Classes/Quarks#*link:: ||
    ## \preUpdate || Will be executed before link::Classes/Git#-pull:: || Upon execution this will have the old state of the code::.quark:: file
    ## \postUpdate || Will be executed after link::Classes/Git#-pull:: || Upon execution this will have the new, updated state of the code::.quark:: file
    ## \preUninstall || Will be executed before link::Classes/Quarks#*unlink:: ||
    ## \postUninstall || Will be executed after link::Classes/Quarks#*unlink:: ||
::

An example to create a directory with samples for a Quark could look like

code::
(
  name: "DemonWidgets",
  // ...
  preInstall: {|data|
	File.mkdir("~/samples/%".format(data[\name]));
  },
  postUninstall: {
	"Samples at '~/samples/DomenWidgets' must be deleted manually".warn;
  },
)
::

subsection::Deprecated/ignored fields

teletype::path:: was used for SVN

teletype::helpdoc:: specifies an html help file in the Quark. It will still work and will load the helpfile, but schelp is preferred.

section:: Contributing fixes to a quark

Best practice is to clone the quark into a folder where you do your development work.
Make a ~/supercollider/quarks (or wherever you want it) and add this to the Quarks folders:

code::
Quarks.addFolder("~/supercollider/quarks");
::

git clone the quark into that folder. You can do your development work / hacking there
and submit a pull request to the repository owner.

There is a git extension that is quite useful for working with github repositories is https://hub.github.com

If you use Quarks.gui you should now be able to see both the downloaded version of the quark and also your own cloned version.

section:: Offline Usage

Quarks should be usable even when offline.
The directory is cached, refreshed every four hours.
Cloned quarks can switch versions without needing to be online.

You can download a zipped release of all quarks:

https://github.com/supercollider-quarks/quarks/releases


title:: Working with HID
summary:: A guide to using HID devices for control input
categories:: External Control>HID
related:: Classes/HID, Classes/HIDFunc

section:: Introduction

Human input devices can be used as controllers for making music. The HID and HIDFunc classes provides you with access to them in a simple and transparent way.

The development of this SuperCollider implementation of HID access was funded by the SuperCollider community and BEK, Bergen Elektronisk Kunst, Bergen, Norway, http://www.bek.no

subsection:: What are HID devices?

HID stands for Human Input Device, so in a sense saying HID device is saying Human Input Device device. Another confusion is that HID's are not merely input devices, they can also have outputs, e.g. the leds which indicate whether you have turned CapsLock or NumLock on, or force feedback (or vibration) in game devices.

Nowadays most HID's use USB to connect to computers, although there are some HID's that use BlueTooth instead (but not all BlueTooth HID's adhere to the standard protocols, most notably the WiiMote does not). SuperCollider provides the means to access HID's in as far as they adhere to the standard protocols that have been created for them. In the implementation we have tried to make the use of HID's as much crossplatform compatible as possible, so that you do not have to change code when transferring to another platform (e.g. from macOS to Linux and vice versa). However, it may be that some HID's use special driver software, that make this impossible. Other incompatibilities may arise from the fact that although there is a standardisation on the device level, the different operating systems then provide software interfaces which vary, so in a way we have had to reverse engineer the differences that the operating systems introduce.

NOTE:: the backend for Windows has not been completed yet, so HID is not working yet on Windows.::


section:: General workflow

The general workflow to work with HID devices is to:

LIST::
## Find the devices that are attached to the computer
## Open the device that you want to work with
## And assign functions to the different controls that the device has
::

When you want to use an HID, you will initially want to explore the device and check out its capabilities, and then write some code that you can reuse every time you want to start using your instrument.

section:: Exploring HID

Here is a short example of how to explore which HID's are attached, and what input they generate:

DEFINITIONLIST::
	## Find available devices:
	|| code:: HID.findAvailable; ::
	## Print a readable list of available devices:
	|| code:: HID.postAvailable; ::
	## Open a specific device:
	|| code:: ~myhid = HID.open( 1103, 53251 ); ::
	## Print all HID output:
	|| code:: HID.debug = true; ::
	## Alternatively (see below for the difference),
    || code:: HIDFunc.trace( true ); ::
::

The method code:: findAvailable :: will check which devices are connected to the computer, and retrieve basic information about them. With the method code:: postAvailable :: the list of devices is then printed to the post window in a readable list, in the first column the index into the devicelist is given, in the second column various properties of the device are listed. These properties can be used to open a specific device.

To open the device, there are various methods available:
LIST::
## using the index into the device list, e.g.: code:: HID.openAt( 0 ); ::
## using the path in the operation system, e.g.: code:: HID.openPath( "/dev/hidraw4" ); ::
## using the vendor id and product id of the device, and optionally the path, e.g.: code:: HID.open( 1103, 53251 ); ::
::

The last one (if the path is not given) is cross platform compatible. The vendor and product id are reported by the device to the operating system, and will thus always be the same. These numbers are unique for the type of device (e.g. any Nintendo Switch Pro Controller has the same number).
If you are using multiple of the same devices, you may want to adjust your setup to use the path as well in order to be able to identify which device you open.

NOTE:: if you have trouble opening a device, e.g. when you get the message code:: ERROR: HID: Could not open device::, please check the LINK::Guides/HID_permissions:: ::

NOTE:: on macOS the internal devices of laptops are somewhat messed up - they show up multiple times and do not have unique paths, this makes it hard to open a specific one of them.::

You can always check which devices have already been opened by SuperCollider with

code:: HID.openDevices; ::

subsection:: Exploring HID control data

If you have enabled debugging of the HID input data, and you move one of the controls on your device, you will get an output similar to this:

code::
HID Element Data:
	devid: 0, elid: 18
	element: 	 page: 1	usage: 53
	array value: 0, 	raw value: 128,	physical value: 128,	value: 0.50196081399918
::

An EMPHASIS::element:: is the name for an element of the HID, it can represent for example the x-axis of a joystick, or the first key that is pressed on a keyboard.

The EMPHASIS::devid:: is the index into the dictionary of open devices (code:: HID.openDevices; ::), the element id (EMPHASIS::elid::) is the index into the array of elements of the device. This index can vary between operating systems, so it is mostly just used internally.

The EMPHASIS::page:: and EMPHASIS::usage:: of the element are lookup indices for the functionality of the element. These lookup indices are standardized and tables are available to look up the names of the controls.

The EMPHASIS::raw value:: is the value as it comes in - it is not scaled in anyway. The EMPHASIS::value:: is scaled between 0 and 1 according to the logical minimum and maximum that is reported by the device.

The EMPHASIS::array value:: is only of importance for those elements which can represent multiple usages, such as from keyboards. In that case it indicates the key that is pressed, and by adding this number to the usage of the element you know which function the key has.

With the debugging method code::HIDFunc.trace( true ):: the data will be printed in a different way:

code::
HID Element Data:	devid: 0, elid: 18
	device: 	a HIDInfo(Thrustmaster, Run'N' Drive, IDs:1103, 53251, /dev/hidraw4, , 258, 0), 	page: 1 	usage: 5
	element:	a HIDElement(18: type: 2, usage: 1, 53)
				page: 1	usage: 53	raw value: 128,	value: 0.50196081399918
::

Turn debugging off again with:

LIST::
## code:: HIDFunc.trace( false )::
## code:: HID.debug_( false )::
::

Rather than looking at the data as it comes in, we can also check which elements the device has with

LIST::
## code::~myhid.postElements::
## code::~myhid.postInputElements::
## code::~myhid.postOutputElements::
::

Or check which usages are available:
code::~myhid.postUsages::

These will post detailed information on each element:

code::
HID Element: 18, type: 1, 2, usage page: 1, usage index: 53
	Description: GenericDesktop, Rz, input,
	[ Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, NonVolatile, BitField ]
	Usage range: [ -1, -1 ]
	Logical range: [ 0, 255 ]
	Physical range: [ 0, 255 ], Unit: 0, Exponent: 0
	Report ID: 0, size 8, index 5
::

The EMPHASIS::type:: is a numerical index of whether it is an input, output or feature element, the second one indicates other properties. In the description the page and usage are translated using the table lookup, and the type indication is also translated to something understandable.

The usage range is again of importance for keyboards, the logical and physical range give ranges within which values will vary.
The report ID, size and index give low level information on how the data comes in.


subsection:: Assigning actions to HID control data

Whenever data comes in from an opened HID device, there are two types of actions fired. An action for the incoming element data and an action for the device, indicating that there has been a change in one of the elements. In most cases you will want to use the first action; only in cases where the order of parsing the element data is important, you may want to use the second type - e.g. when dealing with very accurately timed button press combinations.

There are three levels where you can set actions:
LIST::
	## at the global level - called for any HID device, for any element
	## at the device level - called for the specific device, for any element
	## at the element level - called for the specific element of the specific device
::

Alternately, you can also use the LINK::Classes/HIDFunc:: interface, which allows filtering of events for multiple devices based on their usage.

DEFINITIONLIST::
## the global level
|| code:: HID.action = { |value, rawValue, usage, page, elid, element, devid, device | "HID global action: ".post; [value, rawValue, usage, page, elid, element, devid, device].postln; }; ::
## the device level
|| code:: ~myhid.action = { | value, physValue, rawValue,  arrayValue, usage, page, elid | "HID device action: ".post; [value, physValue, rawValue,  arrayValue, usage, page, elid].postln; }; ::
## the element level
|| code:: ~myhid.elements.at(18).action = { |value,element| "HID element action: ".post; [value,element].postln; }; ::
## using HIDFunc
|| code:: HIDFunc.usage( { |value, rawValue, usage, page, elid, ele, devid, device, key| "HIDFunc.usage action: ".post; [value, rawValue, usage, page, elid, ele, devid, device, key].postln; }, \Rz ); ::
## using HIDdef
|| code:: HIDdef.usage( \myRz, { |value, rawValue, usage, page, elid, ele, devid, device, key| "HIDdef.usage action: ".post; [value, rawValue, usage, page, elid, ele, devid, device, key].postln; }, \Rz ); ::
::

The LINK::Classes/HIDFunc:: and LINK::Classes/HIDdef:: options allow for the most flexible control and are similar to the use of LINK::Classes/MIDIFunc:: and LINK::Classes/MIDIdef:: and LINK::Classes/OSCFunc:: and LINK::Classes/OSCdef::.

The advantages are that you can filter for just the type of control, so you can easily replace your game controller with a game controller of a similar type.

Let's close the device again:
code::
~myhid.close;
::

section:: A simple example

code::
HID.findAvailable; // check which devices are attached
~myhid = HID.open( 1103, 53251 ); // open the Run'N' Drive game controller

s.boot; // boot the server

Ndef( \sinewave, { |freq=500, amp=0.1| SinOsc.ar( freq, 0, amp * 0.2 ) } );
Ndef( \sinewave ).play;

~freqRange = [500, 5000, \exponential].asSpec; // create a frequency range

HIDdef.usage( \freq, { |value| Ndef( \sinewave ).set( \freq, ~freqRange.map( value ) ); }, \X );
HIDdef.usage( \amp, { |value| Ndef( \sinewave ).set( \amp, value ); }, \Y );
::

section:: Finding a device automatically again after it is detached

code::
(
Tdef( 'tryOpenHID' , {
   var keepLooking = true;
   while ( { keepLooking } ){
      if ( ~myhid.notNil ){
         if ( ~myhid.isOpen ){
            keepLooking = false;
         }
      };
      if ( keepLooking ){
         HID.findAvailable;
         if ( HID.findBy(1103, 53251).size > 0 ){
            ~myhid = HID.open( 1103, 53251 );
            if ( ~myhid.notNil ){
               ~myhid.closeAction = {
                    "device closed".postln;
                    Tdef( \tryOpenHID ).reset.play;
               };
               keepLooking = false;
            }{
               3.0.wait;
            };
         }{
            3.0.wait;
         }
      }
   }
} );
);
Tdef( 'tryOpenHID' ).play;
::


title:: Writing Classes
summary:: Writing SuperCollider Classes
categories:: Language>OOP
related:: Reference/Classes, Classes/Class, Classes/Object


SuperCollider follows a pure object-oriented paradigm. It is not built on data types, but on objects, which respond to messages. A class is an object that holds information about how its objects (instances) respond to such messages. Writing a class gives a definition of this behavior.

This is an overview of idioms used in writing classes. It is not a tutorial on writing a system of interrelated classes. It gives an overview of some typical expressions. See also: link::Guides/Intro-to-Objects::, link::Reference/Messages::, and link::Reference/Classes::.

There is also an overview of the current full link::Overviews/ClassTree::.

note:: Class definitions are statically compiled when you launch SuperCollider or "recompile the library." This means
that class definitions must be saved into a file with the extension .sc, in a disk location where SuperCollider looks
for classes. Saving into the main class library (SCClassLibrary) is generally not recommended. It's preferable to use
either the user or system extension directories.

code::
Platform.userExtensionDir;   // Extensions available only to your user account
Platform.systemExtensionDir; // Extensions available to all users on the machine
::

It is not possible to enter a class definition into an interpreter window and execute it.
::


section:: Inheriting

To avoid having to write the same code several times, classes can strong::inherit:: implementations from their strong::superclasses::.

code::
MyClass : SomeSuperclass {

}
::

Without specifying a superclass, link::Classes/Object:: is assumed as the default superclass.

code::
MyClass { // : Object is implied

}
::

This is why in the above example, the message code::new:: can be called without being explicitly defined in the class.



section:: Methods

subsection:: Instance Methods

Each object instance responds to its strong::instance methods::. Instance methods are called in the local context of the object. Within instance methods, the keyword code::this:: refers to the instance itself.

code::
MyClass {

	instanceMethod { | argument |
		this.anotherInstanceMethod(argument)
	}

	anotherInstanceMethod { | argument |
		"hello instance".postln
	}
}
::

This could then be used as follows:

code::
a = MyClass.new // returns a new instance
a.instanceMethod // posts "hello instance"
::


To return from the method use teletype::^:: (caret). Multiple exit points also possible. If no teletype::^:: is
specified, the method will return the instance (and in the case of Class methods, will return the class). There is no
such thing as returning void in SuperCollider.

code::
MyClass {
	someMethod {
		^returnObject
	}

	someOtherMethod { | aBoolean |
		if(aBoolean) {
			^someObject
		} {
			^someOtherObject
		}
	}

}
::


subsection:: Class Methods


An object's  strong::class methods:: are defined alongside its instance methods. They are specified with an asterisk (teletype::*::) before the method name.


A link::Classes/Class:: is itself an object. It is what all instances of it have in common. Class methods are the instance methods of the object's class. That's why within class methods, the keyword code::this:: refers to the class.

code::
MyClass {
	*classMethod { | argument |
		this.anotherClassMethod(argument)
	}

	*anotherClassMethod { | argument |
		"hello class".postln
	}

}
::

This could then be used as follows:

code::
MyClass.classMethod // posts "hello class"
::


subsection::Overriding methods (overloading)

To change the behaviour inherited from the superclass, methods can be overridden. Note that an object looks always for
the method it has defined first and then looks in the superclass. Here code::MyClass.value(2):: will return 6, not 4:

code::
SomeSuperclass {
	calculate { |in| ^in * 2 }
	value { |in| ^this.calculate(in) }
}

MyClass : SomeSuperclass {
	calculate { |in| ^in * 3 }
}
::

The keyword code::super:: can be used to call methods on the superclass

code::
SomeSuperclass {

	value {
		^100.rand
	}
}

MyClass : SomeSuperclass {

	value {
		^super.value * 2
	}
}
::



section:: Instances

code::Object.new:: will return a new object. When overriding the class method code::.new:: you must call the
superclass, which in turn calls its superclass, up until code::Object.new:: is called and an object is actually created
and its memory allocated.

code::
MyClass {

	// this is a normal constructor method
	*new { | arga, argb, argc |
		^super.new.init(arga, argb, argc)
	}

	init { | arga, argb, argc |
		// do initiation here
	}
}
::

In this case note that code::super.new:: called the method new on the superclass and returned a new object. Subsequently
we are calling the code::.init:: method on that object, which is an instance method.

Warning:: If the superclass also happened to call super.new.init it will have expected to call the .init method defined
in that class (the superclass), but instead the message .init will find the implementation of the class that the object
actually is, which is our new subclass. In such cases, a unique method name like myclassInit should be used.
::

One easy way to copy the arguments passed to the instance variables when creating a class is to use link::Classes/Object#*newCopyArgs::.  This
method will copy the arguments to the instance variables in the order that the variables were defined in the class,
starting from the parent classes and working it's way down to the current class.

code::
MyClass {
	var a,b,c;

	*new { | a, b, c |
		^super.newCopyArgs(a, b, c)
	}
}

MyChildClass : MyClass {
	var d;

	*new { | a, b, c, d |
		^super.newCopyArgs(a, b, c, d)
	}
}
::

Class variables are accessible within class methods and in any instance methods.

code::
MyClass {
	classvar myClassvar;

	instanceMethod {
		^myClassvar
	}
}
::

Initializations on class level (e.g. to set up code::classvar::s) can be implemented by overloading the link::Classes/Class#*initClass:: method.

code::
MyClass {
	classvar myClassvar;

	*initClass {
		myClassvar = IdentityDictionary.new;
	}
}
::




section::Alternatives to inheritance

Overreliance on inheritance is usually a design flaw. Inheritance is mainly a way to organise code, and shouldn't be mistaken for a categorisation of objects. Two objects may respond to a message in different ways (polymorphism), and objects delegate control to ther objects they hold in their instance variables (object composition).

subsection::Polymorphism

See also: link::Guides/Polymorphism::

Two completely unrelated objects can respond to the same messages and therefore be used together in the same code. For example, link::Classes/Function:: and link::Classes/Event:: have no common superclass apart from the general class link::Classes/Object::. But both respond to the message code::play::. Instead of inheriting all methods, you can simply implement some of the same methods in your class.

code::
MyClass {
	var count = 0;
	value {
		^count = count + 1
	}
}
// objects of this class will respond to the message "value", just like a function.
a = MyClass.new;
a.value; // returns 1
::


subsection::Object Composition
Often, an object passes control to one of the objects it has in its instance variables. Because these objects can be of any kind, this is a very flexible way to achieve a wide range of functionalities. For example, a link::Classes/Button:: has an code::action:: instance variable, which may hold anything that responds to the message code::value::.

code::
MyClass {
	var action;
	*new { |action|
		^super.newCopyArgs(action)
	}
	value { |x|
		action.value(x);
	}
}

// depending on what "action" is, objects of this class will behave differently
a = MyClass({ "hello." });
b = MyClass({ |i| log2(i) * sin(i * pi) });
a.value(8);
b.value(8);
::

Often, variables like code::action:: above are filled with custom objects that belong to code::MyClass::. Thus, one will write many small classes that can be well combined in such a way. This is called "pluggable behavior".


section::Variables

subsection:: Initializing variables directly

In a variable declaration, variables can be directly initialized. Only link::Reference/Literals:: may be used to initialize variables this way. This means that it is not possible to chain assignments (e.g. code:: var x = 9; var y = x + 1::).

code::
MyClass {
	classvar all = #[];
	var x = 8;
	var y = #[1, 2, 3];
}
::


subsection:: Variable Scope

An instance variable is accessible strong::from all instance methods:: of this class and its subclasses. A class variable, by contrast, is accessible strong::from all class and instance methods:: of this class and its subclasses. Instance variables will shadow class variables of the same name.

code::
MyClass {
	classvar x = 0, y = 1;
	var x = 1;

	*returnX { ^x } // returns 0
	returnX { ^x } // returns 1
	returnXY { ^x + y } // returns 2
}
::

Subclasses can override class variable declarations (but not instance variables). Then the class variables of the superclass are not accessible in the subclass anymore.

code::
SomeSuperclass {
	classvar x = 0;

	returnX { ^x }
	returnXHere { ^x }
}

MyClass : SomeSuperclass {
	classvar x = 1;

	returnXHere { ^x }
}

// SomeSuperclass.returnXHere returns 0
// MyClass.returnXHere returns 1
// MyClass.returnX returns 0


::

subsection:: Getters and Setters

SuperCollider demands that variables are not accessible outside of the class or instance. A method must be added to
explicitly give access:

code::
MyClass : SomeSuperclass {
	var myVariable;

	variable {
		^myVariable
	}

	variable_ { | newValue |
		myVariable = newValue;
	}
}
::

These are referred to as getter and setter methods. SuperCollider allows these methods to be easily added by adding teletype::<:: or
teletype::>::.

code::
MyClass {
	var <getMe, >setMe, <>getMeOrSetMe;
}
::

This provides the following methods:

code::
someObject.getMe;
someObject.setMe_(value);
::

And it also allows us to say:

code::
someObject.setMe = value;

someObject.getMeOrSetMe_(5);
someObject.getMeOrSetMe;
::


A getter or setter method created in this fashion may be overridden in a subclass by explicitly defining the method. Setter methods should take only one argument to support both ways of expression consistently.  eg.

code::
MyClass {

	variable_ { | newValue |
		variable = newValue.clip(minval,maxval);
	}

}
::

A setter method should always return the receiver. This allows us to be sure that several setters can chained up.


subsection::Constants
Constants are variables, that, well, don't vary. They can only be assigned initially.

code::
MyClass {
	const <zero = 0;
}

MyClass.zero // returns 0
::

section:: External method files

Methods may be added to Classes in separate files.  This is equivalent to Categories in Objective-C.  By convention, the
file name starts with a lower case letter: the name of the method or feature that the methods are supporting.

code::
+ Class {

	newMethod {

	}

	*newClassMethod {

	}

}
::


section:: Slotted classes

Classes defined with code::[slot]:: can use the syntax code::myClass[...]:: which will call code::myClass.new:: and then code::this.add(each):: for each item in the square brackets.

code::
MyClass[] {
	var <allOfThem;
	add { |item|
		allOfThem = allOfThem.add(item)
	}
}

a = MyClass[1, 2, 3];
a.allOfThem; // [1, 2, 3]
::

section:: Printing to string

subsection:: Printing custom messages to post window

By default when postln is called on an class instance the name of the class is printed in a post window. When
code::postln:: or code::asString:: is called on a class instance, the class then calls code::printOn:: which by default returns just the object's class name. This should be overridden to obtain more useful information.

code::
MyTestPoint {
	var <x, <y;

	*new { |x, y|
		^super.newCopyArgs(x, y)
	}

	printOn { | stream |
		stream << "MyTestPoint( " << x << ", " << y << " )";
	}
}
::

code::
a = MyTestPoint(2, 3)
::

subsection:: Defining custom asCompileString behaviour

A call to code::asCompileString:: should return a string which when evaluated creates the exact same instance of the
class. To define a custom behaviour one should either override code::storeOn:: or code::storeArgs::. The method
code::storeOn:: should return the string that evaluated creates the instance of the current object. The method
code::storeArgs:: should return an array with the arguments to be passed to code::TheClass.new::. In most cases this
method can be used instead of code::storeOn::.

code::
// either
MyTestPoint {
	var <x, <y;

	*new { |x, y|
		^super.newCopyArgs(x,y)
	}

	storeOn { | stream |
		// note that <<< stands for storeOn, and << for printOn.
		// we want x and y to be completely represented
		stream << "MyTestPoint.new(" <<< x << ", " <<< y << ")"
	}
}

// or
MyTestPoint {
	var <x, <y;

	*new { |x, y|
		^super.newCopyArgs(x,y)
	}

	storeArgs { | stream |
		^[x, y]
	}
}
::

code::
MyTestPoint(2, 3).asCompileString;
::

section::Private Methods

Private methods are marked by a prefix code::pr::, e.g. code::prBundleSize::. This is just a strong::naming convention::; the message can still be called from anywhere. It is recommended to stick to convention and only call private methods from within the class that defines them.


section:: Catching undefined method calls

When a message is received that is undefined, the receiver calls the method code::doesNotUnderstand::. Normally this throws an error. By overriding code::doesNotUnderstand::, it is possible to catch those calls and use them. For an example, see the class definition of code::IdentityDictionary::.

code::
MyClass {

	doesNotUnderstand { | selector...args |
		(this.class ++ " does not understand method " ++ selector);

		if(UGen.findRespondingMethodFor(selector).notNil) {
			"But UGen understands this method".postln
		};
	}
}
::

code::
a = MyClass();
a.someMethodThatDoesNotExist
::



title:: Writing Help
summary:: Get started with writing help
categories:: HelpSystem
related:: Reference/SCDocSyntax, Classes/SCDoc

section:: Writing new help
The simplest way is to look at an existing help file or class document, and read this document and link::Reference/SCDocSyntax::

note:: The help files should use UTF-8 encoding! ::

All tags that are used for document metadata should be entered at the top of the document source file, before any section or other text. See link::Reference/SCDocSyntax#Header tags::

In the header, you must specify the title, summary and categories parts of the header.

Example header:
teletype::
title:: My help file
summary:: A short single-line summary of what this is
categories:: Language>Conditionals, SomeOtherCategory
related:: Reference/FooBar
::

Use regular text in sections and subsections, and possible other tags for lists, tables, trees, images, links, etc.. See link::Reference/SCDocSyntax:: for tag reference.

teletype::
section:: Introduction

This is a nice document...
blah blah blah..

subsection:: Details

Some details..
::

subsection:: Documenting new classes
When you navigate to an undocumented class, it will contain an schelp template that can be filled in and saved to HelpSource/Classes/ClassName.schelp.

A list of all undocumented classes can be seen here: link::Browse#Undocumented classes:: (auto-generated).

section:: Directory layout
The help system uses different folders under HelpSource depending on document kind:
definitionlist::
## HelpSource ||
definitionlist::
## Classes || class reference, file must be named as the class.
## Reference || other reference documentation.
## Tutorials || yes, tutorials.
## Guides || guides that explain stuff but without being a real tutorial.
## Overviews || overviews of other documents, these are mostly auto-generated.
## Other || stuff that don't fit in any other directory.
::
::

note:: It's important that the document is put in the right folder. For Classes, it's a must! ::

All .schelp files will be parsed and rendered to an equal directory layout in the help target directory. Any other files, like images or ready-made HTML files, will just be copied.

section:: Class reference
Class reference has some special tags and a more strict structure. Normal text should be written inside the special top-level sections DESCRIPTION, CLASSMETHODS, INSTANCEMETHODS and EXAMPLES.

Named subsections can be used under each of the above mentioned top-level sections.

Also named sections can be used, but they will be put after all above top-level sections.

subsection:: Methods and arguments
Methods are documented like this:
tree::
## teletype::method\:::: name(s)
    tree::
    ## short description of method.
    ## teletype::argument\:::: name1
    tree::
        ## description of argument
        ::
    ## teletype::argument\:::: name2
    tree::
        ## description of another argument.
        ::
    ## teletype::returns\::::
    tree::
        ## description of return value
        ::
    ## teletype::discussion\::::
    tree::
        ## optional discussion and example code
        ::
    ::
::

note:: Don't list arguments in the method tag, only the method names ::

After the method description comes the arguments, written with teletype:: argument\:: name :: where
strong::name:: is optional, and will be auto-filled in if not given. If given, it must match the real argument name of the method. After each argument line comes the description of that argument.

There is an optional teletype::returns\:::: tag that could be used to describe the methods return value.

If a longer discussion is needed, use the teletype::discussion\:::: tag. This is a good place to insert example code, etc.

Setters are handled automagically, when documenting a setter/getter, use only the getter name (no underscore) and describe both setter and getter as a single property, example:
teletype::
method:: helpSourceDir
set or get the help source directory
::

Methods get an anchor name automatically, prefixed with teletype::*:: for class methods and teletype::-:: for instance methods. For example, to link to the teletype::foo:: class method, use teletype:: link\::#*foo\:: ::.

The teletype::method\:::: tag can be used also in normal documents, and emphasis::should:: then have argumentnames. This can be useful for documenting common interfaces outside of a specific class document, for example link::Reference/plot::.
Anchors for these methods get prefixed with a dot (.) instead of * or -.

When multiple methods have the same signature (like ar and kr in ugens), they should all be listed in one single method tag.

SCDoc generates docs for all undocumented methods. To ignore private methods, add them to a teletype::private\:::: tag, which works just like the method tag but without a section body.

Extensions can add methods to existing class docs, see the link::#Extensions:: section below.

subsection:: Copy methods from other class
You can use teletype:: copymethod\:: ClassName, methodName :: to copy the documentation of a method from another helpfile to this one.

teletype::methodName:: must be prefixed with teletype::*:: (asterix) for class methods and teletype::-:: (dash) for instance methods.

subsection:: Redirect classes
Some classes uses the code::*doesNotUnderstand:: trick to redirect to another implementing class. To document such classes, you need to add this tag in the header:
teletype::
redirect:: implClass
::
Where teletype::implClass:: is the name of the class variable holding the implementing class.

subsection:: Example

An example of documentation for LFPulse UGen, saved to HelpSource/Classes/LFPulse.schelp

teletype::
TITLE:: LFPulse
summary:: pulse oscillator
categories:: UGens>Generators>Deterministic, UGens>Oscillators
related:: Classes/LFSaw

DESCRIPTION::
A non-band-limited pulse oscillator. Outputs a high value of one and a low value of zero.

CLASSMETHODS::
private:: categories

METHOD:: ar, kr

argument::freq
frequency in Hertz

argument::iphase
initial phase offset in cycles ( 0..1 )

argument::width
pulse width duty cycle from zero to one.

returns::
An UGen.

EXAMPLES::

a plot:
code:: { LFPulse.ar(Line.kr(100, 800, 0.1)) }.plot(0.1); ::

50 Hz wave:
code:: { LFPulse.ar(50) * 0.1 }.play; ::
::

section:: Categories
Try to find good categories for the doc you are writing/converting. If a suitable category already exists, you should use that. See the link::Browse##Document Browser:: (auto-generated) for existing categories.

For UGens, you should use the existing categories like UGens>Filter>Nonlinear. View the current categories like this:
code::
Ball.categories
::

Documents can exist in multiple categories, and also have hierarchical categories, like Sequencing>Patterns.

section:: Cross-document linking
To link another document, use teletype:: link\::Path/To/Document\:: :: where the path is relative to link::Classes/SCDoc#*helpTargetDir:: and the document filename is with no extension. Example:
teletype::
Also take a look at link::Classes/SinOsc:: and link::Reference/Literals::
::

subsection:: Methods
To link to a specific class method, append code::#*methodName:: or to an instance method, append code::#-methodName:::
teletype::
Also take a look at the play method of link::Classes/Function#-play::
::
This will render as link::Classes/Function#-play::

For generic methods documented outside of instancemethods or classmethods (like the generic link::Reference/play:: document), use a dot (.) as prefix instead of * or -.

The special link::Overviews/Methods:: overview is dynamic and allows a specific method to be shown by appending code::#name:: where name is the name of the method:
teletype::
For all implementations of play, see link::Overviews/Methods#play::
::

section:: Making the document findable by Search
The link::Search:: page can match on document title/filename, summary, non-private methods, and categories.
If you mention something that should match in search but is not one of the above, you can explicitly add it with the keyword tag:
teletype::
keyword:: someKeyWords
::

section:: Extensions
subsection:: Quarks and extensions
Each extension should have their own HelpSource folder with files that should be included in the help system.

Example file layout:
code::
MyQuark/HelpSource/Classes/MyClass1.schelp
MyQuark/HelpSource/Classes/MyClass2.schelp
MyQuark/HelpSource/Guides/MyGuide.schelp
MyQuark/HelpSource/Guides/MyPicture.png
MyQuark/MyClass1.sc
MyQuark/MyClass2.sc
::

note::
All helpfiles contained in a quark will automatically get a category "Quarks>NameOfQuark" added, so you should not add this yourself. This makes it easy to navigate all documentation of a specific quark.
::

If you want to set a main help file for the quark, set code::\schelp:: in the Quark directory file to the path for the help file relative to teletype::HelpSource:: and without the teletype::.schelp:: extension. Example: code::\schelp: "Guides/MyGuide"::

subsection:: Method extensions
An extension that adds methods to existing classes should document these in code::Classes/TheClass.ext.schelp::, only including the relevant bits (no title, summary, categories, etc..)

Example: Classes/String.ext.schelp
teletype::
INSTANCEMETHODS::

subsection:: Extensions by SCDoc

method:: stripWhiteSpace
strips whitespace at the beginning and end of the string
returns:: the stripped string
::

The contents are inserted into the right spot (section, subsection, etc).
It works for all kind of sections, for example one can add a subsection to code::DESCRIPTION\:::: with additional information, or add another top-level section, etc.

section:: Links

URL's are automagically converted to links.

The code::link\:::: tag is used for cross-reference between docs. It uses a simple namespace, example:
code::
See also link::Classes/SinOsc:: for a nice oscillator.
Or take a look at link::Browse#UGens:: for a full list.
The link::Overviews/Methods#play#play method:: is often very useful.
::

Anchors can be inserted manually with code::anchor\::name\:::: and referenced like this: code::
link::Foo/Bar#hello::
::
or to jump to an anchor in this document: code::
link::#hello::
::

All sections get anchor names automagically.

All methods get anchor names prefixed with code::*:: for class methods and code::-:: for instance methods.

One can change the rendered text of the link by using another code::#:: character:
code::
Also see link::Classes/SinOsc##a nice oscillator::
::

A link to specific methods:
code::
Take a look at link::Classes/SinOsc#*ar:: and link::Classes/Function#-play::
::
Renders as: link::Classes/SinOsc#*ar:: and link::Classes/Function#-play::

The link::Overviews/Methods:: overview is dynamic and allows a specific method to be shown, by using the methodname as anchor, for example to get a list of all classes implementing code::play:: :
code::
All classes implementing code::play:: can be seen link::Overviews/Methods#play#here::.
::
Renders as: All classes implementing code::play:: can be seen link::Overviews/Methods#play#here::.

The link::Browse:: page is also dynamic, and can take a category tree as anchor name:
code::
For more filters, see link::Browse#UGens>Filters::
::
Renders as: For more filters, see link::Browse#UGens>Filters::

section:: Contributing with documentation

The easiest way to contribute to the documentation is:

    1. Fork the SuperCollider repository https://github.com/supercollider/supercollider

    2. Clone your repository
    code::
    git clone --recursive https://github.com/{your_username}/supercollider.git
    ::
    3. Create a branch for doc updates
    code::
    git checkout -b doc_updates
    ::
    4. Do your update, commit your changes and push to github
    code::
    git push origin -u doc_updates
    ::
    5. Submit your pull request through github, from your branch doc_updates to SuperCollider develop

section::Working with legacy documentation

Here is some information for working with documentation that is written in legacy format or syntax.

subsection:: News in SC 3.5.2
SCDoc was rewritten and the parser implemented in C++ for speed and stability in 3.5.2.
The syntax got more strict, and the parser now throws errors or warnings if there are faults in the documentation.

Some important changes to keep in mind:

list::
## Linking to sections does no longer use lower_case_and_underscored anchors, but the exact section title as it is. Example: teletype::link\::#Language-side news\:::: renders: link::#Language-side news::
## Run code::SCDoc.indexAllDocuments:: if you add a new document or other file and want to see the change reflected in the help. If you just changed a document and want to see the changes, just press Reload in the browser and SCDoc will detect and re-index automatically.
## The teletype::CLASS\:::: tag is deprecated, just use teletype::TITLE\:::: instead also for class reference docs.
## The argument name given to the teletype::ARGUMENT\:::: tag is now optional. If not given, SCDoc will auto-fill the real argument name.
::

subsection:: Converting old helpfiles
There is no automated process for this, but for most help files it's really simple to do it manually:

numberedlist::
## open the old helpfile in your web browser
## copy the text and insert it in a new textfile: FileName.schelp
## add the appropriate tags, like title, sections, etc.. (see below)
## save the file to the right subdirectory under HelpSource, depending on the document kind (see link::#Directory layout:: below)
## strong:: check that it rendered OK ::.
You can run code::SCDoc.indexAllDocuments:: (link to method documentation: link::Classes/SCDoc#*indexAllDocuments::) to make SCDoc detect the new file and add it to the document index.

If the file already existed and you want to see the changes, just press Reload in the help browser and SCDoc will re-render it.
::


title:: Writing Primitives
summary:: Writing Primitives
categories:: Internals

Although much of SuperCollider's functionality is implemented in the SuperCollider language itself, for reasons of efficiency, some functionality is implemented in 'back end' C++ functions called 'primitives'. This document provides guidance to members of the SC development community on writing primitives.

section:: Example
subsection:: SuperCollider code

Primitive calls are preceded with an underscore, so for example code::_myPrimitiveName::. Here is an example call to a primitive in an SC class:

code::
Cocoa {
    prGetPathsDialog { arg returnSlot;
        _Cocoa_GetPathsDialog
        ^this.primitiveFailed
    }
}
::

In the example above the primitive is dispatched at code::_Cocoa_GetPathsDialog::. If it is successful, it will return without executing the code below that. Primitive functions (see below) return an integer, which should be one of the values defined in the file emphasis::PyrErrors.h:::

teletype::
enum { // primitive errors
	errReturn = -1,	// not really an error.. primitive executed a non-local return
	errNone,
	errFailed = 5000,
	errBadPrimitive,
	errWrongType,
	errIndexNotAnInteger,
	errIndexOutOfRange,
	errImmutableObject,
	errNotAnIndexableObject,
	errStackOverflow,
	errOutOfMemory,
	errCantCallOS,
	errException,

	errPropertyNotFound = 6000,

	errLastError
};
::

If your primitive can return any value besides teletype::errNone:: then you will need to provide handling code after the primitive call. In most cases this will be code::^this.primitiveFailed::. This will throw an code::Error:: giving the user information about what went wrong.

In some cases, you may wish to execute fallback SC code instead of throwing an code::Error::. This can be useful in cases where for example a primitive provides an optimised version of a method which is not usable in all instances. Here is an example of how this can be done:

code::
flop {
	_ArrayMultiChannelExpand
	^super.flop // this gets executed if the primitive fails
}
::

Note that returning anything besides teletype::errNone:: will result in executing the SC method emphasis::ignoring:: the primitive call. For this reason, if you need to do some preparatory work in SC before calling the primitive, it is best practice to do this in a separate method to avoid duplication. For example:

code::
// do initial work here
openUDPPort {|portNum|
	var result;
	if(openPorts.includes(portNum), {^true});
	result = this.prOpenUDPPort(portNum);
	if(result, { openPorts = openPorts.add(portNum); });
	^result;
}

// this method only calls the primitive, and throws any primitive errors
prOpenUDPPort {|portNum|
	_OpenUDPPort
	^this.primitiveFailed;
}
::

subsection:: Define your primitive

In your primitive source code define the primitive:

teletype::
void initCocoaFilePrimitives()
{
    int base, index;

    base = nextPrimitiveIndex();
    index = 0;

    definePrimitive(base, index++, "_Cocoa_GetPathsDialog", prGetPathsDialog, 2, 0);
    // further primitives can be laid in...
    //definePrimitive(base, index++, "_Cocoa_SaveAsPlist", prSaveAsPlist, 3, 0);
}
::


Here is the prototype for teletype::definePrimitive:::

teletype::
int definePrimitive(int base, int index, char *name, PrimitiveHandler handler, int numArgs, int varArgs);
::

The teletype::numArgs:: is the number of arguments that were passed into the SuperCollider method that calls the primitive, plus one
to include the receiver which is passed in as the first argument.

(TODO varArgs ...)

subsection:: Write your primitive

teletype::g->sp:: is the top of the stack and is the last argument pushed.
teletype::g->sp - inNumArgsPushed + 1 :: is the receiver and where the result goes.

In this example, the teletype::numArgsPushed:: will be 2 (as specified in teletype::definePrimitive::)

teletype::
int prGetPathsDialog(struct VMGlobals *g, int numArgsPushed)
{
    if (!g->canCallOS) return errCantCallOS; //if its deferred, does this matter ?

    PyrSlot *receiver = g->sp - 1; // an instance of Cocoa
    PyrSlot *array = g->sp; // an array

    // ...  the body

    return errNone;
}
::

This example does not set the receiver, so the primitive returns the original receiver unchanged (still an instance of code::Cocoa::). Or set the object at teletype::receiver:: which again is at teletype::(g->sp - numArgsPushed + 1)::.


section:: Guidelines

subsection:: Creating objects in primitives, and GC safety

SuperCollider uses a garbage collector to manage memory allocation and collection where needed.footnote::Some SC language objects, such as numbers, boolean types, chars, and symbols are stored directly within a PyrSlot, and do not require allocation. (Symbols are a special case: A reference to a location in the global symbol table is stored, where each defined symbol is permanently stored.):: In order to meet the requirements of good real time performance, a small and bounded amount of garbage collection may be triggered each time an object is created. This consists of incrementally examining all objects and determining if they are reachable (see below) or not. Unreachable objects may have their memory reallocated to new objects.

The following points are important to understanding how the GC works, and how to avoid bugs:
list::
##An object is emphasis::reachable:: if it has
list::
  ##been stored on the stack, or
  ##been stored in an sclang variable, or a class variable, or
  ##been stored in another object that fulfills one of the above criteria
::
##The GC marks objects as one of the following:
list::
  ##strong::White:: - To be examined
  ##strong::Grey:: - Reachable, but containing objects which themselves have not been fully inspected and marked grey or black
  ##strong::Black:: - Reachable, with any contained objects all fully inspected
  ##strong::Free:: - Unreachable; memory is available for reuse
::
##If triggered, garbage collection will happen emphasis::before:: allocating the new object.
##The newly created object will be marked as strong::white:: (to be examined).
::

SC provides a number of functions which create new objects. These include teletype::instantiateObject::, teletype::newPyrObject::, teletype::newPyrString::, and teletype::newPyrArray::. Before any calls to such functions it is crucial that all previously created objects have been made reachable. If this is not done, it is possible that such objects will be marked as strong::free::. Since a freed object's memory may not be immediately reused, problems may not arise at the time your primitive is called, leading to extremely hard to find bugs.

Alternatively, most object creation functions include a teletype::bool runGC:: argument. If set to false, this will guarantee that the garbage collector does not run on this allocation. While not ideal, as it is best that GC activity is amortised to the extent possible, this option is safe, since the status of any previously created objects will not be changed.

The following two examples are both safe:
definitionlist::
##Make the newly created object reachable:
||teletype::
PyrSlot *arg = g->sp;
PyrObject *array1 = newPyrArray(g->gc, 2, 0, true); // runGC = true
SetObject(arg, array1); // make the array reachable on the stack
PyrObject *array2 = newPyrArray(g->gc, 2, 0, true);
...
::
##Set teletype::runGC:: to false:
||teletype::
PyrSlot *arg = g->sp;
// runGC = true
PyrObject *array1 = newPyrArray(g->gc, 2, 0, true);
// runGC = false so GC is not triggered, and array1 can't be freed
PyrObject *array2 = newPyrArray(g->gc, 2, 0, false);
...
::
::
One caveat: When making a new object reachable by storing it on the stack, you must ensure that you are not overwriting objects that will be needed later in the primitive. If this is done the receiver may be collected on any future allocations. One solution is to strong::push:: the object onto the stack, and then pop it when finished, e.g.:
teletype::
PyrSlot *receiver = g->sp;    // get the receiver
PyrObject *result = newPyrArray(g->gc, 2, 0, true); // create the empty array `result`

// To ensure both the `result` and receiver are reachable,
//    push the `result` array on the stack:
++g->sp;                      // advance the stack pointer
SetObject(g->sp, result);     // set the `result`

// further allocations which make use of the receiver to populate `result`
(...)

--g->sp;                      // pop the stack pointer back to the receiver slot
SetObject(receiver, result);  // set the `result` to the receiver slot
::
teletype::prArrayMultiChanExpand:: in emphasis::lang/LangPrimSource/PyrListPrim.cpp:: gives an example of this approach. Setting teletype::runGC:: to teletype::false:: is another possible solution.

Similarly, care must be taken when writing utility functions which themselves create new objects, since this may happen somewhat opaquely and the calling context may not be known. Functions which may call themselves recursively also need special attention. In such cases setting teletype::runGC:: to teletype::false:: may be the safest option, or including a teletype::runGC:: arg so that GC behaviour is explicit. teletype::MsgToInt8Array:: is one example of such a function.

teletype::
static PyrInt8Array* MsgToInt8Array ( sc_msg_iter& msg, bool runGC )
{
	int size = msg.getbsize() ;
	VMGlobals *g = gMainVMGlobals ;
	PyrInt8Array *obj = newPyrInt8Array ( g->gc , size , 0 , runGC ) ;
	obj->size = size ;
	msg.getb ( (char *)obj->b , obj->size ) ;
	return obj ;
}
::

Setting an object into another object's internal slot (e.g. with teletype::SetObject:: or teletype::slotCopy::) also requires care. If the parent object is emphasis::black:: (reachable and examined), the GC needs to be notified of the change. For this reason, you must usually call teletype::g->gc->GCWrite(parentObject, childObject):: after using one of these methods. The emphasis::only:: exceptions to this rule are cases in which the parent object is known to be white (unexamined). This will be true if:
list::
##It is the last created object, or
##Any subsequently created objects were allocated with teletype::runGC = false:: (i.e. the GC cannot have run in the interim), emphasis::and::
##It has not had teletype::GCWrite:: called upon it
::

The following two examples are both safe:
definitionlist::
##Run teletype::GCWrite:: as parent may not be white:
||teletype::
PyrSlot *arg = g->sp;
PyrObject *array = newPyrArray(g->gc, 2, 0, true); // runGC = true
SetObject(arg, array); // make the array reachable on the stack
PyrObject *str = newPyrString(g->gc, "Hello", 0, true); // runGC = true
SetObject(array->slots, str);
// we must call GCWrite, since array may not be white
g->gc->GCWrite(array, str);
...
::
##We know that parent emphasis::is:: white:
||teletype::
PyrObject *array = newPyrArray(g->gc, 2, 0, true); // runGC = true
PyrObject *str = newPyrString(g->gc, "Hello", 0, false); // runGC = false
SetObject(array->slots, str);
// we don't need GCWrite, since array must still be white
...
::
::

If you emphasis::know:: that the child object is still white, then you can use teletype::GCWriteNew:: instead of teletype::GCWrite::. The child object will still be white if the GC has not been triggered since it was created, and you have not previously called teletype::GCWrite:: on it.

If placing an object inside another has modified its size (e.g. adding an object to an array), you must correctly adjust its size by teletype::parent->size = newSize::. Both this and calling teletype::GCWrite:: (if necessary) should be done before any further object allocations. It is best practice to do them immediately if possible.

definitionlist::
##This is safe:
||teletype::
PyrSlot *arg = g->sp;
int size = 10;
PyrObject *array = newPyrArray(g->gc, size, 0, true); // runGC = true
SetObject(arg, array);
for(i=0; i<numLists; ++i) {
  PyrObject *str = newPyrString(g->gc, "Hello", 0, true); // runGC = true
  SetObject(array->slots + i, str);
  // str must still be white so we can use GCWriteNew
  g->gc->GCWriteNew(array, str);
  // increment size immediately
  //so it is accurate on next allocation
  array->size++;
}
...
::
##This is emphasis::not:: safe:
||teletype::
PyrSlot *arg = g->sp;
int size = 10;
PyrObject *array = newPyrArray(g->gc, size, 0, true); // runGC = true
// setting size to final value here means
// it is *not* accurate on next allocation below
array->size = size;
SetObject(arg, array);
for(i=0; i<numLists; ++i) {
  PyrObject *str = newPyrString(g->gc, "Hello", 0, true); // runGC = true
  SetObject(array->slots + i, str);
  g->gc->GCWriteNew(array, str);
}
...
::
::

It is good practice to avoid creating objects in a primitive at all where possible. Primitives are much simpler to write and debug if you pass in an object that you create in SC code and fill in its slots in the primitive.

note::
To summarize, before calling any function that might allocate (like teletype::newPyr*::) you strong::must:: make sure these criteria are fulfilled:
numberedlist::
## All objects previously created must be reachable, which means they must exist
    list::
    ## on the teletype::g->sp:: stack (taking care not to overwrite any objects which will be needed later)
    ## or, in a lang-side variable or class variable.
    ## or, in a slot of another object that fulfils these criteria.
    ::
## If any object ( teletype::child:: ) was put inside a slot of another object ( teletype::parent:: ), you must have
    list::
    ## called teletype::g->gc->GCWrite(parent, child):: afterwards unless you strong::know:: that the parent is still white (unexamined), or teletype::GCWriteNew:: if you also strong::know:: that the child is white
    ## and, set teletype::parent->size:: to the correct value
    ::
::
::

Here's an example of how a complete primitive might look:
teletype::
int prMyPrimitive(struct VMGlobals* g, int numArgsPushed)
{
    PyrSlot *arg = g->sp;
    float number;
    int err;

    err = slotFloatVal(arg, &number); // get one float argument
    if(err) return err;

    PyrObject *array = newPyrArray(g->gc, 2, 0, true);
    // array->size = 0 at creation; max size is 2
    SetObject(arg, array); // return value

    // NOTE: array is now reachable on the stack, since arg refers to g->sp

    PyrObject *str1 = newPyrString(g->gc, "Hello", 0, true);
    SetObject(array->slots, str1);
    array->size++; // immediately increment array's size
    // array may not be white, so call GCWrite
    // but we know str is white, so can use GCWriteNew instead
    g->gc->GCWriteNew(array, str1);

    // NOTE: str1 is now reachable in array, which is reachable on the stack

    SetFloat(array->slots+1, number);
    array->size++;
    // A float is not an allocated object, so no need for anything special here

    return errNone;
}
::
If we would have put teletype::SetObject(arg, array);:: at the end of this function, teletype::array:: would strong::not:: have been reachable at the call to teletype::newPyrString::, and thus may have been marked teletype::free::, resulting in a hard to track down bug.

warning::Do not store pointers to teletype::PyrObject::s in C/C++ variables unless you can absolutely guarantee that they cannot be garbage collected.
For example the code::File:: and code::SCWindow:: classes do this by storing the objects in an array in a code::classvar::. The object has to stay in that array until no C object refers to it.
strong::Failing to observe the above two points can result in very hard to find bugs.::
::

subsection:: Type safety
Since SC is dynamically typed, you cannot rely on any of the arguments being of the class you expect. You should check every argument to make sure it is the correct type.

One way to do this is by using teletype::isKindOfSlot::. If you just want a numeric value, you can use teletype::slotIntVal::, teletype::slotFloatVal::, or teletype::slotDoubleVal:: which will return an error if the value is not a numeric type. Similarly there is teletype::slotStringVal::.

It is safe to assume that the receiver will be of the correct type because this is ensured by the method dispatch mechanism.

section:: FAQ

definitionList::
## Now where do I put the thing to return it?
|| Store your return value at teletype::g->sp - inNumArgsPushed + 1 ::. (In most primitives this is referred to by the variable teletype::a::.)
::


title:: Writing tests
summary:: Get started with writing unit tests
categories:: Testing
related:: Reference/SCDocSyntax, Classes/SCDoc


To write, use and develop UnitTests, you need to 

list::
## install a sourcecode version of SuperCollider
## change your environment to include only core library functionality
## run UnitTests
::

section:: install a sourcecode version of SuperCollider

Download or clone SuperCollider from github: https://github.com/supercollider/supercollider.
It is not needed to compile SuperCollider from its sources, you can instead use a pre-compiled binary and include the relevant folders (code::SCClassLibrary, HelpSource, testsuite/classlibrary:: in your environment. See below for an example.

section:: Change your environment to include only core library functionality

In order to mimick the standard SuperCollider installation, make sure that you have only the class library installed. 

Best practise is to create a separate code::.yaml:: configuration file that resides parallel to the default one. You can do this either interactively from within the preferences of your IDE (code::Preferences>Interpreter::), or programatically

code::
~sclangConf = "SCLANG_CONF".getenv;
LanguageConfig.addIncludePath(~scSourceDir +/+ "testsuite/classlibrary");
+   LanguageConfig.addExcludePath(~scSourceDir +/+ "testsuite/classlibrary/server");
+   LanguageConfig.addExcludePath(Quarks.folder +/+ "UnitTesting/tests");
+   postf("Writing configuration to %\n", ~sclangConf);
+   LanguageConfig.store(~sclangConf);
:: 


section:: Organisation

Core class code::UnitTest::s are located in the directory
1.  UnitTests go into parrallel directory
2.  server-related tests go into `server` subdir
3.  UnitTests should use assert and assertFloat
4.  look at existing UnitTests to understand what are good UnitTests
5.  UnitTest setup
8.  run UnitTests either automatically (UnitTest.runAll), interactively (UnitTEst.gui), or individually by class (MyClass.test / TestMyClass.run << synonyms)


section:: Writing new tests
The simplest way is to look at an existing help file or class document, and read this document and link::Reference/SCDocSyntax::


title:: Writing Unit Generators
summary:: Get started with writing unit generators
categories:: Internals
related:: Reference/ServerPluginAPI

SuperCollider has a vast library of unit generators that can be assembled in unlimited ways, but sometimes even those
aren't sufficient. You may have a need for an unusual signal processing algorithm, or you're running into efficiency
problems that can be solved by condensing parts of your SynthDef into a single UGen.

UGens are defined in server plugins written in C++. Server plugins are not to be confused with quarks, which extend the
SuperCollider language. UGens exist more or less independently of the interpreter and you don't need much familiarity
with SC to write them.

Writing UGens is not too difficult, but it's arguably far less convenient and intuitive than the high-level tools that
SuperCollider provides. You'll need a build system and a good amount of boilerplate code -- even fairly basic signal
processing operations can require a lot of code. You don't have an instant live coding environment, and mistakes can
easily crash the server. SuperCollider's UGens are stable and well-tested, and custom UGens are best viewed as a last
resort for when the limitations of SC are impassable.

section:: Pseudo-UGens

Before we proceed to the real UGens, we'll take a quick detour for the sake of completeness. A pseudo-UGen is a bit of
SuperCollider code that abbreviates a certain configuration of UGens that gets used repeatedly. A pseudo-UGen is a class
that superficially resembles a UGen class, but it only returns a composition of existing UGens. It has no efficiency
savings, but it does save typing.

The below example has only a code::.ar:: method, but you can just as easily have both code::.ar:: and code::.kr::
methods.

code::
BoringMixer {
    *ar { arg left, right;
        ^(left + right) * 0.5;
    }
}
::

Examples of pseudo-UGens found in SC include link::Classes/BLowPass4:: and link::Classes/BHiPass4::, which break down
into link::Classes/SOS:: UGens.

There are very few restrictions on what these classes can contain, but you should keep the following in mind:

list::
## It is courteous to leave a note in your class's help file that identifies it as a pseudo-UGen.
## To avoid confusion, pseudo-UGens should not inherit from the base class link::Classes/UGen::.
## A SynthDef can only have two link::Classes/LocalIn::/link::Classes/LocalOut:: pairings — one for control rate and one
for audio rate. Putting LocalIn and LocalOut in a pseudo-UGen is a bad idea, as it could interfere with other feedback
loops in the SynthDef.
::

section:: Basics of UGens

A (real) UGen needs two components: a plugin for the server, and a class for the language. The class goes in an ordinary
code::*.sc:: file, and defines the interface for your UGen in the language. This class is generally just a few lines of
code that ultimately call the class method link::Classes/UGen#-multiNew::.

The server plugin is where the actual UGen behavior is defined. It is given by a dynamically loaded library written in
C++, whose format is platform-dependent:

list::
## code::*.so:: for *nix
## code::*.dll:: for Windows
## code::*.scx:: for macOS
::

A plugin file can contain more than one UGen, and it can also define things other than UGens such as buffer fill
("/b_gen") commands.

When the server boots, it will look for plugin files in code::Platform.userExtensionDir::. Since sclang also looks for
class files in the same location, the class file and the library file can go in the same place.

Plug-ins are loaded during the startup of the server, so it will have to be restarted after (re-)compiling a
plugin. If you modify the plugin file but not the class file, you don't need to reboot the interpreter.

section:: FAUST

FAUST footnote::http://faust.grame.fr/:: is an open source DSP language that describes real-time audio units. It can
compile to SuperCollider plugins, providing an easy way to create UGens in SuperCollider.

FAUST provides a shell script useful for SuperCollider users called code::faust2supercollider::. This compiles a .dsp
file into a class file and server plugin, which you can then drop into your extensions directory.

FAUST plugins are often quick to develop and can be painlessly ported to other environments. Unfortunately, they can't
take advantage of all of the server's features, such as accessing Buffers or random number generators, and some UGens
featuring very complex logic are difficult or impossible to write in FAUST. Furthermore, the FAUST compiler is quite
intelligent but it might not always offer the best efficiency in its results. If a UGen you are developing hits these
limitations, it is time to move on to handwritten C++.

section:: Example Plugins

To get an idea of the necessary ingredients for writing UGens, it's often best to poke around at complete examples.
We've set up a GitHub repository at https://github.com/supercollider/example-plugins, which contains some example
plugins numbered roughly by complexity. Each directory in that repository is self-contained with its own build system,
so you can copy out a directory to form a starting point for your own UGens. The source codes of these plugins are
heavily commented.

The first example, BoringMixer, is very minimal. The UGen is stateless and has only one calculation function, which is
audio rate.

MySaw introduces states and multiple calculation functions. AnalogEcho introduces real-time memory management through
internal buffers, and demonstrates how to do cubic interpolation from an array of samples.

section:: Anatomy of a UGen

The SC source code has a header file, code::include/plugin_interface/SC_PlugIn.h::, that gives you your interface to the server
architecture as well as a bunch of helper functions. These are documented at link::Reference/ServerPluginAPI::.

subsection:: The Entry Point

When the library is loaded the server calls a function in the library, which is defined by the code::PluginLoad()::
macro.  This entry point has two responsibilities:

list::
## It needs to store the passed in pointer to the InterfaceTable in a global variable.
## It registers the unit generators.
::

Unit Generators are defined by calling a function in the InterfaceTable and passing it the name of the unit generator,
the size of its C data struct, and pointers to functions for constructing and destructing it. There are 4 macros, which
can be used to simplify the process.

definitionList::
## DefineSimpleUnit || Define a `simple' unit generator
## DefineDtorUnit || Define a unit generator with a destructor
## DefineSimpleCantAliasUnit || Define a `simple' unit generator, whose input and output buffers cannot alias
## DefineDtorCantAliasUnit || Define a unit generator with a destructor, whose input and output buffers cannot alias
::

These macros depend on a specific naming convention:
list::
## The unit generator struct is named like the plug-in.
## The unit generator constructor is named code::PluginName_Ctor::
## The unit generator destructor is named code::PluginName_Dtor::
::

subsection:: The Calculation Function

The meat of the UGen is its calculation function, which gets called every control period with the UGen object as an
argument. (This is for control-rate and audio-rate UGens -- demand-rate is different.) In this function, the UGen reads
from its inputs and writes to its outputs.

The calculation function is selected in the code::PluginName_Ctor:: function with the code::SETCALC:: macro. You can
name the calculation function whatever you want, but the convention is code::PluginName_next::.

UGens often have multiple calculation functions, depending on the rate of the UGen itself and the rate of its inputs.
For example, Phasor can be .ar or .kr, and its argument can be either .ar or .kr. So it has four calculation functions:
Phasor_next_aa, Phasor_next_ak, Phasor_next_ka, and Phasor_next_kk. You don't need to be this thorough for your own
UGens, however. For example, link::Classes/FreeVerb:: has only one calculation function. Who would want a control-rate
reverb?

subsection:: Building Unit Generator Plugins

The most portable way to build plugins is using cmake footnote::http://www.cmake.org::, a cross-platform build
system.

The examples in the example repository contain code::CMakeLists.txt:: files.

section:: Coding Guidelines

Unit generator plugins are called from the real-time context, which means that special care needs to be taken in order
to avoid audio dropouts.

definitionList::
## STL Containers || It is generally not recommended to use STL containers, since they internally allocate memory. The only
                     way the STL containers can be used is by providing an Allocator, which maps to the allocating functions of
                     the server.
## Blocking API Calls || Unit generators should not call any code, which could block the execution of the current thread. In
                         particular, system calls should be avoided. If synchronization with other threads is required, this has to be
                         done in a lock-free manner.
::

subsection:: Memory Allocation
Do not allocate memory from the OS via code::malloc:: / code::free:: or code::new::/ code::delete::. Instead you should use the real-time memory allocator via code::RTAlloc:: / code::RTFree::.

definitionList::
## Remember to code::RTFree:: the memory you code::RTAlloc:: ||

Like with code::malloc/free::, you are reponsible for freeing all the memory you allocate. Remember to include code::RTFree:: calls in your destructor functions.

## Ensure your pointers are initialized to code::nullptr:: ||

Not initialized pointers can have a garbage address, and when RTFree tries to free such a pointer, it can crash the server.
To prevent this, ensure your member pointers are initialized to code::nullptr:: as early as possible in your constructor functions.

## Use code::ClearUnitIfMemFailed:: ||
This macro is used to check your pointers after memory allocation. If any of them is still code::nullptr::, it means that RTAlloc failed to allocate memory for it.
The macro will then print an error message, set the UGen's calculation function to a no-op, and return from the calling function immediately.
Since this can cause early exit from your constructor function, it is fundamental that all pointers are initialized to code::nullptr:: as early as possible, as stated above.

code::ClearUnitIfMemFailed:: can be passed a single pointer, or it can check multiple pointers at the same time, by chaining them with the code::&&:: operator (see examples below).

## For PV and FFT UGens ||
UGens in FFT chains (such as the ones listed in LINK::Guides/FFT-Overview#PV and FFT UGens in the Standard Library::) should use code::ClearFFTUnitIfMemFailed:: instead. This is because, on a failed allocation, code::ClearUnitIfMemFailed:: would make them output code::0::, which would be interpreted by the next UGen in the FFT chain as "FFT data is ready to be processed on buffer number 0", which is not the case. code::ClearFFTUnitIfMemFailed:: will set their output to code::-1:: instead, meaning that FFT data is not ready, and thus blocking further processing for the rest of the FFT chain. For more informations please see LINK::Guides/FFT-Overview#How FFT UGens communicate::.

code::ClearFFTUnitIfMemFailed:: is defined in code::FFT_UGens.h::
::

Minimal example, C style:
code::
struct MyUnit : public Unit {
  float* m_values;
  float* m_moreValues;
}
void MyUnit_Ctor(MyUnit* unit) {
  // 1. Ensure pointers are initialized to nullptr
  unit->m_values = unit->m_moreValues = nullptr;
  // 2. Allocate memory
  unit->m_values = (float*) RTAlloc(unit->mWorld, 64 * sizeof(float));
  unit->m_moreValues = (float*) RTAlloc(unit->mWorld, 128 * sizeof(float));
  // 3. Clear unit if any allocation failed
  ClearUnitIfMemFailed(unit->m_values && unit->m_moreValues);
  // 4. Feel free to access memory now
  memset(unit->m_values, 0, 64 * sizeof(float));
}

void MyUnit_Dtor(MyUnit* unit) {
  // 5. Free your allocated memory
  RTFree(unit->mWorld, unit->m_values);
  RTFree(unit->mWorld, unit->m_moreValues);
}
::
Or, in C++ class style:
code::
namespace MyUnit {
  // 1. Use initializer list to ensure pointers are initialized to nullptr
  MyUnit::MyUnit():
    mValues(nullptr),
    mMoreValues(nullptr) {
    // you'll need to define unit in order to use ClearUnitIfMemFailed
    Unit* unit = (Unit*) this;
    // 2. Allocate memory
    mValues = (float*) RTAlloc(unit->mWorld, 64 * sizeof(float));
    mMoreValues = (float*) RTAlloc(unit->mWorld, 128 * sizeof(float));
    // 3. Clear unit if any allocation failed
    ClearUnitIfMemFailed(mValues && mMoreValues);
    // 4. Feel free to access memory now
    memset(mValues, 0, 64 * sizeof(float));
  }

  MyUnit::~MyUnit() {
    // 5. Free your allocated memory
    RTFree(mWorld, mValues);
    RTFree(mWorld, mMoreValues);
  }
}
::

subsection:: Thread Safety

There are two different implementations of the SuperCollider server. strong::scsynth:: is the traditional server and
strong::supernova:: is a new implementation with support for multi-processor audio synthesis. Since the plugins in
strong::supernova:: can be called at the same time from multiple threads, write access to global data structures needs
to be synchronized.

definitionList::
## Shared Global Data Structures || Unit generators should not share data structures, which are written to. While it it safe to use
    global data structures for read-only purposes (e.g. different unit generators could use the same constant wavetable),
    the data structures that are modified by the unit generators should not be shared among different instances.

## Resource Locking || SuperCollider's buffers and busses are global data structures, and access needs to be synchronized.
    This is done internally by using reader-writer spinlocks. This is done by using the code::ACQUIRE_::, code::RELEASE_::, and
    code::LOCK_:: macros, which are defined in SC_Unit.h. As exception, buffers in the wavetable format are not required to be
    locked.
::

subsection:: Deadlock Prevention

In order to prevent deadlocks, a simple deadlock prevention scheme is implemented, based on the following constraints.

list::
## Lock resources only when required: few unit generators actually require the access to more than one resource at the same time.
   The main exception of this rule are the FFT Chain UGens, which access multiple buffers at the same time. There is no known unit
   generator, which accesses both buffers and busses at the same time.
## Acquire reader locks if possible. Since multiple UGens can acquire a reader lock to the same resource at the same time, their
   use reduces contention.
## Resources have to be acquired in a well-defined order: busses should be acquired before buffers and resources with a high index
   should be acquired before resources with a low index.
::


TITLE:: Making Standalone Applications
SUMMARY:: A guide to making SuperCollider-based applications by 'exporting' existing SuperCollider app configurations and projects.
CATEGORIES:: Platform>macOS, Tutorials
KEYWORD:: standalones, stand-alones

NOTE:: The concept of standalone applications is mainly relevant on macOS. On linux, Miguel Negrão and Fredrik Olofsson have created similar ways of packing versions of SC3 into independent setups. ::

section:: Introduction

SuperCollider 3.6 and earlier versions supported macOS Cocoa interfaces, and a special XCode project that allowed very flexible interface design, including removing and adding Menus. Since 3.7, SuperCollider uses Qt only, and the (now obsolete) standalone XCode project has been removed for 3.9. While the current Qt implementation is less flexible ATM, useful standalone applications can still be created with it using the scripts provided here (or similar ones).

One can package performance setups, installation pieces, software synthesis instruments, complex sound generators and other projects, into fully independent copies of the  SuperCollider.app including the IDE, and the Help system if desired. Custom interfaces can make such apps easily accessible to audiences that need not know how to install SuperCollider, run SuperCollider code, or even know that SuperCollider is involved.
This is useful for distributing applications to the general public, or for creating special-purpose applications for your own use. There is one important restriction: the entire application must be open-source and comply with the GNU General Public License.

On macOS, applications are special directories with an ".app" extension, known as emphasis::bundles::. SuperCollider emphasis::standalone applications:: are bundles that contain your SuperCollider code, as well as a renamed copy of SuperCollider itself that  runs your code.

section:: Practical Guide

(written by Alberto de Campo, 2017)

This Guide is for exporting copies of an existing SC3 setup,
for at least two scenarios:

LIST::
## Freezing an SC-based setup for non-expert users,
say an installation for a piece that runs in a museum,
which is as easily movable and selfcontained as possible.

## Copying a setup for a piece or performance setup,as backup
or safety copy, keeping much flexibility for skilled users.
::

Creating more complex user-oriented applications with SC was possible in versions pre 3.6, and a number of people work on additions to SC that will allow similar flexibility again.

Note::
Known working versions for making standalones:
strong::SC3.8.0, SC3.9dev from branch [2a105f1]::
code::
"https://supercollider.github.io/download".openOS;
::
Self-built SC versions may assume their code:: Platform.userAppSupportDir :: is called code::.../SuperCollider/ :: and not the name of the newly made app.
::

subsection:: How this guide works

This guide is a set of scripts for creating a SuperCollider-based Standalone app in a few basic steps:

numberedlist::
## copy the open SuperCollider.app or SC3-derived standalone.

## fix the copy's info files so it uses its own userAppSupportDir

## test that Platform.userAppSupportDir is independent in the new app!

... Then the adaptation to the specific project begins: ...

## transfer active quarks and extensions to the new app

## copy the project folder used to the new app

## make an internal startupFile for it

## test and adapt until it does what you want
::

subsection:: What to prepare

list::
## have your system ready with all desired quarks installed,
and a working startup file. (can be a very simple test setup)

## read each section, then try evaluating it at once;
 in case of problems, evaluate line by line,
 and tell me where which problems happen

## when you get to the wakeup kiss, share and enjoy!
::

subsection:: Naming, copying, and fixing up the new app

code::
// TO PREPARE, CHECK YOUR CURRENT config in Preferences->Interpreter:
// you should be using the internal SCClassLibrary and HelpSource,
// not an external git repository!
// To test exporting extensions, it is best to have some quarks
// or other extensions installed, as seen in the includePaths.

// 0 - define name and location of new app + helper functions
(
// define the name for the new app and its location:
~newAppName = "StehAllein";
~newAppLocation = "~/Desktop".standardizePath;

// --- nothing to be changed below this line --- \\
// some helper functions
~readText = { |path| File.readAllString(path); };
~writeText = { |path, string| File(path, "w").write(string).close; };
~copyFolder = { |orig, dest|
	var str = "cp -ir" + quote(orig) + quote(dest);
	str.postcs;
	unixCmd(str);
};

// make some needed paths and folders
~pathToThisApp = Platform.resourceDir.dirname.dirname;
~thisAppName = ~pathToThisApp.basename.splitext.first;
~pathToNewApp = ~newAppLocation +/+ ~newAppName ++ ".app";
~newAppResDir = ~pathToNewApp +/+ "Contents/Resources";
~newAppSupportDir = Platform.userConfigDir.dirname +/+ ~newAppName;
);


(
// 1. make a copy of thisApp with the newAppName:
// can take a while on slow harddisks.
// wait for RESULT = 0 to show!

if (File.exists(~pathToNewApp).not) {
	~copyFolder.(~pathToThisApp, ~pathToNewApp);
	File.mkdir(~newAppSupportDir);
} { warn("supportDir % already exists.".format(~pathToNewApp)) };
);

(
// 2. fixups in the new app:
// a. fix the Info.plist file by replacing the name:
~infoPlistPath = ~pathToNewApp +/+ "Contents/Info.plist";
// get its string, replace the SC names, write again
~infoString = ~readText.(~infoPlistPath);
~executableIndex = ~infoString.find("<key>CFBundleExecutable</key>");
~nameToReplace = ~infoString.copyRange(
	~infoString.find("<string>", offset: ~executableIndex) + 8,
	~infoString.find("</string>", offset: ~executableIndex) - 1
);

"replacing bundleName % in plist file at these locations: "
.postf(~nameToReplace.cs);
~foundNameLocs = ~infoString.findAll(~nameToReplace).postln;

~newInfoString = ~infoString.replace(~nameToReplace, ~newAppName );
~writeText.(~infoPlistPath, ~newInfoString);
// ~readText.(~infoPlistPath);

// b. rename the binary file:
"renaming macos binary to: ".post;
// fixups in the new app - 2. rename the binary inside the app folder
unixCmd("mv -i"
	+ quote(~pathToNewApp +/+ "Contents/MacOS/" +/+ ~nameToReplace)
	+ quote(~pathToNewApp +/+ "Contents/MacOS/" ++ ~newAppName).postln
);
);


// 3. *** time for the first wakeup kiss *** //
unixCmd("open" + ~pathToNewApp);

// ... and independence test:
// IN THE NEW APP, run this code:
Platform.userAppSupportDir.postcs;
::

NOTE:: THIS SHOULD END WITH ~newAppName! If it has the original ~thisAppName (the one you started from, e.g. ~/././SuperCollider), the new app will not be interfere with SuperCollider!
So, delete the app again, and start over using a recommended version of SC3 (see tested list on top)!

::

subsection:: Adaptation to the project

Quit the new standalone and go back to the starting app to do:
list::

##4. overwrite .startupFiles to look inside the app folder

##5. make a demo project folder and loadfile for the new app

##6.create a startup file that loads the project loadfile

##7. transfer active quarks and extensions to the new app

##8. replace/fill the project folder with your files, scripts etc
::

code::
(
// 4. write a class extension file to look for the startupFile
// in the app, in Platform.resourceDir for self-containment.
~overDir = ~newAppResDir +/+ "SCClassLibrary/SystemOverwrites";
File.mkdir(~overDir);
~writeText.value(~overDir +/+ "extModStartupFile.sc",
	"+ OSXPlatform {
	startupFiles {
		^[Platform.resourceDir +/+ \"startup.scd\"];
	}
}
"
);
~overDir.openOS;
)

(
// 5. write a basic startupFile:
~startupCode =
"// basic example startup file for osx standalone.
// avoid clash with default SC server
s.addr.port = 57105;

// boots server and plays a little sound
s.waitForBoot {
	{
		Line.kr(1, 0, 10, doneAction: 2) * SinOsc.ar(1000)
		* EnvGen.ar(Env.perc(0.01, 0.25), Impulse.kr(2, [0, 0.5]), 0.1)

	}.play;
};
";
~writeText.(~newAppResDir +/+ "startup.scd", ~startupCode);
(~newAppResDir +/+ "startup.scd").openOS;
)

// *** time for a second wakeup kiss *** //
// should run the startup file and play a sound:
unixCmd("open" + ~pathToNewApp);


// 6. For larger projects:
//    make an example project folder with a loadfile in it,
//    and a startup file that points to the loadfile.
(
~projDirName = ~newAppName ++ "_files";
~projDir = ~newAppResDir +/+ ~projDirName;
File.mkdir(~projDir);
~projDir.openOS;

~loadFileCode =
"\"*** startup file for % loading.\".postln;
\"*** My Platform.userAppSupportDir is: \".postln;
Platform.userAppSupportDir.postcs;
thisProcess.nowExecutingPath.openOS;

// configure server options here if needed:
s.options.memSize = 8192 * 16;
// move server port away from default (57110)
// to avoid interference/clashes with SuperCollider itself:
s.addr.port = 57105;

s.waitForBoot {
	\"*** server booted, plays ping.\".postln;
	Env.perc.test;

	\"*** loading files next ? \".postln;
	// put your loading sequence here:
	// \"loadX.scd\".loadRelative;
	// s.sync; // e.g. when loading buffers
 	// 1.wait;
 	// \"loadY.scd\".loadRelative;
};"
.format(~newAppName);

~loadfilepath = ~projDir +/+ "00_loadMe.scd";
~writeText.value(~loadfilepath, ~loadFileCode);
~loadfilepath.openOS;


// write a startupFile that points to the load file:
~startupCode =
"// example startup file for osx standalone.
// running loadfile in this project folder:
%.loadRelative;
".format((~projDirName +/+ ~loadfilepath.basename).cs);

~writeText.(~newAppResDir +/+ "startup.scd", ~startupCode);
(~newAppResDir +/+ "startup.scd").openOS;
)

// *** time for the third wakeup kiss *** //
unixCmd("open" + ~pathToNewApp);

// this should open the new app, and its loadfile!


// 7. create an internal extensions folder inside the new app,
// and copy all the currently active includePaths there:
(
~newAppQuarksDir = ~newAppResDir +/+ "InternalExtensions";

// copy all folders in my current quarks includePaths
// to Resources/SCClassLibrary to freeze them:
File.mkdir(~newAppQuarksDir);

~pathsToCopy = LanguageConfig.includePaths.reject { |path|
	["SCClassLibrary", "HelpSource"].includesEqual(path.basename)
};

~pathsToCopy.collect(_.basename).sort.printcsAll;

if (~newAppQuarksDir.pathMatch.notEmpty) {
	"/*** copying Quarks : ***/".postln;
	~pathsToCopy.do { |path|
		unixCmd(
			"cd" + quote(~newAppQuarksDir) ++ ";" ++
			" cp -ir" + quote(path).postln + ".");
	};
};
"";
)
// and now the new app folder contains all quarks:
~newAppQuarksDir.openOS;

// open the new app:
unixCmd("open" + ~pathToNewApp);

// AND IN THE NEW APP, run this to create a self-contained startup config file:
(
// use the internal extensions - repeat this when you move the app!
LanguageConfig.addIncludePath(Platform.resourceDir +/+ "InternalExtensions");
// exclude the default
LanguageConfig.addExcludePath(Platform.userExtensionDir);
LanguageConfig.addExcludePath(Platform.systemExtensionDir);
LanguageConfig.store;

// see if the internal path was stored OK:
LanguageConfig.includePaths.last;
// this should not be empty:
LanguageConfig.includePaths.last.pathMatch.postln;
)

// STILL IN THE NEW APP, REBOOT THE INTERPRETER NOW!
// - the added quarks should now be present.
::

Note:: You can use the Standalone quark to make sure your app remains closed, keeps using its to its InternalExtensions dir, and continues to ignore anything in its userExtensionDir or systemExtensionDir.
::
code::
// IN THE NEW APP, DO:
Quarks.install("https://github.com/adcxyz/Standalone");
// reboot interpreter, then do
Standalone.activate;
// reboot interpreter again, and done.


// 8. Now, put your project files in the project folder,
// adapt the loading sequence,
// and test until everything works to perfection...

// Share and Enjoy your special standalone app!
::


